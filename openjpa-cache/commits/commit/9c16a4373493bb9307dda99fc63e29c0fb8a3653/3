{"sha":"9c16a4373493bb9307dda99fc63e29c0fb8a3653","node_id":"MDY6Q29tbWl0MjA2MzY0OjljMTZhNDM3MzQ5M2JiOTMwN2RkYTk5ZmM2M2UyOWMwZmI4YTM2NTM=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-12T14:11:46Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-12T14:11:46Z"},"message":"Creating 1.2.1 tag\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/tags/1.2.1@752874 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"f50e9a665eb242e4b05e0364c41f777a18914e9f","url":"https://api.github.com/repos/apache/openjpa/git/trees/f50e9a665eb242e4b05e0364c41f777a18914e9f"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/9c16a4373493bb9307dda99fc63e29c0fb8a3653","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/9c16a4373493bb9307dda99fc63e29c0fb8a3653","html_url":"https://github.com/apache/openjpa/commit/9c16a4373493bb9307dda99fc63e29c0fb8a3653","comments_url":"https://api.github.com/repos/apache/openjpa/commits/9c16a4373493bb9307dda99fc63e29c0fb8a3653/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"f153a4ea37a2ea16247fd773756fa5da27f075ff","url":"https://api.github.com/repos/apache/openjpa/commits/f153a4ea37a2ea16247fd773756fa5da27f075ff","html_url":"https://github.com/apache/openjpa/commit/f153a4ea37a2ea16247fd773756fa5da27f075ff"}],"stats":{"total":447552,"additions":447552,"deletions":0},"files":[{"sha":"d78f9784589343b910fe0ecd5b36e35a4ca09e7f","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"added","additions":3259,"deletions":0,"changes":3259,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"1d8d9d500463cae1353ca19afb0f1576a72b1127","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","status":"added","additions":461,"deletions":0,"changes":461,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,461 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel;\n+\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.meta.ValueMetaData;\n+\n+/**\n+ * Represents a set of managed objects and their environment.\n+ *\n+ * @since 0.4.0\n+ * @author Abe White\n+ */\n+public interface StoreContext {\n+\n+    /**\n+     * Marker bitset to indicate that all field loads should be excluded in\n+     * the <code>find</code> methods of this interface.\n+     */\n+    public static final BitSet EXCLUDE_ALL = new BitSet(0);\n+\n+    public static final int OID_NOVALIDATE = 2 << 0;\n+    public static final int OID_NODELETED = 2 << 1;\n+    public static final int OID_COPY = 2 << 2;\n+    public static final int OID_ALLOW_NEW = 2 << 3;\n+\n+    /**\n+     * Return the broker for this context, if possible. Note that a broker\n+     * will be unavailable in remote contexts, and this method may return null.\n+     */\n+    public Broker getBroker();\n+\n+    /**\n+     * Return the configuration associated with this context.\n+     */\n+    public OpenJPAConfiguration getConfiguration();\n+\n+    /**\n+     * Return the (mutable) fetch configuration for loading objects from this\n+     * context.\n+     */\n+    public FetchConfiguration getFetchConfiguration();\n+\n+    /**\n+     * Pushes a new fetch configuration that inherits from the current\n+     * fetch configuration onto a stack, and makes the new configuration\n+     * the active one.\n+     *\n+     * @since 1.1.0\n+     * @return the new fetch configuration\n+     */\n+    public FetchConfiguration pushFetchConfiguration();\n+\n+    /**\n+     * Pops the fetch configuration from the top of the stack, making the\n+     * next one down the active one. This returns void to avoid confusion,\n+     * since fetch configurations tend to be used in method-chaining\n+     * patterns often.\n+     *\n+     * @since 1.1.0\n+     * @throws UserException if the fetch configuration stack is empty\n+     */\n+    public void popFetchConfiguration();\n+\n+    /**\n+     * Return the current thread's class loader at the time this context\n+     * was obtained.\n+     */\n+    public ClassLoader getClassLoader();\n+\n+    /**\n+     * Return the lock manager in use.\n+     */\n+    public LockManager getLockManager();\n+\n+    /**\n+     * Return the store manager in use. This will be a wrapper around the\n+     * native store manager, which you can retrieve via\n+     * {@link DelegatingStoreManager#getInnermostDelegate}.\n+     */\n+    public DelegatingStoreManager getStoreManager();\n+\n+    /**\n+     * Return the connection user name.\n+     */\n+    public String getConnectionUserName();\n+\n+    /**\n+     * Return the connection password.\n+     */\n+    public String getConnectionPassword();\n+\n+    /**\n+     * Return the cached instance for the given oid/object, or null if not\n+     * cached.\n+     *\n+     * @param oid the object's id\n+     * @return the cached object, or null if not cached\n+     */\n+    public Object findCached(Object oid, FindCallbacks call);\n+\n+    /**\n+     * Find the persistence object with the given oid. If\n+     * <code>validate</code> is true, the broker will check the store\n+     * for the object, and return null if it does not exist. If\n+     * <code>validate</code> is false, this method never returns null. The\n+     * broker will either return its cached instance, attempt to create a\n+     * hollow instance, or throw an <code>ObjectNotFoundException</code> if\n+     * unable to return a hollow instance.\n+     *\n+     * @param validate if true, validate that the instance exists in the\n+     * store and load fetch group fields, otherwise return\n+     * any cached or hollow instance\n+     */\n+    public Object find(Object oid, boolean validate, FindCallbacks call);\n+\n+    /**\n+     * Return the objects with the given oids.\n+     *\n+     * @param oids the oids of the objects to return\n+     * @return the objects that were looked up, in the same order as the oids\n+     * parameter\n+     * @see #find(Object,boolean,FindCallbacks)\n+     */\n+    public Object[] findAll(Collection oids, boolean validate,\n+        FindCallbacks call);\n+\n+    /**\n+     * Return the object with the given oid. If present, the\n+     * cached instance will be returned. Otherwise, the instance will be\n+     * initialized through the store as usual; however, in this case\n+     * the store will be passed the given execution data, and the\n+     * system will load the object according to the given fetch configuratiion\n+     * (or the context's configuration, if the given one is null).\n+     * Fields can optionally be excluded from required loading using the\n+     * <code>exclude</code> mask. By default this method does not find new\n+     * unflushed instances, validates, and does not throw an exception\n+     * if a cached instance has been deleted concurrently. These options\n+     * are controllable through the given <code>OID_XXX</code> flags.\n+     */\n+    public Object find(Object oid, FetchConfiguration fetch, BitSet exclude,\n+        Object edata, int flags);\n+\n+    /**\n+     * Return the objects with the given oids.\n+     *\n+     * @see #find(Object,FetchConfiguration,BitSet,Object,int)\n+     */\n+    public Object[] findAll(Collection oids, FetchConfiguration fetch,\n+        BitSet exclude, Object edata, int flags);\n+\n+    /**\n+     * Return an iterator over all instances of the given type. The iterator\n+     * should be closed with {@link org.apache.openjpa.util.ImplHelper#close} \n+     * when no longer needed. This method delegates to \n+     * {@link StoreManager#executeExtent}.\n+     */\n+    public Iterator extentIterator(Class cls, boolean subs,\n+        FetchConfiguration fetch, boolean ignoreChanges);\n+\n+    /**\n+     * Immediately load the given object's persistent fields. One might\n+     * use this action to make sure that an instance's fields are loaded\n+     * before transitioning it to transient. Note that this action is not\n+     * recursive. Any related objects that are loaded will not necessarily\n+     * have their fields loaded. Unmanaged target is ignored.\n+     *\n+     * @param fgOnly indicator as to whether to retrieve only fields\n+     * in the current fetch groups, or all fields\n+     * @see #retrieve\n+     */\n+    public void retrieve(Object pc, boolean fgOnly, OpCallbacks call);\n+\n+    /**\n+     * Retrieve the given objects' persistent state. Unmanaged targets are\n+     * ignored.\n+     *\n+     * @param fgOnly indicator as to whether to retrieve only fields\n+     * @see #retrieve\n+     */\n+    public void retrieveAll(Collection objs, boolean fgOnly, OpCallbacks call);\n+\n+    /**\n+     * Make the given instance embedded.\n+     *\n+     * @param obj the instance to embed; may be null to create a new instance\n+     * @param id the id to give the embedded state manager; may be\n+     * null for default\n+     * @param owner the owning state manager\n+     * @param ownerMeta the value in which the object is embedded\n+     * @return the state manager for the embedded instance\n+     */\n+    public OpenJPAStateManager embed(Object obj, Object id,\n+        OpenJPAStateManager owner, ValueMetaData ownerMeta);\n+\n+    /**\n+     * Return the application or datastore identity class the given persistent\n+     * class uses for object ids.\n+     */\n+    public Class getObjectIdType(Class cls);\n+\n+    /**\n+     * Create a new object id instance from the given value.\n+     *\n+     * @param cls the persitent class that uses this identity value\n+     * @param val an object id instance, stringified object id, or primary\n+     * key value\n+     */\n+    public Object newObjectId(Class cls, Object val);\n+\n+    /**\n+     * Return the set of classes that have been made persistent in the current\n+     * transaction.\n+     *\n+     * @since 0.3.4\n+     */\n+    public Collection getPersistedTypes();\n+\n+    /**\n+     * Return the set of classes that have been deleted in the current\n+     * transaction.\n+     *\n+     * @since 0.3.4\n+     */\n+    public Collection getDeletedTypes();\n+\n+    /**\n+     * Return the set of classes for objects that have been modified\n+     * in the current transaction.\n+     *\n+     * @since 0.3.4\n+     */\n+    public Collection getUpdatedTypes();\n+\n+    /**\n+     * Return a list of all managed instances.\n+     */\n+    public Collection getManagedObjects();\n+\n+    /**\n+     * Return a list of current transaction instances.\n+     */\n+    public Collection getTransactionalObjects();\n+\n+    /**\n+     * Return a list of instances which will become transactional upon\n+     * the next transaction.\n+     */\n+    public Collection getPendingTransactionalObjects();\n+\n+    /**\n+     * Return a list of current dirty instances.\n+     */\n+    public Collection getDirtyObjects();\n+\n+    /**\n+     * Whether to maintain the order in which objects are dirtied for\n+     * {@link #getDirtyObjects}. Default is the store manager's decision.\n+     */\n+    public boolean getOrderDirtyObjects();\n+\n+    /**\n+     * Whether to maintain the order in which objects are dirtied for\n+     * {@link #getDirtyObjects}. Default is the store manager's decision.\n+     */\n+    public void setOrderDirtyObjects(boolean order);\n+\n+    /**\n+     * Return the state manager for the given instance. Includes objects\n+     * made persistent in the current transaction. If <code>obj</code> is not\n+     * a managed type or is managed by another context, throw an exception.\n+     */\n+    public OpenJPAStateManager getStateManager(Object obj);\n+\n+    /**\n+     * Return the lock level of the specified object.\n+     */\n+    public int getLockLevel(Object obj);\n+\n+    /**\n+     * Returns the current version indicator for <code>o</code>.\n+     */\n+    public Object getVersion(Object obj);\n+\n+    /**\n+     * Return whether the given object is dirty.\n+     */\n+    public boolean isDirty(Object obj);\n+\n+    /**\n+     * Return whether the given object is transactional.\n+     */\n+    public boolean isTransactional(Object obj);\n+\n+    /**\n+     * Make the given object transactional.\n+     *\n+     * @param pc instance to make transactional\n+     * @param updateVersion if true, the instance's version will be\n+     * incremented at the next flush\n+     */\n+    public void transactional(Object pc, boolean updateVersion,\n+        OpCallbacks call);\n+\n+    /**\n+     * Make the given objects transactional.\n+     *\n+     * @param objs instances to make transactional\n+     * @param updateVersion if true, the instance's version will be\n+     * incremented at the next flush\n+     */\n+    public void transactionalAll(Collection objs, boolean updateVersion,\n+        OpCallbacks call);\n+\n+    /**\n+     * Make the given object nontransactional.\n+     */\n+    public void nontransactional(Object pc, OpCallbacks call);\n+\n+    /**\n+     * Make the given objects nontransactional.\n+     */\n+    public void nontransactionalAll(Collection objs, OpCallbacks call);\n+\n+    /**\n+     * Return whether the given object is persistent.\n+     */\n+    public boolean isPersistent(Object obj);\n+\n+    /**\n+     * Return whether the given object is a newly-created instance registered\n+     * with <code>broker</code>.\n+     */\n+    public boolean isNew(Object obj);\n+\n+    /**\n+     * Return whether the given object is deleted.\n+     */\n+    public boolean isDeleted(Object obj);\n+\n+    /**\n+     * Return the oid of the given instance.\n+     */\n+    public Object getObjectId(Object obj);\n+\n+    /**\n+     * Detach mode constant to determine which fields are part of the\n+     * detached graph. Defaults to {@link DetachState#DETACH_LOADED}.\n+     */\n+    public int getDetachState();\n+\n+    /**\n+     * Detach mode constant to determine which fields are part of the\n+     * detached graph. Defaults to {@link DetachState#DETACH_LOADED}.\n+     */\n+    public void setDetachState(int mode);\n+\n+    /**\n+     * Whether objects accessed during this transaction will be added to the\n+     * store cache. Defaults to true.\n+     *\n+     * @since 0.3.4\n+     */\n+    public boolean getPopulateDataCache();\n+\n+    /**\n+     * Whether to populate the store cache with objects used by this\n+     * transaction. Defaults to true.\n+     *\n+     * @since 0.3.4\n+     */\n+    public void setPopulateDataCache(boolean cache);\n+\n+    /**\n+     * Whether memory usage is reduced during this transaction at the expense\n+     * of tracking changes at the type level instead of the instance level,\n+     * resulting in more aggressive cache invalidation.\n+     *\n+     * @since 1.0.0\n+     */\n+    public boolean isTrackChangesByType();\n+\n+    /**\n+     * If a large number of objects will be created, modified, or deleted\n+     * during this transaction setting this option to true will reduce memory\n+     * usage if you perform periodic flushes by tracking changes at the type\n+     * level instead of the instance level, resulting in more aggressive cache\n+     * invalidation. Upon transaction commit the data cache will have to\n+     * more aggressively flush objects. The store cache will have to flush\n+     * instances of objects for each class of object modified during the\n+     * transaction. A side benefit of large transaction mode is that smaller\n+     * update messages can be used for\n+     * {@link org.apache.openjpa.event.RemoteCommitEvent}s. Defaults to false.\n+     *\n+     * @since 1.0.0\n+     */\n+    public void setTrackChangesByType(boolean largeTransaction);\n+\n+    /**\n+     * Whether this context is using managed transactions.\n+     */\n+    public boolean isManaged();\n+\n+    /**\n+     * Whether a logical transaction is active.\n+     */\n+    public boolean isActive();\n+\n+    /**\n+     * Whether a data store transaction is active.\n+     */\n+    public boolean isStoreActive();\n+\n+    /**\n+     * Begin a data store transaction.\n+     */\n+    public void beginStore();\n+\n+    /**\n+     * Whether the broker has a dedicated connection based on the configured\n+     * connection retain mode and transaction status.\n+     */\n+    public boolean hasConnection();\n+\n+    /**\n+     * Return the connection in use by the context, or a new connection if none.\n+     */\n+    public Object getConnection();\n+\n+    /**\n+     * Synchronizes on an internal lock if the\n+     * <code>Multithreaded</code> flag is set to true. Make sure to call\n+\t * {@link #unlock} in a finally clause of the same method.\n+\t */\n+\tpublic void lock ();\n+\n+\t/**\n+\t * Releases the internal lock.\n+\t */\n+\tpublic void unlock ();\n+}"},{"sha":"16374e1a0bce7aad621ee395a379b04f4ea688cb","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","status":"added","additions":426,"deletions":0,"changes":426,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,426 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel;\n+\n+import java.util.BitSet;\n+import java.util.Collection;\n+\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.lib.util.Closeable;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.ValueStrategies;\n+\n+/**\n+ * Interface to be implemented by data store mechanisms to interact with\n+ * this runtime.\n+ *\n+ * @author Abe White\n+ */\n+public interface StoreManager\n+    extends Closeable {\n+\n+    public static final int VERSION_LATER = 1;\n+    public static final int VERSION_EARLIER = 2;\n+    public static final int VERSION_SAME = 3;\n+    public static final int VERSION_DIFFERENT = 4;\n+\n+    public static final int FORCE_LOAD_NONE = 0;\n+    public static final int FORCE_LOAD_DFG = 1;\n+    public static final int FORCE_LOAD_REFRESH = 3;\n+    public static final int FORCE_LOAD_ALL = 2;\n+\n+    /**\n+     * Set a reference to the corresponding context. This method\n+     * will be called before the store manager is used. The store manager\n+     * is responsible for pulling any necessary configuration data from the\n+     * context, including the transaction mode and connection retain mode.\n+     */\n+    public void setContext(StoreContext ctx);\n+\n+    /**\n+     * Notification that an optimistic transaction has started. This method\n+     * does not replace the {@link #begin} method, which will still be called\n+     * when a true data store transaction should begin.\n+     */\n+    public void beginOptimistic();\n+\n+    /**\n+     * Notification that an optimistic transaction was rolled back before\n+     * a data store transaction ever began.\n+     */\n+    public void rollbackOptimistic();\n+\n+    /**\n+     * Begin a data store transaction. After this method is called,\n+     * it is assumed that all further operations are operating in a single\n+     * transaction that can be committed or rolled back. If optimistic\n+     * transactions are in use, this method will only be called when the\n+     * system requires a transactionally consistent connection due to a\n+     * user request to flush or commit the transaction. In this case, it\n+     * is possible that the optimistic transaction does not have the latest\n+     * versions of all instances (i.e. another transaction has modified the\n+     * same instances and committed since the optimistic transaction started).\n+     * On commit, an exception must be thrown on any attempt to overwrite\n+     * data for an instance with an older version.\n+     *\n+     * @since 0.2.5\n+     */\n+    public void begin();\n+\n+    /**\n+     * Commit the current data store transaction.\n+     */\n+    public void commit();\n+\n+    /**\n+     * Rollback the current data store transaction.\n+     */\n+    public void rollback();\n+\n+    /**\n+     * Verify that the given instance exists in the data store; return false\n+     * if it does not.\n+     */\n+    public boolean exists(OpenJPAStateManager sm, Object edata);\n+\n+    /**\n+     * Update the version information in the given state manager to the\n+     * version stored in the data store.\n+     *\n+     * @param sm the instance to check\n+     * @param edata the current execution data, or null if not\n+     * given to the calling method of the context\n+     * @return true if the instance still exists in the\n+     * datastore and is up-to-date, false otherwise\n+     */\n+    public boolean syncVersion(OpenJPAStateManager sm, Object edata);\n+\n+    /**\n+     * Initialize the given state manager. The object id of the\n+     * state manager will be set, and the state manager's metadata be set to\n+     * the class of the instance to load, or possibly one of its superclasses.\n+     * Initialization involves first calling the\n+     * {@link OpenJPAStateManager#initialize} method with\n+     * a new instance of the correct type constructed with the\n+     * {@link org.apache.openjpa.enhance.PCRegistry#newInstance(Class,\n+     * org.apache.openjpa.enhance.StateManager, boolean)} method\n+     * (this will reset the state manager's metadata if the actual type was a\n+     * subclass). After instance initialization, load any the fields for the\n+     * given fetch configuration that can be efficiently retrieved. If any of\n+     * the configured fields are not loaded in this method, they will be\n+     * loaded with a subsequent call to {@link #load}. If this method is\n+     * called during a data store transaction, the instance's database record\n+     * should be locked. Version information can be loaded if desired through\n+     * the {@link OpenJPAStateManager#setVersion} method.\n+     *\n+     * @param sm the instance to initialize\n+     * @param state the lifecycle state to initialize the state manager with\n+     * @param fetch configuration for how to load the instance\n+     * @param edata the current execution data, or null if not\n+     * given to the calling method of the broker\n+     * @return true if the matching instance exists in the data\n+     * store, false otherwise\n+     */\n+    public boolean initialize(OpenJPAStateManager sm, PCState state,\n+        FetchConfiguration fetch, Object edata);\n+\n+    /**\n+     * Load the given state manager.\n+     * Note that any collection or map types loaded into the state manager\n+     * will be proxied with the correct type; therefore the store manager\n+     * does not have to load the same concrete collection/map types as the\n+     * instance declares. However, array types must be consistent with the\n+     * array type stored by the persistence capable instance. If this method\n+     * is called during a data store transaction, the instance should be\n+     * locked. If the given state manager does not have its version set\n+     * already, version information can be loaded if desired through the\n+     * {@link OpenJPAStateManager#setVersion} method.\n+     *\n+     * @param sm the instance to load\n+     * @param fields set of fields to load; all field indexes in this\n+     * set must be loaded; this set is mutable\n+     * @param fetch the fetch configuration to use when loading\n+     * related objects\n+     * @param lockLevel attempt to load simple fields at this lock level;\n+     * relations should be loaded at the read lock level\n+     * of the fetch configuration\n+     * @param edata the current execution data, or null if not\n+     * given to the calling method of the broker\n+     * @return false if the object no longer exists in the\n+     * database, true otherwise\n+     */\n+    public boolean load(OpenJPAStateManager sm, BitSet fields,\n+        FetchConfiguration fetch, int lockLevel, Object edata);\n+\n+    /**\n+     * Initialize, load, or validate the existance of all of the given\n+     * objects. This method is called from various broker methods that act\n+     * on multiple objects, such as {@link StoreContext#retrieveAll}. It gives\n+     * the store manager an opportunity to efficiently batch-load data for\n+     * several objects. Each of the given state managers will be in one of\n+     * three states, each requiring a different action:\n+     * <ul>\n+     * <li><code>stateManager.getO () == null</code>: An\n+     * uninitialized state manager. Perform the same actions as in\n+     * {@link #initialize}.\n+     * <li><code>load != FORCE_LOAD_NONE || stateManager.getPCState ()\n+     * == PCState.HOLLOW</code>: A hollow state manager, or one whose\n+     * fields must be loaded because this is a refresh or retrieve action.\n+     * Peform the same actions as in {@link #load}, choosing the fields\n+     * to load based on the fetch configuration, or loading all fields\n+     * if <code>load == FORCE_LOAD_ALL</code>. Any required fields left\n+     * unloaded will cause a subsequent invocation of {@link #load} on\n+     * the individual object in question.</li>\n+     * <li><code>load == FORCE_LOAD_NONE &amp;&amp;\n+     * stateManager.getPCState () != PCState.HOLLOW</code>: A non-hollow\n+     * state manager. Perform the same actions as in {@link #exists},\n+     * and load additional state if desired. Non-hollow objects will only\n+     * be included outside of refresh invocations if a user calls\n+     * <code>findAll</code> with the <code>validate</code>\n+     * parameter set to <code>true</code>.</li>\n+     * </ul> \n+     * Store managers that cannot efficiently batch load can simply test\n+     * for these conditions and delegate to the proper methods.\n+     *\n+     * @param sms the state manager instances to load\n+     * @param state the lifecycle state to initialize uninitialized\n+     * state managers with; may be null if no uninitialized\n+     * instances are included in <code>sms</code>\n+     * @param load one of the FORCE_LOAD_* constants describing the\n+     * fields to force-load if this is a refresh or retrieve action\n+     * @param fetch the current fetch configuration to use when loading\n+     * related objects\n+     * @param edata the current execution data, or null if not\n+     * given to the calling method of the broker\n+     * @return a collection of the state manager identities for\n+     * which no data store record exists\n+     * @see org.apache.openjpa.util.ImplHelper#loadAll\n+     */\n+    public Collection loadAll(Collection sms, PCState state, int load,\n+        FetchConfiguration fetch, Object edata);\n+\n+    /**\n+     * Notification that the given state manager is about to change its\n+     * lifecycle state. The store manager is not required to do anything in\n+     * this method, but some back ends may need to.\n+     *\n+     * @since 0.3.0\n+     */\n+    public void beforeStateChange(OpenJPAStateManager sm, PCState fromState,\n+        PCState toState);\n+\n+    /**\n+     * Flush the given state manager collection to the datastore, returning\n+     * a collection of exceptions encountered during flushing.\n+     * The given collection may include states that do not require data\n+     * store action, such as persistent-clean instances or persistent-dirty\n+     * instances that have not been modified since they were last flushed.\n+     * For datastore updates and inserts, the dirty, non-flushed fields of\n+     * each state should be flushed. New instances without an assigned object\n+     * id should be given one via {@link OpenJPAStateManager#setObjectId}. New\n+     * instances with value-strategy fields that have not been assigned yet\n+     * should have their fields set. Datastore version information should be\n+     * updated during flush, and the state manager's version indicator\n+     * updated through the {@link OpenJPAStateManager#setNextVersion} method.\n+     * The current version will roll over to this next version upon successful\n+     * commit.\n+     *\n+     * @see org.apache.openjpa.util.ApplicationIds#assign()\n+     */\n+    public Collection flush(Collection sms);\n+\n+    /**\n+     * Assign an object id to the given new instance. Return false if the\n+     * instance cannot be assigned an identity because a flush is required\n+     * (for example, the identity is determined by the datastore on insert).\n+     * For application identity instances, the assigned object id should be\n+     * based on field state. The implementation is responsible for using the\n+     * proper value strategy according to the instance metadata. This method\n+     * is called the first time a user requests the oid of a new instance\n+     * before flush.\n+     *\n+     * @param preFlush whether this assignment is being requested by the\n+     * system as part of pre-flush activities, and can\n+     * be ignored if it is more efficient to assign within {@link #flush}\n+     * @see org.apache.openjpa.util.ImplHelper#generateFieldValue\n+     * @see org.apache.openjpa.util.ImplHelper#generateIdentityValue\n+     * @see org.apache.openjpa.util.ApplicationIds#assign()\n+     * @since 0.3.3\n+     */\n+    public boolean assignObjectId(OpenJPAStateManager sm, boolean preFlush);\n+\n+    /**\n+     * Assign a value to the given field. Return false if the value cannot\n+     * be assigned because a flush is required (for example, the field value\n+     * is determined by the datastore on insert). This method is called the\n+     * first time a user requests the value of a field with a value-strategy\n+     * on a new instance before flush.\n+     *\n+     * @param preFlush whether this assignment is being requested by the\n+     * system as part of pre-flush activities, and can\n+     * be ignored if it is more efficient to assign within {@link #flush}\n+     * @see org.apache.openjpa.util.ImplHelper#generateFieldValue\n+     * @since 0.4.0\n+     */\n+    public boolean assignField(OpenJPAStateManager sm, int field,\n+        boolean preFlush);\n+\n+    /**\n+     * Return the persistent class for the given data store identity value.\n+     * If the given value is not a datastore identity object, return null.\n+     *\n+     * @since 0.3.0\n+     */\n+    public Class getManagedType(Object oid);\n+\n+    /**\n+     * Return the class used by this StoreManager for datastore identity\n+     * values. The given metadata may be null, in which case the return\n+     * value should the common datastore identity class for all classes, or\n+     * null if this store manager does not use a common identity class.\n+     */\n+    public Class getDataStoreIdType(ClassMetaData meta);\n+\n+    /**\n+     * Copy the given object id value. Use the described type of the given\n+     * metadata, which may be a subclass of the given oid's described type.\n+     */\n+    public Object copyDataStoreId(Object oid, ClassMetaData meta);\n+\n+    /**\n+     * Create a new unique datastore identity for the given type from\n+     * the given oid value (presumably pk, stringified oid, or oid instance).\n+     */\n+    public Object newDataStoreId(Object oidVal, ClassMetaData meta);\n+\n+    /**\n+     * Return a connection to the data store suitable for client use. If\n+     * this method is called during a data store transaction, thie connection\n+     * must be transactional. If no connection is in use, this method should\n+     * create one to return.\n+     */\n+    public Object getClientConnection();\n+\n+    /**\n+     * Instruct the store to retain a connection for continued use. This\n+     * will be invoked automatically based on the user's configured connection\n+     * retain mode.\n+     */\n+    public void retainConnection();\n+\n+    /**\n+     * Instruct the store to release a retained connection. This\n+     * will be invoked automatically based on the user's configured connection\n+     * retain mode.\n+     */\n+    public void releaseConnection();\n+\n+    /**\n+     * Cancel all pending data store statements.\n+     *\n+     * @return true if any statements cancelled, false otherwise\n+     * @since 0.3.1\n+     */\n+    public boolean cancelAll();\n+\n+    /**\n+     * Return a provider for all instances of the given candidate class,\n+     * optionally including subclasses. The given candidate may be an\n+     * unmapped type with mapped subclasses. If the provider is iterated\n+     * within a data store transaction, returned instances should be locked.\n+     */\n+    public ResultObjectProvider executeExtent(ClassMetaData meta,\n+        boolean subclasses, FetchConfiguration fetch);\n+\n+    /**\n+     * Return a query implementation suitable for this store. If the query\n+     * is iterated within a data store transaction, returned instances should\n+     * be locked. Return null if this store does not support native execution\n+     * of the given language. OpenJPA can execute JPQL in memory even without\n+     * back end support.\n+     *\n+     * @param language the query language\n+     */\n+    public StoreQuery newQuery(String language);\n+\n+    /**\n+     * Return a fetch configuration suitable for this runtime. Typically\n+     * will be or extend <code>FetchConfigurationImpl</code>.\n+     */\n+    public FetchConfiguration newFetchConfiguration();\n+\n+    /**\n+     * Compare the two version objects.\n+     *\n+     * @param state the state manager for the object\n+     * @param v1 the first version object to compare\n+     * @param v2 the second version object to compare\n+     * @return <ul>\n+     * <li>{@link #VERSION_LATER} if <code>v1</code>\n+     * is later than <code>v2</code></li>\n+     * <li>{@link #VERSION_EARLIER} if <code>v1</code>\n+     * is earlier than <code>v2</code></li>\n+     * <li>{@link #VERSION_SAME} if <code>v1</code>\n+     * is the same as <code>v2</code></li>\n+     * <li>{@link #VERSION_DIFFERENT} if <code>v1</code>\n+     * is different from <code>v2</code>, but the time\n+     * difference of the versions cannot be determined</li>\n+     * </ul>\n+     */\n+    public int compareVersion(OpenJPAStateManager state, Object v1, Object v2);\n+\n+    /**\n+     * Return a sequence that generates datastore identity values for the\n+     * given class. This method will only be called when the identity strategy\n+     * for the class is one of:\n+     * <ul>\n+     * <li>{@link ValueStrategies#NATIVE}</li>\n+     * <li>{@link ValueStrategies#AUTOASSIGN}</li>\n+     * <li>{@link ValueStrategies#INCREMENT}</li>\n+     * </ul>\n+     * If the identity strategy cannot be represented as a sequence, return\n+     * null.\n+     *\n+     * @since 0.4.0\n+     */\n+    public Seq getDataStoreIdSequence(ClassMetaData forClass);\n+\n+    /**\n+     * Return a sequence that generates values for the given field. This\n+     * method will only be called when the value strategy for the field\n+     * is one of:\n+     * <ul>\n+     * <li>{@link ValueStrategies#NATIVE}</li>\n+     * <li>{@link ValueStrategies#AUTOASSIGN}</li>\n+     * <li>{@link ValueStrategies#INCREMENT}</li>\n+     * </ul> If the value strategy cannot be represented as a sequence, return\n+     * null.\n+     *\n+     * @since 0.4.0\n+     */\n+    public Seq getValueSequence(FieldMetaData forField);\n+\n+    /**\n+     * Free any resources this store manager is using.\n+     *\n+     * @since 0.2.5\n+     */\n+    public void close ();\n+}"},{"sha":"5a690e83221aca9fa827ef5754243db26b8c12a8","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","status":"added","additions":325,"deletions":0,"changes":325,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,325 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import java.io.Serializable;\r\n+import java.util.Iterator;\r\n+import java.util.Map;\r\n+\r\n+import org.apache.commons.collections.map.LinkedMap;\r\n+import org.apache.openjpa.kernel.exps.AggregateListener;\r\n+import org.apache.openjpa.kernel.exps.Constant;\r\n+import org.apache.openjpa.kernel.exps.FilterListener;\r\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+\r\n+/**\r\n+ * Component that executes queries against the datastore. For\r\n+ * expression-based queries, consider subclassing\r\n+ * {@link ExpressionStoreManagerQuery}.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 0.4.0\r\n+ */\r\n+public interface StoreQuery\r\n+    extends QueryOperations, Serializable {\r\n+\r\n+    // linkedmap doesn't allow a size of 0, so use 1\r\n+    public static final LinkedMap EMPTY_PARAMS = new LinkedMap(1, 1F);\r\n+    public static final ClassMetaData[] EMPTY_METAS = new ClassMetaData[0];\r\n+    public static final String[] EMPTY_STRINGS = new String[0];\r\n+    public static final Object[] EMPTY_OBJECTS = new Object[0];\r\n+    public static final Class[] EMPTY_CLASSES = new Class[0];\r\n+    public static final boolean[] EMPTY_BOOLEANS = new boolean[0];\r\n+\r\n+    /**\r\n+     * Return the query context that has been set.\r\n+     */\r\n+    public QueryContext getContext();\r\n+\r\n+    /**\r\n+     * Set the current query context. This will be called before use.\r\n+     */\r\n+    public void setContext(QueryContext ctx);\r\n+\r\n+    /**\r\n+     * This is invoked when the user or a facade creates a new query with\r\n+     * an object that the system does not recognize. Return true if\r\n+     * the object is recognized by the store, false otherwise.\r\n+     */\r\n+    public boolean setQuery(Object query);\r\n+\r\n+    /**\r\n+     * Return the standard filter listener for the given tag, or null.\r\n+     */\r\n+    public FilterListener getFilterListener(String tag);\r\n+\r\n+    /**\r\n+     * Return the standard filter listener for the given tag, or null.\r\n+     */\r\n+    public AggregateListener getAggregateListener(String tag);\r\n+\r\n+    /**\r\n+     * Create a new key for caching compiled query information. May be null.\r\n+     */\r\n+    public Object newCompilationKey();\r\n+\r\n+    /**\r\n+     * Create a new compilation for this query. May be null.\r\n+     */\r\n+    public Object newCompilation();\r\n+\r\n+    /**\r\n+     * Populate internal data from compilation.\r\n+     */\r\n+    public void populateFromCompilation(Object comp);\r\n+\r\n+    /**\r\n+     * Invalidate any internal compilation state.\r\n+     */\r\n+    public void invalidateCompilation();\r\n+\r\n+    /**\r\n+     * True if this query supports datastore execution, false if it\r\n+     * can only run in memory.\r\n+     */\r\n+    public boolean supportsDataStoreExecution();\r\n+\r\n+    /**\r\n+     * True if this query supports in-memory execution, false if it\r\n+     * can only run against the datastore.\r\n+     */\r\n+    public boolean supportsInMemoryExecution();\r\n+\r\n+    /**\r\n+     * Return an executor for in-memory execution of this query.\r\n+     * Executors must be cachable and thread safe. If this class returns\r\n+     * true from {@link #supportsAbstractExecutors}, the given metadata\r\n+     * will always be for the candidate class of this query, or possibly\r\n+     * null if the candidate class is not itself persistence capable (like\r\n+     * an interface or abstract base class). Otherwise, the given type will\r\n+     * be a mapped class.\r\n+     *\r\n+     * @param subs whether to include dependent mapped subclasses in the\r\n+     * results; independent subclasses should never be included\r\n+     */\r\n+    public Executor newInMemoryExecutor(ClassMetaData meta, boolean subs);\r\n+\r\n+    /**\r\n+     * Return an executor for datastore execution of this query.\r\n+     * Executors must be cachable and thread safe. If this class returns\r\n+     * true from {@link #supportsAbstractExecutors}, the given metadata\r\n+     * will always be for the candidate class of this query, or possibly\r\n+     * null if the candidate class is not itself persistence capable (like\r\n+     * an interface or abstract base class). Otherwise, the given type will\r\n+     * be a mapped class.\r\n+     *\r\n+     * @param subs whether to include dependent mapped subclasses in the\r\n+     * results; independent subclasses should never be included\r\n+     */\r\n+    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs);\r\n+\r\n+    /**\r\n+     * Return true if this query supports execution against abstract or\r\n+     * interface types. Returns false by default, meaning we will only\r\n+     * request executors for persistent classes. In this case, we will\r\n+     * automatically combine the results of the executors for all\r\n+     * implementing classes if we execute a query for an interface for\r\n+     * abstract type.\r\n+     */\r\n+    public boolean supportsAbstractExecutors();\r\n+\r\n+    /**\r\n+     * Whether this query requires a candidate class.\r\n+     */\r\n+    public boolean requiresCandidateType();\r\n+\r\n+    /**\r\n+     * Whether this query requires parameters to be declared.\r\n+     */\r\n+    public boolean requiresParameterDeclarations();\r\n+\r\n+    /**\r\n+     * Whether this query supports declared parameters.\r\n+     */\r\n+    public boolean supportsParameterDeclarations();\r\n+\r\n+    public Object evaluate(Object value, Object ob, Object[] params, \r\n+        OpenJPAStateManager sm);\r\n+\r\n+    /**\r\n+     * A query result range.\r\n+     */\r\n+    public static class Range {\r\n+        public long start = 0L;\r\n+        public long end = Long.MAX_VALUE;\r\n+        public boolean lrs = false;\r\n+\r\n+        public Range() {\r\n+        }\r\n+\r\n+        public Range(long start, long end) {\r\n+            this.start = start;\r\n+            this.end = end;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * An executor provides a uniform interface to the mechanism for executing\r\n+     * either an in-memory or datastore query. In the common case, the\r\n+     * {@link #executeQuery} method will be called before other methods,\r\n+     * though this is not guaranteed.\r\n+     *\r\n+     * @author Marc Prud'hommeaux\r\n+     */\r\n+    public static interface Executor {\r\n+\r\n+        /**\r\n+         * Return the result of executing this query with the given parameter\r\n+         * values. If this query is a projection and this executor does not\r\n+         * pack results itself, each element of the returned result object\r\n+         * provider should be an object array containing the projection values.\r\n+         *\r\n+         * @param lrs true if the query result should be treated as a\r\n+         * large result set, assuming the query is not an\r\n+         * aggregate and does not have grouping\r\n+         * @see #isPacking\r\n+         */\r\n+        public ResultObjectProvider executeQuery(StoreQuery q, Object[] params,\r\n+            Range range);\r\n+\r\n+        /**\r\n+         * Deleted the objects that result from the execution of the\r\n+         * query, retuning the number of objects that were deleted.\r\n+         */\r\n+        public Number executeDelete(StoreQuery q, Object[] params);\r\n+\r\n+        /**\r\n+         * Updates the objects that result from the execution of the\r\n+         * query, retuning the number of objects that were updated.\r\n+         */\r\n+        public Number executeUpdate(StoreQuery q, Object[] params);\r\n+\r\n+        /**\r\n+         * Return a description of the commands that will be sent to\r\n+         * the datastore in order to execute the query.\r\n+         */\r\n+        public String[] getDataStoreActions(StoreQuery q, Object[] params,\r\n+            Range range);\r\n+\r\n+        /**\r\n+         * Validate components of query.\r\n+         */\r\n+        public void validate(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Mutate the given range to set any range information stored in \r\n+         * the query string and/or parameters.\r\n+         */\r\n+        public void getRange(StoreQuery q, Object[] params, Range range);\r\n+\r\n+        /**\r\n+         * Extract the value of the <code>orderIndex</code>th ordering\r\n+         * expression in {@link Query#getOrderingClauses} from the\r\n+         * given result object. The result object will be an object from\r\n+         * the result object provider returned from {@link #executeQuery}.\r\n+         * This method is used when several result lists have to be merged\r\n+         * in memory. If this exeuctor's parent query supports executors on\r\n+         * abstract or interface classes, this method will not be used.\r\n+         *\r\n+         * @see StoreQuery#supportsAbstractExecutors\r\n+         */\r\n+        public Object getOrderingValue(StoreQuery q, Object[] params,\r\n+            Object resultObject, int orderIndex);\r\n+\r\n+        /**\r\n+         * Return the ordering direction for all ordering clauses, or empty\r\n+         * array if none.\r\n+         */\r\n+        public boolean[] getAscending(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Return true if this executor packs projections into the result\r\n+         * class itself. Executors for query languages that allow projections\r\n+         * without result clauses must return true and perform the result\r\n+         * packing themselves.\r\n+         */\r\n+        public boolean isPacking(StoreQuery q);\r\n+\r\n+        /**\r\n+         * If this is not a projection but the candidate results are placed\r\n+         * into a result class with an alias, return that alias.\r\n+         */\r\n+        public String getAlias(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Return the alias for each projection element, or empty array\r\n+         * if not a projection.\r\n+         */\r\n+        public String[] getProjectionAliases(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Return the expected types of the projections used by this query,\r\n+         * or an empty array if not a projection.\r\n+         */\r\n+        public Class[] getProjectionTypes(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Return an array of all persistent classes used in this query, or\r\n+         * empty array if unknown.\r\n+         */\r\n+        public ClassMetaData[] getAccessPathMetaDatas(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Returns the operation this executor is meant to execute.\r\n+         *\r\n+         * @see QueryOperations\r\n+         */\r\n+        public int getOperation(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Return true if the compiled query is an aggregate.\r\n+         */\r\n+        public boolean isAggregate(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Whether the compiled query has grouping.\r\n+         */\r\n+        public boolean hasGrouping(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Return a map of parameter names to types. The returned\r\n+         * {@link Map#entrySet}'s {@link Iterator} must return values in the\r\n+         * order in which they were declared or used.\r\n+         */\r\n+        public LinkedMap getParameterTypes(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Returns the result class, if any.\r\n+         */\r\n+        public Class getResultClass(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Return a map of {@link FieldMetaData} to update\r\n+\t\t * {@link Constant}s, in cases where this query is for a bulk update.\r\n+\t \t */\r\n+\t\tpublic Map getUpdates (StoreQuery q);\r\n+\t}\r\n+}\r"},{"sha":"10dabfe8d1c931580e92b5bb4fbdf86dd751b039","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TCleanState.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TCleanState.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TCleanState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TCleanState.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel;\n+\n+/**\n+ * Lifecycle state.\n+ * Represents a transient instance that is managed by a StateManager and\n+ * may be participating in the current\ttransaction, but has not yet been\n+ * modified.\n+ *\n+ * @author Abe White\n+ */\n+class TCleanState\n+    extends PCState {\n+\n+    void initialize(StateManagerImpl context) {\n+        context.clearSavedFields();\n+        context.setLoaded(true);\n+        context.setDirty(false);\n+\n+        // need to replace the second class objects with proxies that\n+        // listen for dirtying so we can track changes to these objects\n+        context.proxyFields(true, false);\n+    }\n+\n+    PCState persist(StateManagerImpl context) {\n+        return (context.getBroker().isActive()) ? PNEW : PNONTRANSNEW;\n+    }\n+\n+    PCState delete(StateManagerImpl context) {\n+        return error(\"transient\", context);\n+    }\n+\n+    PCState nontransactional(StateManagerImpl context) {\n+        return TRANSIENT;\n+    }\n+\n+    PCState beforeWrite(StateManagerImpl context, int field, boolean mutate) {\n+        return TDIRTY;\n+    }\n+\n+    PCState beforeOptimisticWrite(StateManagerImpl context, int field,\n+        boolean mutate) {\n+        return TDIRTY;\n+    }\n+}\n+"},{"sha":"48bd5d1deccf9011ecb902fc0219a66580d90e28","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TDirtyState.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TDirtyState.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TDirtyState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TDirtyState.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel;\n+\n+/**\n+ * Lifecycle state.\n+ * Represents a transient instance that is participating in the current\n+ * transaction, and has been modified.\n+ *\n+ * @author Abe White\n+ */\n+class TDirtyState\n+    extends PCState {\n+\n+    void initialize(StateManagerImpl context) {\n+        context.saveFields(false);\n+        context.setLoaded(true);\n+        context.setDirty(true);\n+    }\n+\n+    PCState commit(StateManagerImpl context) {\n+        return TCLEAN;\n+    }\n+\n+    PCState commitRetain(StateManagerImpl context) {\n+        return TCLEAN;\n+    }\n+\n+    PCState rollback(StateManagerImpl context) {\n+        return TCLEAN;\n+    }\n+\n+    PCState rollbackRestore(StateManagerImpl context) {\n+        context.restoreFields();\n+        return TCLEAN;\n+    }\n+\n+    PCState persist(StateManagerImpl context) {\n+        return (context.getBroker().isActive()) ? PNEW : PNONTRANSNEW;\n+    }\n+\n+    PCState delete(StateManagerImpl context) {\n+        return error(\"transient\", context);\n+    }\n+\n+    PCState nontransactional(StateManagerImpl context) {\n+        return error(\"dirty\", context);\n+    }\n+\n+    boolean isTransactional() {\n+        return true;\n+    }\n+\n+    boolean isDirty() {\n+        return true;\n+    }\n+}\n+"},{"sha":"1afdaeffc423e68ea86217bcbb0fa5fd6f22015f","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TLoadedState.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TLoadedState.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TLoadedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TLoadedState.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,40 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel;\n+\n+/**\n+ * Lifecycle state.\n+ * Represents a temporarily managed transient instance whose fields\n+ * are loaded for the purpose of field inspection such\n+ * as for cascades. This state should be released as soon as inspection\n+ * is complete.\n+ *\n+ * @author Steve Kim\n+ */\n+class TLoadedState\n+    extends PCState {\n+\n+    void initialize(StateManagerImpl context) {\n+        context.setLoaded(true);\n+    }\n+\n+    PCState release(StateManagerImpl context) {\n+        return TRANSIENT;\n+    }\n+}"},{"sha":"f19eb0a374bd2e9e10021b9d10df368f67e75288","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TimeSeededSeq.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TimeSeededSeq.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TimeSeededSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TimeSeededSeq.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel;\n+\n+import org.apache.openjpa.meta.ClassMetaData;\n+import serp.util.Numbers;\n+\n+////////////////////////////////////////////////////////////\n+// NOTE: Do not change property names; see SequenceMetaData \n+// for standard property names.\n+////////////////////////////////////////////////////////////\n+\n+/**\n+ * A simplistic implementation of a {@link Seq} used\n+ * to provide datastore ids. Starts with an id equal to the system's\n+ * current time in milliseconds and increments from there.\n+ *\n+ * @author Greg Campbell\n+ */\n+public class TimeSeededSeq\n+    implements Seq {\n+\n+    private long _id = System.currentTimeMillis();\n+    private int _increment = 1;\n+\n+    public void setType(int type) {\n+    }\n+\n+    public int getIncrement() {\n+        return _increment;\n+    }\n+\n+    public void setIncrement(int increment) {\n+        _increment = increment;\n+    }\n+\n+    public synchronized Object next(StoreContext ctx, ClassMetaData meta) {\n+        _id += _increment;\n+        return Numbers.valueOf(_id);\n+    }\n+\n+    public synchronized Object current(StoreContext ctx, ClassMetaData meta) {\n+        return Numbers.valueOf(_id);\n+    }\n+\n+    public void allocate(int additional, StoreContext ctx, ClassMetaData meta) {\n+    }\n+\n+    public void close() {\n+    }\n+}"},{"sha":"47f4c98a5dbc7b87fe116ec76894daaf17c34a19","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransferFieldManager.java","status":"added","additions":138,"deletions":0,"changes":138,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransferFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransferFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransferFieldManager.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel;\n+\n+import org.apache.openjpa.enhance.FieldManager;\n+\n+/**\n+ * FieldManager type used to transfer a single field value.\n+ *\n+ * @author Abe White\n+ */\n+class TransferFieldManager\n+    implements FieldManager {\n+\n+    protected double dblval = 0;\n+    protected long longval = 0;\n+    protected Object objval = null;\n+    protected int field = -1;\n+\n+    public boolean fetchBooleanField(int field) {\n+        return longval == 1;\n+    }\n+\n+    public byte fetchByteField(int field) {\n+        return (byte) longval;\n+    }\n+\n+    public char fetchCharField(int field) {\n+        return (char) longval;\n+    }\n+\n+    public double fetchDoubleField(int field) {\n+        return dblval;\n+    }\n+\n+    public float fetchFloatField(int field) {\n+        return (float) dblval;\n+    }\n+\n+    public int fetchIntField(int field) {\n+        return (int) longval;\n+    }\n+\n+    public long fetchLongField(int field) {\n+        return longval;\n+    }\n+\n+    public Object fetchObjectField(int field) {\n+        // don't hold onto strong ref to object\n+        Object val = objval;\n+        objval = null;\n+        return val;\n+    }\n+\n+    public short fetchShortField(int field) {\n+        return (short) longval;\n+    }\n+\n+    public String fetchStringField(int field) {\n+        return (String) objval;\n+    }\n+\n+    public void storeBooleanField(int field, boolean curVal) {\n+        this.field = field;\n+        longval = (curVal) ? 1 : 0;\n+    }\n+\n+    public void storeByteField(int field, byte curVal) {\n+        this.field = field;\n+        longval = curVal;\n+    }\n+\n+    public void storeCharField(int field, char curVal) {\n+        this.field = field;\n+        longval = (long) curVal;\n+    }\n+\n+    public void storeDoubleField(int field, double curVal) {\n+        this.field = field;\n+        dblval = curVal;\n+    }\n+\n+    public void storeFloatField(int field, float curVal) {\n+        this.field = field;\n+        dblval = curVal;\n+    }\n+\n+    public void storeIntField(int field, int curVal) {\n+        this.field = field;\n+        longval = curVal;\n+    }\n+\n+    public void storeLongField(int field, long curVal) {\n+        this.field = field;\n+        longval = curVal;\n+    }\n+\n+    public void storeObjectField(int field, Object curVal) {\n+        this.field = field;\n+        objval = curVal;\n+    }\n+\n+    public void storeShortField(int field, short curVal) {\n+        this.field = field;\n+        longval = curVal;\n+    }\n+\n+    public void storeStringField(int field, String curVal) {\n+        this.field = field;\n+        objval = curVal;\n+    }\n+\n+    /**\n+     * Clear any held state. Fields are also cleared automatically when fetched.\n+     */\n+    public void clear() {\n+        dblval = 0;\n+        longval = 0;\n+        objval = null;\n+        field = -1;\n+    }\n+}"},{"sha":"7f12a0b4d9cbf935f015f960c21b70ca336a1f91","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransientState.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransientState.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransientState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/TransientState.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel;\n+\n+/**\n+ * Lifecycle state.\n+ * Represents a transient instance; this state lasts only through\n+ * the {@link #initialize} method, which immediately removes the\n+ * persistence capable instance from management by the OpenJPA runtime.\n+ *\n+ * @author Abe White\n+ */\n+class TransientState\n+    extends PCState {\n+\n+    void initialize(StateManagerImpl context) {\n+        // mark r/w ok, remove from management\n+        context.unproxyFields();\n+        context.getPersistenceCapable().pcReplaceStateManager(null);\n+        context.getBroker().setStateManager(context.getId(),\n+            context, BrokerImpl.STATUS_TRANSIENT);\n+    }\n+}"},{"sha":"3051e4b20a48a3b9f28b7d088a6db87541200027","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDHexSeq.java","status":"added","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDHexSeq.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDHexSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDHexSeq.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel;\n+\n+import org.apache.openjpa.lib.util.UUIDGenerator;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * Sequence for generating 32-character hex UUID strings.\n+ *\n+ * @author Abe White\n+ */\n+public class UUIDHexSeq\n+    implements Seq {\n+\n+    private static final UUIDHexSeq _instance = new UUIDHexSeq();\n+\n+    private String _last = null;\n+\n+    /**\n+     * Return the singleton instance.\n+     */\n+    public static UUIDHexSeq getInstance() {\n+        return _instance;\n+    }\n+\n+    /**\n+     * Hide constructor.\n+     */\n+    private UUIDHexSeq() {\n+    }\n+\n+    public void setType(int type) {\n+    }\n+\n+    public synchronized Object next(StoreContext ctx, ClassMetaData meta) {\n+        _last = UUIDGenerator.nextHex(UUIDGenerator.TYPE1);\n+        return _last;\n+    }\n+\n+    public synchronized Object current(StoreContext ctx, ClassMetaData meta) {\n+        return _last;\n+    }\n+\n+    public void allocate(int additional, StoreContext ctx, ClassMetaData meta) {\n+    }\n+\n+    public void close() {\n+\t}\n+}"},{"sha":"69dcbaf7f33987db0830d55d1636a2cbe002e0f9","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDStringSeq.java","status":"added","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDStringSeq.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDStringSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDStringSeq.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel;\n+\n+import org.apache.openjpa.lib.util.UUIDGenerator;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * Sequence for generating 16-character UUID strings.\n+ *\n+ * @author Abe White\n+ */\n+public class UUIDStringSeq\n+    implements Seq {\n+\n+    private static final UUIDStringSeq _instance = new UUIDStringSeq();\n+\n+    private String _last = null;\n+\n+    /**\n+     * Return the singleton instance.\n+     */\n+    public static UUIDStringSeq getInstance() {\n+        return _instance;\n+    }\n+\n+    /**\n+     * Hide constructor.\n+     */\n+    private UUIDStringSeq() {\n+    }\n+\n+    public void setType(int type) {\n+    }\n+\n+    public synchronized Object next(StoreContext ctx, ClassMetaData meta) {\n+        _last = UUIDGenerator.nextString(UUIDGenerator.TYPE1);\n+        return _last;\n+    }\n+\n+    public synchronized Object current(StoreContext ctx, ClassMetaData meta) {\n+        return _last;\n+    }\n+\n+    public void allocate(int additional, StoreContext ctx, ClassMetaData meta) {\n+    }\n+\n+    public void close() {\n+\t}\n+}"},{"sha":"60b68a6d93fdd2a3abfb6ed6953cf36128c2fbbb","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDType4HexSeq.java","status":"added","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDType4HexSeq.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDType4HexSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDType4HexSeq.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel;\n+\n+import org.apache.openjpa.lib.util.UUIDGenerator;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * Sequence for generating 32-character hex Type 4 UUID strings.\n+ *\n+ * @author Jeremy Bauer\n+ */\n+public class UUIDType4HexSeq\n+    implements Seq {\n+\n+    private static final UUIDType4HexSeq _instance = new UUIDType4HexSeq();\n+\n+    private String _last = null;\n+\n+    /**\n+     * Return the singleton instance.\n+     */\n+    public static UUIDType4HexSeq getInstance() {\n+        return _instance;\n+    }\n+\n+    /**\n+     * Hide constructor.\n+     */\n+    private UUIDType4HexSeq() {\n+    }\n+\n+    public void setType(int type) {\n+    }\n+\n+    public synchronized Object next(StoreContext ctx, ClassMetaData meta) {\n+        _last = UUIDGenerator.nextHex(UUIDGenerator.TYPE4);\n+        return _last;\n+    }\n+\n+    public synchronized Object current(StoreContext ctx, ClassMetaData meta) {\n+        return _last;\n+    }\n+\n+    public void allocate(int additional, StoreContext ctx, ClassMetaData meta) {\n+    }\n+\n+    public void close() {\n+\t}\n+}\n\\ No newline at end of file"},{"sha":"c03d0ea1d25701eed57610778e8c3763c2e7a09a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDType4StringSeq.java","status":"added","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDType4StringSeq.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDType4StringSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/UUIDType4StringSeq.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel;\n+\n+import org.apache.openjpa.lib.util.UUIDGenerator;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * Sequence for generating 16-character UUID strings.\n+ *\n+ * @author Jeremy Bauer\n+ */\n+public class UUIDType4StringSeq\n+    implements Seq {\n+\n+    private static final UUIDType4StringSeq _instance = new UUIDType4StringSeq();\n+\n+    private String _last = null;\n+\n+    /**\n+     * Return the singleton instance.\n+     */\n+    public static UUIDType4StringSeq getInstance() {\n+        return _instance;\n+    }\n+\n+    /**\n+     * Hide constructor.\n+     */\n+    private UUIDType4StringSeq() {\n+    }\n+\n+    public void setType(int type) {\n+    }\n+\n+    public synchronized Object next(StoreContext ctx, ClassMetaData meta) {\n+        _last = UUIDGenerator.nextString(UUIDGenerator.TYPE4);\n+        return _last;\n+    }\n+\n+    public synchronized Object current(StoreContext ctx, ClassMetaData meta) {\n+        return _last;\n+    }\n+\n+    public void allocate(int additional, StoreContext ctx, ClassMetaData meta) {\n+    }\n+\n+    public void close() {\n+\t}\n+}\n\\ No newline at end of file"},{"sha":"d9277e869e82c00d4b785ed38aba7b9f4690fa15","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","status":"added","additions":389,"deletions":0,"changes":389,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,389 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.enhance.StateManager;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.ValueMetaData;\n+import org.apache.openjpa.meta.ValueStrategies;\n+import org.apache.openjpa.util.ApplicationIds;\n+import org.apache.openjpa.util.ObjectNotFoundException;\n+import org.apache.openjpa.util.OptimisticException;\n+import org.apache.openjpa.util.ImplHelper;\n+import org.apache.openjpa.event.LifecycleEvent;\n+\n+/**\n+ * Handles attaching instances using version and primary key fields.\n+ *\n+ * @nojavadoc\n+ * @author Steve Kim\n+ */\n+class VersionAttachStrategy\n+    extends AttachStrategy\n+    implements DetachState {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (VersionAttachStrategy.class);\n+\n+    protected Object getDetachedObjectId(AttachManager manager,\n+        Object toAttach) {\n+        Broker broker = manager.getBroker();\n+        ClassMetaData meta = broker.getConfiguration().\n+            getMetaDataRepositoryInstance().getMetaData(\n+                ImplHelper.getManagedInstance(toAttach).getClass(),\n+                broker.getClassLoader(), true);\n+        return ApplicationIds.create(ImplHelper.toPersistenceCapable(toAttach,\n+            broker.getConfiguration()),\n+            meta);\n+    }\n+\n+    protected void provideField(Object toAttach, StateManagerImpl sm,\n+        int field) {\n+        sm.provideField(ImplHelper.toPersistenceCapable(toAttach,\n+            sm.getContext().getConfiguration()), this, field);\n+    }\n+\n+    public Object attach(AttachManager manager, Object toAttach,\n+        ClassMetaData meta, PersistenceCapable into, OpenJPAStateManager owner,\n+        ValueMetaData ownerMeta, boolean explicit) {\n+        BrokerImpl broker = manager.getBroker();\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(toAttach,\n+            meta.getRepository().getConfiguration());\n+\n+        boolean embedded = ownerMeta != null && ownerMeta.isEmbeddedPC();\n+        boolean isNew = !broker.isDetached(pc);\n+        Object version = null;\n+        StateManagerImpl sm;\n+\n+        // if the state manager for the embedded instance is null, then\n+        // it should be treated as a new instance (since the\n+        // newly persisted owner may create a new embedded instance\n+        // in the constructor); fixed bug #1075.\n+        // also, if the user has attached a detached obj from somewhere\n+        // else in the graph to an embedded field that was previously null,\n+        // copy into a new embedded instance\n+        if (embedded && (isNew || into == null\n+            || broker.getStateManager(into) == null)) {\n+            if (into == null)\n+                into = pc.pcNewInstance(null, false);\n+            sm = (StateManagerImpl) broker.embed(into, null, owner, ownerMeta);\n+            into = sm.getPersistenceCapable();\n+        } else if (isNew) {\n+            Object oid = null;\n+            if (!isPrimaryKeysGenerated(meta))\n+                oid = ApplicationIds.create(pc, meta);\n+\n+            sm = persist(manager, pc, meta, oid, explicit);\n+            into = sm.getPersistenceCapable();\n+        } else if (!embedded && into == null) {\n+            Object id = getDetachedObjectId(manager, toAttach);\n+            if (id != null)\n+                into =\n+                    ImplHelper.toPersistenceCapable(broker.find(id, true, null),\n+                        broker.getConfiguration());\n+            if (into == null)\n+                throw new OptimisticException(_loc.get(\"attach-version-del\",\n+                    ImplHelper.getManagedInstance(pc).getClass(), id, version))\n+                    .setFailedObject(toAttach);\n+\n+            sm = manager.assertManaged(into);\n+            if (meta.getDescribedType()\n+                != sm.getMetaData().getDescribedType()) {\n+                throw new ObjectNotFoundException(_loc.get\n+                    (\"attach-wrongclass\", id, toAttach.getClass(),\n+                        sm.getMetaData().getDescribedType())).\n+                    setFailedObject(toAttach);\n+            }\n+        } else\n+            sm = manager.assertManaged(into);\n+\n+        // mark that we attached the instance *before* we\n+        // fill in values to avoid endless recursion\n+        manager.setAttachedCopy(toAttach, into);\n+\n+        // if persisting in place, just attach field values\n+        if (pc == into) {\n+            attachFieldsInPlace(manager, sm);\n+            return into;\n+        }\n+\n+        if (isNew) {\n+            broker.fireLifecycleEvent(toAttach, null, meta,\n+                LifecycleEvent.BEFORE_PERSIST);\n+        } else {\n+            // invoke any preAttach on the detached instance\n+            manager.fireBeforeAttach(toAttach, meta);\n+        }\n+\n+        // assign the detached pc the same state manager as the object we're\n+        // copying into during the attach process\n+        StateManager smBefore = pc.pcGetStateManager();\n+        pc.pcReplaceStateManager(sm);\n+        int detach = (isNew) ? DETACH_ALL : broker.getDetachState();\n+        FetchConfiguration fetch = broker.getFetchConfiguration();\n+        try {\n+            FieldMetaData[] fmds = meta.getFields();\n+            for (int i = 0; i < fmds.length; i++) {\n+                switch (detach) {\n+                    case DETACH_ALL:\n+                        attachField(manager, toAttach, sm, fmds[i], true);\n+                        break;\n+                    case DETACH_FETCH_GROUPS:\n+                        if (fetch.requiresFetch(fmds[i]) \n+                            != FetchConfiguration.FETCH_NONE)\n+                            attachField(manager, toAttach, sm, fmds[i], true);\n+                        break;\n+                    case DETACH_LOADED:\n+                        attachField(manager, toAttach, sm, fmds[i], false);\n+                        break;\n+                }\n+            }\n+        } finally {\n+            pc.pcReplaceStateManager(smBefore);\n+        }\n+        if (!embedded && !isNew)\n+            compareVersion(sm, pc);\n+        return ImplHelper.getManagedInstance(into);\n+    }\n+\n+    /**\n+     * Make sure the version information is correct in the detached object.\n+     */\n+    private void compareVersion(StateManagerImpl sm, PersistenceCapable pc) {\n+        Object version = pc.pcGetVersion();\n+        if (version == null)\n+            return;\n+\n+        // don't need to load unloaded fields since its implicitly\n+        // a single field value\n+        StoreManager store = sm.getBroker().getStoreManager();\n+        switch (store.compareVersion(sm, version, sm.getVersion())) {\n+            case StoreManager.VERSION_LATER:\n+                // we have a later version: set it into the object.\n+                // lock validation will occur at commit time\n+                sm.setVersion(version);\n+                break;\n+            case StoreManager.VERSION_EARLIER:\n+            case StoreManager.VERSION_DIFFERENT:\n+                sm.setVersion(version);\n+                throw new OptimisticException(sm.getManagedInstance());\n+            case StoreManager.VERSION_SAME:\n+                // no action required\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Attach the fields of an in-place persisted instance.\n+     */\n+    private void attachFieldsInPlace(AttachManager manager,\n+        StateManagerImpl sm) {\n+        FieldMetaData[] fmds = sm.getMetaData().getFields();\n+        for (int i = 0; i < fmds.length; i++) {\n+            if (fmds[i].getManagement() != FieldMetaData.MANAGE_PERSISTENT)\n+                continue;\n+\n+            Object cur, attached;\n+            switch (fmds[i].getDeclaredTypeCode()) {\n+                case JavaTypes.PC:\n+                case JavaTypes.PC_UNTYPED:\n+                    cur = sm.fetchObjectField(i);\n+                    attached = attachInPlace(manager, sm, fmds[i], cur);\n+                    break;\n+                case JavaTypes.ARRAY:\n+                    if (!fmds[i].getElement().isDeclaredTypePC())\n+                        continue;\n+                    cur = sm.fetchObjectField(i);\n+                    attached =\n+                        attachInPlace(manager, sm, fmds[i], (Object[]) cur);\n+                    break;\n+                case JavaTypes.COLLECTION:\n+                    if (!fmds[i].getElement().isDeclaredTypePC())\n+                        continue;\n+                    cur = sm.fetchObjectField(i);\n+                    attached = attachInPlace(manager, sm, fmds[i],\n+                        (Collection) cur);\n+                    break;\n+                case JavaTypes.MAP:\n+                    if (!fmds[i].getElement().isDeclaredTypePC()\n+                        && !fmds[i].getKey().isDeclaredTypePC())\n+                        continue;\n+                    cur = sm.fetchObjectField(i);\n+                    attached = attachInPlace(manager, sm, fmds[i], (Map) cur);\n+                    break;\n+                default:\n+                    continue;\n+            }\n+\n+            if (cur != attached)\n+                sm.settingObjectField(sm.getPersistenceCapable(), i,\n+                    cur, attached, StateManager.SET_REMOTE);\n+        }\n+    }\n+\n+    /**\n+     * Attach the given pc.\n+     */\n+    private Object attachInPlace(AttachManager manager, StateManagerImpl sm,\n+        ValueMetaData vmd, Object pc) {\n+        if (pc == null)\n+            return null;\n+        Object attached = manager.getAttachedCopy(pc);\n+        if (attached != null)\n+            return attached;\n+\n+        OpenJPAStateManager into = manager.getBroker().getStateManager(pc);\n+        PersistenceCapable intoPC = (into == null) ? null\n+            : into.getPersistenceCapable();\n+        if (vmd.isEmbedded())\n+            return manager.attach(pc, intoPC, sm, vmd, false);\n+        return manager.attach(pc, intoPC, null, null, false);\n+    }\n+\n+    /**\n+     * Attach the given array.\n+     */\n+    private Object[] attachInPlace(AttachManager manager, StateManagerImpl sm,\n+        FieldMetaData fmd, Object[] arr) {\n+        if (arr == null)\n+            return null;\n+\n+        for (int i = 0; i < arr.length; i++)\n+            arr[i] = attachInPlace(manager, sm, fmd.getElement(), arr[i]);\n+        return arr;\n+    }\n+\n+    /**\n+     * Attach the given collection.\n+     */\n+    private Collection attachInPlace(AttachManager manager,\n+        StateManagerImpl sm, FieldMetaData fmd, Collection coll) {\n+        if (coll == null || coll.isEmpty())\n+            return coll;\n+\n+        // copy if elements embedded or contains detached, which will mean\n+        // we'll have to copy the existing elements\n+        Collection copy = null;\n+        if (fmd.getElement().isEmbedded())\n+            copy = (Collection) sm.newFieldProxy(fmd.getIndex());\n+        else {\n+            for (Iterator itr = coll.iterator(); itr.hasNext();) {\n+                if (manager.getBroker().isDetached(itr.next())) {\n+                    copy = (Collection) sm.newFieldProxy(fmd.getIndex());\n+                    break;\n+                }\n+            }\n+        }\n+\n+        Object attached;\n+        for (Iterator itr = coll.iterator(); itr.hasNext();) {\n+            attached = attachInPlace(manager, sm, fmd.getElement(),\n+                itr.next());\n+            if (copy != null)\n+                copy.add(attached);\n+        }\n+        return (copy == null) ? coll : copy;\n+    }\n+\n+    /**\n+     * Attach the given map.\n+     */\n+    private Map attachInPlace(AttachManager manager, StateManagerImpl sm,\n+        FieldMetaData fmd, Map map) {\n+        if (map == null || map.isEmpty())\n+            return map;\n+\n+        Map copy = null;\n+        Map.Entry entry;\n+        boolean keyPC = fmd.getKey().isDeclaredTypePC();\n+        boolean valPC = fmd.getElement().isDeclaredTypePC();\n+\n+        // copy if embedded pcs or detached pcs, which will require us to\n+        // copy elements\n+        if (fmd.getKey().isEmbeddedPC() || fmd.getElement().isEmbeddedPC())\n+            copy = (Map) sm.newFieldProxy(fmd.getIndex());\n+        else {\n+            for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n+                entry = (Map.Entry) itr.next();\n+                if ((keyPC && manager.getBroker().isDetached(entry.getKey()))\n+                    || (valPC && manager.getBroker().isDetached\n+                    (entry.getValue()))) {\n+                    copy = (Map) sm.newFieldProxy(fmd.getIndex());\n+                    break;\n+                }\n+            }\n+        }\n+\n+        Object key, val;\n+        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            key = entry.getKey();\n+            if (keyPC)\n+                key = attachInPlace(manager, sm, fmd.getKey(), key);\n+            val = entry.getValue();\n+            if (valPC)\n+                val = attachInPlace(manager, sm, fmd.getElement(), val);\n+            if (copy != null)\n+                copy.put(key, val);\n+        }\n+        return (copy == null) ? map : copy;\n+\t}\n+\n+    /**\n+     * Find a PersistenceCapable instance of an Object if it exists in the\n+     * database. If the object is null or can't be found in the database.\n+     *\n+     * @param pc An object which will be attached into the current context. The\n+     * object may or may not correspond to a row in the database.\n+     *\n+     * @return If the object is null or can't be found in the database this\n+     * method returns null. Otherwise a PersistenceCapable representation of the\n+     * object is returned.\n+     */\n+    protected PersistenceCapable findFromDatabase(AttachManager manager,\n+        Object pc) {\n+        Object oid = manager.getBroker().newObjectId(pc.getClass(),\n+            manager.getDetachedObjectId(pc));\n+\n+        if (oid != null) {\n+            return ImplHelper.toPersistenceCapable(\n+                manager.getBroker().find(oid, true, null),\n+                manager.getBroker().getConfiguration());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private boolean isPrimaryKeysGenerated(ClassMetaData meta) {\n+        FieldMetaData[] pks = meta.getPrimaryKeyFields();\n+        for (int i = 0; i < pks.length; i++) {\n+            if (pks[i].getValueStrategy() != ValueStrategies.NONE)\n+                return true;\n+        }\n+        return false;\n+    }\n+}"},{"sha":"1d5d15cdebc923ee41a64e58934704d8f1964615","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionLockManager.java","status":"added","additions":140,"deletions":0,"changes":140,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionLockManager.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel;\n+\n+import serp.util.Numbers;\n+\n+/**\n+ * {@link LockManager} implementation that provides support\n+ * for version checking and version updating when locks are acquired.\n+ * This lock manager may be used standalone or extended for additional locking.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+public class VersionLockManager\n+    extends AbstractLockManager {\n+\n+    private boolean _versionCheckOnReadLock = true;\n+    private boolean _versionUpdateOnWriteLock = true;\n+\n+    /**\n+     * Returns the given instance's lock level, assuming that the state's\n+     * lock object is a number. If the given instance is embedded, traverses\n+     * to its owner. Override if lock is not stored as a number.\n+     */\n+    public int getLockLevel(OpenJPAStateManager sm) {\n+        while (sm.getOwner() != null)\n+            sm = sm.getOwner();\n+        Number level = (Number) sm.getLock();\n+        return (level == null) ? LOCK_NONE : level.intValue();\n+    }\n+\n+    /**\n+     * Sets the given instance's lock level to the given number. Override\n+     * to store something else as the lock.\n+     */\n+    protected void setLockLevel(OpenJPAStateManager sm, int level) {\n+        sm.setLock(Numbers.valueOf(level));\n+    }\n+\n+    /**\n+     * Nulls given instance's lock object.\n+     */\n+    public void release(OpenJPAStateManager sm) {\n+        sm.setLock(null);\n+    }\n+\n+    /**\n+     * Delegates to {@link #lockInternal} after traversing to owning\n+     * instance (if embedded) and assuring that the instance is persistent,\n+     * is not new, and is not already locked at a higher level. After\n+     * locking, calls {@link #setLockLevel} with the given level.\n+     */\n+    public void lock(OpenJPAStateManager sm, int level, int timeout,\n+        Object sdata) {\n+        if (level == LOCK_NONE)\n+            return;\n+        while (sm.getOwner() != null)\n+            sm = sm.getOwner();\n+        int oldLevel = getLockLevel(sm);\n+        if (!sm.isPersistent() || sm.isNew() || level <= oldLevel)\n+            return;\n+\n+        try {\n+            lockInternal(sm, level, timeout, sdata);\n+        } catch (RuntimeException re) {\n+            // revert lock\n+            setLockLevel(sm, oldLevel);\n+            throw re;\n+        }\n+    }\n+\n+    /**\n+     * Marks the instance's transactional status in accordance with\n+     * the settings of {@link #getVersionCheckOnReadLock}\n+     * and {@link #getVersionUpdateOnWriteLock}. Override to perform\n+     * additional locking.\n+     *\n+     * @see StoreContext#transactional\n+     */\n+    protected void lockInternal(OpenJPAStateManager sm, int level, int timeout,\n+        Object sdata) {\n+        // Set lock level first to prevent infinite recursion with\n+        // transactional(..) call\n+        setLockLevel(sm, level);\n+        if (level >= LockLevels.LOCK_WRITE && _versionUpdateOnWriteLock)\n+            getContext().transactional(sm.getManagedInstance(), true, null);\n+        else if (level >= LockLevels.LOCK_READ && _versionCheckOnReadLock)\n+            getContext().transactional(sm.getManagedInstance(), false, null);\n+    }\n+\n+    /**\n+     * Whether or not we should force a version check at commit\n+     * time when a read lock is requested in order to verify read\n+     * consistency. Defaults to true.\n+     */\n+    public void setVersionCheckOnReadLock(boolean versionCheckOnReadLock) {\n+        _versionCheckOnReadLock = versionCheckOnReadLock;\n+    }\n+\n+    /**\n+     * Whether or not we should force a version check at commit\n+     * time when a read lock is requested in order to verify read\n+     * consistency. Defaults to true.\n+     */\n+    public boolean getVersionCheckOnReadLock() {\n+        return _versionCheckOnReadLock;\n+    }\n+\n+    /**\n+     * Whether or not we should force an update to the version at commit\n+     * time when a write lock is requested. Defaults to true.\n+     */\n+    public void setVersionUpdateOnWriteLock(boolean versionUpdateOnWriteLock) {\n+        _versionUpdateOnWriteLock = versionUpdateOnWriteLock;\n+    }\n+\n+    /**\n+     * Whether or not we should force an update to the version at commit\n+     * time when a write lock is requested. Defaults to true.\n+     */\n+    public boolean getVersionUpdateOnWriteLock() {\n+        return _versionUpdateOnWriteLock;\n+    }\n+}"},{"sha":"9ce120654cb4540d5fda5a2b3fd76032100754af","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Abs.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Abs.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Abs.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Abs.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import org.apache.openjpa.kernel.Filters;\n+import serp.util.Numbers;\n+\n+/**\n+ * Take the absolute value of a number.\n+ */\n+class Abs\n+    extends UnaryMathVal {\n+\n+    /**\n+     * Constructor. Provide the number whose absolute value to calculate.\n+     */\n+    public Abs(Val val) {\n+        super(val);\n+    }\n+\n+    protected Class getType(Class c) {\n+        Class wrap = Filters.wrap(c);\n+        if (wrap == Integer.class\n+            || wrap == Float.class\n+            || wrap == Double.class\n+            || wrap == Long.class\n+            || wrap == BigDecimal.class\n+            || wrap == BigInteger.class)\n+            return Filters.unwrap(c);\n+        return int.class;\n+    }\n+\n+    protected Object operate(Object o, Class c) {\n+        c = Filters.wrap(c);\n+        if (c == Integer.class)\n+            return Numbers.valueOf(Math.abs(((Number) o).intValue()));\n+        if (c == Float.class)\n+            return new Float(Math.abs(((Number) o).floatValue()));\n+        if (c == Double.class)\n+            return new Double(Math.abs(((Number) o).doubleValue()));\n+        if (c == Long.class)\n+            return Numbers.valueOf(Math.abs(((Number) o).longValue()));\n+        if (c == BigDecimal.class)\n+            return ((BigDecimal) o).abs();\n+        if (c == BigInteger.class)\n+            return ((BigInteger) o).abs();\n+\n+        // default to int\n+        return Numbers.valueOf(Math.abs(((Number) o).intValue()));\n+    }\n+}"},{"sha":"4e0571350f75b0855f76caf731b2b997a3a7c0d6","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","status":"added","additions":517,"deletions":0,"changes":517,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,517 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Localizer.Message;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.XMLMetaData;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.UnsupportedException;\n+import org.apache.openjpa.util.UserException;\n+import serp.util.Strings;\n+\n+/**\n+ * Abstract base class to help build expressions. Provides\n+ * generic language-independent support for variable resolution,\n+ * path traversal, and error messages.\n+ *\n+ * @author Marc Prud'hommeaux\n+ * @nojavadoc\n+ */\n+public abstract class AbstractExpressionBuilder {\n+\n+    // used for error messages\n+    protected static final int EX_USER = 0;\n+    protected static final int EX_FATAL = 1;\n+    protected static final int EX_UNSUPPORTED = 2;\n+\n+    // common implicit type settings\n+    protected static final Class TYPE_OBJECT = Object.class;\n+    protected static final Class TYPE_STRING = String.class;\n+    protected static final Class TYPE_CHAR_OBJ = Character.class;\n+    protected static final Class TYPE_NUMBER = Number.class;\n+    protected static final Class TYPE_COLLECTION = Collection.class;\n+    protected static final Class TYPE_MAP = Map.class;\n+\n+    // contains types for setImplicitTypes\n+    protected static final int CONTAINS_TYPE_ELEMENT = 1;\n+    protected static final int CONTAINS_TYPE_KEY = 2;\n+    protected static final int CONTAINS_TYPE_VALUE = 3;\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (AbstractExpressionBuilder.class);\n+\n+    protected final Resolver resolver;\n+    protected ExpressionFactory factory;\n+\n+    private final Set _accessPath = new HashSet();\n+    private Map _seenVars = null;\n+    private Set _boundVars = null;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param factory the expression factory to use\n+     * @param resolver used to resolve variables, parameters, and class\n+     * names used in the query\n+     */\n+    public AbstractExpressionBuilder(ExpressionFactory factory,\n+        Resolver resolver) {\n+        this.factory = factory;\n+        this.resolver = resolver;\n+    }\n+\n+    /**\n+     * Returns the class loader that should be used for resolving\n+     * class names (in addition to the resolver in the query).\n+     */\n+    protected abstract ClassLoader getClassLoader();\n+\n+    /**\n+     * Create a proper parse exception for the given reason.\n+     */\n+    protected OpenJPAException parseException(int e, String token,\n+        Object[] args,\n+        Exception nest) {\n+        String argStr;\n+        if (args == null)\n+            argStr = getLocalizer().get(token).getMessage();\n+        else\n+            argStr = getLocalizer().get(token, args).getMessage();\n+\n+        Message msg = _loc.get(\"parse-error\", argStr, currentQuery());\n+\n+        switch (e) {\n+            case EX_FATAL:\n+                throw new InternalException(msg, nest);\n+            case EX_UNSUPPORTED:\n+                throw new UnsupportedException(msg, nest);\n+            default:\n+                throw new UserException(msg, nest);\n+        }\n+    }\n+\n+    /**\n+     * Register the specified metadata as being in the query's access path.\n+     */\n+    protected ClassMetaData addAccessPath(ClassMetaData meta) {\n+        _accessPath.add(meta);\n+        return meta;\n+    }\n+\n+    /**\n+     * Return the recorded query access path.\n+     */\n+    protected ClassMetaData[] getAccessPath() {\n+        return (ClassMetaData[]) _accessPath.toArray\n+            (new ClassMetaData[_accessPath.size()]);\n+    }\n+\n+    /**\n+     * Return true if the given variable has been bound.\n+     */\n+    protected boolean isBound(Value var) {\n+        return _boundVars != null && _boundVars.contains(var);\n+    }\n+\n+    /**\n+     * Record that the given variable is bound.\n+     */\n+    protected void bind(Value var) {\n+        if (_boundVars == null)\n+            _boundVars = new HashSet();\n+        _boundVars.add(var);\n+    }\n+\n+    /**\n+     * Returns a value for the given id.\n+     */\n+    protected Value getVariable(String id, boolean bind) {\n+        // check for already constructed var\n+        if (isSeenVariable(id))\n+            return (Value) _seenVars.get(id);\n+\n+        // create and cache var\n+        Class type = getDeclaredVariableType(id);\n+\n+        // add this type to the set of classes in the filter's access path\n+        ClassMetaData meta = null;\n+        if (type == null)\n+            type = TYPE_OBJECT;\n+        else\n+            meta = getMetaData(type, false);\n+        if (meta != null)\n+            _accessPath.add(meta);\n+\n+        Value var;\n+        if (bind)\n+            var = factory.newBoundVariable(id, type);\n+        else\n+            var = factory.newUnboundVariable(id, type);\n+        var.setMetaData(meta);\n+\n+        if (_seenVars == null)\n+            _seenVars = new HashMap();\n+        _seenVars.put(id, var);\n+        return var;\n+    }\n+\n+    /**\n+     * Validate that all unbound variables are of a PC type. If not, assume\n+     * that the user actually made a typo that we took for an implicit\n+     * unbound variable.\n+     */\n+    protected void assertUnboundVariablesValid() {\n+        if (_seenVars == null)\n+            return;\n+\n+        Map.Entry entry;\n+        Value var;\n+        for (Iterator itr = _seenVars.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            var = (Value) entry.getValue();\n+            if (var.getMetaData() == null && !isBound(var)\n+                && !isDeclaredVariable((String) entry.getKey())) {\n+                throw parseException(EX_USER, \"not-unbound-var\",\n+                    new Object[]{ entry.getKey() }, null);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns whether the specified variable name has been explicitly\n+     * declared. Note all query languages necessarily support declaring\n+     * variables.\n+     *\n+     * @param id the variable to check\n+     * @return true if the variabe has been explicitely declared\n+     */\n+    protected abstract boolean isDeclaredVariable(String id);\n+\n+    /**\n+     * Return whether the given id has been used as a variable.\n+     */\n+    protected boolean isSeenVariable(String id) {\n+        return _seenVars != null && _seenVars.containsKey(id);\n+    }\n+\n+    /**\n+     * Convenience method to get metadata for the given type.\n+     */\n+    protected ClassMetaData getMetaData(Class c, boolean required) {\n+        return getMetaData(c, required, getClassLoader());\n+    }\n+\n+    /**\n+     * Convenience method to get metadata for the given type.\n+     */\n+    protected ClassMetaData getMetaData(Class c, boolean required,\n+        ClassLoader loader) {\n+        return resolver.getConfiguration().getMetaDataRepositoryInstance().\n+            getMetaData(c, loader, required);\n+    }\n+\n+    /**\n+     * Traverse the given field in the given path.\n+     */\n+    protected Value traversePath(Path path, String field) {\n+        return traversePath(path, field, false, false);\n+    }\n+    \n+    protected Value traverseXPath(Path path, String field) {\n+        XMLMetaData meta = path.getXmlMapping();\n+        if (meta.getFieldMapping(field) == null) {\n+            throw parseException(EX_USER, \"no-field\",\n+                    new Object[]{ meta.getType(), field }, null);\n+        }\n+        else {\n+            // collection-valued xpath is not allowed\n+            int type = meta.getFieldMapping(field).getTypeCode();\n+            switch (type) {\n+                case JavaTypes.ARRAY:\n+                case JavaTypes.COLLECTION:\n+                case JavaTypes.MAP:\n+                    throw new UserException(_loc.get(\"collection-valued-path\",\n+                            field));\n+            }\n+        }\n+        path.get(meta, field);\n+        return path;\n+    }\n+\n+    /**\n+     * Traverse the given field in the given path.\n+     */\n+    protected Value traversePath(Path path, String field, boolean pcOnly,\n+        boolean allowNull) {\n+        ClassMetaData meta = path.getMetaData();\n+        if (meta == null)\n+            throw parseException(EX_USER, \"path-no-meta\",\n+                new Object[]{ field, path.getType() }, null);\n+\n+        FieldMetaData fmd = meta.getField(field);\n+        if (fmd == null) {\n+            Object val = traverseStaticField(meta.getDescribedType(), field);\n+            if (val == null)\n+                throw parseException(EX_USER, \"no-field\",\n+                    new Object[]{ meta.getDescribedType(), field }, null);\n+\n+            return factory.newLiteral(val, Literal.TYPE_UNKNOWN);\n+        }\n+\n+        if (fmd.isEmbedded())\n+            meta = fmd.getEmbeddedMetaData();\n+        else\n+            meta = fmd.getDeclaredTypeMetaData();\n+        if (meta != null) {\n+            addAccessPath(meta);\n+            path.setMetaData(meta);\n+        }\n+        else {\n+            // xmlsupport xpath\n+            XMLMetaData xmlmeta = fmd.getRepository().getXMLMetaData(fmd);\n+            if (xmlmeta != null) {\n+                path.get(fmd, xmlmeta);\n+                return path;\n+            }\n+        }\n+\n+        if (meta != null || !pcOnly)\n+            path.get(fmd, allowNull);\n+\n+        return path;\n+    }\n+\n+    /**\n+     * Return a constant containing the value of the given static field.\n+     */\n+    protected Object traverseStaticField(Class cls, String field) {\n+        try {\n+            return cls.getField(field).get(null);\n+        } catch (Exception e) {\n+            // count not locate the field: return null\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Returns the type of the named variabe if it has been declared.\n+     */\n+    protected abstract Class getDeclaredVariableType(String name);\n+\n+    /**\n+     * Set the implicit types of the given values based on the fact that\n+     * they're used together, and based on the operator type.\n+     */\n+    protected void setImplicitTypes(Value val1, Value val2,\n+        Class expected) {\n+        Class c1 = val1.getType();\n+        Class c2 = val2.getType();\n+        boolean o1 = c1 == TYPE_OBJECT;\n+        boolean o2 = c2 == TYPE_OBJECT;\n+\n+        if (o1 && !o2) {\n+            val1.setImplicitType(c2);\n+            if (val1.getMetaData() == null && !val1.isXPath())\n+                val1.setMetaData(val2.getMetaData());\n+        } else if (!o1 && o2) {\n+            val2.setImplicitType(c1);\n+            if (val2.getMetaData() == null && !val1.isXPath())\n+                val2.setMetaData(val1.getMetaData());\n+        } else if (o1 && o2 && expected != null) {\n+            // we never expect a pc type, so don't bother with metadata\n+            val1.setImplicitType(expected);\n+            val2.setImplicitType(expected);\n+        } else if (isNumeric(val1.getType()) != isNumeric(val2.getType())) {\n+            if (resolver.getConfiguration().getCompatibilityInstance().\n+                getQuotedNumbersInQueries())\n+                convertTypesQuotedNumbers(val1, val2);\n+            else\n+                convertTypes(val1, val2);\n+        }\n+    }\n+\n+    /**\n+     * Perform conversions to make values compatible.\n+     */\n+    private void convertTypes(Value val1, Value val2) {\n+        Class t1 = val1.getType();\n+        Class t2 = val2.getType();\n+\n+        // allow string-to-char conversions\n+        if (t1 == TYPE_STRING && (Filters.wrap(t2) == TYPE_CHAR_OBJ\n+            && !(val2 instanceof Path))) {\n+            val2.setImplicitType(String.class);\n+            return;\n+        }\n+        if (t2 == TYPE_STRING && (Filters.wrap(t1) == TYPE_CHAR_OBJ)\n+            && !(val1 instanceof Path)) {\n+            val1.setImplicitType(String.class);\n+            return;\n+        }\n+\n+        // if the non-numeric side is a string of length 1, cast it\n+        // to a character\n+        if (t1 == TYPE_STRING && val1 instanceof Literal\n+            && ((String) ((Literal) val1).getValue()).length() == 1) {\n+            val1.setImplicitType(Character.class);\n+            return;\n+        }\n+        if (t2 == TYPE_STRING && val2 instanceof Literal\n+            && ((String) ((Literal) val2).getValue()).length() == 1) {\n+            val2.setImplicitType(Character.class);\n+            return;\n+        }\n+\n+        // error\n+        String left;\n+        String right;\n+        if (val1 instanceof Path && ((Path) val1).last() != null)\n+            left = _loc.get(\"non-numeric-path\", ((Path) val1).last().\n+                getName(), t1.getName()).getMessage();\n+        else\n+            left = _loc.get(\"non-numeric-value\", t1.getName()).getMessage();\n+        if (val2 instanceof Path && ((Path) val2).last() != null)\n+            right = _loc.get(\"non-numeric-path\", ((Path) val2).last().\n+                getName(), t2.getName()).getMessage();\n+        else\n+            right = _loc.get(\"non-numeric-value\", t2.getName()).getMessage();\n+        throw new UserException(_loc.get(\"non-numeric-comparison\",\n+            left, right));\n+    }\n+\n+    /**\n+     * Perform conversions to make values compatible.\n+     */\n+    private void convertTypesQuotedNumbers(Value val1, Value val2) {\n+        Class t1 = val1.getType();\n+        Class t2 = val2.getType();\n+\n+        // if we're comparing to a single-quoted string, convert\n+        // the value according to the 3.1 rules.\n+        if (t1 == TYPE_STRING && val1 instanceof Literal\n+            && ((Literal) val1).getParseType() == Literal.TYPE_SQ_STRING) {\n+            String s = (String) ((Literal) val1).getValue();\n+            if (s.length() > 1) {\n+                ((Literal) val1).setValue(s.substring(0, 1));\n+                val1.setImplicitType(Character.TYPE);\n+            }\n+        }\n+        if (t2 == TYPE_STRING && val2 instanceof Literal\n+            && ((Literal) val2).getParseType() == Literal.TYPE_SQ_STRING) {\n+            String s = (String) ((Literal) val2).getValue();\n+            if (s.length() > 1) {\n+                ((Literal) val2).setValue(s.substring(0, 1));\n+                val2.setImplicitType(Character.TYPE);\n+            }\n+        }\n+\n+        // if we're comparing to a double-quoted string, convert the\n+        // value directly to a number\n+        if (t1 == TYPE_STRING && val1 instanceof Literal\n+            && ((Literal) val1).getParseType() == Literal.TYPE_STRING) {\n+            String s = (String) ((Literal) val1).getValue();\n+            ((Literal) val1).setValue(Strings.parse(s, Filters.wrap(t2)));\n+            val1.setImplicitType(t2);\n+        }\n+        if (t2 == TYPE_STRING && val2 instanceof Literal\n+            && ((Literal) val2).getParseType() == Literal.TYPE_STRING) {\n+            String s = (String) ((Literal) val2).getValue();\n+            ((Literal) val2).setValue(Strings.parse(s, Filters.wrap(t1)));\n+            val2.setImplicitType(t1);\n+        }\n+    }\n+\n+    /**\n+     * Return true if given class can be used as a number.\n+     */\n+    private static boolean isNumeric(Class type) {\n+        type = Filters.wrap(type);\n+        return Number.class.isAssignableFrom(type)\n+            || type == Character.TYPE || type == TYPE_CHAR_OBJ;\n+    }\n+\n+    /**\n+     * Set the implicit types of the given values based on the fact that\n+     * the first is supposed to contain the second.\n+     */\n+    protected void setImplicitContainsTypes(Value val1, Value val2, int op) {\n+        if (val1.getType() == TYPE_OBJECT) {\n+            if (op == CONTAINS_TYPE_ELEMENT)\n+                val1.setImplicitType(Collection.class);\n+            else\n+                val1.setImplicitType(Map.class);\n+        }\n+\n+        if (val2.getType() == TYPE_OBJECT && val1 instanceof Path) {\n+            FieldMetaData fmd = ((Path) val1).last();\n+            ClassMetaData meta;\n+            if (fmd != null) {\n+                if (op == CONTAINS_TYPE_ELEMENT || op == CONTAINS_TYPE_VALUE) {\n+                    val2.setImplicitType(fmd.getElement().getDeclaredType());\n+                    meta = fmd.getElement().getDeclaredTypeMetaData();\n+                    if (meta != null) {\n+                        val2.setMetaData(meta);\n+                        addAccessPath(meta);\n+                    }\n+                } else {\n+                    val2.setImplicitType(fmd.getKey().getDeclaredType());\n+                    meta = fmd.getKey().getDeclaredTypeMetaData();\n+                    if (meta != null) {\n+                        val2.setMetaData(meta);\n+                        addAccessPath(meta);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the implicit type of the given value to the given class.\n+     */\n+    protected static void setImplicitType(Value val, Class expected) {\n+        // we never expect a pc type, so no need to worry about metadata\n+        if (val.getType() == TYPE_OBJECT)\n+            val.setImplicitType(expected);\n+    }\n+\n+    /**\n+     * Used for obtaining the {@link Localizer} to use for translating\n+     * error messages.\n+     */\n+    protected abstract Localizer getLocalizer();\n+\n+    /**\n+     * Returns the current string being parsed; used for error messages.\n+\t */\n+\tprotected abstract String currentQuery ();\n+}\n+"},{"sha":"58e450b083caad6e0b26ebb10b0b91535ae88b0d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionVisitor.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionVisitor.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionVisitor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionVisitor.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+\n+/**\n+ * No-op abstract visitor meant for easy extension.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public abstract class AbstractExpressionVisitor \n+    implements ExpressionVisitor {\n+\n+    public void enter(Expression exp) {\n+    }\n+\n+    public void exit(Expression exp) {\n+    }\n+\n+    public void enter(Value val) {\n+    }\n+\n+    public void exit(Value val) {\n+    }\n+}"},{"sha":"1c55aa234a52d6b8de78f7f611aaa21d9308bc4f","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Add.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Add.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Add.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Add.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.Filters;\n+\n+/**\n+ * Value produced by two values being added together.\n+ *\n+ * @author Abe White\n+ */\n+class Add\n+    extends MathVal {\n+\n+    /**\n+     * Constructor. Provide the values to add.\n+     */\n+    public Add(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    protected Object operate(Object o1, Class c1, Object o2, Class c2) {\n+        return Filters.add(o1, c1, o2, c2);\n+    }\n+}"},{"sha":"781fb81689cd5a9c85c11650bbaea5350944e7f6","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Aggregate.java","status":"added","additions":97,"deletions":0,"changes":97,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Aggregate.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Aggregate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Aggregate.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * A value produced from evaluating a result aggregate.\n+ *\n+ * @author Abe White\n+ */\n+class Aggregate\n+    extends Val {\n+\n+    private static final Localizer _loc = Localizer.forPackage(Aggregate.class);\n+\n+    private final AggregateListener _listener;\n+    private final Val _arg;\n+\n+    /**\n+     * Constructor. Supply aggregate listener and its argument value, if any.\n+     */\n+    public Aggregate(AggregateListener listener, Val arg) {\n+        _listener = listener;\n+        _arg = arg;\n+    }\n+\n+    public boolean isAggregate() {\n+        return true;\n+    }\n+\n+    public Class getType() {\n+        return _listener.getType(getArgTypes());\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        if (candidate == null)\n+            candidate = Collections.EMPTY_LIST;\n+\n+        // allow aggregates to be used in filter expressions so long as a\n+        // collection is passed in\n+        if (candidate instanceof Collection)\n+            return eval((Collection) candidate, orig, ctx, params).\n+                iterator().next();\n+        throw new UserException(_loc.get(\"agg-in-filter\"));\n+    }\n+\n+    protected Collection eval(Collection candidates, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Collection args = null;\n+        if (_arg != null)\n+            args = _arg.eval(candidates, orig, ctx, params);\n+        Object agg = _listener.evaluate(args, getArgTypes(), candidates,\n+            ctx);\n+        return Collections.singleton(agg);\n+    }\n+\n+    private Class[] getArgTypes() {\n+        if (_arg == null)\n+            return null;\n+        if (_arg instanceof Args)\n+            return ((Args) _arg).getTypes();\n+        return new Class[]{ _arg.getType() };\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        if (_arg != null)\n+            _arg.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}"},{"sha":"c2051de123fb6b5c805944e02b0422a211e697ab","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateListener.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateListener.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateListener.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * An aggregate listener aggregates data produced by an ExpressionQuery.\n+ *\n+ * @author Abe White\n+ * @author Patrick Linskey\n+ */\n+public interface AggregateListener\n+    extends Serializable {\n+\n+    /**\n+     * Return the tag that this listener listens for.\n+     */\n+    public String getTag();\n+\n+    /**\n+     * Return whether this function expects to act on arguments. Some\n+     * function may not need arguments; for example, a function to count the\n+     * number of objects that match a given filter might be of the form:\n+     * <code>count()</code>.\n+     */\n+    public boolean expectsArguments();\n+\n+    /**\n+     * Return the value of this aggregate.\n+     *\n+     * @param args for each candidate, the value of the arguments to\n+     * the function; will be null if this aggregate does\n+     * not expect an argument; if this function has\n+     * multiple arguments, each element will be an array\n+     * @param argClasses the expected class of each argument element\n+     * @param candidates the candidate objects being evaluated\n+     * @param ctx the persistence context\n+     * @return the value of the aggregate\n+     * @throws org.apache.openjpa.util.UserException if this aggregate does not \n+     * support in-memory operation\n+     */\n+    public Object evaluate(Collection args, Class[] argClasses,\n+        Collection candidates, StoreContext ctx);\n+\n+    /**\n+     * Return the expected type of the result of this listener.\n+     *\n+     * @param argClasses the expected classes of the argument, or null if\n+     * no arguments\n+     */\n+    public Class getType(Class[] argClasses);\n+}"},{"sha":"743db4d0e51f673e5ed8229a93bb2b8e2fc63a31","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateVal.java","status":"added","additions":93,"deletions":0,"changes":93,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateVal.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateVal.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AggregateVal.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * An aggregate of some value.\n+ *\n+ * @author Abe White\n+ */\n+abstract class AggregateVal\n+    extends Val {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (AggregateVal.class);\n+\n+    private final Val _val;\n+\n+    /**\n+     * Constructor. Supply value to aggregate.\n+     */\n+    public AggregateVal(Val val) {\n+        _val = val;\n+    }\n+\n+    public boolean isAggregate() {\n+        return true;\n+    }\n+\n+    public Class getType() {\n+        return getType(_val.getType());\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        if (candidate == null)\n+            candidate = Collections.EMPTY_LIST;\n+\n+        // allow aggregates to be used in filter expressions so long as a\n+        // collection is passed in\n+        if (candidate instanceof Collection)\n+            return eval((Collection) candidate, orig, ctx, params).\n+                iterator().next();\n+        throw new UserException(_loc.get(\"agg-in-filter\"));\n+    }\n+\n+    protected Collection eval(Collection candidates, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Collection args = _val.eval(candidates, orig, ctx, params);\n+        return Collections.singleton(operate(args, _val.getType()));\n+    }\n+\n+    /**\n+     * Return the type of this aggregate based on the value type.\n+     */\n+    protected abstract Class getType(Class c);\n+\n+    /**\n+     * Aggregate the given values.\n+     */\n+    protected abstract Object operate(Collection os, Class c);\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}"},{"sha":"fd3994febfe15e1e9ee36cc5f5807c64d900a9ee","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/All.java","status":"added","additions":59,"deletions":0,"changes":59,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/All.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/All.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/All.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.UnsupportedException;\n+\n+/**\n+ * In-memory All implementation. Currently unsupported since\n+ * in-memory subqueries are not supported.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class All\n+    extends UnaryMathVal {\n+\n+    private static final Localizer _loc = Localizer.forPackage(All.class);\n+\n+    public All(Val val) {\n+        super(val);\n+    }\n+\n+    protected Class getType(Class c) {\n+        Class wrap = Filters.wrap(c);\n+        if (wrap == Integer.class\n+            || wrap == Float.class\n+            || wrap == Double.class\n+            || wrap == Long.class\n+            || wrap == BigDecimal.class\n+            || wrap == BigInteger.class)\n+            return c;\n+        return int.class;\n+    }\n+\n+    protected Object operate(Object o, Class c) {\n+        throw new UnsupportedException(_loc.get(\"in-mem-subquery\"));\n+    }\n+}\n+"},{"sha":"4d98db4be9a2af9d4d4e78f778bb8e8b494abad4","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AndExpression.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AndExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AndExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AndExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * An expression that AND's two others together.\n+ *\n+ * @author Abe White\n+ */\n+class AndExpression\n+    extends Exp {\n+\n+    private final Exp _exp1;\n+    private final Exp _exp2;\n+\n+    /**\n+     * Constructor. Supply expressions to combine.\n+     */\n+    public AndExpression(Exp exp1, Exp exp2) {\n+        _exp1 = exp1;\n+        _exp2 = exp2;\n+    }\n+\n+    public Exp getExpression1() {\n+        return _exp1;\n+    }\n+\n+    public Exp getExpression2() {\n+        return _exp2;\n+    }\n+\n+    protected boolean eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        return _exp1.evaluate(candidate, orig, ctx, params)\n+            && _exp2.evaluate(candidate, orig, ctx, params);\n+    }\n+\n+    protected boolean eval(Collection candidates, StoreContext ctx,\n+        Object[] params) {\n+        return _exp1.evaluate(candidates, ctx, params)\n+            && _exp2.evaluate(candidates, ctx, params);\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _exp1.acceptVisit(visitor);\n+        _exp2.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}\n+"},{"sha":"7e7f05fce18323b86dec5fd78d7fc3e08bce15bc","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Any.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Any.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Any.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Any.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.UnsupportedException;\n+\n+/**\n+ * In-memory Any implementation. Currently unsupported since\n+ * in-memory subqueries are not supported.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class Any\n+    extends UnaryMathVal {\n+\n+    private static final Localizer _loc = Localizer.forPackage(Any.class);\n+\n+    public Any(Val val) {\n+        super(val);\n+    }\n+\n+    protected Class getType(Class c) {\n+        Class wrap = Filters.wrap(c);\n+        if (wrap == Integer.class\n+            || wrap == Float.class\n+            || wrap == Double.class\n+            || wrap == Long.class\n+            || wrap == BigDecimal.class\n+            || wrap == BigInteger.class)\n+            return c;\n+        return int.class;\n+    }\n+\n+    protected Object operate(Object o, Class c) {\n+        throw new UnsupportedException(_loc.get(\"in-mem-subquery\"));\n+    }\n+}"},{"sha":"55758b405953c345741e81314fd3808e472370d0","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Args.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Args.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Args.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Args.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * A list of arguments to a multi-argument function.\n+ *\n+ * @author Abe White\n+ */\n+class Args\n+    extends Val\n+    implements Arguments {\n+\n+    private final List _args = new ArrayList(3);\n+\n+    /**\n+     * Constructor. Supply values being combined.\n+     */\n+    public Args(Value val1, Value val2) {\n+        if (val1 instanceof Args)\n+            _args.addAll(((Args) val1)._args);\n+        else\n+            _args.add(val1);\n+        if (val2 instanceof Args)\n+            _args.addAll(((Args) val2)._args);\n+        else\n+            _args.add(val2);\n+    }\n+\n+    public Value[] getValues() {\n+        return (Value[]) _args.toArray(new Value[_args.size()]);\n+    }\n+\n+    public Class getType() {\n+        return Object[].class;\n+    }\n+\n+    public Class[] getTypes() {\n+        Class[] c = new Class[_args.size()];\n+        for (int i = 0; i < _args.size(); i++)\n+            c[i] = ((Val) _args.get(i)).getType();\n+        return c;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Object[] vals = new Object[_args.size()];\n+        for (int i = 0; i < _args.size(); i++)\n+            vals[i] = ((Val) _args.get(i)).eval(candidate, orig, ctx, params);\n+        return vals;\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        for (int i = 0; i < _args.size(); i++)\n+            ((Val) _args.get(i)).acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}"},{"sha":"4a5c066379edf810001fbf69c834978352693fe2","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Arguments.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Arguments.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Arguments.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Arguments.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+/**\n+ * Multiple arguments to a function call.\n+ *\n+ * @author Abe White\n+ */\n+public interface Arguments\n+    extends Value {\n+\n+    /**\n+     * Return the values that make up the arguments.\n+     */\n+    public Value[] getValues();\n+}"},{"sha":"309e446991ba3eb41bcdea767ca77a04c9de6bab","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Avg.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Avg.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Avg.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Avg.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.openjpa.kernel.Filters;\n+import serp.util.Numbers;\n+\n+/**\n+ * Average values.\n+ *\n+ * @author Abe White\n+ */\n+class Avg\n+    extends AggregateVal {\n+\n+    /**\n+     * Constructor. Provide the value to average.\n+     */\n+    public Avg(Val val) {\n+        super(val);\n+    }\n+\n+    protected Class getType(Class c) {\n+        return c;\n+    }\n+\n+    protected Object operate(Collection os, Class c) {\n+        if (os.isEmpty())\n+            return null;\n+\n+        Object sum = Filters.convert(Numbers.valueOf(0), c);\n+        Object cur;\n+        int size = 0;\n+        for (Iterator itr = os.iterator(); itr.hasNext();) {\n+            cur = itr.next();\n+            if (cur == null)\n+                continue;\n+\n+            sum = Filters.add(sum, c, cur, c);\n+            size++;\n+        }\n+        if (size == 0)\n+            return null;\n+        return Filters.divide(sum, c, Numbers.valueOf(size), int.class);\n+    }\n+}"},{"sha":"749bd8aac98886b4045a8820fb621214077d7ea3","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindKeyVariableExpression.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindKeyVariableExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindKeyVariableExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindKeyVariableExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+/**\n+ * {@link BindVariableExpression} for map key sets.\n+ *\n+ * @author Abe White\n+ */\n+class BindKeyVariableExpression\n+    extends BindVariableExpression {\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param var the bound variable\n+     * @param val the value the variable is bound to\n+     */\n+    public BindKeyVariableExpression(BoundVariable var, Val val) {\n+        super(var, val);\n+    }\n+\n+    protected Collection getCollection(Object values) {\n+        Map map = (Map) values;\n+        return (map == null) ? null : map.keySet();\n+    }\n+}\n+"},{"sha":"1dcfe0b739f64e0092bfccabf08fd8f8f107101e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindValueVariableExpression.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindValueVariableExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindValueVariableExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindValueVariableExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+/**\n+ * {@link BindVariableExpression} for map value collections.\n+ *\n+ * @author Abe White\n+ */\n+class BindValueVariableExpression\n+    extends BindVariableExpression {\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param var the bound variable\n+     * @param val the value the variable is bound to\n+     */\n+    public BindValueVariableExpression(BoundVariable var, Val val) {\n+        super(var, val);\n+    }\n+\n+    protected Collection getCollection(Object values) {\n+        Map map = (Map) values;\n+        return (map == null) ? null : map.values();\n+    }\n+}\n+"},{"sha":"bea88b186ff9386f3d26ccc3aa4da17738360459","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableAndExpression.java","status":"added","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableAndExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableAndExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableAndExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Any contains(var) expression must be followed by at least one\n+ * AND clause using the variable 'var'. This expression type represents\n+ * one of those and AND clauses. It is responsible for evaluating the\n+ * right subexpression for every possible value of the variable.\n+ *\n+ * @author Abe White\n+ */\n+class BindVariableAndExpression\n+    extends AndExpression {\n+\n+    /**\n+     * Constructor. Provide expression binding the variable and the\n+     * expression it is AND'd with.\n+     */\n+    public BindVariableAndExpression(BindVariableExpression var, Exp exp) {\n+        super(var, exp);\n+    }\n+\n+    protected boolean eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        // execute the tree for every element in the variable's collection;\n+        // the variable is aliased to the current element before each\n+        // iteration so that variable paths within the tree can\n+        // use the current value; the expression is true if true for any\n+        // value of the collection\n+\n+        // if the collection is empty it cannot contain any variable\n+        BindVariableExpression bind = (BindVariableExpression)\n+            getExpression1();\n+        Collection vals = bind.getVariableValues(candidate, orig, ctx,\n+            params);\n+        if (vals == null || vals.isEmpty())\n+            return false;\n+\n+        // the subtree is true if true for any variable in the collection\n+        BoundVariable var = bind.getVariable();\n+        for (Iterator itr = vals.iterator(); itr.hasNext();) {\n+            if (!var.setValue(itr.next()))\n+                continue;\n+            if (getExpression2().evaluate(candidate, orig, ctx, params))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    protected boolean eval(Collection candidates, StoreContext ctx,\n+        Object[] params) {\n+        if (candidates == null || candidates.isEmpty())\n+            return false;\n+        Object obj = candidates.iterator().next();\n+        return eval(obj, obj, ctx, params);\n+    }\n+}"},{"sha":"4db9f4cc0affc68f0fa61da3f303a2ec04a3b85e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableExpression.java","status":"added","additions":93,"deletions":0,"changes":93,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BindVariableExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Binds a variable to a collection.\n+ *\n+ * @author Abe White\n+ */\n+class BindVariableExpression\n+    extends Exp {\n+\n+    private final BoundVariable _var;\n+    private final Val _val;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param var the bound variable\n+     * @param val the value the variable is bound to\n+     */\n+    public BindVariableExpression(BoundVariable var, Val val) {\n+        _var = var;\n+        _val = val;\n+    }\n+\n+    public BoundVariable getVariable() {\n+        return _var;\n+    }\n+\n+    /**\n+     * Return the possible values that variable can take.\n+     */\n+    public Collection getVariableValues(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Object values = _val.eval(candidate, orig, ctx, params);\n+        return getCollection(values);\n+    }\n+\n+    /**\n+     * Return a collection for the given object, produced by\n+     * <code>eval</code>'ing the value of this expression. Simply casts\n+     * the object to a collection by default.\n+     */\n+    protected Collection getCollection(Object values) {\n+        return (Collection) values;\n+    }\n+\n+    protected boolean eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        // if the collection is empty no possible variable evals to true\n+        Collection vals = getVariableValues(candidate, orig, ctx, params);\n+        if (vals == null || vals.isEmpty())\n+            return false;\n+        return true;\n+    }\n+\n+    protected boolean eval(Collection candidates, StoreContext ctx,\n+        Object[] params) {\n+        if (candidates == null || candidates.isEmpty())\n+            return false;\n+        Object obj = candidates.iterator().next();\n+        return eval(obj, obj, ctx, params);\n+\t}\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _var.acceptVisit(visitor);\n+        _val.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}\n+"},{"sha":"d17bb7a0188442101b79af984c692097e27822c0","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BoundVariable.java","status":"added","additions":85,"deletions":0,"changes":85,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BoundVariable.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BoundVariable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/BoundVariable.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,85 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Represents a bound variable. Variables are aliased to the\n+ * collection that is stated to contain them in the query.\n+ * When the query is evaluated, expressions containing variables will be\n+ * executed once for every element in the collection.\n+ *\n+ * @author Abe White\n+ */\n+class BoundVariable\n+    extends Val {\n+\n+    private Class _type = null;\n+    private Object _val = null;\n+\n+    /**\n+     * Constructor. Provide variable name and type.\n+     */\n+    public BoundVariable(Class type) {\n+        _type = type;\n+    }\n+\n+    /**\n+     * Set the value this variable should take for the current iteration.\n+     *\n+     * @return false if the type is incompatible with the variable's\n+     * declared type\n+     */\n+    public boolean setValue(Object value) {\n+        if (value != null && !_type.isAssignableFrom(value.getClass()))\n+            return false;\n+        _val = value;\n+        return true;\n+    }\n+\n+    public boolean isVariable() {\n+        return true;\n+    }\n+\n+    public Class getType() {\n+        return _type;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _type = type;\n+    }\n+\n+    /**\n+     * Cast this value to the given type.\n+     */\n+    public void castTo(Class type) {\n+        // incompatible types?\n+        if (!_type.isAssignableFrom(type)\n+            && !type.isAssignableFrom(_type))\n+            throw new ClassCastException(_type.getName());\n+        _type = type;\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        return _val;\n+\t}\n+}\n+"},{"sha":"8d89e01e52f9fc0dd374f75b38b3031de96d0ff0","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","status":"added","additions":199,"deletions":0,"changes":199,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.lang.ObjectUtils;\n+import org.apache.openjpa.kernel.Broker;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.XMLMetaData;\n+import org.apache.openjpa.util.ImplHelper;\n+\n+/**\n+ * A path represents a traversal into fields of a candidate object.\n+ *\n+ * @author Abe White\n+ */\n+class CandidatePath\n+    extends Val\n+    implements Path {\n+\n+    private LinkedList _actions = null;\n+\n+    /**\n+     * Traverse into the given field of the current object, and update\n+     * the current object to that field value.\n+     */\n+    public void get(FieldMetaData field, boolean nullTraversal) {\n+        if (_actions == null)\n+            _actions = new LinkedList();\n+        _actions.add(new Traversal(field, nullTraversal));\n+    }\n+\n+    public Class getType() {\n+        if (_actions == null)\n+            return getCandidateType();\n+\n+        Object last = _actions.getLast();\n+        if (last instanceof Class)\n+            return (Class) last;\n+        FieldMetaData fmd = ((Traversal) last).field;\n+        return fmd.getDeclaredType();\n+    }\n+\n+    protected Class getCandidateType() {\n+        ClassMetaData meta = getMetaData();\n+        if (meta == null)\n+            return Object.class;\n+        return meta.getDescribedType();\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    public FieldMetaData last() {\n+        if (_actions == null)\n+            return null;\n+\n+        ListIterator itr = _actions.listIterator(_actions.size());\n+        Object prev;\n+        while (itr.hasPrevious()) {\n+            prev = itr.previous();\n+            if (prev instanceof Traversal)\n+                return ((Traversal) prev).field;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Cast this path to the given type.\n+     */\n+    public void castTo(Class type) {\n+        if (_actions == null)\n+            _actions = new LinkedList();\n+        _actions.add(type);\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        if (_actions == null)\n+            return candidate;\n+\n+        Object action;\n+        OpenJPAStateManager sm;\n+        Broker tmpBroker = null;\n+        for (Iterator itr = _actions.iterator(); itr.hasNext();) {\n+            action = itr.next();\n+\n+            // fail on null value\n+            if (candidate == null) {\n+                if (action instanceof Traversal\n+                    && ((Traversal) action).nullTraversal)\n+                    return null;\n+                throw new NullPointerException();\n+            }\n+\n+            // check that the cast is valid\n+            if (action instanceof Class) {\n+                candidate = Filters.convert(candidate, (Class) action);\n+                continue;\n+            }\n+\n+            // make sure we can access the instance; even non-pc vals might\n+            // be proxyable\n+            sm = null;\n+            tmpBroker = null;\n+            if (ImplHelper.isManageable(candidate))\n+                sm = (OpenJPAStateManager) (ImplHelper.toPersistenceCapable(\n+                    candidate, ctx.getConfiguration())).\n+                    pcGetStateManager();\n+            if (sm == null) {\n+                tmpBroker = ctx.getBroker();\n+                tmpBroker.transactional(candidate, false, null);\n+                sm = tmpBroker.getStateManager(candidate);\n+            }\n+\n+            try {\n+                // get the specified field value and switch candidate\n+                Traversal traversal = (Traversal) action;\n+                candidate = sm.fetchField(traversal.field.getIndex(), true);\n+            } finally {\n+                // transactional does not clear the state, which is\n+                // important since tmpCandidate might be also managed by\n+                // another broker if it's a proxied non-pc instance\n+                if (tmpBroker != null)\n+                    tmpBroker.nontransactional(sm.getManagedInstance(), null);\n+            }\n+        }\n+        return candidate;\n+    }\n+\n+    public int hashCode() {\n+        return (_actions == null) ? 0 : _actions.hashCode();\n+    }\n+\n+    public boolean equals(Object other) {\n+        if (other == this)\n+            return true;\n+        if (!(other instanceof CandidatePath))\n+            return false;\n+        return ObjectUtils.equals(_actions, ((CandidatePath) other)._actions);\n+    }\n+\n+    /**\n+     * Represents a traversal through a field.\n+     */\n+    private static class Traversal {\n+\n+        public final FieldMetaData field;\n+        public final boolean nullTraversal;\n+\n+        private Traversal(FieldMetaData field, boolean nullTraversal) {\n+            this.field = field;\n+            this.nullTraversal = nullTraversal;\n+        }\n+\n+        public int hashCode() {\n+            return field.hashCode();\n+        }\n+\n+        public boolean equals(Object other) {\n+            if (other == this)\n+                return true;\n+            return ((Traversal) other).field.equals(field);\n+        }\n+\t}\n+\n+    public void get(FieldMetaData fmd, XMLMetaData meta) {\n+    }\n+    \n+    public void get(XMLMetaData meta, String name) {\n+    }\n+    \n+    public XMLMetaData getXmlMapping() {\n+        return null;\n+    }\n+}"},{"sha":"f74600c1d0de6a25406373d14b4a439365c3d491","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Cast.java","status":"added","additions":76,"deletions":0,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Cast.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Cast.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Cast.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Represents a cast.\n+ *\n+ * @author Abe White\n+ */\n+class Cast\n+    extends Val {\n+\n+    private final Val _val;\n+    private final Class _cast;\n+\n+    /**\n+     * Constructor. Provide value to cast and type to cast to.\n+     */\n+    public Cast(Val val, Class cast) {\n+        _val = val;\n+        _cast = cast;\n+    }\n+\n+    public Class getType() {\n+        return _cast;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        return Filters.convert(_val.eval(candidate, orig, ctx, params), _cast);\n+    }\n+\n+    protected Collection eval(Collection candidates, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Collection res = _val.eval(candidates, orig, ctx, params);\n+        if (res == null || res.isEmpty())\n+            return res;\n+\n+        Collection casts = new ArrayList(res.size());\n+        for (Iterator itr = res.iterator(); itr.hasNext();)\n+            casts.add(Filters.convert(itr.next(), _cast));\n+        return casts;\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}"},{"sha":"dea2c060134d0f52e7e117855c82dc0204ff10aa","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CompareExpression.java","status":"added","additions":85,"deletions":0,"changes":85,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CompareExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CompareExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CompareExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,85 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Expression that compares two others.\n+ *\n+ * @author Abe White\n+ */\n+abstract class CompareExpression\n+    extends Exp {\n+\n+    private final Val _val1;\n+    private final Val _val2;\n+\n+    /**\n+     * Constructor. Supply values to compare.\n+     */\n+    public CompareExpression(Val val1, Val val2) {\n+        _val1 = val1;\n+        _val2 = val2;\n+    }\n+\n+    protected boolean eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Object o1 = _val1.eval(candidate, orig, ctx, params);\n+        Object o2 = _val2.eval(candidate, orig, ctx, params);\n+        if (o1 != null && o2 != null) {\n+            Class c = Filters.promote(o1.getClass(), o2.getClass());\n+            o1 = Filters.convert(o1, c);\n+            o2 = Filters.convert(o2, c);\n+        }\n+        return compare(o1, o2);\n+    }\n+\n+    protected boolean eval(Collection candidates, StoreContext ctx,\n+        Object[] params) {\n+        Collection c1 = _val1.eval(candidates, null, ctx, params);\n+        Collection c2 = _val2.eval(candidates, null, ctx, params);\n+        Object o1 = (c1 == null || c1.isEmpty()) ? null\n+            : c1.iterator().next();\n+        Object o2 = (c2 == null || c2.isEmpty()) ? null\n+            : c2.iterator().next();\n+\n+        if (o1 != null && o2 != null) {\n+            Class c = Filters.promote(o1.getClass(), o2.getClass());\n+            o1 = Filters.convert(o1, c);\n+            o2 = Filters.convert(o2, c);\n+        }\n+        return compare(o1, o2);\n+    }\n+\n+    /**\n+     * Compare the two values.\n+     */\n+    protected abstract boolean compare(Object o1, Object o2);\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val1.acceptVisit(visitor);\n+        _val2.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}"},{"sha":"5f2aa5c5b6cde196e39ea298d9cdfc68e6666500","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Concat.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Concat.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Concat.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Concat.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Concatenate two strings together.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class Concat\n+    extends Val {\n+\n+    private final Val _val;\n+    private final Val _args;\n+\n+    /**\n+     * Constructor. Provide target string and the arguments to the\n+     * indexOf method.\n+     */\n+    public Concat(Val val, Val args) {\n+        _val = val;\n+        _args = args;\n+    }\n+\n+    public Class getType() {\n+        return String.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Object str = _val.eval(candidate, orig, ctx, params);\n+        StringBuffer cat = new StringBuffer(str.toString());\n+\n+        Object arg = _args.eval(candidate, orig, ctx, params);\n+        if (arg instanceof Object[]) {\n+            for (int i = 0; i < ((Object[]) arg).length; i++)\n+                cat.append((((Object[]) arg)[i]).toString());\n+        } else\n+            cat.append(arg.toString());\n+\n+        return cat.toString();\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val.acceptVisit(visitor);\n+        _args.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}\n+"},{"sha":"4ba82047756bc1b3b2006c76c72634303e9149d7","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Constant.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Constant.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Constant.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Constant.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+/**\n+ * Interface for any query constant value.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+public interface Constant {\n+\n+    /**\n+     * Return the value for this constant given the specified parameters.\n+     */\n+    public Object getValue(Object[] parameters);\n+}\n+"},{"sha":"45ce2d84953c381c7aff6392e6e7bfabb8791b5d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsExpression.java","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Tests that a Collection contains a value.\n+ *\n+ * @author Abe White\n+ */\n+class ContainsExpression\n+    extends Exp {\n+\n+    private final Val _val1;\n+    private final Val _val2;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param val1 the container value\n+     * @param val2 the containee to test\n+     */\n+    public ContainsExpression(Val val1, Val val2) {\n+        _val1 = val1;\n+        _val2 = val2;\n+    }\n+\n+    protected boolean eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Object obj = _val1.eval(candidate, orig, ctx, params);\n+        Collection coll = getCollection(obj);\n+        return coll != null && !coll.isEmpty()\n+            && coll.contains(_val2.eval(candidate, orig, ctx, params));\n+    }\n+\n+    protected boolean eval(Collection candidates, StoreContext ctx,\n+        Object[] params) {\n+        Collection coll = _val1.eval(candidates, null, ctx, params);\n+        if (coll == null || coll.isEmpty())\n+            return false;\n+        coll = getCollection(coll.iterator().next());\n+        if (coll == null || coll.isEmpty())\n+            return false;\n+\n+        Collection coll2 = _val2.eval(candidates, null, ctx, params);\n+        if (coll2 == null || coll2.isEmpty())\n+            return false;\n+        return coll.contains(coll2.iterator().next());\n+    }\n+\n+    /**\n+     * Return the container collection for the given value.\n+     */\n+    protected Collection getCollection(Object obj) {\n+        return obj instanceof Collection ?\n+            (Collection) obj : Collections.singleton(obj);\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val1.acceptVisit(visitor);\n+        _val2.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}\n+"},{"sha":"5ed62322d2aedc9845126b8eabc7d54b2450df4f","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsKeyExpression.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsKeyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsKeyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsKeyExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+/**\n+ * Tests that a Map key set contains a value.\n+ *\n+ * @author Abe White\n+ */\n+class ContainsKeyExpression\n+    extends ContainsExpression {\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param val1 the container value\n+     * @param val2 the containee to test\n+     */\n+    public ContainsKeyExpression(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    protected Collection getCollection(Object obj) {\n+        return (obj == null) ? null : ((Map) obj).keySet();\n+    }\n+}\n+"},{"sha":"e58061942ddc6aab63a8de2974f2e873f87d28e5","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsValueExpression.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsValueExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsValueExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ContainsValueExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+/**\n+ * Tests that a Map value collection contains a value.\n+ *\n+ * @author Abe White\n+ */\n+class ContainsValueExpression\n+    extends ContainsExpression {\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param val1 the container value\n+     * @param val2 the containee to test\n+     */\n+    public ContainsValueExpression(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    protected Collection getCollection(Object obj) {\n+        return (obj == null) ? null : ((Map) obj).values();\n+    }\n+}\n+"},{"sha":"4a47fca96861c8fbcf1563a647ff56aaf1b42cc5","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Count.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Count.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Count.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Count.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import serp.util.Numbers;\n+\n+/**\n+ * Count non-null values.\n+ *\n+ * @author Abe White\n+ */\n+class Count\n+    extends AggregateVal {\n+\n+    /**\n+     * Constructor. Provide the value to count.\n+     */\n+    public Count(Val val) {\n+        super(val);\n+    }\n+\n+    protected Class getType(Class c) {\n+        return long.class;\n+    }\n+\n+    protected Object operate(Collection os, Class c) {\n+        long count = 0;\n+        for (Iterator itr = os.iterator(); itr.hasNext();)\n+            if (itr.next() != null)\n+                count++;\n+        return Numbers.valueOf(count);\n+    }\n+}"},{"sha":"5c47c4d8b2b9e0d5fc30693fbc7125fc10dc60a0","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CurrentDate.java","status":"added","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CurrentDate.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CurrentDate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CurrentDate.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Date;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Represents the current date.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class CurrentDate\n+    extends Val {\n+\n+    public Class getType() {\n+        return Date.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        return new Date();\n+    }\n+}"},{"sha":"6553a7d110b68eb2811cf4a549abb82be35f109d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Distinct.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Distinct.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Distinct.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Distinct.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * A distinct set of the specified values.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class Distinct\n+    extends Val {\n+\n+    private final Val _val;\n+\n+    /**\n+     * Constructor. Supply value to aggregate.\n+     */\n+    public Distinct(Val val) {\n+        _val = val;\n+    }\n+\n+    public Class getType() {\n+        return Collection.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        if (candidate == null)\n+            candidate = Collections.EMPTY_LIST;\n+        Collection arg = candidate instanceof Collection\n+            ? (Collection) candidate : Collections.singleton(candidate);\n+        return eval(arg, orig, ctx, params).iterator().next();\n+    }\n+\n+    protected Collection eval(Collection candidates, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Collection args = _val.eval(candidates, orig, ctx, params);\n+        return new HashSet(args);\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}\n+"},{"sha":"49e58cf637576326df663d95d0cdb47484bb5d0b","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Divide.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Divide.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Divide.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Divide.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.Filters;\n+\n+/**\n+ * Value produced by one value being divided by another.\n+ *\n+ * @author Abe White\n+ */\n+class Divide\n+    extends MathVal {\n+\n+    /**\n+     * Constructor. Provide the values to divide.\n+     */\n+    public Divide(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    protected Object operate(Object o1, Class c1, Object o2, Class c2) {\n+        return Filters.divide(o1, c1, o2, c2);\n+    }\n+}\n+"},{"sha":"aff7b0585fddf0d41bea8952275df0e27d18a581","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EndsWithExpression.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EndsWithExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EndsWithExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EndsWithExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+/**\n+ * Expression that compares two others.\n+ *\n+ * @author Abe White\n+ */\n+class EndsWithExpression\n+    extends CompareExpression {\n+\n+    /**\n+     * Constructor. Supply values to compare.\n+     */\n+    public EndsWithExpression(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    protected boolean compare(Object o1, Object o2) {\n+        if (o1 == null || o2 == null)\n+            return false;\n+        return o1.toString().endsWith(o2.toString());\n+    }\n+}"},{"sha":"1e2d311fb2803bfd8f7e7f7eacc6eabd9b1e66eb","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EqualExpression.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/EqualExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+/**\n+ * Expression that compares two others.\n+ *\n+ * @author Abe White\n+ */\n+class EqualExpression\n+    extends CompareExpression {\n+\n+    /**\n+     * Constructor. Supply values to compare.\n+     */\n+    public EqualExpression(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    protected boolean compare(Object o1, Object o2) {\n+        return (o1 == null && o2 == null)\n+            || (o1 != null && o1.equals(o2));\n+    }\n+}\n+"},{"sha":"c2a134e6c358ecb8039ec9b1c8341eb73346108a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Exp.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Exp.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Exp.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Exp.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * An in-memory representation of an {@link Expression}.\n+ *\n+ * @author Abe White\n+ */\n+class Exp\n+    implements Expression {\n+\n+    /**\n+     * Evaluate the expression for the given candidate.\n+     */\n+    public final boolean evaluate(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        try {\n+            return eval(candidate, candidate, ctx, params);\n+        } catch (ClassCastException cce) {\n+            return false;\n+        } catch (NullPointerException npe) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Evaluate the expression for the given candidate group.\n+     */\n+    public final boolean evaluate(Collection candidates,\n+        StoreContext ctx, Object[] params) {\n+        try {\n+            return eval(candidates, ctx, params);\n+        } catch (ClassCastException cce) {\n+            return false;\n+        } catch (NullPointerException npe) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Evaluate the expression for the given context candidate and original\n+     * candidate.\n+     */\n+    protected boolean eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        return true;\n+    }\n+\n+    /**\n+     * Evaluate the expression for the given group.\n+     */\n+    protected boolean eval(Collection candidates, StoreContext ctx,\n+        Object[] params) {\n+        return true;\n+\t}\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        visitor.exit(this);\n+    }\n+}"},{"sha":"5fd16b1c09636a8297c2078e04d5960a8519b5b1","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Expression.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Expression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Expression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Expression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,36 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Interface for a set of conditions that must be met for the query\n+ * to be true.\n+ *\n+ * @author Abe White\n+ */\n+public interface Expression\n+    extends Serializable {\n+\n+    /**\n+     * Accept a visit from a tree visitor.\n+     */\n+    public void acceptVisit(ExpressionVisitor visitor);\n+}"},{"sha":"58071387729de53b9a33912b8b29850b2864c6c9","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionFactory.java","status":"added","additions":410,"deletions":0,"changes":410,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionFactory.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionFactory.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,410 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * The ExpressionFactory must be implemented by a particular runtime\n+ * to form {@link Expression}s in its native query language.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public interface ExpressionFactory {\n+\n+    /**\n+     * Return a blank expression; this is used when the filter is empty.\n+     */\n+    public Expression emptyExpression();\n+\n+    /**\n+     * Return the given value as an expression.\n+     */\n+    public Expression asExpression(Value bool);\n+\n+    /**\n+     * Return an expression representing the given condition.\n+     */\n+    public Expression equal(Value v1, Value v2);\n+\n+    /**\n+     * Return an expression representing the given condition.\n+     */\n+    public Expression notEqual(Value v1, Value v2);\n+\n+    /**\n+     * Return an expression representing the given condition.\n+     */\n+    public Expression lessThan(Value v1, Value v2);\n+\n+    /**\n+     * Return an expression representing the given condition.\n+     */\n+    public Expression greaterThan(Value v1, Value v2);\n+\n+    /**\n+     * Return an expression representing the given condition.\n+     */\n+    public Expression lessThanEqual(Value v1, Value v2);\n+\n+    /**\n+     * Return an expression representing the given condition.\n+     */\n+    public Expression greaterThanEqual(Value v1, Value v2);\n+\n+    /**\n+     * Return an expression representing the given condition.\n+     */\n+    public Expression isEmpty(Value target);\n+\n+    /**\n+     * Return an expression representing the given condition.\n+     */\n+    public Expression isNotEmpty(Value target);\n+\n+    /**\n+     * Return an expression representing the given condition.\n+     */\n+    public Expression contains(Value coll, Value arg);\n+\n+    /**\n+     * Return an expression representing the given condition.\n+     */\n+    public Expression containsKey(Value map, Value arg);\n+\n+    /**\n+     * Return an expression representing the given condition.\n+     */\n+    public Expression containsValue(Value map, Value arg);\n+\n+    /**\n+     * Return an expression representing the given condition.\n+     */\n+    public Value getMapValue(Value map, Value arg);\n+\n+    /**\n+     * Return whether the first value is an instance of the given class.\n+     */\n+    public Expression isInstance(Value obj, Class c);\n+\n+    /**\n+     * Return the two expressions AND'd together.\n+     */\n+    public Expression and(Expression exp1, Expression exp2);\n+\n+    /**\n+     * Return the two expressions OR'd together.\n+     */\n+    public Expression or(Expression exp1, Expression exp2);\n+\n+    /**\n+     * Return the inverse of this expression.\n+     */\n+    public Expression not(Expression exp);\n+\n+    /**\n+     * Bind the given variable to the given collection value.\n+     */\n+    public Expression bindVariable(Value var, Value coll);\n+\n+    /**\n+     * Bind the given variable to the key set of the given map value.\n+     */\n+    public Expression bindKeyVariable(Value var, Value map);\n+\n+    /**\n+     * Bind the given variable to the value set of the given map value.\n+     */\n+    public Expression bindValueVariable(Value var, Value map);\n+\n+    /**\n+     * Return whether the first string ends with the second.\n+     */\n+    public Expression endsWith(Value str1, Value str2);\n+\n+    /**\n+     * Return whether the string matches the matching pattern.\n+     *\n+     * @param str the value to compare\n+     * @param regexp the pattern against which to compare\n+     * @param single the token that signifies a single-character match\n+     * @param multi the token that signifies a multi-character match\n+     * @param escape the escape token that escapes the matching tokens\n+     */\n+    public Expression matches(Value str, Value regexp,\n+        String single, String multi, String escape);\n+\n+    /**\n+     * Return whether the string does not match the given pattern.\n+     *\n+     * @param str the value to compare\n+     * @param regexp the pattern against which to compare\n+     * @param single the token that signifies a single-character match\n+     * @param multi the token that signifies a multi-character match\n+     * @param escape the escape token that escapes the matching tokens\n+     */\n+    public Expression notMatches(Value str, Value regexp, String single,\n+        String multi, String escape);\n+\n+    /**\n+     * Return whether the first string starts with the second.\n+     */\n+    public Expression startsWith(Value str1, Value str2);\n+\n+    /**\n+     * Returns the number of characters in the String value.\n+     */\n+    public Value stringLength(Value str);\n+\n+    /**\n+     * Trims the specified specified trimChar from the specified value.\n+     *\n+     * @param str the value from which to trim\n+     * @param trimChar the characters to trim off\n+     * @param where which side of the String to trim: null\n+     * indicates both sides, true indicates\n+     * leading, and false indicates trailing\n+     */\n+    public Value trim(Value str, Value trimChar, Boolean where);\n+\n+    /**\n+     * Return a subquery. Paths for the candidates of the subquery are\n+     * created with {@link #newPath(Value)}, passing in the subquery as the\n+     * value.\n+     *\n+     * @param candidate the candidate class of the subquery\n+     * @param subs whether the query includes subclasses\n+     * @param alias the alias given to the query candidate class\n+     */\n+    public Subquery newSubquery(ClassMetaData candidate, boolean subs,\n+        String alias);\n+\n+    /**\n+     * Return a value representing a path which will consist\n+     * of a chain of 1 or more field names starting in the namespace of the\n+     * candidate class.<br /> Example: <code>parent.address.city</code>\n+     */\n+    public Path newPath();\n+\n+    /**\n+     * Return a value representing a path which will consist\n+     * of a chain of 1 or more field names starting in the namespace of the\n+     * given value.<br /> Example: <code>var.address.city</code>\n+     */\n+    public Path newPath(Value val);\n+\n+    /**\n+     * Return a value representing the given constant, which will be\n+     * a {@link Number}, {@link String}, or {@link Boolean} instance.\n+     */\n+    public Literal newLiteral(Object val, int parseType);\n+\n+    /**\n+     * Return a value representing <code>this</code>.\n+     */\n+    public Value getThis();\n+\n+    /**\n+     * Return a value representing null.\n+     */\n+    public Value getNull();\n+\n+    /**\n+     * Return a value representing the current date.\n+     */\n+    public Value getCurrentDate();\n+\n+    /**\n+     * Return a value representing the current time.\n+     */\n+    public Value getCurrentTime();\n+\n+    /**\n+     * Return a value representing the current timestamp.\n+     */\n+    public Value getCurrentTimestamp();\n+\n+    /**\n+     * Return a value representing a parameter for the given value. The\n+     * type may be <code>Object</code> if the parameter is not declared.\n+     */\n+    public Parameter newParameter(String name, Class type);\n+\n+    /**\n+     * Return the value of the given extension.\n+     */\n+    public Value newExtension(FilterListener listener, Value target,\n+        Value args);\n+\n+    /**\n+     * Return the value of the given function.\n+     */\n+    public Value newAggregate(AggregateListener listener, Value args);\n+\n+    /**\n+     * Return a function argument list consisting of the given values, either\n+     * of which may itself be an argument list.\n+     */\n+    public Arguments newArgumentList(Value arg1, Value arg2);\n+\n+    /**\n+     * Return an unbound variable. This method will only be called once for\n+     * a given named unbound variable. The type may be <code>Object</code>\n+     * if the variable is not declared.\n+     */\n+    public Value newUnboundVariable(String name, Class type);\n+\n+    /**\n+     * This method will be called only once per variable bound in a\n+     * <code>contains</code> clause, and the returned value will be reused\n+     * for any further instances of the variable in subexpression of the\n+     * filter string. The type may be <code>Object</code> if the variable is\n+     * not declared.\n+     */\n+    public Value newBoundVariable(String name, Class type);\n+\n+    /**\n+     * Cast the value to the given class.\n+     */\n+    public Value cast(Value obj, Class cls);\n+\n+    /**\n+     * Return a value representing the two values added together.\n+     */\n+    public Value add(Value num1, Value num2);\n+\n+    /**\n+     * Return a value representing the second value subtracted from the first.\n+     */\n+    public Value subtract(Value num1, Value num2);\n+\n+    /**\n+     * Return a value representing the two values multiplied together.\n+     */\n+    public Value multiply(Value num1, Value num2);\n+\n+    /**\n+     * Return a value representing the first value divided by the first one.\n+     */\n+    public Value divide(Value num1, Value num2);\n+\n+    /**\n+     * Return a value representing the first value mod'd by the second one.\n+     */\n+    public Value mod(Value num1, Value num2);\n+\n+    /**\n+     * Return a value representing the absolute value of the given one.\n+     */\n+    public Value abs(Value num);\n+\n+    /**\n+     * Return a value representing the {@link String#indexOf} function on\n+     * the given target with the given args.\n+     */\n+    public Value indexOf(Value str, Value args);\n+\n+    /**\n+     * Return a value representing the concatenation of\n+     * the given target with the given args.\n+     */\n+    public Value concat(Value str, Value args);\n+\n+    /**\n+     * Return the square root of the given value.\n+     */\n+    public Value sqrt(Value num);\n+\n+    /**\n+     * Return a value representing the {@link String#substring} function on\n+     * the given target with the given args. As with {@link String#substring},\n+     * the start index is zero-based, and the second argument is the end index.\n+     */\n+    public Value substring(Value str, Value args);\n+\n+    /**\n+     * Return the upper case of the given value.\n+     */\n+    public Value toUpperCase(Value str);\n+\n+    /**\n+     * Return the upper case of the given value.\n+     */\n+    public Value toLowerCase(Value str);\n+\n+    /**\n+     * Return the average of the given value for all matches.\n+     */\n+    public Value avg(Value num);\n+\n+    /**\n+     * Return the count of the given value for all matches.\n+     */\n+    public Value count(Value obj);\n+\n+    /**\n+     * Return the max of the given value for all matches.\n+     */\n+    public Value max(Value num);\n+\n+    /**\n+     * Return the max of the given value for all matches.\n+     */\n+    public Value min(Value num);\n+\n+    /**\n+     * Return the max of the given value for all matches.\n+     */\n+    public Value sum(Value num);\n+\n+    /**\n+     * Return an expression representing the given condition.\n+     *\n+     * @since 0.4.0.0\n+     */\n+    public Value any(Value target);\n+\n+    /**\n+     * Return an expression representing the given condition.\n+     *\n+     * @since 0.4.0.0\n+     */\n+    public Value all(Value target);\n+\n+    /**\n+     * Return an expression representing the given condition.\n+     *\n+     * @since 0.4.0.0\n+     */\n+    public Value size(Value target);\n+\n+    /**\n+     * Return distinct values of the given value. This is typically used\n+     * within aggregates, for example: max(distinct(path))\n+\t *\n+\t * @since 0.4.0.0\n+\t */\n+\tpublic Value distinct (Value obj);\n+\n+\t/**\n+\t * Return the object id of the given value.\n+\t */\n+\tpublic Value getObjectId (Value val);\n+}"},{"sha":"54ea1cbf2bd6be43b4bfadf770bab66d9a5cf778","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionParser.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionParser.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionParser.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.io.Serializable;\n+\n+import org.apache.openjpa.kernel.ExpressionStoreQuery;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * Parser for query languages that will be used by a {@link ExpressionQuery}.\n+ * A QueryParser is responsible for translating from some string-based query\n+ * language into {@link Expression}s. Parsers should be stateless.\n+ *\n+ * @author Marc Prud'hommeaux\n+ * @nojavadoc\n+ */\n+public interface ExpressionParser\n+    extends Serializable {\n+\n+    /**\n+     * Return a string key describing the language that this instance parses.\n+     */\n+    public String getLanguage();\n+\n+    /**\n+     * Return a parsed intermediate form of the given query string.\n+     */\n+    public Object parse(String ql, ExpressionStoreQuery query);\n+\n+    /**\n+     * Use the parsed query form to set information such as candidate type,\n+     * result type, etc that was encoded in the query string.\n+     */\n+    public void populate(Object parsed, ExpressionStoreQuery query);\n+\n+    /**\n+     * Parse the given query string.\n+     */\n+    public QueryExpressions eval(Object parsed, ExpressionStoreQuery query,\n+        ExpressionFactory factory, ClassMetaData candidate);\n+\n+    /**\n+     * Parse the given value clauses.\n+     */\n+    public Value[] eval(String[] vals, ExpressionStoreQuery query,\n+        ExpressionFactory factory, ClassMetaData candidate);\n+}"},{"sha":"8c11496f35a5e184fbe6dd691df73ccdbae7a86e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionVisitor.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionVisitor.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionVisitor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ExpressionVisitor.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+\n+/**\n+ * Visits nodes of a query expression tree.\n+ *\n+ * @author Abe White\n+ */\n+public interface ExpressionVisitor {\n+\n+    /**\n+     * Enter an expression.  The expression will then invoke visits on its\n+     * components.\n+     */\n+    public void enter(Expression exp);\n+\n+    /**\n+     * Leave an expression.\n+     */\n+    public void exit(Expression exp);\n+\n+    /**\n+     * Enter a value.  The value will then invoke visits on its components.\n+     */\n+    public void enter(Value val);\n+\n+    /**\n+     * Leave a value.\n+     */\n+    public void exit(Value val);\n+}"},{"sha":"d300587f9731b592eb37d8bc04afcb13750394a9","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Extension.java","status":"added","additions":93,"deletions":0,"changes":93,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Extension.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Extension.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Extension.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * A value produced from evaluating a custom extension.\n+ *\n+ * @author Abe White\n+ */\n+class Extension\n+    extends Val {\n+\n+    private final FilterListener _listener;\n+    private final Val _target;\n+    private final Val _arg;\n+\n+    /**\n+     * Constructor. Supply filter listener, its target value, and\n+     * its argument value, if any.\n+     */\n+    public Extension(FilterListener listener, Val target, Val arg) {\n+        _listener = listener;\n+        _target = target;\n+        _arg = arg;\n+    }\n+\n+    public Class getType() {\n+        Class targetClass = (_target == null) ? null : _target.getType();\n+        return _listener.getType(targetClass, getArgTypes());\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Object target = null;\n+        Class targetClass = null;\n+        if (_target != null) {\n+            target = _target.eval(candidate, orig, ctx, params);\n+            targetClass = _target.getType();\n+        }\n+        Object arg = null;\n+        if (_arg != null)\n+            arg = _arg.eval(candidate, orig, ctx, params);\n+        return _listener.evaluate(target, targetClass, getArgs(arg),\n+            getArgTypes(), candidate, ctx);\n+    }\n+\n+    private Class[] getArgTypes() {\n+        if (_arg == null)\n+            return null;\n+        if (_arg instanceof Args)\n+            return ((Args) _arg).getTypes();\n+        return new Class[]{ _arg.getType() };\n+    }\n+\n+    private Object[] getArgs(Object arg) {\n+        if (arg == null)\n+            return null;\n+        if (_arg instanceof Args)\n+            return (Object[]) arg;\n+        return new Object[]{ arg };\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        if (_target != null)\n+            _target.acceptVisit(visitor);\n+        if (_arg != null)\n+            _arg.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}\n+"},{"sha":"dd1ef2db81b50ba2e9c0b66f9aec6001eb18f3db","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/FilterListener.java","status":"added","additions":89,"deletions":0,"changes":89,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/FilterListener.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/FilterListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/FilterListener.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.io.Serializable;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * A filter listener extends expression filters with custom functionality.\n+ *\n+ * @author Steve Kim\n+ * @author Abe White\n+ */\n+public interface FilterListener\n+    extends Serializable {\n+\n+    /**\n+     * Return the tag that this extension listens for.\n+     */\n+    public String getTag();\n+\n+    /**\n+     * Return true if this extension expects arguments to act on. Some\n+     * extensions may not need arguments; for example, an extension to\n+     * switch a string to upper case might be of the form:\n+     * <code>field.ext:toUpperCase ()</code>.\n+     */\n+    public boolean expectsArguments();\n+\n+    /**\n+     * Return true if this extension expects a target to act on. Some\n+     * extensions act on a field or object value; others stand alone.\n+     * <code>field.ext:toUpperCase ()</code> acts on the target\n+     * <code>field</code> but has no arguments, while another possible form,\n+     * <code>ext:toUpperCase (field)</code> has no target but does have an\n+     * argument.\n+     */\n+    public boolean expectsTarget();\n+\n+    /**\n+     * Evaluate the given expression. This method is used when\n+     * evaluating in-memory expressions. The method used when evaluating\n+     * data store expressions will change depending on the data store in use.\n+     *\n+     * @param target the target object / field value to act on; will be\n+     * null if this extension does not expect a target\n+     * @param targetClass the expected class of the target; given in case\n+     * the target evaluates to null and typing is needed\n+     * @param args the values of the arguments given in the filter;\n+     * will be null if this extension does not expect an argument\n+     * @param argClasses the expected classes of the arguments; given in case\n+     * an argument evaluates to null and typing is needed\n+     * @param candidate the candidate object being evaluated\n+     * @param ctx the persistence context\n+     * @return the value of the extension for this candidate; if\n+     * this extension is an expression, this method should\n+     * return {@link Boolean#TRUE} or {@link Boolean#FALSE}\n+     * @throws org.apache.openjpa.util.UserException if this extension does not \n+     * support in-memory operation\n+     */\n+    public Object evaluate(Object target, Class targetClass, Object[] args,\n+        Class[] argClasses, Object candidate, StoreContext ctx);\n+\n+    /**\n+     * Return the expected type of the result of this listener.\n+     *\n+     * @param targetClass the expected class of the target, or null if no target\n+     * @param argClasses the expected classes of the arguments, or null if\n+     * no arguments\n+     */\n+    public Class getType(Class targetClass, Class[] argClasses);\n+}"},{"sha":"6908631968e5df45b5d140aca86e7e0280477e7a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GetMapValue.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GetMapValue.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GetMapValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GetMapValue.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Returns the value of the specified key in a Map.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class GetMapValue\n+    extends Val {\n+\n+    private final Val _map;\n+    private final Val _arg;\n+\n+    /**\n+     * Constructor. Provide value to upper-case.\n+     */\n+    public GetMapValue(Val map, Val arg) {\n+        _map = map;\n+        _arg = arg;\n+    }\n+\n+    public boolean isVariable() {\n+        return false;\n+    }\n+\n+    public Class getType() {\n+        return Object.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        return ((Map) _map.eval(candidate, orig, ctx, params)).\n+            get(_arg.eval(candidate, orig, ctx, params));\n+    }\n+}"},{"sha":"f5a5ccdfb39f104fa5c462cfb441d3661a104ab2","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GetObjectId.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GetObjectId.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GetObjectId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GetObjectId.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Get the oid of an object.\n+ *\n+ * @author Abe White\n+ */\n+class GetObjectId\n+    extends Val {\n+\n+    private final Val _val;\n+\n+    /**\n+     * Constructor. Provide value whose oid to extract.\n+     */\n+    public GetObjectId(Val val) {\n+        _val = val;\n+    }\n+\n+    public Class getType() {\n+        return Object.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        return ctx.getObjectId(_val.eval(candidate, orig, ctx, params));\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}"},{"sha":"d2e03a0b07ba2d7e7b92dd64764133e79b0067b3","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanEqualExpression.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanEqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanEqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanEqualExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+/**\n+ * Expression that compares two others.\n+ *\n+ * @author Abe White\n+ */\n+class GreaterThanEqualExpression\n+    extends CompareExpression {\n+\n+    /**\n+     * Constructor. Supply values to compare.\n+     */\n+    public GreaterThanEqualExpression(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    protected boolean compare(Object o1, Object o2) {\n+        if (!(o1 instanceof Comparable))\n+            return false;\n+        return ((Comparable) o1).compareTo(o2) >= 0;\n+    }\n+}\n+"},{"sha":"e550a1412032b264a5fbb861f0fa31e5438e9f5e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanExpression.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/GreaterThanExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+/**\n+ * Expression that compares two others.\n+ *\n+ * @author Abe White\n+ */\n+class GreaterThanExpression\n+    extends CompareExpression {\n+\n+    /**\n+     * Constructor. Supply values to compare.\n+     */\n+    public GreaterThanExpression(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    protected boolean compare(Object o1, Object o2) {\n+        if (!(o1 instanceof Comparable))\n+            return false;\n+        return ((Comparable) o1).compareTo(o2) > 0;\n+    }\n+}\n+"},{"sha":"6ffdb5ed62c9925e6847d4bff893eb59bd6d7224","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InMemoryExpressionFactory.java","status":"added","additions":728,"deletions":0,"changes":728,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InMemoryExpressionFactory.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InMemoryExpressionFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InMemoryExpressionFactory.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,728 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.ObjectUtils;\n+import org.apache.openjpa.kernel.Extent;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.util.ImplHelper;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Expression factory implementation that can be used to execute queries\n+ * in memory.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class InMemoryExpressionFactory\n+    implements ExpressionFactory {\n+\n+    private static final Value NULL = new Null();\n+    private static final Value CURRENT_DATE = new CurrentDate();\n+    private static final Object UNIQUE = new Object();\n+\n+    // list of unbound variables in this query\n+    private List _unbounds = null;\n+\n+    /**\n+     * Tests whether the given candidate matches the given type and this\n+     * expression.\n+     */\n+    public boolean matches(QueryExpressions exps, ClassMetaData type,\n+        boolean subs, Object candidate, StoreContext ctx, Object[] params) {\n+        // ignore candidates of the wrong type\n+        if (candidate == null)\n+            return false;\n+        if (!subs && candidate.getClass() != type.getDescribedType())\n+            return false;\n+        if (subs && !type.getDescribedType().isAssignableFrom\n+            (candidate.getClass()))\n+            return false;\n+\n+        // evaluate the expression for all possible combinations of values\n+        // of the unbound variables; the candidate matches if any combination\n+        // matches\n+        return matches((Exp) exps.filter, candidate, ctx, params, 0);\n+    }\n+\n+    /**\n+     * Recursive method to evaluate the expression for all possible\n+     * combinations of unbound variables. This method simulates a sequence\n+     * of embedded procedural loops over the extents of all variables in the\n+     * unbounds list.\n+     */\n+    private boolean matches(Exp exp, Object candidate, StoreContext ctx,\n+        Object[] params, int i) {\n+        // base case: all variables have been aliased; evaluate for current\n+        // values\n+        if (_unbounds == null || i == _unbounds.size())\n+            return exp.evaluate(candidate, candidate, ctx, params);\n+\n+        // grab the extent for this variable\n+        UnboundVariable var = (UnboundVariable) _unbounds.get(i);\n+        Iterator itr = ctx.extentIterator(var.getType(), true, null, false);\n+        try {\n+            // if the extent was empty, then alias the variable to null\n+            if (!itr.hasNext()) {\n+                var.setValue(null);\n+                return matches(exp, candidate, ctx, params, i + 1);\n+            }\n+\n+            // try every value, short-circuiting on match\n+            while (itr.hasNext()) {\n+                // set the variable to each extent value and recurse\n+                var.setValue(itr.next());\n+                if (matches(exp, candidate, ctx, params, i + 1))\n+                    return true;\n+            }\n+\n+            // no match\n+            return false;\n+        } finally {\n+            ImplHelper.close(itr);\n+        }\n+    }\n+\n+    /**\n+     * Group the list of matches into a list of lists.\n+     */\n+    public List group(QueryExpressions exps, List matches,\n+        StoreContext ctx, Object[] params) {\n+        if (matches == null || matches.isEmpty() || exps.grouping.length == 0)\n+            return matches;\n+\n+        // to form groups we first order on the grouping criteria\n+        matches = order(exps, exps.grouping, false, matches, ctx, params);\n+\n+        // now we combine all results whose values for each grouping clause\n+        // are the same, relying on the fact that these values will already be\n+        // together due to the sorting\n+        Object[] prevs = new Object[exps.grouping.length];\n+        Arrays.fill(prevs, UNIQUE);\n+        Object[] curs = new Object[exps.grouping.length];\n+        List grouped = new ArrayList();\n+        List group = null;\n+        Object pc;\n+        boolean eq;\n+        for (Iterator itr = matches.iterator(); itr.hasNext();) {\n+            pc = itr.next();\n+            eq = true;\n+            for (int i = 0; i < exps.grouping.length; i++) {\n+                curs[i] = ((Val) exps.grouping[i]).evaluate(pc, pc, ctx,\n+                    params);\n+                eq = eq && ObjectUtils.equals(prevs[i], curs[i]);\n+            }\n+\n+            // if this object's grouping values differ from the prev,\n+            // start a new group\n+            if (!eq) {\n+                if (group != null)\n+                    grouped.add(group);\n+                group = new ArrayList();\n+            }\n+            group.add(pc);\n+            System.arraycopy(curs, 0, prevs, 0, curs.length);\n+        }\n+        // add the last group formed\n+        if (group != null)\n+            grouped.add(group);\n+\n+        return grouped;\n+    }\n+\n+    /**\n+     * Return true if the given group matches the having expression.\n+     */\n+    public boolean matches(QueryExpressions exps, Collection group,\n+        StoreContext ctx, Object[] params) {\n+        if (group == null || group.isEmpty())\n+            return false;\n+        if (exps.having == null)\n+            return true;\n+\n+        // evaluate the expression for all possible combinations of values\n+        // of the unbound variables; the group matches if any combination\n+        // matches\n+        return matches((Exp) exps.having, group, ctx, params, 0);\n+    }\n+\n+    /**\n+     * Recursive method to evaluate the expression for all possible\n+     * combinations of unbound variables. This method simulates a sequence\n+     * of embedded procedural loops over the extents of all variables in the\n+     * unbounds list.\n+     */\n+    private boolean matches(Exp exp, Collection group, StoreContext ctx,\n+        Object[] params, int i) {\n+        // base case: all variables have been aliased; evaluate for current\n+        // values\n+        if (_unbounds == null || i == _unbounds.size())\n+            return exp.evaluate(group, ctx, params);\n+\n+        // grab the extent for this variable\n+        UnboundVariable var = (UnboundVariable) _unbounds.get(i);\n+        Extent extent = ctx.getBroker().newExtent(var.getType(), true);\n+        Iterator itr = extent.iterator();\n+        try {\n+            // if the extent was empty, then alias the variable to null\n+            if (!itr.hasNext()) {\n+                var.setValue(null);\n+                return matches(exp, group, ctx, params, i + 1);\n+            }\n+\n+            // try every value, short-circuiting on match\n+            while (itr.hasNext()) {\n+                // set the variable to each extent value and recurse\n+                var.setValue(itr.next());\n+                if (matches(exp, group, ctx, params, i + 1))\n+                    return true;\n+            }\n+\n+            // no match\n+            return false;\n+        } finally {\n+            ImplHelper.close(itr);\n+        }\n+    }\n+\n+    /**\n+     * Create the projections for the given results.\n+     */\n+    public List project(QueryExpressions exps, List matches,\n+        StoreContext ctx, Object[] params) {\n+        if (exps.projections.length == 0)\n+            return matches;\n+\n+        // if an ungrouped aggregate, evaluate the whole matches list\n+        if (exps.grouping.length == 0 && exps.isAggregate()) {\n+            Object[] projection = project(matches, exps, true, ctx, params);\n+            return Arrays.asList(new Object[]{ projection });\n+        }\n+\n+        // evaluate each candidate\n+        List projected = new ArrayList(matches.size());\n+        for (Iterator itr = matches.iterator(); itr.hasNext();)\n+            projected.add(project(itr.next(), exps, exps.grouping.length > 0,\n+                ctx, params));\n+        return projected;\n+    }\n+\n+    /**\n+     * Generate a projection on the given candidate.\n+     */\n+    private Object[] project(Object candidate, QueryExpressions exps,\n+        boolean agg, StoreContext ctx, Object[] params) {\n+        Object[] projection = new Object[exps.projections.length\n+            + exps.ordering.length];\n+\n+        // calcualte result values\n+        Object result = null;\n+        for (int i = 0; i < exps.projections.length; i++) {\n+            if (agg)\n+                result = ((Val) exps.projections[i]).evaluate((Collection)\n+                    candidate, null, ctx, params);\n+            else\n+                result = ((Val) exps.projections[i]).evaluate(candidate,\n+                    candidate, ctx, params);\n+            projection[i] = result;\n+        }\n+\n+        // tack on ordering values\n+        boolean repeat;\n+        for (int i = 0; i < exps.ordering.length; i++) {\n+            // already selected as a result?\n+            repeat = false;\n+            for (int j = 0; !repeat && j < exps.projections.length; j++) {\n+                if (exps.orderingClauses[i].equals(exps.projectionClauses[j])) {\n+                    result = projection[j];\n+                    repeat = true;\n+                }\n+            }\n+\n+            // not selected as result; calculate value\n+            if (!repeat) {\n+                if (agg)\n+                    result = ((Val) exps.ordering[i]).evaluate((Collection)\n+                        candidate, null, ctx, params);\n+                else\n+                    result = ((Val) exps.ordering[i]).evaluate(candidate,\n+                        candidate, ctx, params);\n+            }\n+\n+            projection[i + exps.projections.length] = result;\n+        }\n+        return projection;\n+    }\n+\n+    /**\n+     * Order the given list of matches on the given value.\n+     */\n+    public List order(QueryExpressions exps, List matches,\n+        StoreContext ctx, Object[] params) {\n+        return order(exps, exps.ordering, true, matches, ctx, params);\n+    }\n+\n+    /**\n+     * Order the given list of matches on the given value.\n+     *\n+     * @param projected whether projections have been applied to the matches yet\n+     */\n+    private List order(QueryExpressions exps, Value[] orderValues,\n+        boolean projected, List matches, StoreContext ctx, Object[] params) {\n+        if (matches == null || matches.isEmpty()\n+            || orderValues == null || orderValues.length == 0)\n+            return matches;\n+\n+        int results = (projected) ? exps.projections.length : 0;\n+        boolean[] asc = (projected) ? exps.ascending : null;\n+        int idx;\n+        for (int i = orderValues.length - 1; i >= 0; i--) {\n+            // if this is a projection, then in project() we must have selected\n+            // the ordering value already after the projection values\n+            idx = (results > 0) ? results + i : -1;\n+            Collections.sort(matches,\n+                new OrderValueComparator((Val) orderValues[i],\n+                    asc == null || asc[i], idx, ctx, params));\n+        }\n+        return matches;\n+    }\n+\n+    /**\n+     * Filter the given list of matches, removing duplicate entries.\n+     */\n+    public List distinct(QueryExpressions exps, boolean fromExtent,\n+        List matches) {\n+        if (matches == null || matches.isEmpty())\n+            return matches;\n+\n+        // no need to do distinct if not instructed to, or if these are\n+        // candidate objects from an extent\n+        int len = exps.projections.length;\n+        if ((exps.distinct & exps.DISTINCT_TRUE) == 0\n+            || (fromExtent && len == 0))\n+            return matches;\n+\n+        Set seen = new HashSet(matches.size());\n+        List distinct = null;\n+        Object cur;\n+        Object key;\n+        for (ListIterator li = matches.listIterator(); li.hasNext();) {\n+            cur = li.next();\n+            key = (len > 0 && cur != null) ? new ArrayKey((Object[]) cur) : cur;\n+\n+            if (seen.add(key)) {\n+                // key hasn't been seen before; if we've created a distinct\n+                // list, keep adding to it\n+                if (distinct != null)\n+                    distinct.add(cur);\n+            } else if (distinct == null) {\n+                // we need to copy the matches list because the distinct list\n+                // will be different (we've come across a non-unique key); add\n+                // all the elements we've skipped over so far\n+                distinct = new ArrayList(matches.size());\n+                distinct.addAll(matches.subList(0, li.previousIndex()));\n+            }\n+        }\n+        return (distinct == null) ? matches : distinct;\n+    }\n+\n+    public Expression emptyExpression() {\n+        return new Exp();\n+    }\n+\n+    public Expression asExpression(Value v) {\n+        return new ValExpression((Val) v);\n+    }\n+\n+    public Expression equal(Value v1, Value v2) {\n+        return new EqualExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Expression notEqual(Value v1, Value v2) {\n+        return new NotEqualExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Expression lessThan(Value v1, Value v2) {\n+        return new LessThanExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Expression greaterThan(Value v1, Value v2) {\n+        return new GreaterThanExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Expression lessThanEqual(Value v1, Value v2) {\n+        return new LessThanEqualExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Expression greaterThanEqual(Value v1, Value v2) {\n+        return new GreaterThanEqualExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Expression isEmpty(Value v1) {\n+        return new IsEmptyExpression((Val) v1);\n+    }\n+\n+    public Expression isNotEmpty(Value v1) {\n+        return not(isEmpty(v1));\n+    }\n+\n+    public Expression contains(Value v1, Value v2) {\n+        return new ContainsExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Expression containsKey(Value v1, Value v2) {\n+        return new ContainsKeyExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Expression containsValue(Value v1, Value v2) {\n+        return new ContainsValueExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Value getMapValue(Value map, Value arg) {\n+        return new GetMapValue((Val) map, (Val) arg);\n+    }\n+\n+    public Expression isInstance(Value v1, Class c) {\n+        return new InstanceofExpression((Val) v1, c);\n+    }\n+\n+    public Expression and(Expression exp1, Expression exp2) {\n+        if (exp1 instanceof BindVariableExpression)\n+            return new BindVariableAndExpression((BindVariableExpression) exp1,\n+                (Exp) exp2);\n+        return new AndExpression((Exp) exp1, (Exp) exp2);\n+    }\n+\n+    public Expression or(Expression exp1, Expression exp2) {\n+        return new OrExpression((Exp) exp1, (Exp) exp2);\n+    }\n+\n+    public Expression not(Expression exp) {\n+        return new NotExpression((Exp) exp);\n+    }\n+\n+    public Expression bindVariable(Value var, Value val) {\n+        return new BindVariableExpression((BoundVariable) var, (Val) val);\n+    }\n+\n+    public Expression bindKeyVariable(Value var, Value val) {\n+        return new BindKeyVariableExpression((BoundVariable) var, (Val) val);\n+    }\n+\n+    public Expression bindValueVariable(Value var, Value val) {\n+        return new BindValueVariableExpression((BoundVariable) var, (Val) val);\n+    }\n+\n+    public Expression endsWith(Value v1, Value v2) {\n+        return new EndsWithExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Expression matches(Value v1, Value v2,\n+        String single, String multi, String esc) {\n+        return new MatchesExpression((Val) v1, (Val) v2, single, multi, esc,\n+            true);\n+    }\n+\n+    public Expression notMatches(Value v1, Value v2,\n+        String single, String multi, String esc) {\n+        return new MatchesExpression((Val) v1, (Val) v2, single, multi, esc,\n+            false);\n+    }\n+\n+    public Expression startsWith(Value v1, Value v2) {\n+        return new StartsWithExpression((Val) v1, (Val) v2);\n+    }\n+\n+    public Subquery newSubquery(ClassMetaData candidate, boolean subs,\n+        String alias) {\n+        return new SubQ(alias);\n+    }\n+\n+    public Path newPath() {\n+        return new CandidatePath();\n+    }\n+\n+    public Path newPath(Value val) {\n+        return new ValuePath((Val) val);\n+    }\n+\n+    public Literal newLiteral(Object val, int parseType) {\n+        return new Lit(val, parseType);\n+    }\n+\n+    public Value getThis() {\n+        return new This();\n+    }\n+\n+    public Value getNull() {\n+        return NULL;\n+    }\n+\n+    public Value getCurrentDate() {\n+        return CURRENT_DATE;\n+    }\n+\n+    public Value getCurrentTime() {\n+        return CURRENT_DATE;\n+    }\n+\n+    public Value getCurrentTimestamp() {\n+        return CURRENT_DATE;\n+    }\n+\n+    public Parameter newParameter(String name, Class type) {\n+        return new Param(name, type);\n+    }\n+\n+    public Value newExtension(FilterListener listener, Value target,\n+        Value arg) {\n+        return new Extension(listener, (Val) target, (Val) arg);\n+    }\n+\n+    public Value newAggregate(AggregateListener listener, Value arg) {\n+        return new Aggregate(listener, (Val) arg);\n+    }\n+\n+    public Arguments newArgumentList(Value val1, Value val2) {\n+        return new Args(val1, val2);\n+    }\n+\n+    public Value newUnboundVariable(String name, Class type) {\n+        UnboundVariable var = new UnboundVariable(type);\n+        if (_unbounds == null)\n+            _unbounds = new ArrayList(3);\n+        _unbounds.add(var);\n+        return var;\n+    }\n+\n+    public Value newBoundVariable(String name, Class type) {\n+        return new BoundVariable(type);\n+    }\n+\n+    public Value cast(Value val, Class cls) {\n+        if (val instanceof CandidatePath)\n+            ((CandidatePath) val).castTo(cls);\n+        else if (val instanceof BoundVariable)\n+            ((BoundVariable) val).castTo(cls);\n+        else\n+            val = new Cast((Val) val, cls);\n+        return val;\n+    }\n+\n+    public Value add(Value val1, Value val2) {\n+        return new Add((Val) val1, (Val) val2);\n+    }\n+\n+    public Value subtract(Value val1, Value val2) {\n+        return new Subtract((Val) val1, (Val) val2);\n+    }\n+\n+    public Value multiply(Value val1, Value val2) {\n+        return new Multiply((Val) val1, (Val) val2);\n+    }\n+\n+    public Value divide(Value val1, Value val2) {\n+        return new Divide((Val) val1, (Val) val2);\n+    }\n+\n+    public Value mod(Value val1, Value val2) {\n+        return new Mod((Val) val1, (Val) val2);\n+    }\n+\n+    public Value abs(Value val) {\n+        return new Abs((Val) val);\n+    }\n+\n+    public Value indexOf(Value val1, Value val2) {\n+        return new IndexOf((Val) val1, (Val) val2);\n+    }\n+\n+    public Value concat(Value val1, Value val2) {\n+        return new Concat((Val) val1, (Val) val2);\n+    }\n+\n+    public Value stringLength(Value str) {\n+        return new StringLength((Val) str);\n+    }\n+\n+    public Value trim(Value str, Value trimChar, Boolean where) {\n+        return new Trim((Val) str, (Val) trimChar, where);\n+    }\n+\n+    public Value sqrt(Value val) {\n+        return new Sqrt((Val) val);\n+    }\n+\n+    public Value substring(Value val1, Value val2) {\n+        return new Substring((Val) val1, (Val) val2);\n+    }\n+\n+    public Value toUpperCase(Value val) {\n+        return new ToUpperCase((Val) val);\n+    }\n+\n+    public Value toLowerCase(Value val) {\n+        return new ToLowerCase((Val) val);\n+    }\n+\n+    public Value avg(Value val) {\n+        return new Avg((Val) val);\n+    }\n+\n+    public Value count(Value val) {\n+        return new Count((Val) val);\n+    }\n+\n+    public Value distinct(Value val) {\n+        return new Distinct((Val) val);\n+    }\n+\n+    public Value max(Value val) {\n+        return new Max((Val) val);\n+    }\n+\n+    public Value min(Value val) {\n+        return new Min((Val) val);\n+    }\n+\n+    public Value sum(Value val) {\n+        return new Sum((Val) val);\n+    }\n+\n+    public Value any(Value val) {\n+        return new Any((Val) val);\n+    }\n+\n+    public Value all(Value val) {\n+        return new All((Val) val);\n+    }\n+\n+    public Value size(Value val) {\n+        return new Size((Val) val);\n+    }\n+\n+    public Value getObjectId(Value val) {\n+        return new GetObjectId((Val) val);\n+    }\n+\n+    /**\n+     * Key that implements hashCode and equals methods for object arrays.\n+     */\n+    private static class ArrayKey {\n+\n+        private final Object[] _arr;\n+\n+        public ArrayKey(Object[] arr) {\n+            _arr = arr;\n+        }\n+\n+        public int hashCode() {\n+            int rs = 17;\n+            for (int i = 0; i < _arr.length; i++)\n+                rs = 37 * rs + ((_arr[i] == null) ? 0 : _arr[i].hashCode());\n+            return rs;\n+        }\n+\n+        public boolean equals(Object other) {\n+            if (other == this)\n+                return true;\n+            if (other == null)\n+                return false;\n+\n+            Object[] arr = ((ArrayKey) other)._arr;\n+            if (_arr.length != arr.length)\n+                return false;\n+            for (int i = 0; i < _arr.length; i++)\n+                if (!ObjectUtils.equals(_arr[i], arr[i]))\n+                    return false;\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Comparator that uses the result of eval'ing a Value to sort on. Null\n+     * values are placed last if sorting in ascending order, first if\n+     * descending.\n+     */\n+    private static class OrderValueComparator\n+        implements Comparator {\n+\n+        private final StoreContext _ctx;\n+        private final Val _val;\n+        private final boolean _asc;\n+        private final int _idx;\n+        private final Object[] _params;\n+\n+        private OrderValueComparator(Val val, boolean asc, int idx,\n+            StoreContext ctx, Object[] params) {\n+            _ctx = ctx;\n+            _val = val;\n+            _asc = asc;\n+            _idx = idx;\n+            _params = params;\n+        }\n+\n+        public int compare(Object o1, Object o2) {\n+            if (_idx != -1) {\n+                o1 = ((Object[]) o1)[_idx];\n+                o2 = ((Object[]) o2)[_idx];\n+            } else {\n+                o1 = _val.evaluate(o1, o1, _ctx, _params);\n+                o2 = _val.evaluate(o2, o2, _ctx, _params);\n+            }\n+\n+            if (o1 == null && o2 == null)\n+                return 0;\n+            if (o1 == null)\n+                return (_asc) ? 1 : -1;\n+            if (o2 == null)\n+                return (_asc) ? -1 : 1;\n+\n+            if (o1 instanceof Boolean && o2 instanceof Boolean) {\n+                int i1 = ((Boolean) o1).booleanValue() ? 1 : 0;\n+                int i2 = ((Boolean) o2).booleanValue() ? 1 : 0;\n+                return i1 - i2;\n+            }\n+\n+            try {\n+                if (_asc)\n+                    return ((Comparable) o1).compareTo(o2);\n+                return ((Comparable) o2).compareTo(o1);\n+            } catch (ClassCastException cce) {\n+                Localizer loc = Localizer.forPackage\n+                    (InMemoryExpressionFactory.class);\n+                throw new UserException(loc.get(\"not-comp\", o1, o2));\n+\t\t\t}\n+\t\t}\n+\t}\n+}"},{"sha":"9ca3dbbc572f795913afe3a58ea6fb7d3b324d42","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IndexOf.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IndexOf.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IndexOf.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IndexOf.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+import serp.util.Numbers;\n+\n+/**\n+ * Find the index of one string within another.\n+ *\n+ * @author Abe White\n+ */\n+class IndexOf\n+    extends Val {\n+\n+    private final Val _val;\n+    private final Val _args;\n+\n+    /**\n+     * Constructor. Provide target string and the arguments to the\n+     * indexOf method.\n+     */\n+    public IndexOf(Val val, Val args) {\n+        _val = val;\n+        _args = args;\n+    }\n+\n+    public Class getType() {\n+        return int.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Object str = _val.eval(candidate, orig, ctx, params);\n+        Object arg = _args.eval(candidate, orig, ctx, params);\n+        int idx;\n+        if (arg instanceof Object[]) {\n+            Object[] args = (Object[]) arg;\n+            idx = str.toString().indexOf(args[0].toString(),\n+                ((Number) args[1]).intValue());\n+        } else\n+            idx = str.toString().indexOf(arg.toString());\n+        return Numbers.valueOf(idx);\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val.acceptVisit(visitor);\n+        _args.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}"},{"sha":"31822aea365faf2540f50a6afd0c794d81fb0cac","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InstanceofExpression.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InstanceofExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InstanceofExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/InstanceofExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Tests whether a value is an instance of a class.\n+ *\n+ * @author Abe White\n+ */\n+class InstanceofExpression\n+    extends Exp {\n+\n+    private final Val _val;\n+    private final Class _cls;\n+\n+    /**\n+     * Constructor; supply value and class.\n+     */\n+    public InstanceofExpression(Val val, Class cls) {\n+        _val = val;\n+        _cls = Filters.wrap(cls);\n+    }\n+\n+    /**\n+     * Evaluate the expression for the given context candidate and original\n+     * candidate.\n+     */\n+    protected boolean eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        return _cls.isInstance(_val.eval(candidate, orig, ctx, params));\n+    }\n+\n+    /**\n+     * Evaluate the expression for the given group.\n+     */\n+    protected boolean eval(Collection candidates, StoreContext ctx,\n+        Object[] params) {\n+        Collection c = _val.eval(candidates, null, ctx, params);\n+        Object o = (c == null || c.isEmpty()) ? null : c.iterator().next();\n+        return _cls.isInstance(o);\n+\t}\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}"},{"sha":"12d3f985108bd434afd8b37ada6f7be809601b0d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IsEmptyExpression.java","status":"added","additions":76,"deletions":0,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IsEmptyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IsEmptyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/IsEmptyExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Expression to test for an empty Collection.\n+ *\n+ * @author Abe White\n+ */\n+class IsEmptyExpression\n+    extends Exp {\n+\n+    private final Val _val;\n+\n+    /**\n+     * Constructor. Provide collection/map value to test.\n+     */\n+    public IsEmptyExpression(Val val) {\n+        _val = val;\n+    }\n+\n+    protected boolean eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Object obj = _val.eval(candidate, orig, ctx, params);\n+        if (obj == null)\n+            return true;\n+        if (obj instanceof Collection)\n+            return ((Collection) obj).isEmpty();\n+        if (obj instanceof Map)\n+            return ((Map) obj).isEmpty();\n+        return false;\n+    }\n+\n+    protected boolean eval(Collection candidates, StoreContext ctx,\n+        Object[] params) {\n+        Collection c = _val.eval(candidates, null, ctx, params);\n+        if (c == null || c.isEmpty())\n+            return false;\n+        Object obj = c.iterator().next();\n+        if (obj == null)\n+            return true;\n+        if (obj instanceof Collection)\n+            return ((Collection) obj).isEmpty();\n+        if (obj instanceof Map)\n+            return ((Map) obj).isEmpty();\n+        return false;\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}\n+"},{"sha":"f220964e2775394929eb2cb49ff7fb9db1f82ed7","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanEqualExpression.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanEqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanEqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanEqualExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+/**\n+ * Expression that compares two others.\n+ *\n+ * @author Abe White\n+ */\n+class LessThanEqualExpression\n+    extends CompareExpression {\n+\n+    /**\n+     * Constructor. Supply values to compare.\n+     */\n+    public LessThanEqualExpression(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    protected boolean compare(Object o1, Object o2) {\n+        if (!(o1 instanceof Comparable))\n+            return false;\n+        return ((Comparable) o1).compareTo(o2) <= 0;\n+    }\n+}\n+"},{"sha":"0ba399913d422b74ba88104527a1697deb595347","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanExpression.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/LessThanExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+/**\n+ * Expression that compares two others.\n+ *\n+ * @author Abe White\n+ */\n+class LessThanExpression\n+    extends CompareExpression {\n+\n+    /**\n+     * Constructor. Supply values to compare.\n+     */\n+    public LessThanExpression(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    protected boolean compare(Object o1, Object o2) {\n+        if (!(o1 instanceof Comparable))\n+            return false;\n+        return ((Comparable) o1).compareTo(o2) < 0;\n+    }\n+}\n+"},{"sha":"04a7a85c0ea74e349cbbd7613e1027cdd5bb5a84","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Lit.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Lit.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Lit.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Lit.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Represents a literal.\n+ *\n+ * @author Abe White\n+ */\n+class Lit\n+    extends Val\n+    implements Literal {\n+\n+    private Object _val;\n+    private final int _ptype;\n+\n+    /**\n+     * Constructor. Provide constant value.\n+     */\n+    public Lit(Object val, int ptype) {\n+        _val = val;\n+        _ptype = ptype;\n+    }\n+\n+    public Object getValue() {\n+        return _val;\n+    }\n+\n+    public void setValue(Object val) {\n+        _val = val;\n+    }\n+\n+    public int getParseType() {\n+        return _ptype;\n+    }\n+\n+    public Object getValue(Object[] parameters) {\n+        return _val;\n+    }\n+\n+    public Class getType() {\n+        return (_val == null) ? Object.class : _val.getClass();\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _val = Filters.convert(_val, type);\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        return _val;\n+    }\n+}"},{"sha":"178f1e81a8cb79c322e063f385c7b398735552fa","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Literal.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Literal.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Literal.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Literal.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+/**\n+ * Interface for any literal value.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public interface Literal\n+    extends Value, Constant {\n+\n+    public static final int TYPE_UNKNOWN = 0;\n+    public static final int TYPE_NUMBER = 1;\n+    public static final int TYPE_BOOLEAN = 2;\n+    public static final int TYPE_STRING = 3;\n+    public static final int TYPE_SQ_STRING = 4; // single-quoted string\n+\n+    /**\n+     * The value of this literal.\n+     */\n+    public Object getValue();\n+\n+    /**\n+     * The value of this literal.\n+     */\n+    public void setValue(Object val);\n+\n+    /**\n+     * The type the literal was parsed as.\n+     */\n+    public int getParseType();\n+}\n+"},{"sha":"45c549ad1ec0b024db55b8889d011930c6bbb713","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MatchesExpression.java","status":"added","additions":80,"deletions":0,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MatchesExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MatchesExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MatchesExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.SimpleRegex;\n+import serp.util.Strings;\n+\n+/**\n+ * Expression that compares two others.\n+ *\n+ * @author Abe White\n+ */\n+class MatchesExpression\n+    extends CompareExpression {\n+\n+    private static final Localizer _loc = Localizer.forPackage(\n+        MatchesExpression.class);\n+    \n+    private final String _single;\n+    private final String _multi;\n+    private final boolean _affirmation;\n+\n+    /**\n+     * Constructor. Supply values to compare.\n+     */\n+    public MatchesExpression(Val val1, Val val2,\n+        String single, String multi, String escape, boolean affirmation) {\n+        super(val1, val2);\n+        _single = single;\n+        _multi = multi;\n+        if (escape != null)\n+            throw new IllegalArgumentException(_loc.get(\n+                \"escape-for-inmem-query-not-supported\").getMessage());\n+        _affirmation = affirmation;\n+    }\n+\n+    protected boolean compare(Object o1, Object o2) {\n+        if (o1 == null || o2 == null)\n+            return false;\n+\n+        // case insensitive?\n+        String str = o2.toString();\n+        int idx = str.indexOf(\"(?i)\");\n+        boolean uncase = false;\n+        if (idx != -1) {\n+            uncase = true;\n+            if (idx + 4 < str.length())\n+                str = str.substring(0, idx) + str.substring(idx + 4);\n+            else\n+                str = str.substring(0, idx);\n+        }\n+\n+        // now translate from the single and multi character escape\n+        // sequences into an escape that conforms to the regexp syntax\n+        str = Strings.replace(str, _multi, \".*\");\n+        str = Strings.replace(str, _single, \".\");\n+\n+        SimpleRegex re = new SimpleRegex(str, uncase);\n+        boolean matches = re.matches(o1.toString());\n+        return _affirmation ? matches : !matches;\n+    }\n+}\n+"},{"sha":"6d4475fdc895ab3ae98e27b1e1c62b4a08759c00","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MathVal.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MathVal.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MathVal.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/MathVal.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Value produced by a mathematical operation on two values.\n+ *\n+ * @author Abe White\n+ */\n+abstract class MathVal\n+    extends Val {\n+\n+    private final Val _val1;\n+    private final Val _val2;\n+\n+    /**\n+     * Constructor. Provide the values to operate on.\n+     */\n+    public MathVal(Val val1, Val val2) {\n+        _val1 = val1;\n+        _val2 = val2;\n+    }\n+\n+    public Class getType() {\n+        Class c1 = _val1.getType();\n+        Class c2 = _val2.getType();\n+        return Filters.promote(c1, c2);\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Object o1 = _val1.eval(candidate, orig, ctx, params);\n+        Object o2 = _val2.eval(candidate, orig, ctx, params);\n+        return operate(o1, _val1.getType(), o2, _val2.getType());\n+    }\n+\n+    /**\n+     * Return the result of this mathematical operation on the two values.\n+     */\n+    protected abstract Object operate(Object o1, Class c1, Object o2,\n+        Class c2);\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val1.acceptVisit(visitor);\n+        _val2.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}"},{"sha":"f18d395540ed5f6e670c5710b64abd708536b007","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Max.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Max.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Max.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Max.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+/**\n+ * Find the max.\n+ *\n+ * @author Abe White\n+ */\n+class Max\n+    extends AggregateVal {\n+\n+    /**\n+     * Constructor. Provide the value to maximize.\n+     */\n+    public Max(Val val) {\n+        super(val);\n+    }\n+\n+    protected Class getType(Class c) {\n+        return c;\n+    }\n+\n+    protected Object operate(Collection os, Class c) {\n+        Comparable max = null;\n+        Comparable cur;\n+        for (Iterator itr = os.iterator(); itr.hasNext();) {\n+            cur = (Comparable) itr.next();\n+            if (cur != null && (max == null || max.compareTo(cur) < 0))\n+                max = cur;\n+        }\n+        return max;\n+    }\n+}"},{"sha":"e094d9125c8d4c16539d6d8c6afe4ef7d2492488","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Min.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Min.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Min.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Min.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+/**\n+ * Find the min.\n+ *\n+ * @author Abe White\n+ */\n+class Min\n+    extends AggregateVal {\n+\n+    /**\n+     * Constructor. Provide the value to minimize.\n+     */\n+    public Min(Val val) {\n+        super(val);\n+    }\n+\n+    protected Class getType(Class c) {\n+        return c;\n+    }\n+\n+    protected Object operate(Collection os, Class c) {\n+        Comparable min = null;\n+        Comparable cur;\n+        for (Iterator itr = os.iterator(); itr.hasNext();) {\n+            cur = (Comparable) itr.next();\n+            if (cur != null && (min == null || min.compareTo(cur) > 0))\n+                min = cur;\n+        }\n+        return min;\n+    }\n+}"},{"sha":"d19b4d79d9eec0ddf79441d5f9755d411945d151","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Mod.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Mod.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Mod.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Mod.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.Filters;\n+\n+/**\n+ * Value produced by one value being mod'd by another.\n+ *\n+ * @author Abe White\n+ */\n+class Mod\n+    extends MathVal {\n+\n+    /**\n+     * Constructor. Provide the values to mod.\n+     */\n+    public Mod(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    protected Object operate(Object o1, Class c1, Object o2, Class c2) {\n+        return Filters.mod(o1, c1, o2, c2);\n+    }\n+}\n+"},{"sha":"a9d04885c1988a136494f5260393f3f98438f4ad","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Multiply.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Multiply.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Multiply.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Multiply.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.Filters;\n+\n+/**\n+ * Value produced by two values being multiplied together.\n+ *\n+ * @author Abe White\n+ */\n+class Multiply\n+    extends MathVal {\n+\n+    /**\n+     * Constructor. Provide the values to multiply.\n+     */\n+    public Multiply(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    protected Object operate(Object o1, Class c1, Object o2, Class c2) {\n+        return Filters.multiply(o1, c1, o2, c2);\n+    }\n+}\n+"},{"sha":"9d667e28c2b604842ce06c8311b79ef6d0ef2fd7","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotEqualExpression.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotEqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotEqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotEqualExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+/**\n+ * Expression that compares two others.\n+ *\n+ * @author Abe White\n+ */\n+class NotEqualExpression\n+    extends CompareExpression {\n+\n+    /**\n+     * Constructor. Supply values to compare.\n+     */\n+    public NotEqualExpression(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    protected boolean compare(Object o1, Object o2) {\n+        return (o1 == null && o2 != null)\n+            || (o1 != null && !o1.equals(o2));\n+    }\n+}\n+"},{"sha":"bb49896e507e1f7d401eb5b367c548da459197fe","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotExpression.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/NotExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * An expression that NOT's another.\n+ *\n+ * @author Abe White\n+ */\n+class NotExpression\n+    extends Exp {\n+\n+    private final Exp _exp;\n+\n+    /**\n+     * Constructor. Supply expression to negate.\n+     */\n+    public NotExpression(Exp exp) {\n+        _exp = exp;\n+    }\n+\n+    protected boolean eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        return !_exp.evaluate(candidate, orig, ctx, params);\n+    }\n+\n+    protected boolean eval(Collection candidates, StoreContext ctx,\n+        Object[] params) {\n+        return !_exp.evaluate(candidates, ctx, params);\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _exp.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}\n+"},{"sha":"2c0b3a5541b972ffde70b9082009a008a6c5fc7e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Null.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Null.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Null.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Null.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Represents the null constant.\n+ *\n+ * @author Abe White\n+ */\n+class Null\n+    extends Val {\n+\n+    public Class getType() {\n+        return Object.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        return null;\n+    }\n+}"},{"sha":"cb3527673012569671848b45d69a50854662bc9e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/OrExpression.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/OrExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/OrExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/OrExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * An expression that OR's two others together.\n+ *\n+ * @author Abe White\n+ */\n+class OrExpression\n+    extends Exp {\n+\n+    private final Exp _exp1;\n+    private final Exp _exp2;\n+\n+    /**\n+     * Constructor. Supply expressions to combine.\n+     */\n+    public OrExpression(Exp exp1, Exp exp2) {\n+        _exp1 = exp1;\n+        _exp2 = exp2;\n+    }\n+\n+    protected boolean eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        return _exp1.evaluate(candidate, orig, ctx, params)\n+            || _exp2.evaluate(candidate, orig, ctx, params);\n+    }\n+\n+    protected boolean eval(Collection candidates, StoreContext ctx,\n+        Object[] params) {\n+        return _exp1.evaluate(candidates, ctx, params)\n+            || _exp2.evaluate(candidates, ctx, params);\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _exp1.acceptVisit(visitor);\n+        _exp2.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}\n+"},{"sha":"d449c9f7acb659c63574a6006f21079536e28311","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Param.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Param.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Param.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Param.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Represents a parameter.\n+ *\n+ * @author Abe White\n+ */\n+class Param\n+    extends Val\n+    implements Parameter {\n+\n+    private String _name = null;\n+    private Class _type = null;\n+    private int _index = -1;\n+\n+    /**\n+     * Constructor. Provide parameter name and type.\n+     */\n+    public Param(String name, Class type) {\n+        _name = name;\n+        _type = type;\n+    }\n+\n+    public String getParameterName() {\n+        return _name;\n+    }\n+\n+    public Class getType() {\n+        return _type;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _type = type;\n+    }\n+\n+    public void setIndex(int index) {\n+        _index = index;\n+    }\n+\n+    public Object getValue(Object[] params) {\n+        return params[_index];\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        return getValue(params);\n+    }\n+}\n+"},{"sha":"c9616395c5f80bf28d689f76da0e66269f8b88a6","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Parameter.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Parameter.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Parameter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Parameter.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+/**\n+ * A query parameter.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public interface Parameter\n+    extends Value, Constant {\n+\n+    /**\n+     * Set the index of this parameter.\n+     */\n+    public void setIndex(int index);\n+\n+    /**\n+     * Returns the name of the parameter.\n+     */\n+    public String getParameterName();\n+}"},{"sha":"71b41a2c614e7a3f20e02cb0d8137cbba049e804","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.XMLMetaData;\n+\n+/**\n+ * A path represents a traversal into fields of a candidate object.\n+ * Equivalent paths should compare equal.\n+ *\n+ * @author Abe White\n+ */\n+public interface Path\n+    extends Value {\n+\n+    /**\n+     * Traverse into the given field of the current object, and update\n+     * the current object to that field value.\n+     *\n+     * @param nullTraversal if true, allow traversal through a null field\n+     */\n+    public void get(FieldMetaData field, boolean nullTraversal);\n+\n+    /**\n+     * Return the last field in the path, or null if the path does not\n+     * not contain a final field.\n+     */\n+    public FieldMetaData last();\n+\n+    /**\n+     * Traverse into the given field that maps to xml column, and update\n+     * the current object to that field value.\n+     * \n+     * @param fmd field maps to xml column\n+     * @param meta associated xml mapping\n+     */\n+    public void get(FieldMetaData fmd, XMLMetaData meta);\n+    \n+    /**\n+     * Traverse into the gevin xpath name of the current object, and update\n+     * the current object to that xpath field.\n+     * \n+     * @param meta\n+     * @param name\n+     */\n+    public void get(XMLMetaData meta, String name);\n+    \n+    /**\n+     * Return the current XPath's xmlmapping metadata.\n+     * @return Return xmlmapping\n+     */\n+    public XMLMetaData getXmlMapping();\n+}"},{"sha":"ed59ba8040dc191acb50e6f0aca243dcb80b7f0a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java","status":"added","additions":129,"deletions":0,"changes":129,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.map.LinkedMap;\n+import org.apache.openjpa.kernel.QueryOperations;\n+import org.apache.openjpa.kernel.StoreQuery;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+\n+/**\n+ * Struct to hold the state of a parsed expression query.\n+ *\n+ * @author Abe White\n+ * @since 0.3.2\n+ * @nojavadoc\n+ */\n+public class QueryExpressions\n+    implements Serializable {\n+\n+    public static final int DISTINCT_AUTO = 2 << 0;\n+    public static final int DISTINCT_TRUE = 2 << 1;\n+    public static final int DISTINCT_FALSE = 2 << 2;\n+    public static final Value[] EMPTY_VALUES = new Value[0];\n+\n+    /**\n+     * Map of {@link FieldMetaData},{@link Value} for update statements.\n+     */\n+    public Map<Path, Value> updates = Collections.EMPTY_MAP;\n+    public int distinct = DISTINCT_AUTO;\n+    public String alias = null;\n+    public Value[] projections = EMPTY_VALUES;\n+    public String[] projectionClauses = StoreQuery.EMPTY_STRINGS;\n+    public String[] projectionAliases = StoreQuery.EMPTY_STRINGS;\n+    public Class resultClass = null;\n+    public Expression filter = null;\n+    public Value[] grouping = EMPTY_VALUES;\n+    public String[] groupingClauses = StoreQuery.EMPTY_STRINGS;\n+    public Expression having = null;\n+    public Value[] ordering = EMPTY_VALUES;\n+    public boolean[] ascending = StoreQuery.EMPTY_BOOLEANS;\n+    public String[] orderingClauses = StoreQuery.EMPTY_STRINGS;\n+    public LinkedMap parameterTypes = StoreQuery.EMPTY_PARAMS;\n+    public int operation = QueryOperations.OP_SELECT;\n+    public ClassMetaData[] accessPath = StoreQuery.EMPTY_METAS;\n+    public String[] fetchPaths = StoreQuery.EMPTY_STRINGS;\n+    public String[] fetchInnerPaths = StoreQuery.EMPTY_STRINGS;\n+    public Value[] range = EMPTY_VALUES;\n+    private Boolean _aggregate = null;\n+\n+    /**\n+     * Whether this is an aggregate results.\n+     */\n+    public boolean isAggregate() {\n+        if (projections.length == 0)\n+            return false; \n+        if (_aggregate == null)\n+            _aggregate = (AggregateExpressionVisitor.isAggregate(projections))\n+                ? Boolean.TRUE : Boolean.FALSE;\n+        return _aggregate.booleanValue();    \n+    }\n+\n+    /**\n+     * Add an update.\n+     */\n+    public void putUpdate(Path path, Value val) {\n+        if (updates == Collections.EMPTY_MAP)\n+            updates = new LinkedHashMap<Path, Value>();\n+        updates.put(path, val);\n+    }\n+\n+    /**\n+     * Visitor to determine whether our projections are aggregates.\n+     */\n+    private static class AggregateExpressionVisitor\n+        extends AbstractExpressionVisitor {\n+        \n+        private Value _sub = null;\n+        private boolean _agg = false;\n+\n+        /**\n+         * Return whether the given values include projections.\n+         */\n+        public static boolean isAggregate(Value[] vals) {\n+            if (vals.length == 0)\n+                return false;\n+            AggregateExpressionVisitor v = new AggregateExpressionVisitor();\n+            for (int i = 0; i < vals.length && !v._agg; i++)\n+                vals[i].acceptVisit(v);\n+            return v._agg;\n+        }\n+\n+        public void enter(Value val) {\n+            if (_agg)\n+                return;\n+            if (_sub == null) {\n+                if (val.isAggregate())\n+                    _agg = true;\n+            } else if (val instanceof Subquery)\n+                _sub = val;\n+        }\n+\n+        public void exit(Value val) {\n+            if (val == _sub)\n+                _sub = null;\n+        }\n+    }\n+}"},{"sha":"be0361ee25c297a2def8ece2701049c89b76bbe6","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Resolver.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Resolver.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Resolver.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Resolver.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.QueryContext;\n+\n+/**\n+ * A Resolver is used to resolve listeners and class or entity names\n+ * that appear in a query.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public interface Resolver {\n+\n+    /**\n+     * Resolve the type represented by the given class name. This will\n+     * test the type against the namespace of the Query and the declared\n+     * imports, and will properly handle primitives and java.lang types\n+     * as well. Returns null if the name does not match a known type.\n+     */\n+    public Class classForName(String name, String[] imports);\n+\n+    /**\n+     * Return the filter listener for the given tag, or null if none.\n+     */\n+    public FilterListener getFilterListener(String tag);\n+\n+    /**\n+     * Return the function listener for the given tag, or null if none.\n+     */\n+    public AggregateListener getAggregateListener(String tag);\n+\n+    /**\n+     * Return the OpenJPA configuration.\n+     */\n+    public OpenJPAConfiguration getConfiguration ();\n+\n+    /**\n+     * The {@link QueryContext} for which this resolver was created\n+     *\n+     * @since 1.1.0\n+     */\n+    public QueryContext getQueryContext();\n+}"},{"sha":"8b2489aa5570b62020e7a67f5800fa396ee78bbb","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Size.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Size.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Size.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Size.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+import serp.util.Numbers;\n+\n+/**\n+ * Returns the count of a collection.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class Size\n+    extends UnaryMathVal {\n+\n+    public Size(Val val) {\n+        super(val);\n+    }\n+\n+    protected Class getType(Class c) {\n+        return int.class;\n+    }\n+\n+    protected Object operate(Object o, Class c) {\n+        if (o instanceof Collection)\n+            return Numbers.valueOf(((Collection) o).size());\n+        if (o instanceof Map)\n+            return Numbers.valueOf(((Map) o).size());\n+        return (o == null) ? Numbers.valueOf(0) : Numbers.valueOf(1);\n+    }\n+}"},{"sha":"400a0643b5984401f0101a1d66eebfa9bcbc0d87","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sqrt.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sqrt.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sqrt.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sqrt.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+/**\n+ * Take the square root of a number.\n+ *\n+ * @author Abe White\n+ */\n+class Sqrt\n+    extends UnaryMathVal {\n+\n+    /**\n+     * Constructor. Provide the number whose square root to calculate.\n+     */\n+    public Sqrt(Val val) {\n+        super(val);\n+    }\n+\n+    protected Class getType(Class c) {\n+        return double.class;\n+    }\n+\n+    protected Object operate(Object o, Class c) {\n+        return new Double(Math.sqrt(((Number) o).doubleValue()));\n+    }\n+}"},{"sha":"ff70f94dea31d1a7b2422b8b3a6e71e145eab2e8","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StartsWithExpression.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StartsWithExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StartsWithExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StartsWithExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+/**\n+ * Expression that compares two others.\n+ *\n+ * @author Abe White\n+ */\n+class StartsWithExpression\n+    extends CompareExpression {\n+\n+    /**\n+     * Constructor. Supply values to compare.\n+     */\n+    public StartsWithExpression(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    protected boolean compare(Object o1, Object o2) {\n+        if (o1 == null || o2 == null)\n+            return false;\n+        return o1.toString().startsWith(o2.toString());\n+    }\n+}"},{"sha":"572f59b9898698f4ec73cd893d2d13dbcaa3d9a9","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringContains.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringContains.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringContains.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringContains.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Tests if the target contains the given argument. The argument must be\n+ * a constant.\n+ *  Examples:<br />\n+ * <code> \"address.street.ext:stringContains (\\\"main\\\")\"\n+ * </code>\n+ *\n+ * @deprecated Use <code>matches()</code> instead.\n+ * @nojavadoc\n+ */\n+public class StringContains\n+    implements FilterListener {\n+\n+    public static final String TAG = \"stringContains\";\n+\n+    public String getTag() {\n+        return TAG;\n+    }\n+\n+    public boolean expectsArguments() {\n+        return true;\n+    }\n+\n+    public boolean expectsTarget() {\n+        return true;\n+    }\n+\n+    public Object evaluate(Object target, Class targetClass, Object[] args,\n+        Class[] argClasses, Object candidate, StoreContext ctx) {\n+        if (target == null || args[0] == null)\n+            return Boolean.FALSE;\n+        if (target.toString().indexOf(args[0].toString()) != -1)\n+            return Boolean.TRUE;\n+        return Boolean.FALSE;\n+    }\n+\n+    public Class getType(Class targetClass, Class[] argClasses) {\n+        return boolean.class;\n+    }\n+}"},{"sha":"9aa59d56820b882e8b83f09c8653334b7371d348","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringLength.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringLength.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringLength.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/StringLength.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+import serp.util.Numbers;\n+\n+/**\n+ * Returns the number of characters in the String.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class StringLength\n+    extends Val {\n+\n+    private final Val _val;\n+    private Class _cast = null;\n+\n+    /**\n+     * Constructor. Provide value to upper-case.\n+     */\n+    public StringLength(Val val) {\n+        _val = val;\n+    }\n+\n+    public Class getType() {\n+        if (_cast != null)\n+            return _cast;\n+        return int.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _cast = type;\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Object eval = _val.eval(candidate, orig, ctx, params);\n+        if (eval == null)\n+            return Numbers.valueOf(0);\n+\n+        return Numbers.valueOf(eval.toString().length());\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}\n+"},{"sha":"55c995e949b12e9805131865eca8999197612027","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.UnsupportedException;\n+\n+/**\n+ * An in-memory representation of a {@link Subquery}. Currently\n+ * subqueries aren't supported for in-memory use.\n+ *\n+ * @author Abe White\n+ */\n+class SubQ\n+    extends Val\n+    implements Subquery {\n+\n+    private static final Localizer _loc = Localizer.forPackage(Subquery.class);\n+\n+    private final String _alias;\n+    private Class _type = null;\n+\n+    public SubQ(String alias) {\n+        _alias = alias;\n+    }\n+\n+    public String getCandidateAlias() {\n+        return _alias;\n+    }\n+\n+    public void setQueryExpressions(QueryExpressions q) {\n+    }\n+\n+    public Class getType() {\n+        return _type;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _type = type;\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        throw new UnsupportedException(_loc.get(\"in-mem-subquery\"));\n+    }\n+}"},{"sha":"d4f654dae3a3134231ecc7c40cc9167db7c6f20c","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+/**\n+ * Query value representing a subquery.\n+ *\n+ * @author Abe White\n+ * @since 0.3.2\n+ */\n+public interface Subquery\n+    extends Value {\n+\n+    /**\n+     * Return the candidate alias for this subquery.\n+     */\n+    public String getCandidateAlias();\n+\n+    /**\n+     * Set the parsed subquery.\n+     */\n+    public void setQueryExpressions(QueryExpressions query);\n+}"},{"sha":"bd06f83070c2cbf3dd0ae3980168b680e8a8a7cb","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Substring.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Substring.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Substring.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Substring.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Take the substring of a string.\n+ *\n+ * @author Abe White\n+ */\n+class Substring\n+    extends Val {\n+\n+    private final Val _val;\n+    private final Val _args;\n+\n+    /**\n+     * Constructor. Provide value to take substring of and arguments to\n+     * substring method.\n+     */\n+    public Substring(Val val, Val args) {\n+        _val = val;\n+        _args = args;\n+    }\n+\n+    public Class getType() {\n+        return String.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Object str = _val.eval(candidate, orig, ctx, params);\n+        Object arg = _args.eval(candidate, orig, ctx, params);\n+        if (arg instanceof Object[]) {\n+            Object[] args = (Object[]) arg;\n+            int start = ((Number) args[0]).intValue();\n+            int end = ((Number) args[1]).intValue();\n+            String string = str == null ? \"\" : str.toString();\n+            return string.substring(start, Math.min(end, string.length()));\n+        }\n+        return str.toString().substring(((Number) arg).intValue());\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val.acceptVisit(visitor);\n+        _args.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}"},{"sha":"1ab7c4c9e07c7d141e6e577d96029fa0c57ac3a8","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subtract.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subtract.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subtract.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subtract.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.Filters;\n+\n+/**\n+ * Value produced by one value being subtracted from another.\n+ *\n+ * @author Abe White\n+ */\n+class Subtract\n+    extends MathVal {\n+\n+    /**\n+     * Constructor. Provide the values to subtract.\n+     */\n+    public Subtract(Val val1, Val val2) {\n+        super(val1, val2);\n+    }\n+\n+    protected Object operate(Object o1, Class c1, Object o2, Class c2) {\n+        return Filters.subtract(o1, c1, o2, c2);\n+    }\n+}\n+"},{"sha":"2bcbbf93800f288d6e35f1414fdcb4fa07bacb84","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sum.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sum.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sum.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Sum.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.openjpa.kernel.Filters;\n+import serp.util.Numbers;\n+\n+/**\n+ * Sum values.\n+ *\n+ * @author Abe White\n+ */\n+class Sum\n+    extends AggregateVal {\n+\n+    /**\n+     * Constructor. Provide the value to sum.\n+     */\n+    public Sum(Val val) {\n+        super(val);\n+    }\n+\n+    protected Class getType(Class c) {\n+        Class wrap = Filters.wrap(c);\n+        if (wrap == Integer.class\n+            || wrap == Short.class\n+            || wrap == Byte.class)\n+            return long.class;\n+        return c;\n+    }\n+\n+    protected Object operate(Collection os, Class c) {\n+        if (os.isEmpty())\n+            return null;\n+\n+        Class type = getType(c);\n+        Object sum = Filters.convert(Numbers.valueOf(0), type);\n+        Object cur;\n+        for (Iterator itr = os.iterator(); itr.hasNext();) {\n+            cur = itr.next();\n+            if (cur != null)\n+                sum = Filters.add(sum, type, cur, c);\n+        }\n+        return sum;\n+    }\n+}"},{"sha":"cfd8e498003dc5ca79eeb77d88f35c3074850484","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/This.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/This.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/This.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/This.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Represents the 'this' ptr in a filter.\n+ *\n+ * @author Abe White\n+ */\n+class This\n+    extends Val {\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        return orig;\n+    }\n+\n+    public Class getType() {\n+        return getMetaData().getDescribedType();\n+    }\n+}"},{"sha":"2e6c81148fb93571870618df4f31cf69ef4f47fb","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToLowerCase.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToLowerCase.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToLowerCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToLowerCase.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Lower-case a string.\n+ *\n+ * @author Abe White\n+ */\n+class ToLowerCase\n+    extends Val {\n+\n+    private final Val _val;\n+\n+    /**\n+     * Constructor. Provide value to upper-case.\n+     */\n+    public ToLowerCase(Val val) {\n+        _val = val;\n+    }\n+\n+    public Class getType() {\n+        return String.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        return _val.eval(candidate, orig, ctx, params).toString().toLowerCase();\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}"},{"sha":"ffc0eb0879be6beeafc707b98908c605e7a9584c","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToUpperCase.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToUpperCase.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToUpperCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ToUpperCase.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Upper-case a string.\n+ *\n+ * @author Abe White\n+ */\n+class ToUpperCase\n+    extends Val {\n+\n+    private final Val _val;\n+\n+    /**\n+     * Constructor. Provide value to upper-case.\n+     */\n+    public ToUpperCase(Val val) {\n+        _val = val;\n+    }\n+\n+    public Class getType() {\n+        return String.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        return _val.eval(candidate, orig, ctx, params).toString().\n+            toUpperCase();\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}"},{"sha":"3d73f282d52d07905d2a052b25e4edbaa9ce9717","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Trim.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Trim.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Trim.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Trim.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Trims leading, trailing, or both charactes from a String.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+class Trim\n+    extends Val {\n+\n+    private final Val _val;\n+    private final Val _trimChar;\n+    private final Boolean _where;\n+\n+    /**\n+     * Constructor. Provide value to upper-case.\n+     */\n+    public Trim(Val val, Val trimChar, Boolean where) {\n+        _val = val;\n+        _trimChar = trimChar;\n+        _where = where;\n+    }\n+\n+    public Class getType() {\n+        return String.class;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Object eval = _val.eval(candidate, orig, ctx, params);\n+        if (eval == null)\n+            return null;\n+\n+        String toTrim = _trimChar.eval(candidate, orig, ctx, params).\n+            toString();\n+        String str = eval.toString();\n+\n+        // null indicates both, TRUE indicates leading\n+        if (_where == null || Boolean.TRUE.equals(_where)) {\n+            while (str.startsWith(toTrim))\n+                str = str.substring(toTrim.length());\n+        }\n+\n+        // null indicates both, FALSE indicates trailing\n+        if (_where == null || Boolean.FALSE.equals(_where)) {\n+            while (str.endsWith(toTrim))\n+                str = str.substring(0, str.length() - toTrim.length());\n+        }\n+        return str;\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val.acceptVisit(visitor);\n+        _trimChar.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}\n+"},{"sha":"f6a71d12178e6917c9fda073e31521f3ec167deb","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnaryMathVal.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnaryMathVal.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnaryMathVal.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnaryMathVal.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Value produced by a mathematical operation on one value.\n+ *\n+ * @author Abe White\n+ */\n+abstract class UnaryMathVal\n+    extends Val {\n+\n+    private final Val _val;\n+\n+    /**\n+     * Constructor. Provide the value to operate on.\n+     */\n+    public UnaryMathVal(Val val) {\n+        _val = val;\n+    }\n+\n+    public Class getType() {\n+        return getType(_val.getType());\n+    }\n+\n+    public void setImplicitType(Class type) {\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Object o1 = _val.eval(candidate, orig, ctx, params);\n+        return operate(o1, _val.getType());\n+    }\n+\n+    /**\n+     * Return the type of this value based on the numeric type being operated\n+     * on.\n+     */\n+    protected abstract Class getType(Class c);\n+\n+    /**\n+     * Return the result of this mathematical operation on the given value.\n+     */\n+    protected abstract Object operate(Object o, Class c);\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}"},{"sha":"66b8e79ca378338da7e878bbc6a8eba5776d9b5d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnboundVariable.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnboundVariable.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnboundVariable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/UnboundVariable.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Represents an unbound variable. When the query is evaluated,\n+ * expressions containing unbound variables will be\n+ * executed once for every element in the type's extent.\n+ *\n+ * @author Abe White\n+ */\n+class UnboundVariable\n+    extends Val {\n+\n+    private Class _type = null;\n+    private Object _val = null;\n+\n+    /**\n+     * Constructor. Provide variable name and type.\n+     */\n+    public UnboundVariable(Class type) {\n+        _type = type;\n+    }\n+\n+    public boolean isVariable() {\n+        return true;\n+    }\n+\n+    public Class getType() {\n+        return _type;\n+    }\n+\n+    public void setImplicitType(Class type) {\n+        _type = type;\n+    }\n+\n+    /**\n+     * Set the variable's current value. Expressions can be evaluated\n+     * for every possible object in the extent of each unbound variable\n+     * when looking for a match.\n+     */\n+    public void setValue(Object value) {\n+        _val = value;\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        return _val;\n+    }\n+}\n+"},{"sha":"da054c7d722a178d3f04274d3eefe1eb1e6997a8","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","status":"added","additions":121,"deletions":0,"changes":121,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * An in-memory representation of a {@link Value}.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public abstract class Val\n+    implements Value {\n+\n+    private ClassMetaData _meta = null;\n+\n+    /**\n+     * Return this value as a projection on the given candidate.\n+     */\n+    public final Object evaluate(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        try {\n+            return eval(candidate, candidate, ctx, params);\n+        } catch (NullPointerException npe) {\n+            return null;\n+        } catch (ClassCastException cce) {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Return this value as an aggregate projection on the given group\n+     * of candidates.\n+     */\n+    public final Object evaluate(Collection candidates, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        try {\n+            Collection c = eval(candidates, orig, ctx, params);\n+            if (c.isEmpty())\n+                return null;\n+            return c.iterator().next();\n+        } catch (NullPointerException npe) {\n+            return null;\n+        } catch (ClassCastException cce) {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Return this value for the given candidate.\n+     */\n+    protected abstract Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params);\n+\n+    /**\n+     * Return a list of values resulting from evaluating each given\n+     * candidate. By default, this implementation invokes\n+     * {@link #eval(Object,Object,StoreContext,Map)} for\n+     * each instance and packs the return value into a new list. Aggregates\n+     * should override.\n+     */\n+    protected Collection eval(Collection candidates, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Collection ret = new ArrayList(candidates.size());\n+        Object candidate;\n+        for (Iterator itr = candidates.iterator(); itr.hasNext();) {\n+            candidate = itr.next();\n+            ret.add(evaluate(candidate, (orig == null) ? candidate : orig,\n+                ctx, params));\n+        }\n+        return ret;\n+    }\n+\n+    public ClassMetaData getMetaData() {\n+        return _meta;\n+    }\n+\n+    public void setMetaData(ClassMetaData meta) {\n+        _meta = meta;\n+\t}\n+\n+    public boolean isVariable() {\n+        return false;\n+    }\n+\n+    public boolean isAggregate() {\n+        return false;\n+    }\n+    \n+    public boolean isXPath() {\n+        return false;\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        visitor.exit(this);\n+    }\n+}"},{"sha":"14be942d0ecb51cd0a26e888b7f12081a13395f3","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValExpression.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValExpression.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValExpression.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.util.Collection;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Boolean value used as an expression.\n+ *\n+ * @author Abe White\n+ */\n+class ValExpression\n+    extends Exp {\n+\n+    private final Val _val;\n+\n+    /**\n+     * Constructor. Supply value.\n+     */\n+    public ValExpression(Val val) {\n+        _val = val;\n+    }\n+\n+    protected boolean eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        Object o = _val.eval(candidate, orig, ctx, params);\n+        return o != null && ((Boolean) o).booleanValue();\n+    }\n+\n+    protected boolean eval(Collection candidates, StoreContext ctx,\n+        Object[] params) {\n+        Collection c = _val.eval(candidates, null, ctx, params);\n+        Object o = (c == null || c.isEmpty()) ? null : c.iterator().next();\n+        return o != null && ((Boolean) o).booleanValue();\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}"},{"sha":"f2a74459846751595c9331119748bf68517f08ad","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java","status":"added","additions":76,"deletions":0,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.io.Serializable;\n+\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * Interface for any non-operator in a query filter, including\n+ * constants, variables, and object fields.\n+ *\n+ * @author Abe White\n+ */\n+public interface Value\n+    extends Serializable {\n+\n+    /**\n+     * Return the expected type for this value, or <code>Object</code> if\n+     * the type is unknown.\n+     */\n+    public Class getType();\n+\n+    /**\n+     * Set the implicit type of the value, based on how it is used in the\n+     * filter. This method is only called on values who return\n+     * <code>Object</code> from {@link #getType}.\n+     */\n+    public void setImplicitType(Class type);\n+\n+    /**\n+     * Return true if this value is a variable.\n+     */\n+    public boolean isVariable();\n+\n+    /**\n+     * Return true if this value is an aggregate.\n+     */\n+    public boolean isAggregate();\n+\n+    /**\n+     * Return true if this value is an XML Path.\n+     */\n+    public boolean isXPath();\n+    \n+    /**\n+     * Return any associated persistent type.\n+     */\n+    public ClassMetaData getMetaData();\n+\n+    /**\n+     * Associate a persistent type with this value.\n+     */\n+    public void setMetaData(ClassMetaData meta);\n+\n+    /**\n+     * Accept a visit from a tree visitor.\n+     */\n+    public void acceptVisit(ExpressionVisitor visitor);\n+}"},{"sha":"e70f1c958556e0eda1e27268d3e9e9309bde5d79","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValuePath.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValuePath.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValuePath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/ValuePath.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+\n+/**\n+ * Represents a path that begins with a variable or parameter.\n+ *\n+ * @author Abe White\n+ */\n+class ValuePath\n+    extends CandidatePath {\n+\n+    private final Val _val;\n+\n+    /**\n+     * Constructor. Supply context value.\n+     */\n+    public ValuePath(Val val) {\n+        _val = val;\n+    }\n+\n+    public Class getCandidateType() {\n+        return _val.getType();\n+    }\n+\n+    protected Object eval(Object candidate, Object orig,\n+        StoreContext ctx, Object[] params) {\n+        // evaluate with the value's value\n+        return super.eval(_val.eval(candidate, orig, ctx, params), orig,\n+            ctx, params);\n+    }\n+\n+    public void acceptVisit(ExpressionVisitor visitor) {\n+        visitor.enter(this);\n+        _val.acceptVisit(visitor);\n+        visitor.exit(this);\n+    }\n+}\n+"},{"sha":"538a800d56e300eeb9dfc886a7d75ddca02c166c","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/WildcardMatch.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/WildcardMatch.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/WildcardMatch.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/WildcardMatch.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.lib.util.SimpleRegex;\n+\n+/**\n+ * Tests if the target matches the wildcard expression given in the\n+ * argument. The wildcard '?' is used to represent any single character,\n+ * while '*' is used to represent any series of 0 or more characters.\n+ *  Examples:<br />\n+ * <code> \"address.street.ext:wildcardMatch (\\\"?ain*reet\\\")\"\n+ * </code>\n+ *\n+ * @deprecated Use <code>matches()</code> instead.\n+ * @nojavadoc\n+ */\n+public class WildcardMatch\n+    implements FilterListener {\n+\n+    public static final String TAG = \"wildcardMatch\";\n+\n+    public String getTag() {\n+        return TAG;\n+    }\n+\n+    public boolean expectsArguments() {\n+        return true;\n+    }\n+\n+    public boolean expectsTarget() {\n+        return true;\n+    }\n+\n+    public Object evaluate(Object target, Class targetClass, Object[] args,\n+        Class[] argClasses, Object candidate, StoreContext ctx) {\n+        if (target == null || args[0] == null)\n+            return Boolean.FALSE;\n+\n+        // create a regexp for the wildcard expression by subbing '.' for '?'\n+        // and '.*' for '*'\n+        String wild = args[0].toString().replace('?', '.');\n+        for (int st = 0, i; (i = wild.indexOf(\"*\", st)) != -1; st = i + 3)\n+            wild = wild.substring(0, i) + \".\" + wild.substring(i);\n+\n+        SimpleRegex re = new SimpleRegex(wild, false);\n+        return (re.matches(target.toString())) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    public Class getType(Class targetClass, Class[] argClasses) {\n+        return boolean.class;\n+    }\n+}"},{"sha":"35ccff0e4cd58aad1779bc8b4f811f5e1a44a7fe","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/package.html","status":"added","additions":23,"deletions":0,"changes":23,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/package.html","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/package.html?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,23 @@\n+<!--\n+ Licensed to the Apache Software Foundation (ASF) under one\n+ or more contributor license agreements.  See the NOTICE file\n+ distributed with this work for additional information\n+ regarding copyright ownership.  The ASF licenses this file\n+ to you under the Apache License, Version 2.0 (the\n+ \"License\"); you may not use this file except in compliance\n+ with the License.  You may obtain a copy of the License at\n+ \n+ http://www.apache.org/licenses/LICENSE-2.0\n+ \n+ Unless required by applicable law or agreed to in writing,\n+ software distributed under the License is distributed on an\n+ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ KIND, either express or implied.  See the License for the\n+ specific language governing permissions and limitations\n+ under the License.   \n+-->\n+<html>\n+<body>\n+<p><strong>OpenJPA Expression Tree</strong></p>\n+</body>\n+</html>"},{"sha":"1bf5af3824a9c71b765c664b3952dd00dddd5ec5","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","status":"added","additions":1775,"deletions":0,"changes":1775,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,1775 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.jpql;\n+\n+import java.io.PrintStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.Stack;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.collections.map.LinkedMap;\n+import org.apache.openjpa.kernel.ExpressionStoreQuery;\n+import org.apache.openjpa.kernel.QueryContext;\n+import org.apache.openjpa.kernel.QueryOperations;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.kernel.BrokerFactory;\n+import org.apache.openjpa.kernel.exps.AbstractExpressionBuilder;\n+import org.apache.openjpa.kernel.exps.Expression;\n+import org.apache.openjpa.kernel.exps.ExpressionFactory;\n+import org.apache.openjpa.kernel.exps.Literal;\n+import org.apache.openjpa.kernel.exps.Parameter;\n+import org.apache.openjpa.kernel.exps.Path;\n+import org.apache.openjpa.kernel.exps.QueryExpressions;\n+import org.apache.openjpa.kernel.exps.Subquery;\n+import org.apache.openjpa.kernel.exps.Value;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.meta.ValueMetaData;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.UserException;\n+import org.apache.openjpa.conf.Compatibility;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import serp.util.Numbers;\n+\n+/**\n+ * Builder for JPQL expressions. This class takes the query parsed\n+ * in {@link JPQL} and converts it to an expression tree using\n+ * an {@link ExpressionFactory}. Public for unit testing purposes.\n+ *\n+ * @author Marc Prud'hommeaux\n+ * @author Patrick Linskey\n+ * @nojavadoc\n+ */\n+public class JPQLExpressionBuilder\n+    extends AbstractExpressionBuilder\n+    implements JPQLTreeConstants {\n+\n+    private static final int VAR_PATH = 1;\n+    private static final int VAR_ERROR = 2;\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (JPQLExpressionBuilder.class);\n+\n+    private final Stack contexts = new Stack();\n+    private LinkedMap parameterTypes;\n+    private int aliasCount = 0;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param factory the expression factory to use\n+     * @param query used to resolve variables, parameters,\n+     * and class names used in the query\n+     * @param parsedQuery the parsed query\n+     */\n+    public JPQLExpressionBuilder(ExpressionFactory factory,\n+        ExpressionStoreQuery query, Object parsedQuery) {\n+        super(factory, query.getResolver());\n+\n+        contexts.push(new Context(parsedQuery instanceof ParsedJPQL\n+            ? (ParsedJPQL) parsedQuery\n+            : parsedQuery instanceof String\n+            ? getParsedQuery((String) parsedQuery)\n+            : null, null));\n+\n+        if (ctx().parsed == null)\n+            throw new InternalException(parsedQuery + \"\");\n+    }\n+\n+    protected Localizer getLocalizer() {\n+        return _loc;\n+    }\n+\n+    protected ClassLoader getClassLoader() {\n+        // we don't resolve in the context of anything but ourselves\n+        return getClass().getClassLoader();\n+    }\n+\n+    protected ParsedJPQL getParsedQuery() {\n+        return ctx().parsed;\n+    }\n+\n+    protected ParsedJPQL getParsedQuery(String jpql) {\n+        return new ParsedJPQL(jpql);\n+    }\n+\n+    private void setCandidate(ClassMetaData cmd, String schemaAlias) {\n+        addAccessPath(cmd);\n+\n+        if (cmd != null)\n+            ctx().meta = cmd;\n+\n+        if (schemaAlias != null)\n+            ctx().schemaAlias = schemaAlias;\n+    }\n+\n+    private String nextAlias() {\n+        return \"jpqlalias\" + (++aliasCount);\n+    }\n+\n+    protected ClassMetaData resolveClassMetaData(JPQLNode node) {\n+        // handle looking up alias names\n+        String schemaName = assertSchemaName(node);\n+        ClassMetaData cmd = getClassMetaData(schemaName, false);\n+        if (cmd != null)\n+            return cmd;\n+\n+        // we might be referencing a collection field of a subquery's parent\n+        if (isPath(node)) {\n+            Path path = getPath(node);\n+            return getFieldType(path.last());\n+        }\n+\n+        // now run again to throw the correct exception\n+        return getClassMetaData(schemaName, true);\n+    }\n+\n+    private ClassMetaData getClassMetaData(String alias, boolean assertValid) {\n+        ClassLoader loader = getClassLoader();\n+        MetaDataRepository repos = resolver.getConfiguration().\n+            getMetaDataRepositoryInstance();\n+\n+        // first check for the alias\n+        ClassMetaData cmd = repos.getMetaData(alias, loader, false);\n+\n+        if (cmd != null)\n+            return cmd;\n+\n+        // now check for the class name; this is not technically permitted\n+        // by the JPA spec, but is required in order to be able to execute\n+        // JPQL queries from other facades (like JDO) that do not have\n+        // the concept of entity names or aliases\n+        Class c = resolver.classForName(alias, null);\n+        if (c != null)\n+            cmd = repos.getMetaData(c, loader, assertValid);\n+        else if (assertValid)\n+            cmd = repos.getMetaData(alias, loader, false);\n+\n+        if (cmd == null && assertValid) {\n+            String close = repos.getClosestAliasName(alias);\n+            if (close != null)\n+                throw parseException(EX_USER, \"not-schema-name-hint\",\n+                    new Object[]{ alias, close, repos.getAliasNames() }, null);\n+            else\n+                throw parseException(EX_USER, \"not-schema-name\",\n+                    new Object[]{ alias, repos.getAliasNames() }, null);\n+        }\n+\n+        return cmd;\n+    }\n+\n+    private Class getCandidateType() {\n+        return getCandidateMetaData().getDescribedType();\n+    }\n+\n+    private ClassMetaData getCandidateMetaData() {\n+        if (ctx().meta != null)\n+            return ctx().meta;\n+\n+        ClassMetaData cls = getCandidateMetaData(root());\n+        if (cls == null)\n+            throw parseException(EX_USER, \"not-schema-name\",\n+                new Object[]{ root() }, null);\n+\n+        setCandidate(cls, null);\n+        return cls;\n+    }\n+\n+    protected ClassMetaData getCandidateMetaData(JPQLNode node) {\n+        // examing the node to find the candidate query\n+        // ### this should actually be the primary SELECT instance\n+        // resolved against the from variable declarations\n+        JPQLNode from = node.findChildByID(JJTFROMITEM, true);\n+        if (from == null) {\n+            // OPENJPA-15 allow subquery without a FROMITEM\n+            if (node.id == JJTSUBSELECT) { \n+                from = node.findChildByID(JJTFROM, true);\n+            }\n+            else {\n+                throw parseException(EX_USER, \"no-from-clause\", null, null);\n+            }\n+        }\n+\n+        for (int i = 0; i < from.children.length; i++) {\n+            JPQLNode n = from.children[i];\n+\n+            if (n.id == JJTABSTRACTSCHEMANAME) {\n+                // we simply return the first abstract schema child\n+                // as resolved into a class\n+                ClassMetaData cmd = resolveClassMetaData(n);\n+\n+                if (cmd != null)\n+                    return cmd;\n+\n+                // not a schema: treat it as a class\n+                String cls = assertSchemaName(n);\n+                if (cls == null)\n+                    throw parseException(EX_USER, \"not-schema-name\",\n+                        new Object[]{ root() }, null);\n+\n+                return getClassMetaData(cls, true);\n+            }\n+            // OPENJPA-15 support subquery's from clause do not start with \n+            // identification_variable_declaration()\n+            if (node.id == JJTSUBSELECT) {\n+                if (n.id == JJTINNERJOIN) {\n+                    n = n.getChild(0);\n+                }\n+                if (n.id == JJTPATH) {\n+                    Path path = getPath(n);\n+                    ClassMetaData cmd = getFieldType(path.last());\n+                    if (cmd != null) {\n+                        return cmd;\n+                    }\n+                    else {\n+                        throw parseException(EX_USER, \"no-alias\", \n+                                new Object[]{ n }, null);\n+                    }\n+                }\n+            }           \n+        }\n+\n+        return null;\n+    }\n+\n+    protected String currentQuery() {\n+        return ctx().parsed == null || root().parser == null ? null\n+            : root().parser.jpql;\n+    }\n+\n+    QueryExpressions getQueryExpressions() {\n+        QueryExpressions exps = new QueryExpressions();\n+\n+        evalQueryOperation(exps);\n+\n+        Expression filter = null;\n+        filter = and(evalFromClause(root().id == JJTSELECT), filter);\n+        filter = and(evalWhereClause(), filter);\n+        filter = and(evalSelectClause(exps), filter);\n+\n+        exps.filter = filter == null ? factory.emptyExpression() : filter;\n+\n+        evalGroupingClause(exps);\n+        evalHavingClause(exps);\n+        evalFetchJoins(exps);\n+        evalSetClause(exps);\n+        evalOrderingClauses(exps);\n+\n+        if (parameterTypes != null)\n+            exps.parameterTypes = parameterTypes;\n+\n+        exps.accessPath = getAccessPath();\n+\n+        return exps;\n+    }\n+\n+    private Expression and(Expression e1, Expression e2) {\n+        return e1 == null ? e2 : e2 == null ? e1 : factory.and(e1, e2);\n+    }\n+\n+    private static String assemble(JPQLNode node) {\n+        return assemble(node, \".\", 0);\n+    }\n+\n+    /**\n+     * Assemble the children of the specific node by appending each\n+     * child, separated by the delimiter.\n+     */\n+    private static String assemble(JPQLNode node, String delimiter, int last) {\n+        StringBuffer result = new StringBuffer();\n+        JPQLNode[] parts = node.children;\n+        for (int i = 0; parts != null && i < parts.length - last; i++)\n+            result.append(result.length() > 0 ? delimiter : \"\").\n+                append(parts[i].text);\n+\n+        return result.toString();\n+    }\n+\n+    private Expression assignProjections(JPQLNode parametersNode,\n+        QueryExpressions exps) {\n+        int count = parametersNode.getChildCount();\n+        exps.projections = new Value[count];\n+        exps.projectionClauses = new String[count];\n+        exps.projectionAliases = new String[count];\n+\n+        Expression exp = null;\n+        for (int i = 0; i < count; i++) {\n+            JPQLNode parent = parametersNode.getChild(i);\n+            JPQLNode node = onlyChild(parent);\n+            Value proj = getValue(node);\n+            exps.projections[i] = proj;\n+            exps.projectionClauses[i] = assemble(node);\n+            exps.projectionAliases[i] = nextAlias();\n+        }\n+        return exp;\n+    }\n+\n+    private void evalQueryOperation(QueryExpressions exps) {\n+        // determine whether we want to select, delete, or update\n+        if (root().id == JJTSELECT || root().id == JJTSUBSELECT)\n+            exps.operation = QueryOperations.OP_SELECT;\n+        else if (root().id == JJTDELETE)\n+            exps.operation = QueryOperations.OP_DELETE;\n+        else if (root().id == JJTUPDATE)\n+            exps.operation = QueryOperations.OP_UPDATE;\n+        else\n+            throw parseException(EX_UNSUPPORTED, \"unrecognized-operation\",\n+                new Object[]{ root() }, null);\n+    }\n+\n+    private void evalGroupingClause(QueryExpressions exps) {\n+        // handle GROUP BY clauses\n+        JPQLNode groupByNode = root().findChildByID(JJTGROUPBY, false);\n+\n+        if (groupByNode == null)\n+            return;\n+\n+        int groupByCount = groupByNode.getChildCount();\n+\n+        exps.grouping = new Value[groupByCount];\n+\n+        for (int i = 0; i < groupByCount; i++) {\n+            JPQLNode node = groupByNode.getChild(i);\n+            exps.grouping[i] = getValue(node);\n+        }\n+    }\n+\n+    private void evalHavingClause(QueryExpressions exps) {\n+        // handle HAVING clauses\n+        JPQLNode havingNode = root().findChildByID(JJTHAVING, false);\n+\n+        if (havingNode == null)\n+            return;\n+\n+        exps.having = getExpression(onlyChild(havingNode));\n+    }\n+\n+    private void evalOrderingClauses(QueryExpressions exps) {\n+        // handle ORDER BY clauses\n+        JPQLNode orderby = root().findChildByID(JJTORDERBY, false);\n+        if (orderby != null) {\n+            int ordercount = orderby.getChildCount();\n+            exps.ordering = new Value[ordercount];\n+            exps.orderingClauses = new String[ordercount];\n+            exps.ascending = new boolean[ordercount];\n+            for (int i = 0; i < ordercount; i++) {\n+                JPQLNode node = orderby.getChild(i);\n+                exps.ordering[i] = getValue(firstChild(node));\n+                exps.orderingClauses[i] = assemble(firstChild(node));\n+                // ommission of ASC/DESC token implies ascending\n+                exps.ascending[i] = node.getChildCount() <= 1 ||\n+                    lastChild(node).id == JJTASCENDING ? true : false;\n+            }\n+        }\n+    }\n+\n+    private Expression evalSelectClause(QueryExpressions exps) {\n+        if (exps.operation != QueryOperations.OP_SELECT)\n+            return null;\n+\n+        JPQLNode selectNode = root();\n+\n+        JPQLNode selectClause = selectNode.\n+            findChildByID(JJTSELECTCLAUSE, false);\n+        if (selectClause != null && selectClause.hasChildID(JJTDISTINCT))\n+            exps.distinct = exps.DISTINCT_TRUE | exps.DISTINCT_AUTO;\n+        else\n+            exps.distinct = exps.DISTINCT_FALSE;\n+\n+        JPQLNode constructor = selectNode.findChildByID(JJTCONSTRUCTOR, true);\n+        if (constructor != null) {\n+            // build up the fully-qualified result class name by\n+            // appending together the components of the children\n+            String resultClassName = assemble(left(constructor));\n+            exps.resultClass = resolver.classForName(resultClassName, null);\n+\n+            // now assign the arguments to the select clause as the projections\n+            return assignProjections(right(constructor), exps);\n+        } else {\n+            // handle SELECT clauses\n+            JPQLNode expNode = selectNode.\n+                findChildByID(JJTSELECTEXPRESSIONS, true);\n+            if (expNode == null)\n+                return null;\n+\n+            int selectCount = expNode.getChildCount();\n+            JPQLNode selectChild = firstChild(expNode);\n+\n+            // if we are selecting just one thing and that thing is the\n+            // schema's alias, then do not treat it as a projection\n+            if (selectCount == 1 && selectChild != null &&\n+                selectChild.getChildCount() == 1 &&\n+                onlyChild(selectChild) != null &&\n+                assertSchemaAlias().\n+                    equalsIgnoreCase(onlyChild(selectChild).text)) {\n+                return null;\n+            } else {\n+                // JPQL does not filter relational joins for projections\n+                exps.distinct &= ~exps.DISTINCT_AUTO;\n+                return assignProjections(expNode, exps);\n+            }\n+        }\n+    }\n+\n+    private String assertSchemaAlias() {\n+        String alias = ctx().schemaAlias;\n+\n+        if (alias == null)\n+            throw parseException(EX_USER, \"alias-required\",\n+                new Object[]{ ctx().meta }, null);\n+\n+        return alias;\n+    }\n+\n+    protected Expression evalFetchJoins(QueryExpressions exps) {\n+        Expression filter = null;\n+\n+        // handle JOIN FETCH\n+        Set joins = null;\n+        Set innerJoins = null;\n+\n+        JPQLNode[] outers = root().findChildrenByID(JJTOUTERFETCHJOIN);\n+        for (int i = 0; outers != null && i < outers.length; i++)\n+            (joins == null ? joins = new TreeSet() : joins).\n+                add(getPath(onlyChild(outers[i])).last().getFullName(false));\n+\n+        JPQLNode[] inners = root().findChildrenByID(JJTINNERFETCHJOIN);\n+        for (int i = 0; inners != null && i < inners.length; i++) {\n+            String path = getPath(onlyChild(inners[i])).last()\n+                .getFullName(false);\n+            (joins == null ? joins = new TreeSet() : joins).add(path);\n+            (innerJoins == null ? innerJoins = new TreeSet() : innerJoins).\n+                add(path);\n+        }\n+\n+        if (joins != null)\n+            exps.fetchPaths = (String[]) joins.\n+                toArray(new String[joins.size()]);\n+        if (innerJoins != null)\n+            exps.fetchInnerPaths = (String[]) innerJoins.\n+                toArray(new String[innerJoins.size()]);\n+\n+        return filter;\n+    }\n+\n+    protected void evalSetClause(QueryExpressions exps) {\n+        // handle SET field = value\n+        JPQLNode[] nodes = root().findChildrenByID(JJTUPDATEITEM);\n+        for (int i = 0; nodes != null && i < nodes.length; i++) {\n+            Path path = getPath(firstChild(nodes[i]));\n+            JPQLNode lastChild = lastChild(nodes[i]);\n+            Value val = (lastChild.children == null) \n+                      ? null : getValue(onlyChild(lastChild));\n+            exps.putUpdate(path, val);\n+        }\n+    }\n+\n+    private Expression evalWhereClause() {\n+        // evaluate the WHERE clause\n+        JPQLNode whereNode = root().findChildByID(JJTWHERE, false);\n+        if (whereNode == null)\n+            return null;\n+        return (Expression) eval(whereNode);\n+    }\n+\n+    private Expression evalFromClause(boolean needsAlias) {\n+        Expression exp = null;\n+\n+        // build up the alias map in the FROM clause\n+        JPQLNode from = root().findChildByID(JJTFROM, false);\n+        if (from == null)\n+            throw parseException(EX_USER, \"no-from-clause\", null, null);\n+\n+        for (int i = 0; i < from.children.length; i++) {\n+            JPQLNode node = from.children[i];\n+\n+            if (node.id == JJTFROMITEM)\n+                exp = evalFromItem(exp, node, needsAlias);\n+            else if (node.id == JJTOUTERJOIN)\n+                exp = addJoin(node, false, exp);\n+            else if (node.id == JJTINNERJOIN)\n+                exp = addJoin(node, true, exp);\n+            else if (node.id == JJTINNERFETCHJOIN)\n+                ; // we handle inner fetch joins in the evalFetchJoins() method\n+            else if (node.id == JJTOUTERFETCHJOIN)\n+                ; // we handle outer fetch joins in the evalFetchJoins() method\n+            else\n+                throw parseException(EX_USER, \"not-schema-name\",\n+                    new Object[]{ node }, null);\n+        }\n+\n+        return exp;\n+    }\n+\n+    /**\n+     * Adds a join condition to the given expression.\n+     *\n+     * @param node the node to check\n+     * @param inner whether or not the join should be an inner join\n+     * @param exp an existing expression to AND, or null if none\n+     * @return the Expression with the join condition added\n+     */\n+    private Expression addJoin(JPQLNode node, boolean inner, Expression exp) {\n+        // the type will be the declared type for the field\n+        Path path = getPath(firstChild(node), false, inner);\n+\n+        JPQLNode alias = node.getChildCount() >= 2 ? right(node) : null;\n+        // OPENJPA-15 support subquery's from clause do not start with \n+        // identification_variable_declaration()\n+        if (inner && ctx().subquery != null && ctx().schemaAlias == null) {\n+            setCandidate(getFieldType(path.last()), alias.text);\n+\n+            Path subpath = factory.newPath(ctx().subquery);\n+            subpath.setMetaData(ctx().subquery.getMetaData());\n+            exp =  and(exp, factory.equal(path, subpath));\n+        }\n+\n+        return addJoin(path, alias, exp);\n+    }\n+\n+    private Expression addJoin(Path path, JPQLNode aliasNode,\n+        Expression exp) {\n+        FieldMetaData fmd = path.last();\n+\n+        if (fmd == null)\n+            throw parseException(EX_USER, \"path-no-meta\",\n+                new Object[]{ path, null }, null);\n+\n+        String alias = aliasNode != null ? aliasNode.text : nextAlias();\n+\n+        Value var = getVariable(alias, true);\n+        var.setMetaData(getFieldType(fmd));\n+\n+        Expression join = null;\n+\n+        // if the variable is already bound, get the var's value and\n+        // do a regular contains with that\n+        boolean bound = isBound(var);\n+        if (bound) {\n+            var = getValue(aliasNode, VAR_PATH);\n+        } else {\n+            bind(var);\n+            join = and(join, factory.bindVariable(var, path));\n+        }\n+\n+        if (!fmd.isTypePC()) // multi-valued relation\n+        {\n+            if (bound)\n+                join = and(join, factory.contains(path, var));\n+\n+            setImplicitContainsTypes(path, var, CONTAINS_TYPE_ELEMENT);\n+        }\n+\n+        return and(exp, join);\n+    }\n+\n+    private Expression evalFromItem(Expression exp, JPQLNode node,\n+        boolean needsAlias) {\n+        ClassMetaData cmd = resolveClassMetaData(firstChild(node));\n+\n+        String alias = null;\n+\n+        if (node.getChildCount() < 2) {\n+            if (needsAlias)\n+                throw parseException(EX_USER, \"alias-required\",\n+                    new Object[]{ cmd }, null);\n+        } else {\n+            alias = right(node).text;\n+            JPQLNode left = left(node);\n+\n+            // check to see if the we are referring to a path in the from\n+            // clause, since we might be in a subquery against a collection\n+            if (isPath(left)) {\n+                Path path = getPath(left);\n+                setCandidate(getFieldType(path.last()), alias);\n+\n+                Path subpath = factory.newPath(ctx().subquery);\n+                subpath.setMetaData(ctx().subquery.getMetaData());\n+                return and(exp, factory.equal(path, subpath));\n+            } else {\n+                // we have an alias: bind it as a variable\n+                Value var = getVariable(alias, true);\n+                var.setMetaData(cmd);\n+                bind(var);\n+            }\n+        }\n+\n+        // ### we assign the first FROMITEM instance we see as\n+        // the global candidate, which is incorrect: we should\n+        // instead be mapping this to the SELECTITEM to see\n+        // which is the desired candidate\n+        if (ctx().schemaAlias == null)\n+            setCandidate(cmd, alias);\n+\n+        return exp;\n+    }\n+\n+    protected boolean isDeclaredVariable(String name) {\n+        // JPQL doesn't support declaring variables\n+        return false;\n+    }\n+\n+    /**\n+     * Check to see if the specific node is a path (vs. a schema name)\n+     */\n+    boolean isPath(JPQLNode node) {\n+        if (node.getChildCount() < 2)\n+            return false;\n+\n+        final String name = firstChild(node).text;\n+        if (name == null)\n+            return false;\n+\n+        // handle the case where the class name is the alias\n+        // for the candidate (we don't use variables for this)\n+        if (getMetaDataForAlias(name) != null)\n+            return true;\n+\n+        if (!isSeenVariable(name))\n+            return false;\n+\n+        final Value var = getVariable(name, false);\n+\n+        if (var != null)\n+            return isBound(var);\n+\n+        return false;\n+    }\n+\n+    private static ClassMetaData getFieldType(FieldMetaData fmd) {\n+        if (fmd == null)\n+            return null;\n+\n+        ClassMetaData cmd = null;\n+        ValueMetaData vmd;\n+\n+        if ((vmd = fmd.getElement()) != null)\n+            cmd = vmd.getDeclaredTypeMetaData();\n+        else if ((vmd = fmd.getKey()) != null)\n+            cmd = vmd.getDeclaredTypeMetaData();\n+        else if ((vmd = fmd.getValue()) != null)\n+            cmd = vmd.getDeclaredTypeMetaData();\n+\n+        if (cmd == null || cmd.getDescribedType() == Object.class)\n+            cmd = fmd.getDeclaredTypeMetaData();\n+\n+        return cmd;\n+    }\n+\n+    /**\n+     * Identification variables in JPQL are case insensitive, so lower-case\n+     * all variables we are going to bind.\n+     */\n+    protected Value getVariable(String id, boolean bind) {\n+        if (id == null)\n+            return null;\n+\n+        return super.getVariable(id.toLowerCase(), bind);\n+    }\n+\n+    protected boolean isSeendVariable(String id) {\n+        return id != null && super.isSeenVariable(id.toLowerCase());\n+    }\n+\n+    /**\n+     * Returns the class name using the children of the JPQLNode.\n+     */\n+    private String assertSchemaName(JPQLNode node) {\n+        if (node.id != JJTABSTRACTSCHEMANAME)\n+            throw parseException(EX_USER, \"not-identifer\",\n+                new Object[]{ node }, null);\n+\n+        return assemble(node);\n+    }\n+\n+    /**\n+     * Recursive helper method to evaluate the given node.\n+     */\n+    private Object eval(JPQLNode node) {\n+        Value val1 = null;\n+        Value val2 = null;\n+        Value val3 = null;\n+\n+        boolean not = node.not;\n+\n+        switch (node.id) {\n+            case JJTWHERE: // top-level WHERE clause\n+                return getExpression(onlyChild(node));\n+\n+            case JJTBOOLEANLITERAL:\n+                return factory.newLiteral(\"true\".equalsIgnoreCase\n+                    (node.text) ? Boolean.TRUE : Boolean.FALSE,\n+                    Literal.TYPE_BOOLEAN);\n+\n+            case JJTINTEGERLITERAL:\n+                // use BigDecimal because it can handle parsing exponents\n+                BigDecimal intlit = new BigDecimal\n+                    (node.text.endsWith(\"l\") || node.text.endsWith(\"L\")\n+                        ? node.text.substring(0, node.text.length() - 1)\n+                        : node.text).\n+                    multiply(new BigDecimal(negative(node)));\n+                return factory.newLiteral(new Long(intlit.longValue()),\n+                    Literal.TYPE_NUMBER);\n+\n+            case JJTDECIMALLITERAL:\n+                BigDecimal declit = new BigDecimal\n+                    (node.text.endsWith(\"d\") || node.text.endsWith(\"D\") ||\n+                        node.text.endsWith(\"f\") || node.text.endsWith(\"F\")\n+                        ? node.text.substring(0, node.text.length() - 1)\n+                        : node.text).\n+                    multiply(new BigDecimal(negative(node)));\n+                return factory.newLiteral(declit, Literal.TYPE_NUMBER);\n+\n+            case JJTSTRINGLITERAL:\n+            case JJTTRIMCHARACTER:\n+            case JJTESCAPECHARACTER:\n+                return factory.newLiteral(trimQuotes(node.text),\n+                    Literal.TYPE_SQ_STRING);\n+\n+            case JJTPATTERNVALUE:\n+                return eval(firstChild(node));\n+\n+            case JJTNAMEDINPUTPARAMETER:\n+                return getParameter(node.text, false);\n+\n+            case JJTPOSITIONALINPUTPARAMETER:\n+                return getParameter(node.text, true);\n+\n+            case JJTOR: // x OR y\n+                return factory.or(getExpression(left(node)),\n+                    getExpression(right(node)));\n+\n+            case JJTAND: // x AND y\n+                return and(getExpression(left(node)),\n+                    getExpression(right(node)));\n+\n+            case JJTEQUALS: // x = y\n+                val1 = getValue(left(node));\n+                val2 = getValue(right(node));\n+                setImplicitTypes(val1, val2, null);\n+                return factory.equal(val1, val2);\n+\n+            case JJTNOTEQUALS: // x <> y\n+                val1 = getValue(left(node));\n+                val2 = getValue(right(node));\n+                setImplicitTypes(val1, val2, null);\n+                return factory.notEqual(val1, val2);\n+\n+            case JJTLESSTHAN: // x < y\n+                val1 = getValue(left(node));\n+                val2 = getValue(right(node));\n+                setImplicitTypes(val1, val2, null);\n+                return factory.lessThan(val1, val2);\n+\n+            case JJTLESSOREQUAL: // x <= y\n+                val1 = getValue(left(node));\n+                val2 = getValue(right(node));\n+                setImplicitTypes(val1, val2, null);\n+                return factory.lessThanEqual(val1, val2);\n+\n+            case JJTGREATERTHAN: // x > y\n+                val1 = getValue(left(node));\n+                val2 = getValue(right(node));\n+                setImplicitTypes(val1, val2, null);\n+                return factory.greaterThan(val1, val2);\n+\n+            case JJTGREATEROREQUAL: // x >= y\n+                val1 = getValue(left(node));\n+                val2 = getValue(right(node));\n+                setImplicitTypes(val1, val2, null);\n+                return factory.greaterThanEqual(val1, val2);\n+\n+            case JJTADD: // x + y\n+                val1 = getValue(left(node));\n+                val2 = getValue(right(node));\n+                setImplicitTypes(val1, val2, TYPE_NUMBER);\n+                return factory.add(val1, val2);\n+\n+            case JJTSUBTRACT: // x - y\n+                val1 = getValue(left(node));\n+                val2 = getValue(right(node));\n+                setImplicitTypes(val1, val2, TYPE_NUMBER);\n+                return factory.subtract(val1, val2);\n+\n+            case JJTMULTIPLY: // x * y\n+                val1 = getValue(left(node));\n+                val2 = getValue(right(node));\n+                setImplicitTypes(val1, val2, TYPE_NUMBER);\n+                return factory.multiply(val1, val2);\n+\n+            case JJTDIVIDE: // x / y\n+                val1 = getValue(left(node));\n+                val2 = getValue(right(node));\n+                setImplicitTypes(val1, val2, TYPE_NUMBER);\n+                return factory.divide(val1, val2);\n+\n+            case JJTBETWEEN: // x.field [NOT] BETWEEN 5 AND 10\n+                val1 = getValue(child(node, 0, 3));\n+                val2 = getValue(child(node, 1, 3));\n+                val3 = getValue(child(node, 2, 3));\n+                setImplicitTypes(val1, val2, null);\n+                setImplicitTypes(val1, val3, null);\n+                return evalNot(not, and(factory.greaterThanEqual(val1, val2),\n+                    factory.lessThanEqual(val1, val3)));\n+\n+            case JJTIN: // x.field [NOT] IN ('a', 'b', 'c')\n+\n+                Expression inExp = null;\n+                Iterator inIterator = node.iterator();\n+                // the first child is the path\n+                val1 = getValue((JPQLNode) inIterator.next());\n+\n+                while (inIterator.hasNext()) {\n+                    val2 = getValue((JPQLNode) inIterator.next());\n+\n+                    // special case for <value> IN (<subquery>) or\n+                    // <value> IN (<single value>)\n+                    if (!(val2 instanceof Literal) && node.getChildCount() == 2)\n+                        return evalNot(not, factory.contains(val2, val1)); \n+\n+                    // this is currently a sequence of OR expressions, since we\n+                    // do not have support for IN expressions\n+                    setImplicitTypes(val1, val2, null);\n+                    if (inExp == null)\n+                        inExp = factory.equal(val1, val2);\n+                    else\n+                        inExp = factory.or(inExp, factory.equal(val1, val2));\n+                }\n+\n+                // we additionally need to add in a \"NOT NULL\" clause, since\n+                // the IN behavior that is expected by the CTS also expects\n+                // to filter our NULLs\n+                return and(evalNot(not, inExp),\n+                    factory.notEqual(val1, factory.getNull()));\n+\n+            case JJTISNULL: // x.field IS [NOT] NULL\n+                if (not)\n+                    return factory.notEqual\n+                        (getValue(onlyChild(node)), factory.getNull());\n+                else\n+                    return factory.equal\n+                        (getValue(onlyChild(node)), factory.getNull());\n+\n+            case JJTPATH:\n+                return getPathOrConstant(node);\n+\n+            case JJTIDENTIFIER:\n+            case JJTIDENTIFICATIONVARIABLE:\n+                return getIdentifier(node);\n+\n+            case JJTNOT:\n+                return factory.not(getExpression(onlyChild(node)));\n+\n+            case JJTLIKE: // field LIKE '%someval%'\n+                val1 = getValue(left(node));\n+                val2 = getValue(right(node));\n+\n+                setImplicitType(val1, TYPE_STRING);\n+                setImplicitType(val2, TYPE_STRING);\n+\n+                // look for an escape character beneath the node\n+                String escape = null;\n+                JPQLNode escapeNode = right(node).\n+                    findChildByID(JJTESCAPECHARACTER, true);\n+                if (escapeNode != null)\n+                    escape = trimQuotes(onlyChild(escapeNode).text);\n+\n+                if (not)\n+                    return factory.notMatches(val1, val2, \"_\", \"%\", escape);\n+                else\n+                    return factory.matches(val1, val2, \"_\", \"%\", escape);\n+\n+            case JJTISEMPTY:\n+                return evalNot(not,\n+                    factory.isEmpty(getValue(onlyChild(node))));\n+\n+            case JJTSIZE:\n+                return factory.size(getValue(onlyChild(node)));\n+\n+            case JJTUPPER:\n+                val1 = getValue(onlyChild(node));\n+                setImplicitType(val1, TYPE_STRING);\n+                return factory.toUpperCase(val1);\n+\n+            case JJTLOWER:\n+                return factory.toLowerCase(getStringValue(onlyChild(node)));\n+\n+            case JJTLENGTH:\n+                return factory.stringLength(getStringValue(onlyChild(node)));\n+\n+            case JJTABS:\n+                return factory.abs(getNumberValue(onlyChild(node)));\n+\n+            case JJTSQRT:\n+                return factory.sqrt(getNumberValue(onlyChild(node)));\n+\n+            case JJTMOD:\n+                val1 = getValue(left(node));\n+                val2 = getValue(right(node));\n+                setImplicitTypes(val1, val2, TYPE_NUMBER);\n+                return factory.mod(val1, val2);\n+\n+            case JJTTRIM: // TRIM([[where] [char] FROM] field)\n+                val1 = getValue(lastChild(node));\n+                setImplicitType(val1, TYPE_STRING);\n+\n+                Boolean trimWhere = null;\n+\n+                JPQLNode firstTrimChild = firstChild(node);\n+\n+                if (node.getChildCount() > 1) {\n+                    trimWhere =\n+                        firstTrimChild.id == JJTTRIMLEADING ? Boolean.TRUE\n+                            :\n+                            firstTrimChild.id == JJTTRIMTRAILING ? Boolean.FALSE\n+                                : null;\n+                }\n+\n+                Value trimChar;\n+\n+                // if there are 3 children, then we know the trim\n+                // char is the second node\n+                if (node.getChildCount() == 3)\n+                    trimChar = getValue(secondChild(node));\n+                    // if there are two children, then we need to check to see\n+                    // if the first child is a leading/trailing/both node,\n+                    // or the trim character node\n+                else if (node.getChildCount() == 2\n+                    && firstTrimChild.id != JJTTRIMLEADING\n+                    && firstTrimChild.id != JJTTRIMTRAILING\n+                    && firstTrimChild.id != JJTTRIMBOTH)\n+                    trimChar = getValue(firstChild(node));\n+                    // othwerwise, we default to trimming the space character\n+                else\n+                    trimChar = factory.newLiteral(\" \", Literal.TYPE_STRING);\n+\n+                return factory.trim(val1, trimChar, trimWhere);\n+\n+            case JJTCONCAT:\n+                val1 = getValue(left(node));\n+                val2 = getValue(right(node));\n+                setImplicitType(val1, TYPE_STRING);\n+                setImplicitType(val2, TYPE_STRING);\n+                return factory.concat(val1, val2);\n+\n+            case JJTSUBSTRING:\n+                val1 = getValue(child(node, 0, 3));\n+                val2 = getValue(child(node, 1, 3));\n+                val3 = getValue(child(node, 2, 3));\n+                setImplicitType(val1, TYPE_STRING);\n+                setImplicitType(val2, Integer.TYPE);\n+                setImplicitType(val3, Integer.TYPE);\n+\n+                // the semantics of the JPQL substring() function\n+                // are that arg2 is the 1-based start index, and arg3 is\n+                // the length of the string to be return; this is different\n+                // than the semantics of the ExpressionFactory's substring,\n+                // which matches the Java language (0-based start index,\n+                // arg2 is the end index): we perform the translation by\n+                // adding one to the first argument, and then adding the\n+                // first argument to the second argument to get the endIndex\n+                Value start;\n+                Value end;\n+                if (val2 instanceof Literal && val3 instanceof Literal) {\n+                    // optimize SQL for the common case of two literals\n+                    long jpqlStart = ((Number) ((Literal) val2).getValue())\n+                        .longValue();\n+                    long length = ((Number) ((Literal) val3).getValue())\n+                        .longValue();\n+                    start = factory.newLiteral(new Long(jpqlStart - 1),\n+                        Literal.TYPE_NUMBER);\n+                    long endIndex = length + (jpqlStart - 1);\n+                    end = factory.newLiteral(new Long(endIndex),\n+                        Literal.TYPE_NUMBER);\n+                } else {\n+                    start = factory.subtract(val2, factory.newLiteral\n+                        (Numbers.valueOf(1), Literal.TYPE_NUMBER));\n+                    end = factory.add(val3,\n+                        (factory.subtract(val2, factory.newLiteral\n+                            (Numbers.valueOf(1), Literal.TYPE_NUMBER))));\n+                }\n+                return factory.substring(val1, factory.newArgumentList(\n+                    start, end));\n+\n+            case JJTLOCATE:\n+                // as with SUBSTRING (above), the semantics for LOCATE differ\n+                // from ExpressionFactory.indexOf in that LOCATE uses a\n+                // 0-based index, and indexOf uses a 1-based index\n+                Value locatePath = getValue(firstChild(node));\n+                Value locateSearch = getValue(secondChild(node));\n+                Value locateFromIndex = null;\n+                if (node.getChildCount() > 2) // optional start index arg\n+                    locateFromIndex = getValue(thirdChild(node));\n+\n+                setImplicitType(locatePath, TYPE_STRING);\n+                setImplicitType(locateSearch, TYPE_STRING);\n+\n+                if (locateFromIndex != null)\n+                    setImplicitType(locateFromIndex, TYPE_STRING);\n+\n+                return factory.add(factory.indexOf(locateSearch,\n+                    locateFromIndex == null ? locatePath\n+                        : factory.newArgumentList(locatePath,\n+                        factory.subtract(locateFromIndex,\n+                            factory.newLiteral(Numbers.valueOf(1),\n+                                Literal.TYPE_NUMBER)))),\n+                    factory.newLiteral(Numbers.valueOf(1),\n+                        Literal.TYPE_NUMBER));\n+\n+            case JJTAGGREGATE:\n+                // simply pass-through while asserting a single child\n+                return eval(onlyChild(node));\n+\n+            case JJTCOUNT:\n+                return factory.count(getValue(lastChild(node)));\n+\n+            case JJTMAX:\n+                return factory.max(getNumberValue(onlyChild(node)));\n+\n+            case JJTMIN:\n+                return factory.min(getNumberValue(onlyChild(node)));\n+\n+            case JJTSUM:\n+                return factory.sum(getNumberValue(onlyChild(node)));\n+\n+            case JJTAVERAGE:\n+                return factory.avg(getNumberValue(onlyChild(node)));\n+\n+            case JJTDISTINCTPATH:\n+                return factory.distinct(getValue(onlyChild(node)));\n+\n+            case JJTEXISTS:\n+                return factory.isNotEmpty((Value) eval(onlyChild(node)));\n+\n+            case JJTANY:\n+                return factory.any((Value) eval(onlyChild(node)));\n+\n+            case JJTALL:\n+                return factory.all((Value) eval(onlyChild(node)));\n+\n+            case JJTSUBSELECT:\n+                return getSubquery(node);\n+\n+            case JJTMEMBEROF:\n+                val1 = getValue(left(node), VAR_PATH);\n+                val2 = getValue(right(node), VAR_PATH);\n+                setImplicitContainsTypes(val2, val1, CONTAINS_TYPE_ELEMENT);\n+                return evalNot(not, factory.contains(val2, val1));\n+\n+            case JJTCURRENTDATE:\n+                return factory.getCurrentDate();\n+\n+            case JJTCURRENTTIME:\n+                return factory.getCurrentTime();\n+\n+            case JJTCURRENTTIMESTAMP:\n+                return factory.getCurrentTimestamp();\n+\n+            case JJTSELECTEXTENSION:\n+                assertQueryExtensions(\"SELECT\");\n+                return eval(onlyChild(node));\n+\n+            case JJTGROUPBYEXTENSION:\n+                assertQueryExtensions(\"GROUP BY\");\n+                return eval(onlyChild(node));\n+\n+            case JJTORDERBYEXTENSION:\n+                assertQueryExtensions(\"ORDER BY\");\n+                return eval(onlyChild(node));\n+\n+            default:\n+                throw parseException(EX_FATAL, \"bad-tree\",\n+                    new Object[]{ node }, null);\n+        }\n+    }\n+\n+    private void assertQueryExtensions(String clause) {\n+        OpenJPAConfiguration conf = resolver.getConfiguration();\n+        switch(conf.getCompatibilityInstance().getJPQL()) {\n+            case Compatibility.JPQL_WARN:\n+                // check if we've already warned for this query-factory combo\n+                StoreContext ctx = resolver.getQueryContext().getStoreContext();\n+                String query = currentQuery();\n+                if (ctx.getBroker() != null && query != null) {\n+                    String key = getClass().getName() + \":\" + query;\n+                    BrokerFactory factory = ctx.getBroker().getBrokerFactory();\n+                    Object hasWarned = factory.getUserObject(key);\n+                    if (hasWarned != null)\n+                        break;\n+                    else\n+                        factory.putUserObject(key, Boolean.TRUE);\n+                }\n+                Log log = conf.getLog(OpenJPAConfiguration.LOG_QUERY);\n+                if (log.isWarnEnabled())\n+                    log.warn(_loc.get(\"query-extensions-warning\", clause,\n+                        currentQuery()));\n+                break;\n+            case Compatibility.JPQL_STRICT:\n+                throw new ParseException(_loc.get(\"query-extensions-error\",\n+                    clause, currentQuery()).getMessage());\n+            case Compatibility.JPQL_EXTENDED:\n+                break;\n+            default:\n+                throw new IllegalStateException(\n+                    \"Compatibility.getJPQL() == \"\n+                        + conf.getCompatibilityInstance().getJPQL());\n+        }\n+    }\n+\n+    protected void setImplicitTypes(Value val1, Value val2, Class expected) {\n+        super.setImplicitTypes(val1, val2, expected);\n+\n+        // as well as setting the types for conversions, we also need to\n+        // ensure that any parameters are declared with the correct type,\n+        // since the JPA spec expects that these will be validated\n+        Parameter param = val1 instanceof Parameter ? (Parameter) val1\n+            : val2 instanceof Parameter ? (Parameter) val2 : null;\n+        Path path = val1 instanceof Path ? (Path) val1\n+            : val2 instanceof Path ? (Path) val2 : null;\n+\n+        // we only check for parameter-to-path comparisons\n+        if (param == null || path == null || parameterTypes == null)\n+            return;\n+\n+        FieldMetaData fmd = path.last();\n+        if (fmd == null)\n+            return;\n+\n+        Class type = path.isXPath() ? path.getType() : fmd.getDeclaredType();\n+        if (type == null)\n+            return;\n+\n+        String paramName = param.getParameterName();\n+        if (paramName == null)\n+            return;\n+\n+        // make sure we have already declared the parameter\n+        if (parameterTypes.containsKey(paramName))\n+            parameterTypes.put(paramName, type);\n+    }\n+\n+    private Value getStringValue(JPQLNode node) {\n+        return getTypeValue(node, TYPE_STRING);\n+    }\n+\n+    private Value getNumberValue(JPQLNode node) {\n+        return getTypeValue(node, TYPE_NUMBER);\n+    }\n+\n+    private Value getTypeValue(JPQLNode node, Class implicitType) {\n+        Value val = getValue(node);\n+        setImplicitType(val, implicitType);\n+        return val;\n+    }\n+\n+    private Value getSubquery(JPQLNode node) {\n+        final boolean subclasses = true;\n+        String alias = nextAlias();\n+\n+        // parse the subquery\n+        ParsedJPQL parsed = new ParsedJPQL(node.parser.jpql, node);\n+\n+        ClassMetaData candidate = getCandidateMetaData(node);\n+        Subquery subq = factory.newSubquery(candidate, subclasses, alias);\n+        subq.setMetaData(candidate);\n+\n+        contexts.push(new Context(parsed, subq));\n+\n+        try {\n+            QueryExpressions subexp = getQueryExpressions();\n+            subq.setQueryExpressions(subexp);\n+            return subq;\n+        } finally {\n+            // remove the subquery parse context\n+            contexts.pop();\n+        }\n+    }\n+\n+    /**\n+     * Record the names and order of implicit parameters.\n+     */\n+    private Parameter getParameter(String id, boolean positional) {\n+        if (parameterTypes == null)\n+            parameterTypes = new LinkedMap(6);\n+        if (!parameterTypes.containsKey(id))\n+            parameterTypes.put(id, TYPE_OBJECT);\n+\n+        Class type = Object.class;\n+        ClassMetaData meta = null;\n+        int index;\n+\n+        if (positional) {\n+            try {\n+                // indexes in JPQL are 1-based, as opposed to 0-based in\n+                // the core ExpressionFactory\n+                index = Integer.parseInt(id) - 1;\n+            } catch (NumberFormatException e) {\n+                throw parseException(EX_USER, \"bad-positional-parameter\",\n+                    new Object[]{ id }, e);\n+            }\n+\n+            if (index < 0)\n+                throw parseException(EX_USER, \"bad-positional-parameter\",\n+                    new Object[]{ id }, null);\n+        } else {\n+            // otherwise the index is just the current size of the params\n+            index = parameterTypes.indexOf(id);\n+        }\n+\n+        Parameter param = factory.newParameter(id, type);\n+        param.setMetaData(meta);\n+        param.setIndex(index);\n+\n+        return param;\n+    }\n+\n+    /**\n+     * Checks to see if we should evaluate for a NOT expression.\n+     */\n+    private Expression evalNot(boolean not, Expression exp) {\n+        return not ? factory.not(exp) : exp;\n+    }\n+\n+    /**\n+     * Trim off leading and trailing single-quotes, and then\n+     * replace any internal '' instances with ' (since repeating the\n+     * quote is the JPQL mechanism of escaping a single quote).\n+     */\n+    private String trimQuotes(String str) {\n+        if (str == null || str.length() <= 1)\n+            return str;\n+\n+        if (str.startsWith(\"'\") && str.endsWith(\"'\"))\n+            str = str.substring(1, str.length() - 1);\n+\n+        int index = -1;\n+\n+        while ((index = str.indexOf(\"''\", index + 1)) != -1)\n+            str = str.substring(0, index + 1) + str.substring(index + 2);\n+\n+        return str;\n+    }\n+\n+    /**\n+     * An IntegerLiteral and DecimalLiteral node will\n+     * have a child node of Negative if it is negative:\n+     * if so, this method returns -1, else it returns 1.\n+     */\n+    private short negative(JPQLNode node) {\n+        if (node.children != null && node.children.length == 1\n+            && firstChild(node).id == JJTNEGATIVE)\n+            return -1;\n+        else\n+            return 1;\n+    }\n+\n+    private Value getIdentifier(JPQLNode node) {\n+        final String name = node.text;\n+        final Value val = getVariable(name, false);\n+\n+        ClassMetaData cmd = getMetaDataForAlias(name);\n+\n+        if (cmd != null) {\n+            // handle the case where the class name is the alias\n+            // for the candidate (we don't use variables for this)\n+            Value thiz = factory.getThis();\n+            thiz.setMetaData(cmd);\n+            return thiz;\n+        } else if (val instanceof Path) {\n+            return (Path) val;\n+        } else if (val instanceof Value) {\n+            return (Value) val;\n+        }\n+\n+        throw parseException(EX_USER, \"unknown-identifier\",\n+            new Object[]{ name }, null);\n+    }\n+\n+    private Value getPathOrConstant(JPQLNode node) {\n+        // first check to see if the path is an enum or static field, and\n+        // if so, load it\n+        String className = assemble(node, \".\", 1);\n+        Class c = resolver.classForName(className, null);\n+        if (c != null) {\n+            String fieldName = lastChild(node).text;\n+\n+            try {\n+                Field field = c.getField(fieldName);\n+                Object value = field.get(null);\n+                return factory.newLiteral(value, Literal.TYPE_UNKNOWN);\n+            } catch (NoSuchFieldException nsfe) {\n+                if (node.inEnumPath)\n+                    throw parseException(EX_USER, \"no-field\",\n+                        new Object[]{ c.getName(), fieldName }, nsfe);\n+                else\n+                    return getPath(node, false, true);\n+            } catch (Exception e) {\n+                throw parseException(EX_USER, \"unaccessible-field\",\n+                    new Object[]{ className, fieldName }, e);\n+            }\n+        } else {\n+            return getPath(node, false, true);\n+        }\n+    }\n+\n+    private Path getPath(JPQLNode node) {\n+        return getPath(node, false, true);\n+    }\n+\n+    private Path getPath(JPQLNode node, boolean pcOnly, boolean inner) {\n+        // resolve the first element against the aliases map ...\n+        // i.e., the path \"SELECT x.id FROM SomeClass x where x.id > 10\"\n+        // will need to have \"x\" in the alias map in order to resolve\n+        Path path;\n+\n+        final String name = firstChild(node).text;\n+        final Value val = getVariable(name, false);\n+\n+        // handle the case where the class name is the alias\n+        // for the candidate (we don't use variables for this)\n+        if (name.equalsIgnoreCase(ctx().schemaAlias)) {\n+            if (ctx().subquery != null) {\n+                path = factory.newPath(ctx().subquery);\n+                path.setMetaData(ctx().subquery.getMetaData());\n+            } else {\n+                path = factory.newPath();\n+                path.setMetaData(ctx().meta);\n+            }\n+        } else if (getMetaDataForAlias(name) != null)\n+            path = newPath(null, getMetaDataForAlias(name));\n+        else if (val instanceof Path)\n+            path = (Path) val;\n+        else if (val.getMetaData() != null)\n+            path = newPath(val, val.getMetaData());\n+        else\n+            throw parseException(EX_USER, \"path-invalid\",\n+                new Object[]{ assemble(node), name }, null);\n+\n+        // walk through the children and assemble the path\n+        boolean allowNull = !inner;\n+        for (int i = 1; i < node.children.length; i++) {\n+            if (path.isXPath()) {\n+                for (int j = i; j <node.children.length; j++)\n+                    path = (Path) traverseXPath(path, node.children[j].text);\n+                return path;\n+            }\n+            path = (Path) traversePath(path, node.children[i].text, pcOnly,\n+                allowNull);\n+\n+            // all traversals but the first one will always be inner joins\n+            allowNull = false;\n+        }\n+\n+        return path;\n+    }\n+\n+    protected Class getDeclaredVariableType(String name) {\n+        ClassMetaData cmd = getMetaDataForAlias(name);\n+        if (cmd != null)\n+            return cmd.getDescribedType();\n+\n+        if (name != null && name.equals(ctx().schemaAlias))\n+            return getCandidateType();\n+\n+        // JPQL has no declared variables\n+        return null;\n+    }\n+\n+    /**\n+     * Returns an Expression for the given node by eval'ing it.\n+     */\n+    private Expression getExpression(JPQLNode node) {\n+        Object exp = eval(node);\n+\n+        // check for boolean values used as expressions\n+        if (!(exp instanceof Expression))\n+            return factory.asExpression((Value) exp);\n+        return (Expression) exp;\n+    }\n+\n+    private Value getValue(JPQLNode node) {\n+        return getValue(node, VAR_PATH);\n+    }\n+\n+    private Path newPath(Value val, ClassMetaData meta) {\n+        Path path = val == null ? factory.newPath() : factory.newPath(val);\n+        if (meta != null)\n+            path.setMetaData(meta);\n+        return path;\n+    }\n+\n+    /**\n+     * Returns a Value for the given node by eval'ing it.\n+     */\n+    private Value getValue(JPQLNode node, int handleVar) {\n+        Value val = (Value) eval(node);\n+\n+        // determined how to evaluate a variable\n+        if (!val.isVariable())\n+            return val;\n+        else if (handleVar == VAR_PATH && !(val instanceof Path))\n+            return newPath(val, val.getMetaData());\n+        else if (handleVar == VAR_ERROR)\n+            throw parseException(EX_USER, \"unexpected-var\",\n+                new Object[]{ node.text }, null);\n+        else\n+            return val;\n+    }\n+\n+    ////////////////////////////\n+    // Parse Context Management\n+    ////////////////////////////\n+\n+    private Context ctx() {\n+        return (Context) contexts.peek();\n+    }\n+\n+    private JPQLNode root() {\n+        return ctx().parsed.root;\n+    }\n+\n+    private ClassMetaData getMetaDataForAlias(String alias) {\n+        for (int i = contexts.size() - 1; i >= 0; i--) {\n+            Context context = (Context) contexts.get(i);\n+            if (alias.equalsIgnoreCase(context.schemaAlias))\n+                return context.meta;\n+        }\n+\n+        return null;\n+    }\n+\n+    private class Context {\n+\n+        private final ParsedJPQL parsed;\n+        private ClassMetaData meta;\n+        private String schemaAlias;\n+        private Subquery subquery;\n+\n+        Context(ParsedJPQL parsed, Subquery subquery) {\n+            this.parsed = parsed;\n+            this.subquery = subquery;\n+        }\n+    }\n+\n+    ////////////////////////////\n+    // Node traversal utilities\n+    ////////////////////////////\n+\n+    private JPQLNode onlyChild(JPQLNode node)\n+        throws UserException {\n+        JPQLNode child = firstChild(node);\n+\n+        if (node.children.length > 1)\n+            throw parseException(EX_USER, \"multi-children\",\n+                new Object[]{ node, Arrays.asList(node.children) }, null);\n+\n+        return child;\n+    }\n+\n+    /**\n+     * Returns the left node (the first of the children), and asserts\n+     * that there are exactly two children.\n+     */\n+    private JPQLNode left(JPQLNode node) {\n+        return child(node, 0, 2);\n+    }\n+\n+    /**\n+     * Returns the right node (the second of the children), and asserts\n+     * that there are exactly two children.\n+     */\n+    private JPQLNode right(JPQLNode node) {\n+        return child(node, 1, 2);\n+    }\n+\n+    private JPQLNode child(JPQLNode node, int childNum, int assertCount) {\n+        if (node.children.length != assertCount)\n+            throw parseException(EX_USER, \"wrong-child-count\",\n+                new Object[]{ new Integer(assertCount), node,\n+                    Arrays.asList(node.children) }, null);\n+\n+        return node.children[childNum];\n+    }\n+\n+    private JPQLNode firstChild(JPQLNode node) {\n+        if (node.children == null || node.children.length == 0)\n+            throw parseException(EX_USER, \"no-children\",\n+                new Object[]{ node }, null);\n+        return node.children[0];\n+    }\n+\n+    private static JPQLNode secondChild(JPQLNode node) {\n+        return node.children[1];\n+    }\n+\n+    private static JPQLNode thirdChild(JPQLNode node) {\n+        return node.children[2];\n+    }\n+\n+    private static JPQLNode lastChild(JPQLNode node) {\n+        return lastChild(node, 0);\n+    }\n+\n+    /**\n+     * The Nth from the last child. E.g.,\n+     * lastChild(1) will return the second-to-the-last child.\n+     */\n+    private static JPQLNode lastChild(JPQLNode node, int fromLast) {\n+        return node.children[node.children.length - (1 + fromLast)];\n+    }\n+\n+    /**\n+     * Base node that will be generated by the JPQLExpressionBuilder; base\n+     * class of the {@link SimpleNode} that is used by {@link JPQL}.\n+     *\n+     * @author Marc Prud'hommeaux\n+     * @see Node\n+     * @see SimpleNode\n+     */\n+    protected abstract static class JPQLNode\n+        implements Node, Serializable {\n+\n+        final int id;\n+        final JPQL parser;\n+        JPQLNode parent;\n+        JPQLNode[] children;\n+        String text;\n+        boolean not = false;\n+        boolean inEnumPath = false;\n+\n+        public JPQLNode(JPQL parser, int id) {\n+            this.id = id;\n+            this.parser = parser;\n+            this.inEnumPath = parser.inEnumPath;\n+        }\n+\n+        public void jjtOpen() {\n+        }\n+\n+        public void jjtClose() {\n+        }\n+\n+        JPQLNode[] findChildrenByID(int id) {\n+            Collection<JPQLNode> set = new LinkedHashSet<JPQLNode>();\n+            findChildrenByID(id, set);\n+            return set.toArray(new JPQLNode[set.size()]);\n+        }\n+\n+        private void findChildrenByID(int id, Collection<JPQLNode> set) {\n+            for (int i = 0; children != null && i < children.length; i++) {\n+                if (children[i].id == id)\n+                    set.add(children[i]);\n+\n+                children[i].findChildrenByID(id, set);\n+            }\n+        }\n+\n+        boolean hasChildID(int id) {\n+            return findChildByID(id, false) != null;\n+        }\n+\n+        JPQLNode findChildByID(int id, boolean recurse) {\n+            for (int i = 0; children != null && i < children.length; i++) {\n+                JPQLNode child = children[i];\n+\n+                if (child.id == id)\n+                    return children[i];\n+\n+                if (recurse) {\n+                    JPQLNode found = child.findChildByID(id, recurse);\n+                    if (found != null)\n+                        return found;\n+                }\n+            }\n+\n+            // not found\n+            return null;\n+        }\n+\n+        public void jjtSetParent(Node parent) {\n+            this.parent = (JPQLNode) parent;\n+        }\n+\n+        public Node jjtGetParent() {\n+            return this.parent;\n+        }\n+\n+        public void jjtAddChild(Node n, int i) {\n+            if (children == null) {\n+                children = new JPQLNode[i + 1];\n+            } else if (i >= children.length) {\n+                JPQLNode c[] = new JPQLNode[i + 1];\n+                System.arraycopy(children, 0, c, 0, children.length);\n+                children = c;\n+            }\n+\n+            children[i] = (JPQLNode) n;\n+        }\n+\n+        public Node jjtGetChild(int i) {\n+            return children[i];\n+        }\n+\n+        public int getChildCount() {\n+            return jjtGetNumChildren();\n+        }\n+\n+        public JPQLNode getChild(int index) {\n+            return (JPQLNode) jjtGetChild(index);\n+        }\n+\n+        public Iterator iterator() {\n+            return Arrays.asList(children).iterator();\n+        }\n+\n+        public int jjtGetNumChildren() {\n+            return (children == null) ? 0 : children.length;\n+        }\n+\n+        void setText(String text) {\n+            this.text = text;\n+        }\n+\n+        void setToken(Token t) {\n+            setText(t.image);\n+        }\n+\n+        public String toString() {\n+            return JPQLTreeConstants.jjtNodeName[this.id];\n+        }\n+\n+        public String toString(String prefix) {\n+            return prefix + toString();\n+        }\n+\n+        /**\n+         * Debugging method.\n+         *\n+         * @see #dump(java.io.PrintStream,String)\n+         */\n+        public void dump(String prefix) {\n+            dump(System.out, prefix);\n+        }\n+\n+        public void dump() {\n+            dump(\" \");\n+        }\n+\n+        /**\n+         * Debugging method to output a parse tree.\n+         *\n+         * @param out the stream to which to write the debugging info\n+         * @param prefix the prefix to write out before lines\n+         */\n+        public void dump(PrintStream out, String prefix) {\n+            dump(out, prefix, false);\n+        }\n+\n+        public void dump(PrintStream out, String prefix, boolean text) {\n+            out.println(toString(prefix)\n+                + (text && this.text != null ? \" [\" + this.text + \"]\" : \"\"));\n+            if (children != null) {\n+                for (int i = 0; i < children.length; ++i) {\n+                    JPQLNode n = (JPQLNode) children[i];\n+                    if (n != null) {\n+                        n.dump(out, prefix + \" \", text);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Public for unit testing purposes.\n+     * @nojavadoc\n+     */\n+    public static class ParsedJPQL\n+        implements Serializable {\n+\n+        // This is only ever used during parse; when ParsedJPQL instances\n+        // are serialized, they will have already been parsed.\n+        private final transient JPQLNode root;\n+\n+        private final String query;\n+        \n+        // cache of candidate type data. This is stored here in case this  \n+        // parse tree is reused in a context that does not know what the \n+        // candidate type is already. \n+        private Class _candidateType;\n+\n+        ParsedJPQL(String jpql) {\n+            this(jpql, parse(jpql));\n+        }\n+\n+        ParsedJPQL(String query, JPQLNode root) {\n+            this.root = root;\n+            this.query = query;\n+        }\n+\n+        private static JPQLNode parse(String jpql) {\n+            if (jpql == null)\n+                jpql = \"\";\n+\n+            try {\n+                return (JPQLNode) new JPQL(jpql).parseQuery();\n+            } catch (Error e) {\n+                // special handling for Error subclasses, which the\n+                // parser may sometimes (unfortunately) throw\n+                throw new UserException(_loc.get(\"parse-error\",\n+                    new Object[]{ e.toString(), jpql }));\n+            }\n+        }\n+\n+        void populate(ExpressionStoreQuery query) {\n+            QueryContext ctx = query.getContext();\n+\n+            // if the owning query's context does not have\n+            // any candidate class, then set it here\n+            if (ctx.getCandidateType() == null) {\n+                if (_candidateType == null)\n+                    _candidateType = new JPQLExpressionBuilder\n+                        (null, query, this).getCandidateType();\n+                ctx.setCandidateType(_candidateType, true);\n+            }\n+        }\n+        \n+        /**\n+         * Public for unit testing purposes.\n+         */\n+        public Class getCandidateType() {\n+            return _candidateType;\n+        }\n+\n+        public String toString ()\n+\t\t{\n+\t\t\treturn this.query;\n+\t\t}\n+\t}\n+}\n+"},{"sha":"db08d32a90c7d2b681da603687f7c086882e084e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLParser.java","status":"added","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLParser.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLParser.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.jpql;\n+\n+import org.apache.openjpa.kernel.ExpressionStoreQuery;\n+import org.apache.openjpa.kernel.exps.ExpressionFactory;\n+import org.apache.openjpa.kernel.exps.ExpressionParser;\n+import org.apache.openjpa.kernel.exps.QueryExpressions;\n+import org.apache.openjpa.kernel.exps.Value;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Parser for JPQL queries.\n+ *\n+ * @author Marc Prud'hommeaux\n+ * @nojavadoc\n+ */\n+public class JPQLParser\n+    implements ExpressionParser {\n+\n+    private static final Localizer _loc =\n+        Localizer.forPackage(JPQLParser.class);\n+    public static final String LANG_JPQL = \"javax.persistence.JPQL\";\n+\n+    public Object parse(String ql, ExpressionStoreQuery query) {\n+        if (query.getContext().getParameterDeclaration() != null)\n+            throw new UserException(_loc.get(\"param-decs-invalid\"));\n+\n+        return new JPQLExpressionBuilder.ParsedJPQL(ql);\n+    }\n+\n+    public void populate(Object parsed, ExpressionStoreQuery query) {\n+        if (!(parsed instanceof JPQLExpressionBuilder.ParsedJPQL))\n+            throw new ClassCastException(parsed == null ? null + \"\"\n+                : parsed.getClass().getName());\n+\n+        ((JPQLExpressionBuilder.ParsedJPQL) parsed).populate(query);\n+    }\n+\n+    public QueryExpressions eval(Object parsed, ExpressionStoreQuery query,\n+        ExpressionFactory factory, ClassMetaData candidate) {\n+        try {\n+            return new JPQLExpressionBuilder(factory, query, parsed).\n+                getQueryExpressions();\n+        } catch (OpenJPAException ke) {\n+            throw ke;\n+        } catch (Exception e) {\n+            throw new UserException(_loc.get(\"bad-jpql\", parsed), e);\n+        }\n+    }\n+\n+    public Value[] eval(String[] vals, ExpressionStoreQuery query,\n+        ExpressionFactory factory, ClassMetaData candidate) {\n+        return null;\n+    }\n+\n+    public String getLanguage() {\n+        return JPQLParser.LANG_JPQL;\n+    }\n+}"},{"sha":"0943ab0b1506c4dd71bfbe9d564d195ea923d236","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/ParseException.java","status":"added","additions":173,"deletions":0,"changes":173,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/ParseException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/ParseException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/ParseException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.jpql;\n+\n+import java.util.TreeSet;\n+\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Localizer.Message;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Signifies that a lexical error occurred when parsing the JPQL statement.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+public class ParseException\n+    extends UserException {\n+\n+    private static final Localizer _loc =\n+        Localizer.forPackage(ParseException.class);\n+\n+    /**\n+     * This constructor is used by the method \"generateParseException\"\n+     * in the generated parser. Calling this constructor generates\n+     * a new object of this type with the fields \"currentToken\",\n+     * \"expectedTokenSequences\", and \"tokenImage\" set.\n+     * This constructor calls its super class with the empty string\n+     * to force the \"toString\" method of parent class \"Throwable\" to\n+     * print the error message in the form:\n+     * ParseException: <result of getMessage>\n+     */\n+    public ParseException(Token currentTokenVal,\n+        int[][]expectedTokenSequencesVal, String[]tokenImageVal) {\n+        super(initMessage(currentTokenVal,\n+            expectedTokenSequencesVal, tokenImageVal));\n+    }\n+\n+    /**\n+     * The following constructors are for use by you for whatever\n+     * purpose you can think of. Constructing the exception in this\n+     * manner makes the exception behave in the normal way - i.e., as\n+     * documented in the class \"Throwable\". The fields \"errorToken\",\n+     * \"expectedTokenSequences\", and \"tokenImage\" do not contain\n+     * relevant information. The JavaCC generated code does not use\n+     * these constructors.\n+     */\n+    public ParseException() {\n+        super();\n+    }\n+\n+    /**\n+     * String constructor. Constructing the exception in this\n+     * manner makes the exception behave in the normal way - i.e., as\n+     * documented in the class \"Throwable\". The fields \"errorToken\",\n+     * \"expectedTokenSequences\", and \"tokenImage\" do not contain\n+     * relevant information. The JavaCC generated code does not use\n+     * these constructors.\n+     */\n+    public ParseException(String message) {\n+        super(message);\n+    }\n+\n+    /**\n+     * This method has the standard behavior when this object has been\n+     * created using the standard constructors. Otherwise, it uses\n+     * \"currentToken\" and \"expectedTokenSequences\" to generate a parse\n+     * error message and returns it. If this object has been created\n+     * due to a parse error, and you do not catch it (it gets thrown\n+     * from the parser), then this method is called during the printing\n+     * of the final stack trace, and hence the correct error message\n+     * gets displayed.\n+     */\n+    private static Message initMessage(Token currentToken,\n+        int[][]expectedTokenSequences, String[]tokenImage) {\n+        TreeSet expected = new TreeSet();\n+\n+        int maxSize = 0;\n+\n+        for (int i = 0; i < expectedTokenSequences.length; i++) {\n+            if (maxSize < expectedTokenSequences[i].length)\n+                maxSize = expectedTokenSequences[i].length;\n+\n+            for (int j = 0; j < expectedTokenSequences[i].length; j++)\n+                expected.add(tokenImage[expectedTokenSequences[i][j]]);\n+        }\n+\n+        Token tok = currentToken.next;\n+\n+        String curtok = \"\";\n+        for (int i = 0; i < maxSize; i++) {\n+            if (i != 0)\n+                curtok += \" \";\n+            if (tok.kind == 0) {\n+                curtok += tokenImage[0];\n+                break;\n+            }\n+\n+            curtok += escape(tok.image);\n+            tok = tok.next;\n+        }\n+\n+        return _loc.get(\"bad-parse\", new Object[]{ curtok,\n+            new Integer(currentToken.next.beginColumn), expected });\n+    }\n+\n+    /**\n+     * Used to convert raw characters to their escaped version\n+     * when these raw version cannot be used as part of an ASCII string literal.\n+     */\n+    private static String escape(String str) {\n+        StringBuffer retval = new StringBuffer();\n+        char ch;\n+\n+        for (int i = 0; i < str.length(); i++) {\n+            switch (str.charAt(i)) {\n+                case 0:\n+                    continue;\n+                case '\\b':\n+                    retval.append(\"\\\\b\");\n+                    continue;\n+                case '\\t':\n+                    retval.append(\"\\\\t\");\n+                    continue;\n+                case '\\n':\n+                    retval.append(\"\\\\n\");\n+                    continue;\n+                case '\\f':\n+                    retval.append(\"\\\\f\");\n+                    continue;\n+                case '\\r':\n+                    retval.append(\"\\\\r\");\n+                    continue;\n+                case '\\\"':\n+                    retval.append(\"\\\\\\\"\");\n+                    continue;\n+                case '\\'':\n+                    retval.append(\"\\\\\\'\");\n+                    continue;\n+                case '\\\\':\n+                    retval.append(\"\\\\\\\\\");\n+                    continue;\n+                default:\n+                    if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n+                        String s = \"0000\" + Integer.toString(ch, 16);\n+\n+                        retval.append(\"\\\\u\" + s.substring(s.length() - 4,\n+                            s.length()));\n+                    } else {\n+                        retval.append(ch);\n+                    }\n+                    continue;\n+            }\n+        }\n+        return retval.toString();\n+\t}\n+\n+}"},{"sha":"bc5b83abc22f5be672ea5d63bb9665ceb3588822","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/SimpleNode.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/SimpleNode.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/SimpleNode.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/SimpleNode.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,34 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.jpql;\n+\n+/**\n+ * Base node implementation for all JPQL nodes. Subclasses will be\n+ * generated as part of the JavaCC process.\n+ *\n+ * @author Marc Prud'hommeaux\n+ * @nojavadoc\n+ */\n+public class SimpleNode\n+    extends JPQLExpressionBuilder.JPQLNode {\n+\n+    SimpleNode(JPQL parser, int id) {\n+        super(parser, id);\n+    }\n+}"},{"sha":"e5a88917a1962b3787b958ba1b8d84cb551d8331","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/package.html","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/package.html","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/package.html?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,27 @@\n+<!--\n+ Licensed to the Apache Software Foundation (ASF) under one\n+ or more contributor license agreements.  See the NOTICE file\n+ distributed with this work for additional information\n+ regarding copyright ownership.  The ASF licenses this file\n+ to you under the Apache License, Version 2.0 (the\n+ \"License\"); you may not use this file except in compliance\n+ with the License.  You may obtain a copy of the License at\n+ \n+ http://www.apache.org/licenses/LICENSE-2.0\n+ \n+ Unless required by applicable law or agreed to in writing,\n+ software distributed under the License is distributed on an\n+ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ KIND, either express or implied.  See the License for the\n+ specific language governing permissions and limitations\n+ under the License.   \n+-->\n+<html>\n+<body>\n+<p><strong>JPA Query Language Support</strong></p>\n+\n+<p>\n+    Allow any spec or store to use JPQL.\n+</p>\n+</body>\n+</html>"},{"sha":"e1f68db46c4bc642c365d0dc3eeafa9289a74b7a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/package.html","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/package.html","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/package.html?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,28 @@\n+<!--\n+ Licensed to the Apache Software Foundation (ASF) under one\n+ or more contributor license agreements.  See the NOTICE file\n+ distributed with this work for additional information\n+ regarding copyright ownership.  The ASF licenses this file\n+ to you under the Apache License, Version 2.0 (the\n+ \"License\"); you may not use this file except in compliance\n+ with the License.  You may obtain a copy of the License at\n+ \n+ http://www.apache.org/licenses/LICENSE-2.0\n+ \n+ Unless required by applicable law or agreed to in writing,\n+ software distributed under the License is distributed on an\n+ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ KIND, either express or implied.  See the License for the\n+ specific language governing permissions and limitations\n+ under the License.   \n+-->\n+<html>\n+<body>\n+<p><strong>OpenJPA Runtime Kernel</strong></p>\n+\n+<p>\n+    This package provides a common OpenJPA runtime environment that can be\n+    adapted for use with various data store mechanisms.\n+</p>\n+</body>\n+</html>"},{"sha":"c770456acc9a6f349e0dd73e9fc6834ea845fef6","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java","status":"added","additions":878,"deletions":0,"changes":878,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractCFMetaDataFactory.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,878 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipInputStream;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.lib.meta.ClassArgParser;\n+import org.apache.openjpa.lib.meta.ClasspathMetaDataIterator;\n+import org.apache.openjpa.lib.meta.FileMetaDataIterator;\n+import org.apache.openjpa.lib.meta.MetaDataFilter;\n+import org.apache.openjpa.lib.meta.MetaDataIterator;\n+import org.apache.openjpa.lib.meta.MetaDataParser;\n+import org.apache.openjpa.lib.meta.MetaDataSerializer;\n+import org.apache.openjpa.lib.meta.ResourceMetaDataIterator;\n+import org.apache.openjpa.lib.meta.URLMetaDataIterator;\n+import org.apache.openjpa.lib.meta.ZipFileMetaDataIterator;\n+import org.apache.openjpa.lib.meta.ZipStreamMetaDataIterator;\n+import org.apache.openjpa.lib.util.Files;\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.GeneralException;\n+import org.apache.openjpa.util.UserException;\n+import serp.util.Strings;\n+\n+/**\n+ * Base class for factory implementations built around XML metadata files\n+ * in the common fomat.\n+ *\n+ * @author Abe White\n+ * @since 0.4.0\n+ */\n+public abstract class AbstractCFMetaDataFactory\n+    extends AbstractMetaDataFactory {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (AbstractMetaDataFactory.class);\n+\n+    protected Collection files = null;\n+    protected Collection urls = null;\n+    protected Collection rsrcs = null;\n+    protected Collection cpath = null;\n+\n+    private Set _typeNames = null;\n+\n+    /**\n+     * Set of {@link File}s of metadata files or directories supplied by user.\n+     */\n+    public void setFiles(Collection files) {\n+        this.files = files;\n+    }\n+\n+    /**\n+     * Set of semicolon-separated {@link File}s of metadata files or\n+     * directories supplied by user via auto-configuration.\n+     */\n+    public void setFiles(String files) {\n+        if (StringUtils.isEmpty(files))\n+            this.files = null;\n+        else {\n+            String[] strs = Strings.split(files, \";\", 0);\n+            this.files = new HashSet((int) (strs.length * 1.33 + 1));\n+\n+            File file;\n+            for (int i = 0; i < strs.length; i++) {\n+                file = new File(strs[i]);\n+                if (((Boolean) AccessController.doPrivileged(\n+                    J2DoPrivHelper.existsAction(file))).booleanValue())\n+                    this.files.add(file);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set of {@link URL}s of metadata files or jars supplied by user.\n+     */\n+    public void setURLs(Collection urls) {\n+        this.urls = urls;\n+    }\n+\n+    /**\n+     * Set of semicolon-separated {@link URL}s of metadata files or jars\n+     * supplied by user via auto-configuration.\n+     */\n+    public void setURLs(String urls) {\n+        if (StringUtils.isEmpty(urls))\n+            this.urls = null;\n+        else {\n+            String[] strs = Strings.split(urls, \";\", 0);\n+            this.urls = new HashSet((int) (strs.length * 1.33 + 1));\n+            try {\n+                for (int i = 0; i < strs.length; i++)\n+                    this.urls.add(new URL(strs[i]));\n+            } catch (MalformedURLException mue) {\n+                throw new UserException(mue);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set of resource paths of metadata files or jars supplied by user.\n+     */\n+    public void setResources(Collection rsrcs) {\n+        this.rsrcs = rsrcs;\n+    }\n+\n+    /**\n+     * Set of semicolon-separated resource paths of metadata files or jars\n+     * supplied by user via auto-configuration.\n+     */\n+    public void setResources(String rsrcs) {\n+        // keep list mutable so subclasses can add implicit locations\n+        this.rsrcs = (StringUtils.isEmpty(rsrcs)) ? null\n+            : new ArrayList(Arrays.asList(Strings.split(rsrcs, \";\", 0)));\n+    }\n+\n+    /**\n+     * Set of classpath directories or jars to scan for metadata supplied\n+     * by user.\n+     */\n+    public void setClasspathScan(Collection cpath) {\n+        this.cpath = cpath;\n+    }\n+\n+    /**\n+     * Set of classpath directories or jars to scan for metadata supplied\n+     * by user via auto-configuration.\n+     */\n+    public void setClasspathScan(String cpath) {\n+        // keep list mutable so subclasses can add implicit locations\n+        this.cpath = (StringUtils.isEmpty(cpath)) ? null\n+            : new ArrayList(Arrays.asList(Strings.split(cpath, \";\", 0)));\n+    }\n+\n+    public boolean store(ClassMetaData[] metas, QueryMetaData[] queries,\n+        SequenceMetaData[] seqs, int mode, Map output) {\n+        if (mode == MODE_NONE)\n+            return true;\n+        if (isMappingOnlyFactory() && (mode & MODE_MAPPING) == 0)\n+            return true;\n+\n+        if (!strict && (mode & MODE_META) != 0)\n+            mode |= MODE_MAPPING;\n+        Class cls = (metas.length == 0) ? null : metas[0].getDescribedType();\n+        ClassLoader loader = repos.getConfiguration().\n+            getClassResolverInstance().getClassLoader(cls, null);\n+        Map clsNames = new HashMap((int) (metas.length * 1.33 + 1));\n+        for (int i = 0; i < metas.length; i++)\n+            clsNames.put(metas[i].getDescribedType().getName(), metas[i]);\n+\n+        // assign default files if in metadata mode (in other modes we assume\n+        // the files would have to be read already to create the metadatas)\n+        Set metaFiles = null;\n+        Set queryFiles = null;\n+        if (isMappingOnlyFactory() || (mode & MODE_META) != 0)\n+            metaFiles = assignDefaultMetaDataFiles(metas, queries, seqs, mode,\n+                clsNames);\n+        if (!isMappingOnlyFactory() && (mode & MODE_QUERY) != 0)\n+            queryFiles = assignDefaultQueryFiles(queries, clsNames);\n+\n+        // parse all files to be sure we don't delete existing metadata when\n+        // writing out new metadata, then serialize\n+        Serializer ser;\n+        Parser parser;\n+        if (mode != MODE_QUERY) {\n+            int sermode = (isMappingOnlyFactory()) ? mode : mode | MODE_META;\n+            if ((mode & MODE_ANN_MAPPING) != 0)\n+                ser = newAnnotationSerializer();\n+            else\n+                ser = newSerializer();\n+            ser.setMode(sermode);\n+            if (metaFiles != null) {\n+                parser = newParser(false);\n+                parser.setMode(sermode);\n+                parser.setClassLoader(loader);\n+                parse(parser, metaFiles);\n+\n+                MetaDataRepository pr = parser.getRepository();\n+                pr.setSourceMode(mode);\n+                if (isMappingOnlyFactory())\n+                    pr.setResolve(MODE_NONE);\n+                else\n+                    pr.setResolve(MODE_MAPPING, false);\n+                ser.addAll(pr);\n+            }\n+\n+            for (int i = 0; i < metas.length; i++)\n+                ser.addMetaData(metas[i]);\n+            if ((mode & MODE_MAPPING) != 0)\n+                for (int i = 0; i < seqs.length; i++)\n+                    ser.addSequenceMetaData(seqs[i]);\n+            for (int i = 0; i < queries.length; i++)\n+                if (queries[i].getSourceMode() != MODE_QUERY\n+                    && (queries[i].getSourceMode() & mode) != 0)\n+                    ser.addQueryMetaData(queries[i]);\n+\n+            int flags = ser.PRETTY;\n+            if ((store & STORE_VERBOSE) != 0)\n+                flags |= ser.VERBOSE;\n+            serialize(ser, output, flags);\n+        }\n+\n+        // do we have any queries stored in query files?\n+        if (!isMappingOnlyFactory()) {\n+            boolean qFiles = queryFiles != null;\n+            for (int i = 0; !qFiles && i < queries.length; i++)\n+                qFiles = queries[i].getSourceMode() == MODE_QUERY;\n+            if (qFiles) {\n+                if ((mode & MODE_ANN_MAPPING) != 0)\n+                    ser = newAnnotationSerializer();\n+                else\n+                    ser = newSerializer();\n+                ser.setMode(MODE_QUERY);\n+                if (queryFiles != null) {\n+                    parser = newParser(false);\n+                    parser.setMode(MODE_QUERY);\n+                    parser.setClassLoader(loader);\n+                    parse(parser, queryFiles);\n+                    ser.addAll(parser.getRepository());\n+                }\n+                for (int i = 0; i < queries.length; i++)\n+                    if (queries[i].getSourceMode() == MODE_QUERY)\n+                        ser.addQueryMetaData(queries[i]);\n+                serialize(ser, output, ser.PRETTY);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public boolean drop(Class[] cls, int mode, ClassLoader envLoader) {\n+        if (mode == MODE_NONE)\n+            return true;\n+        if (isMappingOnlyFactory() && (mode & MODE_MAPPING) == 0)\n+            return true;\n+\n+        Parser parser = newParser(false);\n+        MetaDataRepository pr = parser.getRepository();\n+        pr.setSourceMode(MODE_MAPPING, false);\n+        pr.setResolve(MODE_MAPPING, false);\n+\n+        // parse metadata for all these classes\n+        if ((mode & (MODE_META | MODE_MAPPING)) != 0) {\n+            parser.setMode((isMappingOnlyFactory()) ? mode\n+                : MODE_META | MODE_MAPPING | MODE_QUERY);\n+            parse(parser, cls);\n+        }\n+        if (!isMappingOnlyFactory() && (mode & MODE_QUERY) != 0) {\n+            parser.setMode(MODE_QUERY);\n+            parse(parser, cls);\n+        }\n+\n+        // remove metadatas from repository or clear their mappings\n+        Set files = new HashSet();\n+        Set clsNames = null;\n+        if ((mode & (MODE_META | MODE_MAPPING)) != 0) {\n+            clsNames = new HashSet((int) (cls.length * 1.33 + 1));\n+            ClassMetaData meta;\n+            for (int i = 0; i < cls.length; i++) {\n+                if (cls[i] == null)\n+                    clsNames.add(null);\n+                else\n+                    clsNames.add(cls[i].getName());\n+                meta = pr.getMetaData(cls[i], envLoader, false);\n+                if (meta != null) {\n+                    if (getSourceFile(meta) != null)\n+                        files.add(getSourceFile(meta));\n+                    if ((mode & MODE_META) != 0)\n+                        pr.removeMetaData(meta);\n+                    else if (!isMappingOnlyFactory())\n+                        clearMapping(meta);\n+                }\n+            }\n+        }\n+\n+        // remove query mode metadatas so we can store them separately\n+        QueryMetaData[] queries = pr.getQueryMetaDatas();\n+        List qqs = (!isMappingOnlyFactory() && (mode & MODE_QUERY) == 0)\n+            ? null : new ArrayList();\n+        boolean rem;\n+        Class def;\n+        for (int i = 0; i < queries.length; i++) {\n+            if (!isMappingOnlyFactory() && queries[i].getSourceFile() != null)\n+                files.add(queries[i].getSourceFile());\n+            def = queries[i].getDefiningType();\n+            rem = (queries[i].getSourceMode() & mode) != 0\n+                && clsNames.contains((def == null) ? null : def.getName());\n+            if (rem || (!isMappingOnlyFactory()\n+                && queries[i].getSourceMode() == MODE_QUERY))\n+                pr.removeQueryMetaData(queries[i]);\n+            if (qqs != null && queries[i].getSourceMode() == MODE_QUERY && !rem)\n+                qqs.add(queries[i]);\n+        }\n+\n+        // write new metadata without removed instances\n+        backupAndDelete(files);\n+        Serializer ser;\n+        if ((mode & (MODE_META | MODE_MAPPING)) != 0) {\n+            ser = newSerializer();\n+            ser.setMode((isMappingOnlyFactory()) ? mode : mode | MODE_META);\n+            ser.addAll(pr);\n+            // remove from serializer rather than from repository above so that\n+            // calling code can take advantage of metadata still in repos\n+            if (isMappingOnlyFactory())\n+                for (int i = 0; i < cls.length; i++)\n+                    ser.removeMetaData(pr.getMetaData(cls[i], envLoader,\n+                        false));\n+            serialize(ser, null, ser.PRETTY);\n+        }\n+        if (qqs != null && !qqs.isEmpty()) {\n+            ser = newSerializer();\n+            ser.setMode(MODE_QUERY);\n+            for (int i = 0; i < qqs.size(); i++)\n+                ser.addQueryMetaData((QueryMetaData) qqs.get(i));\n+            serialize(ser, null, ser.PRETTY);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Assign default source files to the given metadatas.\n+     *\n+     * @param clsNames map of class names to metadatas\n+     * @return set of existing files used by these metadatas, or\n+     * null if no existing files\n+     */\n+    private Set assignDefaultMetaDataFiles(ClassMetaData[] metas,\n+        QueryMetaData[] queries, SequenceMetaData[] seqs, int mode,\n+        Map clsNames) {\n+        Set files = null;\n+        for (int i = 0; i < metas.length; i++) {\n+            if (getSourceFile(metas[i]) == null)\n+                setSourceFile(metas[i], defaultSourceFile(metas[i]));\n+            if (((Boolean) AccessController.doPrivileged(J2DoPrivHelper\n+                .existsAction(getSourceFile(metas[i])))).booleanValue()) {\n+                if (files == null)\n+                    files = new HashSet();\n+                files.add(getSourceFile(metas[i]));\n+            }\n+        }\n+        for (int i = 0; i < queries.length; i++) {\n+            if (queries[i].getSourceMode() == MODE_QUERY\n+                || (mode & queries[i].getSourceMode()) == 0)\n+                continue;\n+            if (queries[i].getSourceFile() == null)\n+                queries[i].setSource(defaultSourceFile(queries[i],\n+                    clsNames), queries[i].getSourceScope(),\n+                    queries[i].getSourceType());\n+            if (((Boolean) AccessController.doPrivileged(\n+                J2DoPrivHelper.existsAction(queries[i].getSourceFile())))\n+                .booleanValue()) {\n+                if (files == null)\n+                    files = new HashSet();\n+                files.add(queries[i].getSourceFile());\n+            }\n+        }\n+        if ((mode & MODE_MAPPING) != 0) {\n+            for (int i = 0; i < seqs.length; i++) {\n+                if (getSourceFile(seqs[i]) == null)\n+                    setSourceFile(seqs[i], defaultSourceFile(seqs[i],\n+                        clsNames));\n+                if (((Boolean) AccessController.doPrivileged(\n+                    J2DoPrivHelper.existsAction(getSourceFile(seqs[i]))))\n+                    .booleanValue()) {\n+                    if (files == null)\n+                        files = new HashSet();\n+                    files.add(getSourceFile(seqs[i]));\n+                }\n+            }\n+        }\n+        return files;\n+    }\n+\n+    /**\n+     * Assign default source files to the given queries.\n+     *\n+     * @param clsNames map of class names to metadatas\n+     * @return set of existing files used by these metadatas, or\n+     * null if no existing files\n+     */\n+    private Set assignDefaultQueryFiles(QueryMetaData[] queries,\n+        Map clsNames) {\n+        Set files = null;\n+        for (int i = 0; i < queries.length; i++) {\n+            if (queries[i].getSourceMode() != MODE_QUERY)\n+                continue;\n+            if (queries[i].getSourceFile() == null)\n+                queries[i].setSource(defaultSourceFile(queries[i], clsNames),\n+                    queries[i].getSourceScope(), queries[i].getSourceType());\n+            if (((Boolean) AccessController.doPrivileged(\n+                J2DoPrivHelper.existsAction(queries[i].getSourceFile())))\n+                .booleanValue()) {\n+                if (files == null)\n+                    files = new HashSet();\n+                files.add(queries[i].getSourceFile());\n+            }\n+        }\n+        return files;\n+    }\n+\n+    /**\n+     * Return true if this factory deals only with mapping data, and relies\n+     * on a separate factory for metadata.\n+     */\n+    protected boolean isMappingOnlyFactory() {\n+        return false;\n+    }\n+\n+    /**\n+     * Parse all given files.\n+     */\n+    protected void parse(MetaDataParser parser, Collection files) {\n+        try {\n+            for (Iterator itr = files.iterator(); itr.hasNext();)\n+                parser.parse((File) itr.next());\n+        } catch (IOException ioe) {\n+            throw new GeneralException(ioe);\n+        }\n+    }\n+\n+    /**\n+     * Parse all given classses.\n+     */\n+    protected void parse(MetaDataParser parser, Class[] cls) {\n+        try {\n+            for (int i = 0; i < cls.length; i++)\n+                parser.parse(cls[i], isParseTopDown());\n+        } catch (IOException ioe) {\n+            throw new GeneralException(ioe);\n+        }\n+    }\n+\n+    /**\n+     * Whether to parse classes top down. Defaults to false.\n+     */\n+    protected boolean isParseTopDown() {\n+        return false;\n+    }\n+\n+    /**\n+     * Tell the given serialier to write its metadatas.\n+     */\n+    protected void serialize(MetaDataSerializer ser, Map output, int flags) {\n+        try {\n+            if (output == null)\n+                ser.serialize(flags);\n+            else\n+                ser.serialize(output, flags);\n+        } catch (IOException ioe) {\n+            throw new GeneralException(ioe);\n+        }\n+    }\n+\n+    /**\n+     * Backup and delete the source files for the given metadatas.\n+     */\n+    protected void backupAndDelete(Collection files) {\n+        File file;\n+        for (Iterator itr = files.iterator(); itr.hasNext();) {\n+            file = (File) itr.next();\n+            if (Files.backup(file, false) != null)\n+                AccessController\n+                    .doPrivileged(J2DoPrivHelper.deleteAction(file));\n+        }\n+    }\n+\n+    /**\n+     * Clear mapping information from the given metadata.\n+     */\n+    protected void clearMapping(ClassMetaData meta) {\n+        meta.setSourceMode(MODE_MAPPING, false);\n+    }\n+\n+    /**\n+     * Return the current source file of the given metadata.\n+     */\n+    protected File getSourceFile(ClassMetaData meta) {\n+        return meta.getSourceFile();\n+    }\n+\n+    /**\n+     * Set the current source file of the given metadata.\n+     */\n+    protected void setSourceFile(ClassMetaData meta, File sourceFile) {\n+        meta.setSource(sourceFile, meta.getSourceType());\n+    }\n+\n+    /**\n+     * Return the current source file of the given metadata.\n+     */\n+    protected File getSourceFile(SequenceMetaData meta) {\n+        return meta.getSourceFile();\n+    }\n+\n+    /**\n+     * Set the current source file of the given metadata.\n+     */\n+    protected void setSourceFile(SequenceMetaData meta, File sourceFile) {\n+        meta.setSource(sourceFile, meta.getSourceScope(),\n+            meta.getSourceType());\n+    }\n+\n+    /**\n+     * Return the default file for the given metadata.\n+     */\n+    protected abstract File defaultSourceFile(ClassMetaData meta);\n+\n+    /**\n+     * Return a default file for the given query.\n+     */\n+    protected abstract File defaultSourceFile(QueryMetaData query,\n+        Map clsNames);\n+\n+    /**\n+     * Return a default file for the given sequence.\n+     */\n+    protected abstract File defaultSourceFile(SequenceMetaData seq,\n+        Map clsNames);\n+\n+    /**\n+     * Create a new metadata parser.\n+     *\n+     * @param loading if true, this will be the cached parser used for\n+     * loading metadata\n+     */\n+    protected abstract Parser newParser(boolean loading);\n+\n+    /**\n+     * Create a new metadata serializer.\n+     */\n+    protected abstract Serializer newSerializer();\n+\n+    /**\n+     * Create a new annotation metadata serializer.\n+     */\n+    protected abstract Serializer newAnnotationSerializer();\n+\n+    /**\n+     * Return the metadata that defines the given query, if any.\n+     *\n+     * @param clsNames map of class names to metadatas\n+     */\n+    protected ClassMetaData getDefiningMetaData(QueryMetaData query,\n+        Map clsNames) {\n+        Class def = query.getDefiningType();\n+        if (def != null)\n+            return (ClassMetaData) clsNames.get(def.getName());\n+\n+        Map.Entry entry;\n+        String pkg;\n+        for (Iterator itr = clsNames.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            pkg = Strings.getPackageName((String) entry.getKey());\n+            if (pkg.length() == 0)\n+                return (ClassMetaData) entry.getValue();\n+        }\n+        return null;\n+    }\n+\n+    public Set getPersistentTypeNames(boolean devpath, ClassLoader envLoader) {\n+        // some configured locations might be implicit in spec, so return\n+        // null if we don't find any classes, rather than if we don't have\n+        // any locations\n+        if (_typeNames != null)\n+            return (_typeNames.isEmpty()) ? null : _typeNames;\n+\n+        try {\n+            ClassLoader loader = repos.getConfiguration().\n+                getClassResolverInstance().getClassLoader(getClass(),\n+                envLoader);\n+            long start = System.currentTimeMillis();\n+\n+            Set names = parsePersistentTypeNames(loader);\n+            if (names.isEmpty() && devpath)\n+                scan(new ClasspathMetaDataIterator(null, newMetaDataFilter()),\n+                    newClassArgParser(), names, false, null);\n+            else // we don't cache a full dev cp scan\n+                _typeNames = names;\n+\n+            if (log.isTraceEnabled())\n+                log.trace(_loc.get(\"found-pcs\", String.valueOf(names.size()),\n+                    String.valueOf(System.currentTimeMillis() - start)));\n+            return (names.isEmpty()) ? null : names;\n+        } catch (IOException ioe) {\n+            throw new GeneralException(ioe);\n+        }\n+    }\n+\n+    /**\n+     * Parse persistent type names.\n+     */\n+    private Set parsePersistentTypeNames(ClassLoader loader)\n+        throws IOException {\n+        ClassArgParser cparser = newClassArgParser();\n+        String[] clss;\n+        Set names = new HashSet();\n+        if (files != null) {\n+            File file;\n+            for (Iterator itr = files.iterator(); itr.hasNext();) {\n+                file = (File) itr.next();\n+                if (((Boolean) AccessController.doPrivileged(J2DoPrivHelper\n+                    .isDirectoryAction(file))).booleanValue()) {\n+                    if (log.isTraceEnabled())\n+                        log.trace(_loc.get(\"scanning-directory\", file));\n+                    scan(new FileMetaDataIterator(file, newMetaDataFilter()),\n+                        cparser, names, true, file);\n+                } else if (file.getName().endsWith(\".jar\")) {\n+                    if (log.isTraceEnabled())\n+                        log.trace(_loc.get(\"scanning-jar\", file));\n+                    try {\n+                        ZipFile zFile = (ZipFile) AccessController\n+                            .doPrivileged(J2DoPrivHelper\n+                                .newZipFileAction(file));\n+                        scan(new ZipFileMetaDataIterator(zFile,\n+                            newMetaDataFilter()), cparser, names, true, file);\n+                    } catch (PrivilegedActionException pae) {\n+                        throw (IOException) pae.getException();\n+                    }\n+                } else {\n+                    if (log.isTraceEnabled())\n+                        log.trace(_loc.get(\"scanning-file\", file));\n+                    clss = cparser.parseTypeNames(new FileMetaDataIterator\n+                        (file));\n+                    if (log.isTraceEnabled())\n+                        log.trace(_loc.get(\"scan-found-names\", clss, file));\n+                    names.addAll(Arrays.asList(clss));\n+                    File f = (File) AccessController\n+                        .doPrivileged(J2DoPrivHelper\n+                            .getAbsoluteFileAction(file));\n+                    try {\n+                        mapPersistentTypeNames(AccessController\n+                            .doPrivileged(J2DoPrivHelper.toURLAction(f)), clss);\n+                    } catch (PrivilegedActionException pae) {\n+                        throw (FileNotFoundException) pae.getException();\n+                    }\n+                }\n+            }\n+        }\n+        URL url;\n+        if (urls != null) {\n+            for (Iterator itr = urls.iterator(); itr.hasNext();) {\n+                url = (URL) itr.next();\n+                if (\"file\".equals(url.getProtocol())) {\n+                    File file = (File) AccessController\n+                        .doPrivileged(J2DoPrivHelper\n+                            .getAbsoluteFileAction(new File(url.getFile()))); \n+                    if (files != null && files.contains(file)) {\n+                        continue;\n+                    } else if (((Boolean) AccessController\n+                        .doPrivileged(J2DoPrivHelper.isDirectoryAction(file)))\n+                        .booleanValue()) {\n+                        if (log.isTraceEnabled())\n+                            log.trace(_loc.get(\"scanning-directory\", file));\n+                        scan(\n+                            new FileMetaDataIterator(file, newMetaDataFilter()),\n+                            cparser, names, true, file);\n+                        continue;\n+                    }\n+                }\n+                if (\"jar\".equals(url.getProtocol())\n+                    && url.getPath().endsWith(\"!/\")) {\n+                    if (log.isTraceEnabled())\n+                        log.trace(_loc.get(\"scanning-jar-url\", url));\n+                    scan(new ZipFileMetaDataIterator(url,\n+                        newMetaDataFilter()), cparser, names, true, url);\n+                } else if (url.getPath().endsWith(\".jar\")) {\n+                    if (log.isTraceEnabled())\n+                        log.trace(_loc.get(\"scanning-jar-at-url\", url));\n+                    try {\n+                        InputStream is = (InputStream)\n+                            AccessController.doPrivileged(\n+                                J2DoPrivHelper.openStreamAction(url));\n+                        scan(new ZipStreamMetaDataIterator(\n+                            new ZipInputStream(is),\n+                            newMetaDataFilter()), cparser, names, true, url);\n+                    } catch (PrivilegedActionException pae) {\n+                        throw (IOException) pae.getException();\n+                    }\n+                } else {\n+                    if (log.isTraceEnabled())\n+                        log.trace(_loc.get(\"scanning-url\", url));\n+                    clss = cparser.parseTypeNames(new URLMetaDataIterator(url));\n+                    if (log.isTraceEnabled())\n+                        log.trace(_loc.get(\"scan-found-names\", clss, url));\n+                    names.addAll(Arrays.asList(clss));\n+                    mapPersistentTypeNames(url, clss);\n+                }\n+            }\n+        }\n+        if (rsrcs != null) {\n+            String rsrc;\n+            MetaDataIterator mitr;\n+            for (Iterator itr = rsrcs.iterator(); itr.hasNext();) {\n+                rsrc = (String) itr.next();\n+                if (rsrc.endsWith(\".jar\")) {\n+                    url = (URL) AccessController.doPrivileged(\n+                        J2DoPrivHelper.getResourceAction(loader, rsrc)); \n+                    if (url != null) {\n+                        if (log.isTraceEnabled())\n+                            log.trace(_loc.get(\"scanning-jar-stream-url\", url));\n+                        try {\n+                            InputStream is = (InputStream)\n+                                AccessController.doPrivileged(\n+                                    J2DoPrivHelper.openStreamAction(url));\n+                            scan(new ZipStreamMetaDataIterator\n+                                (new ZipInputStream(is),\n+                                newMetaDataFilter()), cparser, names, true,\n+                                url);\n+                        } catch (PrivilegedActionException pae) {\n+                            throw (IOException) pae.getException();\n+                        }\n+                    }\n+                } else {\n+                    if (log.isTraceEnabled())\n+                        log.trace(_loc.get(\"scanning-resource\", rsrc));\n+                    mitr = new ResourceMetaDataIterator(rsrc, loader);\n+                    while (mitr.hasNext()) {\n+                        url = (URL) mitr.next();\n+                        clss = cparser.parseTypeNames(new URLMetaDataIterator\n+                            (url));\n+                        if (log.isTraceEnabled())\n+                            log.trace(_loc.get(\"scan-found-names\", clss, rsrc));\n+                        names.addAll(Arrays.asList(clss));\n+                        mapPersistentTypeNames(url, clss);\n+                    }\n+                    mitr.close();\n+                }\n+            }\n+        }\n+        if (cpath != null) {\n+            String[] dirs = (String[]) cpath.toArray(new String[cpath.size()]);\n+            scan(new ClasspathMetaDataIterator(dirs, newMetaDataFilter()),\n+                cparser, names, true, dirs);\n+        }\n+        if (types != null)\n+            names.addAll(types);\n+\n+        if (log.isTraceEnabled())\n+            log.trace(_loc.get(\"parse-found-names\", names));\n+        \n+        return names;\n+    }\n+\n+    /**\n+     * Scan for persistent type names using the given metadata iterator.\n+     */\n+    private void scan(MetaDataIterator mitr, ClassArgParser cparser, Set names,\n+        boolean mapNames, Object debugContext)\n+        throws IOException {\n+        Map map;\n+        try {\n+            map = cparser.mapTypeNames(mitr);\n+        } finally {\n+            mitr.close();\n+        }\n+\n+        Map.Entry entry;\n+        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            if (mapNames)\n+                mapPersistentTypeNames(entry.getKey(), (String[])\n+                    entry.getValue());\n+            List newNames = Arrays.asList((String[]) entry.getValue());\n+            if (log.isTraceEnabled())\n+                log.trace(_loc.get(\"scan-found-names\", newNames, debugContext));\n+            names.addAll(newNames);\n+        }\n+    }\n+\n+    /**\n+     * Implement this method to map metadata resources to the persistent\n+     * types contained within them. The method will be called when\n+     * {@link #getPersistentTypeNames} is invoked.\n+     */\n+    protected void mapPersistentTypeNames(Object rsrc, String[] names) {\n+    }\n+\n+    /**\n+     * Return a metadata filter that identifies metadata resources when\n+     * performing jar and classpath scans.\n+     */\n+    protected abstract MetaDataFilter newMetaDataFilter();\n+\n+    public void clear() {\n+        super.clear();\n+        _typeNames = null;\n+    }\n+\n+    /**\n+     * Internal parser interface.\n+     */\n+    public static interface Parser\n+        extends MetaDataParser {\n+\n+        /**\n+         * Returns the repository for this parser. If none has been set,\n+         * creates a new repository and sets it.\n+         */\n+        public MetaDataRepository getRepository();\n+\n+        /**\n+         * The parse mode according to the expected document type.\n+         */\n+        public void setMode(int mode);\n+    }\n+\n+    /**\n+     * Internal serializer interface.\n+     */\n+    public static interface Serializer\n+        extends MetaDataSerializer {\n+\n+        /**\n+         * The serialization mode according to the expected document type. The\n+         * mode constants act as bit flags, and therefore can be combined.\n+         */\n+        public void setMode(int mode);\n+\n+        /**\n+         * Add a class meta data to the set to be serialized.\n+         */\n+        public void addMetaData(ClassMetaData meta);\n+\n+        /**\n+         * Remove a class meta data from the set to be serialized.\n+         */\n+        public boolean removeMetaData(ClassMetaData meta);\n+\n+        /**\n+         * Add a sequence meta data to the set to be serialized.\n+         */\n+        public void addSequenceMetaData(SequenceMetaData meta);\n+\n+        /**\n+         * Add a query meta data to the set to be serialized.\n+         */\n+        public void addQueryMetaData(QueryMetaData meta);\n+\n+        /**\n+         * Add all components in the given repository to the set to be\n+         * serialized.\n+         */\n+        public void addAll (MetaDataRepository repos);\n+    }\n+}"},{"sha":"669af3cf0d78317aebd482cd5a4ed0f89bf013b2","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","status":"added","additions":391,"deletions":0,"changes":391,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,391 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.util.List;\n+\n+import org.apache.openjpa.enhance.PCRegistry;\n+import org.apache.openjpa.enhance.Reflection;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Abstract metadata defaults.\n+ *\n+ * @author Abe White\n+ */\n+public abstract class AbstractMetaDataDefaults\n+    implements MetaDataDefaults {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (AbstractMetaDataDefaults.class);\n+\n+    private int _access = ClassMetaData.ACCESS_FIELD;\n+    private int _identity = ClassMetaData.ID_UNKNOWN;\n+    private boolean _ignore = true;\n+    private boolean _interface = true;\n+    private boolean _pcRegistry = true;\n+    private int _callback = CALLBACK_RETHROW;\n+    private boolean _unwrapped = false;\n+\n+    /**\n+     * Whether to attempt to use the information from registered classes\n+     * to populate metadata defaults. Defaults to true.\n+     */\n+    public boolean getUsePCRegistry() {\n+        return _pcRegistry;\n+    }\n+\n+    /**\n+     * Whether to attempt to use the information from registered classes\n+     * to populate metadata defaults. Defaults to true.\n+     */\n+    public void setUsePCRegistry(boolean pcRegistry) {\n+        _pcRegistry = pcRegistry;\n+    }\n+\n+    /**\n+     * The default access type for base classes with ACCESS_UNKNOWN.\n+     * ACCESS_FIELD by default.\n+     */\n+    public int getDefaultAccessType() {\n+        return _access;\n+    }\n+\n+    /**\n+     * The default access type for base classes with ACCESS_UNKNOWN.\n+     * ACCESS_FIELD by default.\n+     */\n+    public void setDefaultAccessType(int access) {\n+        _access = access;\n+    }\n+\n+    /**\n+     * The default identity type for unmapped classes without primary \n+     * key fields. ID_UNKNOWN by default.\n+     */\n+    public int getDefaultIdentityType() {\n+        return _identity;\n+    }\n+\n+    /**\n+     * The default identity type for unmapped classes without primary \n+     * key fields. ID_UNKNOWN by default.\n+     */\n+    public void setDefaultIdentityType(int identity) {\n+        _identity = identity;\n+    }\n+\n+    public int getCallbackMode() {\n+        return _callback;\n+    }\n+\n+    public void setCallbackMode(int mode) {\n+        _callback = mode;\n+    }\n+\n+    public void setCallbackMode(int mode, boolean on) {\n+        if (on)\n+            _callback |= mode;\n+        else\n+            _callback &= ~mode;\n+    }\n+\n+    public boolean getCallbacksBeforeListeners(int type) {\n+        return false;\n+    }\n+\n+    public boolean isDeclaredInterfacePersistent() {\n+        return _interface;\n+    }\n+\n+    public void setDeclaredInterfacePersistent(boolean pers) {\n+        _interface = pers;\n+    }\n+\n+    public boolean isDataStoreObjectIdFieldUnwrapped() {\n+        return _unwrapped;\n+    }\n+\n+    public void setDataStoreObjectIdFieldUnwrapped(boolean unwrapped) {\n+        _unwrapped = unwrapped;\n+    }\n+\n+    public boolean getIgnoreNonPersistent() {\n+        return _ignore;\n+    }\n+\n+    public void setIgnoreNonPersistent(boolean ignore) {\n+        _ignore = ignore;\n+    }\n+\n+    public void populate(ClassMetaData meta, int access) {\n+        if (meta.getDescribedType() == Object.class)\n+            return;\n+\n+        if (access == ClassMetaData.ACCESS_UNKNOWN) {\n+            // we do not allow using both field and method access at\n+            // the same time\n+            access = getAccessType(meta);\n+            if ((access & ClassMetaData.ACCESS_FIELD) != 0\n+                && (access & ClassMetaData.ACCESS_PROPERTY) != 0) {\n+                List fields = getFieldAccessNames(meta);\n+                List props = getPropertyAccessNames(meta);\n+                if (fields != null || props != null)\n+                    throw new UserException(_loc.get(\n+                        \"access-field-and-prop-hints\",\n+                        meta.getDescribedType().getName(), fields, props));\n+                else\n+                    throw new UserException(_loc.get(\"access-field-and-prop\",\n+                        meta.getDescribedType().getName()));\n+            }\n+        }\n+        meta.setAccessType(access);\n+\n+        Log log = meta.getRepository().getLog();\n+        if (log.isTraceEnabled())\n+            log.trace(_loc.get(\"gen-meta\", meta));\n+        if (!_pcRegistry || !populateFromPCRegistry(meta)) {\n+            if (log.isTraceEnabled())\n+                log.trace(_loc.get(\"meta-reflect\"));\n+            populateFromReflection(meta);\n+        }\n+    }\n+\n+    /**\n+     * Populate initial field data. Does nothing by default.\n+     */\n+    protected void populate(FieldMetaData fmd) {\n+    }\n+\n+    /**\n+     * Populate the given metadata using the {@link PCRegistry}.\n+     */\n+    private boolean populateFromPCRegistry(ClassMetaData meta) {\n+        Class cls = meta.getDescribedType();\n+        if (!PCRegistry.isRegistered(cls))\n+            return false;\n+        try {\n+            String[] fieldNames = PCRegistry.getFieldNames(cls);\n+            Class[] fieldTypes = PCRegistry.getFieldTypes(cls);\n+            Member member;\n+            FieldMetaData fmd;\n+            for (int i = 0; i < fieldNames.length; i ++) {\n+                if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD)\n+                    member = (Field) AccessController.doPrivileged(\n+                        J2DoPrivHelper.getDeclaredFieldAction(\n+                            cls,fieldNames[i])); \n+                else\n+                    member = Reflection.findGetter(meta.getDescribedType(),\n+                        fieldNames[i], true);\n+                fmd = meta.addDeclaredField(fieldNames[i], fieldTypes[i]);\n+                fmd.backingMember(member);\n+                populate(fmd);\n+            }\n+            return true;\n+        } catch (OpenJPAException ke) {\n+            throw ke;\n+        } catch (Exception e) {\n+            if (e instanceof PrivilegedActionException)\n+                e = ((PrivilegedActionException) e).getException();\n+            throw new UserException(e);\n+        }\n+    }\n+\n+    /**\n+     * Generate the given metadata using reflection.\n+     */\n+    private void populateFromReflection(ClassMetaData meta) {\n+        Member[] members;\n+        boolean iface = meta.getDescribedType().isInterface();\n+        if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD && !iface)\n+            members = (Field[]) AccessController.doPrivileged(\n+                J2DoPrivHelper.getDeclaredFieldsAction(\n+                    meta.getDescribedType())); \n+        else\n+            members = (Method[]) AccessController.doPrivileged(\n+                J2DoPrivHelper.getDeclaredMethodsAction(\n+                    meta.getDescribedType())); \n+\n+        int mods;\n+        String name;\n+        boolean def;\n+        FieldMetaData fmd;\n+        for (int i = 0; i < members.length; i++) {\n+            mods = members[i].getModifiers();\n+            if (Modifier.isStatic(mods) || Modifier.isFinal(mods))\n+                continue;\n+\n+            name = getFieldName(members[i]);\n+            if (name == null || isReservedFieldName(name))\n+                continue;\n+\n+            def = isDefaultPersistent(meta, members[i], name);\n+            if (!def && _ignore)\n+                continue;\n+\n+            // passed the tests; persistent type -- we construct with\n+            // Object.class because setting backing member will set proper\n+            // type anyway\n+            fmd = meta.addDeclaredField(name, Object.class);\n+            fmd.backingMember(members[i]);\n+            if (!def) {\n+                fmd.setExplicit(true);\n+                fmd.setManagement(FieldMetaData.MANAGE_NONE);\n+            }\n+            populate(fmd);\n+        }\n+    }\n+\n+    /**\n+     * Return the access type of the given metadata. May be a bitwise\n+     * combination of field and property access constants, or ACCESS_UNKNOWN.\n+     * Returns ACCESS_FIELD by default.\n+     */\n+    protected int getAccessType(ClassMetaData meta) {\n+        if (meta.getDescribedType().isInterface())\n+            return ClassMetaData.ACCESS_PROPERTY;\n+        else\n+            return ClassMetaData.ACCESS_FIELD;\n+    }\n+\n+    /**\n+     * Return the list of fields in <code>meta</code> that use field access,\n+     * or <code>null</code> if a list of fields is unobtainable. An empty list\n+     * should be returned if the list of fields is obtainable, but there\n+     * happens to be no field access in <code>meta</code>.\n+     *\n+     * This is used for error reporting purposes only, so need not be efficient.\n+     *\n+     * This implementation returns <code>null</code>.\n+     */\n+    protected List getFieldAccessNames(ClassMetaData meta) {\n+        return null;\n+    }\n+\n+    /**\n+     * Return the list of methods in <code>meta</code> that use property access,\n+     * or <code>null</code> if a list of methods is unobtainable. An empty list\n+     * should be returned if the list of methods is obtainable, but there\n+     * happens to be no property access in <code>meta</code>.\n+     *\n+     * This is used for error reporting purposes only, so need not be efficient.\n+     *\n+     * This implementation returns <code>null</code>.\n+     */\n+    protected List getPropertyAccessNames(ClassMetaData meta) {\n+        return null;\n+    }\n+\n+    /**\n+     * Return the field name for the given member. This will only be invoked\n+     * on members of the right type (field vs. method). Return null if the\n+     * member cannot be managed. Default behavior: For fields, returns the\n+     * field name. For getter methods, returns the minus \"get\" or \"is\" with\n+     * the next letter lower-cased. For other methods, returns null.\n+     */\n+    protected String getFieldName(Member member) {\n+        if (member instanceof Field)\n+            return member.getName();\n+\n+        Method meth = (Method) member;\n+        if (meth.getReturnType() == void.class\n+            || meth.getParameterTypes().length != 0)\n+            return null;\n+\n+        String name = meth.getName();\n+        if (name.startsWith(\"get\") && name.length() > 3)\n+            name = name.substring(3);\n+        else if ((meth.getReturnType() == boolean.class\n+            || meth.getReturnType() == Boolean.class)\n+            && name.startsWith(\"is\") && name.length() > 2)\n+            name = name.substring(2);\n+        else\n+            return null;\n+\n+        if (name.length() == 1)\n+            return name.toLowerCase();\n+        return Character.toLowerCase(name.charAt(0)) + name.substring(1);\n+    }\n+\n+    /**\n+     * Returns true if the given field name is reserved for unmanaged fields.\n+     */\n+    protected boolean isReservedFieldName(String name) {\n+        // names used by enhancers\n+        return name.startsWith(\"openjpa\") || name.startsWith(\"jdo\");\n+    }\n+\n+    /**\n+     * Return true if the given member is persistent by default. This will\n+     * only be invoked on members of the right type (field vs. method).\n+     * Returns false if member is static or final by default.\n+     *\n+     * @param name the field name from {@link #getFieldName}\n+     */\n+    protected abstract boolean isDefaultPersistent(ClassMetaData meta,\n+        Member member, String name);\n+\n+    public Member getBackingMember(FieldMetaData fmd) {\n+        if (fmd == null)\n+            return null;\n+        try {\n+            //### note that we might not have access to declaring metadata yet\n+            //### (this could be used during parse), so we have to settle for\n+            //### defining.  could cause problems if maps a superclass field\n+            //### where the superclass uses a different access type\n+            if (fmd.getDefiningMetaData().getAccessType() ==\n+                ClassMetaData.ACCESS_FIELD)\n+                return (Field) AccessController.doPrivileged(\n+                    J2DoPrivHelper.getDeclaredFieldAction(\n+                        fmd.getDeclaringType(), fmd.getName())); \n+            return Reflection.findGetter(fmd.getDeclaringType(), fmd.getName(),\n+                true);\n+        } catch (OpenJPAException ke) {\n+            throw ke;\n+        } catch (Exception e) {\n+            if (e instanceof PrivilegedActionException)\n+                e = ((PrivilegedActionException) e).getException();\n+            throw new InternalException(e);\n+        }\n+    }\n+\n+    public Class getUnimplementedExceptionType() {\n+        return UnsupportedOperationException.class;\n+    }\n+\n+    /**\n+     * Helper method; returns true if the given class appears to be\n+     * user-defined.\n+     */\n+    protected static boolean isUserDefined(Class cls) {\n+        return cls != null && !cls.getName().startsWith(\"java.\")\n+            && !cls.getName().startsWith (\"javax.\");\n+\t}\n+}"},{"sha":"d47e8b6d2f8b869c20fd39a990b152df6a488375","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataFactory.java","status":"added","additions":120,"deletions":0,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataFactory.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.meta.ClassArgParser;\n+import serp.util.Strings;\n+\n+/**\n+ * Abstract {@link MetaDataFactory} that provides default implementations\n+ * of many methods.\n+ *\n+ * @author Abe White\n+ */\n+public abstract class AbstractMetaDataFactory\n+    implements MetaDataFactory {\n+\n+    protected MetaDataRepository repos = null;\n+    protected transient Log log = null;\n+    protected File dir = null;\n+    protected int store = STORE_DEFAULT;\n+    protected boolean strict = false;\n+    protected Set types = null;\n+\n+\n+    /**\n+     * Set of persistent type names supplied by user.\n+     */\n+    public void setTypes(Set types) {\n+        this.types = types;\n+    }\n+\n+    /**\n+     * Set of semicolon-separated persistent type names supplied by user via\n+     * auto-configuration.\n+     */\n+    public void setTypes(String types) {\n+        this.types = (StringUtils.isEmpty(types)) ? null\n+            : new HashSet(Arrays.asList(Strings.split(types, \";\", 0)));\n+    }\n+\n+    public void setRepository(MetaDataRepository repos) {\n+        this.repos = repos;\n+        if (repos != null)\n+            log = repos.getConfiguration().getLog\n+                (OpenJPAConfiguration.LOG_METADATA);\n+    }\n+\n+    public void setStoreDirectory(File dir) {\n+        this.dir = dir;\n+    }\n+\n+    public void setStoreMode(int store) {\n+        this.store = store;\n+    }\n+\n+    public void setStrict(boolean strict) {\n+        this.strict = strict;\n+    }\n+\n+    public boolean store(ClassMetaData[] metas, QueryMetaData[] queries,\n+        SequenceMetaData[] seqs, int mode, Map output) {\n+        return false;\n+    }\n+\n+    public boolean drop(Class[] cls, int mode, ClassLoader envLoader) {\n+        return false;\n+    }\n+\n+    public Set getPersistentTypeNames(boolean devpath, ClassLoader envLoader) {\n+        return types;\n+    }\n+\n+    public Class getQueryScope(String queryName, ClassLoader loader) {\n+        return null;\n+    }\n+\n+    public Class getResultSetMappingScope(String resultSetMappingName,\n+        ClassLoader loader) {\n+        return null;\n+    }\n+\n+    public ClassArgParser newClassArgParser() {\n+        return new ClassArgParser();\n+    }\n+\n+    public void clear() {\n+    }\n+\n+    public void addClassExtensionKeys(Collection exts) {\n+    }\n+\n+    public void addFieldExtensionKeys(Collection exts) {\n+    }\n+}"},{"sha":"f3a415093b90dc38f3cd2bc67d550b34115f3d03","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","status":"added","additions":2396,"deletions":0,"changes":2396,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,2396 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.File;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.security.AccessController;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.datacache.DataCache;\n+import org.apache.openjpa.enhance.PCRegistry;\n+import org.apache.openjpa.enhance.Reflection;\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.lib.conf.Value;\n+import org.apache.openjpa.lib.conf.ValueListener;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.meta.SourceTracker;\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.xml.Commentable;\n+import org.apache.openjpa.util.BigDecimalId;\n+import org.apache.openjpa.util.BigIntegerId;\n+import org.apache.openjpa.util.ByteId;\n+import org.apache.openjpa.util.CharId;\n+import org.apache.openjpa.util.DateId;\n+import org.apache.openjpa.util.DoubleId;\n+import org.apache.openjpa.util.FloatId;\n+import org.apache.openjpa.util.GeneralException;\n+import org.apache.openjpa.util.IntId;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.LongId;\n+import org.apache.openjpa.util.MetaDataException;\n+import org.apache.openjpa.util.ObjectId;\n+import org.apache.openjpa.util.OpenJPAId;\n+import org.apache.openjpa.util.ShortId;\n+import org.apache.openjpa.util.StringId;\n+import org.apache.openjpa.util.UnsupportedException;\n+import org.apache.openjpa.util.ImplHelper;\n+import serp.util.Strings;\n+\n+/**\n+ * Contains metadata about a persistent type.\n+ * This metadata is available both at enhancement time and runtime.\n+ *  Note that this class employs aggressive caching, and therefore it is\n+ * important to finalize the configuration of field metadatas before invoking\n+ * methods that depend on that configuration, such as\n+ * {@link #getPrimaryKeyFields}.\n+ *\n+ * @author Abe White\n+ */\n+public class ClassMetaData\n+    extends Extensions\n+    implements Comparable, SourceTracker, MetaDataContext, MetaDataModes,\n+    Commentable, ValueListener {\n+\n+    /**\n+     * Unkonwn identity type.\n+     */\n+    public static final int ID_UNKNOWN = 0;\n+\n+    /**\n+     * Datastore identity type.\n+     */\n+    public static final int ID_DATASTORE = 1;\n+\n+    /**\n+     * Application identity type.\n+     */\n+    public static final int ID_APPLICATION = 2;\n+\n+    /**\n+     * Unknown access type.\n+     */\n+    public static final int ACCESS_UNKNOWN = 0;\n+\n+    /**\n+     * Persistent attributes are accessed via direct field access. Bit flag.\n+     */\n+    public static final int ACCESS_FIELD = 2 << 0;\n+\n+    /**\n+     * Persistent attributes are accessed via setters and getters. Bit flag.\n+     */\n+    public static final int ACCESS_PROPERTY = 2 << 1;\n+\n+    /**\n+     * Value for using a synthetic detached state field, which is the default.\n+     */\n+    public static final String SYNTHETIC = \"`syn\";\n+\n+    protected static final String DEFAULT_STRING = \"`\";\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (ClassMetaData.class);\n+\n+    private static final FetchGroup[] EMPTY_FETCH_GROUP_ARRAY\n+        = new FetchGroup[0];\n+    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n+\n+    private MetaDataRepository _repos;\n+    private transient ClassLoader _loader = null;\n+\n+    private final ValueMetaData _owner;\n+    private final LifecycleMetaData _lifeMeta = new LifecycleMetaData(this);\n+    private File _srcFile = null;\n+    private int _srcType = SRC_OTHER;\n+    private int _lineNum = 0;  \n+    private int _colNum = 0;  \n+    private String[] _comments = null;\n+    private int _listIndex = -1;\n+    private int _srcMode = MODE_META | MODE_MAPPING;\n+    private int _resMode = MODE_NONE;\n+\n+    private Class _type = Object.class;\n+    private final Map _fieldMap = new TreeMap();\n+    private Map _supFieldMap = null;\n+    private boolean _defSupFields = false;\n+    private Collection _staticFields = null;\n+    private int[] _fieldDataTable = null;\n+    private Map _fgMap = null;\n+\n+    ////////////////////////////////////////////////////////////////////\n+    // Note: if you add additional state, make sure to add it to copy()\n+    ////////////////////////////////////////////////////////////////////\n+\n+    private Class _objectId = null;\n+    private Boolean _objectIdShared = null;\n+    private Boolean _openjpaId = null;\n+    private Boolean _extent = null;\n+    private Boolean _embedded = null;\n+    private Boolean _interface = null;\n+    private Class _impl = null;\n+    private List _interfaces = null;\n+    private final Map _ifaceMap = new HashMap();\n+    private int _identity = ID_UNKNOWN;\n+    private int _idStrategy = ValueStrategies.NONE;\n+    private int _accessType = ACCESS_UNKNOWN;\n+\n+    private String _seqName = DEFAULT_STRING;\n+    private SequenceMetaData _seqMeta = null;\n+    private String _cacheName = DEFAULT_STRING;\n+    private int _cacheTimeout = Integer.MIN_VALUE;\n+    private Boolean _detachable = null;\n+    private String _detachState = DEFAULT_STRING;\n+    private String _alias = null;\n+    private int _versionIdx = Integer.MIN_VALUE;\n+\n+    private Class _super = null;\n+    private ClassMetaData _superMeta = null;\n+    private Class[] _subs = null;\n+    private ClassMetaData[] _subMetas = null;\n+    private ClassMetaData[] _mapSubMetas = null;\n+\n+    private FieldMetaData[] _fields = null;\n+    private FieldMetaData[] _unmgdFields = null;\n+    private FieldMetaData[] _allFields = null;\n+    private FieldMetaData[] _allPKFields = null;\n+    private FieldMetaData[] _allDFGFields = null;\n+    private FieldMetaData[] _definedFields = null;\n+    private FieldMetaData[] _listingFields = null;\n+    private FieldMetaData[] _allListingFields = null;\n+    private FetchGroup[] _fgs = null;\n+    private FetchGroup[] _customFGs = null;\n+    private boolean _intercepting = false;\n+\n+    /**\n+     * Constructor. Supply described type and repository.\n+     */\n+    protected ClassMetaData(Class type, MetaDataRepository repos) {\n+        _repos = repos;\n+        _owner = null;\n+        setDescribedType(type);\n+        registerForValueUpdate(\"DataCacheTimeout\");\n+    }\n+\n+    /**\n+     * Embedded constructor. Supply embedding value.\n+     */\n+    protected ClassMetaData(ValueMetaData owner) {\n+        _owner = owner;\n+        _repos = owner.getRepository();\n+        setEnvClassLoader(owner.getFieldMetaData().getDefiningMetaData().\n+            getEnvClassLoader());\n+        registerForValueUpdate(\"DataCacheTimeout\");\n+    }\n+\n+    /**\n+     * Return the owning repository.\n+     */\n+    public MetaDataRepository getRepository() {\n+        return _repos;\n+    }\n+\n+    /**\n+     * If this metadata is for an embedded object, returning the owning value.\n+     */\n+    public ValueMetaData getEmbeddingMetaData() {\n+        return _owner;\n+    }\n+\n+    /**\n+     * The persistence capable class described by this metadata.\n+     */\n+    public Class getDescribedType() {\n+        return _type;\n+    }\n+\n+    /**\n+     * Set the class descibed by this metadata. The type may be reset when\n+     * an embedded value changes its declared type.\n+     */\n+    protected void setDescribedType(Class type) {\n+        if (type.getSuperclass() != null && \"java.lang.Enum\".equals\n+            (type.getSuperclass().getName()))\n+            throw new MetaDataException(_loc.get(\"enum\", type));\n+        _type = type;\n+        if (PersistenceCapable.class.isAssignableFrom(type))\n+            setIntercepting(true);\n+    }\n+\n+    /**\n+     * The environmental loader used when loading this metadata.\n+     * The class metadata should use this loader when loading metadata for\n+     * its superclass and field types.\n+     */\n+    public ClassLoader getEnvClassLoader() {\n+        return _loader;\n+    }\n+\n+    /**\n+     * The class environmental loader used when loading this metadata.\n+     * The class metadata should use this loader when loading metadata for\n+     * its superclass and field types.\n+     */\n+    public void setEnvClassLoader(ClassLoader loader) {\n+        _loader = loader;\n+    }\n+\n+    /**\n+     * The persistence capable superclass of the described type.\n+     */\n+    public Class getPCSuperclass() {\n+        return _super;\n+    }\n+\n+    /**\n+     * The persistence capable superclass of the described type.\n+     */\n+    public void setPCSuperclass(Class pc) {\n+        clearAllFieldCache();\n+        _super = pc;\n+    }\n+\n+    /**\n+     * The metadata for this class' superclass.\n+     */\n+    public ClassMetaData getPCSuperclassMetaData() {\n+        if (_superMeta == null && _super != null) {\n+            if (_owner != null) {\n+                _superMeta = _repos.newEmbeddedClassMetaData(_owner);\n+                _superMeta.setDescribedType(_super);\n+            } else\n+                _superMeta = _repos.getMetaData(_super, _loader, true);\n+        }\n+        return _superMeta;\n+    }\n+\n+    /**\n+     * The metadata for this class' superclass.\n+     */\n+    public void setPCSuperclassMetaData(ClassMetaData meta) {\n+        clearAllFieldCache();\n+        _superMeta = meta;\n+        if (meta != null)\n+            setPCSuperclass(meta.getDescribedType());\n+    }\n+\n+    /**\n+     * Whether this class is mapped to the datastore. By default, only\n+     * returns false if class is embedded-only, but subclasses might override\n+     * to allow unmapped other types.\n+     */\n+    public boolean isMapped() {\n+        return _embedded != Boolean.TRUE;\n+    }\n+\n+    /**\n+     * Return the closest mapped superclass.\n+     */\n+    public ClassMetaData getMappedPCSuperclassMetaData() {\n+        ClassMetaData sup = getPCSuperclassMetaData();\n+        if (sup == null || sup.isMapped())\n+            return sup;\n+        return sup.getMappedPCSuperclassMetaData();\n+    }\n+\n+    /**\n+     * Return the known persistence capable subclasses of the described type,\n+     * or empty array if none or if this is embedded metadata.\n+     */\n+    public Class[] getPCSubclasses() {\n+        if (_owner != null)\n+            return _repos.EMPTY_CLASSES;\n+\n+        _repos.processRegisteredClasses(_loader);\n+        if (_subs == null) {\n+            Collection subs = _repos.getPCSubclasses(_type);\n+            _subs = (Class[]) subs.toArray(new Class[subs.size()]);\n+        }\n+        return _subs;\n+    }\n+\n+    /**\n+     * Return the metadata for the known persistence capable subclasses of\n+     * the described type, or empty array if none or if this is embedded\n+     * metadata.\n+     */\n+    public ClassMetaData[] getPCSubclassMetaDatas() {\n+        if (_owner != null)\n+            return _repos.EMPTY_METAS;\n+\n+        Class[] subs = getPCSubclasses(); // checks for new\n+        if (_subMetas == null) {\n+            if (subs.length == 0)\n+                _subMetas = _repos.EMPTY_METAS;\n+            else {\n+                ClassMetaData[] metas = _repos.newClassMetaDataArray\n+                    (subs.length);\n+                for (int i = 0; i < subs.length; i++)\n+                    metas[i] = _repos.getMetaData(subs[i], _loader, true);\n+                _subMetas = metas;\n+            }\n+        }\n+        return _subMetas;\n+    }\n+\n+    /**\n+     * Return all mapped subclasses.\n+     */\n+    public ClassMetaData[] getMappedPCSubclassMetaDatas() {\n+        if (_owner != null)\n+            return _repos.EMPTY_METAS;\n+\n+        ClassMetaData[] subs = getPCSubclassMetaDatas(); // checks for new\n+        if (_mapSubMetas == null) {\n+            if (subs.length == 0)\n+                _mapSubMetas = subs;\n+            else {\n+                List mapped = new ArrayList(subs.length);\n+                for (int i = 0; i < subs.length; i++)\n+                    if (subs[i].isMapped())\n+                        mapped.add(subs[i]);\n+                _mapSubMetas = (ClassMetaData[]) mapped.toArray\n+                    (_repos.newClassMetaDataArray(mapped.size()));\n+            }\n+        }\n+        return _mapSubMetas;\n+    }\n+\n+    /**\n+     * The type of identity being used. This will be one of:\n+     * <ul>\n+     * <li>{@link #ID_UNKNOWN}: unknown identity type</li>\n+     * <li>{@link #ID_DATASTORE}: identity managed by the data store and\n+     * independent\tof the fields of the instance</li>\n+     * <li>{@link #ID_APPLICATION}: identity managed by the application and\n+     * defined by one or more fields of the instance</li>\n+     * </ul> If unspecified, defaults to {@link #ID_DATASTORE} if there are no\n+     * primary key fields, and {@link #ID_APPLICATION} otherwise.\n+     */\n+    public int getIdentityType() {\n+        if (_identity == ID_UNKNOWN) {\n+            ClassMetaData sup = getPCSuperclassMetaData();\n+            if (sup != null && sup.getIdentityType() != ID_UNKNOWN)\n+                _identity = sup.getIdentityType();\n+            else if (getPrimaryKeyFields().length > 0)\n+                _identity = ID_APPLICATION;\n+            else if (isMapped())\n+                _identity = ID_DATASTORE;\n+            else\n+                _identity = _repos.getMetaDataFactory().getDefaults().\n+                    getDefaultIdentityType();\n+        }\n+        return _identity;\n+    }\n+\n+    /**\n+     * The type of identity being used. This will be one of:\n+     * <ul>\n+     * <li>{@link #ID_UNKNOWN}: unknown identity type</li>\n+     * <li>{@link #ID_DATASTORE}: identity managed by the data store and\n+     * independent\tof the fields of the instance</li>\n+     * <li>{@link #ID_APPLICATION}: identity managed by the application and\n+     * defined by one or more fields of the instance</li>\n+     * </ul> If unspecified, defaults to {@link #ID_DATASTORE} if there are no\n+     * primary key fields, and {@link #ID_APPLICATION} otherwise.\n+     */\n+    public void setIdentityType(int type) {\n+        _identity = type;\n+        if (type != ID_APPLICATION) {\n+            _objectId = null;\n+            _openjpaId = null;\n+        }\n+    }\n+\n+    /**\n+     * The metadata-specified class to use for the object ID.\n+     */\n+    public Class getObjectIdType() {\n+        if (_objectId != null)\n+            return _objectId;\n+        if (getIdentityType() != ID_APPLICATION)\n+            return null;\n+        ClassMetaData sup = getPCSuperclassMetaData();\n+        if (sup != null && sup.getIdentityType() != ID_UNKNOWN) {\n+            _objectId = sup.getObjectIdType();\n+            return _objectId;\n+        }\n+\n+        // figure out openjpa identity type based on primary key field\n+        FieldMetaData[] pks = getPrimaryKeyFields();\n+        if (pks.length != 1)\n+            return null;\n+        switch (pks[0].getObjectIdFieldTypeCode()) {\n+            case JavaTypes.BYTE:\n+            case JavaTypes.BYTE_OBJ:\n+                _objectId = ByteId.class;\n+                break;\n+            case JavaTypes.CHAR:\n+            case JavaTypes.CHAR_OBJ:\n+                _objectId = CharId.class;\n+                break;\n+            case JavaTypes.DOUBLE:\n+            case JavaTypes.DOUBLE_OBJ:\n+                _objectId = DoubleId.class;\n+                break;\n+            case JavaTypes.FLOAT:\n+            case JavaTypes.FLOAT_OBJ:\n+                _objectId = FloatId.class;\n+                break;\n+            case JavaTypes.INT:\n+            case JavaTypes.INT_OBJ:\n+                _objectId = IntId.class;\n+                break;\n+            case JavaTypes.LONG:\n+            case JavaTypes.LONG_OBJ:\n+                _objectId = LongId.class;\n+                break;\n+            case JavaTypes.SHORT:\n+            case JavaTypes.SHORT_OBJ:\n+                _objectId = ShortId.class;\n+                break;\n+            case JavaTypes.STRING:\n+                _objectId = StringId.class;\n+                break;\n+            case JavaTypes.DATE:\n+                _objectId = DateId.class;\n+                break;\n+            case JavaTypes.OID:\n+            case JavaTypes.OBJECT:\n+                _objectId = ObjectId.class;\n+                break;\n+            case JavaTypes.BIGDECIMAL:\n+                _objectId = BigDecimalId.class;\n+                break;\n+            case JavaTypes.BIGINTEGER:\n+                _objectId = BigIntegerId.class;\n+                break;\n+        }\n+        return _objectId;\n+    }\n+\n+    /**\n+     * The metadata-specified class to use for the object ID.\n+     */\n+    public void setObjectIdType(Class cls, boolean shared) {\n+        _objectId = null;\n+        _openjpaId = null;\n+        _objectIdShared = null;\n+        if (cls != null) {\n+            // don't let people assign OpenJPAId types; safer to calculate it\n+            // ourselves\n+            setIdentityType(ID_APPLICATION);\n+            if (!OpenJPAId.class.isAssignableFrom(cls)) {\n+                _objectId = cls;\n+                _objectIdShared = (shared) ? Boolean.TRUE : Boolean.FALSE;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Whether this type uses an application identity class that is shared\n+     * with other classes, and is therefore wrapped in an {@link ObjectId}.\n+     */\n+    public boolean isObjectIdTypeShared() {\n+        if (_objectIdShared != null)\n+            return _objectIdShared.booleanValue();\n+        if (_super != null)\n+            return getPCSuperclassMetaData().isObjectIdTypeShared();\n+        return isOpenJPAIdentity();\n+    }\n+\n+    /**\n+     * Whether this type uses OpenJPA identity.\n+     */\n+    public boolean isOpenJPAIdentity() {\n+        if (_openjpaId == null) {\n+            Class cls = getObjectIdType();\n+            if (cls == null)\n+                return false;\n+            _openjpaId = (OpenJPAId.class.isAssignableFrom(cls)) ? Boolean.TRUE\n+                : Boolean.FALSE;\n+        }\n+        return _openjpaId.booleanValue();\n+    }\n+\n+    /**\n+     * The strategy to use for datastore identity generation.\n+     * One of the constants from {@link ValueStrategies}.\n+     */\n+    public int getIdentityStrategy() {\n+        if (getIdentityType() == ID_DATASTORE\n+            && _idStrategy == ValueStrategies.NONE) {\n+            ClassMetaData sup = getPCSuperclassMetaData();\n+            if (sup != null && sup.getIdentityType() != ID_UNKNOWN)\n+                _idStrategy = sup.getIdentityStrategy();\n+            else\n+                _idStrategy = ValueStrategies.NATIVE;\n+        }\n+        return _idStrategy;\n+    }\n+\n+    /**\n+     * The strategy to use for datastore identity generation.\n+     * One of the constants from {@link ValueStrategies}.\n+     */\n+    public void setIdentityStrategy(int strategy) {\n+        _idStrategy = strategy;\n+        if (strategy != ValueStrategies.SEQUENCE)\n+            setIdentitySequenceName(null);\n+    }\n+\n+    /**\n+     * The datastore identity sequence name, or null for none.\n+     */\n+    public String getIdentitySequenceName() {\n+        if (DEFAULT_STRING.equals(_seqName)) {\n+            if (_super != null)\n+                _seqName = getPCSuperclassMetaData().getIdentitySequenceName();\n+            else\n+                _seqName = null;\n+        }\n+        return _seqName;\n+    }\n+\n+    /**\n+     * The datastore identity sequence name, or null for none.\n+     */\n+    public void setIdentitySequenceName(String seqName) {\n+        _seqName = seqName;\n+        _seqMeta = null;\n+        if (seqName != null)\n+            setIdentityStrategy(ValueStrategies.SEQUENCE);\n+    }\n+\n+    /**\n+     * Metadata for the datastore identity sequence.\n+     */\n+    public SequenceMetaData getIdentitySequenceMetaData() {\n+        if (_seqMeta == null && getIdentitySequenceName() != null)\n+            _seqMeta = _repos.getSequenceMetaData(this,\n+                getIdentitySequenceName(), true);\n+        return _seqMeta;\n+    }\n+\n+    /**\n+     * Information about lifecycle callbacks for this class.\n+     */\n+    public LifecycleMetaData getLifecycleMetaData() {\n+        return _lifeMeta;\n+    }\n+\n+    /**\n+     * Returns the alias for the described type, or <code>null</code> if none\n+     * has been set.\n+     * \n+     * @see #setTypeAlias\n+     */\n+    public String getTypeAlias() {\n+        if (_alias == null)\n+            _alias = Strings.getClassName(_type);\n+        return _alias;\n+    }\n+\n+    /**\n+     * Sets the alias for the described type. The alias can be\n+     * any arbitrary string that the implementation can later use to\n+     * refer to the class. Note that at runtime, only the alias\n+     * computed when the persistent type was enhanced is used.\n+     *\n+     * @param alias the alias name to apply to the described type\n+     */\n+    public void setTypeAlias(String alias) {\n+        _alias = alias;\n+    }\n+\n+    /**\n+     * The access type used by this class. Either {@link #ACCESS_FIELD}\n+     * or {@link #ACCESS_PROPERTY}.\n+     */\n+    public int getAccessType() {\n+        if (_accessType == ACCESS_UNKNOWN) {\n+            ClassMetaData sup = getPCSuperclassMetaData();\n+            if (sup != null)\n+                return sup.getAccessType();\n+            else {\n+                return getRepository().getMetaDataFactory().\n+                    getDefaults().getDefaultAccessType();\n+            }\n+        }\n+        return _accessType;\n+    }\n+\n+    /**\n+     * The access type used by this class. Must be either\n+     * {@link #ACCESS_FIELD} or {@link #ACCESS_PROPERTY}.\n+     */\n+    public void setAccessType(int type) {\n+        _accessType = type;\n+    }\n+\n+    /**\n+     * Whether the type requires extent management.\n+     */\n+    public boolean getRequiresExtent() {\n+        if (_owner != null || isEmbeddedOnly())\n+            return false;\n+\n+        if (_extent == null) {\n+            ClassMetaData sup = getPCSuperclassMetaData();\n+            if (sup != null)\n+                _extent = (sup.getRequiresExtent()) ? Boolean.TRUE\n+                    : Boolean.FALSE;\n+            else\n+                _extent = Boolean.TRUE;\n+        }\n+        return _extent.booleanValue();\n+    }\n+\n+    /**\n+     * Whether the type requires extent management.\n+     */\n+    public void setRequiresExtent(boolean req) {\n+        _extent = (req) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Whether the type can only be used as an embedded object.\n+     */\n+    public boolean isEmbeddedOnly() {\n+        if (_embedded == null) {\n+            ClassMetaData sup = getPCSuperclassMetaData();\n+            if (sup != null)\n+                _embedded = (sup.isEmbeddedOnly()) ? Boolean.TRUE\n+                    : Boolean.FALSE;\n+            else\n+                _embedded = Boolean.FALSE;\n+        }\n+        return _embedded.booleanValue();\n+    }\n+\n+    /**\n+     * Whether the type can only be used as an embedded object.\n+     */\n+    public void setEmbeddedOnly(boolean embed) {\n+        _embedded = (embed) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Whether the type's fields are actively intercepted, either by\n+     * redefinition or enhancement.\n+     */\n+    public boolean isIntercepting() {\n+        return _intercepting;\n+    }\n+\n+    /**\n+     * Whether the type's fields are actively intercepted, either by\n+     * redefinition or enhancement.\n+     */\n+    public void setIntercepting(boolean intercepting) {\n+        _intercepting = intercepting;\n+    }\n+\n+    /**\n+     * Whether the type is a managed interface.\n+     */\n+    public boolean isManagedInterface() {\n+        if (!_type.isInterface())\n+            return false;\n+        return _interface == null ? false : _interface.booleanValue();\n+    }\n+\n+    /**\n+     * Whether the type is a managed interface\n+     */\n+    public void setManagedInterface(boolean managedInterface) {\n+        if (!_type.isInterface())\n+            throw new MetaDataException(_loc.get(\"not-interface\", _type));\n+        _interface = managedInterface ? Boolean.TRUE : Boolean.FALSE;\n+\n+        // managed interfaces always do proper interception; OpenJPA generates\n+        // the implementations.\n+        if (isManagedInterface())\n+            setIntercepting(true);\n+\n+        // managed interfaces always use property access.\n+        setAccessType(ACCESS_PROPERTY);\n+    }\n+\n+    /**\n+     * Return the managed interface implementor if any.\n+     */\n+    public Class getInterfaceImpl() {\n+        return _impl;\n+    }\n+\n+    /**\n+     * Set the managed interface implementor class.\n+     */\n+    public void setInterfaceImpl(Class impl) {\n+        _impl = impl;\n+    }\n+\n+    /**\n+     * Return all explicitly declared interfaces this class implements.\n+     */\n+    public Class[] getDeclaredInterfaces() {\n+        if (_interfaces == null)\n+            return MetaDataRepository.EMPTY_CLASSES;\n+        return (Class[]) _interfaces.toArray(new Class[_interfaces.size()]);\n+    }\n+\n+    /**\n+     * Explicitly declare the given interface among the ones this\n+     * class implements.\n+     */\n+    public void addDeclaredInterface(Class iface) {\n+        if (iface == null || !iface.isInterface())\n+            throw new MetaDataException(_loc.get(\"declare-non-interface\",\n+                this, iface));\n+        if (_interfaces == null)\n+            _interfaces = new ArrayList();\n+        _interfaces.add(iface);\n+    }\n+\n+    /**\n+     * Remove the given interface from the declared list.\n+     */\n+    public boolean removeDeclaredInterface(Class iface) {\n+        if (_interfaces == null)\n+            return false;\n+        return _interfaces.remove(iface);\n+    }\n+\n+    /**\n+     * Alias properties from the given interface during  queries to\n+     * the local field.\n+     */\n+    public void setInterfacePropertyAlias(Class iface, String orig, \n+        String local) {\n+        synchronized (_ifaceMap) {\n+            Map fields = (Map) _ifaceMap.get(iface);\n+            if (fields == null) {\n+                fields = new HashMap();\n+                _ifaceMap.put(iface, fields);\n+            }\n+            if (fields.containsKey(orig))\n+                throw new MetaDataException(_loc.get(\"duplicate-iface-alias\", \n+                    this, orig, local));\n+            fields.put(orig, local);\n+        }\n+    }\n+    \n+    /**\n+     * Get local field alias for the given interface property.\n+     */\n+    public String getInterfacePropertyAlias(Class iface, String orig) {\n+        synchronized (_ifaceMap) {\n+            Map fields = (Map) _ifaceMap.get(iface);\n+            if (fields == null)\n+                return null;\n+            return (String) fields.get(orig);\n+        }\n+    }\n+    \n+    /**\n+     * Return all aliases property named for the given interface.\n+     */\n+    public String[] getInterfaceAliasedProperties(Class iface) {\n+        synchronized (_ifaceMap) {\n+            Map fields = (Map) _ifaceMap.get(iface);\n+            if (fields == null)\n+                return EMPTY_STRING_ARRAY;\n+            return (String[]) fields.keySet().toArray(\n+                new String[fields.size()]);\n+        }\n+    }\n+    \n+    /**\n+     * Return the number of fields that use impl or intermediate data, in\n+     * order to create a compacted array for storage of said data.\n+     */\n+    public int getExtraFieldDataLength() {\n+        int[] table = getExtraFieldDataTable();\n+        for (int i = table.length - 1; i >= 0; i--)\n+            if (table[i] != -1)\n+                return table[i] + 1;\n+        return 0;\n+    }\n+\n+    /**\n+     * Return the impl / intermediate field data index of the given field\n+     * in the compacted array, or -1 if the field does not use extra data.\n+     *\n+     * @see #getExtraFieldDataLength\n+     */\n+    public int getExtraFieldDataIndex(int field) {\n+        return getExtraFieldDataTable()[field];\n+    }\n+\n+    /**\n+     * Creates a table mapping each field index to its extra data index.\n+     */\n+    private int[] getExtraFieldDataTable() {\n+        if (_fieldDataTable == null) {\n+            FieldMetaData[] fmds = getFields();\n+            int[] table = new int[fmds.length];\n+            int idx = 0;\n+            for (int i = 0; i < fmds.length; i++) {\n+                if (fmds[i].usesIntermediate()\n+                    || fmds[i].usesImplData() != Boolean.FALSE)\n+                    table[i] = idx++;\n+                else\n+                    table[i] = -1;\n+            }\n+            _fieldDataTable = table;\n+        }\n+        return _fieldDataTable;\n+    }\n+\n+    /**\n+     * Return whether the given name represents a managed or static field of\n+     * this class, including superclass fields.\n+     */\n+    public boolean isAccessibleField(String field) {\n+        if (getDeclaredField(field) != null)\n+            return true;\n+        if (_staticFields == null) {\n+            Field[] fields = (Field[]) AccessController.doPrivileged(\n+                J2DoPrivHelper.getDeclaredFieldsAction(_type)); \n+            Set names = new HashSet((int) (fields.length * 1.33 + 1));\n+            for (int i = 0; i < fields.length; i++)\n+                if (Modifier.isStatic(fields[i].getModifiers()))\n+                    names.add(fields[i].getName());\n+            _staticFields = names;\n+        }\n+        if (_staticFields.contains(field))\n+            return true;\n+        if (_super != null)\n+            return getPCSuperclassMetaData().isAccessibleField(field);\n+        return false;\n+    }\n+\n+    /**\n+     * Return all field metadatas, including superclass fields.\n+     */\n+    public FieldMetaData[] getFields() {\n+        if (_allFields == null) {\n+            if (_super == null)\n+                _allFields = getDeclaredFields();\n+            else {\n+                FieldMetaData[] fields = getDeclaredFields();\n+                FieldMetaData[] supFields = getPCSuperclassMetaData().\n+                    getFields();\n+\n+                FieldMetaData[] allFields = _repos.newFieldMetaDataArray\n+                    (fields.length + supFields.length);\n+                System.arraycopy(supFields, 0, allFields, 0, supFields.length);\n+                replaceDefinedSuperclassFields(allFields, supFields.length);\n+\n+                for (int i = 0; i < fields.length; i++) {\n+                    fields[i].setIndex(supFields.length + i);\n+                    allFields[supFields.length + i] = fields[i];\n+                }\n+                _allFields = allFields;\n+            }\n+        }\n+        return _allFields;\n+    }\n+\n+    /**\n+     * Replace superclass fields that we define with our version.\n+     */\n+    private void replaceDefinedSuperclassFields(FieldMetaData[] fields,\n+        int len) {\n+        if (_supFieldMap == null || !_defSupFields)\n+            return;\n+\n+        // don't assume fields are in order; this method is used for\n+        // listing order as well\n+        FieldMetaData supField;\n+        for (int i = 0; i < len; i++) {\n+            supField = (FieldMetaData) _supFieldMap.get(fields[i].getName());\n+            if (supField != null) {\n+                fields[i] = supField;\n+                supField.setIndex(i);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return the superclass copy of the given field.\n+     */\n+    protected FieldMetaData getSuperclassField(FieldMetaData supField) {\n+        ClassMetaData sm = getPCSuperclassMetaData();\n+        FieldMetaData fmd = sm == null ? null : sm.getField(supField.getName());\n+        if (fmd == null || fmd.getManagement() != fmd.MANAGE_PERSISTENT)\n+            throw new MetaDataException(_loc.get(\"unmanaged-sup-field\",\n+                supField, this));\n+        return fmd;\n+    }\n+\n+    /**\n+     * Return only the fields for this class, without superclass fields.\n+     */\n+    public FieldMetaData[] getDeclaredFields() {\n+        if (_fields == null) {\n+            List fields = new ArrayList(_fieldMap.size());\n+            FieldMetaData fmd;\n+            for (Iterator itr = _fieldMap.values().iterator(); itr.hasNext();) {\n+                fmd = (FieldMetaData) itr.next();\n+                if (fmd.getManagement() != FieldMetaData.MANAGE_NONE) {\n+                    fmd.setDeclaredIndex(fields.size());\n+                    fmd.setIndex(fmd.getDeclaredIndex());\n+                    fields.add(fmd);\n+                }\n+            }\n+            _fields = (FieldMetaData[]) fields.toArray\n+                (_repos.newFieldMetaDataArray(fields.size()));\n+        }\n+        return _fields;\n+    }\n+\n+    /**\n+     * Return primary key fields, or empty array if none. The order\n+     * in which the keys are returned will be the order in which\n+     * the fields are declared, starting at the least-derived superclass\n+     * and ending with the primary key fields of the most-derived subclass.\n+     */\n+    public FieldMetaData[] getPrimaryKeyFields() {\n+        // check for pk fields even if not set to ID_APPLICATION so that\n+        // app id tool sees them even when user doesn't declare app id\n+        if (_allPKFields == null) {\n+            FieldMetaData[] fields = getFields();\n+            int num = 0;\n+            for (int i = 0; i < fields.length; i++)\n+                if (fields[i].isPrimaryKey())\n+                    num++;\n+\n+            if (num == 0)\n+                _allPKFields = _repos.EMPTY_FIELDS;\n+            else {\n+                FieldMetaData[] pks = _repos.newFieldMetaDataArray(num);\n+                num = 0;\n+                for (int i = 0; i < fields.length; i++) {\n+                    if (fields[i].isPrimaryKey()) {\n+                        fields[i].setPrimaryKeyIndex(num);\n+                        pks[num] = fields[i];\n+                        num++;\n+                    }\n+                }\n+                _allPKFields = pks;\n+            }\n+        }\n+        return _allPKFields;\n+    }\n+\n+    /**\n+     * Return the list of fields in the default fetch group,\n+     * including superclass fields, or an empty array if none.\n+     */\n+    public FieldMetaData[] getDefaultFetchGroupFields() {\n+        if (_allDFGFields == null) {\n+            FieldMetaData[] fields = getFields();\n+            int num = 0;\n+            for (int i = 0; i < fields.length; i++)\n+                if (fields[i].isInDefaultFetchGroup())\n+                    num++;\n+\n+            FieldMetaData[] dfgs = _repos.newFieldMetaDataArray(num);\n+            num = 0;\n+            for (int i = 0; i < fields.length; i++)\n+                if (fields[i].isInDefaultFetchGroup())\n+                    dfgs[num++] = fields[i];\n+            _allDFGFields = dfgs;\n+        }\n+        return _allDFGFields;\n+    }\n+\n+    /**\n+     * Return the version field for this class, if any.\n+     */\n+    public FieldMetaData getVersionField() {\n+        if (_versionIdx == Integer.MIN_VALUE) {\n+            FieldMetaData[] fields = getFields();\n+            int idx = -1;\n+            for (int i = 0; i < fields.length; i++) {\n+                if (fields[i].isVersion()) {\n+                    if (idx != -1)\n+                        throw new MetaDataException(_loc.get\n+                            (\"mult-vers-fields\", this, fields[idx], fields[i]));\n+                    idx = i;\n+                }\n+            }\n+            _versionIdx = idx;\n+        }\n+        if (_versionIdx == -1)\n+            return null;\n+        return getFields()[_versionIdx];\n+    }\n+\n+    /**\n+     * Return the metadata for the persistent or transactional field with\n+     * the given absolute index.\n+     *\n+     * @return the field's metadata, or null if not found\n+     */\n+    public FieldMetaData getField(int index) {\n+        FieldMetaData[] fields = getFields();\n+        if (index < 0 || index >= fields.length)\n+            return null;\n+        return fields[index];\n+    }\n+\n+    /**\n+     * Return the metadata for the persistent or transactional field with\n+     * the given relative index.\n+     *\n+     * @return the field's metadata, or null if not found\n+     */\n+    public FieldMetaData getDeclaredField(int index) {\n+        FieldMetaData[] fields = getDeclaredFields();\n+        if (index < 0 || index >= fields.length)\n+            return null;\n+        return fields[index];\n+    }\n+\n+    /**\n+     * Return the metadata for the persistent or transactional field with\n+     * the given name.\n+     *\n+     * @return the field's metadata, or null if not found\n+     */\n+    public FieldMetaData getField(String name) {\n+        FieldMetaData fmd = getDeclaredField(name);\n+        if (fmd != null)\n+            return fmd;\n+        if (_supFieldMap != null && _defSupFields) {\n+            fmd = (FieldMetaData) _supFieldMap.get(name);\n+            if (fmd != null)\n+                return fmd;\n+        }\n+        if (_super != null)\n+            return getPCSuperclassMetaData().getField(name);\n+        return null;\n+    }\n+\n+    /**\n+     * Return the metadata for the persistent or transactional field with\n+     * the given name, without including superclass fields.\n+     *\n+     * @return the field's metadata, or null if not found\n+     */\n+    public FieldMetaData getDeclaredField(String name) {\n+        FieldMetaData field = (FieldMetaData) _fieldMap.get(name);\n+        if (field == null || field.getManagement() == field.MANAGE_NONE)\n+            return null;\n+        return field;\n+    }\n+\n+    /**\n+     * Return any fields that were added as non-managed.\n+     * All other methods to get fields return only those that are managed.\n+     */\n+    public FieldMetaData[] getDeclaredUnmanagedFields() {\n+        if (_unmgdFields == null) {\n+            Collection unmanaged = new ArrayList(3);\n+            FieldMetaData field;\n+            for (Iterator itr = _fieldMap.values().iterator(); itr.hasNext();) {\n+                field = (FieldMetaData) itr.next();\n+                if (field.getManagement() == FieldMetaData.MANAGE_NONE)\n+                    unmanaged.add(field);\n+            }\n+            _unmgdFields = (FieldMetaData[]) unmanaged.toArray\n+                (_repos.newFieldMetaDataArray(unmanaged.size()));\n+        }\n+        return _unmgdFields;\n+    }\n+\n+    /**\n+     * Add a new field metadata to this class.\n+     */\n+    public FieldMetaData addDeclaredField(String name, Class type) {\n+        FieldMetaData fmd = _repos.newFieldMetaData(name, type, this);\n+        clearFieldCache();\n+        _fieldMap.put(name, fmd);\n+        return fmd;\n+    }\n+\n+    /**\n+     * Remove the given field from management.\n+     *\n+     * @return true if the field was removed, false otherwise\n+     */\n+    public boolean removeDeclaredField(FieldMetaData field) {\n+        if (field != null && _fieldMap.remove(field.getName()) != null) {\n+            clearFieldCache();\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Return the defined superclass field with the given name, or null if none.\n+     */\n+    public FieldMetaData getDefinedSuperclassField(String name) {\n+        if (_supFieldMap == null)\n+            return null;\n+        return (FieldMetaData) _supFieldMap.get(name);\n+    }\n+\n+    /**\n+     * Add a new defined superclass field metadata to this class.\n+     */\n+    public FieldMetaData addDefinedSuperclassField(String name, Class type,\n+        Class sup) {\n+        FieldMetaData fmd = _repos.newFieldMetaData(name, type, this);\n+        fmd.setDeclaringType(sup);\n+        clearAllFieldCache();\n+        _defSupFields = false;\n+        if (_supFieldMap == null)\n+            _supFieldMap = new HashMap();\n+        _supFieldMap.put(name, fmd);\n+        return fmd;\n+    }\n+\n+    /**\n+     * Remove the given field from management.\n+     *\n+     * @return true if the field was removed, false otherwise\n+     */\n+    public boolean removeDefinedSuperclassField(FieldMetaData field) {\n+        if (field != null && _supFieldMap != null\n+            && _supFieldMap.remove(field.getName()) != null) {\n+            clearAllFieldCache();\n+            _defSupFields = false;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Incorporate superclass fields redefined in this subclass into this\n+     * metadata. This method is generally called after metadata is resolved\n+     * and mapping information is loaded, but before mapping resolve.\n+     *\n+     * @param force whether to force re-mapping of even mapped superclass fields\n+     */\n+    public void defineSuperclassFields(boolean force) {\n+        if (_defSupFields)\n+            return;\n+\n+        ClassMetaData sup = getPCSuperclassMetaData();\n+        if (isMapped() && sup != null) {\n+            // redefine all unmapped superclass fields\n+            FieldMetaData[] sups = sup.getFields();\n+            for (int i = 0; i < sups.length; i++) {\n+                if ((force || !sups[i].getDefiningMetaData().isMapped())\n+                    && getDefinedSuperclassField(sups[i].getName()) == null) {\n+                    addDefinedSuperclassField(sups[i].getName(),\n+                        sups[i].getDeclaredType(), sups[i].getDeclaringType());\n+                }\n+            }\n+        }\n+        resolveDefinedSuperclassFields();\n+\n+        // this ensures that all field indexes get set when fields are cached.\n+        // I don't like doing this twice (it's also done in resolveMeta), but\n+        // we have to re-cache in case this class or any superclass replaced\n+        // some fields with redefined versions, and I don't want outside code\n+        // to have to call this method after resolve just to get field indexes,\n+        // etc set correctly\n+        clearAllFieldCache();\n+        cacheFields();\n+    }\n+\n+    /**\n+     * Resolve superclass fields we've redefined.\n+     */\n+    private void resolveDefinedSuperclassFields() {\n+        _defSupFields = true;\n+        if (_supFieldMap == null)\n+            return;\n+\n+        FieldMetaData fmd;\n+        FieldMetaData sup;\n+        for (Iterator itr = _supFieldMap.values().iterator(); itr.hasNext();) {\n+            fmd = (FieldMetaData) itr.next();\n+            sup = getSuperclassField(fmd);\n+\n+            // jpa metadata doesn't qualify superclass field names, so we\n+            // might not know the declaring type until now\n+            if (fmd.getDeclaringType() == Object.class) {\n+                fmd.setDeclaringType(sup.getDeclaringType());\n+                fmd.backingMember(getRepository().getMetaDataFactory().\n+                    getDefaults().getBackingMember(fmd));\n+            }\n+            fmd.copy(sup);\n+            fmd.resolve(MODE_META);\n+        }\n+    }\n+\n+    /**\n+     * Returns an array of all the fields defined by this class.\n+     * This includes mapped declared fields and any concrete mapping of\n+     * unmapped superclass fields performed by this class.\n+     */\n+    public FieldMetaData[] getDefinedFields() {\n+        if (_definedFields == null) {\n+            FieldMetaData[] fields = getFields();\n+            List defined = new ArrayList(fields.length);\n+            for (int i = 0; i < fields.length; i++) {\n+                if (fields[i].isMapped()\n+                    && fields[i].getDefiningMetaData() == this)\n+                    defined.add(fields[i]);\n+            }\n+            _definedFields = (FieldMetaData[]) defined.toArray\n+                (_repos.newFieldMetaDataArray(defined.size()));\n+        }\n+        return _definedFields;\n+    }\n+\n+    /**\n+     * Returns all fields in the order they are listed in the metadata\n+     * file. Unlisted fields are placed after listed ones.\n+     */\n+    public FieldMetaData[] getFieldsInListingOrder() {\n+        if (_allListingFields == null) {\n+            // combine declared and unmanaged fields into listing order array\n+            FieldMetaData[] dec = getDeclaredFields();\n+            FieldMetaData[] unmgd = getDeclaredUnmanagedFields();\n+            FieldMetaData[] decListing = _repos.newFieldMetaDataArray\n+                (dec.length + unmgd.length);\n+            System.arraycopy(dec, 0, decListing, 0, dec.length);\n+            System.arraycopy(unmgd, 0, decListing, dec.length, unmgd.length);\n+            Arrays.sort(decListing, ListingOrderComparator.getInstance());\n+\n+            if (_super == null)\n+                _allListingFields = decListing;\n+            else {\n+                // place superclass fields in listing order before our\n+                // listing-order declared fields\n+                FieldMetaData[] sup = getPCSuperclassMetaData().\n+                    getFieldsInListingOrder();\n+                FieldMetaData[] listing = _repos.newFieldMetaDataArray\n+                    (sup.length + decListing.length);\n+                System.arraycopy(sup, 0, listing, 0, sup.length);\n+                replaceDefinedSuperclassFields(listing, sup.length);\n+                System.arraycopy(decListing, 0, listing, sup.length,\n+                    decListing.length);\n+                _allListingFields = listing;\n+            }\n+        }\n+        return _allListingFields;\n+    }\n+\n+    /**\n+     * Returns all fields defined by this class in the order they are listed\n+     * in the metadata file. Unlisted fields are placed after listed ones.\n+     * This array includes declared transactional and unmanaged fields.\n+     */\n+    public FieldMetaData[] getDefinedFieldsInListingOrder() {\n+        if (_listingFields == null) {\n+            FieldMetaData[] fields = getFields();\n+            List defined = new ArrayList(fields.length);\n+            for (int i = 0; i < fields.length; i++)\n+                if (fields[i].getDefiningMetaData() == this)\n+                    defined.add(fields[i]);\n+            FieldMetaData[] unmgd = getDeclaredUnmanagedFields();\n+            FieldMetaData[] listing = _repos.newFieldMetaDataArray\n+                (defined.size() + unmgd.length);\n+            for (int i = 0; i < defined.size(); i++)\n+                listing[i] = (FieldMetaData) defined.get(i);\n+            System.arraycopy(unmgd, 0, listing, defined.size(), unmgd.length);\n+            Arrays.sort(listing, ListingOrderComparator.getInstance());\n+            _listingFields = listing;\n+        }\n+        return _listingFields;\n+    }\n+\n+    /**\n+     * The name of the datacache to use for this class, or null if none.\n+     */\n+    public String getDataCacheName() {\n+        if (DEFAULT_STRING.equals(_cacheName)) {\n+            if (_super != null)\n+                _cacheName = getPCSuperclassMetaData().getDataCacheName();\n+            else\n+                _cacheName = DataCache.NAME_DEFAULT;\n+        }\n+        return _cacheName;\n+    }\n+\n+    /**\n+     * Set the cache name for this class. Set to null to disable caching.\n+     */\n+    public void setDataCacheName(String name) {\n+        _cacheName = name;\n+    }\n+\n+    /**\n+     * The cache timeout for this class. -1 indicates no timeout.\n+     */\n+    public int getDataCacheTimeout() {\n+        if (_cacheTimeout == Integer.MIN_VALUE) {\n+            if (_super != null)\n+                _cacheTimeout = getPCSuperclassMetaData().\n+                    getDataCacheTimeout();\n+            else\n+                _cacheTimeout = _repos.getConfiguration().\n+                    getDataCacheTimeout();\n+        }\n+        return _cacheTimeout;\n+    }\n+\n+    /**\n+     * The cache timeout for this class. -1 indicates no timeout.\n+     */\n+    public void setDataCacheTimeout(int timeout) {\n+        _cacheTimeout = timeout;\n+    }\n+\n+    /**\n+     * Return the data cache for this class, or null if it is not cachable.\n+     */\n+    public DataCache getDataCache() {\n+        String name = getDataCacheName();\n+        if (name == null)\n+            return null;\n+        return _repos.getConfiguration().getDataCacheManagerInstance().\n+            getDataCache(name, true);\n+    }\n+\n+    /**\n+     * Whether instances are detachable.\n+     */\n+    public boolean isDetachable() {\n+        if (_detachable == null) {\n+            if (_super != null)\n+                _detachable = (getPCSuperclassMetaData().isDetachable())\n+                    ? Boolean.TRUE : Boolean.FALSE;\n+            else\n+                _detachable = Boolean.FALSE;\n+        }\n+        return _detachable.booleanValue();\n+    }\n+\n+    /**\n+     * Whether instances are detachable.\n+     */\n+    public void setDetachable(boolean detachable) {\n+        _detachable = (detachable) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * The name of the detach state field, or null if none.\n+     */\n+    public String getDetachedState() {\n+        if (DEFAULT_STRING.equals(_detachState)) {\n+            ClassMetaData sup = getPCSuperclassMetaData();\n+            if (sup != null && sup.isDetachable() == isDetachable())\n+                _detachState = sup.getDetachedState();\n+            else {\n+                Boolean use = usesDetachedState(SYNTHETIC, true);\n+                _detachState = (Boolean.FALSE.equals(use)) ? null : SYNTHETIC;\n+            }\n+        }\n+        return _detachState;\n+    }\n+\n+    /**\n+     * The name of the detach state field, or null if none.\n+     */\n+    public void setDetachedState(String field) {\n+        _detachState = field;\n+    }\n+\n+    /**\n+     * Return the detach state field, or null if none.\n+     */\n+    public Field getDetachedStateField() {\n+        // no caching; only used at enhancement\n+        String fieldName = getDetachedState();\n+        if (fieldName == null || SYNTHETIC.equals(fieldName))\n+            return null;\n+\n+        Field f = Reflection.findField(_type, fieldName, false);\n+        if (f != null)\n+            return f;\n+        else\n+            throw new MetaDataException(\n+                _loc.get(\"no-detach-state\", fieldName, _type));\n+    }\n+\n+    /**\n+     * Whether an instance of this type has detached state.\n+     *\n+     * @return true if a detached instance must have detached state, false\n+     * if it does not, and null if it may use a\n+     * manually-constructed instance without detached state\n+     */\n+    public Boolean usesDetachedState() {\n+        // no need to let conf disallow because it's taken into account in\n+        // getDetachedState() call\n+        return usesDetachedState(getDetachedState(), false);\n+    }\n+\n+    /**\n+     * Whether an instance of this type has detached state, assuming the given\n+     * detached state field.\n+     *\n+     * @return true if a detached instance must have detached state, false\n+     * if it does not, and null if it may use a\n+     * manually-constructed instance without detached state\n+     */\n+    private Boolean usesDetachedState(String detachedField,\n+        boolean confDisallows) {\n+        if (!isDetachable())\n+            return Boolean.FALSE;\n+\n+        // if we declare a detached state field, have to use it\n+        if (detachedField == null)\n+            return Boolean.FALSE;\n+        if (!SYNTHETIC.equals(detachedField))\n+            return Boolean.TRUE;\n+\n+        // allow conf to disallow\n+        if (confDisallows && !_repos.getConfiguration().\n+            getDetachStateInstance().getDetachedStateField())\n+            return Boolean.FALSE;\n+\n+        // have to use detached state to store datastore id\n+        if (getIdentityType() == ID_DATASTORE)\n+            return Boolean.TRUE;\n+\n+        // allow detached state use, but don't require\n+        return null;\n+    }\n+\n+    /**\n+     * Clear cached field data.\n+     */\n+    protected void clearAllFieldCache() {\n+        _allFields = null;\n+        _allDFGFields = null;\n+        _allPKFields = null;\n+        _definedFields = null;\n+        _listingFields = null;\n+        _allListingFields = null;\n+        _fieldDataTable = null;\n+    }\n+\n+    /**\n+     * Clear defined field data.\n+     */\n+    protected void clearDefinedFieldCache() {\n+        _definedFields = null;\n+        _listingFields = null;\n+    }\n+\n+    /**\n+     * Clear cached field data.\n+     */\n+    protected void clearFieldCache() {\n+        clearAllFieldCache();\n+        _fields = null;\n+        _unmgdFields = null;\n+        _versionIdx = Integer.MIN_VALUE;\n+    }\n+\n+    /**\n+     * Clear cached subclass data.\n+     */\n+    protected void clearSubclassCache() {\n+        _subs = null;\n+        _subMetas = null;\n+        _mapSubMetas = null;\n+    }\n+\n+    /**\n+     * Clear impl data and intermediate data table.\n+     */\n+    void clearExtraFieldDataTable() {\n+        _fieldDataTable = null;\n+    }\n+\n+    /**\n+     * Cache field arrays.\n+     */\n+    private void cacheFields() {\n+        getFields();\n+        getPrimaryKeyFields();\n+    }\n+\n+    public int hashCode() {\n+        return _type.getName().hashCode();\n+    }\n+\n+    public boolean equals(Object other) {\n+        if (other == this)\n+            return true;\n+        if (!(other instanceof ClassMetaData))\n+            return false;\n+        return _type == ((ClassMetaData) other).getDescribedType();\n+    }\n+\n+    public int compareTo(Object other) {\n+        if (other == this)\n+            return 0;\n+        return _type.getName().compareTo(((ClassMetaData) other).\n+            getDescribedType().getName());\n+    }\n+\n+    public String toString() {\n+        return getDescribedType().getName();\n+    }\n+\n+    ////////////////////////\n+    // Resolve and validate\n+    ////////////////////////\n+\n+    /**\n+     * The resolve mode for this metadata.\n+     */\n+    public int getResolve() {\n+        return _resMode;\n+    }\n+\n+    /**\n+     * The resolve mode for this metadata.\n+     */\n+    public void setResolve(int mode) {\n+        _resMode = mode;\n+    }\n+\n+    /**\n+     * The resolve mode for this metadata.\n+     */\n+    public void setResolve(int mode, boolean on) {\n+        if (mode == MODE_NONE)\n+            _resMode = mode;\n+        else if (on)\n+            _resMode |= mode;\n+        else\n+            _resMode &= ~mode;\n+    }\n+\n+    /**\n+     * Resolve and validate metadata. Return true if already resolved.\n+     */\n+    public boolean resolve(int mode) {\n+        if ((_resMode & mode) == mode)\n+            return true;\n+        int cur = _resMode;\n+        _resMode |= mode;\n+\n+        int val = _repos.getValidate();\n+        boolean runtime = (val & _repos.VALIDATE_RUNTIME) != 0;\n+        boolean validate =\n+            !ImplHelper.isManagedType(getRepository().getConfiguration(), _type)\n+            || (val & MetaDataRepository.VALIDATE_UNENHANCED) == 0;\n+\n+        // we only do any actions for metadata mode\n+        if ((mode & MODE_META) != 0 && (cur & MODE_META) == 0) {\n+            resolveMeta(runtime);\n+            if (validate && (val & _repos.VALIDATE_META) != 0)\n+                validateMeta(runtime);\n+        }\n+        if ((mode & MODE_MAPPING) != 0 && (cur & MODE_MAPPING) == 0) {\n+            resolveMapping(runtime);\n+            if (validate && (val & _repos.VALIDATE_MAPPING) != 0)\n+                validateMapping(runtime);\n+        }\n+        if ((mode & MODE_MAPPING_INIT) != 0 && (cur & MODE_MAPPING_INIT) == 0)\n+            initializeMapping();\n+        return false;\n+    }\n+\n+    /**\n+     * Resolve metadata.\n+     */\n+    protected void resolveMeta(boolean runtime) {\n+        boolean embed = _owner != null && _owner.getDeclaredType() == _type;\n+        Log log = _repos.getLog();\n+        if (log.isTraceEnabled())\n+            log.trace(_loc.get((embed) ? \"resolve-embed-meta\" : \"resolve-meta\",\n+                this + \"@\" + System.identityHashCode(this)));\n+\n+        if (runtime && !_type.isInterface() &&\n+            !ImplHelper.isManagedType(getRepository().getConfiguration(),_type))\n+            throw new MetaDataException(_loc.get(\"not-enhanced\", _type));\n+\n+        // are we the target of an embedded value?\n+        if (embed) {\n+            if (_owner.getFieldMetaData().getDefiningMetaData().\n+                getDescribedType().isAssignableFrom(_type))\n+                throw new MetaDataException(_loc.get(\"recurse-embed\", _owner));\n+\n+            // copy info from the \"real\" metadata for this type\n+            ClassMetaData meta = _repos.getMetaData(_type, _loader, true);\n+            meta.resolve(MODE_META);\n+            copy(this, meta);\n+            _embedded = Boolean.FALSE; // embedded instance isn't embedded-only\n+        }\n+\n+        // make sure superclass is resolved\n+        ClassMetaData sup = getPCSuperclassMetaData();\n+        if (sup != null) {\n+            sup.resolve(MODE_META);\n+            if (embed) {\n+                // embedded instance always redefine all superclass fields\n+                FieldMetaData[] sups = sup.getFields();\n+                for (int i = 0; i < sups.length; i++) {\n+                    if (_supFieldMap == null\n+                        || !_supFieldMap.containsKey(sups[i].getName())) {\n+                        addDefinedSuperclassField(sups[i].getName(),\n+                            sups[i].getDeclaredType(),\n+                            sups[i].getDeclaringType());\n+                    }\n+                }\n+            }\n+        }\n+\n+        // resolve fields and remove invalids\n+        FieldMetaData fmd;\n+        for (Iterator itr = _fieldMap.values().iterator(); itr.hasNext();) {\n+            // only pass on metadata resolve mode so that metadata is always\n+            // resolved before any other resolve modes our subclasses pass along\n+            fmd = (FieldMetaData) itr.next();\n+            fmd.resolve(MODE_META);\n+\n+            if (!fmd.isExplicit()\n+                && (fmd.getDeclaredTypeCode() == JavaTypes.OBJECT\n+                || fmd.getDeclaredTypeCode() == JavaTypes.PC_UNTYPED\n+                || (fmd.getDeclaredTypeCode() == JavaTypes.ARRAY\n+                && fmd.getElement().getDeclaredTypeCode()\n+                == JavaTypes.OBJECT))) {\n+                _repos.getLog().warn(_loc.get(\"rm-field\", fmd));\n+                if (fmd.getListingIndex() != -1)\n+                    fmd.setManagement(fmd.MANAGE_NONE);\n+                else\n+                    itr.remove();\n+                clearFieldCache();\n+            }\n+        }\n+\n+        // embedded instances must embed all superclass fields too\n+        if (embed) {\n+            clearAllFieldCache();\n+            resolveDefinedSuperclassFields();\n+        }\n+\n+        // this ensures that all field indexes get set when fields are cached\n+        cacheFields();\n+\n+        // resolve lifecycle metadata now to prevent lazy threading problems\n+        _lifeMeta.resolve();\n+\n+        // record implements in the repository\n+        if (_interfaces != null) {\n+            for (Iterator it = _interfaces.iterator(); it.hasNext();)\n+                _repos.addDeclaredInterfaceImpl(this, (Class) it.next());\n+        }\n+\n+        // resolve fetch groups\n+        if (_fgMap != null)\n+            for (Iterator itr = _fgMap.values().iterator(); itr.hasNext();)\n+                ((FetchGroup) itr.next()).resolve();\n+\n+        if (!embed && _type.isInterface()) {\n+            if (_interface != Boolean.TRUE)\n+                throw new MetaDataException(_loc.get(\"interface\", _type));\n+\n+            if (runtime) {\n+                _impl = _repos.getImplGenerator().createImpl(this);\n+                _repos.setInterfaceImpl(this, _impl);\n+            }\n+        }\n+\n+        // if this is runtime, create a pc instance and scan it for comparators\n+        if (runtime && !Modifier.isAbstract(_type.getModifiers())) {\n+            ProxySetupStateManager sm = new ProxySetupStateManager();\n+            sm.setProxyData(PCRegistry.newInstance(_type, sm, false), this);\n+        }\n+    }\n+\n+    /**\n+     * Validate resolved metadata.\n+     */\n+    protected void validateMeta(boolean runtime) {\n+        validateDataCache();\n+        validateDetachable();\n+        validateExtensionKeys();\n+        validateIdentity();\n+        validateAccessType();\n+    }\n+\n+    /**\n+     * Resolve mapping data. Logs resolve message and resolves super by default.\n+     */\n+    protected void resolveMapping(boolean runtime) {\n+        Log log = _repos.getLog();\n+        if (log.isTraceEnabled())\n+            log.trace(_loc.get(\"resolve-mapping\", this + \"@\"\n+                + System.identityHashCode(this)));\n+\n+        // make sure superclass is resolved first\n+        ClassMetaData sup = getPCSuperclassMetaData();\n+        if (sup != null)\n+            sup.resolve(MODE_MAPPING);\n+    }\n+\n+    /**\n+     * Validate mapping data.\n+     */\n+    protected void validateMapping(boolean runtime) {\n+    }\n+\n+    /**\n+     * Initialize mapping. Logs init message by default.\n+     */\n+    protected void initializeMapping() {\n+        Log log = _repos.getLog();\n+        if (log.isTraceEnabled())\n+            log.trace(_loc.get(\"init-mapping\", this + \"@\"\n+                + System.identityHashCode(this)));\n+    }\n+\n+    /**\n+     * Validate data cache settings.\n+     */\n+    private void validateDataCache() {\n+        int timeout = getDataCacheTimeout();\n+        if (timeout < -1 || timeout == 0)\n+            throw new MetaDataException(_loc.get(\"cache-timeout-invalid\",\n+                _type, String.valueOf(timeout)));\n+\n+        if (_super == null)\n+            return;\n+        String cache = getDataCacheName();\n+        if (cache == null)\n+            return;\n+\n+        String superCache = getPCSuperclassMetaData().getDataCacheName();\n+        if (!StringUtils.equals(cache, superCache))\n+            throw new MetaDataException(_loc.get(\"cache-names\", new Object[]\n+                { _type, cache, _super, superCache }));\n+    }\n+\n+    /**\n+     * Assert that the identity handling for this class is valid.\n+     */\n+    private void validateIdentity() {\n+        // make sure identity types are consistent\n+        ClassMetaData sup = getPCSuperclassMetaData();\n+        int id = getIdentityType();\n+        if (sup != null && sup.getIdentityType() != ID_UNKNOWN\n+            && sup.getIdentityType() != id)\n+            throw new MetaDataException(_loc.get(\"id-types\", _type));\n+\n+        // check for things the data store doesn't support\n+        Collection opts = _repos.getConfiguration().supportedOptions();\n+        if (id == ID_APPLICATION\n+            && !opts.contains(OpenJPAConfiguration.OPTION_ID_APPLICATION)) {\n+            throw new UnsupportedException(_loc.get(\"appid-not-supported\",\n+                _type));\n+        }\n+        if (id == ID_DATASTORE\n+            && !opts.contains(OpenJPAConfiguration.OPTION_ID_DATASTORE)) {\n+            throw new UnsupportedException(_loc.get\n+                (\"datastoreid-not-supported\", _type));\n+        }\n+\n+        if (id == ID_APPLICATION) {\n+            if (_idStrategy != ValueStrategies.NONE)\n+                throw new MetaDataException(_loc.get(\"appid-strategy\", _type));\n+            validateAppIdClass();\n+        } else if (id != ID_UNKNOWN)\n+            validateNoPKFields();\n+\n+        int strategy = getIdentityStrategy();\n+        if (strategy == ValueStrategies.SEQUENCE\n+            && getIdentitySequenceName() == null)\n+            throw new MetaDataException(_loc.get(\"no-seq-name\", _type));\n+\n+        ValueStrategies.assertSupported(strategy, this,\n+            \"datastore identity strategy\");\n+    }\n+\n+    /**\n+     * Make sure the application identity class is valid.\n+     */\n+    private void validateAppIdClass() {\n+        // base types must declare an oid class if not single-field identity\n+        FieldMetaData[] pks = getPrimaryKeyFields();\n+        if (getObjectIdType() == null) {\n+            if (pks.length == 1)\n+                throw new MetaDataException(_loc.get(\"unsupported-id-type\",\n+                    _type, pks[0].getName(),\n+                    pks[0].getDeclaredType().getName()));\n+            throw new MetaDataException(_loc.get(\"no-id-class\", _type));\n+        }\n+        if (_objectId == null)\n+            return;\n+\n+        if (isOpenJPAIdentity()) {\n+            if (pks[0].getDeclaredTypeCode() == JavaTypes.OID) {\n+                ClassMetaData embed = pks[0].getEmbeddedMetaData();\n+                validateAppIdClassMethods(embed.getDescribedType());\n+                validateAppIdClassPKs(embed, embed.getFields(),\n+                    embed.getDescribedType());\n+            }\n+            return;\n+        }\n+\n+        if (_super != null) {\n+            // concrete superclass oids must match or be parent of ours\n+            ClassMetaData sup = getPCSuperclassMetaData();\n+            if (!sup.getObjectIdType().isAssignableFrom(_objectId))\n+                throw new MetaDataException(_loc.get(\"id-classes\",\n+                    new Object[]{ _type, _objectId, _super,\n+                        sup.getObjectIdType() }));\n+\n+            // validate that no other pks are declared if we have a\n+            // concrete PC superclass\n+            if (hasConcretePCSuperclass())\n+                validateNoPKFields();\n+        }\n+\n+        // if this class has its own oid class, do some more validation\n+        if (_super == null\n+            || _objectId != getPCSuperclassMetaData().getObjectIdType()) {\n+            // make sure non-abstract oid classes override the proper methods\n+            if (!Modifier.isAbstract(_objectId.getModifiers()))\n+                validateAppIdClassMethods(_objectId);\n+\n+            // make sure the app id class has all pk fields\n+            validateAppIdClassPKs(this, pks, _objectId);\n+        }\n+    }\n+\n+    /**\n+     * Return true if this class has a concrete persistent superclass.\n+     */\n+    private boolean hasConcretePCSuperclass() {\n+        if (_super == null)\n+            return false;\n+        if (!Modifier.isAbstract(_super.getModifiers()))\n+            return true;\n+        return getPCSuperclassMetaData().hasConcretePCSuperclass();\n+    }\n+\n+    /**\n+     * Ensure that the user has overridden the equals and hashCode methods,\n+     * and has the proper constructors.\n+     */\n+    private void validateAppIdClassMethods(Class oid) {\n+        try {\n+            oid.getConstructor((Class[]) null);\n+        } catch (Exception e) {\n+            throw new MetaDataException(_loc.get(\"null-cons\", _type)).\n+                setCause(e);\n+        }\n+\n+        // check for equals and hashcode overrides; don't enforce it\n+        // for abstract app id classes, since they may not necessarily\n+        // declare primary key fields\n+        Method method;\n+        try {\n+            method = oid.getMethod(\"equals\", new Class[]{ Object.class });\n+        } catch (Exception e) {\n+            throw new GeneralException(e).setFatal(true);\n+        }\n+\n+        boolean abs = Modifier.isAbstract(_type.getModifiers());\n+        if (!abs && method.getDeclaringClass() == Object.class)\n+            throw new MetaDataException(_loc.get(\"eq-method\", _type));\n+\n+        try {\n+            method = oid.getMethod(\"hashCode\", (Class[]) null);\n+        } catch (Exception e) {\n+            throw new GeneralException(e).setFatal(true);\n+        }\n+        if (!abs && method.getDeclaringClass() == Object.class)\n+            throw new MetaDataException(_loc.get(\"hc-method\", _type));\n+    }\n+\n+    /**\n+     * Validate that the primary key class has all pk fields.\n+     */\n+    private void validateAppIdClassPKs(ClassMetaData meta,\n+        FieldMetaData[] fmds, Class oid) {\n+        if (fmds.length == 0 && !Modifier.isAbstract(meta.getDescribedType().\n+            getModifiers()))\n+            throw new MetaDataException(_loc.get(\"no-pk\", _type));\n+\n+        // check that the oid type contains all pk fields\n+        Field f;\n+        Method m;\n+        Class c;\n+        for (int i = 0; i < fmds.length; i++) {\n+            switch (fmds[i].getDeclaredTypeCode()) {\n+                case JavaTypes.ARRAY:\n+                    c = fmds[i].getDeclaredType().getComponentType();\n+                    if (c == byte.class || c == Byte.class\n+                        || c == char.class || c == Character.class) {\n+                        c = fmds[i].getDeclaredType();\n+                        break;\n+                    }\n+                    // else no break\n+                case JavaTypes.PC_UNTYPED:\n+                case JavaTypes.COLLECTION:\n+                case JavaTypes.MAP:\n+                case JavaTypes.OID: // we're validating embedded fields\n+                    throw new MetaDataException(_loc.get(\"bad-pk-type\",\n+                        fmds[i]));\n+                default:\n+                    c = fmds[i].getObjectIdFieldType();\n+            }\n+\n+            if (meta.getAccessType() == ACCESS_FIELD) {\n+                f = Reflection.findField(oid, fmds[i].getName(), false);\n+                if (f == null || !f.getType().isAssignableFrom(c))\n+                    throw new MetaDataException(_loc.get(\"invalid-id\",\n+                        _type, fmds[i].getName()));\n+            } else if (meta.getAccessType() == ACCESS_PROPERTY) {\n+                m = Reflection.findGetter(oid, fmds[i].getName(), false);\n+                if (m == null || !m.getReturnType().isAssignableFrom(c))\n+                    throw new MetaDataException(_loc.get(\"invalid-id\",\n+                        _type, fmds[i].getName()));\n+                m = Reflection.findSetter(oid, fmds[i].getName(),\n+                    fmds[i].getObjectIdFieldType(), false);\n+                if (m == null || m.getReturnType() != void.class)\n+                    throw new MetaDataException(_loc.get(\"invalid-id\",\n+                        _type, fmds[i].getName()));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate that this class doesn't declare any primary key fields.\n+     */\n+    private void validateNoPKFields() {\n+        FieldMetaData[] fields = getDeclaredFields();\n+        for (int i = 0; i < fields.length; i++)\n+            if (fields[i].isPrimaryKey())\n+                throw new MetaDataException(_loc.get(\"bad-pk\", fields[i]));\n+    }\n+\n+    /**\n+     * Assert that this class' access type is allowed.\n+     */\n+    private void validateAccessType() {\n+        if (_accessType == ACCESS_UNKNOWN)\n+            return;\n+        ClassMetaData sup = getPCSuperclassMetaData();\n+        if (sup != null && sup.getAccessType() != ACCESS_UNKNOWN\n+            && sup.getAccessType() != _accessType &&\n+            getPCSuperclassMetaData().getFields().length > 0) {\n+            throw new MetaDataException(_loc.get(\"inconsistent-access\",\n+                this, sup));\n+        }\n+    }\n+\n+    /**\n+     * Assert that detachment configuration is valid.\n+     */\n+    private void validateDetachable() {\n+        boolean first = true;\n+        for (ClassMetaData parent = getPCSuperclassMetaData();\n+            first && parent != null; parent = parent.getPCSuperclassMetaData())\n+        {\n+            if (parent.isDetachable())\n+                first = false;\n+        }\n+\n+        Field field = getDetachedStateField();\n+        if (field != null) {\n+            if (!first)\n+                throw new MetaDataException(_loc.get(\"parent-detach-state\",\n+                    _type));\n+            if (getField(field.getName()) != null)\n+                throw new MetaDataException(_loc.get(\"managed-detach-state\",\n+                    field.getName(), _type));\n+            if (field.getType() != Object.class)\n+                throw new MetaDataException(_loc.get(\"bad-detach-state\",\n+                    field.getName(), _type));\n+        }\n+    }\n+\n+    ///////////////\n+    // Fetch Group\n+    ///////////////\n+\n+    /**\n+     * Return the fetch groups declared explicitly in this type.\n+     */\n+    public FetchGroup[] getDeclaredFetchGroups() {\n+        if (_fgs == null)\n+            _fgs = (_fgMap == null) ? EMPTY_FETCH_GROUP_ARRAY : (FetchGroup[])\n+                _fgMap.values().toArray(new FetchGroup[_fgMap.size()]); \n+        return _fgs;\n+    }\n+\n+    /**\n+     * Return all fetch groups for this type, including superclass groups.\n+     */\n+    public FetchGroup[] getCustomFetchGroups() {\n+        if (_customFGs == null) {\n+            // map fgs to names, allowing our fgs to override supers\n+            Map fgs = new HashMap();\n+            ClassMetaData sup = getPCSuperclassMetaData();\n+            if (sup != null)\n+            {\n+                FetchGroup[] supFGs = sup.getCustomFetchGroups();\n+                for (int i = 0; i < supFGs.length; i++)\n+                    fgs.put(supFGs[i].getName(), supFGs[i]);\n+            }\n+            FetchGroup[] decs = getDeclaredFetchGroups();\n+            for (int i = 0; i < decs.length; i++)\n+                fgs.put(decs[i].getName(), decs[i]);\n+            \n+            // remove std groups\n+            fgs.remove(FetchGroup.NAME_DEFAULT);\n+            fgs.remove(FetchGroup.NAME_ALL);\n+\n+            _customFGs = (FetchGroup[]) fgs.values().toArray\n+                (new FetchGroup[fgs.size()]);\n+        }\n+        return _customFGs;\n+    }\n+\n+    /**\n+     * Gets a named fecth group. If not available in this receiver then looks\n+     * up the inheritence hierarchy. \n+     *\n+     * @param name name of a fetch group.\n+     * @return an existing fecth group of the given name if known to this \n+     * receiver or any of its superclasses. Otherwise null.\n+     */\n+    public FetchGroup getFetchGroup(String name) {\n+        FetchGroup fg = (_fgMap == null) ? null : (FetchGroup) _fgMap.get(name);\n+        if (fg != null)\n+            return fg;\n+        ClassMetaData sup = getPCSuperclassMetaData();\n+        if (sup != null)\n+            return sup.getFetchGroup(name);\n+        if (FetchGroup.NAME_DEFAULT.equals(name))\n+            return FetchGroup.DEFAULT;\n+        if (FetchGroup.NAME_ALL.equals(name))\n+            return FetchGroup.ALL;\n+        return null;\n+    }\n+\n+    /**\n+     * Adds fetch group of the given name, or returns existing instance.\n+     *\n+     * @param name a non-null, non-empty name. Must be unique within this\n+     * receiver's scope. The super class <em>may</em> have a group with\n+     * the same name.\n+     */\n+    public FetchGroup addDeclaredFetchGroup(String name) {\n+    \tif (StringUtils.isEmpty(name))\n+    \t\tthrow new MetaDataException(_loc.get(\"empty-fg-name\", this));\n+        if (_fgMap == null)\n+            _fgMap = new HashMap();\n+        FetchGroup fg = (FetchGroup) _fgMap.get(name);\n+        if (fg == null) {\n+        \tfg = new FetchGroup(this, name);\n+        \t_fgMap.put(name, fg);\n+            _fgs = null;\n+            _customFGs = null;\n+        }\n+        return fg;\n+    }\n+\n+    /**\n+     * Remove a declared fetch group.\n+     */\n+    public boolean removeDeclaredFetchGroup(FetchGroup fg) {\n+        if (fg == null)\n+            return false;\n+        if (_fgMap.remove(fg.getName()) != null) {\n+            _fgs = null;\n+            _customFGs = null;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /////////////////\n+    // SourceTracker\n+    /////////////////\n+\n+    public File getSourceFile() {\n+        return _srcFile;\n+    }\n+\n+    public Object getSourceScope() {\n+        return null;\n+    }\n+\n+    public int getSourceType() {\n+        return _srcType;\n+    }\n+\n+    public void setSource(File file, int srcType) {\n+        _srcFile = file;\n+        _srcType = srcType;\n+    }\n+\n+    public String getResourceName() {\n+        return _type.getName();\n+    }\n+    \n+    public int getLineNumber() {\n+        return _lineNum;\n+    }\n+\n+    public void setLineNumber(int lineNum) {\n+        _lineNum = lineNum;\n+    }\n+\n+    public int getColNumber() {\n+        return _colNum;\n+    }\n+\n+    public void setColNumber(int colNum) {\n+        _colNum = colNum;\n+    }\n+\n+    /**\n+     * The source mode this metadata has been loaded under.\n+     */\n+    public int getSourceMode() {\n+        return _srcMode;\n+    }\n+\n+    /**\n+     * The source mode this metadata has been loaded under.\n+     */\n+    public void setSourceMode(int mode) {\n+        _srcMode = mode;\n+    }\n+\n+    /**\n+     * The source mode this metadata has been loaded under.\n+     */\n+    public void setSourceMode(int mode, boolean on) {\n+        if (mode == MODE_NONE)\n+            _srcMode = mode;\n+        else if (on)\n+            _srcMode |= mode;\n+        else\n+            _srcMode &= ~mode;\n+    }\n+\n+    /**\n+     * The index in which this class was listed in the metadata. Defaults to\n+     * <code>-1</code> if this class was not listed in the metadata.\n+     */\n+    public int getListingIndex() {\n+        return _listIndex;\n+    }\n+\n+    /**\n+     * The index in which this field was listed in the metadata. Defaults to\n+     * <code>-1</code> if this class was not listed in the metadata.\n+     */\n+    public void setListingIndex(int index) {\n+        _listIndex = index;\n+    }\n+\n+    ///////////////\n+    // Commentable\n+    ///////////////\n+\n+    public String[] getComments() {\n+        return (_comments == null) ? EMPTY_COMMENTS : _comments;\n+    }\n+\n+    public void setComments(String[] comments) {\n+        _comments = comments;\n+    }\n+\n+    //////////////\n+    // State copy\n+    //////////////\n+\n+    /**\n+     * Copy the metadata from the given instance to this one. Do not\n+     * copy mapping information.\n+     */\n+    public void copy(ClassMetaData meta) {\n+        if (meta.getDescribedType() != _type)\n+            throw new InternalException();\n+        super.copy(meta);\n+\n+        // copy class-level info; use get methods to force resolution of\n+        // lazy data\n+        _super = meta.getPCSuperclass();\n+        _objectId = meta.getObjectIdType();\n+        _extent = (meta.getRequiresExtent()) ? Boolean.TRUE : Boolean.FALSE;\n+        _embedded = (meta.isEmbeddedOnly()) ? Boolean.TRUE : Boolean.FALSE;\n+        _interface = (meta.isManagedInterface()) ? Boolean.TRUE : Boolean.FALSE;\n+        setIntercepting(meta.isIntercepting());\n+        _impl = meta.getInterfaceImpl();\n+        _identity = meta.getIdentityType();\n+        _idStrategy = meta.getIdentityStrategy();\n+        _seqName = meta.getIdentitySequenceName();\n+        _seqMeta = null;\n+        _alias = meta.getTypeAlias();\n+        _accessType = meta.getAccessType();\n+\n+        // only copy this information if it wasn't set explicitly for this\n+        // instance\n+        if (DEFAULT_STRING.equals(_cacheName))\n+            _cacheName = meta.getDataCacheName();\n+        if (_cacheTimeout == Integer.MIN_VALUE)\n+            _cacheTimeout = meta.getDataCacheTimeout();\n+        if (_detachable == null)\n+            _detachable = meta._detachable;\n+        if (DEFAULT_STRING.equals(_detachState))\n+            _detachState = meta.getDetachedState();\n+\n+        // synch field information; first remove extra fields\n+        clearFieldCache();\n+        _fieldMap.keySet().retainAll(meta._fieldMap.keySet());\n+\n+        // add copies of declared fields; other defined fields already copied\n+        FieldMetaData[] fields = meta.getDeclaredFields();\n+        FieldMetaData field;\n+        for (int i = 0; i < fields.length; i++) {\n+            field = getDeclaredField(fields[i].getName());\n+            if (field == null)\n+                field = addDeclaredField(fields[i].getName(),\n+                    fields[i].getDeclaredType());\n+            field.setDeclaredIndex(-1);\n+            field.setIndex(-1);\n+            field.copy(fields[i]);\n+        }\n+\n+        // copy fetch groups\n+        FetchGroup[] fgs = meta.getDeclaredFetchGroups();\n+        FetchGroup fg;\n+        for (int i = 0; i < fgs.length; i++) {\n+            fg = addDeclaredFetchGroup(fgs[i].getName());\n+            fg.copy(fgs[i]); \n+        }\n+\n+        // copy iface re-mapping\n+        _ifaceMap.clear();\n+        _ifaceMap.putAll(meta._ifaceMap);\n+    }\n+\n+    /**\n+     * Recursive helper to copy embedded metadata.\n+     */\n+    private static void copy(ClassMetaData embed, ClassMetaData dec) {\n+        ClassMetaData sup = dec.getPCSuperclassMetaData();\n+        if (sup != null) {\n+            embed.setPCSuperclass(sup.getDescribedType());\n+            copy(embed.getPCSuperclassMetaData(), sup);\n+        }\n+        embed.copy(dec);\n+    }\n+\n+    protected void addExtensionKeys(Collection exts) {\n+        _repos.getMetaDataFactory().addClassExtensionKeys(exts);\n+    }\n+\n+    /**\n+     * Comparator used to put field metadatas into listing order.\n+     */\n+    private static class ListingOrderComparator\n+        implements Comparator {\n+\n+        private static final ListingOrderComparator _instance\n+            = new ListingOrderComparator();\n+\n+        /**\n+         * Access singleton instance.\n+         */\n+        public static ListingOrderComparator getInstance() {\n+            return _instance;\n+        }\n+\n+        public int compare(Object o1, Object o2) {\n+            if (o1 == o2)\n+                return 0;\n+            if (o1 == null)\n+                return 1;\n+            if (o2 == null)\n+                return -1;\n+\n+            FieldMetaData f1 = (FieldMetaData) o1;\n+            FieldMetaData f2 = (FieldMetaData) o2;\n+            if (f1.getListingIndex() == f2.getListingIndex()) {\n+                if (f1.getIndex() == f2.getIndex())\n+                    return f1.getFullName(false).compareTo\n+                        (f2.getFullName(false));\n+\t\t\t\tif (f1.getIndex () == -1)\n+\t\t\t\t\treturn 1;\n+\t\t\t\tif (f2.getIndex () == -1)\n+\t\t\t\t\treturn -1;\n+\t\t\t\treturn f1.getIndex () - f2.getIndex ();\n+\t\t\t}\t\n+\t\t\tif (f1.getListingIndex () == -1)\n+\t\t\t\treturn 1;\n+\t\t\tif (f2.getListingIndex () == -1)\n+\t\t\t\treturn -1;\n+\t\t\treturn f1.getListingIndex () - f2.getListingIndex ();\n+\t\t}\n+\t}\n+    \n+    public void registerForValueUpdate(String...values) {\n+    \tif (values == null)\n+    \t\treturn;\n+    \tfor (String key : values) {\n+    \t\tValue value = getRepository().getConfiguration()\n+    \t\t\t.getValue(key);\n+    \t\tif (value != null)\n+    \t\t\tvalue.addListener(this);\n+    \t}\n+    }\n+    \n+    public void valueChanged(Value val) {\n+    \tif (val ==  null)\n+    \t\treturn;\n+    \tString key = val.getProperty();\n+    \tif (\"DataCacheTimeout\".equals(key)) {\n+    \t\t_cacheTimeout = Integer.MIN_VALUE;\n+    \t}\n+    }\n+}"},{"sha":"308d022b9f12678cd57b5fda4911edff538b5eb3","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/DelegatingMetaDataFactory.java","status":"added","additions":129,"deletions":0,"changes":129,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/DelegatingMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/DelegatingMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/DelegatingMetaDataFactory.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.File;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.openjpa.lib.meta.ClassArgParser;\n+\n+/**\n+ * Base class for factory instances that use a delegate.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class DelegatingMetaDataFactory\n+    implements MetaDataFactory {\n+\n+    private final MetaDataFactory _delegate;\n+\n+    /**\n+     * Constructor; supply delegate.\n+     */\n+    public DelegatingMetaDataFactory(MetaDataFactory delegate) {\n+        _delegate = delegate;\n+    }\n+\n+    /**\n+     * Factory delegate.\n+     */\n+    public MetaDataFactory getDelegate() {\n+        return _delegate;\n+    }\n+\n+    /**\n+     * Innermost delegate.\n+     */\n+    public MetaDataFactory getInnermostDelegate() {\n+        if (_delegate instanceof DelegatingMetaDataFactory)\n+            return ((DelegatingMetaDataFactory) _delegate).\n+                getInnermostDelegate();\n+        return _delegate;\n+    }\n+\n+    public void setRepository(MetaDataRepository repos) {\n+        _delegate.setRepository(repos);\n+    }\n+\n+    public void setStoreDirectory(File dir) {\n+        _delegate.setStoreDirectory(dir);\n+    }\n+\n+    public void setStoreMode(int store) {\n+        _delegate.setStoreMode(store);\n+    }\n+\n+    public void setStrict(boolean strict) {\n+        _delegate.setStrict(true);\n+    }\n+\n+    public void load(Class cls, int mode, ClassLoader envLoader) {\n+        _delegate.load(cls, mode, envLoader);\n+    }\n+\n+    public boolean store(ClassMetaData[] metas, QueryMetaData[] queries,\n+        SequenceMetaData[] seqs, int mode, Map output) {\n+        return _delegate.store(metas, queries, seqs, mode, output);\n+    }\n+\n+    public boolean drop(Class[] cls, int mode, ClassLoader envLoader) {\n+        return _delegate.drop(cls, mode, envLoader);\n+    }\n+\n+    public MetaDataDefaults getDefaults() {\n+        return _delegate.getDefaults();\n+    }\n+\n+    public ClassArgParser newClassArgParser() {\n+        return _delegate.newClassArgParser();\n+    }\n+\n+    public Set getPersistentTypeNames(boolean classpath,\n+        ClassLoader envLoader) {\n+        return _delegate.getPersistentTypeNames(classpath, envLoader);\n+    }\n+\n+    public Class getQueryScope(String queryName, ClassLoader loader) {\n+        return _delegate.getQueryScope(queryName, loader);\n+    }\n+\n+    public Class getResultSetMappingScope(String resultSetMappingName,\n+        ClassLoader loader) {\n+        return _delegate.getResultSetMappingScope(resultSetMappingName, loader);\n+    }\n+\n+    public void clear() {\n+        _delegate.clear();\n+    }\n+\n+    public void addClassExtensionKeys(Collection exts) {\n+        _delegate.addClassExtensionKeys(exts);\n+    }\n+\n+    public void addFieldExtensionKeys(Collection exts) {\n+        _delegate.addFieldExtensionKeys(exts);\n+    }\n+\n+    public void loadXMLMetaData(FieldMetaData fmd) {\n+        _delegate.loadXMLMetaData(fmd);\n+    }\n+}"},{"sha":"c01fcfa0388b4f90e03afed39ba1ce8da0cd4a39","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/Extensions.java","status":"added","additions":466,"deletions":0,"changes":466,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/Extensions.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/Extensions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/Extensions.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,466 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.StringDistance;\n+import serp.util.Strings;\n+\n+/**\n+ * Vendor extensions. This class is thread safe for reads, but not for\n+ * mutations.\n+ *\n+ * @author Abe White\n+ */\n+public abstract class Extensions\n+    implements Serializable {\n+\n+    public static final String OPENJPA = \"openjpa\";\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (Extensions.class);\n+\n+    private Map _exts = null;\n+    private Map _embed = null;\n+\n+    /**\n+     * Return true if there are no keys for any vendor.\n+     */\n+    public boolean isEmpty() {\n+        return (_exts == null || _exts.isEmpty())\n+            && (_embed == null || _embed.isEmpty());\n+    }\n+\n+    /**\n+     * Return all vendors who have extension keys at this level.\n+     */\n+    public String[] getExtensionVendors() {\n+        if (_exts == null || _exts.isEmpty())\n+            return new String[0];\n+\n+        Set vendors = new TreeSet();\n+        for (Iterator itr = _exts.keySet().iterator(); itr.hasNext();)\n+            vendors.add(getVendor(itr.next()));\n+        return (String[]) vendors.toArray(new String[vendors.size()]);\n+    }\n+\n+    /**\n+     * Return all extension keys.\n+     */\n+    public String[] getExtensionKeys() {\n+        return getExtensionKeys(OPENJPA);\n+    }\n+\n+    /**\n+     * Return all extension keys for the given vendor.\n+     */\n+    public String[] getExtensionKeys(String vendor) {\n+        if (_exts == null || _exts.isEmpty())\n+            return new String[0];\n+\n+        Collection keys = new TreeSet();\n+        Object key;\n+        for (Iterator itr = _exts.keySet().iterator(); itr.hasNext();) {\n+            key = itr.next();\n+            if (vendor.equals(getVendor(key)))\n+                keys.add(getKey(key));\n+        }\n+        return (String[]) keys.toArray(new String[keys.size()]);\n+    }\n+\n+    /**\n+     * Return true if the extension with the given key exists.\n+     */\n+    public boolean hasExtension(String key) {\n+        return hasExtension(OPENJPA, key);\n+    }\n+\n+    /**\n+     * Return true if the extension with the given key exists.\n+     */\n+    public boolean hasExtension(String vendor, String key) {\n+        return _exts != null && _exts.containsKey(getHashKey(vendor, key));\n+    }\n+\n+    /**\n+     * Add a vendor extension to this entity.\n+     */\n+    public void addExtension(String key, Object value) {\n+        addExtension(OPENJPA, key, value);\n+    }\n+\n+    /**\n+     * Add a vendor extension to this entity.\n+     */\n+    public void addExtension(String vendor, String key, Object value) {\n+        if (_exts == null)\n+            _exts = new HashMap();\n+        _exts.put(getHashKey(vendor, key), value);\n+    }\n+\n+    /**\n+     * Remove a vendor extension.\n+     */\n+    public boolean removeExtension(String key) {\n+        return removeExtension(OPENJPA, key);\n+    }\n+\n+    /**\n+     * Remove a vendor extension.\n+     */\n+    public boolean removeExtension(String vendor, String key) {\n+        if (_exts != null && _exts.remove(getHashKey(vendor, key)) != null) {\n+            removeEmbeddedExtensions(key);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Get the value of an extension.\n+     */\n+    public Object getObjectExtension(String key) {\n+        return getObjectExtension(OPENJPA, key);\n+    }\n+\n+    /**\n+     * Get the value of an extension.\n+     */\n+    public Object getObjectExtension(String vendor, String key) {\n+        if (_exts == null)\n+            return null;\n+        return _exts.get(getHashKey(vendor, key));\n+    }\n+\n+    /**\n+     * Get the value as a string.\n+     */\n+    public String getStringExtension(String key) {\n+        return getStringExtension(OPENJPA, key);\n+    }\n+\n+    /**\n+     * Get the value as a string.\n+     */\n+    public String getStringExtension(String vendor, String key) {\n+        Object val = getObjectExtension(vendor, key);\n+        return (val == null) ? null : val.toString();\n+    }\n+\n+    /**\n+     * Get the value as an int.\n+     */\n+    public int getIntExtension(String key) {\n+        return getIntExtension(OPENJPA, key);\n+    }\n+\n+    /**\n+     * Get the value as an int.\n+     */\n+    public int getIntExtension(String vendor, String key) {\n+        String str = getStringExtension(vendor, key);\n+        return (str == null) ? 0 : Integer.parseInt(str);\n+    }\n+\n+    /**\n+     * Get the value as a double.\n+     */\n+    public double getDoubleExtension(String key) {\n+        return getDoubleExtension(OPENJPA, key);\n+    }\n+\n+    /**\n+     * Get the value as a double.\n+     */\n+    public double getDoubleExtension(String vendor, String key) {\n+        String str = getStringExtension(vendor, key);\n+        return (str == null) ? 0D : Double.parseDouble(str);\n+    }\n+\n+    /**\n+     * Get the value as a boolean.\n+     */\n+    public boolean getBooleanExtension(String key) {\n+        return getBooleanExtension(OPENJPA, key);\n+    }\n+\n+    /**\n+     * Get the value as a boolean.\n+     */\n+    public boolean getBooleanExtension(String vendor, String key) {\n+        String str = getStringExtension(vendor, key);\n+        return (str == null) ? false : Boolean.valueOf(str).booleanValue();\n+    }\n+\n+    /**\n+     * Return the embedded extensions under the given key.\n+     */\n+    public Extensions getEmbeddedExtensions(String key, boolean create) {\n+        return getEmbeddedExtensions(OPENJPA, key, create);\n+    }\n+\n+    /**\n+     * Return the embedded extensions under the given key.\n+     */\n+    public Extensions getEmbeddedExtensions(String vendor, String key,\n+        boolean create) {\n+        if (_embed == null && !create)\n+            return null;\n+        if (_embed == null)\n+            _embed = new HashMap();\n+\n+        Object hk = getHashKey(vendor, key);\n+        Extensions exts = (Extensions) _embed.get(hk);\n+        if (exts == null && !create)\n+            return null;\n+        if (exts == null) {\n+            exts = new EmbeddedExtensions(this);\n+            _embed.put(hk, exts);\n+\n+            // required to recognize embedded extensions without values\n+            if (_exts == null)\n+                _exts = new HashMap();\n+            if (!_exts.containsKey(hk))\n+                _exts.put(hk, null);\n+        }\n+        return exts;\n+    }\n+\n+    public boolean removeEmbeddedExtensions(String key) {\n+        return removeEmbeddedExtensions(OPENJPA, key);\n+    }\n+\n+    public boolean removeEmbeddedExtensions(String vendor, String key) {\n+        return _embed != null\n+            && _embed.remove(getHashKey(vendor, key)) != null;\n+    }\n+\n+    /**\n+     * Copy the extensions not present in this instance but present in the\n+     * given instance.\n+     */\n+    protected void copy(Extensions exts) {\n+        if (exts.isEmpty())\n+            return;\n+\n+        if (exts._exts != null && !exts._exts.isEmpty()) {\n+            if (_exts == null)\n+                _exts = new HashMap();\n+\n+            Map.Entry entry;\n+            for (Iterator itr = exts._exts.entrySet().iterator();\n+                itr.hasNext();) {\n+                entry = (Map.Entry) itr.next();\n+                if (!_exts.containsKey(entry.getKey()))\n+                    _exts.put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+\n+        if (exts._embed != null && !exts._embed.isEmpty()) {\n+            if (_embed == null)\n+                _embed = new HashMap();\n+\n+            Map.Entry entry;\n+            Extensions embedded;\n+            for (Iterator itr = exts._embed.entrySet().iterator();\n+                itr.hasNext();) {\n+                entry = (Map.Entry) itr.next();\n+                embedded = (Extensions) _embed.get(entry.getKey());\n+                if (embedded == null) {\n+                    embedded = new EmbeddedExtensions(this);\n+                    _embed.put(entry.getKey(), embedded);\n+                }\n+                embedded.copy((Extensions) entry.getValue());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Helper method to issue warnings for any extensions that we\n+     * recognize but do not use.\n+     *\n+     * @since 0.3.1.3\n+     */\n+    public void validateExtensionKeys() {\n+        if (_exts == null || _exts.isEmpty())\n+            return;\n+\n+        OpenJPAConfiguration conf = getRepository().getConfiguration();\n+        Log log = conf.getLog(conf.LOG_METADATA);\n+        if (!log.isWarnEnabled())\n+            return;\n+\n+        Collection validNames = new TreeSet();\n+        addExtensionKeys(validNames);\n+\n+        // this is where we store things like \"jdbc-\" for a\n+        // prefix for an extension name that we won't validate; that\n+        // way a new vendor could theoretically add in their\n+        // own prefix into the localizer.properties file and\n+        // not have to issue warnings for their extensions\n+        String prefixes = _loc.get(\"extension-datastore-prefix\").getMessage();\n+        String[] allowedPrefixes = null;\n+        if (prefixes != null)\n+            allowedPrefixes = Strings.split(prefixes, \",\", 0);\n+\n+        Object next;\n+        String key;\n+        outer:\n+        for (Iterator itr = _exts.keySet().iterator(); itr.hasNext();) {\n+            next = itr.next();\n+            if (!OPENJPA.equals(getVendor(next)))\n+                continue;\n+            key = getKey(next);\n+            if (validNames.contains(key))\n+                continue;\n+\n+            if (allowedPrefixes != null) {\n+                for (int j = 0; j < allowedPrefixes.length; j++) {\n+                    if (key.startsWith(allowedPrefixes[j])\n+                        && !validateDataStoreExtensionPrefix\n+                        (allowedPrefixes[j]))\n+                        continue outer;\n+                }\n+            }\n+\n+            // try to determine if there are any other names that are\n+            // similiar to this one, so we can add in a hint\n+            String closestName = StringDistance.getClosestLevenshteinDistance\n+                (key, validNames, 0.5f);\n+\n+            if (closestName == null)\n+                log.warn(_loc.get(\"unrecognized-extension\", this,\n+                    key, validNames));\n+            else\n+                log.warn(_loc.get(\"unrecognized-extension-hint\",\n+                    new Object[]{ this, key, validNames, closestName }));\n+        }\n+    }\n+\n+    /**\n+     * Add all the known extension keys to the specified collection; any\n+     * implementation that utilized new extensions should override this\n+     * method to include both the known extensions of its superclass as well\n+     * as its own extension keys.\n+     *\n+     * @since 0.3.1.3\n+     */\n+    protected void addExtensionKeys(Collection exts) {\n+        // no extensions by default\n+    }\n+\n+    /**\n+     * Return true if extensions starting with the given official datastore\n+     * prefix should be validated for this runtime.\n+     */\n+    protected boolean validateDataStoreExtensionPrefix(String prefix) {\n+        return false;\n+    }\n+\n+    /**\n+     * Return the metadata repository.\n+     */\n+    public abstract MetaDataRepository getRepository();\n+\n+    /**\n+     * Create a hash key for the given vendor/key combo.\n+     */\n+    private Object getHashKey(String vendor, String key) {\n+        if (OPENJPA.equals(vendor))\n+            return key;\n+        return new HashKey(vendor, key);\n+    }\n+\n+    /**\n+     * Extract the vendor from the given hash key.\n+     */\n+    private String getVendor(Object hashKey) {\n+        return (hashKey instanceof String) ? OPENJPA :\n+            ((HashKey) hashKey).vendor;\n+    }\n+\n+    /**\n+     * Extract the key from the given hash key.\n+     */\n+    private String getKey(Object hashKey) {\n+        return (hashKey instanceof String) ? (String) hashKey\n+            : ((HashKey) hashKey).key;\n+    }\n+\n+    /**\n+     * Key class.\n+     */\n+    private static class HashKey \n+        implements Serializable {\n+\n+        public final String vendor;\n+        public final String key;\n+\n+        public HashKey(String vendor, String key) {\n+            this.vendor = vendor;\n+            this.key = key;\n+        }\n+\n+        public int hashCode() {\n+            int i = 0;\n+            if (vendor != null)\n+                i = vendor.hashCode();\n+            if (key != null)\n+                i += 17 * key.hashCode();\n+            return i;\n+        }\n+\n+        public boolean equals(Object other) {\n+            if (other == this)\n+                return true;\n+            HashKey hk = (HashKey) other;\n+            return StringUtils.equals(vendor, hk.vendor)\n+                && StringUtils.equals(key, hk.key);\n+        }\n+    }\n+\n+    /**\n+     * Embedded extensions implementation.\n+     */\n+    private static class EmbeddedExtensions\n+        extends Extensions {\n+\n+        private final Extensions _parent;\n+\n+        public EmbeddedExtensions(Extensions parent) {\n+            _parent = parent;\n+        }\n+\n+        public MetaDataRepository getRepository ()\n+\t\t{\n+\t\t\treturn _parent.getRepository ();\n+\t\t}\n+\t}\n+}"},{"sha":"5809becce288f6fffa100bda2834b7158ceec8a1","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","status":"added","additions":388,"deletions":0,"changes":388,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,388 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.meta;\r\n+\r\n+import java.io.Serializable;\r\n+import java.util.ArrayList;\r\n+import java.util.Collections;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+\r\n+import org.apache.commons.lang.StringUtils;\r\n+import org.apache.commons.lang.ObjectUtils;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.util.MetaDataException;\r\n+import serp.util.Numbers;\r\n+\r\n+/**\r\n+ * Captures fetch group metadata.\r\n+ */\r\n+public class FetchGroup \r\n+    implements Serializable {\r\n+\r\n+    /**\r\n+     * Name of the default fetch group.\r\n+     */\r\n+    public static final String NAME_DEFAULT = \"default\";\r\n+\r\n+    /**\r\n+     * Name of the \"all\" fetch group.\r\n+     */\r\n+    public static final String NAME_ALL = \"all\";\r\n+\r\n+    /**\r\n+     * Default field recursion depth.\r\n+     */\r\n+    public static final int RECURSION_DEPTH_DEFAULT = 1;\r\n+\r\n+    /**\r\n+     * Infinite depth.\r\n+     */\r\n+\tpublic static final int DEPTH_INFINITE = -1;\r\n+\r\n+    /**\r\n+     *  Standard default fetch group.\r\n+     */\r\n+    static final FetchGroup DEFAULT = new FetchGroup(NAME_DEFAULT, true);\r\n+\r\n+    /**\r\n+     *  Standard \"all\" fetch group.\r\n+     */\r\n+    static final FetchGroup ALL = new FetchGroup(NAME_ALL, false);\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (FetchGroup.class);\r\n+\r\n+    private final String _name;\r\n+    private final ClassMetaData _meta;\r\n+    private final boolean _readOnly;\r\n+    private List _includes;\r\n+    private Set  _containedBy;\r\n+    private Map _depths;\r\n+    private Boolean _postLoad;\r\n+\r\n+    /**\r\n+     * Constructor; supply immutable name.\r\n+     *\r\n+     * @param name must not by null or empty.\r\n+     */\r\n+    FetchGroup(ClassMetaData cm, String name) {\r\n+        _meta = cm;\r\n+        _name = name;\r\n+        _readOnly = false;\r\n+    }\r\n+\r\n+    /**\r\n+     * Internal constructor for builtin fetch groups.\r\n+     */\r\n+    private FetchGroup(String name, boolean postLoad) {\r\n+        _meta = null;\r\n+        _name = name;\r\n+        _postLoad = (postLoad) ? Boolean.TRUE : Boolean.FALSE;\r\n+        _readOnly = true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Copy state from the given fetch group.\r\n+     */\r\n+    void copy(FetchGroup fg) {\r\n+        if (fg._includes != null)\r\n+            for (Iterator itr = fg._includes.iterator(); itr.hasNext();)\r\n+                addDeclaredInclude((String) itr.next());\r\n+        if (fg._containedBy != null) \r\n+        \tthis._containedBy = new HashSet(fg._containedBy);\r\n+        \r\n+        if (fg._depths != null) {\r\n+            Map.Entry entry;\r\n+            for (Iterator itr = fg._depths.entrySet().iterator(); \r\n+                itr.hasNext();) {\r\n+                entry = (Map.Entry) itr.next();\r\n+                setRecursionDepth((FieldMetaData) entry.getKey(), ((Number) \r\n+                    entry.getValue()).intValue());\r\n+            }\r\n+        }\r\n+        if (fg._postLoad != null)\r\n+            _postLoad = fg._postLoad;\r\n+    }\r\n+\r\n+    /**\r\n+     * Fetch group name.\r\n+     */\r\n+    public String getName() {\r\n+        return _name;\r\n+    }\r\n+\r\n+    /**\r\n+     * Includes given fetch group within this receiver.\r\n+     */\r\n+    public void addDeclaredInclude(String fgName) {\r\n+        if (_readOnly)\r\n+            throw new UnsupportedOperationException();\r\n+        if (StringUtils.isEmpty(fgName))\r\n+            throw new MetaDataException(_loc.get(\"null-include-fg\", this));\r\n+        if (_includes == null)\r\n+            _includes = new ArrayList();\r\n+        if (!_includes.contains(fgName))\r\n+            _includes.add(fgName);\r\n+    }\r\n+\r\n+    /**\r\n+     * Affirms if given fetch group is included by this receiver.  Includes\r\n+     * superclass definition of fetch group and optionally other included \r\n+     * groups.\r\n+     *\r\n+     * @param recurse if true then recursively checks within the included\r\n+     * fecth groups\r\n+     */\r\n+    public boolean includes(String fgName, boolean recurse) {\r\n+        // check our includes\r\n+        if (_includes != null) {\r\n+            if (_includes.contains(fgName))\r\n+                return true;\r\n+            if (recurse && _meta!=null) {\r\n+                FetchGroup fg;\r\n+                for (Iterator i = _includes.iterator(); i.hasNext();) {\r\n+                    fg = _meta.getFetchGroup((String) i.next());\r\n+                    if (fg != null && fg.includes(fgName, true))\r\n+                        return true;\r\n+                }\r\n+            }\r\n+        }\r\n+        if (_meta != null) {\r\n+            // check superclass includes\r\n+            ClassMetaData sup = _meta.getPCSuperclassMetaData();\r\n+            if (sup != null) {\r\n+                FetchGroup supFG = sup.getFetchGroup(_name);\r\n+                if (supFG != null)\r\n+                    return supFG.includes(fgName, recurse);\r\n+            }\r\n+        }\r\n+        return false;\r\n+    }\r\n+    \r\n+    /**\r\n+     * Adds this receiver as one of the included fetch groups of the given\r\n+     * parent. \r\n+     * The parent fecth group will include this receiver as a side-effect of\r\n+     * this call.\r\n+     * \r\n+     * @see #includes(String, boolean)\r\n+     * @see #addDeclaredInclude(String) \r\n+     * \r\n+     * @return true if given parent is a new addition. false othrwise.\r\n+     * @since 1.1.0\r\n+     */\r\n+    public boolean addContainedBy(FetchGroup parent) {\r\n+    \tparent.addDeclaredInclude(this.getName());\r\n+    \tif (_containedBy==null)\r\n+    \t\t_containedBy = new HashSet();\r\n+    \treturn _containedBy.add(parent.getName());\r\n+    }\r\n+    \r\n+    /**\r\n+     * Gets the name of the fetch groups in which this receiver has been\r\n+     * included.\r\n+     * \r\n+     * @see #addContainedBy(FetchGroup)\r\n+     * @since 1.1.0\r\n+     */\r\n+    public Set getContainedBy() {\r\n+    \treturn (_containedBy == null) ? Collections.EMPTY_SET :\r\n+            Collections.unmodifiableSet(_containedBy);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the fetch group names declared included by this group.\r\n+     */\r\n+    public String[] getDeclaredIncludes() {\r\n+        // only used during serialization; no need to cache\r\n+        return (_includes == null) ? new String[0]\r\n+            : (String[]) _includes.toArray(new String[_includes.size()]);\r\n+    }\r\n+\r\n+    /**\r\n+     * Recursion depth for the given field.  This is the depth of relations of\r\n+     * the same class as this one we can fetch through the given field.\r\n+     */\r\n+    public void setRecursionDepth(FieldMetaData fm, int depth) {\r\n+        if (_readOnly)\r\n+            throw new UnsupportedOperationException();\r\n+        if (depth < -1)\r\n+            throw new MetaDataException(_loc.get(\"invalid-fg-depth\", _name, fm, \r\n+                Numbers.valueOf(depth)));\r\n+        if (_depths == null)\r\n+            _depths = new HashMap();\r\n+        _depths.put(fm, Numbers.valueOf(depth));\r\n+    }\r\n+\r\n+    /**\r\n+     * Recursion depth for the given field.  This is the depth of relations of\r\n+     * the same class as this one we can fetch through the given field.\r\n+     */\r\n+    public int getRecursionDepth(FieldMetaData fm) {\r\n+        Number depth = findRecursionDepth(fm);\r\n+        return (depth == null) ? RECURSION_DEPTH_DEFAULT : depth.intValue();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the recursion depth declared for the given field, or \r\n+     * 0 if none.\r\n+     */\r\n+    public int getDeclaredRecursionDepth(FieldMetaData fm) {\r\n+        Number depth = (_depths == null) ? null : (Number) _depths.get(fm);\r\n+        return (depth == null) ? 0 : depth.intValue();\r\n+    }\r\n+\r\n+    /**\r\n+     * Helper to find recursion depth recursively in our includes.\r\n+     */\r\n+    private Number findRecursionDepth(FieldMetaData fm) { \r\n+        Number depth = (_depths == null) ? null : (Number) _depths.get(fm);\r\n+        if (depth != null)\r\n+            return depth;\r\n+\r\n+        // check for superclass declaration of depth\r\n+        Number max = null;\r\n+        if (_meta != null && fm.getDeclaringMetaData() != _meta) {\r\n+            ClassMetaData sup = _meta.getPCSuperclassMetaData();\r\n+            if (sup != null) {\r\n+                FetchGroup supFG = sup.getFetchGroup(_name);\r\n+                if (supFG != null)\r\n+                    max = supFG.findRecursionDepth(fm);\r\n+            }\r\n+        }\r\n+        if (_includes == null)\r\n+            return max;\r\n+\r\n+        // find largest included depth\r\n+        FetchGroup fg;\r\n+        for (Iterator itr = _includes.iterator(); itr.hasNext();) {\r\n+            fg = _meta.getFetchGroup((String) itr.next());\r\n+            depth = (fg == null) ? null : fg.findRecursionDepth(fm);\r\n+            if (depth != null && (max == null \r\n+                || depth.intValue() > max.intValue()))\r\n+                max = depth;\r\n+        }\r\n+        return max;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the fields with declared recursion depths in this group.\r\n+     */\r\n+    public FieldMetaData[] getDeclaredRecursionDepthFields() {\r\n+        // used in serialization only; no need to cache\r\n+        if (_depths == null)\r\n+            return new FieldMetaData[0];\r\n+         return (FieldMetaData[]) _depths.keySet().toArray\r\n+            (new FieldMetaData[_depths.size()]);\r\n+    } \r\n+\r\n+    /**\r\n+     * Whether loading this fetch group causes a post-load callback on the\r\n+     * loaded instance.\r\n+     */\r\n+    public void setPostLoad (boolean flag) {\r\n+        if (_readOnly && flag != isPostLoad())\r\n+            throw new UnsupportedOperationException();\r\n+    \t_postLoad = (flag) ? Boolean.TRUE : Boolean.FALSE;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether loading this fetch group causes a post-load callback on the\r\n+     * loaded instance.\r\n+     */\r\n+    public boolean isPostLoad () {\r\n+    \tif (_postLoad != null)\r\n+            return _postLoad.booleanValue();\r\n+\r\n+        if (_meta != null) {\r\n+            ClassMetaData sup = _meta.getPCSuperclassMetaData();\r\n+            if (sup != null) {\r\n+                FetchGroup supFG = sup.getFetchGroup(_name);\r\n+                if (supFG != null && supFG.isPostLoad())\r\n+                    return true;\r\n+            }\r\n+        }\r\n+\r\n+        if (_includes == null)\r\n+            return false;\r\n+        FetchGroup fg;\r\n+        for (Iterator itr = _includes.iterator(); itr.hasNext();) {\r\n+            fg = _meta.getFetchGroup((String) itr.next());\r\n+            if (fg != null && fg.isPostLoad())\r\n+                return true;\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the post-load value is declared for this group.  \r\n+     */\r\n+    public boolean isPostLoadExplicit() {\r\n+        return _postLoad != null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Resolve and validate fetch group metadata.\r\n+     */\r\n+    public void resolve() {\r\n+        if (_includes == null)\r\n+            return;\r\n+\r\n+        // validate includes\r\n+        String name;\r\n+        FetchGroup fg;\r\n+        for (Iterator itr = _includes.iterator(); itr.hasNext();) {\r\n+            name = (String) itr.next();\r\n+            if (name.equals(_name))\r\n+                throw new MetaDataException(_loc.get(\"cyclic-fg\", this, name));\r\n+            fg = _meta.getFetchGroup(name);\r\n+            if (fg == null)\r\n+                throw new MetaDataException(_loc.get(\"bad-fg-include\", this,\r\n+                    name));\r\n+            if (fg.includes(_name, true))\r\n+                throw new MetaDataException(_loc.get(\"cyclic-fg\", this, name));\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Affirms equality if the other has the same name and declaring type.\r\n+     */\r\n+    public boolean equals(Object other) {\r\n+        if (other == this)\r\n+            return true;\r\n+        if (!(other instanceof FetchGroup))\r\n+            return false;\r\n+        FetchGroup that = (FetchGroup) other;\r\n+        return _name.equals(that._name)\r\n+            && ObjectUtils.equals(_meta, that._meta);\r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return _name.hashCode() + ((_meta == null) ? 0 : _meta.hashCode());\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        return ((_meta == null) ? \"Builtin\" : _meta.toString ()) + \".\" + _name;\r\n+    }\r\n+}\r"},{"sha":"467efdbfd952e18aa6e886f69f0ac7adb4814546","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","status":"added","additions":2121,"deletions":0,"changes":2121,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,2121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.Serializable;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TimeZone;\n+\n+import org.apache.commons.collections.comparators.ComparatorChain;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\n+import org.apache.openjpa.lib.util.JavaVersions;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Options;\n+import org.apache.openjpa.lib.xml.Commentable;\n+import org.apache.openjpa.util.Exceptions;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.MetaDataException;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.UnsupportedException;\n+import org.apache.openjpa.util.ImplHelper;\n+import org.apache.openjpa.util.UserException;\n+\n+import serp.util.Strings;\n+\n+/**\n+ * Metadata for a managed class field.\n+ *\n+ * @author Abe White\n+ */\n+public class FieldMetaData\n+    extends Extensions\n+    implements ValueMetaData, MetaDataContext, MetaDataModes, Commentable {\n+    \n+    /**\n+     * Constant specifying that no null-value was given.\n+     */\n+    public static final int NULL_UNSET = -1;\n+\n+    /**\n+     * Constant specifying to use a datastore null to persist null values\n+     * in object fields.\n+     */\n+    public static final int NULL_NONE = 0;\n+\n+    /**\n+     * Constant specifying to use a datastore default value to persist null\n+     * values in object fields.\n+     */\n+    public static final int NULL_DEFAULT = 1;\n+\n+    /**\n+     * Constant specifying to throw an exception when attempting to persist\n+     * null values in object fields.\n+     */\n+    public static final int NULL_EXCEPTION = 2;\n+\n+    /**\n+     * Constant specifying the management level of a field.\n+     */\n+    public static final int MANAGE_PERSISTENT = 3;\n+\n+    /**\n+     * Constant specifying the management level of a field.\n+     */\n+    public static final int MANAGE_TRANSACTIONAL = 1;\n+\n+    /**\n+     * Constant specifying the management level of a field.\n+     */\n+    public static final int MANAGE_NONE = 0;\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (FieldMetaData.class);\n+\n+    private static final int DFG_FALSE = 1;\n+    private static final int DFG_TRUE = 2;\n+    private static final int DFG_EXPLICIT = 4;\n+\n+    private static final Method DEFAULT_METHOD;\n+    static {\n+        try {\n+            DEFAULT_METHOD = Object.class.getMethod(\"wait\", (Class[]) null);\n+        } catch (Exception e) {\n+            // shouldn't ever happen\n+            throw new InternalException(e);\n+        }\n+    }\n+\n+    // name and type\n+    private final ValueMetaData _val;\n+    private final ValueMetaData _key;\n+    private final ValueMetaData _elem;\n+    private final ClassMetaData _owner;\n+    private final String _name;\n+    private Class _dec = null;\n+    private ClassMetaData _decMeta = null;\n+    private String _fullName = null;\n+    private String _embedFullName = null;\n+    private int _resMode = MODE_NONE;\n+\n+    // load/store info\n+    private String[] _comments = null;\n+    private int _listIndex = -1;\n+\n+    ////////////////////////////////////////////////////////////////////\n+    // Note: if you add additional state, make sure to add it to copy()\n+    ////////////////////////////////////////////////////////////////////\n+\n+    // misc info\n+    private Class _proxyClass = null;\n+    private Object _initializer = null;\n+    private boolean _transient = false;\n+    private boolean _primKey = false;\n+    private Boolean _version = null;\n+    private int _nullValue = NULL_UNSET;\n+    private int _manage = MANAGE_PERSISTENT;\n+    private int _index = -1;\n+    private int _decIndex = -1;\n+    private int _pkIndex = -1;\n+    private boolean _explicit = false;\n+    private int _dfg = 0;\n+    private Set _fgSet = null;\n+    private String[] _fgs = null;\n+    private String   _lfg = null;\n+    private Boolean _lrs = null;\n+    private Boolean _stream = null;\n+    private String _extName = null;\n+    private String _factName = null;\n+    private String _extString = null;\n+    private Map _extValues = Collections.EMPTY_MAP;\n+    private Map _fieldValues = Collections.EMPTY_MAP;\n+    private Boolean _enumField = null;\n+    private Boolean _lobField = null;\n+    private Boolean _serializableField = null;\n+    private boolean _generated = false;\n+\n+    // Members aren't serializable. Use a proxy that can provide a Member\n+    // to avoid writing the full Externalizable implementation.\n+    private MemberProvider _backingMember = null;\n+\n+    // Members aren't serializable. Initializing _extMethod and _factMethod to\n+    // DEFAULT_METHOD is sufficient to trigger lazy population of these fields.\n+    private transient Method _extMethod = DEFAULT_METHOD;\n+    private transient Member _factMethod = DEFAULT_METHOD;\n+\n+    // intermediate and impl data\n+    private boolean _intermediate = true;\n+    private Boolean _implData = Boolean.TRUE;\n+\n+    // value generation\n+    private int _valStrategy = -1;\n+    private int _upStrategy = -1;\n+    private String _seqName = ClassMetaData.DEFAULT_STRING;\n+    private SequenceMetaData _seqMeta = null;\n+\n+    // inverses\n+    private String _mappedBy = null;\n+    private FieldMetaData _mappedByMeta = null;\n+    private FieldMetaData[] _inverses = null;\n+    private String _inverse = ClassMetaData.DEFAULT_STRING;\n+\n+    // ordering on load\n+    private Order[] _orders = null;\n+    private String _orderDec = null;\n+    // indicate if this field is used by other field as \"order by\" value \n+    private boolean _usedInOrderBy = false;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param name the field name\n+     * @param type the field type\n+     * @param owner the owning class metadata\n+     */\n+    protected FieldMetaData(String name, Class type, ClassMetaData owner) {\n+        _name = name;\n+        _owner = owner;\n+        _dec = null;\n+        _decMeta = null;\n+        _val = owner.getRepository().newValueMetaData(this);\n+        _key = owner.getRepository().newValueMetaData(this);\n+        _elem = owner.getRepository().newValueMetaData(this);\n+\n+        setDeclaredType(type);\n+    }\n+\n+    /**\n+     * Supply the backing member object; this allows us to utilize\n+     * parameterized type information if available.\n+     */\n+    public void backingMember(Member member) {\n+        if (member == null)\n+            return;\n+        if (Modifier.isTransient(member.getModifiers()))\n+            _transient = true;\n+\n+        _backingMember = new MemberProvider(member);\n+\n+        Class type;\n+        Class[] types;\n+        if (member instanceof Field) {\n+            Field f = (Field) member;\n+            type = f.getType();\n+            types = JavaVersions.getParameterizedTypes(f);\n+        } else {\n+            Method meth = (Method) member;\n+            type = meth.getReturnType();\n+            types = JavaVersions.getParameterizedTypes(meth);\n+        }\n+\n+        setDeclaredType(type);\n+        if (Collection.class.isAssignableFrom(type)\n+            && _elem.getDeclaredType() == Object.class\n+            && types.length == 1) {\n+            _elem.setDeclaredType(types[0]);\n+        } else if (Map.class.isAssignableFrom(type)\n+            && types.length == 2) {\n+            if (_key.getDeclaredType() == Object.class)\n+                _key.setDeclaredType(types[0]);\n+            if (_elem.getDeclaredType() == Object.class)\n+                _elem.setDeclaredType(types[1]);\n+        }\n+    }\n+\n+    /**\n+     * Return the backing member supplied in {@link #backingMember}.\n+     */\n+    public Member getBackingMember() {\n+        return (_backingMember == null) ? null : _backingMember.getMember();\n+    }\n+\n+    /**\n+     * The metadata repository.\n+     */\n+    public MetaDataRepository getRepository() {\n+        return _owner.getRepository();\n+    }\n+\n+    /**\n+     * The class that defines the metadata for this field.\n+     */\n+    public ClassMetaData getDefiningMetaData() {\n+        return _owner;\n+    }\n+\n+    /**\n+     * The declaring class.\n+     */\n+    public Class getDeclaringType() {\n+        return (_dec == null) ? _owner.getDescribedType() : _dec;\n+    }\n+\n+    /**\n+     * The declaring class.\n+     */\n+    public void setDeclaringType(Class cls) {\n+        _dec = cls;\n+        _decMeta = null;\n+        _fullName = null;\n+        _embedFullName = null;\n+    }\n+\n+    /**\n+     * The declaring class.\n+     */\n+    public ClassMetaData getDeclaringMetaData() {\n+        if (_dec == null)\n+            return _owner;\n+        if (_decMeta == null)\n+            _decMeta = getRepository().getMetaData(_dec,\n+                _owner.getEnvClassLoader(), true);\n+        return _decMeta;\n+    }\n+\n+    /**\n+     * The field name.\n+     */\n+    public String getName() {\n+        return _name;\n+    }\n+\n+    /**\n+     * The field name, qualified by the owning class.\n+     * @deprecated Use getFullName(boolean) instead.\n+     */\n+    public String getFullName() {\n+        return getFullName(false);\n+    }\n+\n+    /**\n+     * The field name, qualified by the owning class and optionally the\n+     * embedding owner's name (if any).\n+     */\n+    public String getFullName(boolean embedOwner) {\n+        if (_fullName == null)\n+            _fullName = getDeclaringType().getName() + \".\" + _name;\n+        if (embedOwner && _embedFullName == null) {\n+            if (_owner.getEmbeddingMetaData() == null)\n+                _embedFullName = _fullName;\n+            else\n+                _embedFullName = _owner.getEmbeddingMetaData().\n+                    getFieldMetaData().getFullName(true) + \".\" + _fullName;\n+        }\n+        return (embedOwner) ? _embedFullName : _fullName;\n+    }\n+\n+    /**\n+     * MetaData about the field value.\n+     */\n+    public ValueMetaData getValue() {\n+        return _val;\n+    }\n+\n+    /**\n+     * Metadata about the key value.\n+     */\n+    public ValueMetaData getKey() {\n+        return _key;\n+    }\n+\n+    /**\n+     * Metadata about the element value.\n+     */\n+    public ValueMetaData getElement() {\n+        return _elem;\n+    }\n+\n+    /**\n+     * Return whether this field is mapped to the datastore. By default,\n+     * returns true for all persistent fields whose defining class is mapped.\n+     */\n+    public boolean isMapped() {\n+        return _manage == MANAGE_PERSISTENT && _owner.isMapped();\n+    }\n+\n+    /**\n+     * The type this field was initialized with, and therefore the\n+     * type to use for proxies when loading data into this field.\n+     */\n+    public Class getProxyType() {\n+        return (_proxyClass == null) ? getDeclaredType() : _proxyClass;\n+    }\n+\n+    /**\n+     * The type this field was initialized with, and therefore the\n+     * type to use for proxies when loading data into this field.\n+     */\n+    public void setProxyType(Class type) {\n+        _proxyClass = type;\n+    }\n+\n+    /**\n+     * The initializer used by the field, or null if none. This\n+     * is additional information for initializing the field, such as\n+     * a custom {@link Comparator} used by a {@link Set} or\n+     * a {@link TimeZone} used by a {@link Calendar}.\n+     */\n+    public Object getInitializer() {\n+        return _initializer;\n+    }\n+\n+    /**\n+     * The initializer used by the field, or null if none. This\n+     * is additional information for initializing the field, such as\n+     * a custom {@link Comparator} used by a {@link Set} or\n+     * a {@link TimeZone} used by a {@link Calendar}.\n+     */\n+    public void setInitializer(Object initializer) {\n+        _initializer = initializer;\n+    }\n+\n+    /**\n+     * Return whether this is a transient field.\n+     */\n+    public boolean isTransient() {\n+        return _transient;\n+    }\n+\n+    /**\n+     * Return whether this is a transient field.\n+     */\n+    public void setTransient(boolean trans) {\n+        _transient = trans;\n+    }\n+\n+    /**\n+     * The absolute index of this persistent/transactional field.\n+     */\n+    public int getIndex() {\n+        return _index;\n+    }\n+\n+    /**\n+     * The absolute index of this persistent/transactional field.\n+     */\n+    public void setIndex(int index) {\n+        _index = index;\n+    }\n+\n+    /**\n+     * The relative index of this persistent/transactional field.\n+     */\n+    public int getDeclaredIndex() {\n+        return _decIndex;\n+    }\n+\n+    /**\n+     * The relative index of this persistent/transactional field.\n+     */\n+    public void setDeclaredIndex(int index) {\n+        _decIndex = index;\n+    }\n+\n+    /**\n+     * The index in which this field was listed in the metadata. Defaults to\n+     * <code>-1</code> if this field was not listed in the metadata.\n+     */\n+    public int getListingIndex() {\n+        return _listIndex;\n+    }\n+\n+    /**\n+     * The index in which this field was listed in the metadata. Defaults to\n+     * <code>-1</code> if this field was not listed in the metadata.\n+     */\n+    public void setListingIndex(int index) {\n+        _listIndex = index;\n+    }\n+\n+    /**\n+     * The absolute primary key index for this field, or -1 if not a primary\n+     * key. The first primary key field has index 0, the second index 1, etc.\n+     */\n+    public int getPrimaryKeyIndex() {\n+        return _pkIndex;\n+    }\n+\n+    /**\n+     * The absolute primary key index for this field, or -1 if not a primary\n+     * key. The first primary key field has index 0, the second index 1, etc.\n+     */\n+    public void setPrimaryKeyIndex(int index) {\n+        _pkIndex = index;\n+    }\n+\n+    /**\n+     * Return the management level for the field. Will be one of:\n+     * <ul>\n+     * <li>{@link #MANAGE_PERSISTENT}: the field is persistent</li>\n+     * <li>{@link #MANAGE_TRANSACTIONAL}: the field is transactional but not\n+     * persistent</li>\n+     * <li>{@link #MANAGE_NONE}: the field is not managed</li>\n+     * </ul> Defaults to {@link #MANAGE_PERSISTENT}.\n+     */\n+    public int getManagement() {\n+        return _manage;\n+    }\n+\n+    /**\n+     * Return the management level for the field. Will be one of:\n+     * <ul>\n+     * <li>{@link #MANAGE_PERSISTENT}: the field is persistent</li>\n+     * <li>{@link #MANAGE_TRANSACTIONAL}: the field is transactional but not\n+     * persistent</li>\n+     * <li>{@link #MANAGE_NONE}: the field is not managed</li>\n+     * </ul> \n+     * Defaults to {@link #MANAGE_PERSISTENT}.\n+     */\n+    public void setManagement(int manage) {\n+        if ((_manage == MANAGE_NONE) != (manage == MANAGE_NONE))\n+            _owner.clearFieldCache();\n+        _manage = manage;\n+    }\n+\n+    /**\n+     * Whether this is a primary key field.\n+     */\n+    public boolean isPrimaryKey() {\n+        return _primKey;\n+    }\n+\n+    /**\n+     * Whether this is a primary key field.\n+     */\n+    public void setPrimaryKey(boolean primKey) {\n+        _primKey = primKey;\n+    }\n+\n+    /**\n+     * For a primary key field, return the type of the corresponding object id \n+     * class field.\n+     */\n+    public int getObjectIdFieldTypeCode() {\n+        ClassMetaData relmeta = getDeclaredTypeMetaData();\n+        if (relmeta == null)\n+            return getDeclaredTypeCode();\n+        if (relmeta.getIdentityType() == ClassMetaData.ID_DATASTORE) {\n+            boolean unwrap = getRepository().getMetaDataFactory().getDefaults().\n+                isDataStoreObjectIdFieldUnwrapped();\n+            return (unwrap) ? JavaTypes.LONG : JavaTypes.OBJECT;\n+        }\n+        if (relmeta.isOpenJPAIdentity())\n+            return relmeta.getPrimaryKeyFields()[0].getObjectIdFieldTypeCode();\n+        return JavaTypes.OBJECT;\n+    }\n+\n+    /**\n+     * For a primary key field, return the type of the corresponding object id \n+     * class field.\n+     */\n+    public Class getObjectIdFieldType() {\n+        ClassMetaData relmeta = getDeclaredTypeMetaData();\n+        if (relmeta == null)\n+            return getDeclaredType();\n+        switch (relmeta.getIdentityType()) {\n+            case ClassMetaData.ID_DATASTORE:\n+                boolean unwrap = getRepository().getMetaDataFactory().\n+                    getDefaults().isDataStoreObjectIdFieldUnwrapped();\n+                return (unwrap) ? long.class : Object.class;\n+            case ClassMetaData.ID_APPLICATION:\n+                if (relmeta.isOpenJPAIdentity())\n+                    return relmeta.getPrimaryKeyFields()[0].\n+                        getObjectIdFieldType();\n+                return (relmeta.getObjectIdType() == null) ? Object.class\n+                    : relmeta.getObjectIdType();\n+            default:\n+                return Object.class;\n+        } \n+    }\n+\n+    /**\n+     * Whether this field holds optimistic version information.\n+     */\n+    public boolean isVersion() {\n+        return _version == Boolean.TRUE;\n+    }\n+\n+    /**\n+     * Whether this field holds optimistic version information.\n+     */\n+    public void setVersion(boolean version) {\n+        _version = (version) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Whether this field is in the default fetch group.\n+     */\n+    public boolean isInDefaultFetchGroup() {\n+        if (_dfg == 0) {\n+            if (_manage != MANAGE_PERSISTENT || isPrimaryKey() || isVersion())\n+                _dfg = DFG_FALSE;\n+            else {\n+                // field left as default; dfg setting depends on type\n+                switch (getTypeCode()) {\n+                    case JavaTypes.OBJECT:\n+                        if (isSerializable() || isEnum())\n+                            _dfg = DFG_TRUE;\n+                        else\n+                            _dfg = DFG_FALSE;\n+                        break;\n+                    case JavaTypes.ARRAY:\n+                        if (isLobArray())\n+                            _dfg = DFG_TRUE;\n+                        else\n+                            _dfg = DFG_FALSE;\n+                        break;\n+                    case JavaTypes.COLLECTION:\n+                    case JavaTypes.MAP:\n+                    case JavaTypes.PC:\n+                    case JavaTypes.PC_UNTYPED:\n+                        _dfg = DFG_FALSE;\n+                        break;\n+                    default:\n+                        _dfg = DFG_TRUE;\n+                }\n+            }\n+        }\n+        return (_dfg & DFG_TRUE) > 0;\n+    }\n+\n+    private boolean isEnum() {\n+        if (_enumField == null) {\n+            Class dt = getDeclaredType();\n+            _enumField = JavaVersions.isEnumeration(dt)\n+                ? Boolean.TRUE : Boolean.FALSE;\n+        }\n+        return _enumField.booleanValue();\n+    }\n+\n+    private boolean isSerializable() {\n+        if (_serializableField == null) {\n+            Class dt = getDeclaredType();\n+            if (Serializable.class.isAssignableFrom(dt))\n+                _serializableField = Boolean.TRUE;\n+            else\n+                _serializableField = Boolean.FALSE;\n+        }\n+        return _serializableField.booleanValue();\n+    }\n+\n+    private boolean isLobArray() {\n+        // check for byte[], Byte[], char[], Character[]\n+        if (_lobField == null) {\n+            Class dt = getDeclaredType();\n+            if (dt == byte[].class || dt == Byte[].class ||\n+                dt == char[].class || dt == Character[].class)\n+                _lobField = Boolean.TRUE;\n+            else\n+                _lobField = Boolean.FALSE;\n+        }\n+        return _lobField.booleanValue();\n+    }\n+\n+    /**\n+     * Whether this field is in the default fetch group.\n+     */\n+    public void setInDefaultFetchGroup(boolean dfg) {\n+        if (dfg)\n+            _dfg = DFG_TRUE;\n+        else\n+            _dfg = DFG_FALSE;\n+        _dfg |= DFG_EXPLICIT;\n+    }\n+\n+    /**\n+     * Whether the default fetch group setting is explicit.\n+     */\n+    public boolean isDefaultFetchGroupExplicit() {\n+        return (_dfg & DFG_EXPLICIT) > 0;\n+    }\n+\n+    /**\n+     * Whether the default fetch group setting is explicit. Allow setting\n+     * for testing.\n+     */\n+    public void setDefaultFetchGroupExplicit(boolean explicit) {\n+        if (explicit)\n+            _dfg |= DFG_EXPLICIT;\n+        else\n+            _dfg &= ~DFG_EXPLICIT;\n+    }\n+\n+    /**\n+     * Gets the name of the custom fetch groups those are associated to this \n+     * receiver.  This does not include the \"default\" and \"all\" fetch groups.\n+     *\n+     * @return the set of fetch group names, not including the default and\n+     * all fetch groups.\n+     */\n+    public String[] getCustomFetchGroups() {\n+        if (_fgs == null) {\n+            if (_fgSet == null || _manage != MANAGE_PERSISTENT \n+                || isPrimaryKey() || isVersion())\n+                _fgs = new String[0];\n+            else\n+                _fgs = (String[]) _fgSet.toArray(new String[_fgSet.size()]);\n+        }\n+        return _fgs;\n+    }\n+\n+    /**\n+     * The fetch group that is to be loaded when this receiver is loaded, or\n+     * null if none set.\n+     */\n+    public String getLoadFetchGroup () {\n+    \treturn _lfg;\n+    }\n+    \n+    /**\n+     * The fetch group that is to be loaded when this receiver is loaded, or\n+     * null if none set.\n+     */\n+    public void setLoadFetchGroup (String lfg) {\n+        if (\"\".equals(lfg))\n+            lfg = null;\n+    \t_lfg = lfg;\n+    }\n+\n+    /**\n+     * Whether this field is in the given fetch group.\n+     */\n+    public boolean isInFetchGroup(String fg) {\n+        if (_manage != MANAGE_PERSISTENT || isPrimaryKey() || isVersion())\n+            return false;\n+        if (FetchGroup.NAME_ALL.equals(fg))\n+            return true;\n+        if (FetchGroup.NAME_DEFAULT.equals(fg))\n+            return isInDefaultFetchGroup();\n+        return _fgSet != null && _fgSet.contains(fg);\n+    }\n+\n+    /**\n+     * Set whether this field is in the given fetch group.\n+     *\n+     * @param fg is the name of a fetch group that must be present in the\n+     * class that declared this field or any of its persistent superclasses.\n+     */\n+    public void setInFetchGroup(String fg, boolean in) {\n+        if (StringUtils.isEmpty(fg))\n+            throw new MetaDataException(_loc.get(\"empty-fg-name\", this));\n+        if (fg.equals(FetchGroup.NAME_ALL))\n+            return;\n+        if (fg.equals(FetchGroup.NAME_DEFAULT)) {\n+            setInDefaultFetchGroup(in);\n+            return;\n+        }\n+        if (_owner.getFetchGroup(fg) == null)\n+            throw new MetaDataException(_loc.get(\"unknown-fg\", fg, this));\n+        if (in && _fgSet == null)\n+            _fgSet = new HashSet();\n+        if ((in && _fgSet.add(fg))\n+            || (!in && _fgSet != null && _fgSet.remove(fg)))\n+            _fgs = null;\n+    }\n+    \n+    /**\n+     * How the data store should treat null values for this field:\n+     * <ul>\n+     * <li>{@link #NULL_UNSET}: no value supplied</li>\n+     * <li>{@link #NULL_NONE}: leave null values as null in the data store</li>\n+     * <li>{@link #NULL_EXCEPTION}: throw an exception if this field is null\n+     * at commit</li>\n+     * <li>{@link #NULL_DEFAULT}: use the database default if this field is\n+     * null at commit</li>\n+     * </ul> Defaults to {@link #NULL_UNSET}.\n+     */\n+    public int getNullValue() {\n+        return _nullValue;\n+    }\n+\n+    /**\n+     * How the data store should treat null values for this field:\n+     * <ul>\n+     * <li>{@link #NULL_UNSET}: no value supplied</li>\n+     * <li>{@link #NULL_NONE}: leave null values as null in the data store</li>\n+     * <li>{@link #NULL_EXCEPTION}: throw an exception if this field is null\n+     * at commit</li>\n+     * <li>{@link #NULL_DEFAULT}: use the database default if this field is\n+     * null at commit</li>\n+     * </ul> Defaults to {@link #NULL_UNSET}.\n+     */\n+    public void setNullValue(int nullValue) {\n+        _nullValue = nullValue;\n+    }\n+\n+    /**\n+     * Whether this field is explicitly declared in the metadata.\n+     */\n+    public boolean isExplicit() {\n+        return _explicit;\n+    }\n+\n+    /**\n+     * Whether this field is explicitly declared in the metadata.\n+     */\n+    public void setExplicit(boolean explicit) {\n+        _explicit = explicit;\n+    }\n+\n+    /**\n+     * The field that this field shares a mapping with.\n+     */\n+    public String getMappedBy() {\n+        return _mappedBy;\n+    }\n+\n+    /**\n+     * The field that this field shares a mapping with.\n+     */\n+    public void setMappedBy(String mapped) {\n+        _mappedBy = mapped;\n+        _mappedByMeta = null;\n+    }\n+\n+    /**\n+     * The field that this field shares a mapping with.\n+     */\n+    public FieldMetaData getMappedByMetaData() {\n+        if (_mappedBy != null && _mappedByMeta == null) {\n+            ClassMetaData meta = null;\n+            switch (getTypeCode()) {\n+                case JavaTypes.PC:\n+                    meta = getTypeMetaData();\n+                    break;\n+                case JavaTypes.ARRAY:\n+                case JavaTypes.COLLECTION:\n+                case JavaTypes.MAP:\n+                    meta = _elem.getTypeMetaData();\n+                    break;\n+            }\n+\n+            FieldMetaData field = (meta == null) ? null\n+                : meta.getField(_mappedBy);\n+            if (field == null)\n+                throw new MetaDataException(_loc.get(\"no-mapped-by\", this,\n+                    _mappedBy));\n+            if (field.getMappedBy() != null)\n+                throw new MetaDataException(_loc.get(\"circ-mapped-by\", this,\n+                    _mappedBy));\n+            _mappedByMeta = field;\n+        }\n+        return _mappedByMeta;\n+    }\n+\n+    /**\n+     * Logical inverse field.\n+     */\n+    public String getInverse() {\n+        if (ClassMetaData.DEFAULT_STRING.equals(_inverse))\n+            _inverse = null;\n+        return _inverse;\n+    }\n+\n+    /**\n+     * Logical inverse field.\n+     */\n+    public void setInverse(String inverse) {\n+        _inverses = null;\n+        _inverse = inverse;\n+    }\n+\n+    /**\n+     * Return all inverses of this field.\n+     */\n+    public FieldMetaData[] getInverseMetaDatas() {\n+        if (_inverses == null) {\n+            // can't declare both an inverse owner and a logical inverse\n+            String inv = getInverse();\n+            if (_mappedBy != null && inv != null && !_mappedBy.equals(inv))\n+                throw new MetaDataException(_loc.get(\"mapped-not-inverse\",\n+                    this));\n+\n+            // get the metadata for the type on the other side of this relation\n+            ClassMetaData meta = null;\n+            switch (getTypeCode()) {\n+                case JavaTypes.PC:\n+                    meta = getTypeMetaData();\n+                    break;\n+                case JavaTypes.ARRAY:\n+                case JavaTypes.COLLECTION:\n+                    meta = _elem.getTypeMetaData();\n+                    break;\n+            }\n+\n+            Collection inverses = null;\n+            if (meta != null) {\n+                // add mapped by and named inverse, if any\n+                FieldMetaData field = getMappedByMetaData();\n+                if (field != null) {\n+                    // mapped by field isn't necessarily a pc type, but all\n+                    // inverses must be\n+                    if (field.getTypeCode() == JavaTypes.PC\n+                        || field.getElement().getTypeCode() == JavaTypes.PC) {\n+                        inverses = new ArrayList(3);\n+                        inverses.add(field);\n+                    }\n+                } else if (inv != null) {\n+                    field = meta.getField(inv);\n+                    if (field == null)\n+                        throw new MetaDataException(_loc.get(\"no-inverse\",\n+                            this, inv));\n+                    inverses = new ArrayList(3);\n+                    inverses.add(field);\n+                }\n+\n+                // scan rel type for fields that name this field as an inverse\n+                FieldMetaData[] fields = meta.getFields();\n+                Class type = getDeclaringMetaData().getDescribedType();\n+                for (int i = 0; i < fields.length; i++) {\n+                    // skip fields that aren't compatible with our owning class\n+                    switch (fields[i].getTypeCode()) {\n+                        case JavaTypes.PC:\n+                            if (!type.isAssignableFrom(fields[i].getType()))\n+                                continue;\n+                            break;\n+                        case JavaTypes.COLLECTION:\n+                        case JavaTypes.ARRAY:\n+                            if (!type.isAssignableFrom(fields[i].\n+                                getElement().getType()))\n+                                continue;\n+                            break;\n+                        default:\n+                            continue;\n+                    }\n+\n+                    // if the field declares us as its inverse and we haven't\n+                    // already added it (we might have if we also declared it\n+                    // as our inverse), add it now\n+                    if (_name.equals(fields[i].getMappedBy())\n+                        || _name.equals(fields[i].getInverse())) {\n+                        if (inverses == null)\n+                            inverses = new ArrayList(3);\n+                        if (!inverses.contains(fields[i]))\n+                            inverses.add(fields[i]);\n+                    }\n+                }\n+            }\n+\n+            MetaDataRepository repos = getRepository();\n+            if (inverses == null)\n+                _inverses = repos.EMPTY_FIELDS;\n+            else\n+                _inverses = (FieldMetaData[]) inverses.toArray\n+                    (repos.newFieldMetaDataArray(inverses.size()));\n+        }\n+        return _inverses;\n+    }\n+\n+    /**\n+     * The strategy to use for insert value generation.\n+     * One of the constants from {@link ValueStrategies}.\n+     */\n+    public int getValueStrategy() {\n+        if (_valStrategy == -1)\n+            _valStrategy = ValueStrategies.NONE;\n+        return _valStrategy;\n+    }\n+\n+    /**\n+     * The strategy to use for insert value generation.\n+     * One of the constants from {@link ValueStrategies}.\n+     */\n+    public void setValueStrategy(int strategy) {\n+        _valStrategy = strategy;\n+        if (strategy != ValueStrategies.SEQUENCE)\n+            setValueSequenceName(null);\n+    }\n+\n+    /**\n+     * The value sequence name, or null for none.\n+     */\n+    public String getValueSequenceName() {\n+        if (ClassMetaData.DEFAULT_STRING.equals(_seqName))\n+            _seqName = null;\n+        return _seqName;\n+    }\n+\n+    /**\n+     * The value sequence name, or null for none.\n+     */\n+    public void setValueSequenceName(String seqName) {\n+        _seqName = seqName;\n+        _seqMeta = null;\n+        if (seqName != null)\n+            setValueStrategy(ValueStrategies.SEQUENCE);\n+    }\n+\n+    /**\n+     * Metadata for the value sequence.\n+     */\n+    public SequenceMetaData getValueSequenceMetaData() {\n+        if (_seqMeta == null && getValueSequenceName() != null)\n+            _seqMeta = getRepository().getSequenceMetaData(_owner,\n+                getValueSequenceName(), true);\n+        return _seqMeta;\n+    }\n+\n+    /**\n+     * The strategy to use when updating the field.\n+     */\n+    public int getUpdateStrategy() {\n+        if (isVersion())\n+            return UpdateStrategies.RESTRICT;\n+        if (_upStrategy == -1)\n+            _upStrategy = UpdateStrategies.NONE;\n+        return _upStrategy;\n+    }\n+\n+    /**\n+     * Set the update strategy.\n+     */\n+    public void setUpdateStrategy(int strategy) {\n+        _upStrategy = strategy;\n+    }\n+\n+    /**\n+     * Whether this field is backed by a large result set.\n+     */\n+    public boolean isLRS() {\n+        return _lrs == Boolean.TRUE && _manage == MANAGE_PERSISTENT;\n+    }\n+\n+    /**\n+     * Whether this field is backed by a large result set.\n+     */\n+    public void setLRS(boolean lrs) {\n+        _lrs = (lrs) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Whether this field is backed by a stream.\n+     *\n+     * @since 1.1.0\n+     */\n+    public boolean isStream() {\n+        return _stream == Boolean.TRUE && _manage == MANAGE_PERSISTENT;\n+    }\n+    \n+    /**\n+     * Whether this field is backed by a stream.\n+     *\n+     * @since 1.1.0\n+     */\n+    public void setStream(boolean stream) {\n+        _stream = (stream) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+    \n+    /**\n+     * Whether this field uses intermediate data when loading/storing\n+     * information through a {@link OpenJPAStateManager}. Defaults to true.\n+     *\n+     * @see OpenJPAStateManager#setIntermediate(int,Object)\n+     */\n+    public boolean usesIntermediate() {\n+        return _intermediate;\n+    }\n+\n+    /**\n+     * Whether this field uses intermediate data when loading/storing\n+     * information through a {@link OpenJPAStateManager}. Defaults to true.\n+     *\n+     * @see OpenJPAStateManager#setIntermediate(int,Object)\n+     */\n+    public void setUsesIntermediate(boolean intermediate) {\n+        _intermediate = intermediate;\n+        _owner.clearExtraFieldDataTable();\n+    }\n+\n+    /**\n+     * Whether this field uses impl data in conjunction with standard\n+     * field data when acting on a {@link OpenJPAStateManager}.\n+     * Defaults to {@link Boolean#TRUE} (non-cachable impl data).\n+     *\n+     * @return {@link Boolean#FALSE} if this field does not use impl data,\n+     * {@link Boolean#TRUE} if this field uses non-cachable impl\n+     * data, or <code>null</code> if this field uses impl data that\n+     * should be cached across instances\n+     * @see OpenJPAStateManager#setImplData(int,Object)\n+     */\n+    public Boolean usesImplData() {\n+        return _implData;\n+    }\n+\n+    /**\n+     * Whether this field uses impl data in conjunction with standard\n+     * field data when acting on a {@link OpenJPAStateManager}.\n+     *\n+     * @see OpenJPAStateManager#setImplData(int,Object)\n+     * @see #usesImplData\n+     */\n+    public void setUsesImplData(Boolean implData) {\n+        _implData = implData;\n+        _owner.clearExtraFieldDataTable();\n+    }\n+\n+    /**\n+     * The orderings for this field to be applied on load, or empty array.\n+     */\n+    public Order[] getOrders() {\n+        if (_orders == null) {\n+            if (_orderDec == null)\n+                _orders = getRepository().EMPTY_ORDERS;\n+            else {\n+                String[] decs = Strings.split(_orderDec, \",\", 0);\n+                Order[] orders = getRepository().newOrderArray(decs.length);\n+                int spc;\n+                boolean asc;\n+                for (int i = 0; i < decs.length; i++) {\n+                    decs[i] = decs[i].trim();\n+                    spc = decs[i].indexOf(' ');\n+                    if (spc == -1)\n+                        asc = true;\n+                    else {\n+                        asc = decs[i].substring(spc + 1).trim().\n+                            toLowerCase().startsWith(\"asc\");\n+                        decs[i] = decs[i].substring(0, spc);\n+                    }\n+                    orders[i] = getRepository().newOrder(this, decs[i], asc);\n+                    //set \"isUsedInOrderBy\" to the field\n+                    ClassMetaData elemCls = getElement()\n+                        .getDeclaredTypeMetaData();\n+                    if (elemCls != null) {\n+                      FieldMetaData fmd = elemCls.getDeclaredField(decs[i]);\n+                      if (fmd != null)\n+                        fmd.setUsedInOrderBy(true);                      \n+                    }\n+                }\n+                _orders = orders;\n+            }\n+        }\n+        return _orders;\n+    }\n+\n+    /**\n+     * The orderings for this field to be applied on load.\n+     */\n+    public void setOrders(Order[] orders) {\n+        _orderDec = null;\n+        _orders = orders;\n+    }\n+\n+    /**\n+     * String declaring the orderings for this field to be applied on load,\n+     * or null. The string is of the form:<br />\n+     * <code>orderable[ asc|desc][, ...]</code><br />\n+     * The orderable <code>#element</code> is used to denote the value of\n+     * the field's elements.\n+     */\n+    public String getOrderDeclaration() {\n+        if (_orderDec == null && _orders != null) {\n+            StringBuffer buf = new StringBuffer();\n+            for (int i = 0; i < _orders.length; i++) {\n+                if (i > 0)\n+                    buf.append(\", \");\n+                buf.append(_orders[i].getName()).append(\" \");\n+                buf.append((_orders[i].isAscending()) ? \"asc\" : \"desc\");\n+            }\n+            _orderDec = buf.toString();\n+        }\n+        return _orderDec;\n+    }\n+\n+    /**\n+     * String declaring the orderings for this field to be applied on load,\n+     * or null. The string is of the form:<br />\n+     * <code>orderable[ asc|desc][, ...]</code><br />\n+     * The orderable <code>#element</code> is used to denote the value of\n+     * the field's elements.\n+     */\n+    public void setOrderDeclaration(String dec) {\n+        _orderDec = StringUtils.trimToNull(dec);\n+        _orders = null;\n+    }\n+\n+    /**\n+     * Order this field value when it is loaded.\n+     */\n+    public Object order(Object val) {\n+        if (val == null)\n+            return null;\n+\n+        Order[] orders = getOrders();\n+        if (orders.length == 0)\n+            return val;\n+\n+        // create a comparator for the elements of the value\n+        Comparator comp;\n+        if (orders.length == 1)\n+            comp = orders[0].getComparator();\n+        else {\n+            List comps = null;\n+            Comparator curComp;\n+            for (int i = 0; i < orders.length; i++) {\n+                curComp = orders[i].getComparator();\n+                if (curComp != null) {\n+                    if (comps == null)\n+                        comps = new ArrayList(orders.length);\n+                    if (i != comps.size())\n+                        throw new MetaDataException(_loc.get\n+                            (\"mixed-inmem-ordering\", this));\n+                    comps.add(curComp);\n+                }\n+            }\n+            if (comps == null)\n+                comp = null;\n+            else\n+                comp = new ComparatorChain(comps);\n+        }\n+\n+        if (comp == null)\n+            return val;\n+\n+        // sort\n+        switch (getTypeCode()) {\n+            case JavaTypes.ARRAY:\n+                List l = JavaTypes.toList(val, _elem.getType(), true);\n+                Collections.sort(l, comp);\n+                return JavaTypes.toArray(l, _elem.getType());\n+            case JavaTypes.COLLECTION:\n+                if (val instanceof List)\n+                    Collections.sort((List) val, comp);\n+                return val;\n+            default:\n+                throw new MetaDataException(_loc.get(\"cant-order\", this));\n+        }\n+    }\n+\n+    /**\n+     * Whether the field is externalized.\n+     */\n+    public boolean isExternalized() {\n+        return getExternalizerMethod() != null\n+            || getExternalValueMap() != null;\n+    }\n+\n+    /**\n+     * Convert the given field value to its external value through the\n+     * provided externalizer, or return the value as-is if no externalizer.\n+     */\n+    public Object getExternalValue(Object val, StoreContext ctx) {\n+        Map extValues = getExternalValueMap();\n+        if (extValues != null) {\n+            Object foundVal = extValues.get(val);\n+            if (foundVal == null) {\n+                throw new UserException(_loc.get(\"bad-externalized-value\",\n+                        new Object[] { val, extValues.keySet(), this }))\n+                        .setFatal(true).setFailedObject(val);\n+            } else {\n+                return foundVal;\n+            }\n+        }\n+\n+        Method externalizer = getExternalizerMethod();\n+        if (externalizer == null)\n+            return val;\n+\n+        // special case for queries: allow the given value to pass through\n+        // as-is if it is already in externalized form\n+        if (val != null && getType().isInstance(val)\n+            && (!getDeclaredType().isInstance(val)\n+            || getDeclaredType() == Object.class))\n+            return val;\n+\n+        try {\n+            // either invoke the static toExternal(val[, ctx]) method, or the\n+            // non-static val.toExternal([ctx]) method\n+            if (Modifier.isStatic(externalizer.getModifiers())) {\n+                if (externalizer.getParameterTypes().length == 1)\n+                    return externalizer.invoke(null, new Object[]{ val });\n+                return externalizer.invoke(null, new Object[]{ val, ctx });\n+            }\n+            if (val == null)\n+                return null;\n+            if (externalizer.getParameterTypes().length == 0)\n+                return externalizer.invoke(val, (Object[]) null);\n+            return externalizer.invoke(val, new Object[]{ ctx });\n+        } catch (OpenJPAException ke) {\n+            throw ke;\n+        } catch (Exception e) {\n+            throw new MetaDataException(_loc.get(\"externalizer-err\", this,\n+                Exceptions.toString(val), e.toString())).setCause(e);\n+        }\n+    }\n+\n+    /**\n+     * Return the result of passing the given external value through the\n+     * factory to get the field value. If no factory is present,\n+     * the given value is returned as-is.\n+     */\n+    public Object getFieldValue(Object val, StoreContext ctx) {\n+        Map fieldValues = getFieldValueMap();\n+        if (fieldValues != null)\n+            return fieldValues.get(val);\n+\n+        Member factory = getFactoryMethod();\n+        if (factory == null)\n+            return val;\n+\n+        try {\n+            if (val == null && getNullValue() == NULL_DEFAULT)\n+                return AccessController.doPrivileged(\n+                    J2DoPrivHelper.newInstanceAction(getDeclaredType())); \n+\n+            // invoke either the constructor for the field type,\n+            // or the static type.toField(val[, ctx]) method\n+            if (factory instanceof Constructor) {\n+                if (val == null)\n+                    return null;\n+                return ((Constructor) factory).newInstance\n+                    (new Object[]{ val });\n+            }\n+\n+            Method meth = (Method) factory;\n+            if (meth.getParameterTypes().length == 1)\n+                return meth.invoke(null, new Object[]{ val });\n+            return meth.invoke(null, new Object[]{ val, ctx });\n+        } catch (Exception e) {\n+            // unwrap cause\n+            if (e instanceof InvocationTargetException) {\n+                Throwable t = ((InvocationTargetException) e).\n+                    getTargetException();\n+                if (t instanceof Error)\n+                    throw (Error) t;\n+                e = (Exception) t;\n+\n+                // allow null values to cause NPEs and illegal arg exceptions\n+                // without error\n+                if (val == null && (e instanceof NullPointerException\n+                    || e instanceof IllegalArgumentException))\n+                    return null;\n+            }\n+\n+            if (e instanceof OpenJPAException)\n+                throw (OpenJPAException) e;\n+            if (e instanceof PrivilegedActionException)\n+                e = ((PrivilegedActionException) e).getException();\n+            throw new MetaDataException(_loc.get(\"factory-err\", this,\n+                Exceptions.toString(val), e.toString())).setCause(e);\n+        }\n+    }\n+\n+    /**\n+     * The name of this field's externalizer, or null if none.\n+     */\n+    public String getExternalizer() {\n+        return _extName;\n+    }\n+\n+    /**\n+     * The name of this field's externalizer, or null if none.\n+     */\n+    public void setExternalizer(String externalizer) {\n+        _extName = externalizer;\n+        _extMethod = DEFAULT_METHOD;\n+    }\n+\n+    /**\n+     * The name of this field's factory, or null if none.\n+     */\n+    public String getFactory() {\n+        return _factName;\n+    }\n+\n+    /**\n+     * The name of this field's factory, or null if none.\n+     */\n+    public void setFactory(String factory) {\n+        _factName = factory;\n+        _factMethod = DEFAULT_METHOD;\n+    }\n+\n+    /**\n+     * Properties string mapping field values to external values.\n+     */\n+    public String getExternalValues() {\n+        return _extString;\n+    }\n+\n+    /**\n+     * Properties string mapping field values to external values.\n+     */\n+    public void setExternalValues(String values) {\n+        _extString = values;\n+        _extValues = null;\n+    }\n+\n+    /**\n+     * Return the mapping of field values to external values.\n+     */\n+    public Map getExternalValueMap() {\n+        parseExternalValues();\n+        return _extValues;\n+    }\n+\n+    /**\n+     * Return the mapping of external values to field values.\n+     */\n+    public Map getFieldValueMap() {\n+        parseExternalValues();\n+        return _fieldValues;\n+    }\n+\n+    /**\n+     * Parse external values into maps.\n+     */\n+    private void parseExternalValues() {\n+        if (_extValues != Collections.EMPTY_MAP\n+            && _fieldValues != Collections.EMPTY_MAP)\n+            return;\n+\n+        if (_extString == null) {\n+            _extValues = null;\n+            _fieldValues = null;\n+            return;\n+        }\n+\n+        // parse string into options; this takes care of proper trimming etc\n+        Options values = Configurations.parseProperties(_extString);\n+        if (values.isEmpty())\n+            throw new MetaDataException(_loc.get(\"no-external-values\", this,\n+                _extString));\n+\n+        Map extValues = new HashMap((int) (values.size() * 1.33 + 1));\n+        Map fieldValues = new HashMap((int) (values.size() * 1.33 + 1));\n+        Map.Entry entry;\n+        Object extValue, fieldValue;\n+        for (Iterator itr = values.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            fieldValue = transform((String) entry.getKey(),\n+                getDeclaredTypeCode());\n+            extValue = transform((String) entry.getValue(), getTypeCode());\n+\n+            extValues.put(fieldValue, extValue);\n+            fieldValues.put(extValue, fieldValue);\n+        }\n+\n+        _extValues = extValues;\n+        _fieldValues = fieldValues;\n+    }\n+\n+    /**\n+     * Return the string value converted to the given type code. The string\n+     * must be non-null and trimmed.\n+     */\n+    private Object transform(String val, int typeCode) {\n+        if (\"null\".equals(val))\n+            return null;\n+\n+        switch (typeCode) {\n+            case JavaTypes.BOOLEAN:\n+            case JavaTypes.BOOLEAN_OBJ:\n+                return Boolean.valueOf(val);\n+            case JavaTypes.BYTE:\n+            case JavaTypes.BYTE_OBJ:\n+                return Byte.valueOf(val);\n+            case JavaTypes.INT:\n+            case JavaTypes.INT_OBJ:\n+                return Integer.valueOf(val);\n+            case JavaTypes.LONG:\n+            case JavaTypes.LONG_OBJ:\n+                return Long.valueOf(val);\n+            case JavaTypes.SHORT:\n+            case JavaTypes.SHORT_OBJ:\n+                return Short.valueOf(val);\n+            case JavaTypes.DOUBLE:\n+            case JavaTypes.DOUBLE_OBJ:\n+                return Double.valueOf(val);\n+            case JavaTypes.FLOAT:\n+            case JavaTypes.FLOAT_OBJ:\n+                return Float.valueOf(val);\n+            case JavaTypes.CHAR:\n+            case JavaTypes.CHAR_OBJ:\n+                return new Character(val.charAt(0));\n+            case JavaTypes.STRING:\n+                return val;\n+        }\n+        throw new MetaDataException(_loc.get(\"bad-external-type\", this));\n+    }\n+\n+    /**\n+     * The externalizer method.\n+     */\n+    public Method getExternalizerMethod() {\n+        if (_manage != MANAGE_PERSISTENT)\n+            return null;\n+        if (_extMethod == DEFAULT_METHOD) {\n+            if (_extName != null) {\n+                _extMethod = findMethod(_extName);\n+                if (_extMethod == null)\n+                    throw new MetaDataException(_loc.get(\"bad-externalizer\",\n+                        this, _extName));\n+            } else\n+                _extMethod = null;\n+        }\n+        return _extMethod;\n+    }\n+\n+    /**\n+     * The factory method or constructor.\n+     */\n+    public Member getFactoryMethod() {\n+        if (_manage != MANAGE_PERSISTENT)\n+            return null;\n+        if (_factMethod == DEFAULT_METHOD) {\n+            if (getExternalizerMethod() == null)\n+                _factMethod = null;\n+            else {\n+                try {\n+                    if (_factName == null)\n+                        _factMethod = getDeclaredType().getConstructor\n+                            (new Class[]{ getType() });\n+                    else\n+                        _factMethod = findMethod(_factName);\n+                } catch (OpenJPAException ke) {\n+                    throw ke;\n+                } catch (Exception e) {\n+                }\n+\n+                if (!(_factMethod instanceof Constructor)\n+                    && !(_factMethod instanceof Method))\n+                    throw new MetaDataException(_loc.get(\"bad-factory\", this));\n+            }\n+        }\n+        return _factMethod;\n+    }\n+\n+    /**\n+     * Find the method for the specified name. Possible forms are:\n+     * <ul>\n+     * <li>toExternalString</li>\n+     * <li>MyFactoryClass.toExternalString</li>\n+     * <li>com.company.MyFactoryClass.toExternalString</li>\n+     * </ul>\n+     *\n+     * @param method the name of the method to locate\n+     * @return the method for invocation\n+     */\n+    private Method findMethod(String method) {\n+        if (StringUtils.isEmpty(method))\n+            return null;\n+\n+        // get class name and get package name divide on the last '.', so the\n+        // names don't apply in this case, but the methods do what we want\n+        String methodName = Strings.getClassName(method);\n+        String clsName = Strings.getPackageName(method);\n+\n+        Class cls = null;\n+        Class owner = _owner.getDescribedType();\n+\n+        if (clsName.length() == 0)\n+            cls = getDeclaredType();\n+        else if (clsName.equals(owner.getName())\n+            || clsName.equals(Strings.getClassName(owner)))\n+            cls = owner;\n+        else\n+            cls = JavaTypes.classForName(clsName, this);\n+\n+        // find the named method\n+        Method[] methods = cls.getMethods();\n+        Class[] params;\n+        for (int i = 0; i < methods.length; i++) {\n+            if (methods[i].getName().equals(methodName)) {\n+                params = methods[i].getParameterTypes();\n+\n+                // static factory methods require one argument or one argument\n+                // plus a ctx; non-static methods require zero arguments or\n+                // just a ctx\n+                if (Modifier.isStatic(methods[i].getModifiers())\n+                    && (params.length == 1 || (params.length == 2\n+                    && isStoreContextParameter(params[1]))))\n+                    return methods[i];\n+                if (!Modifier.isStatic(methods[i].getModifiers())\n+                    && (params.length == 0 || (params.length == 1\n+                    && isStoreContextParameter(params[0]))))\n+                    return methods[i];\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Return true if the given type is a store context type; we can't\n+     * use the standard <code>isAssignableFrom</code> because of classloader\n+     * oddness.\n+     */\n+    private static boolean isStoreContextParameter(Class type) {\n+        return StoreContext.class.getName().equals(type.getName());\n+    }\n+\n+    public boolean equals(Object other) {\n+        if (other == this)\n+            return true;\n+        if (!(other instanceof FieldMetaData))\n+            return false;\n+        return getFullName(true).equals(((FieldMetaData) other).\n+            getFullName(true));\n+    }\n+\n+    public int hashCode() {\n+        return getFullName(true).hashCode();\n+    }\n+\n+    public int compareTo(Object other) {\n+        if (other == null)\n+            return 1;\n+        return getFullName(true).compareTo(((FieldMetaData) other).\n+            getFullName(true));\n+    }\n+\n+    public String toString() {\n+        return getFullName(true);\n+    }\n+\n+    ////////////////////////\n+    // Resolve and validate\n+    ////////////////////////\n+\n+    /**\n+     * Resolve mode for this field.\n+     */\n+    public int getResolve() {\n+        return _resMode;\n+    }\n+\n+    /**\n+     * Resolve mode for this field.\n+     */\n+    public void setResolve(int mode) {\n+        _resMode = mode;\n+    }\n+\n+    /**\n+     * Resolve mode for this field.\n+     */\n+    public void setResolve(int mode, boolean on) {\n+        if (mode == MODE_NONE)\n+            _resMode = mode;\n+        else if (on)\n+            _resMode |= mode;\n+        else\n+            _resMode &= ~mode;\n+    }\n+\n+    /**\n+     * Resolve and validate metadata. Return true if already resolved.\n+     */\n+    public boolean resolve(int mode) {\n+        if ((_resMode & mode) == mode)\n+            return true;\n+        int cur = _resMode;\n+        _resMode |= mode;\n+\n+        Log log = getRepository().getLog();\n+        if (log.isTraceEnabled())\n+            log.trace(_loc.get(\"resolve-field\", _owner + \"@\"\n+                + System.identityHashCode(_owner) + \".\" + _name));\n+\n+        // we only perform actions for metadata mode\n+        if ((mode & MODE_META) == 0 || (cur & MODE_META) != 0)\n+            return false;\n+\n+        Method externalizer = getExternalizerMethod();\n+        if (externalizer != null)\n+            setType(externalizer.getReturnType());\n+\n+        // only pass on metadata resolve mode so that metadata is always\n+        // resolved before any other resolve modes our subclasses pass along\n+        _val.resolve(MODE_META);\n+        _key.resolve(MODE_META);\n+        _elem.resolve(MODE_META);\n+\n+        MetaDataRepository repos = getRepository();\n+        int validate = repos.getValidate();\n+        if ((validate & MetaDataRepository.VALIDATE_META) != 0\n+            && (!ImplHelper.isManagedType(repos.getConfiguration(),\n+                _owner.getDescribedType())\n+            || (validate & MetaDataRepository.VALIDATE_UNENHANCED) == 0)) {\n+            validateLRS();\n+            if ((validate & repos.VALIDATE_RUNTIME) == 0)\n+                validateSupportedType();\n+            validateValue();\n+            validateExtensionKeys();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Validate that this field can be used for LRS.\n+     */\n+    private void validateLRS() {\n+        if (!isLRS())\n+            return;\n+\n+        // can't use lrs for arrays\n+        if (getTypeCode() == JavaTypes.ARRAY)\n+            throw new MetaDataException(_loc.get(\"bad-lrs-array\", this));\n+\n+        // can't use lrs for extranalized vals\n+        if (getExternalizerMethod() != null)\n+            throw new MetaDataException(_loc.get(\"bad-lrs-extern\", this));\n+\n+        // can't use lrs for concrete types\n+        if (getType() != Collection.class && getType() != Map.class\n+            && getType() != Set.class)\n+            throw new MetaDataException(_loc.get(\"bad-lrs-concrete\", this));\n+    }\n+\n+    /**\n+     * Validate that this field is supported by the runtime.\n+     */\n+    private void validateSupportedType() {\n+        // log warnings about things we don't handle\n+        OpenJPAConfiguration conf = getRepository().getConfiguration();\n+        Collection opts = conf.supportedOptions();\n+        Log log = conf.getLog(conf.LOG_METADATA);\n+        switch (getTypeCode()) {\n+            case JavaTypes.PC:\n+                if (isEmbedded() &&\n+                    !opts.contains(conf.OPTION_EMBEDDED_RELATION)) {\n+                    setEmbedded(false);\n+                    if (log.isWarnEnabled())\n+                        log.warn(_loc.get(\"cant-embed\", this));\n+                } else\n+                if (isEmbedded() && getDeclaredTypeCode() != JavaTypes.PC) {\n+                    setEmbedded(false);\n+                    if (log.isWarnEnabled())\n+                        log.warn(_loc.get(\"cant-embed-extern\", this));\n+                }\n+                break;\n+            case JavaTypes.COLLECTION:\n+                if (!opts.contains(conf.OPTION_TYPE_COLLECTION))\n+                    throw new UnsupportedException(\n+                        _loc.get(\"type-not-supported\",\n+                            \"Collection\", this));\n+                if (_elem.isEmbeddedPC()\n+                    && !opts.contains(conf.OPTION_EMBEDDED_COLLECTION_RELATION))\n+                {\n+                    _elem.setEmbedded(false);\n+                    if (log.isWarnEnabled())\n+                        log.warn(_loc.get(\"cant-embed-element\", this));\n+                }\n+                break;\n+            case JavaTypes.ARRAY:\n+                if (!opts.contains(conf.OPTION_TYPE_ARRAY))\n+                    throw new UnsupportedException(\n+                        _loc.get(\"type-not-supported\",\n+                            \"Array\", this));\n+                if (_elem.isEmbeddedPC()\n+                    && !opts.contains(conf.OPTION_EMBEDDED_COLLECTION_RELATION))\n+                {\n+                    _elem.setEmbedded(false);\n+                    if (log.isWarnEnabled())\n+                        log.warn(_loc.get(\"cant-embed-element\", this));\n+                }\n+                break;\n+            case JavaTypes.MAP:\n+                if (!opts.contains(conf.OPTION_TYPE_MAP))\n+                    throw new UnsupportedException(\n+                        _loc.get(\"type-not-supported\",\n+                            \"Map\", this));\n+                if (_elem.isEmbeddedPC()\n+                    && !opts.contains(conf.OPTION_EMBEDDED_MAP_RELATION)) {\n+                    _elem.setEmbedded(false);\n+                    if (log.isWarnEnabled())\n+                        log.warn(_loc.get(\"cant-embed-element\", this));\n+                }\n+                if (_key.isEmbeddedPC()\n+                    && !opts.contains(conf.OPTION_EMBEDDED_MAP_RELATION)) {\n+                    _key.setEmbedded(false);\n+                    if (log.isWarnEnabled())\n+                        log.warn(_loc.get(\"cant-embed-key\", this));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Validate our value strategy.\n+     */\n+    private void validateValue() {\n+        if (getExternalizerMethod() != null && getExternalValueMap() != null)\n+            throw new MetaDataException(_loc.get(\"extern-externvalues\", this));\n+        if (getValueStrategy() == ValueStrategies.SEQUENCE\n+            && getValueSequenceName() == null)\n+            throw new MetaDataException(_loc.get(\"no-seq-name\", this));\n+        ValueStrategies.assertSupported(getValueStrategy(), this,\n+            \"value strategy\");\n+    }\n+\n+    /**\n+     * Copy state from the given field to this one. Do not copy mapping\n+     * information.\n+     */\n+    public void copy(FieldMetaData field) {\n+        super.copy(field);\n+\n+        _intermediate = field.usesIntermediate();\n+        _implData = field.usesImplData();\n+\n+        // copy field-level info; use get methods to force resolution of\n+        // lazy data\n+        _proxyClass = field.getProxyType();\n+        _initializer = field.getInitializer();\n+        _transient = field.isTransient();\n+        _nullValue = field.getNullValue();\n+        _manage = field.getManagement();\n+        _explicit = field.isExplicit();\n+        _extName = field.getExternalizer();\n+        _extMethod = DEFAULT_METHOD;\n+        _factName = field.getFactory();\n+        _factMethod = DEFAULT_METHOD;\n+        _extString = field.getExternalValues();\n+        _extValues = Collections.EMPTY_MAP;\n+        _fieldValues = Collections.EMPTY_MAP;\n+        _primKey = field.isPrimaryKey();\n+        _backingMember = field._backingMember;\n+        _enumField = field._enumField;\n+        _lobField = field._lobField;\n+        _serializableField = field._serializableField;\n+        _generated = field._generated;\n+\n+        // embedded fields can't be versions\n+        if (_owner.getEmbeddingMetaData() == null && _version == null)\n+            _version = (field.isVersion()) ? Boolean.TRUE : Boolean.FALSE;\n+\n+        // only copy this data if not already set explicitly in this instance\n+        if (_dfg == 0) {\n+            _dfg = (field.isInDefaultFetchGroup()) ? DFG_TRUE : DFG_FALSE;\n+            if (field.isDefaultFetchGroupExplicit())\n+                _dfg |= DFG_EXPLICIT;\n+        }\n+        if (_fgSet == null && field._fgSet != null)\n+            _fgSet = new HashSet(field._fgSet);\n+        if (_lfg == null)\n+            _lfg = field.getLoadFetchGroup();\n+        if (_lrs == null)\n+            _lrs = (field.isLRS()) ? Boolean.TRUE : Boolean.FALSE;\n+        if (_valStrategy == -1)\n+            _valStrategy = field.getValueStrategy();\n+        if (_upStrategy == -1)\n+            _upStrategy = field.getUpdateStrategy();\n+        if (ClassMetaData.DEFAULT_STRING.equals(_seqName)) {\n+            _seqName = field.getValueSequenceName();\n+            _seqMeta = null;\n+        }\n+        if (ClassMetaData.DEFAULT_STRING.equals(_inverse))\n+            _inverse = field.getInverse();\n+\n+        // copy value metadata\n+        _val.copy(field);\n+        _key.copy(field.getKey());\n+        _elem.copy(field.getElement());\n+    }\n+\n+    protected void addExtensionKeys(Collection exts) {\n+        getRepository().getMetaDataFactory().addFieldExtensionKeys(exts);\n+    }\n+\n+    ///////////////\n+    // Commentable\n+    ///////////////\n+\n+    public String[] getComments() {\n+        return (_comments == null) ? EMPTY_COMMENTS : _comments;\n+    }\n+\n+    public void setComments(String[] comments) {\n+        _comments = comments;\n+    }\n+\n+    ////////////////////////////////\n+    // ValueMetaData implementation\n+    ////////////////////////////////\n+\n+    public FieldMetaData getFieldMetaData() {\n+        return this;\n+    }\n+\n+    public Class getType() {\n+        return _val.getType();\n+    }\n+\n+    public void setType(Class type) {\n+        _val.setType(type);\n+        if (type.isArray())\n+            _elem.setType(type.getComponentType());\n+        else if (type == Properties.class) {\n+            _key.setType(String.class);\n+            _elem.setType(String.class);\n+        }\n+    }\n+\n+    public int getTypeCode() {\n+        return _val.getTypeCode();\n+    }\n+\n+    public void setTypeCode(int code) {\n+        _val.setTypeCode(code);\n+    }\n+\n+    public boolean isTypePC() {\n+        return _val.isTypePC();\n+    }\n+\n+    public ClassMetaData getTypeMetaData() {\n+        return _val.getTypeMetaData();\n+    }\n+\n+    public Class getDeclaredType() {\n+        return _val.getDeclaredType();\n+    }\n+\n+    public void setDeclaredType(Class type) {\n+        _val.setDeclaredType(type);\n+        if (type.isArray())\n+            _elem.setDeclaredType(type.getComponentType());\n+        else if (type == Properties.class) {\n+            _key.setDeclaredType(String.class);\n+            _elem.setDeclaredType(String.class);\n+        }\n+    }\n+\n+    public int getDeclaredTypeCode() {\n+        return _val.getDeclaredTypeCode();\n+    }\n+\n+    public void setDeclaredTypeCode(int type) {\n+        _val.setDeclaredTypeCode(type);\n+    }\n+\n+    public boolean isDeclaredTypePC() {\n+        return _val.isDeclaredTypePC();\n+    }\n+\n+    public ClassMetaData getDeclaredTypeMetaData() {\n+        return _val.getDeclaredTypeMetaData();\n+    }\n+\n+    public boolean isEmbedded() {\n+        return _val.isEmbedded();\n+    }\n+\n+    public void setEmbedded(boolean embedded) {\n+        _val.setEmbedded(embedded);\n+    }\n+\n+    public boolean isEmbeddedPC() {\n+        return _val.isEmbeddedPC();\n+    }\n+\n+    public ClassMetaData getEmbeddedMetaData() {\n+        return _val.getEmbeddedMetaData();\n+    }\n+\n+    public ClassMetaData addEmbeddedMetaData() {\n+        return _val.addEmbeddedMetaData();\n+    }\n+\n+    public int getCascadeDelete() {\n+        return _val.getCascadeDelete();\n+    }\n+\n+    public void setCascadeDelete(int delete) {\n+        _val.setCascadeDelete(delete);\n+    }\n+\n+    public int getCascadePersist() {\n+        return _val.getCascadePersist();\n+    }\n+\n+    public void setCascadePersist(int persist) {\n+        _val.setCascadePersist(persist);\n+    }\n+\n+    public int getCascadeAttach() {\n+        return _val.getCascadeAttach();\n+    }\n+\n+    public void setCascadeAttach(int attach) {\n+        _val.setCascadeAttach(attach);\n+    }\n+\n+    public int getCascadeRefresh() {\n+        return _val.getCascadeRefresh();\n+    }\n+\n+    public void setCascadeRefresh(int refresh) {\n+        _val.setCascadeRefresh(refresh);\n+    }\n+\n+    public boolean isSerialized() {\n+        return _val.isSerialized();\n+    }\n+\n+    public void setSerialized(boolean serialized) {\n+        _val.setSerialized(serialized);\n+    }\n+\n+    public String getValueMappedBy() {\n+        return _val.getValueMappedBy();\n+    }\n+\n+    public void setValueMappedBy(String mapped) {\n+        _val.setValueMappedBy(mapped);\n+    }\n+\n+    public FieldMetaData getValueMappedByMetaData ()\n+\t{\n+\t\treturn _val.getValueMappedByMetaData ();\n+\t}\n+\n+\tpublic Class getTypeOverride ()\n+\t{\n+\t\treturn _val.getTypeOverride ();\n+\t}\n+\n+\tpublic void setTypeOverride (Class type)\n+\t{\n+\t\t_val.setTypeOverride (type);\n+\t}\n+\n+\tpublic void copy (ValueMetaData vmd)\n+\t{\n+\t\t_val.copy (vmd);\n+\t}\n+\n+    /**\n+     * Check if this field is used by other field as \"order by\" value.\n+     *\n+     * @since 1.1.0\n+     */\n+    public boolean isUsedInOrderBy() {\n+    \treturn _usedInOrderBy;\n+    }\n+    \n+    /**\n+     * Whether this field is used by other field as \"order by\" value .\n+     *\n+     * @since 1.1.0\n+     */\n+    public void setUsedInOrderBy(boolean isUsed) {\n+    \t_usedInOrderBy = isUsed;\n+    }\n+    \n+    /**\n+     * Serializable wrapper around a {@link Method} or {@link Field}. For \n+     * space considerations, this does not support {@link Constructor}s.\n+     */\n+\tpublic static class MemberProvider\n+        implements Externalizable {\n+\n+        private transient Member _member;\n+\n+        public MemberProvider() {\n+            // for externalization\n+        }\n+\n+        MemberProvider(Member member) {\n+            if (member instanceof Constructor)\n+                throw new IllegalArgumentException();\n+\n+            _member = member;\n+        }\n+\n+        public Member getMember() {\n+            return _member;\n+        }\n+\n+        public void readExternal(ObjectInput in)\n+            throws IOException, ClassNotFoundException {\n+            boolean isField = in.readBoolean();\n+            Class cls = (Class) in.readObject();\n+            String memberName = (String) in.readObject();\n+            try {\n+                if (isField)\n+                    _member = (Field) AccessController.doPrivileged(\n+                        J2DoPrivHelper.getDeclaredFieldAction(\n+                            cls, memberName)); \n+                else {\n+                    Class[] parameterTypes = (Class[]) in.readObject();\n+                    _member = (Method) AccessController.doPrivileged(\n+                        J2DoPrivHelper.getDeclaredMethodAction(\n+                            cls, memberName, parameterTypes));\n+                }\n+            } catch (SecurityException e) {\n+                IOException ioe = new IOException(e.getMessage());\n+                ioe.initCause(e);\n+                throw ioe;\n+            } catch (PrivilegedActionException pae) {\n+                IOException ioe = new IOException(\n+                    pae.getException().getMessage());\n+                ioe.initCause(pae);\n+                throw ioe;\n+            }\n+        }\n+\n+        public void writeExternal(ObjectOutput out)\n+            throws IOException {\n+            boolean isField = _member instanceof Field;\n+            out.writeBoolean(isField);\n+            out.writeObject(_member.getDeclaringClass());\n+            out.writeObject(_member.getName());\n+            if (!isField)\n+                out.writeObject(((Method) _member).getParameterTypes());\n+        }\n+    }\n+\n+    public boolean isValueGenerated() {\n+        return _generated;\n+    }\n+\n+    public void setValueGenerated(boolean generated) {\n+        this._generated = generated;\n+    }\n+}"},{"sha":"532dcb10b2e69e42d5cbeadf1a86725a8d12bf7a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryRelatedFieldOrder.java","status":"added","additions":84,"deletions":0,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryRelatedFieldOrder.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryRelatedFieldOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryRelatedFieldOrder.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.util.Comparator;\n+\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.util.ImplHelper;\n+\n+/**\n+ * Order by a field in the related type in memory.\n+ *\n+ * @author Abe White\n+ */\n+class InMemoryRelatedFieldOrder\n+    implements Order, Comparator {\n+\n+    private final FieldMetaData _rel;\n+    private final boolean _asc;\n+    private final OpenJPAConfiguration _conf;\n+\n+    public InMemoryRelatedFieldOrder(FieldMetaData rel, boolean asc,\n+        OpenJPAConfiguration conf) {\n+        _rel = rel;\n+        _asc = asc;\n+        _conf = conf;\n+    }\n+\n+    public String getName() {\n+        return _rel.getName();\n+    }\n+\n+    public boolean isAscending() {\n+        return _asc;\n+    }\n+\n+    public Comparator getComparator() {\n+        return this;\n+    }\n+\n+    public int compare(Object o1, Object o2) {\n+        if (o1 == o2)\n+            return 0;\n+        if (!(ImplHelper.isManageable(o1))\n+            || !(ImplHelper.isManageable(o2)))\n+            return 0;\n+\n+        PersistenceCapable pc1 = ImplHelper.toPersistenceCapable(o1, _conf);\n+        PersistenceCapable pc2 = ImplHelper.toPersistenceCapable(o2, _conf);\n+        OpenJPAStateManager sm1 = (OpenJPAStateManager) pc1.pcGetStateManager();\n+        OpenJPAStateManager sm2 = (OpenJPAStateManager) pc2.pcGetStateManager();\n+        if (sm1 == null || sm2 == null)\n+            return 0;\n+\n+        Object v1 = sm1.fetchField(_rel.getIndex(), false);\n+        Object v2 = sm2.fetchField(_rel.getIndex(), false);\n+        if (v1 == v2)\n+            return 0;\n+        if (v1 == null)\n+            return (_asc) ? -1 : 1;\n+        if (v2 == null)\n+            return (_asc) ? 1 : -1;\n+        int cmp = ((Comparable) v1).compareTo(v2);\n+        return (_asc) ? cmp : -cmp;\n+    }\n+}"},{"sha":"a06e5a9acc3387401e722419ed1dc0c3a1201945","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryValueOrder.java","status":"added","additions":117,"deletions":0,"changes":117,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryValueOrder.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryValueOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InMemoryValueOrder.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.util.Comparator;\n+\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.util.ApplicationIds;\n+import org.apache.openjpa.util.ImplHelper;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+\n+/**\n+ * Order by the field value in memory. If the field contains\n+ * {@link PersistenceCapable} objects, order on their primary key values.\n+ * Relies on primary key values, including datastore oid objects, being\n+ * {@link Comparable}.\n+ *\n+ * @author Abe White\n+ */\n+class InMemoryValueOrder\n+    implements Order, Comparator {\n+\n+    private final boolean _asc;\n+    private final OpenJPAConfiguration _conf;\n+\n+    public InMemoryValueOrder(boolean asc, OpenJPAConfiguration conf) {\n+        _asc = asc;\n+        _conf = conf;\n+    }\n+\n+    public String getName() {\n+        return Order.ELEMENT;\n+    }\n+\n+    public boolean isAscending() {\n+        return _asc;\n+    }\n+\n+    public Comparator getComparator() {\n+        return this;\n+    }\n+\n+    public int compare(Object o1, Object o2) {\n+        if (o1 == o2)\n+            return 0;\n+        if (o1 == null)\n+            return (_asc) ? -1 : 1;\n+        if (o2 == null)\n+            return (_asc) ? 1 : -1;\n+\n+        // non-pc values must be comparable\n+        int cmp;\n+        if (!(ImplHelper.isManageable(o1))\n+            || !(ImplHelper.isManageable(o2))) {\n+            cmp = ((Comparable) o1).compareTo(o2);\n+            return (_asc) ? cmp : -cmp;\n+        }\n+\n+        // order on primary key values\n+        PersistenceCapable pc1 = ImplHelper.toPersistenceCapable(o1, _conf);\n+        PersistenceCapable pc2 = ImplHelper.toPersistenceCapable(o2, _conf);\n+        OpenJPAStateManager sm1 = (OpenJPAStateManager) pc1.pcGetStateManager();\n+        OpenJPAStateManager sm2 = (OpenJPAStateManager) pc2.pcGetStateManager();\n+        if (sm1 == null || sm2 == null)\n+            return 0;\n+\n+        Object[] pk1 = toPKValues(sm1);\n+        Object[] pk2 = toPKValues(sm2);\n+        int len = Math.min(pk1.length, pk2.length);\n+        for (int i = 0; i < len; i++) {\n+            if (pk1[i] == pk2[i])\n+                return 0;\n+            if (pk1[i] == null)\n+                return (_asc) ? -1 : 1;\n+            if (pk2[i] == null)\n+                return (_asc) ? 1 : -1;\n+            cmp = ((Comparable) pk1[i]).compareTo(pk2[i]);\n+            if (cmp != 0)\n+                return (_asc) ? cmp : -cmp;\n+        }\n+\n+        cmp = pk1.length - pk2.length;\n+        return (_asc) ? cmp : -cmp;\n+    }\n+\n+    /**\n+     * Convert the given state manager's oid to an array of (possibly null)\n+     * primary key values.\n+     */\n+    private static Object[] toPKValues(OpenJPAStateManager sm) {\n+        if (sm.getMetaData().getIdentityType() != ClassMetaData.ID_APPLICATION)\n+            return new Object[]{ sm.getObjectId() };\n+\n+        Object[] pks = ApplicationIds.toPKValues(sm.getObjectId(),\n+            sm.getMetaData());\n+        if (pks == null)\n+            pks = new Object[]{ null };\n+        return pks;\n+    }\n+}"},{"sha":"12e18562756ee1c4cd65fa952818cd2d13927a83","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceComparator.java","status":"added","additions":100,"deletions":0,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceComparator.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceComparator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceComparator.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+/**\n+ * Comparator that keeps classes in inheritance order.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class InheritanceComparator\n+    implements Comparator, Serializable {\n+\n+    private Class _base = Object.class;\n+\n+    /**\n+     * Set the least-derived type possible; defaults to <code>null</code>.\n+     */\n+    public void setBase(Class base) {\n+        _base = base;\n+    }\n+\n+    public Class getBase() {\n+        return _base;\n+    }\n+\n+    /**\n+     * Subclasses can override this method to extract the class to compare\n+     * on from the elements of the collection.\n+     */\n+    protected Class toClass(Object elem) {\n+        return (Class) elem;\n+    }\n+\n+    public int compare(Object o1, Object o2) {\n+        if (o1 == o2)\n+            return 0;\n+        if (o1 == null)\n+            return -1;\n+        if (o2 == null)\n+            return 1;\n+\n+        Class c1 = toClass(o1);\n+        Class c2 = toClass(o2);\n+        if (c1 == c2)\n+            return 0;\n+        if (c1 == null)\n+            return -1;\n+        if (c2 == null)\n+            return 1;\n+\n+        int i1 = levels(c1);\n+        int i2 = levels(c2);\n+        if (i1 == i2) {\n+            // sort simple interfaces as well as simple order test will fail.\n+            if (c1.isAssignableFrom(c2))\n+                return -1;\n+            if (c2.isAssignableFrom(c1))\n+                return 1;\n+            return c1.getName().compareTo(c2.getName());\n+        }\n+        if (i1 < i2)\n+            return -1;\n+        else if (i1 > i2)\n+            return 1;\n+        else\n+            return 0;\n+    }\n+\n+    /**\n+     * Count the levels of inheritance between this class and our base class.\n+     */\n+    private int levels(Class to) {\n+        if (to.isInterface())\n+            return to.getInterfaces().length;\n+        for (int i = 0; to != null; i++, to = to.getSuperclass())\n+            if (to == _base)\n+                return i;\n+        return Integer.MAX_VALUE;\n+    }\n+}"},{"sha":"79376fb717f684e500ec77e09c503c1762ba9259","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceOrderedMetaDataList.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceOrderedMetaDataList.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceOrderedMetaDataList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceOrderedMetaDataList.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.ListIterator;\n+import java.io.Serializable;\n+\n+public class InheritanceOrderedMetaDataList\n+    implements Serializable {\n+\n+    private MetaDataInheritanceComparator _comp\n+        = new MetaDataInheritanceComparator();\n+    private LinkedList<ClassMetaData> buffer = new LinkedList<ClassMetaData>();\n+\n+    public boolean add(ClassMetaData meta) {\n+        if (meta == null || buffer.contains(meta))\n+            return false;\n+        for (ListIterator<ClassMetaData> itr = buffer.listIterator();\n+            itr.hasNext();) {\n+            int ord = _comp.compare(meta, itr.next());\n+            if (ord > 0)\n+                continue;\n+            if (ord == 0)\n+                return false;\n+            itr.previous();\n+            itr.add(meta);\n+            return true;\n+        }\n+        buffer.add(meta);\n+        return true;\n+    }\n+\n+    public boolean remove(ClassMetaData meta) {\n+        return buffer.remove(meta);\n+    }\n+\n+    public ClassMetaData peek() {\n+        return buffer.peek();\n+    }\n+    \n+    public int size() {\n+        return buffer.size();\n+    }\n+    \n+    public Iterator<ClassMetaData> iterator() {\n+        return buffer.iterator();\n+    }\n+    \n+    public boolean isEmpty() {\n+        return buffer.isEmpty();\n+    }\n+    \n+    public void clear() {\n+        buffer.clear();\n+    }\n+}"},{"sha":"5f6fdd2b0e9de608c0f85548dcbface6b5b0daba","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InterfaceImplGenerator.java","status":"added","additions":245,"deletions":0,"changes":245,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InterfaceImplGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InterfaceImplGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InterfaceImplGenerator.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.lang.reflect.Method;\n+import java.io.ByteArrayInputStream;\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.util.Set;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.enhance.PCEnhancer;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\n+import org.apache.openjpa.lib.util.Localizer;\n+import serp.bytecode.BCClass;\n+import serp.bytecode.BCClassLoader;\n+import serp.bytecode.BCField;\n+import serp.bytecode.BCMethod;\n+import serp.bytecode.Code;\n+import serp.bytecode.Constants;\n+import serp.bytecode.Project;\n+\n+/**\n+ * Creates implementations of managed interfaces.  Will throw exceptions\n+ * on unknown properties.\n+ *\n+ * @author Steve Kim\n+ */\n+class InterfaceImplGenerator {\n+    private static final Localizer _loc = Localizer.forPackage\n+        (InterfaceImplGenerator.class);\n+    private static final String POSTFIX = \"openjpaimpl\";\n+\n+    private final MetaDataRepository _repos;\n+    private final Map _impls = new WeakHashMap();\n+    private final Project _project = new Project();\n+ \n+    // distinct project / loader for enhanced version of class\n+    private final Project _enhProject = new Project();\n+\n+    /**\n+     * Constructor.  Supply repository.\n+     */\n+    public InterfaceImplGenerator(MetaDataRepository repos) {\n+        _repos = repos;\n+    }\n+\n+    /**\n+     * Create a concrete implementation of the given type, possibly\n+     * returning a cached version of the class.\n+     */\n+    public synchronized Class createImpl(ClassMetaData meta) {\n+        Class iface = meta.getDescribedType();\n+\n+        // check cache.\n+        Class impl = (Class) _impls.get(iface);\n+        if (impl != null)\n+            return impl;\n+\n+        ClassLoader parentLoader = (ClassLoader) AccessController.doPrivileged(\n+            J2DoPrivHelper.getClassLoaderAction(iface)); \n+        BCClassLoader loader = (BCClassLoader) AccessController\n+            .doPrivileged(J2DoPrivHelper.newBCClassLoaderAction(_project,\n+                parentLoader));\n+        BCClassLoader enhLoader = (BCClassLoader) AccessController\n+            .doPrivileged(J2DoPrivHelper.newBCClassLoaderAction(_enhProject,\n+                parentLoader));\n+        BCClass bc = _project.loadClass(getClassName(meta));\n+        bc.declareInterface(iface);\n+        ClassMetaData sup = meta.getPCSuperclassMetaData();\n+        if (sup != null) {\n+            bc.setSuperclass(sup.getInterfaceImpl());\n+            enhLoader = (BCClassLoader) AccessController\n+                .doPrivileged(J2DoPrivHelper.newBCClassLoaderAction(\n+                    _enhProject, (ClassLoader) AccessController\n+                        .doPrivileged(J2DoPrivHelper.getClassLoaderAction(sup\n+                            .getInterfaceImpl()))));\n+        }\n+\n+        FieldMetaData[] fields = meta.getDeclaredFields();\n+        Set methods = new HashSet();\n+        for (int i = 0; i < fields.length; i++) \n+            addField(bc, iface, fields[i], methods);\n+        invalidateNonBeanMethods(bc, iface, methods);\n+\n+        // first load the base class as the enhancer requires the class\n+        // to be available\n+        try {\n+            meta.setInterfaceImpl(Class.forName(bc.getName(), true, loader));\n+        } catch (Throwable t) {\n+            throw new InternalException(_loc.get(\"interface-load\", iface, \n+                loader), t).setFatal(true);\n+        }\n+        // copy the BCClass into the enhancer project.\n+        bc = _enhProject.loadClass(new ByteArrayInputStream(bc.toByteArray()), \n+            loader);\n+        PCEnhancer enhancer = new PCEnhancer(_repos, bc, meta);\n+\n+        int result = enhancer.run();\n+        if (result != PCEnhancer.ENHANCE_PC)\n+            throw new InternalException(_loc.get(\"interface-badenhance\", \n+                iface)).setFatal(true);\n+        try {\n+            // load the class for real.\n+            impl = Class.forName(bc.getName(), true, enhLoader);\n+        } catch (Throwable t) {\n+            throw new InternalException(_loc.get(\"interface-load2\", iface, \n+                enhLoader), t).setFatal(true);\n+        }\n+        // cache the generated impl.\n+        _impls.put(iface, impl);\n+        return impl;\n+    }\n+\n+    /**\n+     * Add bean getters and setters, also recording seen methods\n+     * into the given set.\n+     */\n+    private void addField (BCClass bc, Class iface, FieldMetaData fmd, \n+        Set methods) {\n+        String name = fmd.getName();\n+        Class type = fmd.getDeclaredType();\n+        BCField field = bc.declareField(name, type);\n+        field.setAccessFlags(Constants.ACCESS_PRIVATE);\n+\n+        // getter\n+        name = StringUtils.capitalize(name);\n+        String prefix = isGetter(iface, fmd) ? \"get\" : \"is\";\n+        BCMethod meth = bc.declareMethod(prefix + name, type, null);\n+        meth.makePublic();\n+        Code code = meth.getCode(true);\n+        code.aload().setThis();\n+        code.getfield().setField(field);\n+        code.xreturn().setType(type);\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+        methods.add(getMethodSafe(iface, meth.getName(), null));\n+\n+        // setter\n+        meth = bc.declareMethod(\"set\" + name, void.class, new Class[]{type});\n+        meth.makePublic();\n+        code = meth.getCode(true);\n+        code.aload().setThis();\n+        code.xload().setParam(0).setType(type);\n+        code.putfield().setField(field);\n+        code.vreturn();\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+        methods.add(getMethodSafe(iface, meth.getName(), type));\n+    }\n+\n+    /**\n+     * Invalidate methods on the interface which are not managed.\n+     */\n+    private void invalidateNonBeanMethods(BCClass bc, Class iface, \n+        Set methods) {\n+        Method[] meths = (Method[]) AccessController.doPrivileged(\n+            J2DoPrivHelper.getDeclaredMethodsAction(iface)); \n+        BCMethod meth;\n+        Code code;\n+        Class type = _repos.getMetaDataFactory().getDefaults().\n+            getUnimplementedExceptionType();\n+        for (int i = 0; i < meths.length; i++) {\n+            if (methods.contains(meths[i]))\n+                continue;\n+            meth = bc.declareMethod(meths[i].getName(), \n+                meths[i].getReturnType(), meths[i].getParameterTypes());\n+            meth.makePublic();\n+            code = meth.getCode(true);\n+            code.anew().setType(type);\n+            code.dup();\n+            code.invokespecial().setMethod(type, \"<init>\", void.class, null);\n+            code.athrow();\n+            code.calculateMaxLocals();\n+            code.calculateMaxStack();\n+        }\n+    }\n+\n+    /**\n+     * Return a unique class name.\n+     */\n+    protected final String getClassName(ClassMetaData meta) {\n+        Class iface = meta.getDescribedType();\n+        return iface.getName() + \"$\" + System.identityHashCode(iface) + POSTFIX;\n+    }\n+\n+    /**\n+     * Convenience method to return the given method / arg.\n+     */\n+    private static Method getMethodSafe(Class iface, String name, Class arg) {\n+        try {\n+            return (Method) AccessController.doPrivileged(\n+                J2DoPrivHelper.getDeclaredMethodAction(\n+                    iface, name, arg == null ? null : new Class[]{arg}));\n+        } catch (PrivilegedActionException pae) {\n+            throw new InternalException (_loc.get (\"interface-mismatch\", name));\n+        }\n+    }\n+\n+    private static boolean isGetter(Class iface, FieldMetaData fmd) {\n+        if (fmd.getType() != boolean.class && fmd.getType() != Boolean.class)\n+            return true;\n+        try {\n+            Method meth = (Method) AccessController.doPrivileged(\n+                J2DoPrivHelper.getDeclaredMethodAction(iface, \"is\" +\n+                    StringUtils.capitalize(fmd.getName()), (Class[]) null));\n+            return meth == null;\n+        } catch (PrivilegedActionException pae) {}\n+        return true;\n+    }\n+\n+    boolean isImplType(Class cls) {\n+        return (cls.getName().endsWith(POSTFIX)\n+            && cls.getName().indexOf('$') != -1);\n+    }\n+\n+    public Class toManagedInterface(Class cls) {\n+        Class[] ifaces = cls.getInterfaces();\n+        for (int i = 0; i < ifaces.length; i++) {\n+            if (_impls.get(ifaces[i]) == cls)\n+                return ifaces[i];\n+        }\n+        throw new IllegalArgumentException(cls.getName());\n+    }\n+}"},{"sha":"26606eb15491d3bca6a748d8c840426fee6e93af","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/JavaTypes.java","status":"added","additions":437,"deletions":0,"changes":437,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/JavaTypes.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/JavaTypes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/JavaTypes.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,437 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.lib.meta.CFMetaDataParser;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.MetaDataException;\n+import serp.util.Numbers;\n+import serp.util.Strings;\n+\n+/**\n+ * Type constants for managed fields.\n+ *\n+ * @author Abe White\n+ */\n+public class JavaTypes {\n+\n+    public static final int BOOLEAN = 0;\n+    public static final int BYTE = 1;\n+    public static final int CHAR = 2;\n+    public static final int DOUBLE = 3;\n+    public static final int FLOAT = 4;\n+    public static final int INT = 5;\n+    public static final int LONG = 6;\n+    public static final int SHORT = 7;\n+    // keep OBJECT as first non-primitive type code; other code relies on it\n+    public static final int OBJECT = 8;\n+    public static final int STRING = 9;\n+    public static final int NUMBER = 10;\n+    public static final int ARRAY = 11;\n+    public static final int COLLECTION = 12;\n+    public static final int MAP = 13;\n+    public static final int DATE = 14;\n+    public static final int PC = 15;\n+    public static final int BOOLEAN_OBJ = 16;\n+    public static final int BYTE_OBJ = 17;\n+    public static final int CHAR_OBJ = 18;\n+    public static final int DOUBLE_OBJ = 19;\n+    public static final int FLOAT_OBJ = 20;\n+    public static final int INT_OBJ = 21;\n+    public static final int LONG_OBJ = 22;\n+    public static final int SHORT_OBJ = 23;\n+    public static final int BIGDECIMAL = 24;\n+    public static final int BIGINTEGER = 25;\n+    public static final int LOCALE = 26;\n+    public static final int PC_UNTYPED = 27;\n+    public static final int CALENDAR = 28;\n+    public static final int OID = 29;\n+    public static final int INPUT_STREAM = 30;\n+    public static final int INPUT_READER = 31;\n+\n+    private static final Localizer _loc = Localizer.forPackage(JavaTypes.class);\n+\n+    private static final Map _typeCodes = new HashMap();\n+\n+    static {\n+        _typeCodes.put(String.class, Numbers.valueOf(STRING));\n+        _typeCodes.put(Boolean.class, Numbers.valueOf(BOOLEAN_OBJ));\n+        _typeCodes.put(Byte.class, Numbers.valueOf(BYTE_OBJ));\n+        _typeCodes.put(Character.class, Numbers.valueOf(CHAR_OBJ));\n+        _typeCodes.put(Double.class, Numbers.valueOf(DOUBLE_OBJ));\n+        _typeCodes.put(Float.class, Numbers.valueOf(FLOAT_OBJ));\n+        _typeCodes.put(Integer.class, Numbers.valueOf(INT_OBJ));\n+        _typeCodes.put(Long.class, Numbers.valueOf(LONG_OBJ));\n+        _typeCodes.put(Short.class, Numbers.valueOf(SHORT_OBJ));\n+        _typeCodes.put(Date.class, Numbers.valueOf(DATE));\n+        _typeCodes.put(java.sql.Date.class, Numbers.valueOf(DATE));\n+        _typeCodes.put(java.sql.Timestamp.class, Numbers.valueOf(DATE));\n+        _typeCodes.put(java.sql.Time.class, Numbers.valueOf(DATE));\n+        _typeCodes.put(BigInteger.class, Numbers.valueOf(BIGINTEGER));\n+        _typeCodes.put(BigDecimal.class, Numbers.valueOf(BIGDECIMAL));\n+        _typeCodes.put(Number.class, Numbers.valueOf(NUMBER));\n+        _typeCodes.put(Locale.class, Numbers.valueOf(LOCALE));\n+        _typeCodes.put(Object.class, Numbers.valueOf(OBJECT));\n+        _typeCodes.put(PersistenceCapable.class, Numbers.valueOf(PC_UNTYPED));\n+        _typeCodes.put(Properties.class, Numbers.valueOf(MAP));\n+        _typeCodes.put(Calendar.class, Numbers.valueOf(CALENDAR));\n+    }\n+\n+    /**\n+     * Return the field metadata type code for the given class. First class\n+     * objects are not recognized in this method.\n+     */\n+    public static int getTypeCode(Class type) {\n+        if (type == null)\n+            return OBJECT;\n+\n+        if (type.isPrimitive()) {\n+            switch (type.getName().charAt(0)) {\n+                case 'b':\n+                    return (type == boolean.class) ? BOOLEAN : BYTE;\n+                case 'c':\n+                    return CHAR;\n+                case 'd':\n+                    return DOUBLE;\n+                case 'f':\n+                    return FLOAT;\n+                case 'i':\n+                    return INT;\n+                case 'l':\n+                    return LONG;\n+                case 's':\n+                    return SHORT;\n+            }\n+        }\n+\n+        Integer code = (Integer) _typeCodes.get(type);\n+        if (code != null)\n+            return code.intValue();\n+\n+        // have to do this first to catch custom collection and map types;\n+        // on resolve we figure out if these custom types are\n+        // persistence-capable\n+        if (Collection.class.isAssignableFrom(type))\n+            return COLLECTION;\n+        if (Map.class.isAssignableFrom(type))\n+            return MAP;\n+        if (type.isArray())\n+            return ARRAY;\n+        if (Calendar.class.isAssignableFrom(type))\n+            return CALENDAR;\n+\n+        if (type.isInterface()) {\n+            if (type == Serializable.class)\n+                return OBJECT;\n+            return PC_UNTYPED;\n+        }\n+        if (type.isAssignableFrom(Reader.class))\n+            return INPUT_READER;\n+        if (type.isAssignableFrom (InputStream.class))\n+            return INPUT_STREAM;\n+            \n+        return OBJECT;\n+    }\n+ \n+    /**\n+     * Check the given name against the same set of standard packages used\n+     * when parsing metadata.\n+     */\n+    public static Class classForName(String name, ClassMetaData context) {\n+        return classForName(name, context, null);\n+    }\n+\n+    /**\n+     * Check the given name against the same set of standard packages used\n+     * when parsing metadata.\n+     */\n+    public static Class classForName(String name, ClassMetaData context,\n+        ClassLoader loader) {\n+        return classForName(name, context, context.getDescribedType(), null,\n+            loader);\n+    }\n+\n+    /**\n+     * Check the given name against the same set of standard packages used\n+     * when parsing metadata.\n+     */\n+    public static Class classForName(String name, ValueMetaData context) {\n+        return classForName(name, context, null);\n+    }\n+\n+    /**\n+     * Check the given name against the same set of standard packages used\n+     * when parsing metadata.\n+     */\n+    public static Class classForName(String name, ValueMetaData context,\n+        ClassLoader loader) {\n+        return classForName(name,\n+            context.getFieldMetaData().getDefiningMetaData(),\n+            context.getFieldMetaData().getDeclaringType(), context, loader);\n+    }\n+\n+    /**\n+     * Check the given name against the same set of standard packages used\n+     * when parsing metadata.\n+     */\n+    private static Class classForName(String name, ClassMetaData meta,\n+        Class dec, ValueMetaData vmd, ClassLoader loader) {\n+        // special case for PersistenceCapable and Object\n+        if (\"PersistenceCapable\".equals(name)\n+            || \"javax.jdo.PersistenceCapable\".equals(name)) // backwards compat\n+            return PersistenceCapable.class;\n+        if (\"Object\".equals(name))\n+            return Object.class;\n+\n+        MetaDataRepository rep = meta.getRepository();\n+        boolean runtime = (rep.getValidate() & rep.VALIDATE_RUNTIME) != 0;\n+        if (loader == null)\n+            loader = rep.getConfiguration().getClassResolverInstance().\n+                getClassLoader(dec, meta.getEnvClassLoader());\n+\n+        // try the owner's package\n+        String pkg = Strings.getPackageName(dec);\n+        Class cls = CFMetaDataParser.classForName(name, pkg, runtime, loader);\n+        if (cls == null && vmd != null) {\n+            // try against this value type's package too\n+            pkg = Strings.getPackageName(vmd.getDeclaredType());\n+            cls = CFMetaDataParser.classForName(name, pkg, runtime, loader);\n+        }\n+        if (cls == null)\n+            throw new MetaDataException(_loc.get(\"bad-class\", name,\n+                (vmd == null) ? (Object) meta : (Object) vmd));\n+        return cls;\n+    }\n+\n+    /**\n+     * Convert the given object to the given type if possible. If the type is\n+     * a numeric primitive, this method only guarantees that the return value\n+     * is a {@link Number}. If no known conversion or the value is null,\n+     * returns the original value.\n+     */\n+    public static Object convert(Object val, int typeCode) {\n+        if (val == null)\n+            return null;\n+\n+        switch (typeCode) {\n+            case BIGDECIMAL:\n+                if (val instanceof BigDecimal)\n+                    return val;\n+                if (val instanceof Number)\n+                    return new BigDecimal(((Number) val).doubleValue());\n+                if (val instanceof String)\n+                    return new BigDecimal(val.toString());\n+                return val;\n+            case BIGINTEGER:\n+                if (val instanceof BigInteger)\n+                    return val;\n+                if (val instanceof Number || val instanceof String)\n+                    return new BigInteger(val.toString());\n+                return val;\n+            case BOOLEAN:\n+            case BOOLEAN_OBJ:\n+                if (val instanceof String)\n+                    return Boolean.valueOf(val.toString());\n+                return val;\n+            case BYTE_OBJ:\n+                if (val instanceof Byte)\n+                    return val;\n+                if (val instanceof Number)\n+                    return new Byte(((Number) val).byteValue());\n+                // no break\n+            case BYTE:\n+                if (val instanceof String)\n+                    return new Byte(val.toString());\n+                return val;\n+            case CHAR:\n+            case CHAR_OBJ:\n+                if (val instanceof Character)\n+                    return val;\n+                if (val instanceof String)\n+                    return new Character(val.toString().charAt(0));\n+                if (val instanceof Number)\n+                    return new Character((char) ((Number) val).intValue());\n+                return val;\n+            case DATE:\n+                if (val instanceof String)\n+                    return new Date(val.toString());\n+                return val;\n+            case DOUBLE_OBJ:\n+                if (val instanceof Double)\n+                    return val;\n+                if (val instanceof Number)\n+                    return new Double(((Number) val).doubleValue());\n+                // no break\n+            case DOUBLE:\n+                if (val instanceof String)\n+                    return new Double(val.toString());\n+                return val;\n+            case FLOAT_OBJ:\n+                if (val instanceof Float)\n+                    return val;\n+                if (val instanceof Number)\n+                    return new Float(((Number) val).floatValue());\n+                // no break\n+            case FLOAT:\n+                if (val instanceof String)\n+                    return new Float(val.toString());\n+                return val;\n+            case INT_OBJ:\n+                if (val instanceof Integer)\n+                    return val;\n+                if (val instanceof Number)\n+                    return Numbers.valueOf(((Number) val).intValue());\n+                // no break\n+            case INT:\n+                if (val instanceof String)\n+                    return new Integer(val.toString());\n+                return val;\n+            case LONG_OBJ:\n+                if (val instanceof Long)\n+                    return val;\n+                if (val instanceof Number)\n+                    return Numbers.valueOf(((Number) val).longValue());\n+                // no break\n+            case LONG:\n+                if (val instanceof String)\n+                    return new Long(val.toString());\n+                return val;\n+            case NUMBER:\n+                if (val instanceof Number)\n+                    return val;\n+                if (val instanceof String)\n+                    return new BigDecimal(val.toString());\n+                return val;\n+            case SHORT_OBJ:\n+                if (val instanceof Short)\n+                    return val;\n+                if (val instanceof Number)\n+                    return new Short(((Number) val).shortValue());\n+                // no break\n+            case SHORT:\n+                if (val instanceof String)\n+                    return new Short(val.toString());\n+                return val;\n+            case STRING:\n+                return val.toString();\n+            default:\n+                return val;\n+        }\n+    }\n+\n+    /**\n+     * Return true if the (possibly unresolved) field or its elements might be\n+     * persistence capable objects.\n+     */\n+    public static boolean maybePC(FieldMetaData field) {\n+        switch (field.getDeclaredTypeCode()) {\n+            case JavaTypes.ARRAY:\n+            case JavaTypes.COLLECTION:\n+                return maybePC(field.getElement());\n+            case JavaTypes.MAP:\n+                return maybePC(field.getKey()) || maybePC(field.getElement());\n+            default:\n+                return maybePC((ValueMetaData) field);\n+        }\n+    }\n+\n+    /**\n+     * Return true if the (possibly unresolved) value might be a first class\n+     * object.\n+     */\n+    public static boolean maybePC(ValueMetaData val) {\n+        return maybePC(val.getDeclaredTypeCode(), val.getDeclaredType());\n+    }\n+\n+    /**\n+     * Return true if the given unresolved typecode/type pair may represent a\n+     * persistent object.\n+     */\n+    static boolean maybePC(int typeCode, Class type) {\n+        if (type == null)\n+            return false;\n+        switch (typeCode) {\n+            case JavaTypes.OBJECT:\n+            case JavaTypes.PC:\n+            case JavaTypes.PC_UNTYPED:\n+                return true;\n+            case JavaTypes.COLLECTION:\n+            case JavaTypes.MAP:\n+                return !type.getName().startsWith(\"java.util.\");\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Helper method to return the given array value as a collection.\n+     */\n+    public static List toList(Object val, Class elem, boolean mutable) {\n+        if (val == null)\n+            return null;\n+\n+        List l;\n+        if (!elem.isPrimitive()) {\n+            // if an object array, use built-in list function\n+            l = Arrays.asList((Object[]) val);\n+            if (mutable)\n+                l = new ArrayList(l);\n+        } else {\n+            // convert to list of wrapper objects\n+            int length = Array.getLength(val);\n+            l = new ArrayList(length);\n+            for (int i = 0; i < length; i++)\n+                l.add(Array.get(val, i));\n+        }\n+        return l;\n+    }\n+\n+    /**\n+     * Helper method to return the given collection as an array.\n+     */\n+    public static Object toArray(Collection coll, Class elem) {\n+        if (coll == null)\n+            return null;\n+\n+        Object array = Array.newInstance(elem, coll.size());\n+        int idx = 0;\n+        for (Iterator itr = coll.iterator(); itr.hasNext(); idx++)\n+            Array.set(array, idx, itr.next ());\n+\t\treturn array;\n+\t}\n+}"},{"sha":"998005db9cf0a8786487be1dfae7a9302b2bf235","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/LifecycleMetaData.java","status":"added","additions":257,"deletions":0,"changes":257,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/LifecycleMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/LifecycleMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/LifecycleMetaData.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,257 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.openjpa.event.LifecycleCallbacks;\n+import org.apache.openjpa.event.LifecycleEvent;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.InternalException;\n+\n+/**\n+ * Information about lifecycle events for a managed type.\n+ *\n+ * @author Steve Kim\n+ * @author Abe White\n+ */\n+public class LifecycleMetaData\n+    implements Serializable {\n+\n+    public static final int IGNORE_NONE = 0;\n+    public static final int IGNORE_HIGH = 2 << 0;\n+    public static final int IGNORE_LOW = 2 << 1;\n+\n+    private static final LifecycleCallbacks[] EMPTY_CALLBACKS =\n+        new LifecycleCallbacks[0];\n+    private static final Localizer _loc = Localizer.forPackage\n+        (LifecycleMetaData.class);\n+\n+    private final ClassMetaData _meta;\n+    private LifecycleCallbacks[][] _declared = null;\n+    private LifecycleCallbacks[][] _super = null;\n+    private LifecycleCallbacks[][] _all = null;\n+    private int[] _high = null;\n+    private int[] _superHigh = null;\n+    private boolean _resolved = false;\n+    private boolean _ignoreSystem = false;\n+    private int _ignoreSups = 0;\n+\n+    /**\n+     * Construct with owning metadata.\n+     */\n+    LifecycleMetaData(ClassMetaData meta) {\n+        _meta = meta;\n+    }\n+\n+    /**\n+     * Whether to exclude system listeners from events.\n+     */\n+    public boolean getIgnoreSystemListeners() {\n+        return _ignoreSystem;\n+    }\n+\n+    /**\n+     * Whether to exclude system listeners from events.\n+     */\n+    public void setIgnoreSystemListeners(boolean ignore) {\n+        _ignoreSystem = ignore;\n+    }\n+\n+    /**\n+     * Whether to exclude superclass callbacks from events.\n+     */\n+    public int getIgnoreSuperclassCallbacks() {\n+        return _ignoreSups;\n+    }\n+\n+    /**\n+     * Whether to exclude superclass callbacks from events.\n+     */\n+    public void setIgnoreSuperclassCallbacks(int ignore) {\n+        _ignoreSups = ignore;\n+    }\n+\n+    /**\n+     * Return the declared callbacks for the given event type.\n+     */\n+    public LifecycleCallbacks[] getDeclaredCallbacks(int eventType) {\n+        return (_declared == null || _declared[eventType] == null)\n+            ? EMPTY_CALLBACKS : _declared[eventType];\n+    }\n+\n+    /**\n+     * Return all callbacks for the given event type, including superclass\n+     * callbacks if appropriate.\n+     */\n+    public LifecycleCallbacks[] getCallbacks(int eventType) {\n+        resolve();\n+        return (_all == null || _all[eventType] == null)\n+            ? EMPTY_CALLBACKS : _all[eventType];\n+    }\n+\n+    /**\n+     * Set the callbacks for the given event type.\n+     *\n+     * @param highPriority the first N given callbacks are high priority;\n+     * high priority callbacks will be returned before\n+     * non-high-priority superclass callbacks\n+     */\n+    public void setDeclaredCallbacks(int eventType,\n+        LifecycleCallbacks[] callbacks, int highPriority) {\n+        if (_resolved)\n+            throw new InternalException(_loc.get(\"lifecycle-resolved\",\n+                _meta, Arrays.asList(callbacks)));\n+\n+        if (_declared == null) {\n+            _declared = new LifecycleCallbacks\n+                [LifecycleEvent.ALL_EVENTS.length][];\n+            _high = new int[LifecycleEvent.ALL_EVENTS.length];\n+        }\n+        _declared[eventType] = callbacks;\n+        _high[eventType] = highPriority;\n+    }\n+\n+    /**\n+     * Return the callbacks for the non-PC superclass.\n+     */\n+    public LifecycleCallbacks[] getNonPCSuperclassCallbacks\n+        (int eventType) {\n+        return (_super == null || _super[eventType] == null)\n+            ? EMPTY_CALLBACKS : _super[eventType];\n+    }\n+\n+    /**\n+     * Set the callbacks for the given event type for non-persistent\n+     * superclass. Note these callbacks will only be used where the\n+     * non-persistent superclass is the direct ancestor of the described class.\n+     *\n+     * @param highPriority the first N given callbacks are high priority;\n+     * high priority callbacks will be returned before\n+     * non-high-priority superclass callbacks\n+     */\n+    public void setNonPCSuperclassCallbacks(int eventType,\n+        LifecycleCallbacks[] callbacks, int highPriority) {\n+        if (_resolved)\n+            throw new InternalException(_loc.get(\"lifecycle-resolved\",\n+                _meta, Arrays.asList(callbacks)));\n+\n+        if (_super == null) {\n+            _super = new LifecycleCallbacks\n+                [LifecycleEvent.ALL_EVENTS.length][];\n+            _superHigh = new int[LifecycleEvent.ALL_EVENTS.length];\n+        }\n+        _super[eventType] = callbacks;\n+        _superHigh[eventType] = highPriority;\n+    }\n+\n+    /**\n+     * Resolve all callbacks.\n+     */\n+    void resolve() {\n+        if (!_resolved) {\n+            _all = combineCallbacks();\n+            _resolved = true;\n+        }\n+    }\n+\n+    /**\n+     * Combine our callbacks with superclass callbacks as necessary.\n+     * This method has the side effect of manipulating the _high array to\n+     * reflect the combined callbacks rather than the declared ones.\n+     */\n+    private LifecycleCallbacks[][] combineCallbacks() {\n+        if (_ignoreSups == (IGNORE_HIGH | IGNORE_LOW))\n+            return _declared;\n+\n+        LifecycleMetaData supMeta = (_meta.getPCSuperclass() == null) ? null\n+            : _meta.getPCSuperclassMetaData().getLifecycleMetaData();\n+        if (supMeta == null && _super == null)\n+            return _declared;\n+\n+        if (supMeta != null) {\n+            supMeta.resolve();\n+            if (supMeta._all == null)\n+                return _declared;\n+            if (_declared == null && _ignoreSups == 0) {\n+                _high = supMeta._high;\n+                return supMeta._all;\n+            }\n+            // don't hold strong refs onto redundant info\n+            _super = null;\n+            _superHigh = null;\n+        }\n+\n+        LifecycleCallbacks[][] all = new LifecycleCallbacks\n+            [LifecycleEvent.ALL_EVENTS.length][];\n+        LifecycleCallbacks[] decs, sups;\n+        int supStart, supEnd, supHigh;\n+        int count;\n+        for (int i = 0; i < all.length; i++) {\n+            decs = getDeclaredCallbacks(i);\n+            if (supMeta == null) {\n+                sups = (_super[i] == null) ? EMPTY_CALLBACKS : _super[i];\n+                supHigh = (_superHigh == null) ? 0 : _superHigh[i];\n+            } else {\n+                sups = supMeta.getCallbacks(i);\n+                supHigh = (supMeta._high == null) ? 0 : supMeta._high[i];\n+            }\n+            supStart = ((_ignoreSups & IGNORE_HIGH) != 0) ? supHigh : 0;\n+            supEnd = ((_ignoreSups & IGNORE_LOW) != 0) ? supHigh : sups.length;\n+\n+            if (supEnd - supStart == 0)\n+                all[i] = decs;\n+            else if (decs.length == 0) {\n+                if (supEnd - supStart == sups.length)\n+                    all[i] = sups;\n+                else {\n+                    all[i] = new LifecycleCallbacks[supEnd - supStart];\n+                    System.arraycopy(sups, supStart, all[i], 0, all[i].length);\n+                }\n+                if (_high == null)\n+                    _high = new int[all.length];\n+                _high[i] = supHigh - supStart;\n+            } else {\n+                all[i] =\n+                    new LifecycleCallbacks[decs.length + supEnd - supStart];\n+                count = 0;\n+\n+                // add superclass high priority callbacks first\n+                if ((_ignoreSups & IGNORE_HIGH) == 0)\n+                    for (int j = 0; j < supHigh; j++)\n+                        all[i][count++] = sups[j];\n+                // then our high priority\n+                for (int j = 0; j < _high[i]; j++)\n+                    all[i][count++] = decs[j];\n+                // then superclass low priority\n+                if ((_ignoreSups & IGNORE_LOW) == 0)\n+                    for (int j = supHigh; j < sups.length; j++)\n+                        all[i][count++] = sups[j];\n+                // then our low priority\n+                for (int j = _high[i]; j < decs.length; j++)\n+                    all[i][count++] = decs[j];\n+\n+                if ((_ignoreSups & IGNORE_HIGH) == 0)\n+                    _high[i] += supHigh;\n+\t\t\t}\n+\t\t}\n+\t\treturn all;\n+\t}\n+}"},{"sha":"942ca402d5c4810db22bf2d7b5dd9bbd4cdc1405","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataContext.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataContext.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataContext.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataContext.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+/**\n+ * Allows us to access configuration through metadata in a generic way.\n+ *\n+ * @author Abe White\n+ */\n+public interface MetaDataContext {\n+\n+    /**\n+     * Access metadata repository.\n+     */\n+    public MetaDataRepository getRepository();\n+}"},{"sha":"a3aec0a42e8915f6a7b07072cb64d04086386e86","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataDefaults.java","status":"added","additions":92,"deletions":0,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataDefaults.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653","patch":"@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.lang.reflect.Member;\n+\n+import org.apache.openjpa.event.CallbackModes;\n+\n+/**\n+ * Populates new metadata with default values.\n+ *\n+ * @author Abe White\n+ */\n+public interface MetaDataDefaults\n+    extends CallbackModes {\n+\n+    /**\n+     * Return the default access type for a base persistent class with\n+     * {@link ClassMetaData#ACCESS_UNKNOWN} access type.\n+     */\n+    public int getDefaultAccessType();\n+\n+    /**\n+     * Return the default identity type for unmapped classes without primary\n+     * key fields.\n+     */\n+    public int getDefaultIdentityType();\n+\n+    /**\n+     * What to do on lifecycle callback exceptions.\n+     */\n+    public int getCallbackMode();\n+\n+    /**\n+     * If callbacks are fired before listeners for the given\n+     * event type. Defaults to false.\n+     */\n+    public boolean getCallbacksBeforeListeners(int type);\n+   \n+    /**\n+     * Whether declared interfaces of a class are treated as persistent\n+     * types. Defaults to true.\n+     */\n+    public boolean isDeclaredInterfacePersistent();\n+\n+    /**\n+     * Whether the field in the object id class corresponding to a \n+     * datastore id persistence-capable primary key field is the simple \n+     * datastore id value of the related instance.  Defaults to false.\n+     */\n+    public boolean isDataStoreObjectIdFieldUnwrapped();\n+ \n+    /**\n+     * Whether to ignore members which are not persistent by default\n+     * during metadata population. Defaults to true.\n+     */\n+    public void setIgnoreNonPersistent(boolean ignore);\n+\n+    /**\n+     * Populate the given metadata with default settings.\n+     *\n+     * @param access access type constant from {@link ClassMetaData}\n+     */\n+    public void populate(ClassMetaData meta, int access);\n+\n+    /**\n+     * Return the backing member for the given field metadata.\n+     */\n+    public Member getBackingMember(FieldMetaData field);\n+\n+    /**\n+     * Return a runtime exception class to throw for un-implemented\n+     * managed interface methods.\n+     */\n+    public Class getUnimplementedExceptionType();\n+}"},{"sha":"cc14ca852ac44589e4b9726fca13dbc7d18ca23c","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataFactory.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataFactory.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"13e72dec8242f68f9ef29850f1a443617ea8f644","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataInheritanceComparator.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataInheritanceComparator.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataInheritanceComparator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataInheritanceComparator.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"3210b0598ca31a550682609529495933b0b1de8c","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataModes.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataModes.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataModes.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"1b5845769d80a1ba85922d93ec1d8be73f420fcf","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","status":"added","additions":1986,"deletions":0,"changes":1986,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"9b2b9bc02217b173c0e6a4b7f18a46a018f813ee","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataTool.java","status":"added","additions":351,"deletions":0,"changes":351,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataTool.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataTool.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"81ff89e965d4f7eb88a21078e947ba152a6c5509","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","status":"added","additions":149,"deletions":0,"changes":149,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"2aa78483341c27ba44152e97dd26e04335e75f16","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NoneMetaDataFactory.java","status":"added","additions":140,"deletions":0,"changes":140,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NoneMetaDataFactory.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NoneMetaDataFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NoneMetaDataFactory.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"977927cf64ef2ef021d1fa828bed2270dda4383a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/Order.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/Order.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/Order.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/Order.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"9fe2390054558e6e27670c4c2c9739de0f846d3d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ProxySetupStateManager.java","status":"added","additions":302,"deletions":0,"changes":302,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ProxySetupStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ProxySetupStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ProxySetupStateManager.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"948f144cb61266db5605ac08ee850052ead36b87","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/QueryMetaData.java","status":"added","additions":296,"deletions":0,"changes":296,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/QueryMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/QueryMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/QueryMetaData.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"d575c364b8e5616527bfd6e11a1338e5be1cf8ba","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/SequenceMetaData.java","status":"added","additions":391,"deletions":0,"changes":391,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/SequenceMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/SequenceMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/SequenceMetaData.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"1c00782dbcb888ab296e0064ce00d5b4190f6944","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/UpdateStrategies.java","status":"added","additions":92,"deletions":0,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/UpdateStrategies.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/UpdateStrategies.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/UpdateStrategies.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"ffe7ef46aa4fff2ec6ef64e9dcd59273ae1cde4f","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaData.java","status":"added","additions":305,"deletions":0,"changes":305,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaData.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"51cfe2e2cc106f269b153aef9f562169745d9887","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaDataImpl.java","status":"added","additions":460,"deletions":0,"changes":460,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaDataImpl.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaDataImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaDataImpl.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"8704a443acdeb3af91d2b0393fa188d4642bc293","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueStrategies.java","status":"added","additions":157,"deletions":0,"changes":157,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueStrategies.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueStrategies.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueStrategies.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"61a3c79828bbf75ab96047262702e6ba685e405d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLClassMetaData.java","status":"added","additions":125,"deletions":0,"changes":125,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLClassMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLClassMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLClassMetaData.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"179fbd602f30a8c59703ab258d8f59055cfe92ff","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLFieldMetaData.java","status":"added","additions":122,"deletions":0,"changes":122,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLFieldMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLFieldMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLFieldMetaData.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"f315012120fbdb96d291cdf75e1812cf6982c39f","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLMetaData.java","status":"added","additions":123,"deletions":0,"changes":123,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLMetaData.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"f58f387537554f7108ca3b7ae0e852f887dc3f46","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/package.html","status":"added","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/package.html","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/meta/package.html?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"d7ec2d10fc3e2f8d5dddf66dd260936046c72ff8","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractChangeTracker.java","status":"added","additions":236,"deletions":0,"changes":236,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractChangeTracker.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractChangeTracker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractChangeTracker.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"7b23b88dd42f172ef63128259cc6412d5f02d216","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyCollection.java","status":"added","additions":427,"deletions":0,"changes":427,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyCollection.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyCollection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyCollection.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"299af7bc682b289fc4e7f0c85d1e6a90a619abe1","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyMap.java","status":"added","additions":527,"deletions":0,"changes":527,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyMap.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/AbstractLRSProxyMap.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"32c2c7b4cbaf5f54079b1d2179333466a878f019","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java","status":"added","additions":614,"deletions":0,"changes":614,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"51e546ddd3b388326d97f22afa46a42120a4ed28","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ArrayStateImage.java","status":"added","additions":107,"deletions":0,"changes":107,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ArrayStateImage.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ArrayStateImage.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ArrayStateImage.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"529b9f0d84b79fefc7ddb0394f741fa15e81a4a7","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"95e9053a0ad3468683cb3ff778fc9f13454b797f","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"1810bfe44fd5c04502c6ed5dda6e774c56491ae5","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ByteId.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ByteId.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ByteId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ByteId.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"123e96a3c145bcc4db5ae18b6d89ea4046682f1a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","status":"added","additions":642,"deletions":0,"changes":642,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"a203280ceff720247a979ba860dbe7db36f0db89","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CallbackException.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CallbackException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CallbackException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CallbackException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"a810e7c8534089067fb3299dcd1650b32e983c98","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ChangeTracker.java","status":"added","additions":89,"deletions":0,"changes":89,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ChangeTracker.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ChangeTracker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ChangeTracker.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"7c8dfb57d79dfb86385063e2c7b7fa9df1540476","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CharId.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CharId.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CharId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CharId.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"9c506f3d0b042a084b5302643ca7aff42a84c8e5","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolver.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolver.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolver.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolver.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"a325a69ea4c8bfe8854d73df5e1eb86a6e0fcc03","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolverImpl.java","status":"added","additions":68,"deletions":0,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolverImpl.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolverImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolverImpl.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"2236764daf200c4b0417b4c262702088713c1a68","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CollectionChangeTracker.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CollectionChangeTracker.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CollectionChangeTracker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CollectionChangeTracker.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"4412c911a19c2aeba3ad1679c8ec60050dae2199","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CollectionChangeTrackerImpl.java","status":"added","additions":126,"deletions":0,"changes":126,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CollectionChangeTrackerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CollectionChangeTrackerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/CollectionChangeTrackerImpl.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"3badaff62d459f2a4ad15743c0ac1b2722815f58","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/DateId.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/DateId.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/DateId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/DateId.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"9929872c8a9c037223d22cc9035ee5e508f8fee3","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/DoubleId.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/DoubleId.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/DoubleId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/DoubleId.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"6c514d6cc922acafbc9b822ddc4a2c743bdd7673","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ExceptionInfo.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ExceptionInfo.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ExceptionInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ExceptionInfo.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"2d6bfe5dcc6c48e857870ba27f56e65182bc0a70","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Exceptions.java","status":"added","additions":268,"deletions":0,"changes":268,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Exceptions.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Exceptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Exceptions.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"981e4530ac8bcdbaef4e4a48329c0c796cb7d436","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/FloatId.java","status":"added","additions":68,"deletions":0,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/FloatId.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/FloatId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/FloatId.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"d56d783b728eb45963af9c4a9946f14d308345b3","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneralException.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneralException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneralException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneralException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"4dd235aa638ebe8f7a721162e9ebdfea5a2e6438","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","status":"added","additions":92,"deletions":0,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"f13b8bad1a54cf155723df8693bd9a5e52f49c21","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Id.java","status":"added","additions":156,"deletions":0,"changes":156,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Id.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Id.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Id.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"7f6b2f25d3e3b800dc958c345c19797ccc032339","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","status":"added","additions":326,"deletions":0,"changes":326,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"876dbc7604ad42c9b7bb77110cb12f4114b58c47","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/IntId.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/IntId.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/IntId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/IntId.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"ad661436bbcad3f6d6c078118aee43a6dad5f8ab","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/InternalException.java","status":"added","additions":64,"deletions":0,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/InternalException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/InternalException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/InternalException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"f0d67467ac50791b6248dd8f41794bd38740c918","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/InvalidStateException.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/InvalidStateException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/InvalidStateException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/InvalidStateException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"b794c7666f628dd137c4a4965079111c0eae2a5f","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/LRSProxy.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/LRSProxy.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/LRSProxy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/LRSProxy.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"82fa32a092a2e9f70ad0b58a43b01969e1ff3b01","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/LockException.java","status":"added","additions":88,"deletions":0,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/LockException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/LockException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/LockException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"abca0d9a0dbdb8d3490ae4e00736759963d96576","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/LongId.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/LongId.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/LongId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/LongId.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"4d41050d4d276c81377dc1f5fa1986b47d508118","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/MapChangeTracker.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/MapChangeTracker.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/MapChangeTracker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/MapChangeTracker.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"a047c6becb19e72ffbcf0ba1dc80476bddf26730","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/MapChangeTrackerImpl.java","status":"added","additions":132,"deletions":0,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/MapChangeTrackerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/MapChangeTrackerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/MapChangeTrackerImpl.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"884646ecfe2dab48a19c731f72ac1259c2a7324a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/MetaDataException.java","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/MetaDataException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/MetaDataException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/MetaDataException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"473bdaa36b13545d7ad7b628503d777a5f73660f","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/MultiLoaderClassResolver.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/MultiLoaderClassResolver.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/MultiLoaderClassResolver.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/MultiLoaderClassResolver.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"46e2100940874156d1980173394d5439da4554de","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/NoResultException.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/NoResultException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/NoResultException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/NoResultException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"973fa0bfd3e55837f7380ceefbadb7dcd01cc211","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/NoTransactionException.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/NoTransactionException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/NoTransactionException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/NoTransactionException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"96ab1b3f4e6512100c03c418520a8901e7efac67","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/NonUniqueResultException.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/NonUniqueResultException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/NonUniqueResultException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/NonUniqueResultException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"74d1c020a649aad2d04e91b91a6640adbffb02a2","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectExistsException.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectExistsException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectExistsException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectExistsException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"50696dbabb30d080f00e07825a0f63a9dc7e0baa","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectId.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectId.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectId.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"875d8768af95223cb5b117a3b9d034061118b7d3","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectNotFoundException.java","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectNotFoundException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectNotFoundException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ObjectNotFoundException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"d50d409741c828e9084e55c41deb8256090b0c8e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAException.java","status":"added","additions":202,"deletions":0,"changes":202,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"8879de04bde32573ee2ecdaa251926c75b0bf7a9","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","status":"added","additions":148,"deletions":0,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"ebd249e1e71dfe2ab6f2e0a612ff5fad24f0f692","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/OptimisticException.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/OptimisticException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/OptimisticException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/OptimisticException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"bd2fd656ffeb5230f1040db63c28ff13d5c5a5b3","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxies.java","status":"added","additions":89,"deletions":0,"changes":89,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxies.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxies.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxies.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"f5ab8ae64666cea90d96c4ac32d55fbe651f11ba","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxy.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxy.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxy.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"f29cf673849db59b95ce5c2ede7f6df66ff445e0","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyBean.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyBean.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyBean.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyBean.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"1cc377cbed7d96160377aafcd285704e4c1fb0b7","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCalendar.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCalendar.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCalendar.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCalendar.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"12a52d318d8ec226d7500baa09ac5325daefbb72","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCollection.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCollection.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCollection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCollection.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"b5f54cb251ee37b598e57d4f2c6118dff2655df7","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCollections.java","status":"added","additions":471,"deletions":0,"changes":471,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCollections.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCollections.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyCollections.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"fefb3463cf4edb0f7a7dcc4b86ea32722048c812","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyDate.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyDate.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyDate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyDate.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"1c59b5d379b5d16f5b0e3c516a6b894d8f44b5da","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManager.java","status":"added","additions":116,"deletions":0,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManager.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManager.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"9048d2151ebf0cfc2639f2ffc499c727a2b48d17","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","status":"added","additions":1662,"deletions":0,"changes":1662,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"19d064a8bb473694f203abe76ae2a2237d00a5c4","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyMap.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyMap.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyMap.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"205d4dd3610203d908c4b2d66f476e8467092404","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyMaps.java","status":"added","additions":285,"deletions":0,"changes":285,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyMaps.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyMaps.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyMaps.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"5c17109eeaf525dda9e782e200284d516dfb550a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ReferentialIntegrityException.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ReferentialIntegrityException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ReferentialIntegrityException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ReferentialIntegrityException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"5b599500e85a19cc6f812b32ca026f2334536d1d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/RuntimeExceptionTranslator.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/RuntimeExceptionTranslator.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/RuntimeExceptionTranslator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/RuntimeExceptionTranslator.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"b39db70677d92db1af1bdf3d0de4c45902f6a7ed","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Serialization.java","status":"added","additions":210,"deletions":0,"changes":210,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Serialization.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Serialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/Serialization.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"daf7ed6348e8689c3ee05ffadf4c73cccb3a9378","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ShortId.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ShortId.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ShortId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/ShortId.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"bb831727ee46097c135034ba3849b10a98030c5b","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreException.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"8d4bcd457b196418511b2f143a509ba15e8fa72a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","status":"added","additions":115,"deletions":0,"changes":115,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"2d80f5d4b0bb04d9ecf770c59277b75c2e163a16","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/StringId.java","status":"added","additions":59,"deletions":0,"changes":59,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/StringId.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/StringId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/StringId.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"e532777a36ce49a4ad277e74532ac543641ca576","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/UnsupportedException.java","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/UnsupportedException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/UnsupportedException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/UnsupportedException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"d69254157cd85af0971715636e40e91dde535458","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/UserException.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/UserException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/UserException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/UserException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"3e34fcab36bdcbeb543c51da62101208f795b86d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/package.html","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/package.html","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/util/package.html?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"a77d7ba16282693e659e4048b5ae927a37aa5617","filename":"1.2.x/openjpa-kernel/src/main/jjtree/org/apache/openjpa/kernel/jpql/JPQL.jjt","status":"added","additions":1308,"deletions":0,"changes":1308,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/jjtree/org/apache/openjpa/kernel/jpql/JPQL.jjt","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/jjtree/org/apache/openjpa/kernel/jpql/JPQL.jjt","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/jjtree/org/apache/openjpa/kernel/jpql/JPQL.jjt?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"cbf1fdceda6bb6c84ed3db6a6f39f1bea879c7af","filename":"1.2.x/openjpa-kernel/src/main/resources/META-INF/services/org.apache.openjpa.kernel.exps.ExpressionParser","status":"added","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/META-INF/services/org.apache.openjpa.kernel.exps.ExpressionParser","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/META-INF/services/org.apache.openjpa.kernel.exps.ExpressionParser","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/resources/META-INF/services/org.apache.openjpa.kernel.exps.ExpressionParser?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"e9d1449846725ecfd71746101fa766b65002df31","filename":"1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/abstractstore/localizer.properties","status":"added","additions":19,"deletions":0,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/abstractstore/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/abstractstore/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/abstractstore/localizer.properties?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"7b54e2a943b6165853a02859e8201e8de80a3545","filename":"1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/ant/antlib.xml","status":"added","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/ant/antlib.xml","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/ant/antlib.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/ant/antlib.xml?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"13c497cbd3fe08523966d5f5f13b1489dd376a8b","filename":"1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/ant/localizer.properties","status":"added","additions":19,"deletions":0,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/ant/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/ant/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/ant/localizer.properties?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"a02bf86a84ecc3bd67793c081dabfd2d2b16a8a2","filename":"1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/conf/localizer.properties","status":"added","additions":586,"deletions":0,"changes":586,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/conf/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/conf/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/conf/localizer.properties?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"d82c0b325467ae41b7175c210033fc1f9780f08b","filename":"1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/datacache/localizer.properties","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/datacache/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/datacache/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/datacache/localizer.properties?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"014e0aca1d83f02cf4df3dc635da0cadc4603f70","filename":"1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/ee/localizer.properties","status":"added","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/ee/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/ee/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/ee/localizer.properties?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"d82698b08a8b9d08e2457606f0fb0ad8978f430c","filename":"1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/enhance/localizer.properties","status":"added","additions":206,"deletions":0,"changes":206,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/enhance/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/enhance/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/enhance/localizer.properties?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"d146f0848187106bf1cc7acc0d1cc7d81020c951","filename":"1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/event/localizer.properties","status":"added","additions":101,"deletions":0,"changes":101,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/event/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/event/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/event/localizer.properties?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"b540f10ef7c2c7f98d932ea9e2cb6dbebd3b1e7a","filename":"1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/exps/localizer.properties","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/exps/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/exps/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/exps/localizer.properties?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"b44c422062c6094d9e2d1d2ba5d42fa941ff9631","filename":"1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/jpql/localizer.properties","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/jpql/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/jpql/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/jpql/localizer.properties?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"985d7de11dbaa70307fbd8eb0bbb374b467406f5","filename":"1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","status":"added","additions":402,"deletions":0,"changes":402,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"1446b14175bf1b776d9147f99e076ad7d21e5546","filename":"1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","status":"added","additions":323,"deletions":0,"changes":323,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"ef55f95f89f3bb15968a45fc42256f1f8e1e0d06","filename":"1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/util/localizer.properties","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/util/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/util/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/resources/org/apache/openjpa/util/localizer.properties?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"b9611e10eaf45da4c5751fd50902f0275b4a410f","filename":"1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"1254cd79c1104191ef829d37bf290d375182b8eb","filename":"1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","status":"added","additions":93,"deletions":0,"changes":93,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"f337f2628d72b402f8f183b612fa65f47a9ee77d","filename":"1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"32780d9765417d241b07c31023e0ffa8e69cd71d","filename":"1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/meta/TestMemberProvider.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/meta/TestMemberProvider.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/meta/TestMemberProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/meta/TestMemberProvider.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"53fa96c2167f28ba218a810de75e22d1ee86a412","filename":"1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/util/TestProxyManager.java","status":"added","additions":1039,"deletions":0,"changes":1039,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/util/TestProxyManager.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/util/TestProxyManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/test/java/org/apache/openjpa/util/TestProxyManager.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"5e8f6527afd149a96ce72293c9224b2ff23140f9","filename":"1.2.x/openjpa-lib/pom.xml","status":"added","additions":135,"deletions":0,"changes":135,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/pom.xml?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"0fb9221eefdb3dc2b00a3c9f543a50b515f87771","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/AbstractTask.java","status":"added","additions":202,"deletions":0,"changes":202,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/AbstractTask.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/AbstractTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/AbstractTask.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"953c00070938e457023d4c359f9aded9cea2db8b","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/package.html","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/package.html","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/ant/package.html?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"4700dbe2ddb82d25da315fcfe959e4b2eefb4771","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/AbstractProductDerivation.java","status":"added","additions":89,"deletions":0,"changes":89,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/AbstractProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/AbstractProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/AbstractProductDerivation.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"d9e4076cb15d8ab692b1dd78dbf98084dd651c61","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BooleanValue.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BooleanValue.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BooleanValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BooleanValue.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"b58b0cf2c325d86d34cbdc99885484d86176bf5b","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"be41ecb69c69515e639a1cf22a99cf221c6eac5c","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurable.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurable.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurable.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"a00fd5be3e0eedcd31d1e95ccf79b72bf63d3017","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configuration.java","status":"added","additions":255,"deletions":0,"changes":255,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configuration.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configuration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configuration.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"9cddb36180d30ef9fb6c78dfe2601b3c4020e21f","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationImpl.java","status":"added","additions":1006,"deletions":0,"changes":1006,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationImpl.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"67654e9534fdf8517d746818981d11fdf7498564","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationProvider.java","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationProvider.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationProvider.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"d4e4202c3c1c945fd0eb7a76d0b67efaefefe745","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","status":"added","additions":721,"deletions":0,"changes":721,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"34e4c7711662ccb6dd02b4692a7b6931b83d9906","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/DoubleValue.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/DoubleValue.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/DoubleValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/DoubleValue.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"8a23ccb2be1b515c906617f55bc8120c9740e3e7","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/FileValue.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/FileValue.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/FileValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/FileValue.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"8946dbf22fc862a3ce88e2f2c3b403ad508bb851","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/GenericConfigurable.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/GenericConfigurable.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/GenericConfigurable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/GenericConfigurable.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"0ea17b95e019e1d86279dbaf982fa37ef74db3a6","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/IntValue.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/IntValue.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/IntValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/IntValue.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"90c7f01690ae7e8b48d9fcffcc510359a7639dab","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/MapConfigurationProvider.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/MapConfigurationProvider.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/MapConfigurationProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/MapConfigurationProvider.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"93578493fa4416cca12e981b14b9ba4bd713f4c2","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","status":"added","additions":138,"deletions":0,"changes":138,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"915e9986f9276ce3b4bf34e141affdb816c61c94","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/PluginListValue.java","status":"added","additions":212,"deletions":0,"changes":212,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/PluginListValue.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/PluginListValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/PluginListValue.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"e9dd08fdaa0abe87011137f8789b47862a1e3b9f","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/PluginValue.java","status":"added","additions":150,"deletions":0,"changes":150,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/PluginValue.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/PluginValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/PluginValue.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"92ad60fbabf845e5b1ea556656390712e734a3c9","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ProductDerivation.java","status":"added","additions":160,"deletions":0,"changes":160,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ProductDerivation.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"c72f91b26a36a114fa7c43985ce31ab5f1adadae","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ProductDerivations.java","status":"added","additions":474,"deletions":0,"changes":474,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ProductDerivations.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ProductDerivations.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ProductDerivations.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"4a51a12c12ce10bdd3e5cb4ac839a41fbcc2d90c","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/StringListValue.java","status":"added","additions":145,"deletions":0,"changes":145,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/StringListValue.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/StringListValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/StringListValue.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"1331abeaf3a1e9a72e9b1859ee3ed3501b3c39fe","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/StringValue.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/StringValue.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/StringValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/StringValue.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"36c7cdc32c0385654fbca122a698cde326807ff9","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Value.java","status":"added","additions":496,"deletions":0,"changes":496,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Value.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Value.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Value.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"a73a39a2d2aa112ab614e64ba7e5e55b5f34b65b","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ValueListener.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ValueListener.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ValueListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ValueListener.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"a6a51ed24319741aaad83dbc412ef57985e89ff5","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/package.html","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/package.html","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/package.html?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"16f643ad2b1305b6104bbddd19689607aa71df01","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","status":"added","additions":145,"deletions":0,"changes":145,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"0f4693b7da474ddff4439c1213684c4f5d23afac","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","status":"added","additions":358,"deletions":0,"changes":358,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"94522a8ca25d73cce881aa59cdb0f6bfce7faf14","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","status":"added","additions":222,"deletions":0,"changes":222,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"6077e6d0b29b7f41f723f9850d2db5de53b251e1","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","status":"added","additions":202,"deletions":0,"changes":202,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"852602d7d7859bf0a5d35106bcce513f50e45f10","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"c3dbe01d55b35af8fba1608e9a113645d56565fc","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"9095a4ec0368bfd122f7c762215689b7185b19fc","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/package.html","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/package.html","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/package.html?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"aecc0806517a4fa8a40184b44b09fddb3d85e22f","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/AbstractJDBCListener.java","status":"added","additions":92,"deletions":0,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/AbstractJDBCListener.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/AbstractJDBCListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/AbstractJDBCListener.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"cf8be7cf3f1eaa62493f3d64b1534918ed984e3a","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ConfiguringConnectionDecorator.java","status":"added","additions":170,"deletions":0,"changes":170,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ConfiguringConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ConfiguringConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ConfiguringConnectionDecorator.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"3c3035ed9683cd7842a6ad514df30b85b18d2fc3","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ConnectionDecorator.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ConnectionDecorator.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"ca3f6efcc3560e679ffbb89f2418bb06ee1f3cbd","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DataSourceLogs.java","status":"added","additions":149,"deletions":0,"changes":149,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DataSourceLogs.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DataSourceLogs.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DataSourceLogs.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"81269c9047c961ef47e24c487190bb1f0c52604a","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","status":"added","additions":103,"deletions":0,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"a83569683181072aeab06a94c5da34e9b1fdcb22","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java","status":"added","additions":794,"deletions":0,"changes":794,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"473a96b44a5e43150f8e5deb7cf6d5aaa261806a","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingConnection.java","status":"added","additions":591,"deletions":0,"changes":591,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingConnection.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingConnection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingConnection.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"30bba6e30710ba7e645e75d82ef9c0f2e7f0556d","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDataSource.java","status":"added","additions":120,"deletions":0,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDataSource.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"1ceadd62fbd2e6a9112e4c8c0fd3aa8eeea633bf","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","status":"added","additions":773,"deletions":0,"changes":773,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"d88c9b45157bbe22c169cafa8a2df29a29cf73fe","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingPreparedStatement.java","status":"added","additions":456,"deletions":0,"changes":456,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingPreparedStatement.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingPreparedStatement.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingPreparedStatement.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"0f571cac1f5cac5d9ba041021caf12068285e10f","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingResultSet.java","status":"added","additions":671,"deletions":0,"changes":671,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingResultSet.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingResultSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingResultSet.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"ab9ec4d7a922ea8aa10aacbe54432fe178390a35","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingStatement.java","status":"added","additions":272,"deletions":0,"changes":272,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingStatement.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingStatement.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingStatement.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"ce8fbf49ea5f8992ab890193226b518ea29f4b1f","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEvent.java","status":"added","additions":162,"deletions":0,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEvent.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEvent.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"52ed8f2208b08bb0c90667fdc1059f469e6cecab","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","status":"added","additions":295,"deletions":0,"changes":295,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"fb0d81a93b3524761f3fb01f6f8dd97a3fca088e","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCListener.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCListener.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCListener.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"c403e80382ff1be82898e20fdb0a845004b456c8","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","status":"added","additions":1299,"deletions":0,"changes":1299,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"560108a69b33e0cdd2b84703351d2fe0fa72b4f4","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ReportingSQLException.java","status":"added","additions":93,"deletions":0,"changes":93,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ReportingSQLException.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ReportingSQLException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/ReportingSQLException.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"8eb5fa98c9a9b4d0134ce49340cc736b0f553d98","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/SQLFormatter.java","status":"added","additions":272,"deletions":0,"changes":272,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/SQLFormatter.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/SQLFormatter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/SQLFormatter.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"cb7d8f2f1120ce7b32bf38a2bb79a22c33a78f4c","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/package.html","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/package.html","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/package.html?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"9989781fc8f4ee0ee86812f2de0acb25b1bb2ada","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/AbstractLog.java","status":"added","additions":140,"deletions":0,"changes":140,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/AbstractLog.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/AbstractLog.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/AbstractLog.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"b1841b1c15dfe389de4c3cca8242edaf0ad6f5dc","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/CommonsLogFactory.java","status":"added","additions":115,"deletions":0,"changes":115,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/CommonsLogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/CommonsLogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/CommonsLogFactory.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"357f7e8db86087b2db8e069671f3bf0d5a8f5110","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/Log.java","status":"added","additions":130,"deletions":0,"changes":130,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/Log.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/Log.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/Log.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"5753750091abd70680dc6452eb6e8b531c931286","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/Log4JLogFactory.java","status":"added","additions":111,"deletions":0,"changes":111,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/Log4JLogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/Log4JLogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/Log4JLogFactory.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"3394e0e6ba80c88da02eaf5cdd35524d5c51938c","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactory.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactory.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"0bc0d85cbdbc3f81b7fe169a6b035cb382c95b42","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"b9b7a6508b231e246c36ce6b9adfc391dcfdcb88","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","status":"added","additions":368,"deletions":0,"changes":368,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"baa7402037e69f05607539ed00378022c6dbc479","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogOutputStream.java","status":"added","additions":95,"deletions":0,"changes":95,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogOutputStream.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogOutputStream.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogOutputStream.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"13fb9fced33084c1bf27189faddd87de8b8f1458","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","status":"added","additions":193,"deletions":0,"changes":193,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"82db5587ae7de557e2ea5d4723ed3901270a6b25","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/NoneLogFactory.java","status":"added","additions":95,"deletions":0,"changes":95,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/NoneLogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/NoneLogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/NoneLogFactory.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"20558c92a3ab64f46d90cb9957271f3d42d30155","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/package.html","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/package.html","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/package.html?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"a0a3f8e297c2b3e2b70be8f26642416f88709615","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/CFMetaDataParser.java","status":"added","additions":331,"deletions":0,"changes":331,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/CFMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/CFMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/CFMetaDataParser.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"1e66e0f2cefbdd3d1aa3c3acb2023f73102bdb84","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/CFMetaDataSerializer.java","status":"added","additions":103,"deletions":0,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/CFMetaDataSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/CFMetaDataSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/CFMetaDataSerializer.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"a6ee36b401c8b26c29a14e54bd83eb699fa4ef10","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassAnnotationMetaDataFilter.java","status":"added","additions":209,"deletions":0,"changes":209,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassAnnotationMetaDataFilter.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassAnnotationMetaDataFilter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassAnnotationMetaDataFilter.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"4c9526c6822a0bbd41fadc2605ed2fe672871fed","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassArgParser.java","status":"added","additions":622,"deletions":0,"changes":622,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassArgParser.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassArgParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassArgParser.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"789e89905c2f6ebc7dc7bc37d2a79e926548bb37","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassMetaDataIterator.java","status":"added","additions":199,"deletions":0,"changes":199,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassMetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassMetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClassMetaDataIterator.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"},{"sha":"f787488ca974a7e2b1e7bcdc56dbe1a60c928faa","filename":"1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClasspathMetaDataIterator.java","status":"added","additions":92,"deletions":0,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClasspathMetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/9c16a4373493bb9307dda99fc63e29c0fb8a3653/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClasspathMetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-lib/src/main/java/org/apache/openjpa/lib/meta/ClasspathMetaDataIterator.java?ref=9c16a4373493bb9307dda99fc63e29c0fb8a3653"}]}

