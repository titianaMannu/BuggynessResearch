{"sha":"9d37d74a105f2a97061e127791555495ccdc055b","node_id":"MDY6Q29tbWl0MjA2MzY0OjlkMzdkNzRhMTA1ZjJhOTcwNjFlMTI3NzkxNTU1NDk1Y2NkYzA1NWI=","commit":{"author":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2009-09-29T01:35:39Z"},"committer":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2009-09-29T01:35:39Z"},"message":"OPENJPA-1327 Doc update for JPA2 JPQL Query\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@819794 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"2df76975ba96dc42cbca991829b7292b25780f84","url":"https://api.github.com/repos/apache/openjpa/git/trees/2df76975ba96dc42cbca991829b7292b25780f84"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/9d37d74a105f2a97061e127791555495ccdc055b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/9d37d74a105f2a97061e127791555495ccdc055b","html_url":"https://github.com/apache/openjpa/commit/9d37d74a105f2a97061e127791555495ccdc055b","comments_url":"https://api.github.com/repos/apache/openjpa/commits/9d37d74a105f2a97061e127791555495ccdc055b/comments","author":null,"committer":null,"parents":[{"sha":"9f24d10ecdd5c9286f22e363852e84f116d0f994","url":"https://api.github.com/repos/apache/openjpa/commits/9f24d10ecdd5c9286f22e363852e84f116d0f994","html_url":"https://github.com/apache/openjpa/commit/9f24d10ecdd5c9286f22e363852e84f116d0f994"}],"stats":{"total":715,"additions":553,"deletions":162},"files":[{"sha":"9c96d06bafb2121b69cdcd68663c98107b5926e8","filename":"openjpa-project/src/doc/manual/jpa_overview_query.xml","status":"modified","additions":553,"deletions":162,"changes":715,"blob_url":"https://github.com/apache/openjpa/blob/9d37d74a105f2a97061e127791555495ccdc055b/openjpa-project/src/doc/manual/jpa_overview_query.xml","raw_url":"https://github.com/apache/openjpa/raw/9d37d74a105f2a97061e127791555495ccdc055b/openjpa-project/src/doc/manual/jpa_overview_query.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_overview_query.xml?ref=9d37d74a105f2a97061e127791555495ccdc055b","patch":"@@ -607,8 +607,10 @@ SELECT x FROM Magazine x WHERE MOD(x.price, 10) = 0\n which an order column has been specified.\n                     </para>\n                     <para>\n-In the following example, <literal>studentWaitlist</literal> is a list of students for which an order column has\n-been specified, the query returns the name of the first student on the waitiing list of the course named 'Calculus':\n+In the following example, <literal>studentWaitlist</literal> is a list of \n+students for which an order column has\n+been specified, the query returns the name of the first student on the waiting list of \n+the course named 'Calculus':\n                     </para>\n <programlisting>\n SELECT w.name FROM Course c JOIN c.studentWaitlist w WHERE c.name = ‘Calculus’ AND INDEX(w) = 0\n@@ -719,6 +721,11 @@ This code substitutes <literal>JDJ</literal> for the <literal> :titleParam\n </literal> parameter and <literal>5.0</literal> for the <literal>:priceParam\n </literal> parameter, then executes the query with those values.\n             </para>\n+            <para>\n+All input parameters must be single-valued, except in IN expressions \n+(see section <xref linkend=\"jpa_langref_in\"/>), which support the use of collection-valued\n+ input parameters. \n+            </para>\n         </section>\n         <section id=\"jpa_overview_query_hints\">\n             <title>\n@@ -1118,7 +1125,7 @@ language.\n         <note>\n             <para> \n Much of this section is paraphrased or taken directly from Chapter 4 of the \n-JSR 220 specification.\n+JSR 317 Java Persistence API Specification.\n             </para>\n         </note>\n         <section id=\"jpa_langref_stmnttypes\">\n@@ -1245,12 +1252,15 @@ The Java Persistence query language is a typed language, and every expression\n has a type. The type of an expression is derived from the structure of the\n expression, the abstract schema types of the identification variable\n declarations, the types to which the persistent fields and relationships\n-evaluate, and the types of literals. The abstract schema type of an entity is\n+evaluate, and the types of literals. \n+            </para>\n+            <para>\n+The abstract schema type of an entity or embeddable is\n derived from the entity class and the metadata information provided by Java\n language annotations or in the XML descriptor.\n             </para>\n             <para>\n-Informally, the abstract schema type of an entity can be characterized as\n+Informally, the abstract schema type of an entity or embeddable can be characterized as\n follows: \n             </para>\n             <itemizedlist>\n@@ -1268,18 +1278,28 @@ For every persistent relationship field or get accessor method (for a persistent\n relationship property) of the entity class, there is a field\n (\"association-field\") whose type is the abstract schema type of the related\n entity (or, if the relationship is a one-to-many or many-to-many, a collection\n-of such). Abstract schema types are specific to the query language data featureSelection.\n+of such). \n+                    </para>\n+                </listitem>\n+            </itemizedlist>\n+                    <para>\n+Abstract schema types are specific to the query language data featureSelection.\n The persistence provider is not required to implement or otherwise materialize\n-an abstract schema type. The domain of a query consists of the abstract schema\n-types of all entities that are defined in the same persistence unit. The domain\n-of a query may be restricted by the navigability of the relationships of the\n-entity on which it is based. The association-fields of an entity's abstract\n-schema type determine navigability. Using the association-fields and their\n+an abstract schema type.\n+                    </para>\n+                    <para>\n+The domain of a query consists of the abstract schema\n+types of all entities and embeddables that are defined in the same persistence unit.\n+                    </para>\n+                    <para>\n+The domain\n+of a query may be restricted by the <literal>navigability</literal> of the relationships of the\n+entity and associated embeddable classes on which it is based. The association-fields of an entity's\n+or embeddable's abstract\n+schema type determine navigability. Using the association fields and their\n values, a query can select related entities and use their abstract schema types\n in the query.\n                     </para>\n-                </listitem>\n-            </itemizedlist>\n             <section id=\"jpa_langref_schemanaming\">\n                 <title>\n                     JPQL Entity Naming\n@@ -1312,28 +1332,37 @@ in a one-to-one relationship.\n                 </para>\n                 <para>\n Queries to select magazines can be defined by navigating over the\n-association-fields and state-fields defined by Magazine and Author. A query to\n+association-fields and state-fields defined by <literal>Magazine</literal> and \n+<literal>Author</literal>. A query to\n find all magazines that have unpublished articles is as follows:\n                 </para>\n <programlisting>\n SELECT DISTINCT mag FROM Magazine AS mag JOIN mag.articles AS art WHERE art.published = FALSE\n </programlisting> \n                 <para>\n-This query navigates over the association-field authors of the\n+This query navigates over the association-field <literal>authors</literal> of the\n abstract schema type <literal>Magazine</literal> to find articles, and uses the\n state-field <literal>published</literal> of <literal>Article</literal> to select\n those magazines that have at least one article that is not published. Although\n predefined reserved identifiers, such as <literal>DISTINCT</literal>, <literal>\n FROM</literal>, <literal>AS</literal>, <literal>JOIN</literal>, <literal>\n WHERE</literal>, and <literal>FALSE</literal> appear in upper case in this \n-example, predefined reserved identifiers are case insensitive. The <literal>\n+example, predefined reserved identifiers are case insensitive.\n+                </para>\n+                <para>\n+ The <literal>\n SELECT</literal> clause of this example designates the return type of this \n-query to be of type Magazine. Because the same persistence unit defines the \n+query to be of type <literal>Magazine</literal>.\n+                </para>\n+                <para>\n+Because the same persistence unit defines the \n abstract persistence schemas of the related entities, the developer can also \n-specify a query over <literal>articles</literal> that utilizes the abstract \n+specify a query over articles that utilizes the abstract \n schema type for products, and hence the state-fields and association-fields of \n-both the abstract schema types Magazine and Author. For example, if the \n-abstract schema type Author has a state-field named firstName, a query over \n+both the abstract schema types <literal>Magazine</literal> and <literal>Author</literal>. \n+For example, if the \n+abstract schema type <literal>Author</literal> has a state-field named <literal>firstName</literal>,\n+ a query over \n articles can be specified using this state-field. Such a query might be to \n find all magazines that have articles authored by someone with the first name \n \"John\".\n@@ -1342,13 +1371,16 @@ find all magazines that have articles authored by someone with the first name\n SELECT DISTINCT mag FROM Magazine mag JOIN mag.articles art JOIN art.author auth WHERE auth.firstName = 'John'\n </programlisting> \n                 <para>\n-Because Magazine is related to Author by means of the\n-relationships between Magazine and Article and between Article and Author,\n-navigation using the association-fields authors and product is used to express\n-the query. This query is specified by using the abstract schema name Magazine,\n+Because <literal>Magazine</literal> is related to <literal>Author</literal> by means of the\n+relationships between <literal>Magazine</literal> and <literal>Article</literal> \n+and between <literal>Article</literal> and <literal>Author</literal>,\n+navigation using the association-fields <literal>authors</literal> and \n+<literal>product</literal> is used to express\n+the query. This query is specified by using the abstract schema name <literal>Magazine</literal>,\n which designates the abstract schema type over which the query ranges. The basis\n-for the navigation is provided by the association-fields authors and product of\n-the abstract schema types Magazine and Article respectively.\n+for the navigation is provided by the association-fields <literal>authors</literal> \n+and <literal>product</literal> of\n+the abstract schema types <literal>Magazine</literal> and <literal>Article</literal> respectively.\n                 </para>\n             </section>\n         </section>\n@@ -1360,7 +1392,10 @@ the abstract schema types Magazine and Article respectively.\n The <literal>FROM</literal> clause of a query defines the domain of the query by\n declaring identification variables. An identification variable is an identifier\n declared in the <literal>FROM</literal> clause of a query. The domain of the\n-query may be constrained by path expressions. Identification variables designate\n+query may be constrained by path expressions (See section <xref linkend=\"jpa_langref_path\"/>.\n+            </para>\n+            <para>\n+Identification variables designate\n instances of a particular entity abstract schema type. The <literal>FROM\n </literal> clause can contain multiple identification variable declarations\n separated by a comma (,).\n@@ -1411,6 +1446,9 @@ identification_variable\n                     </para>\n                 </listitem>\n             </itemizedlist>\n+            <para>\n+The following subsections discuss the constructs used in the <literal>FROM</literal> clause.\n+            </para>\n             <section id=\"jpa_langref_from_identifiers\">\n                 <title>\n                     JPQL FROM Identifiers\n@@ -1430,157 +1468,222 @@ query language. The following are reserved identifiers:\n                 <itemizedlist>\n                     <listitem>\n                         <para>\n-                        <literal>SELECT</literal>\n+<literal>ABS</literal>\n+                            </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para>\n+<literal>ALL</literal>\n+                            </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para>\n+<literal>AND</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>FROM</literal>\n+<literal>ANY</literal>\n+                            </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para>\n+<literal>AS</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>WHERE</literal>\n+<literal>ASC</literal>\n+                            </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para>\n+<literal>AVG</literal>\n+                            </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para>\n+<literal>BETWEEN</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>UPDATE</literal>\n+<literal>BOTH</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>DELETE</literal>\n+<literal>BY</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>JOIN</literal>\n+<literal>CASE</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>OUTER</literal>\n+<literal>CLASS</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>INNER</literal>\n+<literal>COALESCE</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>LEFT</literal>\n+<literal>CONCAT</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>GROUP</literal>\n+<literal>COUNT</literal>\n+                            </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para>\n+<literal>CURRENT_DATE</literal>\n+                            </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para>\n+<literal>CURRENT_TIME</literal>\n+                            </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para>\n+<literal>CURRENT_TIMESTAMP</literal>\n+                            </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para>\n+<literal>DELETE</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>BY</literal>\n+<literal>DESC</literal>\n+                            </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para>\n+<literal>DISTINCT</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>HAVING</literal>\n+<literal>ELSE</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>FETCH</literal>\n+<literal>EMPTY</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>DISTINCT</literal>\n+<literal>END</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>OBJECT</literal>\n+<literal>ENTRY</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>NULL</literal>\n+<literal>ESCAPE</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>TRUE</literal>\n+<literal>EXISTS</literal>\n+                            </para>\n+                        </listitem>\n+                        <listitem>\n+                            <para>\n+<literal>FALSE</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>FALSE</literal>\n+<literal>FETCH</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>NOT</literal>\n+<literal>FROM</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>AND</literal>\n+<literal>GROUP</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>OR</literal>\n+<literal>HAVING</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>BETWEEN</literal>\n+<literal>IN</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>LIKE</literal>\n+<literal>INDEX</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>IN</literal>\n+<literal>INNER</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>AS</literal>\n+<literal>IS</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>UNKNOWN</literal>\n+<literal>JOIN</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>EMPTY</literal>\n+<literal>KEY</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>MEMBER</literal>\n+<literal>LEADING</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>OF</literal>\n+<literal>LEFT</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>IS</literal>\n+<literal>LENGTH</literal>\n                         </para>\n                     </listitem>\n                     <listitem>\n                         <para>\n-<literal>AVG</literal>\n+<literal>LIKE</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>LOCATE</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>LOWER</literal>\n                             </para>\n                         </listitem>\n                         <listitem>\n@@ -1590,66 +1693,151 @@ query language. The following are reserved identifiers:\n                         </listitem>\n                         <listitem>\n                             <para>\n+<literal>MEMBER</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n <literal>MIN</literal>\n                             </para>\n                         </listitem>\n                         <listitem>\n                             <para>\n-<literal>SUM</literal>\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n-<literal>COUNT</literal>\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n-<literal>ORDER</literal>\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n-<literal>BY</literal>\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n-<literal>ASC</literal>\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n-<literal>DESC</literal>\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n <literal>MOD</literal>\n                             </para>\n                         </listitem>\n                         <listitem>\n                             <para>\n-<literal>UPPER</literal>\n+<literal>NEW</literal>\n                             </para>\n                         </listitem>\n                         <listitem>\n                             <para>\n-<literal>LOWER</literal>\n+<literal>NOT</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>NULL</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>NULLIF</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>OBJECT</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>OF</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>OR</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>ORDER</literal>\n                             </para>\n                         </listitem>\n                         <listitem>\n                             <para>\n+<literal>OUTER</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>SELECT</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>SET</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>SIZE</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>SOME</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>SQRT</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>SIBSTRING</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>SUM</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>THEN</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>TRAILING</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n <literal>TRIM</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>TRUE</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>TYPE</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>UPDATE</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>UPPER</literal>\n                             </para>\n                         </listitem>\n                         <listitem>\n                             <para>\n-<literal>POSITION</literal>\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n+<literal>VALUE</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>WHEN</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n+<literal>WHERE</literal>\n+                        </para>\n+                    </listitem>\n+                    <listitem>\n+                        <para>\n <literal>CHARACTER_LENGTH</literal>\n                             </para>\n                         </listitem>\n@@ -1663,106 +1851,139 @@ query language. The following are reserved identifiers:\n <literal>BIT_LENGTH</literal>\n                             </para>\n                         </listitem>\n-                        <listitem>\n-                            <para>\n-<literal>CURRENT_TIME</literal>\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n-<literal>CURRENT_DATE</literal>\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n-<literal>CURRENT_TIMESTAMP</literal>\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n-<literal>NEW</literal>\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n-<literal>EXISTS</literal>\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n-<literal>ALL</literal>\n-                            </para>\n-                        </listitem>\n-                        <listitem>\n-                            <para>\n-<literal>ANY</literal>\n+                    <listitem>\n+                        <para>\n+<literal>POSITION</literal>\n                             </para>\n                         </listitem>\n                         <listitem>\n                             <para>\n-<literal>SOME</literal>\n+<literal>UNKNOWN</literal>\n                         </para>\n                     </listitem>\n                 </itemizedlist>\n                 <para>    \n Reserved identifiers are case insensitive. Reserved identifiers must not be \n-used as identification variables. It is recommended that other SQL reserved \n+used as identification variables or result variables.\n+                </para>\n+                <note>\n+                    <para>\n+It is recommended that other SQL reserved \n words also not be as identification variables in queries because they may be \n used as reserved identifiers in future releases of the specification.  \n-                </para>\n+                    </para>\n+                </note>\n+                <note>\n+                    <para>\n+BIT_LENGTH, CHAR_LENGTH, CHARACTER_LENGTH, POSITION, and UNKNOWN are not currently used: they are\n+reserved for future use.\n+                    </para>\n+                </note>\n             </section>\n             <section id=\"jpa_langref_from_vars\">\n                 <title>\n                     JPQL Identification Variables\n                 </title>\n                 <para>\n An identification variable is a valid identifier declared in the <literal>FROM\n-</literal> clause of a query. All identification variables must be declared in\n+</literal> clause of a query.\n+                </para>\n+                <para> \n+All identification variables must be declared in\n the <literal>FROM</literal> clause. Identification variables cannot be declared\n-in other clauses. An identification variable must not be a reserved identifier\n-or have the same name as any entity in the same persistence unit. Identification\n-variables are case insensitive. An identification variable evaluates to a value\n+in other clauses. \n+                </para>\n+                <para>\n+An identification variable must not be a reserved identifier\n+or have the same name as any entity in the same persistence unit.\n+                </para>\n+                <para>                \n+Identification variables are case insensitive.\n+                </para> \n+                <para>                \n+An identification variable evaluates to a value\n of the type of the expression used in declaring the variable. For example,\n consider the previous query: <programlisting>SELECT DISTINCT mag FROM Magazine mag JOIN mag.articles art JOIN art.author auth WHERE auth.firstName = 'John'\n-</programlisting> In the <literal>FROM</literal> clause declaration <literal>\n+</programlisting> \n+In the <literal>FROM</literal> clause declaration <literal>\n mag.articles</literal> <literal>art</literal>, the identification variable\n <literal>art</literal> evaluates to any <literal>Article</literal> value\n directly reachable from <literal>Magazine</literal>. The association-field\n <literal>articles</literal> is a collection of instances of the abstract schema\n type <literal>Article</literal> and the identification variable <literal>art\n </literal> refers to an element of this collection. The type of <literal>auth\n-</literal> is the abstract schema type of <literal>Author</literal>. An\n-identification variable ranges over the abstract schema type of an entity. An\n+</literal> is the abstract schema type of <literal>Author</literal>. \n+                 </para>\n+                 <para>\n+An identification variable can range over an entity, \n+embeddable, or basic abstract schema type. An\n identification variable designates an instance of an entity abstract schema type\n-or an element of a collection of entity abstract schema type instances.\n-Identification variables are existentially quantified in a query. An\n+or an element of a collection of entity abstract schema type instances. \n+                 </para>\n+                 <para>\n+Note that for identification variables referring to an instance of an association or collection represented\n+as a <literal>java.util.Map</literal>, the identification variable is of the abstract schema type of the map \n+<literal>value</literal>.\n+                 </para>\n+                 <para>\n+An\n identification variable always designates a reference to a single value. It is\n declared in one of three ways: in a range variable declaration, in a join\n clause, or in a collection member declaration. The identification variable\n declarations are evaluated from left to right in the <literal>FROM</literal>\n clause, and an identification variable declaration can use the result of a\n preceding identification variable declaration of the query string.\n                 </para>\n+                <para>\n+All identification variables used in the <literal>SELECT</literal>, \n+<literal>WHERE</literal>, \n+<literal>ORDER BY</literal>, \n+<literal>GROUP BY</literal>, or \n+<literal>HAVING</literal>\n+clause of a <literal>SELECT</literal> or \n+<literal>DELETE</literal> statement must be declared in the <literal>FROM</literal> clause. \n+The identification\n+variables used in the <literal>WHERE</literal> clause of \n+an <literal>UPDATE</literal> statement must be declared in the <literal>UPDATE</literal> clause.\n+                </para>\n+                <para>\n+Identification variables are existentially quantified in these clauses. This means that an identification\n+variable represents a member of a collection or an instance of an entity’s abstract schema type. An identification\n+variable never designates a collection in its entirety.\n+                </para>\n+                <para>\n+An identification variable is scoped to the query (or subquery) in which it is defined and is also visible\n+to any subqueries within that query scope that do not define an identification variable of the same name.\n+                </para>\n             </section>\n             <section id=\"jpa_langref_range\">\n                 <title>\n                     JPQL Range Declarations\n                 </title>\n                 <para>\n The syntax for declaring an identification variable as a range variable is\n-similar to that of SQL; optionally, it uses the AS keyword. \n+similar to that of SQL; optionally, it uses the AS keyword. A range variable designates an \n+entity abstract schema type.\n+                </para>\n+                <note>\n+                <para>\n+A range variable must not designate an embeddable class abstract schema type.\n                 </para>\n+                </note>\n                 <itemizedlist>\n                     <listitem>\n                         <para>\n-range_variable_declaration ::= abstract_schema_name [AS]\n+range_variable_declaration ::= entity_name [AS]\n identification_variable\n                         </para>\n                     </listitem>\n                 </itemizedlist>\n                 <para>\n Range variable declarations allow the developer to designate a \"root\" for\n-objects which may not be reachable by navigation. In order to select values by\n+objects which may not be reachable by navigation. \n+                </para>\n+                <para>\n+In order to select values by\n comparing more than one instance of an entity abstract schema type, more than\n one identification variable ranging over the abstract schema type is needed in\n the <literal>FROM</literal> clause.\n@@ -1789,14 +2010,101 @@ An identification variable followed by the navigation operator (.) and a\n state-field or association-field is a path expression. The type of the path\n expression is the type computed as the result of navigation; that is, the type\n of the state-field or association-field to which the expression navigates.\n+                </para>\n+                <para>\n+An identification variable qualified by the <literal>KEY</literal>, \n+<literal>VALUE</literal>, or <literal>ENTRY</literal> \n+operator is a path expression. The\n+<literal>KEY</literal>, <literal>VALUE</literal>, \n+and <literal>ENTRY</literal> operators may only be applied to identification variables that correspond to\n+map-valued associations or map-valued element collections. The type of the path expression is the type\n+computed as the result of the operation; that is, the abstract schema type of the field that is the value of\n+the <literal>KEY</literal>, \n+<literal>VALUE</literal>, or <literal>ENTRY</literal> \n+operator (the map key, map value, or map entry respectively).\n+                </para>\n+                <note>\n+                <para>\n+Note that use of <literal>VALUE</literal> is optional, \n+as an identification variable referring to an association of type \n+<literal>java.util.Map</literal> is of the\n+abstract schema type of the map value.\n+                </para>\n+                </note>\n+                <para>\n+The syntax for qualified identification variables is as follows.\n+                </para>\n+                <itemizedlist>\n+                    <listitem>\n+                        <para>\n+qualified_identification_variable :: =\n+KEY(identification_variable) |\n+VALUE(identification_variable) |\n+ENTRY(identification_variable)\n+                        </para>\n+                    </listitem>\n+                </itemizedlist>\n+                <para>\n+A path expression using the <literal>KEY</literal> or <literal>VALUE</literal> \n+operator may be further composed. A path expression\n+using the <literal>ENTRY</literal> operator is terminal. \n+It cannot be further composed and can only appear in the\n+<literal>SELECT</literal> list of a query.\n+                </para>\n+                <para>\n+In the following query, <literal>photos</literal> is a map from photo label to filename.\n+                </para>\n+<programlisting>\n+SELECT i.name, VALUE(p)\n+FROM Item i JOIN i.photos p\n+WHERE KEY(p) LIKE ‘egret’\n+</programlisting>\n+                <para>\n+In the above query the identification variable <literal>p</literal> designates \n+an abstract schema type corresponding to the\n+map value. The results of <literal>VALUE(p)</literal> and <literal>KEY(p)</literal> \n+are the map value and the map key associated with\n+p, respectively. The following query is equivalent:\n+                </para>\n+<programlisting>\n+SELECT i.name, p\n+FROM Item i JOIN i.photos p\n+WHERE KEY(p) LIKE ‘egret’\n+</programlisting>\n+                <para>\n Depending on navigability, a path expression that leads to a association-field\n+or to a field whose type is an embeddable class \n may be further composed. Path expressions can be composed from other path\n expressions if the original path expression evaluates to a single-valued type\n-(not a collection) corresponding to a association-field. Path expression\n+(not a collection) corresponding to a association-field.\n+                </para>\n+                <para>\n+In the following example, <literal>contactInfo</literal> denotes an embeddable \n+class consisting of an address and\n+set of phones. <literal>Phone</literal> is an entity.\n+                </para>\n+<programlisting>\n+SELECT p.vendor\n+FROM Employee e JOIN e.contactInfo.phones p\n+WHERE e.contactInfo.address.zipcode = '95054'\n+</programlisting>\n+                <para>\n+Path expression\n navigability is composed using \"inner join\" semantics. That is, if the value of\n a non-terminal association-field in the path expression is null, the path is\n considered to have no value, and does not participate in the determination of\n-the result. The syntax for single-valued path expressions and collection valued\n+the result. \n+                </para>\n+                <para>\n+The following query is equivalent to the query above:\n+                </para>\n+<programlisting>\n+SELECT p.vendor\n+FROM Employee e JOIN e.contactInfo c JOIN c.phones p\n+WHERE e.contactInfo.address.zipcode = '95054'\n+</programlisting>\n+                <para>\n+The syntax for single-valued path expressions and collection valued\n path expressions is as follows:\n                 </para>\n                 <itemizedlist>\n@@ -2315,12 +2623,12 @@ The syntax for the use of the comparison operator [ <literal>NOT</literal> ]\n                 </para>\n                 <para>\n <itemizedlist><listitem><para>in_expression ::= state_field_path_expression\n-[NOT] IN ( in_item {, in_item}* | subquery)\n+[NOT] IN {( in_item {, in_item}* ) | (subquery) | collection_valued_input_parameter }\n                             </para>\n                         </listitem>\n                         <listitem>\n                             <para>\n-in_item ::= literal | input_parameter\n+in_item ::= literal | single_valued_input_parameter\n                             </para>\n                         </listitem>\n                     </itemizedlist>\n@@ -2346,6 +2654,10 @@ value of a state_field_path_expression in an <literal>IN</literal> or <literal>\n NOT IN</literal> expression is <literal>NULL</literal> or unknown, the value of\n the expression is unknown.\n                 </para>\n+                <para>\n+Note that use of a collection-valued input parameter will mean that a static query cannot\n+be precompiled.\n+                </para>\n             </section>\n             <section id=\"jpa_langref_like\">\n                 <title>\n@@ -2588,13 +2900,62 @@ illustrated in the following example involving a numeric comparison operation.\n </programlisting>\n                 </para>\n             </section>\n-            <section id=\"jpa_langref_functional\">\n+        </section>\n+        <section id=\"jpa_langref_scalar_expressions\">\n+                <title>\n+                    JPQL Scalar Expressions\n+                </title>\n+                <para>\n+Numeric, string, datetime, case, and entity type expressions result in scalar values.\n+                </para>\n+                <para>\n+Scalar expressions may be used in the <literal>SELECT</literal> clause of a query as well as in the\n+ <literal>WHERE</literal> and <literal>HAVING</literal> clauses.\n+                </para>\n+                <para>\n+scalar_expression::=\n+arithmetic_expression |\n+string_primary |\n+enum_primary |\n+datetime_primary |\n+boolean_primary |\n+case_expression |\n+entity_type_expression                \n+                </para>\n+            <section id=\"jpa_langref_arithmetic_expressions\">\n                 <title>\n-                    JPQL Functional Expressions\n+                    Arithmetic Expressions\n                 </title>\n                 <para>\n-The JPQL includes the following built-in functions, which may be used in the\n-<literal>WHERE</literal> or <literal>HAVING</literal> clause of a query. If the\n+The arithmetic operators are:\n+<itemizedlist>\n+<listitem>+, - unary</listitem>\n+<listitem>*, / multiplication and division</listitem>\n+<listitem>+, - addition and subtraction</listitem>\n+                </itemizedlist>\n+                <para>\n+Arithmetic operations use numeric promotion.\n+                </para>\n+                <para>\n+Arithmetic functions are described in section <xref link=\"jpa_langref_arithmetic\"/>.\n+                </para>\n+                </para>\n+            </section>\n+            <section id=\"jpa_langref_functional_expressions\">\n+                <title>\n+                    String, Arithmetic, and Datetime Functional Expressions\n+                </title>\n+                <para> \n+JPQL includes the built-in functions described in subsections \n+<xref linkend=\"jpa_langref_string_fun\"/>, \n+<xref linkend=\"jpa_langref_arithmetic\"/>,\n+<xref linkend=\"jpa_langref_datetime\"/>,\n+which may be used in the <literal>SELECT</literal>,\n+<literal>WHERE</literal>\n+or <literal>HAVING</literal> clause of a query.\n+                 <para>\n+                 </para>               \n+If the\n value of any argument to a functional expression is null or unknown, the value\n of the functional expression is unknown.\n                 </para>\n@@ -2605,7 +2966,7 @@ of the functional expression is unknown.\n                     <para>\n <itemizedlist><listitem><para>functions_returning_strings ::=\n CONCAT(string_primary, string_primary) | SUBSTRING(string_primary,\n-simple_arithmetic_expression, simple_arithmetic_expression) |\n+simple_arithmetic_expression[, simple_arithmetic_expression]) |\n TRIM([[trim_specification] [trim_character] FROM] string_primary) |\n LOWER(string_primary) | UPPER(string_primary)\n                                 </para>\n@@ -2625,25 +2986,43 @@ LOCATE(string_primary, string_primary[, simple_arithmetic_expression])\n                     </para>\n                     <para>\n The <literal>CONCAT</literal> function returns a string that is a concatenation\n-of its arguments. The second and third arguments of the <literal>SUBSTRING\n+of its arguments.\n+                    </para>\n+                    <para>\n+ The second and third arguments of the <literal>SUBSTRING\n </literal> function denote the starting position and length of the substring to\n-be returned. These arguments are integers. The first position of a string is\n-denoted by 1. The <literal>SUBSTRING</literal> function returns a string. The\n+be returned. These arguments are integers. \n+The third argument is optional. If it is not specified, \n+the substring from the start position to the end of the string is returned.\n+ The first position of a string is\n+denoted by 1. The <literal>SUBSTRING</literal> function returns a string. \n+                    </para>\n+                    <para>\n+The\n <literal>TRIM</literal> function trims the specified character from a string. If\n the character to be trimmed is not specified, it is assumed to be space (or\n blank). The optional trim_character is a single-character string literal or a\n character-valued input parameter (i.e., char or Character). If a trim\n specification is not provided, <literal>BOTH</literal> is assumed. The <literal>\n-TRIM</literal> function returns the trimmed string. The <literal>LOWER</literal>\n+TRIM</literal> function returns the trimmed string.\n+                     </para>\n+                     <para>\n+ The <literal>LOWER</literal>\n and <literal>UPPER</literal> functions convert a string to lower and upper case,\n-respectively. They return a string. The <literal>LOCATE</literal> function\n+respectively. They return a string. \n+                     </para>\n+                     <para>\n+The <literal>LOCATE</literal> function\n returns the position of a given string within a string, starting the search at a\n specified position. It returns the first position at which the string was found\n as an integer. The first argument is the string to be located; the second\n argument is the string to be searched; the optional third argument is an integer\n that represents the string position at which the search is started (by default,\n the beginning of the string to be searched). The first position in a string is\n-denoted by 1. If the string is not found, 0 is returned. The <literal>LENGTH\n+denoted by 1. If the string is not found, 0 is returned. \n+                     </para>\n+                     <para>\n+The <literal>LENGTH\n </literal> function returns the length of the string in characters as an\n integer.\n                     </para>\n@@ -2656,15 +3035,19 @@ integer.\n <itemizedlist><listitem><para>functions_returning_numerics ::=\n ABS(simple_arithmetic_expression) | SQRT(simple_arithmetic_expression) |\n MOD(simple_arithmetic_expression, simple_arithmetic_expression) |\n-SIZE(collection_valued_path_expression)\n+SIZE(collection_valued_path_expression) |\n+INDEX(identification_variable)\n                                 </para>\n                             </listitem>\n                         </itemizedlist>\n                     </para>\n                     <para>\n The <literal>ABS</literal> function takes a numeric argument and returns a\n number (integer, float, or double) of the same type as the argument to the\n-function. The <literal>SQRT</literal> function takes a numeric argument and\n+function. \n+                    </para>\n+                    <para>\n+The <literal>SQRT</literal> function takes a numeric argument and\n returns a double.\n                     </para>\n                     <para>\n@@ -2676,12 +3059,20 @@ not portable.\n                     </para>\n                     <para>\n The <literal>MOD</literal> function takes two integer arguments and returns an\n-integer. The <literal>SIZE</literal> function returns an integer value, the\n+integer. \n+                    </para>\n+                    <para>\n+The <literal>SIZE</literal> function returns an integer value, the\n number of elements of the collection. If the collection is empty, the <literal>\n SIZE</literal> function evaluates to zero. Numeric arguments to these functions\n may correspond to the numeric Java object types as well as the primitive numeric\n types.\n                     </para>\n+                    <para>\n+The INDEX function returns an integer value corresponding to the position of its argument in an\n+ordered list. The INDEX function can only be applied to identification variables denoting types for\n+which an order column has been specified.\n+                    </para>\n                 </section>\n                 <section id=\"jpa_langref_datetime\">\n                     <title>\n@@ -2696,7 +3087,7 @@ the database server.\n                     </para>\n                 </section>\n             </section>\n-        </section>\n+            </section>\n         <section id=\"jpa_langref_group\">\n             <title>\n                 JPQL GROUP BY, HAVING"}]}

