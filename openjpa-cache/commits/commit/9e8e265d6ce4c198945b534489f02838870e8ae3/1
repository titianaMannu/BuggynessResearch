{"sha":"9e8e265d6ce4c198945b534489f02838870e8ae3","node_id":"MDY6Q29tbWl0MjA2MzY0OjllOGUyNjVkNmNlNGMxOTg5NDViNTM0NDg5ZjAyODM4ODcwZThhZTM=","commit":{"author":{"name":"David J. Wisneski","email":"wisneskid@apache.org","date":"2007-04-03T19:34:59Z"},"committer":{"name":"David J. Wisneski","email":"wisneskid@apache.org","date":"2007-04-03T19:34:59Z"},"message":"changes for JIRA OPENJPA-182\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@525252 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"cf4c162441bc28dc87c66a2cc750902af715da91","url":"https://api.github.com/repos/apache/openjpa/git/trees/cf4c162441bc28dc87c66a2cc750902af715da91"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/9e8e265d6ce4c198945b534489f02838870e8ae3","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/9e8e265d6ce4c198945b534489f02838870e8ae3","html_url":"https://github.com/apache/openjpa/commit/9e8e265d6ce4c198945b534489f02838870e8ae3","comments_url":"https://api.github.com/repos/apache/openjpa/commits/9e8e265d6ce4c198945b534489f02838870e8ae3/comments","author":null,"committer":null,"parents":[{"sha":"9c25f9bdf555dd57de22e5cbbc9b73cce7c0c000","url":"https://api.github.com/repos/apache/openjpa/commits/9c25f9bdf555dd57de22e5cbbc9b73cce7c0c000","html_url":"https://github.com/apache/openjpa/commit/9c25f9bdf555dd57de22e5cbbc9b73cce7c0c000"}],"stats":{"total":245,"additions":239,"deletions":6},"files":[{"sha":"5c3ff4bfcbb007379af89d69701d2be2210f7686","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/9e8e265d6ce4c198945b534489f02838870e8ae3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/9e8e265d6ce4c198945b534489f02838870e8ae3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java?ref=9e8e265d6ce4c198945b534489f02838870e8ae3","patch":"@@ -52,7 +52,7 @@ public AbstractDB2Dictionary() {\n         supportsLockingWithOrderClause = false;\n         supportsLockingWithOuterJoin = false;\n         supportsLockingWithInnerJoin = false;\n-        supportsLockingWithSelectRange = false;\n+        supportsLockingWithSelectRange = true;\n \n         requiresAutoCommitForMetaData = true;\n         requiresAliasForSubselect = true;"},{"sha":"bb6f3c10a80c86dab220273d6dd11bacd75896f6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","status":"modified","additions":238,"deletions":5,"changes":243,"blob_url":"https://github.com/apache/openjpa/blob/9e8e265d6ce4c198945b534489f02838870e8ae3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/9e8e265d6ce4c198945b534489f02838870e8ae3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java?ref=9e8e265d6ce4c198945b534489f02838870e8ae3","patch":"@@ -15,13 +15,15 @@\n  */\r\n package org.apache.openjpa.jdbc.sql;\r\n \r\n+import java.lang.reflect.Method;\r\n import java.sql.Connection;\r\n import java.sql.DatabaseMetaData;\r\n import java.sql.SQLException;\r\n import java.util.Arrays;\r\n-\r\n+import java.util.StringTokenizer;\r\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\r\n import org.apache.openjpa.jdbc.schema.Sequence;\r\n+import org.apache.openjpa.lib.log.Log;\r\n \r\n /**\r\n  * Dictionary for IBM DB2 database.\r\n@@ -31,7 +33,18 @@\n \r\n     public String optimizeClause = \"optimize for\";\r\n     public String rowClause = \"row\";\r\n-\r\n+    private int db2ServerType = 0; \r\n+    private static final int  db2ISeriesV5R3AndEarlier = 1;\r\n+    private static final int db2UDBV81OrEarlier = 2;\r\n+    private static final int db2ZOSV8x = 3;\r\n+    private static final int db2UDBV82AndLater = 4;\r\n+    private static final int  db2ISeriesV5R4AndLater = 5;\r\n+\tprivate static final String  forUpdateOfClause=\"FOR UPDATE OF\";\r\n+    private static final String  withRSClause=\"WITH RS\";\r\n+    private static final String  withRRClause=\"WITH RR\";\r\n+    private static final String  useKeepUpdateLockClause= \"USE AND KEEP UPDATE LOCKS\";\r\n+    private static final String  useKeepExclusiveLockClause=\"USE AND KEEP EXCLUSIVE LOCKS\";\r\n+    private static final String  forReadOnlyClause = \"FOR READ ONLY\";\r\n     public DB2Dictionary() {\r\n         platform = \"DB2\";\r\n         validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\r\n@@ -170,6 +183,18 @@ public void connectedConfiguration(Connection conn) throws SQLException {\n     \tif (isJDBC3(metaData)) {\r\n \t\t\tint maj = metaData.getDatabaseMajorVersion();\r\n \t    \tint min = metaData.getDatabaseMinorVersion();\r\n+\t    \t\r\n+\t    \t// Determine the type of DB2 database\r\n+\t    \tif (isDB2ISeriesV5R3AndEarlier(metaData))\r\n+\t    \t    db2ServerType =db2ISeriesV5R3AndEarlier;\r\n+\t    \telse if (isDB2UDBV81OrEarlier(metaData,maj,min))\r\n+\t    \t    db2ServerType =db2UDBV81OrEarlier;\r\n+\t    \telse if (isDB2ZOSV8x(metaData,maj))\r\n+\t    \t    db2ServerType =db2ZOSV8x;\r\n+\t    \telse if (isDB2UDBV82AndLater(metaData,maj,min))\r\n+\t    \t    db2ServerType=db2UDBV82AndLater;\r\n+\t    \telse if (isDB2ISeriesV5R4AndLater(metaData))\r\n+\t    \t    db2ServerType=db2ISeriesV5R4AndLater;\r\n \r\n \t    \tif (maj >= 9 || (maj == 8 && min >= 2)) {\r\n \t    \t\tsupportsLockingWithMultipleTables = true;\r\n@@ -198,13 +223,221 @@ public void connectedConfiguration(Connection conn) throws SQLException {\n         }\r\n     }\r\n     \r\n+    /** Get the update clause for the query based on the \r\n+     * updateClause and isolationLevel hints\r\n+     */\r\n+    public String getForUpdateClause(JDBCFetchConfiguration fetch, boolean forUpdate) {\r\n+        String isolationLevel = null;\r\n+        Boolean updateClause = null;\r\n+        DatabaseMetaData metaData = null;\r\n+        StringBuffer forUpdateString = new StringBuffer();\r\n+        try {\r\n+            // Determine the update clause/isolationLevel the hint \r\n+            // overrides the persistence.xml value\r\n+            if (fetch != null && fetch.getHint(\"openjpa.hint.updateClause\")\r\n+                !=null )\r\n+                updateClause = (Boolean)fetch.\r\n+                getHint(\"openjpa.hint.updateClause\");\r\n+            else \r\n+                updateClause = forUpdate;\r\n+            if (fetch != null &&fetch.getHint(\"openjpa.hint.isolationLevel\")\r\n+                !=null )\r\n+                isolationLevel = (String)fetch.\r\n+                getHint(\"openjpa.hint.isolationLevel\");\r\n+            else \r\n+                isolationLevel = conf.getTransactionIsolation();\r\n+            if (updateClause == false)\r\n+                //This sql is not for update so add FOR Read Only clause\r\n+                forUpdateString.append(\" \").append(forReadOnlyClause)\r\n+                .append(\" \");\r\n+            else if (updateClause == true){\r\n+\r\n+                switch(db2ServerType){\r\n+                case db2ISeriesV5R3AndEarlier:\r\n+                case db2UDBV81OrEarlier: \r\n+                    if (isolationLevel.equals(\"read-uncommitted\"))\r\n+                        forUpdateString.append(\" \").append(withRSClause)\r\n+                        .append(\" \").append(forUpdateOfClause).append(\" \");\r\n+                    else\r\n+                        forUpdateString.append(\" \").append(forUpdateOfClause)\r\n+                        .append(\" \");\r\n+                    break;   \r\n+                case db2ZOSV8x:\r\n+                case db2UDBV82AndLater: \r\n+                    if (isolationLevel.equals(\"serializable\"))\r\n+                        forUpdateString.append(\" \").append(withRRClause)\r\n+                        .append(\" \").append(useKeepUpdateLockClause)\r\n+                        .append(\" \");\r\n+                    else\r\n+                        forUpdateString.append(\" \").append(withRSClause)\r\n+                        .append(\" \").append(useKeepUpdateLockClause)\r\n+                        .append(\" \");\t\r\n+                    break;\r\n+                case db2ISeriesV5R4AndLater:\r\n+                    if (isolationLevel.equals(\"serializable\"))\r\n+                        forUpdateString.append(\" \").append(withRRClause)\r\n+                        .append(\" \").append(useKeepExclusiveLockClause)\r\n+                        .append(\" \");\r\n+                    else\r\n+                        forUpdateString.append(\" \").append(withRSClause)\r\n+                        .append(\" \").append(useKeepExclusiveLockClause)\r\n+                        .append(\" \");\t\r\n+                }\r\n+            }\r\n+        }    \r\n+        catch (Exception e) {\r\n+            if (log.isTraceEnabled())\r\n+                log.error(e.toString(),e);\r\n+        }\r\n+        return forUpdateString.toString();\r\n+    }  \r\n+\r\n+   \r\n+    /** Override the DBDictionary toSelect to call getOptimizeClause and append \r\n+     *   to the select string\r\n+     */   \r\n+    public SQLBuffer toSelect(SQLBuffer selects, JDBCFetchConfiguration fetch,\r\n+       SQLBuffer from, SQLBuffer where, SQLBuffer group,\r\n+       SQLBuffer having, SQLBuffer order,\r\n+       boolean distinct, boolean forUpdate, long start, long end,\r\n+       int expectedResultCount) {\r\n+       String forUpdateString = getForUpdateClause(fetch,forUpdate);\r\n+       SQLBuffer selString = toOperation(getSelectOperation(fetch), \r\n+            selects, from, where,\r\n+            group, having, order, distinct,\r\n+            forUpdate, start, end,forUpdateString);\r\n+        return selString;\r\n+    }\r\n+\r\n+    public boolean isDB2UDBV82AndLater(DatabaseMetaData metadata, int maj,\r\n+        int min) throws SQLException {\r\n+        boolean match = false;\r\n+        if (metadata.getDatabaseProductVersion().indexOf(\"SQL\") != -1 \r\n+            && ((maj ==8 && min >=2) ||(maj >=8)))\r\n+            match = true; \r\n+        return match;\r\n+    }\r\n+\r\n+    public boolean isDB2ZOSV8x(DatabaseMetaData metadata,int maj)\r\n+       throws SQLException {\r\n+       boolean match = false;\r\n+       if (metadata.getDatabaseProductVersion().indexOf(\"DSN\") != -1 \r\n+           && maj ==8 )\r\n+           match = true; \r\n+        return match;\r\n+    }\r\n+\r\n+    public boolean isDB2ISeriesV5R3AndEarlier(DatabaseMetaData metadata)\r\n+       throws SQLException {\r\n+       boolean match = false;\r\n+       if (metadata.getDatabaseProductVersion().indexOf(\"AS\") != -1 \r\n+           && generateVersionNumber(metadata.getDatabaseProductVersion())\r\n+           <= 530 )\r\n+           match = true; \r\n+       return match;\r\n+    }\r\n+\r\n+    public boolean isDB2ISeriesV5R4AndLater(DatabaseMetaData metadata)\r\n+       throws SQLException {\r\n+       boolean match = false;\r\n+       if (metadata.getDatabaseProductVersion().indexOf(\"AS\") != -1 \r\n+           && generateVersionNumber(metadata.getDatabaseProductVersion())\r\n+           >= 540 )\r\n+           match = true; \r\n+      return match;\r\n+    }\r\n+\r\n+    public boolean isDB2UDBV81OrEarlier(DatabaseMetaData metadata,int maj, \r\n+        int min) throws SQLException {\r\n+        boolean match = false;\r\n+        if (metadata.getDatabaseProductVersion().indexOf(\"SQL\") != -1 &&\r\n+           ((maj ==8 && min <=1)|| maj <8 ))\r\n+            match = true; \r\n+        return match;\r\n+    }\r\n+\r\n+    /** Get the version number for the ISeries\r\n+     */ \r\n+    protected  int generateVersionNumber(String versionString) {\r\n+        String s = versionString.substring(versionString.indexOf('V'));\r\n+        s = s.toUpperCase(); \r\n+        int i = -1;\r\n+        StringTokenizer stringtokenizer = new StringTokenizer(s, \"VRM\", false);\r\n+        if (stringtokenizer.countTokens() == 3)\r\n+        {\r\n+            String s1 = stringtokenizer.nextToken();\r\n+            s1 = s1 + stringtokenizer.nextToken();\r\n+            s1 = s1 + stringtokenizer.nextToken();\r\n+            i = Integer.parseInt(s1);\r\n+        }\r\n+        return i;\r\n+    }\r\n+ \r\n+       \r\n+    /**\r\n+     * Override the toOperationMethod of DBDictionary to pass the \r\n+     * forUpdateString.\r\n+     */\r\n+    protected SQLBuffer toOperation(String op, SQLBuffer selects, \r\n+        SQLBuffer from, SQLBuffer where, SQLBuffer group, SQLBuffer having, \r\n+        SQLBuffer order, boolean distinct, boolean forUpdate, long start, \r\n+        long end,String forUpdateString) {\r\n+        SQLBuffer buf = new SQLBuffer(this);\r\n+        buf.append(op);\r\n+        boolean range = start != 0 || end != Long.MAX_VALUE;\r\n+        if (range && rangePosition == RANGE_PRE_DISTINCT)\r\n+            appendSelectRange(buf, start, end);\r\n+        if (distinct)\r\n+            buf.append(\" DISTINCT\");\r\n+        if (range && rangePosition == RANGE_POST_DISTINCT)\r\n+            appendSelectRange(buf, start, end);\r\n+        buf.append(\" \").append(selects).append(\" FROM \").append(from);\r\n+\r\n+        if (where != null && !where.isEmpty())\r\n+            buf.append(\" WHERE \").append(where);\r\n+        if (group != null && !group.isEmpty())\r\n+            buf.append(\" GROUP BY \").append(group);\r\n+        if (having != null && !having.isEmpty()) {\r\n+            assertSupport(supportsHaving, \"SupportsHaving\");\r\n+            buf.append(\" HAVING \").append(having);\r\n+        }\r\n+        if (order != null && !order.isEmpty())\r\n+            buf.append(\" ORDER BY \").append(order);\r\n+        if (range && rangePosition == RANGE_POST_SELECT)\r\n+            appendSelectRange(buf, start, end);\r\n+\r\n+        if (!simulateLocking ) {\r\n+            assertSupport(supportsSelectForUpdate, \"SupportsSelectForUpdate\");\r\n+            buf.append(\" \").append(forUpdateString);\r\n+        }\r\n+        if (range && rangePosition == RANGE_POST_LOCK)\r\n+            appendSelectRange(buf, start, end);\r\n+        return buf;\r\n+    }\r\n+\r\n     public SQLBuffer toSelect(Select sel, boolean forUpdate,\r\n         JDBCFetchConfiguration fetch) {\r\n-        SQLBuffer buf = super.toSelect(sel, forUpdate, fetch); \r\n+        sel.addJoinClassConditions();\r\n+        boolean update = forUpdate && sel.getFromSelect() == null;\r\n+        SQLBuffer select = getSelects(sel, false, update);\r\n+        SQLBuffer ordering = null;\r\n+        if (!sel.isAggregate() || sel.getGrouping() != null)\r\n+            ordering = sel.getOrdering();\r\n+        SQLBuffer from;\r\n+        if (sel.getFromSelect() != null)\r\n+            from = getFromSelect(sel, forUpdate);\r\n+        else\r\n+            from = getFrom(sel, update);\r\n+        SQLBuffer where = getWhere(sel, update);\r\n+        String forUpdateString = getForUpdateClause(fetch,forUpdate);\r\n+        SQLBuffer buf = toOperation(getSelectOperation(fetch), select,\r\n+            from, where,sel.getGrouping(), sel.getHaving(),  ordering,\r\n+            sel.isDistinct(), forUpdate, sel.getStartIndex(),\r\n+            sel.getEndIndex(),forUpdateString);\r\n         if (sel.getExpectedResultCount() > 0)\r\n             buf.append(\" \").append(optimizeClause).append(\" \").\r\n-                append(String.valueOf(sel.getExpectedResultCount())).\r\n-                append(\" \").append(rowClause);\r\n+            append(String.valueOf(sel.getExpectedResultCount())).\r\n+            append(\" \").append(rowClause);\r\n         return buf;\r\n     }\r\n }\r"}]}

