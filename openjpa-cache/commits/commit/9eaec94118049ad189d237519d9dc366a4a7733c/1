{"sha":"9eaec94118049ad189d237519d9dc366a4a7733c","node_id":"MDY6Q29tbWl0MjA2MzY0OjllYWVjOTQxMTgwNDlhZDE4OWQyMzc1MTlkOWRjMzY2YTRhNzczM2M=","commit":{"author":{"name":"David J. Wisneski","email":"wisneskid@apache.org","date":"2007-05-11T15:44:13Z"},"committer":{"name":"David J. Wisneski","email":"wisneskid@apache.org","date":"2007-05-11T15:44:13Z"},"message":"OpenJPA 168  testcase\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@537213 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a39fe8838b82385a19869ab47b47d3161143cc35","url":"https://api.github.com/repos/apache/openjpa/git/trees/a39fe8838b82385a19869ab47b47d3161143cc35"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/9eaec94118049ad189d237519d9dc366a4a7733c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/9eaec94118049ad189d237519d9dc366a4a7733c","html_url":"https://github.com/apache/openjpa/commit/9eaec94118049ad189d237519d9dc366a4a7733c","comments_url":"https://api.github.com/repos/apache/openjpa/commits/9eaec94118049ad189d237519d9dc366a4a7733c/comments","author":null,"committer":null,"parents":[{"sha":"a461910160707b08dd4a9cb1cf95ba04bd27c357","url":"https://api.github.com/repos/apache/openjpa/commits/a461910160707b08dd4a9cb1cf95ba04bd27c357","html_url":"https://github.com/apache/openjpa/commit/a461910160707b08dd4a9cb1cf95ba04bd27c357"}],"stats":{"total":112,"additions":112,"deletions":0},"files":[{"sha":"7ff53dae3a48c77dbe0f09067dba0561a887b37e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestOptimizeForClause.java","status":"added","additions":112,"deletions":0,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/9eaec94118049ad189d237519d9dc366a4a7733c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestOptimizeForClause.java","raw_url":"https://github.com/apache/openjpa/raw/9eaec94118049ad189d237519d9dc366a4a7733c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestOptimizeForClause.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestOptimizeForClause.java?ref=9eaec94118049ad189d237519d9dc366a4a7733c","patch":"@@ -0,0 +1,112 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.persistence.jdbc;\r\n+\r\n+import javax.persistence.Query;\r\n+\r\n+import org.apache.openjpa.persistence.test.SQLListenerTestCase;\r\n+import org.apache.openjpa.persistence.simple.AllFieldTypes;\r\n+import org.apache.openjpa.persistence.OpenJPAPersistence;\r\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\r\n+import org.apache.openjpa.persistence.OpenJPAQuery;\r\n+import org.apache.openjpa.persistence.InvalidStateException;\r\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\r\n+import org.apache.openjpa.jdbc.sql.DB2Dictionary;\r\n+import org.apache.openjpa.jdbc.sql.HSQLDictionary;\r\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n+\r\n+public class TestOptimizeForClause\r\n+    extends SQLListenerTestCase {\r\n+\r\n+    public void setUp() {\r\n+        setUp(AllFieldTypes.class);\r\n+    }\r\n+\r\n+    public void testOptimizeForClauseViaHint() {\r\n+        testOptimizeForClause(true,false,false);\r\n+    }\r\n+\r\n+    public void testOptimizeForClauseViaFind() {\r\n+        testOptimizeForClause(false,true,false);\r\n+    }\r\n+    public void testOptimizeForClauseViaQueryHint() {\r\n+        testOptimizeForClause(false,true,true);\r\n+    }\r\n+    public void testOptimizeForClause(boolean hint,\r\n+        boolean find, boolean queryHint) {\r\n+        OpenJPAEntityManager em =\r\n+            OpenJPAPersistence.cast(emf.createEntityManager());\r\n+        DBDictionary dict = ((JDBCConfiguration) em.getConfiguration())\r\n+            .getDBDictionaryInstance();\r\n+\r\n+        // hsql doesn't support optimizing; circumvent the test\r\n+        if (dict instanceof HSQLDictionary)\r\n+            return;\r\n+\r\n+        sql.clear();\r\n+        try {\r\n+            em.getTransaction().begin();\r\n+            if (hint || queryHint) {\r\n+                if (hint) {\r\n+                    Query q = em.createQuery(\r\n+                    \"select o from AllFieldTypes o where o.intField = :p\");\r\n+                    q.setParameter(\"p\", 0);\r\n+                    q.setHint(\"openjpa.hint.OptimizeResultCount\"\r\n+                         ,new Integer(8));\r\n+                    q.getResultList();\r\n+                }    \r\n+                else {\r\n+                    OpenJPAQuery q =  OpenJPAPersistence.cast (em.createQuery \r\n+                        (\"select o from AllFieldTypes o where o.intField \" +\r\n+                         \"= :p\"));\r\n+                    q.setParameter(\"p\", 0);\r\n+                    q.setHint(q.HINT_RESULT_COUNT, new Integer(8)); \r\n+                    q.getResultList();\r\n+               }     \r\n+               if (dict instanceof DB2Dictionary) {\r\n+                   assertEquals(1, sql.size());\r\n+                   assertSQL(\"SELECT t0.id, t0.booleanField, t0.byteField,\" +\r\n+                       \" t0.charField, t0.dateField, t0.doubleField, \" +\r\n+                       \"t0.floatField, t0.intField, t0.longField, \" +\r\n+                       \"t0.shortField, t0.stringField FROM AllFieldTypes \" +\r\n+                       \"t0 WHERE \\\\(t0.intField = \\\\?\\\\)  optimize for 8 row\");\r\n+               }\r\n+            }\r\n+            else {\r\n+                 em.find(AllFieldTypes.class, 0);\r\n+                 if (dict instanceof DB2Dictionary ) {\r\n+                    assertEquals(1, sql.size());\r\n+                    assertSQL(\"SELECT t0.booleanField, t0.byteField, \" +\r\n+                        \"t0.charField, t0.dateField, t0.doubleField, \" +\r\n+                        \"t0.floatField, t0.intField, t0.longField, \" +\r\n+                        \"t0.shortField, t0.stringField FROM AllFieldTypes\" +\r\n+                        \" t0 WHERE t0.id = \\\\?  optimize for 1 row\");\r\n+                }\r\n+                   \r\n+            }\r\n+        } catch (InvalidStateException pe) {\r\n+            // if we're not using DB2, we expect an InvalidStateException.\r\n+            if (dict instanceof DB2Dictionary)\r\n+                throw pe;\r\n+        } finally {\r\n+            em.getTransaction().rollback();\r\n+            em.close();\r\n+        }\r\n+    }\r\n+}\r"}]}

