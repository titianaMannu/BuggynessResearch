{"sha":"9f24d10ecdd5c9286f22e363852e84f116d0f994","node_id":"MDY6Q29tbWl0MjA2MzY0OjlmMjRkMTBlY2RkNWM5Mjg2ZjIyZTM2Mzg1MmU4NGYxMTZkMGY5OTQ=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2009-09-28T23:51:33Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2009-09-28T23:51:33Z"},"message":"OPENJPA-1050: Use generics for DataCache\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@819771 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"37c251f01f9afbee09513168c17d164a8f0067d5","url":"https://api.github.com/repos/apache/openjpa/git/trees/37c251f01f9afbee09513168c17d164a8f0067d5"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/9f24d10ecdd5c9286f22e363852e84f116d0f994","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/9f24d10ecdd5c9286f22e363852e84f116d0f994","html_url":"https://github.com/apache/openjpa/commit/9f24d10ecdd5c9286f22e363852e84f116d0f994","comments_url":"https://api.github.com/repos/apache/openjpa/commits/9f24d10ecdd5c9286f22e363852e84f116d0f994/comments","author":null,"committer":null,"parents":[{"sha":"450f8352f856cd49bbf53525502db99821654441","url":"https://api.github.com/repos/apache/openjpa/commits/450f8352f856cd49bbf53525502db99821654441","html_url":"https://github.com/apache/openjpa/commit/450f8352f856cd49bbf53525502db99821654441"}],"stats":{"total":413,"additions":195,"deletions":218},"files":[{"sha":"2adb489859b9606e30c6fd8bbe1bcf62624b04c1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java?ref=9f24d10ecdd5c9286f22e363852e84f116d0f994","patch":"@@ -117,9 +117,9 @@ public void commit(Collection additions, Collection newUpdates,\n             putAllInternal(existingUpdates);\n \n         if (log.isTraceEnabled()) {\n-            Collection addIds = new ArrayList(additions.size());\n-            Collection upIds = new ArrayList(newUpdates.size());\n-            Collection exIds = new ArrayList(existingUpdates.size());\n+            Collection<Object> addIds = new ArrayList<Object>(additions.size());\n+            Collection<Object> upIds = new ArrayList<Object>(newUpdates.size());\n+            Collection<Object> exIds = new ArrayList<Object>(existingUpdates.size());\n \n             for (Iterator iter = additions.iterator(); iter.hasNext();)\n                 addIds.add(((DataCachePCData) iter.next()).getId());"},{"sha":"cc69828bf06602a3b9cc8f697f95811462d07201","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCache.java","status":"modified","additions":12,"deletions":8,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCache.java","raw_url":"https://github.com/apache/openjpa/raw/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCache.java?ref=9f24d10ecdd5c9286f22e363852e84f116d0f994","patch":"@@ -97,8 +97,8 @@\n      * @param deletes A collection of object IDs that have been deleted\n      * and must therefore be dropped from the cache.\n      */\n-    public void commit(Collection additions, Collection newUpdates,\n-        Collection existingUpdates, Collection deletes);\n+    public void commit(Collection<DataCachePCData> additions, Collection<DataCachePCData> newUpdates,\n+        Collection<DataCachePCData> existingUpdates, Collection<Object> deletes);\n \n     /**\n      * Returns <code>true</code> if this cache contains data\n@@ -110,7 +110,7 @@ public void commit(Collection additions, Collection newUpdates,\n     /**\n      * Returns the indexes of the oids in this cache.\n      */\n-    public BitSet containsAll(Collection oids);\n+    public BitSet containsAll(Collection<Object> oids);\n \n     /**\n      * Return the cached object for the given oid. Modifying the returned\n@@ -165,7 +165,7 @@ public void commit(Collection additions, Collection newUpdates,\n      * @return the indexes of the removed oids\n      * @see #remove\n      */\n-    public BitSet removeAll(Collection oids);\n+    public BitSet removeAll(Collection<Object> oids);\n \n     /**\n      * Evict all values of a specified type.\n@@ -197,7 +197,7 @@ public void commit(Collection additions, Collection newUpdates,\n      * @return the indexes of the pinned oids\n      * @see #pin\n      */\n-    public BitSet pinAll(Collection oids);\n+    public BitSet pinAll(Collection<Object> oids);\n \n     /**\n      * Pin all oids for the given type.\n@@ -223,7 +223,7 @@ public void commit(Collection additions, Collection newUpdates,\n      * @return the indexes of the unpinned oids\n      * @see #unpin\n      */\n-    public BitSet unpinAll(Collection oids);\n+    public BitSet unpinAll(Collection<Object> oids);\n \n     /**\n      * Unpin all oids associaed with the given type from the cache.\n@@ -261,9 +261,13 @@ public void commit(Collection additions, Collection newUpdates,\n \tpublic void close ();\n     \n     /**\n-\t * returns objects from the caches for a given list of keys\n+\t * Gets objects from the caches for a given list of keys.\n+\t * The returned map has the same keys as the given keys.\n+\t * If the cache does not contain data for a specific key,\n+\t * the returned map still contains the key with a null value.  \n+\t * \n      */\n-    public Map getAll(List keys);\n+    public Map<Object,DataCachePCData> getAll(List<Object> keys);\n     \n     /**\n      * Returns number of read/write request and cache hit ratio data."},{"sha":"ed2711085301bfabb37535024db1bb244397ffe0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","status":"modified","additions":79,"deletions":102,"changes":181,"blob_url":"https://github.com/apache/openjpa/blob/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java?ref=9f24d10ecdd5c9286f22e363852e84f116d0f994","patch":"@@ -77,8 +77,7 @@ public DataCacheStoreManager(StoreManager sm) {\n \n     public void setContext(StoreContext ctx) {\n         _ctx = ctx;\n-        _gen = ctx.getConfiguration().getDataCacheManagerInstance().\n-            getPCDataGenerator();\n+        _gen = ctx.getConfiguration().getDataCacheManagerInstance().getPCDataGenerator();\n         super.setContext(ctx);\n     }\n \n@@ -110,18 +109,16 @@ public void rollback() {\n     /**\n      * Evict all members of the given classes.\n      */\n-    private void evictTypes(Collection classes) {\n+    private void evictTypes(Collection<Class<?>> classes) {\n         if (classes.isEmpty())\n             return;\n \n         MetaDataRepository mdr = _ctx.getConfiguration().\n             getMetaDataRepositoryInstance();\n         ClassLoader loader = _ctx.getClassLoader();\n \n-        Class cls;\n         DataCache cache;\n-        for (Iterator itr = classes.iterator(); itr.hasNext();) {\n-            cls = (Class) itr.next();\n+        for (Class<?> cls : classes) {\n             cache = mdr.getMetaData(cls, loader, false).getDataCache();\n             if (cache != null)\n                 cache.removeAll(cls, false);\n@@ -134,20 +131,20 @@ private void evictTypes(Collection classes) {\n     private void updateCaches() {\n         if(_ctx.getCacheStoreMode() != DataCacheStoreMode.BYPASS ) { \n             // map each data cache to the modifications we need to perform\n-            Map modMap = null;\n+            Map<DataCache,Modifications> modMap = null;\n+            if ((_ctx.getPopulateDataCache() && _inserts != null) || _updates != null || _deletes != null)\n+                modMap = new HashMap<DataCache,Modifications>();\n             Modifications mods;\n             DataCachePCData data;\n             DataCache cache;\n \n             // create pc datas for inserts\n             if (_ctx.getPopulateDataCache() && _inserts != null) {\n-                for(OpenJPAStateManager sm : _inserts) {\n+                for (OpenJPAStateManager sm : _inserts) {\n                     cache = sm.getMetaData().getDataCache();\n                     if (cache == null)\n                         continue;\n \n-                    if (modMap == null)\n-                        modMap = new HashMap();\n                     mods = getModifications(modMap, cache);\n                     data = newPCData(sm);\n                     data.store(sm);\n@@ -159,7 +156,7 @@ private void updateCaches() {\n             if (_updates != null) {\n                 BitSet fields;\n                 OpenJPAStateManager sm;\n-                for(Map.Entry<OpenJPAStateManager, BitSet> entry : _updates.entrySet()) { \n+                for (Map.Entry<OpenJPAStateManager, BitSet> entry : _updates.entrySet()) { \n                     sm = entry.getKey();\n                     fields = entry.getValue();\n \n@@ -173,8 +170,6 @@ private void updateCaches() {\n                     // to the underlying cache are valid. If the commit had not\n                     // already succeeded, then we'd want to clone the retrieved\n                     // object.\n-                    if (modMap == null)\n-                        modMap = new HashMap();\n                     data = cache.get(sm.getObjectId());\n                     mods = getModifications(modMap, cache);\n \n@@ -194,33 +189,30 @@ private void updateCaches() {\n \n             // remove pcdatas for deletes\n             if (_deletes != null) {\n-                for(OpenJPAStateManager sm : _deletes) { \n+                for (OpenJPAStateManager sm : _deletes) { \n                     cache = sm.getMetaData().getDataCache();\n                     if (cache == null)\n                         continue;\n \n-                    if (modMap == null)\n-                        modMap = new HashMap();\n                     mods = getModifications(modMap, cache);\n                     mods.deletes.add(sm.getObjectId());\n                 }\n             }\n \n             // notify the caches of the changes\n             if (modMap != null) {\n-                for (Iterator itr = modMap.entrySet().iterator(); itr.hasNext();) {\n-                    Map.Entry entry = (Map.Entry) itr.next();\n-                    cache = (DataCache) entry.getKey();\n-                    mods = (Modifications) entry.getValue();\n+                for (Map.Entry<DataCache,Modifications> entry : modMap.entrySet()) {\n+                    cache = entry.getKey();\n+                    mods = entry.getValue();\n \n                     // make sure we're not caching old versions\n                     cache.writeLock();\n                     try {\n-                        transformToVersionSafePCDatas(cache, mods.additions);\n-                        transformToVersionSafePCDatas(cache, mods.newUpdates);\n-                        transformToVersionSafePCDatas(cache, mods.existingUpdates);\n-                        cache.commit(mods.additions, mods.newUpdates,\n-                            mods.existingUpdates, mods.deletes);\n+                        cache.commit(\n+                                transformToVersionSafePCDatas(cache, mods.additions), \n+                                transformToVersionSafePCDatas(cache, mods.newUpdates), \n+                                transformToVersionSafePCDatas(cache, mods.existingUpdates), \n+                                mods.deletes);\n                     } finally {\n                         cache.writeUnlock();\n                     }\n@@ -239,12 +231,12 @@ private void updateCaches() {\n             QueryCache queryCache = _ctx.getConfiguration().\n             getDataCacheManagerInstance().getSystemQueryCache();\n             if (queryCache != null) {\n-                Collection pers = _ctx.getPersistedTypes();\n-                Collection del = _ctx.getDeletedTypes();\n-                Collection up = _ctx.getUpdatedTypes();\n+                Collection<Class<?>> pers = _ctx.getPersistedTypes();\n+                Collection<Class<?>> del = _ctx.getDeletedTypes();\n+                Collection<Class<?>> up = _ctx.getUpdatedTypes();\n                 int size = pers.size() + del.size() + up.size();\n                 if (size > 0) {\n-                    Collection types = new ArrayList(size);\n+                    Collection<Class<?>> types = new ArrayList<Class<?>>(size);\n                     types.addAll(pers);\n                     types.addAll(del);\n                     types.addAll(up);\n@@ -258,41 +250,37 @@ private void updateCaches() {\n      * Transforms a collection of {@link PCDataHolder}s that might contain\n      * stale instances into a collection of up-to-date {@link DataCachePCData}s.\n      */\n-    private void transformToVersionSafePCDatas(DataCache cache,\n-        List holders) {\n-\n+    private List<DataCachePCData> transformToVersionSafePCDatas(DataCache cache, List<PCDataHolder> holders) {\n+        List<DataCachePCData> transformed = new ArrayList<DataCachePCData>(holders.size());\n         Map<Object,Integer> ids = new HashMap<Object,Integer>(holders.size());\n         // this list could be removed if DataCache.getAll() took a Collection\n-        List idList = new ArrayList(holders.size());\n+        List<Object> idList = new ArrayList<Object>(holders.size());\n         int i = 0;\n-        for (PCDataHolder holder : (List<PCDataHolder>) holders) {\n+        for (PCDataHolder holder : holders) {\n             ids.put(holder.sm.getObjectId(), i++);\n             idList.add(holder.sm.getObjectId());\n         }\n \n-        List<PCDataHolder> removes = new ArrayList<PCDataHolder>();\n         Map<Object,DataCachePCData> pcdatas = cache.getAll(idList);\n         for (Entry<Object,DataCachePCData> entry : pcdatas.entrySet()) {\n             Integer index = ids.get(entry.getKey());\n             DataCachePCData oldpc = entry.getValue();\n-            PCDataHolder holder = (PCDataHolder) holders.get(index);\n+            PCDataHolder holder = holders.get(index);\n             if (oldpc != null && compareVersion(holder.sm,\n                 holder.sm.getVersion(), oldpc.getVersion()) == VERSION_EARLIER)\n-                removes.add(holder);\n+                continue;\n             else\n-                holders.set(index, holder.pcdata);\n+                transformed.add(holder.pcdata);\n         }\n-\n-        for (PCDataHolder holder : removes)\n-            holders.remove(holder);\n+        return transformed;\n     }\n \n     /**\n      * Return a {@link Modifications} instance to track modifications\n      * to the given cache, creating and caching the instance if it does\n      * not already exist in the given map.\n      */\n-    private static Modifications getModifications(Map modMap, DataCache cache) {\n+    private static Modifications getModifications(Map<DataCache,Modifications> modMap, DataCache cache) {\n         Modifications mods = (Modifications) modMap.get(cache);\n         if (mods == null) {\n             mods = new Modifications();\n@@ -334,45 +322,43 @@ public boolean syncVersion(OpenJPAStateManager sm, Object edata) {\n     }\n \n     public boolean initialize(OpenJPAStateManager sm, PCState state, FetchConfiguration fetch, Object edata) {\n-        boolean rval; \n+        boolean fromDatabase; \n         DataCache cache = sm.getMetaData().getDataCache();\n+        DataCachePCData data = null;\n         boolean updateCache = _ctx.getCacheStoreMode() != DataCacheStoreMode.BYPASS && _ctx.getPopulateDataCache();\n         if (cache == null || sm.isEmbedded() || _ctx.getCacheRetrieveMode() == DataCacheRetrieveMode.BYPASS\n             || _ctx.getCacheStoreMode() == DataCacheStoreMode.REFRESH) {\n-            rval = super.initialize(sm, state, fetch, edata);\n-        }\n-\n-        else {\n-            DataCachePCData data = cache.get(sm.getObjectId());\n+            fromDatabase = super.initialize(sm, state, fetch, edata);\n+        } else {\n+            data = cache.get(sm.getObjectId());\n             if (data != null && !isLocking(fetch)) {                \n                 //### the 'data.type' access here probably needs to be\n                 //### addressed for bug 511\n                 sm.initialize(data.getType(), state);\n                 data.load(sm, fetch, edata);\n                 // no need to update the cache. \n                 updateCache = false;\n-                rval = true;\n+                fromDatabase = true;\n             } else {\n                 // initialize from store manager\n-                rval = super.initialize(sm, state, fetch, edata);\n+                fromDatabase = super.initialize(sm, state, fetch, edata);\n             }\n         }\n \n-        if (cache != null && (rval && updateCache)) {\n+        if (cache != null && (fromDatabase && updateCache)) {\n             // update cache if the result came from the database and configured to store or refresh the cache.\n-            cacheStateManager(cache, sm);\n+            cacheStateManager(cache, sm, data);\n         }\n-        return rval;\n+        return fromDatabase;\n     }\n     \n-    private void cacheStateManager(DataCache cache, OpenJPAStateManager sm) {\n+    private void cacheStateManager(DataCache cache, OpenJPAStateManager sm, DataCachePCData data) {\n         if(sm.isFlushed()) { \n             return;\n         }\n         // make sure that we're not trying to cache an old version\n         cache.writeLock();\n         try {\n-            DataCachePCData data = cache.get(sm.getObjectId());\n             if (data != null && compareVersion(sm, sm.getVersion(), data.getVersion()) == VERSION_EARLIER) {\n                 return;\n             }\n@@ -385,10 +371,9 @@ private void cacheStateManager(DataCache cache, OpenJPAStateManager sm) {\n                 data = newPCData(sm);\n             }\n             data.store(sm);\n-            if(isNew) { \n+            if (isNew) { \n                 cache.put(data);\n-            }\n-            else {\n+            } else {\n                 cache.update(data);\n             }\n         } finally {\n@@ -403,8 +388,7 @@ public boolean load(OpenJPAStateManager sm, BitSet fields,\n             return super.load(sm, fields, fetch, lockLevel, edata);\n \n         DataCachePCData data = cache.get(sm.getObjectId());\n-        if (lockLevel == LockLevels.LOCK_NONE && !isLocking(fetch)\n-            && data != null)\n+        if (lockLevel == LockLevels.LOCK_NONE && !isLocking(fetch) && data != null)\n             data.load(sm, fields, fetch, edata);\n         if (fields.length() == 0)\n             return true;\n@@ -414,13 +398,13 @@ public boolean load(OpenJPAStateManager sm, BitSet fields,\n         if (!super.load(sm, (BitSet) fields.clone(), fetch, lockLevel, edata))\n             return false;\n         if (_ctx.getPopulateDataCache()) {\n-            cacheStateManager(cache, sm);\n+            cacheStateManager(cache, sm, data);\n         }\n         return true;\n \n     }\n \n-    public Collection loadAll(Collection sms, PCState state, int load,\n+    public Collection<Object> loadAll(Collection<OpenJPAStateManager> sms, PCState state, int load,\n     \t\tFetchConfiguration fetch, Object edata) {\n     \tif (isLocking(fetch) || \n     \t   (!isLocking(fetch) &&\n@@ -430,15 +414,13 @@ public Collection loadAll(Collection sms, PCState state, int load,\n     \t}\n \n         Map<OpenJPAStateManager, BitSet> unloaded = null;\n-        List smList = null;\n-        Map caches = new HashMap();\n-        OpenJPAStateManager sm;\n+        List<OpenJPAStateManager> smList = null;\n+        Map<DataCache,List<OpenJPAStateManager>> caches = new HashMap<DataCache,List<OpenJPAStateManager>>();\n         DataCache cache;\n         DataCachePCData data;\n         BitSet fields;\n \n-        for (Iterator itr = sms.iterator(); itr.hasNext();) {\n-            sm = (OpenJPAStateManager) itr.next();\n+        for (OpenJPAStateManager sm : sms) {\n             cache = sm.getMetaData().getDataCache();\n             if (cache == null || sm.isEmbedded()) {\n                 unloaded = addUnloaded(sm, null, unloaded);\n@@ -448,41 +430,39 @@ public Collection loadAll(Collection sms, PCState state, int load,\n             if (sm.getManagedInstance() == null\n                 || load != FORCE_LOAD_NONE\n                 || sm.getPCState() == PCState.HOLLOW) {\n-                smList = (List) caches.get(cache);\n+                smList = caches.get(cache);\n                 if (smList == null) {\n-                    smList = new ArrayList();\n+                    smList = new ArrayList<OpenJPAStateManager>();\n                     caches.put(cache, smList);\n                 }\n                 smList.add(sm);\n             } else if (!cache.contains(sm.getObjectId()))\n                 unloaded = addUnloaded(sm, null, unloaded);\n         }\n         \n-        for (Iterator itr = caches.keySet().iterator(); itr.hasNext();) {\n-            cache = (DataCache) itr.next();\n-            smList = (List) caches.get(cache);\n-            List oidList = new ArrayList(smList.size());\n+        for (Iterator<DataCache> itr = caches.keySet().iterator(); itr.hasNext();) {\n+            cache = itr.next();\n+            smList = caches.get(cache);\n+            List<Object> oidList = new ArrayList<Object>(smList.size());\n \n-            for (itr=smList.iterator();itr.hasNext();) {\n-                sm = (OpenJPAStateManager) itr.next();\n+            for (OpenJPAStateManager sm : smList) {\n                 oidList.add((OpenJPAId) sm.getObjectId());\n             }\n             \n-            Map dataMap = cache.getAll(oidList);\n+            Map<Object,DataCachePCData> dataMap = cache.getAll(oidList);\n \n-            for (itr=smList.iterator();itr.hasNext();) {\n-                sm = (OpenJPAStateManager) itr.next();\n-                data = (DataCachePCData) dataMap.get(\n-                        (OpenJPAId) sm.getObjectId());\n+            for (OpenJPAStateManager sm : smList) {\n+                data = dataMap.get(sm.getObjectId());\n \n                 if (sm.getManagedInstance() == null) {\n                     if (data != null) {\n                         //### the 'data.type' access here probably needs\n                         //### to be addressed for bug 511\n                         sm.initialize(data.getType(), state);\n                         data.load(sm, fetch, edata);\n-                    } else\n+                    } else {\n                         unloaded = addUnloaded(sm, null, unloaded);\n+                    }\n                 } else if (load != FORCE_LOAD_NONE\n                         || sm.getPCState() == PCState.HOLLOW) {\n                     data = cache.get(sm.getObjectId());\n@@ -499,11 +479,10 @@ public Collection loadAll(Collection sms, PCState state, int load,\n         }\n \n         if (unloaded == null)\n-            return Collections.EMPTY_LIST;\n+            return Collections.emptyList();\n \n         // load with delegate\n-        Collection failed = super.loadAll(unloaded.keySet(), state, load,\n-            fetch, edata);\n+        Collection<Object> failed = super.loadAll(unloaded.keySet(), state, load, fetch, edata);\n         if (!_ctx.getPopulateDataCache())\n             return failed;\n \n@@ -512,7 +491,7 @@ public Collection loadAll(Collection sms, PCState state, int load,\n         boolean isNew;\n \n         for(Map.Entry<OpenJPAStateManager, BitSet> entry : unloaded.entrySet()) { \n-            sm = entry.getKey();\n+            OpenJPAStateManager sm = entry.getKey();\n             fields = entry.getValue();\n \n             cache = sm.getMetaData().getDataCache();\n@@ -557,13 +536,12 @@ public Collection loadAll(Collection sms, PCState state, int load,\n         return unloaded;\n     }\n \n-    public Collection flush(Collection states) {\n-        Collection exceps = super.flush(states);\n+    public Collection<Exception> flush(Collection<OpenJPAStateManager> states) {\n+        Collection<Exception> exceps = super.flush(states);\n \n         // if there were errors evict bad instances and don't record changes\n         if (!exceps.isEmpty()) {\n-            for (Iterator iter = exceps.iterator(); iter.hasNext(); ) {\n-                Exception e = (Exception) iter.next();\n+            for (Exception e : exceps) {\n                 if (e instanceof OptimisticException)\n                     notifyOptimisticLockFailure((OptimisticException) e);\n             }\n@@ -574,10 +552,7 @@ public Collection flush(Collection states) {\n         if (_ctx.isTrackChangesByType())\n             return exceps;\n \n-        OpenJPAStateManager sm;\n-        for (Iterator itr = states.iterator(); itr.hasNext();) {\n-            sm = (OpenJPAStateManager) itr.next();\n-\n+        for (OpenJPAStateManager sm : states) {\n             if (sm.getPCState() == PCState.PNEW && !sm.isFlushed()) {\n                 if (_inserts == null) {\n                     _inserts = new ArrayList<OpenJPAStateManager>();\n@@ -605,7 +580,7 @@ else if (sm.getPCState() == PCState.PDIRTY) {\n                 _deletes.add(sm);\n             }\n         }\n-        return Collections.EMPTY_LIST;\n+        return Collections.emptyList();\n     }\n \n     /**\n@@ -708,8 +683,7 @@ public StoreQuery newQuery(String language) {\n     private DataCachePCData newPCData(OpenJPAStateManager sm) {\n         ClassMetaData meta = sm.getMetaData();\n         if (_gen != null)\n-            return (DataCachePCData) _gen.generatePCData\n-                (sm.getObjectId(), meta);\n+            return (DataCachePCData) _gen.generatePCData(sm.getObjectId(), meta);\n         return new DataCachePCDataImpl(sm.fetchObjectId(), meta);\n     }\n \n@@ -727,19 +701,22 @@ private boolean isLocking(FetchConfiguration fetch) {\n      */\n     private static class Modifications {\n \n-        public final List additions = new ArrayList();\n-        public final List newUpdates = new ArrayList();\n-        public final List existingUpdates = new ArrayList();\n-        public final List deletes = new ArrayList();\n+        public final List<PCDataHolder> additions = new ArrayList<PCDataHolder>();\n+        public final List<PCDataHolder> newUpdates = new ArrayList<PCDataHolder>();\n+        public final List<PCDataHolder> existingUpdates = new ArrayList<PCDataHolder>();\n+        public final List<Object> deletes = new ArrayList<Object>();\n     }\n \n+    /**\n+     * Utility structure holds the tuple of cacheable instance and its corresponding state manager. \n+     *\n+     */\n     private static class PCDataHolder {\n \n         public final DataCachePCData pcdata;\n         public final OpenJPAStateManager sm;\n \n-        public PCDataHolder(DataCachePCData pcdata,\n-            OpenJPAStateManager sm) {\n+        public PCDataHolder(DataCachePCData pcdata, OpenJPAStateManager sm) {\n             this.pcdata = pcdata;\n             this.sm = sm;\n \t\t}"},{"sha":"7af4cca3e5ea6421fa3643efc03106a8e82e0964","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","status":"modified","additions":10,"deletions":11,"changes":21,"blob_url":"https://github.com/apache/openjpa/blob/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java?ref=9f24d10ecdd5c9286f22e363852e84f116d0f994","patch":"@@ -111,7 +111,7 @@ public StoreQuery getDelegate() {\n      * READ_SERIALIZABLE -- to do so, we'd just return false when in\n      * a transaction.\n      */\n-    private List checkCache(QueryKey qk) {\n+    private List<Object> checkCache(QueryKey qk) {\n         if (qk == null)\n             return null;\n         FetchConfiguration fetch = getContext().getFetchConfiguration();\n@@ -125,7 +125,7 @@ private List checkCache(QueryKey qk) {\n         if (res == null)\n             return null;        \n         if (res.isEmpty())\n-            return Collections.EMPTY_LIST;\n+            return Collections.emptyList();\n \n         // this if block is invoked if the evictOnTimestamp is set to true\n         if (_cache instanceof AbstractQueryCache) {\n@@ -323,7 +323,7 @@ public Object evaluate(Object value, Object ob, Object[] params,\n         implements Executor {\n \n         private final Executor _ex;\n-        private final Class _candidate;\n+        private final Class<?> _candidate;\n         private final boolean _subs;\n         private final FetchConfiguration _fc;\n \n@@ -341,7 +341,7 @@ public ResultObjectProvider executeQuery(StoreQuery q, Object[] params,\n             QueryKey key = QueryKey.newInstance(cq.getContext(),\n                 _ex.isPacking(q), params, _candidate, _subs, range.start, \n                 range.end);\n-            List cached = cq.checkCache(key);\n+            List<Object> cached = cq.checkCache(key);\n             if (cached != null)\n                 return new ListResultObjectProvider(cached);\n \n@@ -371,7 +371,7 @@ private void clearAccessPath(StoreQuery q) {\n             if (cmd == null || cmd.length == 0)\n                 return;\n \n-            List classes = new ArrayList(cmd.length);\n+            List<Class<?>> classes = new ArrayList<Class<?>>(cmd.length);\n             for (int i = 0; i < cmd.length; i++)\n                 classes.add(cmd[i].getDescribedType());\n \n@@ -435,7 +435,7 @@ public String getAlias(StoreQuery q) {\n             return _ex.getAlias(unwrap(q));\n         }\n \n-        public Class getResultClass(StoreQuery q) {\n+        public Class<?> getResultClass(StoreQuery q) {\n             return _ex.getResultClass(unwrap(q));\n         }\n \n@@ -447,7 +447,7 @@ public Class getResultClass(StoreQuery q) {\n             return _ex.getProjectionAliases(unwrap(q));\n         }\n \n-        public Class[] getProjectionTypes(StoreQuery q) {\n+        public Class<?>[] getProjectionTypes(StoreQuery q) {\n             return _ex.getProjectionTypes(unwrap(q));\n         }\n \n@@ -488,8 +488,7 @@ private static StoreQuery unwrap(StoreQuery q) {\n      * Result list implementation for a cached query result. Package-protected\n      * for testing.\n      */\n-    public static class CachedList\n-        extends AbstractList\n+    public static class CachedList extends AbstractList<Object>\n         implements Serializable {\n \n         private final QueryResult _res;\n@@ -521,7 +520,7 @@ public int size() {\n \n         public Object writeReplace()\n             throws ObjectStreamException {\n-            return new ArrayList(this);\n+            return new ArrayList<Object>(this);\n         }\n     }\n \n@@ -537,7 +536,7 @@ public Object writeReplace()\n         private final ResultObjectProvider _rop;\n         private final boolean _proj;\n         private final QueryKey _qk;\n-        private final TreeMap _data = new TreeMap();\n+        private final TreeMap<Integer,Object> _data = new TreeMap<Integer,Object>();\n         private boolean _maintainCache = true;\n         private int _pos = -1;\n "},{"sha":"ba45990a46ebe2f27c397e1d0f902cfe0806563b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryResult.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryResult.java","raw_url":"https://github.com/apache/openjpa/raw/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryResult.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryResult.java?ref=9f24d10ecdd5c9286f22e363852e84f116d0f994","patch":"@@ -26,16 +26,17 @@\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public class QueryResult\n-    extends ArrayList {\n+    extends ArrayList<Object> {\n \n     private final long _ex;\n \n     private long _timestamp = 0L;\n     /**\n      * Constructor; supply corresponding query key and result data.\n      */\n-    public QueryResult(QueryKey key, Collection data) {\n+    public QueryResult(QueryKey key, Collection<Object> data) {\n         super(data);\n \n         if (key.getTimeout() == -1)\n@@ -47,7 +48,7 @@ public QueryResult(QueryKey key, Collection data) {\n     /**\n      * Constructor to set internal data from a serializer.\n      */\n-    public QueryResult(Collection data, long ex) {\n+    public QueryResult(Collection<Object> data, long ex) {\n         super(data);\n         _ex = ex;\n     }"},{"sha":"b264860a689b728a64132d9d9dcae18a816012fd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","status":"modified","additions":22,"deletions":22,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java?ref=9f24d10ecdd5c9286f22e363852e84f116d0f994","patch":"@@ -49,7 +49,7 @@\n import serp.bytecode.LookupSwitchInstruction;\n \n /**\n- * Generates {@link PCData} instances which avoid primitve wrappers\n+ * Generates {@link PCData} instances which avoid primitive wrappers\n  * to optimize memory use and performance at the cost of slightly higher\n  * startup time.\n  *\n@@ -65,7 +65,7 @@\n \n     protected static final String POSTFIX = \"$openjpapcdata\";\n \n-    private final Map _generated = new ConcurrentHashMap();\n+    private final Map<Class<?>, DynamicStorage> _generated = new ConcurrentHashMap<Class<?>, DynamicStorage>();\n     private final OpenJPAConfiguration _conf;\n     private final Log _log;\n \n@@ -87,8 +87,8 @@ public OpenJPAConfiguration getConfiguration() {\n     public PCData generatePCData(Object oid, ClassMetaData meta) {\n         if (meta == null)\n             return null;\n-        Class type = meta.getDescribedType();\n-        DynamicStorage storage = (DynamicStorage) _generated.get(type);\n+        Class<?> type = meta.getDescribedType();\n+        DynamicStorage storage = _generated.get(type);\n         if (storage == null) {\n             storage = generateStorage(meta);\n             _generated.put(type, storage);\n@@ -142,7 +142,7 @@ protected final String getClassName(Object obj) {\n     /**\n      * Creates a unique name for the given type's pcdata implementation.\n      */\n-    protected String getUniqueName(Class type) {\n+    protected String getUniqueName(Class<?> type) {\n         return type.getName() + \"$\" + System.identityHashCode(type) + POSTFIX;\n     }\n \n@@ -218,7 +218,7 @@ private void addGetType(BCClass bc, ClassMetaData meta) {\n         // }\n         code.getstatic().setField(type);\n \n-        Collection jumps = new LinkedList();\n+        Collection<Instruction> jumps = new LinkedList<Instruction>();\n         jumps.add(code.ifnonnull());\n         ExceptionHandler handler = code.addExceptionHandler();\n \n@@ -528,8 +528,8 @@ private void addLoadMethod(BCClass bc, ClassMetaData meta) {\n         // \t\tObject context)\n         Code code = addLoadMethod(bc, false);\n         FieldMetaData[] fmds = meta.getFields();\n-        Collection jumps = new LinkedList();\n-        Collection jumps2;\n+        Collection<Instruction> jumps = new LinkedList<Instruction>();\n+        Collection<Instruction> jumps2;\n \t\t\n         int local = code.getNextLocalsIndex();\n         code.constant().setNull();\n@@ -541,7 +541,7 @@ private void addLoadMethod(BCClass bc, ClassMetaData meta) {\n         int objectCount = 0;\n         boolean intermediate;\n         for (int i = 0; i < fmds.length; i++) {\n-            jumps2 = new LinkedList();\n+            jumps2 = new LinkedList<Instruction>();\n             intermediate = usesIntermediate(fmds[i]);\n             setTarget(code.aload().setThis(), jumps);\n             // if (loaded.get(i)) or (!loaded.get(i)) depending on inter resp\n@@ -583,8 +583,8 @@ private void addLoadWithFieldsMethod(BCClass bc, ClassMetaData meta) {\n         // public void load(OpenJPAStateManager sm, BitSet fields,\n         // \t\tFetchConfiguration fetch, Object conn)\n         FieldMetaData[] fmds = meta.getFields();\n-        Collection jumps = new LinkedList();\n-        Collection jumps2;\n+        Collection<Instruction> jumps = new LinkedList<Instruction>();\n+        Collection<Instruction> jumps2;\n         int objectCount = 0;\n         boolean intermediate;\n         int local = code.getNextLocalsIndex();\n@@ -595,7 +595,7 @@ private void addLoadWithFieldsMethod(BCClass bc, ClassMetaData meta) {\n         code.astore().setLocal(inter);\n \n         for (int i = 0; i < fmds.length; i++) {\n-            jumps2 = new LinkedList();\n+            jumps2 = new LinkedList<Instruction>();\n             intermediate = usesIntermediate(fmds[i]);\n             // if (fields.get(i))\n             // {\n@@ -650,7 +650,7 @@ private void addLoadWithFieldsMethod(BCClass bc, ClassMetaData meta) {\n      * Declare and start the base load method.\n      */\n     private Code addLoadMethod(BCClass bc, boolean fields) {\n-        Class[] args = null;\n+        Class<?>[] args = null;\n         if (fields)\n             args = new Class[]{ OpenJPAStateManager.class, BitSet.class,\n                 FetchConfiguration.class, Object.class };\n@@ -684,7 +684,7 @@ private Instruction addLoad(BCClass bc, Code code, FieldMetaData fmd,\n         Instruction first;\n         if (typeCode < JavaTypes.OBJECT) {\n             // sm.store<type>(i, field<i>)\n-            Class type = forType(fmd.getTypeCode());\n+            Class<?> type = forType(fmd.getTypeCode());\n             first = code.aload().setParam(0);\n             code.constant().setValue(index);\n             code.aload().setThis();\n@@ -730,7 +730,7 @@ private Instruction addLoad(BCClass bc, Code code, FieldMetaData fmd,\n      * Load intermediate data if possible.\n      */\n     private Instruction addLoadIntermediate(Code code, int index,\n-        int objectCount, Collection jumps2, int inter) {\n+        int objectCount, Collection<Instruction> jumps2, int inter) {\n         // {\n         // \t\tObject inter = objects[objectCount];\n         Instruction first = code.aload().setThis();\n@@ -794,7 +794,7 @@ private void addStoreMethod(BCClass bc, ClassMetaData meta,\n             new Class[]{ OpenJPAStateManager.class });\n \n         FieldMetaData[] fmds = meta.getFields();\n-        Collection jumps = new LinkedList();\n+        Collection<Instruction> jumps = new LinkedList<Instruction>();\n         int objectCount = 0;\n         for (int i = 0; i < fmds.length; i++) {\n             if (fields) {\n@@ -857,7 +857,7 @@ private void addStore(BCClass bc, Code code, FieldMetaData fmd,\n         int typeCode = replaceType(fmd);\n         int index = fmd.getIndex();\n         if (typeCode < JavaTypes.OBJECT) {\n-            Class type = forType(typeCode);\n+            Class<?> type = forType(typeCode);\n             // field<i> = sm.fetch<Type>(index)\n             code.aload().setThis();\n             code.aload().setParam(0);\n@@ -1027,8 +1027,8 @@ private int countImplDataFields(ClassMetaData meta) {\n     /**\n      * Add method which defers to AbstractPCData.\n      */\n-    protected void callAbstractPCData(BCClass bc, String name, Class retType,\n-        Class[] args) {\n+    protected void callAbstractPCData(BCClass bc, String name, Class<?> retType,\n+        Class<?>[] args) {\n         BCMethod meth = bc.declareMethod(name, retType, args);\n         Code code = meth.getCode(true);\n         code.aload().setThis();\n@@ -1046,16 +1046,16 @@ protected void callAbstractPCData(BCClass bc, String name, Class retType,\n      * Set the collection of {@link JumpInstruction}s to the given instruction,\n      * clearing the collection in the process.\n      */\n-    protected void setTarget(Instruction ins, Collection jumps) {\n-        for (Iterator it = jumps.iterator(); it.hasNext();)\n+    protected void setTarget(Instruction ins, Collection<Instruction> jumps) {\n+        for (Iterator<Instruction> it = jumps.iterator(); it.hasNext();)\n             ((JumpInstruction) it.next()).setTarget(ins);\n         jumps.clear();\n     }\n \n     /**\n      * Transform the given array of classes to strings.\n      */\n-    private static String[] toStrings(Class[] cls) {\n+    private static String[] toStrings(Class<?>[] cls) {\n         String[] strings = new String[cls.length];\n         for (int i = 0; i < strings.length; i++)\n             strings[i] = cls[i].getName();"},{"sha":"c8cb329400c3c017a327da121265cbe4434b85fc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java?ref=9f24d10ecdd5c9286f22e363852e84f116d0f994","patch":"@@ -116,7 +116,7 @@ public boolean load(OpenJPAStateManager sm, BitSet fields,\n         return _store.load(sm, fields, fetch, lockLevel, context);\n     }\n \n-    public Collection loadAll(Collection sms, PCState state, int load,\n+    public Collection<Object> loadAll(Collection<OpenJPAStateManager> sms, PCState state, int load,\n         FetchConfiguration fetch, Object context) {\n         return _store.loadAll(sms, state, load, fetch, context);\n     }\n@@ -126,7 +126,7 @@ public void beforeStateChange(OpenJPAStateManager sm, PCState fromState,\n         _store.beforeStateChange(sm, fromState, toState);\n     }\n \n-    public Collection flush(Collection sms) {\n+    public Collection<Exception> flush(Collection<OpenJPAStateManager> sms) {\n         return _store.flush(sms);\n     }\n \n@@ -139,11 +139,11 @@ public boolean assignField(OpenJPAStateManager sm, int field,\n         return _store.assignField(sm, field, preFlush);\n     }\n \n-    public Class getManagedType(Object oid) {\n+    public Class<?> getManagedType(Object oid) {\n         return _store.getManagedType(oid);\n     }\n \n-    public Class getDataStoreIdType(ClassMetaData meta) {\n+    public Class<?> getDataStoreIdType(ClassMetaData meta) {\n         return _store.getDataStoreIdType(meta);\n     }\n "},{"sha":"12681ba06f5c50e3769587c257446b47fc42a57b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","status":"modified","additions":19,"deletions":21,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","raw_url":"https://github.com/apache/openjpa/raw/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreContext.java?ref=9f24d10ecdd5c9286f22e363852e84f116d0f994","patch":"@@ -142,15 +142,15 @@\n      * parameter\n      * @see #find(Object,boolean,FindCallbacks)\n      */\n-    public Object[] findAll(Collection oids, boolean validate,\n+    public Object[] findAll(Collection<Object> oids, boolean validate,\n         FindCallbacks call);\n \n     /**\n      * Return the object with the given oid. If present, the\n      * cached instance will be returned. Otherwise, the instance will be\n      * initialized through the store as usual; however, in this case\n      * the store will be passed the given execution data, and the\n-     * system will load the object according to the given fetch configuratiion\n+     * system will load the object according to the given fetch configuration\n      * (or the context's configuration, if the given one is null).\n      * Fields can optionally be excluded from required loading using the\n      * <code>exclude</code> mask. By default this method does not find new\n@@ -166,7 +166,7 @@ public Object find(Object oid, FetchConfiguration fetch, BitSet exclude,\n      *\n      * @see #find(Object,FetchConfiguration,BitSet,Object,int)\n      */\n-    public Object[] findAll(Collection oids, FetchConfiguration fetch,\n+    public Object[] findAll(Collection<Object> oids, FetchConfiguration fetch,\n         BitSet exclude, Object edata, int flags);\n \n     /**\n@@ -175,7 +175,7 @@ public Object find(Object oid, FetchConfiguration fetch, BitSet exclude,\n      * when no longer needed. This method delegates to \n      * {@link StoreManager#executeExtent}.\n      */\n-    public Iterator extentIterator(Class cls, boolean subs,\n+    public Iterator<Object> extentIterator(Class<?> cls, boolean subs,\n         FetchConfiguration fetch, boolean ignoreChanges);\n \n     /**\n@@ -198,7 +198,7 @@ public Iterator extentIterator(Class cls, boolean subs,\n      * @param fgOnly indicator as to whether to retrieve only fields\n      * @see #retrieve\n      */\n-    public void retrieveAll(Collection objs, boolean fgOnly, OpCallbacks call);\n+    public void retrieveAll(Collection<Object> objs, boolean fgOnly, OpCallbacks call);\n \n     /**\n      * Make the given instance embedded.\n@@ -217,61 +217,61 @@ public OpenJPAStateManager embed(Object obj, Object id,\n      * Return the application or datastore identity class the given persistent\n      * class uses for object ids.\n      */\n-    public Class getObjectIdType(Class cls);\n+    public Class<?> getObjectIdType(Class<?> cls);\n \n     /**\n      * Create a new object id instance from the given value.\n      *\n-     * @param cls the persitent class that uses this identity value\n+     * @param cls the persistent class that uses this identity value\n      * @param val an object id instance, stringified object id, or primary\n      * key value\n      */\n-    public Object newObjectId(Class cls, Object val);\n+    public Object newObjectId(Class<?> cls, Object val);\n \n     /**\n      * Return the set of classes that have been made persistent in the current\n      * transaction.\n      *\n      * @since 0.3.4\n      */\n-    public Collection getPersistedTypes();\n+    public Collection<Class<?>> getPersistedTypes();\n \n     /**\n      * Return the set of classes that have been deleted in the current\n      * transaction.\n      *\n      * @since 0.3.4\n      */\n-    public Collection getDeletedTypes();\n+    public Collection<Class<?>> getDeletedTypes();\n \n     /**\n      * Return the set of classes for objects that have been modified\n      * in the current transaction.\n      *\n      * @since 0.3.4\n      */\n-    public Collection getUpdatedTypes();\n+    public Collection<Class<?>> getUpdatedTypes();\n \n     /**\n      * Return a list of all managed instances.\n      */\n-    public Collection getManagedObjects();\n+    public Collection<Object> getManagedObjects();\n \n     /**\n      * Return a list of current transaction instances.\n      */\n-    public Collection getTransactionalObjects();\n+    public Collection<Object> getTransactionalObjects();\n \n     /**\n      * Return a list of instances which will become transactional upon\n      * the next transaction.\n      */\n-    public Collection getPendingTransactionalObjects();\n+    public Collection<Object> getPendingTransactionalObjects();\n \n     /**\n      * Return a list of current dirty instances.\n      */\n-    public Collection getDirtyObjects();\n+    public Collection<Object> getDirtyObjects();\n \n     /**\n      * Whether to maintain the order in which objects are dirtied for\n@@ -319,8 +319,7 @@ public OpenJPAStateManager embed(Object obj, Object id,\n      * @param updateVersion if true, the instance's version will be\n      * incremented at the next flush\n      */\n-    public void transactional(Object pc, boolean updateVersion,\n-        OpCallbacks call);\n+    public void transactional(Object pc, boolean updateVersion, OpCallbacks call);\n \n     /**\n      * Make the given objects transactional.\n@@ -329,18 +328,17 @@ public void transactional(Object pc, boolean updateVersion,\n      * @param updateVersion if true, the instance's version will be\n      * incremented at the next flush\n      */\n-    public void transactionalAll(Collection objs, boolean updateVersion,\n-        OpCallbacks call);\n+    public void transactionalAll(Collection<Object> objs, boolean updateVersion, OpCallbacks call);\n \n     /**\n-     * Make the given object nontransactional.\n+     * Make the given object non-transactional.\n      */\n     public void nontransactional(Object pc, OpCallbacks call);\n \n     /**\n      * Make the given objects nontransactional.\n      */\n-    public void nontransactionalAll(Collection objs, OpCallbacks call);\n+    public void nontransactionalAll(Collection<Object> objs, OpCallbacks call);\n \n     /**\n      * Return whether the given object is persistent."},{"sha":"8bc3715ce15e1e6c06025d9a10b1ad99652e8ed3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreManager.java?ref=9f24d10ecdd5c9286f22e363852e84f116d0f994","patch":"@@ -213,7 +213,7 @@ public boolean load(OpenJPAStateManager sm, BitSet fields,\n      * which no data store record exists\n      * @see org.apache.openjpa.util.ImplHelper#loadAll\n      */\n-    public Collection loadAll(Collection sms, PCState state, int load,\n+    public Collection<Object> loadAll(Collection<OpenJPAStateManager> sms, PCState state, int load,\n         FetchConfiguration fetch, Object edata);\n \n     /**\n@@ -244,7 +244,7 @@ public void beforeStateChange(OpenJPAStateManager sm, PCState fromState,\n      *\n      * @see org.apache.openjpa.util.ApplicationIds#assign()\n      */\n-    public Collection flush(Collection sms);\n+    public Collection<Exception> flush(Collection<OpenJPAStateManager> sms);\n \n     /**\n      * Assign an object id to the given new instance. Return false if the\n@@ -288,15 +288,15 @@ public boolean assignField(OpenJPAStateManager sm, int field,\n      *\n      * @since 0.3.0\n      */\n-    public Class getManagedType(Object oid);\n+    public Class<?> getManagedType(Object oid);\n \n     /**\n      * Return the class used by this StoreManager for datastore identity\n      * values. The given metadata may be null, in which case the return\n      * value should the common datastore identity class for all classes, or\n      * null if this store manager does not use a common identity class.\n      */\n-    public Class getDataStoreIdType(ClassMetaData meta);\n+    public Class<?> getDataStoreIdType(ClassMetaData meta);\n \n     /**\n      * Copy the given object id value. Use the described type of the given"},{"sha":"c32c60efe68a0ede2766eadd1fc6dfb2ac57890a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/AbstractWriteBehindCache.java","status":"modified","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/AbstractWriteBehindCache.java","raw_url":"https://github.com/apache/openjpa/raw/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/AbstractWriteBehindCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/AbstractWriteBehindCache.java?ref=9f24d10ecdd5c9286f22e363852e84f116d0f994","patch":"@@ -20,11 +20,9 @@\n \n public abstract class AbstractWriteBehindCache implements WriteBehindCache {\n     public String getName() {\n-        // TODO Auto-generated method stub\n         return null;\n     }\n     \n     public void setName(String name) {\n-        // TODO Auto-generated method stub\n     }\n }"},{"sha":"8923a0890647c6c7cb317f41ad851403fcf630e7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/SimpleWriteBehindCache.java","status":"modified","additions":11,"deletions":11,"changes":22,"blob_url":"https://github.com/apache/openjpa/blob/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/SimpleWriteBehindCache.java","raw_url":"https://github.com/apache/openjpa/raw/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/SimpleWriteBehindCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/SimpleWriteBehindCache.java?ref=9f24d10ecdd5c9286f22e363852e84f116d0f994","patch":"@@ -25,16 +25,18 @@\n import java.util.Map;\n \n import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.StateManagerImpl;\n import org.apache.openjpa.meta.ClassMetaData;\n \n public class SimpleWriteBehindCache extends AbstractWriteBehindCache {\n \n-    private Map<WriteBehindCacheKey, StateManagerImpl> _cache = new HashMap<WriteBehindCacheKey, StateManagerImpl>();\n+    private Map<WriteBehindCacheKey, OpenJPAStateManager> _cache = \n+        new HashMap<WriteBehindCacheKey, OpenJPAStateManager>();\n \n-    public List<Exception> add(Collection<StateManagerImpl> sms) {\n+    public List<Exception> add(Collection<OpenJPAStateManager> sms) {\n         List<Exception> exceptions = new ArrayList<Exception>();\n-        for (StateManagerImpl sm : sms) {\n+        for (OpenJPAStateManager sm : sms) {\n             try {\n                 add(sm);\n             } catch (WriteBehindException wbe) {\n@@ -44,7 +46,7 @@\n         return exceptions;\n     }\n \n-    protected void add(StateManagerImpl sm) {\n+    protected void add(OpenJPAStateManager sm) {\n         WriteBehindCacheKey key = getKey(sm);\n         synchronized (_cache) {\n             if (_cache.containsKey(key) && _cache.get(key) != sm) {\n@@ -65,23 +67,22 @@ public boolean contains(Object o) {\n         return rval;\n     }\n \n-    public WriteBehindCacheKey getKey(StateManagerImpl sm) {\n+    public WriteBehindCacheKey getKey(OpenJPAStateManager sm) {\n         ClassMetaData md = sm.getMetaData();\n         Class<?> cls = md.getDescribedType();\n         String className = cls.getCanonicalName();\n         Object id = sm.getId();\n         \n-        SimpleWriteBehindCacheKey key =\n-            new SimpleWriteBehindCacheKey(className, id);\n+        SimpleWriteBehindCacheKey key = new SimpleWriteBehindCacheKey(className, id);\n         return key;\n     }\n \n     public int getSize() {\n         return _cache.size();\n     }\n \n-    public Collection<StateManagerImpl> getStateManagers() {\n-        return new ArrayList<StateManagerImpl>(_cache.values());\n+    public Collection<OpenJPAStateManager> getStateManagers() {\n+        return new ArrayList<OpenJPAStateManager>(_cache.values());\n     }\n \n     public void initialize(WriteBehindCacheManager manager) {\n@@ -109,8 +110,7 @@ public boolean isEmpty() {\n     }\n     \n     // Might be better in smImpl. \n-    protected StateManagerImpl merge(StateManagerImpl from,\n-        StateManagerImpl into) {\n+    protected OpenJPAStateManager merge(OpenJPAStateManager from, OpenJPAStateManager into) {\n         for (int i = 0; i < into.getMetaData().getFields().length; i++) {\n             if (from.getDirty().get(i)) {\n                 into.dirty(i);"},{"sha":"e7ad5fcbe34056ef128bb4860c6fe468ee526169","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/SimpleWriteBehindCallback.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/SimpleWriteBehindCallback.java","raw_url":"https://github.com/apache/openjpa/raw/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/SimpleWriteBehindCallback.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/SimpleWriteBehindCallback.java?ref=9f24d10ecdd5c9286f22e363852e84f116d0f994","patch":"@@ -21,6 +21,7 @@\n import java.util.Collection;\n \n import org.apache.openjpa.kernel.Broker;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.StateManagerImpl;\n import org.apache.openjpa.kernel.StoreManager;\n \n@@ -42,7 +43,7 @@ public void initialize(Broker broker, WriteBehindCache cache) {\n         // skip past any delegating store managers.\n         StoreManager storeManager =\n             _broker.getStoreManager().getInnermostDelegate();\n-        Collection<StateManagerImpl> sms = null;\n+        Collection<OpenJPAStateManager> sms = null;\n         if (_cache != null && !_cache.isEmpty()) {\n             // TODO lock or switch the cache\n             sms = _cache.getStateManagers();"},{"sha":"30976a8f698b3024843680b4361ee854a334c7d5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/WriteBehindCache.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/WriteBehindCache.java","raw_url":"https://github.com/apache/openjpa/raw/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/WriteBehindCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/WriteBehindCache.java?ref=9f24d10ecdd5c9286f22e363852e84f116d0f994","patch":"@@ -21,6 +21,7 @@\n import java.util.Collection;\n import java.util.List;\n \n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.StateManagerImpl;\n \n /**\n@@ -69,14 +70,14 @@\n      *         StateManager to the cache. If no exceptions occur the collection\n      *         will be empty.\n      */\n-    public List<Exception> add(Collection<StateManagerImpl> sms);\n+    public List<Exception> add(Collection<OpenJPAStateManager> sms);\n \n     /**\n      * Obtain the StateManagers currently in the cache.\n      * \n      * @return collection of state managers.\n      */\n-    public Collection<StateManagerImpl> getStateManagers();\n+    public Collection<OpenJPAStateManager> getStateManagers();\n \n     /**\n      * Initialize any resources associated with the given\n@@ -92,7 +93,7 @@\n      *            A StateManager\n      * @return A key that may be used to cache the StateManager.\n      */\n-    public WriteBehindCacheKey getKey(StateManagerImpl sm);\n+    public WriteBehindCacheKey getKey(OpenJPAStateManager sm);\n \n     /**\n      * Determine whether the cache is empty."},{"sha":"96a7c8216e4dc135b705f3b717cb8a29a972c5dd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/WriteBehindStoreManager.java","status":"modified","additions":18,"deletions":20,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/WriteBehindStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/WriteBehindStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/writebehind/WriteBehindStoreManager.java?ref=9f24d10ecdd5c9286f22e363852e84f116d0f994","patch":"@@ -24,6 +24,7 @@\n import java.util.Set;\n \n import org.apache.openjpa.kernel.DelegatingStoreManager;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.PCState;\n import org.apache.openjpa.kernel.StateManagerImpl;\n import org.apache.openjpa.kernel.StoreManager;\n@@ -42,7 +43,7 @@\n     public static final int OP_UPDATE = 3; \n \n     WriteBehindCache _cache;\n-    Collection<StateManagerImpl> inFlightSMs = new ArrayList<StateManagerImpl>();\n+    Collection<OpenJPAStateManager> inFlightSMs = new ArrayList<OpenJPAStateManager>();\n \n     public WriteBehindStoreManager(StoreManager store) {\n         this(store, null);\n@@ -54,30 +55,27 @@ public WriteBehindStoreManager(StoreManager store,\n         _cache = wbCache;\n     }\n \n-    public Collection flush(Collection sms) {\n-        LinkedHashSet<StateManagerImpl> passingThrough = null;\n-        for (Object o : sms) {\n-            if(cacheAble((StateManagerImpl)o)) {\n-                StateManagerImpl sm = (StateManagerImpl) o;\n+    public Collection<Exception> flush(Collection<OpenJPAStateManager> sms) {\n+        LinkedHashSet<OpenJPAStateManager> passingThrough = null;\n+        for (OpenJPAStateManager sm : sms) {\n+            if (cacheAble(sm)) {\n                 PCState newState = sm.getPCState();\n-                if(newState == PCState.PDELETEDFLUSHED) { \n+                if (newState == PCState.PDELETEDFLUSHED) { \n                     newState = PCState.PDELETED; // effectively reset the flush\n                 }\n-                inFlightSMs.add(new StateManagerImpl(sm, newState));\n-            }\n-            else {\n-                if(passingThrough == null) { \n-                    passingThrough = new LinkedHashSet<StateManagerImpl>();\n+                inFlightSMs.add(new StateManagerImpl((StateManagerImpl)sm, newState));\n+            } else {\n+                if (passingThrough == null) { \n+                    passingThrough = new LinkedHashSet<OpenJPAStateManager>();\n                 }\n-                passingThrough.add((StateManagerImpl)o);\n+                passingThrough.add(sm);\n             }\n         }\n         \n-        Collection rval;\n-        if(passingThrough != null) { \n+        Collection<Exception> rval;\n+        if (passingThrough != null) { \n             rval = getDelegate().flush(passingThrough);\n-        }\n-        else { \n+        } else { \n             rval = new ArrayList<Exception>();\n         }\n         return rval;\n@@ -100,11 +98,11 @@ public void rollback() {\n         }\n     }\n \n-    public Collection<Exception> flushBehind(Collection<StateManagerImpl> sms) {\n+    public Collection<Exception> flushBehind(Collection<OpenJPAStateManager> sms) {\n         return super.flush(sms);\n     }\n \n-    public boolean cacheAble(StateManagerImpl sm) {\n+    public boolean cacheAble(OpenJPAStateManager sm) {\n         boolean rval = false;\n         switch (getOperation(sm)) {\n         case OP_INSERT:\n@@ -135,7 +133,7 @@ public boolean cacheAble(StateManagerImpl sm) {\n         return rval;\n     }\n     \n-    protected int getOperation(StateManagerImpl sm) {\n+    protected int getOperation(OpenJPAStateManager sm) {\n         int rval = -1; // TODO define me\n         if (sm.isDirty()) {\n             if (sm.isNew()) {"},{"sha":"3e3649de4ba1e470f34457d4f317feb9616e805d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/writebehind/CustomWriteBehindCache.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/writebehind/CustomWriteBehindCache.java","raw_url":"https://github.com/apache/openjpa/raw/9f24d10ecdd5c9286f22e363852e84f116d0f994/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/writebehind/CustomWriteBehindCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/writebehind/CustomWriteBehindCache.java?ref=9f24d10ecdd5c9286f22e363852e84f116d0f994","patch":"@@ -33,7 +33,7 @@\n  */\n public class CustomWriteBehindCache extends AbstractWriteBehindCache {\n \n-    public List<Exception> add(Collection<StateManagerImpl> sms) {\n+    public List<Exception> add(Collection<OpenJPAStateManager> sms) {\n         List<Exception> exceptions = new ArrayList<Exception>(); \n         return exceptions;\n     }\n@@ -48,7 +48,7 @@ public boolean contains(Object o) {\n     public void flush() {\n     }\n \n-    public WriteBehindCacheKey getKey(StateManagerImpl sm) {\n+    public WriteBehindCacheKey getKey(OpenJPAStateManager sm) {\n         return null;\n     }\n \n@@ -64,7 +64,7 @@ public int getSize() {\n         return 0;\n     }\n \n-    public Collection<StateManagerImpl> getStateManagers() {\n+    public Collection<OpenJPAStateManager> getStateManagers() {\n         return null;\n     }\n "}]}

