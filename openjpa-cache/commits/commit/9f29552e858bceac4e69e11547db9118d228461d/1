{"sha":"9f29552e858bceac4e69e11547db9118d228461d","node_id":"MDY6Q29tbWl0MjA2MzY0OjlmMjk1NTJlODU4YmNlYWM0ZTY5ZTExNTQ3ZGI5MTE4ZDIyODQ2MWQ=","commit":{"author":{"name":"Fay Wang","email":"faywang@apache.org","date":"2009-09-26T13:42:19Z"},"committer":{"name":"Fay Wang","email":"faywang@apache.org","date":"2009-09-26T13:42:19Z"},"message":"OPENJPA-1253: support foreign key strategy for uni-directional one to many mapping using Map with entity as the Map key.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@819139 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"fb5603263b04da45d3066816a0e37e8affbb2281","url":"https://api.github.com/repos/apache/openjpa/git/trees/fb5603263b04da45d3066816a0e37e8affbb2281"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/9f29552e858bceac4e69e11547db9118d228461d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/9f29552e858bceac4e69e11547db9118d228461d","html_url":"https://github.com/apache/openjpa/commit/9f29552e858bceac4e69e11547db9118d228461d","comments_url":"https://api.github.com/repos/apache/openjpa/commits/9f29552e858bceac4e69e11547db9118d228461d/comments","author":null,"committer":null,"parents":[{"sha":"28573bfcfd38c7f08c15094d54f3769de7f60ea5","url":"https://api.github.com/repos/apache/openjpa/commits/28573bfcfd38c7f08c15094d54f3769de7f60ea5","html_url":"https://github.com/apache/openjpa/commit/28573bfcfd38c7f08c15094d54f3769de7f60ea5"}],"stats":{"total":575,"additions":494,"deletions":81},"files":[{"sha":"3b39d542454de85174f17f606071cd6717ada2d4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMappingInfo.java","status":"modified","additions":17,"deletions":1,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/9f29552e858bceac4e69e11547db9118d228461d/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/9f29552e858bceac4e69e11547db9118d228461d/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMappingInfo.java?ref=9f29552e858bceac4e69e11547db9118d228461d","patch":"@@ -23,6 +23,7 @@\n import java.util.List;\n \n import org.apache.openjpa.conf.Compatibility;\n+import org.apache.openjpa.jdbc.meta.strats.MapTableFieldStrategy;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n@@ -147,14 +148,29 @@ public String get(Schema schema) {\n         }, schemaName, tableName, adapt);\n     }\n \n+    public ForeignKey getJoinForeignKey (final FieldMapping field, Table table,\n+        boolean adapt) {\n+        Strategy strat = field.getStrategy();\n+        if (strat instanceof MapTableFieldStrategy && \n+            ((MapTableFieldStrategy)strat).isUni1ToMFK()) {\n+            List cols = field.getElementMapping().getValueInfo().getColumns();\n+            return getJoin(field, table, adapt, cols);\n+        }\n+        return null;\n+    }\n+    \n     /**\n      * Return the join from the field table to the owning class table.\n      */\n     public ForeignKey getJoin(final FieldMapping field, Table table,\n         boolean adapt) {\n         // if we have no join columns defined, check class-level join\n     \t// if the given field is embedded then consider primary table of owner\n-        List cols = getColumns();\n+        return getJoin(field, table, adapt, getColumns());\n+    }\n+    \n+    public ForeignKey getJoin(final FieldMapping field, Table table,\n+            boolean adapt, List cols) {\n         if (cols.isEmpty()) {\n         \tClassMapping mapping;\n         \tif (field.isEmbedded() && "},{"sha":"3687aefc51225fc34537b107e4b32b4175032240","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingInfo.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/9f29552e858bceac4e69e11547db9118d228461d/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/9f29552e858bceac4e69e11547db9118d228461d/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingInfo.java?ref=9f29552e858bceac4e69e11547db9118d228461d","patch":"@@ -107,7 +107,7 @@ public void populate(Table local, Table foreign, Column col,\n             getDefiningMapping(), rel, inversable, adapt);\n     }\n \n-    private Table getTable(ValueMapping val) {\n+    public Table getTable(ValueMapping val) {\n         FieldMapping field = val.getFieldMapping();\n         Table table = field.getTable();\n         if (table == null) {"},{"sha":"129368d3e7dc356f5e3c63b9850b150ce7a99852","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","status":"modified","additions":40,"deletions":18,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/9f29552e858bceac4e69e11547db9118d228461d/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/9f29552e858bceac4e69e11547db9118d228461d/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java?ref=9f29552e858bceac4e69e11547db9118d228461d","patch":"@@ -150,7 +150,7 @@ public void map(boolean adapt) {\n             // map to the owner table\n             handleMappedByForeignKey(adapt);\n         } else if ((!isUni1ToMFK() && isBi1ToMJT()) || \n-            (!isUni1ToMFK() && !isBi1ToMJT() && mapped == null)){ \n+            (!isUni1ToMFK() && !isBi1ToMJT() && mapped == null)) { \n             // map to a separate table\n             field.mapJoin(adapt, true);\n             if (val.getTypeMapping().isMapped()) {\n@@ -306,29 +306,21 @@ public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n             for (Iterator itr = rem.iterator(); itr.hasNext();) {\n                 mkey = itr.next();\n                 if (isUni1ToMFK()){\n-                    delRow = rm.getRow(field.getElementMapping().getDeclaredTypeMapping().getTable(),\n-                        Row.ACTION_UPDATE, sm, true);\n-                    val.setForeignKey(delRow, null);\n-                } \n-                \n-                HandlerStrategies.where(key, mkey, store, delRow,\n-                    _kcols);\n-                if (!isUni1ToMFK())\n+                    updateSetNull(sm, mkey, store, rm);\n+                } else {\n+                    HandlerStrategies.where(key, mkey, store, delRow, _kcols);\n                     rm.flushSecondaryRow(delRow);\n+                }\n             }\n             if (!canChange && !change.isEmpty()) {\n                 for (Iterator itr = change.iterator(); itr.hasNext();) {\n                     mkey = itr.next();\n                     if (isUni1ToMFK()){\n-                        delRow = rm.getRow(field.getElementMapping().getDeclaredTypeMapping().getTable(),\n-                            Row.ACTION_UPDATE, sm, true);\n-                        val.setForeignKey(delRow, null);\n-                    } \n-\n-                    HandlerStrategies.where(key, itr.next(), store, delRow,\n-                        _kcols);\n-                    if (!isUni1ToMFK())\n+                        updateSetNull(sm, mkey, store, rm);\n+                    } else { \n+                        HandlerStrategies.where(key, itr.next(), store, delRow,  _kcols);\n                         rm.flushSecondaryRow(delRow);\n+                    }\n                 }\n             }\n         }\n@@ -422,8 +414,38 @@ public Object toKeyDataStoreValue(Object val, JDBCStore store) {\n     \n     public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n         throws SQLException {\n-        if ((field.getMappedBy() != null && !isBi1ToMJT()) || isUni1ToMFK())\n+        if ((field.getMappedBy() != null && !isBi1ToMJT()))\n             return;\n+        if (isUni1ToMFK()) {\n+            Map mapObj = (Map)sm.fetchObject(field.getIndex());\n+            updateSetNull(sm, store, rm, mapObj.keySet());\n+            return;\n+        }    \n+\n         super.delete(sm, store, rm);\n     }\n+    \n+    private void updateSetNull(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n+        Set rem) throws SQLException {\n+        for (Iterator itr = rem.iterator(); itr.hasNext();) {\n+            Object mkey = itr.next();\n+            updateSetNull(sm, mkey, store, rm);\n+        }\n+    }\n+\n+    private void updateSetNull(OpenJPAStateManager sm, Object mkey, \n+        JDBCStore store, RowManager rm) throws SQLException {\n+        ValueMapping key = field.getKeyMapping();\n+        ValueMapping val = field.getElementMapping();\n+        StoreContext ctx = store.getContext();\n+        ValueMappingInfo vinfo = field.getElementMapping().getValueInfo();\n+        Table table = vinfo.getTable(val);\n+        ForeignKey joinFK = field.getMappingInfo().getJoinForeignKey(field, table, true);\n+        Row delRow = rm.getRow(field.getElementMapping().getDeclaredTypeMapping().getTable(),\n+            Row.ACTION_UPDATE, sm, true);\n+        delRow.whereForeignKey(joinFK, sm);\n+        val.setForeignKey(delRow, null);\n+        HandlerStrategies.set(key, null, store, delRow, _kcols, _kio, true);\n+        HandlerStrategies.where(key, mkey, store, delRow, _kcols);\n+    }\n }"},{"sha":"299fd3ea90623787c91ae295755659d6356faf24","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/9f29552e858bceac4e69e11547db9118d228461d/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/9f29552e858bceac4e69e11547db9118d228461d/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java?ref=9f29552e858bceac4e69e11547db9118d228461d","patch":"@@ -99,13 +99,13 @@ private boolean hasJoinColumnOrJoinTable() {\n         \n     }\n     \n-    protected boolean isBi1ToMJT() {\n+    public boolean isBi1ToMJT() {\n         if (_isBi1ToMJT == null)\n             isNonDefaultMapping();\n         return _isBi1ToMJT;\n     }\n     \n-    protected boolean isUni1ToMFK() {\n+    public boolean isUni1ToMFK() {\n         if (_isUni1ToMFK == null)\n             isNonDefaultMapping();\n         return _isUni1ToMFK;"},{"sha":"562130911b5ad740314db56336f21dd430f08760","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","status":"modified","additions":191,"deletions":58,"changes":249,"blob_url":"https://github.com/apache/openjpa/blob/9f29552e858bceac4e69e11547db9118d228461d/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/9f29552e858bceac4e69e11547db9118d228461d/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java?ref=9f29552e858bceac4e69e11547db9118d228461d","patch":"@@ -80,7 +80,17 @@ public void selectValue(Select sel, ClassMapping val,\n         kunion.setLRS(lrs);\n         kunion.select(new Union.Selector() {\n             public void select(Select sel, int idx) {\n-                sel.whereForeignKey(field.getJoinForeignKey(),\n+                ForeignKey joinFK = null;\n+                if (isUni1ToMFK()) {\n+                    ValueMapping val = field.getElementMapping();\n+                    ValueMappingInfo vinfo = val.getValueInfo();\n+                    Table table = vinfo.getTable(val);\n+                    joinFK = field.getMappingInfo().getJoinForeignKey(field, table, true);\n+                } else {\n+                    joinFK = field.getJoinForeignKey();\n+                }\n+                \n+                sel.whereForeignKey(joinFK,\n                     sm.getObjectId(), field.getDefiningMapping(), store);\n \n                 // order before select in case we're faking union with\n@@ -106,21 +116,29 @@ public void select(Select sel, int idx) {\n         vunion.setLRS(lrs);\n         vunion.select(new Union.Selector() {\n             public void select(Select sel, int idx) {\n-                sel.whereForeignKey(field.getJoinForeignKey(),\n-                    sm.getObjectId(), field.getDefiningMapping(), store);\n-\n-                // order before select in case we're faking union with\n-                // multiple selects; order vals used to merge results\n-                FieldMapping mapped = field.getMappedByMapping();\n-                Joins joins = joinValueRelation(sel.newJoins(), vals[idx]);\n-                sel.orderBy(field.getKeyMapping().getColumns(), true, true);\n-                sel.select(vals[idx], field.getElementMapping().\n-                    getSelectSubclasses(), store, fetch, eagerMode, joins);\n-\n-                //### cheat: result joins only care about the relation path;\n-                //### thus we can use first mapping of union only\n-                if (idx == 0)\n-                    resJoins[1] = joins;\n+                if (isUni1ToMFK()) {\n+                    sel.orderBy(field.getKeyMapping().getColumns(), true, true);\n+                    sel.select(vals[idx], field.getElementMapping().\n+                        getSelectSubclasses(), store, fetch, eagerMode, null);\n+                    sel.whereForeignKey(field.getElementMapping().getForeignKey(),\n+                        sm.getObjectId(), field.getElementMapping().getDeclaredTypeMapping(), store);\n+                    \n+                } else {\n+                    sel.whereForeignKey(field.getJoinForeignKey(),\n+                        sm.getObjectId(), field.getDefiningMapping(), store);\n+\n+                    // order before select in case we're faking union with\n+                    // multiple selects; order vals used to merge results\n+                    Joins joins = joinValueRelation(sel.newJoins(), vals[idx]);\n+                    sel.orderBy(field.getKeyMapping().getColumns(), true, true);\n+                    sel.select(vals[idx], field.getElementMapping().\n+                        getSelectSubclasses(), store, fetch, eagerMode, joins);\n+\n+                    //### cheat: result joins only care about the relation path;\n+                    //### thus we can use first mapping of union only\n+                    if (idx == 0)\n+                        resJoins[1] = joins;\n+                }\n             }\n         });\n \n@@ -184,10 +202,12 @@ public void map(boolean adapt) {\n         FieldMapping mapped = field.getMappedByMapping();\n         DBDictionary dict = field.getMappingRepository().getDBDictionary();\n         String keyName = null;\n-        if (mapped != null) {         \n+        if ((isUni1ToMFK() && !isBi1ToMJT()) || \n+            (!isUni1ToMFK() && !isBi1ToMJT() && mapped != null)) { \n             handleMappedByForeignKey(adapt);\n             keyName = dict.getValidColumnName(\"vkey\", field.getTable());\n-         } else {\n+         } else if ((!isUni1ToMFK() && isBi1ToMJT()) || \n+            (!isUni1ToMFK() && !isBi1ToMJT() && mapped == null)) { \n             field.mapJoin(adapt, true);\n             mapTypeJoin(val, \"value\", adapt);\n             keyName = dict.getValidColumnName(\"key\", field.getTable());\n@@ -226,13 +246,15 @@ private void insert(OpenJPAStateManager sm, RowManager rm, Map map,\n         if (map == null || map.isEmpty())\n             return;\n         \n-        if (field.getMappedBy() != null)\n+        if (!isBi1ToMJT() && field.getMappedBy() != null)\n             return;\n \n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n-            sm);\n-\n+        Row row = null;\n+        if (!isUni1ToMFK()) {\n+            row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n+            row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n+                sm);\n+        }\n         ValueMapping key = field.getKeyMapping();\n         ValueMapping val = field.getElementMapping();\n         StoreContext ctx = sm.getContext();\n@@ -242,24 +264,32 @@ private void insert(OpenJPAStateManager sm, RowManager rm, Map map,\n             entry = (Map.Entry) itr.next();\n             keysm = RelationStrategies.getStateManager(entry.getKey(), ctx);\n             valsm = RelationStrategies.getStateManager(entry.getValue(), ctx);\n+            if (isUni1ToMFK()){\n+                row = rm.getRow(field.getElementMapping().getDeclaredTypeMapping().getTable(),\n+                    Row.ACTION_UPDATE, valsm, true);\n+                row.wherePrimaryKey(valsm);\n+                val.setForeignKey(row, sm);\n+            } else {\n+                val.setForeignKey(row, valsm);\n+            }\n             key.setForeignKey(row, keysm);\n-            val.setForeignKey(row, valsm);\n             \n-            // so far, we poplulated the key/value of each\n+            // so far, we populated the key/value of each\n             // map element owned by the entity.\n             // In the case of ToMany, and both sides\n             // use Map to represent the relation,\n             // we need to populate the key value of the owner\n             // from the view point of the owned side\n             PersistenceCapable obj = sm.getPersistenceCapable();\n             if (!populateKey(row, valsm, obj, ctx, rm, store))\n-                rm.flushSecondaryRow(row);\n+                if (!isUni1ToMFK())\n+                    rm.flushSecondaryRow(row);\n         }\n     }\n \n     public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n         throws SQLException {\n-        if (field.getMappedBy() != null)\n+        if (field.getMappedBy() != null && !isBi1ToMJT())\n             return;\n         \n         Map map = (Map) sm.fetchObject(field.getIndex());\n@@ -289,67 +319,135 @@ public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n         boolean canChange = val.getForeignKey().isLogical();\n         Object mkey;\n         if (canChange && !change.isEmpty()) {\n-            Row changeRow = rm.getSecondaryRow(field.getTable(),\n-                Row.ACTION_UPDATE);\n-            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n-\n+            Row changeRow = null;\n+            if (!isUni1ToMFK()) {\n+                rm.getSecondaryRow(field.getTable(),\n+                    Row.ACTION_UPDATE);\n+                changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+            }\n             for (Iterator itr = change.iterator(); itr.hasNext();) {\n                 mkey = itr.next();\n+                Object mval = map.get(mkey);\n+                if (mval == null) {\n+                    Set<Map.Entry> entries = map.entrySet();\n+                    for (Map.Entry entry : entries) {\n+                        if (entry.getKey().equals(mkey))\n+                            mval = entry.getValue();\n+                    }\n+                }\n+                if (mval == null)\n+                    continue;\n                 keysm = RelationStrategies.getStateManager(mkey, ctx);\n-                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n+                valsm = RelationStrategies.getStateManager(mval, ctx);\n                 key.whereForeignKey(changeRow, keysm);\n-                val.setForeignKey(changeRow, valsm);\n-                rm.flushSecondaryRow(changeRow);\n+                if (isUni1ToMFK()){\n+                    changeRow = rm.getRow(field.getElementMapping().getDeclaredTypeMapping().getTable(),\n+                        Row.ACTION_UPDATE, valsm, true);\n+                    changeRow.wherePrimaryKey(valsm);\n+                    val.setForeignKey(changeRow, sm);\n+                } else {\n+                    val.setForeignKey(changeRow, valsm);\n+                    rm.flushSecondaryRow(changeRow);\n+                }\n             }\n         }\n \n         // delete the removes\n         Collection rem = ct.getRemoved();\n         if (!rem.isEmpty() || (!canChange && !change.isEmpty())) {\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\n-                Row.ACTION_DELETE);\n-            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+            Row delRow = null;\n+            if (!isUni1ToMFK()) {\n+                delRow = rm.getSecondaryRow(field.getTable(),\n+                    Row.ACTION_DELETE);\n+                delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+            }\n \n             for (Iterator itr = rem.iterator(); itr.hasNext();) {\n-                keysm = RelationStrategies.getStateManager(itr.next(), ctx);\n-                key.whereForeignKey(delRow, keysm);\n-                rm.flushSecondaryRow(delRow);\n+                Object pc = itr.next();\n+                if (isUni1ToMFK()){\n+                    updateSetNull(sm, rm, pc);\n+                } else {\n+                    keysm = RelationStrategies.getStateManager(pc, ctx);\n+                    key.whereForeignKey(delRow, keysm);\n+                    rm.flushSecondaryRow(delRow);\n+                }\n             }\n             if (!canChange && !change.isEmpty()) {\n                 for (Iterator itr = change.iterator(); itr.hasNext();) {\n-                    keysm = RelationStrategies.getStateManager(itr.next(),\n-                        ctx);\n-                    key.whereForeignKey(delRow, keysm);\n-                    rm.flushSecondaryRow(delRow);\n+                    Object pc = itr.next();\n+                    if (isUni1ToMFK()){\n+                        updateSetNull(sm, rm, pc);\n+                    } else { \n+                        keysm = RelationStrategies.getStateManager(pc, ctx);\n+                        key.whereForeignKey(delRow, keysm);\n+                        rm.flushSecondaryRow(delRow);\n+                    }\n                 }\n             }\n         }\n \n         // insert the adds\n         Collection add = ct.getAdded();\n         if (!add.isEmpty() || (!canChange && !change.isEmpty())) {\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\n-                Row.ACTION_INSERT);\n-            addRow.setForeignKey(field.getJoinForeignKey(),\n-                field.getJoinColumnIO(), sm);\n-\n+            Row addRow = null;\n+            if (!isUni1ToMFK()) {\n+                addRow = rm.getSecondaryRow(field.getTable(),\n+                    Row.ACTION_INSERT);\n+                addRow.setForeignKey(field.getJoinForeignKey(),\n+                    field.getJoinColumnIO(), sm);\n+            }\n             for (Iterator itr = add.iterator(); itr.hasNext();) {\n                 mkey = itr.next();\n+                Object mval = map.get(mkey);\n+                if (mval == null) {\n+                    Set<Map.Entry> entries = map.entrySet();\n+                    for (Map.Entry entry : entries) {\n+                        if (entry.getKey().equals(mkey))\n+                            mval = entry.getValue();\n+                    }\n+                }\n+                if (mval == null)\n+                    continue;\n                 keysm = RelationStrategies.getStateManager(mkey, ctx);\n-                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n-                key.setForeignKey(addRow, keysm);\n-                val.setForeignKey(addRow, valsm);\n-                rm.flushSecondaryRow(addRow);\n+                valsm = RelationStrategies.getStateManager(mval, ctx);\n+                if (isUni1ToMFK()){\n+                    addRow = rm.getRow(field.getElementMapping().getDeclaredTypeMapping().getTable(),\n+                        Row.ACTION_UPDATE, valsm, true);\n+                    addRow.wherePrimaryKey(valsm);\n+                    key.setForeignKey(addRow, keysm);\n+                    val.setForeignKey(addRow, sm);\n+                } else {\n+                    key.setForeignKey(addRow, keysm);\n+                    val.setForeignKey(addRow, valsm);\n+                    rm.flushSecondaryRow(addRow);\n+                }\n             }\n             if (!canChange && !change.isEmpty()) {\n                 for (Iterator itr = change.iterator(); itr.hasNext();) {\n                     mkey = itr.next();\n+                    Object mval = map.get(mkey);\n+                    if (mval == null) {\n+                        Set<Map.Entry> entries = map.entrySet();\n+                        for (Map.Entry entry : entries) {\n+                            if (entry.getKey().equals(mkey))\n+                                mval = entry.getValue();\n+                        }\n+                    }\n+                    if (mval == null)\n+                        continue;\n                     keysm = RelationStrategies.getStateManager(mkey, ctx);\n-                    valsm = RelationStrategies.getStateManager(map.get(mkey),\n-                        ctx);\n-                    key.setForeignKey(addRow, keysm);\n-                    val.setForeignKey(addRow, valsm);\n-                    rm.flushSecondaryRow(addRow);\n+                    valsm = RelationStrategies.getStateManager(mval, ctx);\n+                    if (isUni1ToMFK()){\n+                        addRow = rm.getRow(field.getElementMapping().getDeclaredTypeMapping().getTable(),\n+                            Row.ACTION_UPDATE, valsm, true);\n+                        addRow.wherePrimaryKey(valsm);\n+                        key.setForeignKey(addRow, keysm);\n+                        val.setForeignKey(addRow, sm);\n+                    } else {\n+                        key.setForeignKey(addRow, keysm);\n+                        val.setForeignKey(addRow, valsm);\n+                        rm.flushSecondaryRow(addRow);\n+                    }\n                 }\n             }\n         }\n@@ -403,4 +501,39 @@ public Object toKeyDataStoreValue(Object val, JDBCStore store) {\n         return RelationStrategies.toDataStoreValue(field.getKeyMapping(),\n             val, store);\n     }\n+    \n+    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        if (isUni1ToMFK()) {\n+            Map mapObj = (Map)sm.fetchObject(field.getIndex());\n+            updateSetNull(sm, store, rm, mapObj.keySet());\n+            return;\n+        }    \n+        super.delete(sm, store, rm);\n+    }\n+    \n+    private void updateSetNull(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n+        Set rem) throws SQLException {\n+        for (Iterator itr = rem.iterator(); itr.hasNext();) {\n+            Object mkey = itr.next();\n+            updateSetNull(sm, rm, mkey);\n+        }\n+    }\n+    \n+    private void updateSetNull(OpenJPAStateManager sm, RowManager rm, Object mkey) \n+        throws SQLException {\n+        StoreContext ctx = sm.getContext();\n+        ValueMapping key = field.getKeyMapping();\n+        ValueMapping val = field.getElementMapping();\n+        OpenJPAStateManager keysm = RelationStrategies.getStateManager(mkey, ctx);\n+        Row delRow = rm.getRow(field.getElementMapping().getDeclaredTypeMapping().getTable(),\n+                Row.ACTION_UPDATE, sm, true);\n+        ValueMappingInfo vinfo = field.getElementMapping().getValueInfo();\n+        Table table = vinfo.getTable(val);\n+        ForeignKey joinFK = field.getMappingInfo().getJoinForeignKey(field, table, true);\n+        delRow.whereForeignKey(joinFK, sm);\n+        delRow.whereForeignKey(key.getForeignKey(), keysm);\n+        val.setForeignKey(delRow, null);\n+        key.setForeignKey(delRow, null);\n+    }\n }"},{"sha":"e8082303809adcf63b6f76927f9d0af993060517","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/EntityC.java","status":"modified","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/apache/openjpa/blob/9f29552e858bceac4e69e11547db9118d228461d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/EntityC.java","raw_url":"https://github.com/apache/openjpa/raw/9f29552e858bceac4e69e11547db9118d228461d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/EntityC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/EntityC.java?ref=9f29552e858bceac4e69e11547db9118d228461d","patch":"@@ -44,4 +44,17 @@ public String getName() {\n     public void setName(String name) { \n         this.name = name; \n     }\n+    \n+    public int hashCode() {\n+        return name.hashCode() + (int)id;\n+    }\n+    \n+    public boolean equals(Object o) {\n+        if (!(o instanceof EntityC)) return false;\n+        EntityC c = (EntityC)o;\n+        if (!c.name.equals(name)) return false;\n+        if (c.id != id) return false;\n+        return true;\n+    }\n+    \n }"},{"sha":"7fc8d28bf3ce213bcad9dedb73069c1c99c7fb4f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/EntityC_U1M_Map_RelKey_FK.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/9f29552e858bceac4e69e11547db9118d228461d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/EntityC_U1M_Map_RelKey_FK.java","raw_url":"https://github.com/apache/openjpa/raw/9f29552e858bceac4e69e11547db9118d228461d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/EntityC_U1M_Map_RelKey_FK.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/EntityC_U1M_Map_RelKey_FK.java?ref=9f29552e858bceac4e69e11547db9118d228461d","patch":"@@ -0,0 +1,61 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.persistence.compat;\r\n+\r\n+import java.util.List;\r\n+\r\n+import javax.persistence.*;\r\n+\r\n+@Entity\r\n+public class EntityC_U1M_Map_RelKey_FK {\r\n+\r\n+    @Id\r\n+    @GeneratedValue\r\n+    private long id;\r\n+\r\n+    private String name;\r\n+\r\n+    public long getId() { \r\n+        return id; \r\n+    }\r\n+\r\n+    public String getName() { \r\n+        return name; \r\n+    }\r\n+\r\n+    public void setName(String name) { \r\n+        this.name = name; \r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return name.hashCode() + (int)id;\r\n+    }\r\n+    \r\n+    public boolean equals(Object o) {\r\n+        if (!(o instanceof EntityC_U1M_Map_RelKey_FK)) return false;\r\n+        EntityC_U1M_Map_RelKey_FK c = (EntityC_U1M_Map_RelKey_FK)o;\r\n+        if (!c.name.equals(name)) return false;\r\n+        if (c.id != id) return false;\r\n+        return true;\r\n+    }\r\n+    \r\n+    public String toString() {\r\n+        return id + name;\r\n+    }\r\n+}\r"},{"sha":"314570e99d75c2092eb600dad47bcbba9c297b80","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestSpecCompatibilityOptions.java","status":"modified","additions":72,"deletions":1,"changes":73,"blob_url":"https://github.com/apache/openjpa/blob/9f29552e858bceac4e69e11547db9118d228461d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestSpecCompatibilityOptions.java","raw_url":"https://github.com/apache/openjpa/raw/9f29552e858bceac4e69e11547db9118d228461d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestSpecCompatibilityOptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestSpecCompatibilityOptions.java?ref=9f29552e858bceac4e69e11547db9118d228461d","patch":"@@ -341,7 +341,6 @@ public void crudBi1MFK(EntityManager em) {\n         em.clear();\n     }\n \n-    // non default\n     public void crudBi1MJT(EntityManager em) {\n         Bi_1ToM_JT b = new Bi_1ToM_JT();\n         b.setName(\"bi1mfk\");\n@@ -398,6 +397,9 @@ public void testOneToManyMapRelation() {\n         types.add(Uni_1ToM_Map_FK.class);\n         types.add(EntityC_B1M_Map_JT.class);\n         types.add(Bi_1ToM_Map_JT.class);\n+        types.add(EntityC_U1M_Map_RelKey_FK.class);\n+        types.add(Uni_1ToM_Map_RelKey_FK.class);\n+        types.add(EntityC.class);\n         OpenJPAEntityManagerFactorySPI emf = createEMF2_0(types);\n         EntityManager em = emf.createEntityManager();\n         \n@@ -408,6 +410,7 @@ public void testOneToManyMapRelation() {\n             assertSQLFragnments(sql, \"CREATE TABLE EntityC_U1M_Map_FK\", \"Uni1MFK_ID\", \"KEY0\");\n             crudUni1MMapFK(em);\n             crudBi1MMapJT(em);\n+            crudUni1MMapRelKeyFK(em);\n         } catch (Exception e) {\n             e.printStackTrace();\n             fail(\"OneToMany mapping failed with exception message: \" + e.getMessage());\n@@ -526,6 +529,74 @@ public void crudBi1MMapJT(EntityManager em) {\n         em.getTransaction().commit();\n     }\n     \n+    public void crudUni1MMapRelKeyFK(EntityManager em) {\n+        //create\n+        Uni_1ToM_Map_RelKey_FK u = new Uni_1ToM_Map_RelKey_FK();\n+        u.setName(\"uni1mfk\");\n+        Map<EntityC, EntityC_U1M_Map_RelKey_FK> cs = new HashMap<EntityC, EntityC_U1M_Map_RelKey_FK>();\n+        EntityC_U1M_Map_RelKey_FK c1 = new EntityC_U1M_Map_RelKey_FK();\n+        c1.setName(\"c1\");\n+        EntityC cKey1 = new EntityC();\n+        cKey1.setName(\"cKey1\");\n+        cs.put(cKey1, c1);\n+        EntityC_U1M_Map_RelKey_FK c2 = new EntityC_U1M_Map_RelKey_FK();\n+        c2.setName(\"c2\");\n+        EntityC cKey2 = new EntityC();\n+        cKey2.setName(\"cKey2\");\n+        cs.put(cKey2, c1);\n+        cs.put(cKey2, c2);\n+        u.setEntityCs(cs);\n+        em.persist(u);\n+        em.persist(c1);\n+        em.persist(c2);\n+        em.persist(cKey1);\n+        em.persist(cKey2);\n+        em.getTransaction().begin();\n+        em.getTransaction().commit();\n+\n+        //update by adding a new C\n+        em.getTransaction().begin();\n+        cs = u.getEntityCs();\n+        u.setName(\"uni1mfk_new\");\n+        EntityC_U1M_Map_RelKey_FK c3 = new EntityC_U1M_Map_RelKey_FK();\n+        c3.setName(\"c3\");\n+        EntityC cKey3 = new EntityC();\n+        cKey3.setName(\"cKey3\");\n+        cs.put(cKey3, c3);\n+        em.persist(c3);\n+        em.persist(cKey3);\n+        em.getTransaction().commit();\n+        \n+        // update by removing a c and then add this c to a new u\n+        em.getTransaction().begin();\n+        EntityC_U1M_Map_RelKey_FK c4 = cs.remove(cKey1);\n+        \n+        Uni_1ToM_Map_RelKey_FK u2 = new Uni_1ToM_Map_RelKey_FK();\n+        u2.setName(\"uni1mfk2\");\n+        Map<EntityC, EntityC_U1M_Map_RelKey_FK> cs2 = new HashMap<EntityC, EntityC_U1M_Map_RelKey_FK>();\n+        cs2.put(cKey1, c4);\n+        u2.setEntityCs(cs2);\n+        em.persist(u2);\n+        em.getTransaction().commit();\n+        em.clear();\n+        \n+        //query\n+        Query q = em.createQuery(\"SELECT u FROM Uni_1ToM_Map_RelKey_FK u where u.name='uni1mfk_new'\");\n+        Uni_1ToM_Map_RelKey_FK u1 = (Uni_1ToM_Map_RelKey_FK)q.getSingleResult();\n+        assertEquals(u, u1);\n+        em.clear();\n+\n+        //find\n+        long id = u1.getId();\n+        Uni_1ToM_Map_RelKey_FK findU = em.find(Uni_1ToM_Map_RelKey_FK.class, id);\n+        assertEquals(u, findU);\n+        \n+        //remove\n+        em.getTransaction().begin();\n+        em.remove(findU);\n+        em.getTransaction().commit();\n+    }\n+\n     private OpenJPAEntityManagerFactorySPI createEMF2_0(List<Class<?>> types) {\n         Map<Object,Object> map = new HashMap<Object,Object>();\n         map.put(\"openjpa.jdbc.JDBCListeners\", "},{"sha":"b6a2b23a7cfe719376c2ac69ad63d4c3b71719b7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/Uni_1ToM_Map_RelKey_FK.java","status":"added","additions":97,"deletions":0,"changes":97,"blob_url":"https://github.com/apache/openjpa/blob/9f29552e858bceac4e69e11547db9118d228461d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/Uni_1ToM_Map_RelKey_FK.java","raw_url":"https://github.com/apache/openjpa/raw/9f29552e858bceac4e69e11547db9118d228461d/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/Uni_1ToM_Map_RelKey_FK.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/Uni_1ToM_Map_RelKey_FK.java?ref=9f29552e858bceac4e69e11547db9118d228461d","patch":"@@ -0,0 +1,97 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.persistence.compat;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+\r\n+import javax.persistence.*;\r\n+\r\n+//non-default mapping\r\n+//Sec 11.1.36, Example 3: \r\n+//    Unidirectional One-to-Many association using a foreign key mapping\r\n+//    In Customer class:\r\n+//    @OneToMany(orphanRemoval=true)\r\n+//    @JoinColumn(name=\"CUST_ID\") // join column is in table for Order\r\n+//    public Set<Order> getOrders() {return orders;}\r\n+\r\n+@Entity\r\n+public class Uni_1ToM_Map_RelKey_FK {\r\n+\r\n+    @Id\r\n+    @GeneratedValue\r\n+    private long id;\r\n+\r\n+    private String name;\r\n+\r\n+    @OneToMany(/*cascade = CascadeType.ALL,*/ fetch=FetchType.EAGER)\r\n+    @JoinColumn(name=\"Uni1MFK_ID\")\r\n+    private Map<EntityC, EntityC_U1M_Map_RelKey_FK> entityCs = null;\r\n+    \r\n+    public long getId() { \r\n+        return id; \r\n+    }\r\n+\r\n+    public String getName() { \r\n+        return name; \r\n+    }\r\n+\r\n+    public void setName(String name) { \r\n+        this.name = name; \r\n+    }\r\n+\r\n+    public Map<EntityC, EntityC_U1M_Map_RelKey_FK> getEntityCs() { \r\n+        return entityCs; \r\n+    }\r\n+\r\n+    public void setEntityCs(Map<EntityC, EntityC_U1M_Map_RelKey_FK> entityCs) { \r\n+        this.entityCs = entityCs; \r\n+    }\r\n+\r\n+    public int hashCode() {\r\n+        return name.hashCode();\r\n+    }\r\n+    \r\n+    public boolean equals(Object o) {\r\n+        if (!(o instanceof Uni_1ToM_Map_RelKey_FK)) return false;\r\n+        Uni_1ToM_Map_RelKey_FK b = (Uni_1ToM_Map_RelKey_FK)o;\r\n+        if (!b.name.equals(name)) return false;\r\n+        if (b.entityCs.size() != entityCs.size()) return false;\r\n+        \r\n+        Set<EntityC> coll = b.entityCs.keySet();\r\n+        for (EntityC cKey : coll) {\r\n+            EntityC_U1M_Map_RelKey_FK val = (EntityC_U1M_Map_RelKey_FK)getValue(b.entityCs, cKey);\r\n+            EntityC_U1M_Map_RelKey_FK val1 = (EntityC_U1M_Map_RelKey_FK)getValue(entityCs, cKey); \r\n+            if (!val.equals(val1))\r\n+                return false;\r\n+        }\r\n+        return true;\r\n+    }\r\n+    \r\n+    private Object getValue(Map map, Object mkey) {\r\n+        Set<Map.Entry> entries = map.entrySet();\r\n+        for (Map.Entry entry : entries) {\r\n+            if (entry.getKey().equals(mkey))\r\n+                return entry.getValue();\r\n+        }\r\n+        return null;\r\n+    }\r\n+}\r"}]}

