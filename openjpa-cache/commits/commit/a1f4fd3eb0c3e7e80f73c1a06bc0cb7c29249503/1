{"sha":"a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503","node_id":"MDY6Q29tbWl0MjA2MzY0OmExZjRmZDNlYjBjM2U3ZTgwZjczYzFhMDZiYzBjYjdjMjkyNDk1MDM=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-07-20T01:15:04Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-07-20T01:15:04Z"},"message":"changed some more finally and catch blocks that didn't get properly reformatted with earlier reformattings / sed scripts\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@423693 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ec10ac9d99451d328f8637c93f620c07fa6754ee","url":"https://api.github.com/repos/apache/openjpa/git/trees/ec10ac9d99451d328f8637c93f620c07fa6754ee"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503","html_url":"https://github.com/apache/openjpa/commit/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503","comments_url":"https://api.github.com/repos/apache/openjpa/commits/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503/comments","author":null,"committer":null,"parents":[{"sha":"b108a39e7ec1719df17034f9f0083477be816951","url":"https://api.github.com/repos/apache/openjpa/commits/b108a39e7ec1719df17034f9f0083477be816951","html_url":"https://github.com/apache/openjpa/commit/b108a39e7ec1719df17034f9f0083477be816951"}],"stats":{"total":457,"additions":206,"deletions":251},"files":[{"sha":"308b3be52473dad8cc251da98ad1e9eed388b76c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractUpdateManager.java","status":"modified","additions":36,"deletions":44,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractUpdateManager.java","raw_url":"https://github.com/apache/openjpa/raw/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractUpdateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractUpdateManager.java?ref=a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503","patch":"@@ -63,8 +63,8 @@ public void endConfiguration() {\n     public Collection flush(Collection states, JDBCStore store) {\n         Connection conn = store.getConnection();\n         try {\n-            PreparedStatementManager psMgr = newPreparedStatementManager\n-                (store, conn);\n+            PreparedStatementManager psMgr = newPreparedStatementManager(store,\n+                conn);\n             return flush(states, store, psMgr);\n         } finally {\n             try {\n@@ -81,9 +81,8 @@ private Collection flush(Collection states, JDBCStore store,\n         Collection customs = new LinkedList();\n         Collection exceps = null;\n         for (Iterator itr = states.iterator(); itr.hasNext();)\n-            exceps =\n-                populateRowManager((OpenJPAStateManager) itr.next(), rowMgr,\n-                    store, exceps, customs);\n+            exceps = populateRowManager((OpenJPAStateManager) itr.next(),\n+                rowMgr, store, exceps, customs);\n \n         // flush rows\n         exceps = flush(rowMgr, psMgr, exceps);\n@@ -93,8 +92,7 @@ private Collection flush(Collection states, JDBCStore store,\n             try {\n                 ((CustomMapping) itr.next()).execute(store);\n             } catch (SQLException se) {\n-                exceps = addException(exceps, SQLExceptions.getStore(se,\n-                    dict));\n+                exceps = addException(exceps, SQLExceptions.getStore(se, dict));\n             } catch (OpenJPAException ke) {\n                 exceps = addException(exceps, ke);\n             }\n@@ -118,8 +116,8 @@ private Collection flush(Collection states, JDBCStore store,\n     /**\n      * Return a new {@link PreparedStatementManager}.\n      */\n-    protected abstract PreparedStatementManager newPreparedStatementManager\n-        (JDBCStore store, Connection conn);\n+    protected abstract PreparedStatementManager newPreparedStatementManager(\n+        JDBCStore store, Connection conn);\n \n     /**\n      * Flush all rows of the given row manager. Add exceptions to\n@@ -142,36 +140,34 @@ private Collection populateRowManager(OpenJPAStateManager sm,\n         Collection customs) {\n         try {\n             if (sm.getPCState() == PCState.PNEW && !sm.isFlushed()) {\n-                insert(sm, (ClassMapping) sm.getMetaData(), rowMgr,\n-                    store, customs);\n+                insert(sm, (ClassMapping) sm.getMetaData(), rowMgr, store,\n+                    customs);\n             } else if (sm.getPCState() == PCState.PNEWFLUSHEDDELETED\n                 || sm.getPCState() == PCState.PDELETED) {\n-                delete(sm, (ClassMapping) sm.getMetaData(), rowMgr,\n-                    store, customs);\n-            } else if ((sm.getPCState() == PCState.PDIRTY\n-                && (!sm.isFlushed() || sm.isFlushedDirty()))\n-                || (sm.getPCState() == PCState.PNEW\n-                && sm.isFlushedDirty())) {\n+                delete(sm, (ClassMapping) sm.getMetaData(), rowMgr, store,\n+                    customs);\n+            } else if ((sm.getPCState() == PCState.PDIRTY && (!sm.isFlushed() || sm\n+                .isFlushedDirty()))\n+                || (sm.getPCState() == PCState.PNEW && sm.isFlushedDirty())) {\n                 BitSet dirty = sm.getDirty();\n                 if (sm.isFlushed()) {\n                     dirty = (BitSet) dirty.clone();\n                     dirty.andNot(sm.getFlushed());\n                 }\n \n                 if (dirty.length() > 0)\n-                    update(sm, dirty, (ClassMapping) sm.getMetaData(),\n-                        rowMgr, store, customs);\n+                    update(sm, dirty, (ClassMapping) sm.getMetaData(), rowMgr,\n+                        store, customs);\n             } else if (sm.isVersionUpdateRequired()) {\n-                updateIndicators(sm, (ClassMapping) sm.getMetaData(),\n-                    rowMgr, store, customs, true);\n+                updateIndicators(sm, (ClassMapping) sm.getMetaData(), rowMgr,\n+                    store, customs, true);\n             } else if (sm.isVersionCheckRequired()) {\n-                if (!((ClassMapping) sm.getMetaData()).getVersion().\n-                    checkVersion(sm, store, false))\n-                    exceps = addException(exceps, new OptimisticException\n-                        (sm.getManagedInstance()));\n+                if (!((ClassMapping) sm.getMetaData()).getVersion()\n+                    .checkVersion(sm, store, false))\n+                    exceps = addException(exceps, new OptimisticException(sm\n+                        .getManagedInstance()));\n             }\n-        }\n-        catch (SQLException se) {\n+        } catch (SQLException se) {\n             exceps = addException(exceps, SQLExceptions.getStore(se, dict));\n         } catch (OpenJPAException ke) {\n             exceps = addException(exceps, ke);\n@@ -284,8 +280,7 @@ private boolean bufferCustomDelete(Strategy strat, OpenJPAStateManager sm,\n      */\n     private void update(OpenJPAStateManager sm, BitSet dirty,\n         ClassMapping mapping, RowManager rowMgr, JDBCStore store,\n-        Collection customs)\n-        throws SQLException {\n+        Collection customs) throws SQLException {\n         Boolean custom = mapping.isCustomUpdate(sm, store);\n         if (!Boolean.FALSE.equals(custom))\n             mapping.customUpdate(sm, store);\n@@ -314,8 +309,7 @@ private void update(OpenJPAStateManager sm, BitSet dirty,\n      */\n     private void updateIndicators(OpenJPAStateManager sm, ClassMapping mapping,\n         RowManager rowMgr, JDBCStore store, Collection customs,\n-        boolean versionUpdateOnly)\n-        throws SQLException {\n+        boolean versionUpdateOnly) throws SQLException {\n         while (mapping.getJoinablePCSuperclassMapping() != null)\n             mapping = mapping.getJoinablePCSuperclassMapping();\n \n@@ -359,25 +353,23 @@ private boolean bufferCustomUpdate(Strategy strat, OpenJPAStateManager sm,\n         private final OpenJPAStateManager _sm;\n         private final Strategy _strat;\n \n-        public CustomMapping(int action, OpenJPAStateManager sm,\n-            Strategy strat) {\n+        public CustomMapping(int action, OpenJPAStateManager sm, Strategy strat) {\n             _action = action;\n             _sm = sm;\n             _strat = strat;\n         }\n \n-        public void execute(JDBCStore store)\n-            throws SQLException {\n+        public void execute(JDBCStore store) throws SQLException {\n             switch (_action) {\n-                case INSERT:\n-                    _strat.customInsert(_sm, store);\n-                    break;\n-                case UPDATE:\n-                    _strat.customUpdate(_sm, store);\n-                    break;\n-                case DELETE:\n-                    _strat.customDelete(_sm, store);\n-                    break;\n+            case INSERT:\n+                _strat.customInsert(_sm, store);\n+                break;\n+            case UPDATE:\n+                _strat.customUpdate(_sm, store);\n+                break;\n+            case DELETE:\n+                _strat.customDelete(_sm, store);\n+                break;\n             }\n         }\n     }"},{"sha":"484cd0d30b47f3cd828c3eccc7e8ff80fc0be752","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ClassTableJDBCSeq.java","status":"modified","additions":12,"deletions":15,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ClassTableJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ClassTableJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ClassTableJDBCSeq.java?ref=a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503","patch":"@@ -41,11 +41,11 @@\n  *\n  * @author Abe White\n  */\n-public class ClassTableJDBCSeq\n+public class ClassTableJDBCSeq \n     extends TableJDBCSeq {\n \n-    private static final Localizer _loc = Localizer.forPackage\n-        (ClassTableJDBCSeq.class);\n+    private static final Localizer _loc = Localizer\n+        .forPackage(ClassTableJDBCSeq.class);\n \n     private final Map _stats = new HashMap();\n     private boolean _ignore = false;\n@@ -109,8 +109,8 @@ protected Status getStatus(ClassMapping mapping) {\n \n     protected Column addPrimaryKeyColumn(Table table) {\n         DBDictionary dict = getConfiguration().getDBDictionaryInstance();\n-        Column pkColumn = table.addColumn(dict.getValidColumnName\n-            (getPrimaryKeyColumn(), table));\n+        Column pkColumn = table.addColumn(dict.getValidColumnName(\n+            getPrimaryKeyColumn(), table));\n         pkColumn.setType(dict.getPreferredType(Types.VARCHAR));\n         pkColumn.setJavaType(JavaTypes.STRING);\n         pkColumn.setSize(dict.characterColumnSize);\n@@ -163,8 +163,7 @@ private String getKey(ClassMapping mapping, boolean db) {\n      * <li><i>set</i>: Set the sequence value for the given class.</li>\n      * </ul>\n      */\n-    public static void main(String[] args)\n-        throws Exception {\n+    public static void main(String[] args) throws Exception {\n         Options opts = new Options();\n         args = opts.setFromCmdLine(args);\n         JDBCConfiguration conf = new JDBCConfigurationImpl();\n@@ -180,8 +179,7 @@ public static void main(String[] args)\n      * Run the tool. Returns false if invalid options were given.\n      */\n     public static boolean run(JDBCConfiguration conf, String[] args,\n-        Options opts)\n-        throws Exception {\n+        Options opts) throws Exception {\n         if (opts.containsKey(\"help\") || opts.containsKey(\"-help\"))\n             return false;\n \n@@ -213,11 +211,11 @@ public static boolean run(JDBCConfiguration conf, String[] args,\n                 return false;\n \n             if (loader == null)\n-                loader = conf.getClassResolverInstance().\n-                    getClassLoader(ClassTableJDBCSeq.class, null);\n+                loader = conf.getClassResolverInstance().getClassLoader(\n+                    ClassTableJDBCSeq.class, null);\n \n-            ClassArgParser cap = conf.getMetaDataRepository().\n-                getMetaDataFactory().newClassArgParser();\n+            ClassArgParser cap = conf.getMetaDataRepository()\n+                .getMetaDataFactory().newClassArgParser();\n             cap.setClassLoader(loader);\n             Class cls = cap.parseTypes(args[0])[0];\n \n@@ -246,8 +244,7 @@ public static boolean run(JDBCConfiguration conf, String[] args,\n                     }\n                     System.err.println(mapping + \": \" + set);\n                 }\n-            }\n-            catch (NumberFormatException nfe) {\n+            } catch (NumberFormatException nfe) {\n                 return false;\n             } finally {\n                 try {"},{"sha":"3e047a87fa966f797240d1c34fdbbee69d71a820","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","status":"modified","additions":92,"deletions":118,"changes":210,"blob_url":"https://github.com/apache/openjpa/blob/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java?ref=a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503","patch":"@@ -81,11 +81,11 @@\n  * @author Abe White\n  * @nojavadoc\n  */\n-public class JDBCStoreManager\n+public class JDBCStoreManager \n     implements StoreManager, JDBCStore {\n \n-    private static final Localizer _loc = Localizer.forPackage\n-        (JDBCStoreManager.class);\n+    private static final Localizer _loc = Localizer\n+        .forPackage(JDBCStoreManager.class);\n \n     private StoreContext _ctx = null;\n     private JDBCConfiguration _conf = null;\n@@ -142,10 +142,10 @@ public JDBCFetchConfiguration getFetchConfiguration() {\n         return (JDBCFetchConfiguration) _ctx.getFetchConfiguration();\n     }\n \n-    private JDBCFetchConfiguration getFetchConfiguration\n-        (JDBCFetchState fetchState) {\n-        return (fetchState == null) ? getFetchConfiguration()\n-            : fetchState.getJDBCFetchConfiguration();\n+    private JDBCFetchConfiguration getFetchConfiguration(\n+        JDBCFetchState fetchState) {\n+        return (fetchState == null) ? getFetchConfiguration() : fetchState\n+            .getJDBCFetchConfiguration();\n     }\n \n     public void beginOptimistic() {\n@@ -187,8 +187,9 @@ public void rollback() {\n             return;\n \n         try {\n-            if (_conn != null && (!_ctx.isManaged()\n-                || !_conf.isConnectionFactoryModeManaged()))\n+            if (_conn != null\n+                && (!_ctx.isManaged() || !_conf\n+                    .isConnectionFactoryModeManaged()))\n                 _conn.rollback();\n         } catch (SQLException se) {\n             throw SQLExceptions.getStore(se, _dict);\n@@ -256,8 +257,7 @@ public boolean initialize(OpenJPAStateManager sm, PCState state,\n         FetchState fetchState, Object context) {\n         ConnectionInfo info = (ConnectionInfo) context;\n         try {\n-            return initializeState(sm, state, (JDBCFetchState) fetchState,\n-                info);\n+            return initializeState(sm, state, (JDBCFetchState) fetchState, info);\n         } catch (ClassNotFoundException cnfe) {\n             throw new UserException(cnfe);\n         } catch (SQLException se) {\n@@ -281,8 +281,8 @@ private boolean initializeState(OpenJPAStateManager sm, PCState state,\n             if (info.mapping == null)\n                 info.mapping = mapping;\n             mapping = info.mapping;\n-        } else\n-        if (oid instanceof OpenJPAId && !((OpenJPAId) oid).hasSubclasses()) {\n+        } else if (oid instanceof OpenJPAId\n+            && !((OpenJPAId) oid).hasSubclasses()) {\n             Boolean custom = customLoad(sm, mapping, state, jfetch);\n             if (custom != null)\n                 return custom.booleanValue();\n@@ -293,8 +293,8 @@ private boolean initializeState(OpenJPAStateManager sm, PCState state,\n             if (res != null && !res.next())\n                 return false;\n         } else {\n-            ClassMapping[] mappings = mapping.\n-                getIndependentAssignableMappings();\n+            ClassMapping[] mappings = mapping\n+                .getIndependentAssignableMappings();\n             if (mappings.length == 1) {\n                 mapping = mappings[0];\n                 Boolean custom = customLoad(sm, mapping, state, jfetch);\n@@ -388,8 +388,7 @@ private Result getInitializeStateResult(OpenJPAStateManager sm,\n      */\n     private Result getInitializeStateUnionResult(final OpenJPAStateManager sm,\n         ClassMapping mapping, final ClassMapping[] mappings,\n-        final JDBCFetchState fetchState)\n-        throws SQLException {\n+        final JDBCFetchState fetchState) throws SQLException {\n         final JDBCStoreManager store = this;\n         JDBCFetchConfiguration jfetch = getFetchConfiguration(fetchState);\n         final int eager = Math.min(jfetch.getEagerFetchMode(),\n@@ -400,6 +399,7 @@ private Result getInitializeStateUnionResult(final OpenJPAStateManager sm,\n         if (jfetch.getSubclassFetchMode(mapping) != jfetch.EAGER_JOIN)\n             union.abortUnion();\n         union.select(new Union.Selector() {\n+\n             public void select(Select sel, int i) {\n                 sel.select(mappings[i], Select.SUBS_ANY_JOINABLE, store,\n                     fetchState, eager);\n@@ -414,8 +414,7 @@ public void select(Select sel, int i) {\n      * if needed.\n      */\n     private boolean selectPrimaryKey(OpenJPAStateManager sm,\n-        ClassMapping mapping,\n-        JDBCFetchConfiguration jfetch)\n+        ClassMapping mapping, JDBCFetchConfiguration jfetch)\n         throws SQLException {\n         // select pks from base class record to ensure it exists and lock\n         // it if needed\n@@ -442,8 +441,8 @@ private boolean selectPrimaryKey(OpenJPAStateManager sm,\n \n     public boolean load(OpenJPAStateManager sm, BitSet fields,\n         FetchState fetchState, int lockLevel, Object context) {\n-        JDBCFetchState jfetchState = (fetchState == null)\n-            ? (JDBCFetchState) getFetchConfiguration().newFetchState()\n+        JDBCFetchState jfetchState = (fetchState == null) ? (JDBCFetchState) getFetchConfiguration()\n+            .newFetchState()\n             : (JDBCFetchState) fetchState;\n \n         JDBCFetchConfiguration jfetch = getFetchConfiguration(jfetchState);\n@@ -586,8 +585,7 @@ public Class getDataStoreIdType(ClassMetaData meta) {\n \n     public Object copyDataStoreId(Object oid, ClassMetaData meta) {\n         Id id = (Id) oid;\n-        return new Id(meta.getDescribedType(), id.getId(),\n-            id.hasSubclasses());\n+        return new Id(meta.getDescribedType(), id.getId(), id.hasSubclasses());\n     }\n \n     public Object newDataStoreId(Object val, ClassMetaData meta) {\n@@ -605,12 +603,12 @@ public ResultObjectProvider executeExtent(ClassMetaData meta,\n         if (subclasses)\n             mappings = mapping.getIndependentAssignableMappings();\n         else\n-            mappings = new ClassMapping[]{ mapping };\n+            mappings = new ClassMapping[] { mapping };\n \n         ResultObjectProvider[] rops = null;\n         final JDBCFetchConfiguration jfetch = (JDBCFetchConfiguration) fetch;\n-        final JDBCFetchState jfetchState = (JDBCFetchState)\n-            jfetch.newFetchState();\n+        final JDBCFetchState jfetchState = (JDBCFetchState) jfetch\n+            .newFetchState();\n         if (jfetch.getSubclassFetchMode(mapping) != jfetch.EAGER_JOIN)\n             rops = new ResultObjectProvider[mappings.length];\n \n@@ -657,6 +655,7 @@ public ResultObjectProvider executeExtent(ClassMetaData meta,\n             union.setLRS(true);\n             final BitSet[] paged = new BitSet[mappings.length];\n             union.select(new Union.Selector() {\n+\n                 public void select(Select sel, int idx) {\n                     paged[idx] = selectExtent(sel, mappings[idx], jfetchState,\n                         subclasses);\n@@ -670,8 +669,8 @@ public void select(Select sel, int idx) {\n                         JDBCStoreManager.this, jfetchState, paged,\n                         Long.MAX_VALUE);\n             }\n-            return new InstanceResultObjectProvider(union, mappings[0],\n-                this, jfetchState);\n+            return new InstanceResultObjectProvider(union, mappings[0], this,\n+                jfetchState);\n         } catch (SQLException se) {\n             throw SQLExceptions.getStore(se, _dict);\n         }\n@@ -684,8 +683,8 @@ private BitSet selectExtent(Select sel, ClassMapping mapping,\n         JDBCFetchState jfetchState, boolean subclasses) {\n         int subs = (subclasses) ? Select.SUBS_JOINABLE : Select.SUBS_NONE;\n         // decide between paging and standard iteration\n-        BitSet paged = PagingResultObjectProvider.getPagedFields(sel,\n-            mapping, this, jfetchState, JDBCFetchConfiguration.EAGER_PARALLEL,\n+        BitSet paged = PagingResultObjectProvider.getPagedFields(sel, mapping,\n+            this, jfetchState, JDBCFetchConfiguration.EAGER_PARALLEL,\n             Long.MAX_VALUE);\n         if (paged == null)\n             sel.selectIdentifier(mapping, subs, this, jfetchState,\n@@ -752,16 +751,14 @@ private void connect(boolean ref) {\n      * Connect to the database. This method is separated out so that it\n      * can be profiled.\n      */\n-    private RefCountConnection connectInternal()\n-        throws SQLException {\n+    private RefCountConnection connectInternal() throws SQLException {\n         return new RefCountConnection(_ds.getConnection());\n     }\n \n     /**\n      * Find the object with the given oid.\n      */\n-    public Object find(Object oid, ValueMapping vm,\n-        JDBCFetchState fetchState) {\n+    public Object find(Object oid, ValueMapping vm, JDBCFetchState fetchState) {\n         if (oid == null)\n             return null;\n         Object pc = _ctx.find(oid, fetchState, null, null, 0);\n@@ -776,11 +773,10 @@ public Object find(Object oid, ValueMapping vm,\n      * Load the object in the current row of the given result.\n      */\n     public Object load(ClassMapping mapping, JDBCFetchState fetchState,\n-        BitSet exclude, Result result)\n-        throws SQLException {\n+        BitSet exclude, Result result) throws SQLException {\n         if (!mapping.isMapped())\n-            throw new InvalidStateException(_loc.get(\"virtual-mapping\",\n-                mapping));\n+            throw new InvalidStateException(_loc\n+                .get(\"virtual-mapping\", mapping));\n \n         // get the object id for the row; base class selects pk columns\n         ClassMapping base = mapping;\n@@ -801,8 +797,7 @@ public Object load(ClassMapping mapping, JDBCFetchState fetchState,\n      * mappings originally selected will be loaded.\n      */\n     private void load(ClassMapping mapping, OpenJPAStateManager sm,\n-        JDBCFetchState fetchState, Result res)\n-        throws SQLException {\n+        JDBCFetchState fetchState, Result res) throws SQLException {\n         FieldMapping eagerToMany = load(mapping, sm, fetchState, res, null);\n         if (eagerToMany != null)\n             eagerToMany.loadEagerJoin(sm, this, fetchState, res);\n@@ -832,8 +827,7 @@ else if (sm.getVersion() == null)\n         FieldMapping[] fms = mapping.getDefinedFieldMappings();\n         Object eres, processed;\n         for (int i = 0; i < fms.length; i++) {\n-            if (fms[i].isPrimaryKey()\n-                || sm.getLoaded().get(fms[i].getIndex()))\n+            if (fms[i].isPrimaryKey() || sm.getLoaded().get(fms[i].getIndex()))\n                 continue;\n \n             // check for eager result, and if not present do standard load\n@@ -894,8 +888,8 @@ public boolean select(Select sel, ClassMapping mapping, int subs,\n         // preventing infinite recursion\n         JDBCFetchConfiguration fetch = getFetchConfiguration(fetchState);\n         eager = Math.min(eager, fetch.getEagerFetchMode());\n-        FieldMapping eagerToMany = createEagerSelects(sel, mapping, sm,\n-            fields, fetchState, eager);\n+        FieldMapping eagerToMany = createEagerSelects(sel, mapping, sm, fields,\n+            fetchState, eager);\n \n         // select all base class mappings; do this after batching so that\n         // the joins needed by these selects don't get in the WHERE clause\n@@ -928,8 +922,8 @@ private FieldMapping createEagerSelects(Select sel, ClassMapping mapping,\n             return null;\n \n         JDBCFetchConfiguration fetch = getFetchConfiguration(fetchState);\n-        FieldMapping eagerToMany = createEagerSelects(sel, mapping.\n-            getJoinablePCSuperclassMapping(), sm, fields, fetchState, eager);\n+        FieldMapping eagerToMany = createEagerSelects(sel, mapping\n+            .getJoinablePCSuperclassMapping(), sm, fields, fetchState, eager);\n \n         FieldMapping[] fms = mapping.getDefinedFieldMappings();\n         boolean inEagerJoin = sel.hasEagerJoin(false);\n@@ -944,10 +938,9 @@ private FieldMapping createEagerSelects(Select sel, ClassMapping mapping,\n                 continue;\n \n             // try to select with join first\n-            jtype = (fms[i].getNullValue() == fms[i].NULL_EXCEPTION)\n-                ? sel.EAGER_INNER : sel.EAGER_OUTER;\n-            if (mode != fetch.EAGER_PARALLEL\n-                && !fms[i].isEagerSelectToMany()\n+            jtype = (fms[i].getNullValue() == fms[i].NULL_EXCEPTION) ? sel.EAGER_INNER\n+                : sel.EAGER_OUTER;\n+            if (mode != fetch.EAGER_PARALLEL && !fms[i].isEagerSelectToMany()\n                 && fms[i].supportsSelect(sel, jtype, sm, this, fetch) > 0\n                 && sel.eagerClone(fms[i], jtype, false, 1) != null)\n                 continue;\n@@ -959,13 +952,12 @@ private FieldMapping createEagerSelects(Select sel, ClassMapping mapping,\n             // to use a to-many join also.  currently we limit eager\n             // outer joins to non-LRS, non-ranged selects that don't already\n             // have an eager to-many join\n-            if ((hasJoin || mode == fetch.EAGER_JOIN\n-                || (mode == fetch.DEFAULT && sm != null))\n+            if ((hasJoin || mode == fetch.EAGER_JOIN || (mode == fetch.DEFAULT && sm != null))\n                 && fms[i].isEagerSelectToMany()\n-                && !inEagerJoin && !sel.hasEagerJoin(true)\n+                && !inEagerJoin\n+                && !sel.hasEagerJoin(true)\n                 && (!sel.getAutoDistinct() || (!sel.isLRS()\n-                && sel.getStartIndex() == 0\n-                && sel.getEndIndex() == Long.MAX_VALUE))\n+                    && sel.getStartIndex() == 0 && sel.getEndIndex() == Long.MAX_VALUE))\n                 && fms[i].supportsSelect(sel, jtype, sm, this, fetch) > 0) {\n                 if (sel.eagerClone(fms[i], jtype, true, 1) != null)\n                     eagerToMany = fms[i];\n@@ -974,10 +966,11 @@ private FieldMapping createEagerSelects(Select sel, ClassMapping mapping,\n             }\n \n             // finally, try parallel\n-            if (eager == fetch.EAGER_PARALLEL && (sels = fms[i].\n-                supportsSelect(sel, sel.EAGER_PARALLEL, sm, this, fetch)) != 0)\n-                sel.eagerClone(fms[i], Select.EAGER_PARALLEL,\n-                    fms[i].isEagerSelectToMany(), sels);\n+            if (eager == fetch.EAGER_PARALLEL\n+                && (sels = fms[i].supportsSelect(sel, sel.EAGER_PARALLEL, sm,\n+                    this, fetch)) != 0)\n+                sel.eagerClone(fms[i], Select.EAGER_PARALLEL, fms[i]\n+                    .isEagerSelectToMany(), sels);\n         }\n         return eagerToMany;\n     }\n@@ -986,8 +979,7 @@ private FieldMapping createEagerSelects(Select sel, ClassMapping mapping,\n      * Determine if the given field needs to be selected.\n      */\n     private static boolean requiresSelect(FieldMapping fm,\n-        OpenJPAStateManager sm,\n-        BitSet fields, JDBCFetchState fetchState) {\n+        OpenJPAStateManager sm, BitSet fields, JDBCFetchState fetchState) {\n         if (fields != null)\n             return fields.get(fm.getIndex());\n         if (sm != null && sm.getPCState() != PCState.TRANSIENT\n@@ -1018,8 +1010,8 @@ private int selectBaseMappings(Select sel, ClassMapping mapping,\n         JDBCFetchConfiguration fetch = getFetchConfiguration(fetchState);\n         ClassMapping parent = mapping.getJoinablePCSuperclassMapping();\n         if (parent == null && !mapping.isMapped())\n-            throw new InvalidStateException(_loc.get(\"virtual-mapping\",\n-                mapping.getDescribedType()));\n+            throw new InvalidStateException(_loc.get(\"virtual-mapping\", mapping\n+                .getDescribedType()));\n \n         int seld = -1;\n         int pseld = -1;\n@@ -1036,9 +1028,9 @@ private int selectBaseMappings(Select sel, ClassMapping mapping,\n             }\n \n             // if no instance or not initialized and not exact oid, select type\n-            if ((sm == null || (sm.getPCState() == PCState.TRANSIENT\n-                && (!(sm.getObjectId()instanceof OpenJPAId)\n-                || ((OpenJPAId) sm.getObjectId()).hasSubclasses())))\n+            if ((sm == null || (sm.getPCState() == PCState.TRANSIENT && (!(sm\n+                .getObjectId() instanceof OpenJPAId) || ((OpenJPAId) sm\n+                .getObjectId()).hasSubclasses())))\n                 && mapping.getDiscriminator().select(sel, orig))\n                 seld = 1;\n \n@@ -1102,13 +1094,12 @@ private int selectBaseMappings(Select sel, ClassMapping mapping,\n      * case as an optimization.\n      */\n     private boolean optSelect(FieldMapping fm, Select sel,\n-        OpenJPAStateManager sm,\n-        JDBCFetchState fetchState) {\n+        OpenJPAStateManager sm, JDBCFetchState fetchState) {\n         return !fm.isDefaultFetchGroupExplicit()\n-            && (sm == null || sm.getPCState() == PCState.TRANSIENT\n-            || !sm.getLoaded().get(fm.getIndex()))\n+            && (sm == null || sm.getPCState() == PCState.TRANSIENT || !sm\n+                .getLoaded().get(fm.getIndex()))\n             && fm.supportsSelect(sel, sel.TYPE_TWO_PART, sm, this,\n-            getFetchConfiguration(fetchState)) > 0\n+                getFetchConfiguration(fetchState)) > 0\n             && fetchState.requiresSelect(fm, true);\n     }\n \n@@ -1153,9 +1144,8 @@ private void selectSubclassMappings(Select sel, ClassMapping mapping,\n                 if (!fms[j].isInDefaultFetchGroup()\n                     && !fetch.hasFetchGroup(fms[j].getFetchGroups())\n                     && !fetch.hasField(fms[j].getFullName())\n-                    && (fms[j].isDefaultFetchGroupExplicit()\n-                    || fms[j].supportsSelect(sel, sel.TYPE_TWO_PART, sm,\n-                    this, fetch) <= 0))\n+                    && (fms[j].isDefaultFetchGroupExplicit() || fms[j]\n+                        .supportsSelect(sel, sel.TYPE_TWO_PART, sm, this, fetch) <= 0))\n                     continue;\n \n                 // if we can join to the subclass, do so; much better chance\n@@ -1164,15 +1154,14 @@ private void selectSubclassMappings(Select sel, ClassMapping mapping,\n                     // mark joined whether or not we join, so we don't have to\n                     // test conditions again for this subclass\n                     joined = true;\n-                    sel.where(joinSubclass(sel, mapping, subMappings[i],\n-                        null));\n+                    sel.where(joinSubclass(sel, mapping, subMappings[i], null));\n                 }\n \n                 // if can select with tables already selected, do it\n-                if (fms[j].supportsSelect(sel, sel.TYPE_JOINLESS, sm,\n-                    this, fetch) > 0)\n-                    fms[j].select(sel, null, this, fetchState,\n-                        fetch.EAGER_NONE);\n+                if (fms[j].supportsSelect(sel, sel.TYPE_JOINLESS, sm, this,\n+                    fetch) > 0)\n+                    fms[j]\n+                        .select(sel, null, this, fetchState, fetch.EAGER_NONE);\n             }\n         }\n     }\n@@ -1237,8 +1226,8 @@ public boolean addClassConditions(Select sel, ClassMapping mapping,\n         // join down to base class where the conditions will be added\n         ClassMapping from = mapping;\n         ClassMapping sup = mapping.getJoinablePCSuperclassMapping();\n-        for (; sup != null; from = sup,\n-            sup = from.getJoinablePCSuperclassMapping()) {\n+        for (; sup != null; from = sup, sup = from\n+            .getJoinablePCSuperclassMapping()) {\n             if (from.getTable() != sup.getTable()) {\n                 if (joins == null)\n                     joins = sel.newJoins();\n@@ -1273,23 +1262,20 @@ private void afterExecuteStatement(Statement stmnt) {\n      * Connection returned to client code. Makes sure its wrapped connection\n      * ref count is decremented on finalize.\n      */\n-    private static class ClientConnection\n-        extends DelegatingConnection {\n+    private static class ClientConnection extends DelegatingConnection {\n \n         private boolean _closed = false;\n \n         public ClientConnection(Connection conn) {\n             super(conn);\n         }\n \n-        public void close()\n-            throws SQLException {\n+        public void close() throws SQLException {\n             _closed = true;\n             super.close();\n         }\n \n-        protected void finalize()\n-            throws SQLException {\n+        protected void finalize() throws SQLException {\n             if (!_closed)\n                 close();\n         }\n@@ -1299,8 +1285,7 @@ protected void finalize()\n      * Connection wrapper that keeps an internal ref count so that it knows\n      * when to really close.\n      */\n-    private class RefCountConnection\n-        extends DelegatingConnection {\n+    private class RefCountConnection extends DelegatingConnection {\n \n         private boolean _retain = false;\n         private int _refs = 0;\n@@ -1325,8 +1310,7 @@ public void ref() {\n             _refs++;\n         }\n \n-        public void close()\n-            throws SQLException {\n+        public void close() throws SQLException {\n             // lock at broker level to avoid deadlocks\n             _ctx.lock();\n             try {\n@@ -1354,46 +1338,41 @@ public void free() {\n             _conn = null;\n         }\n \n-        protected Statement createStatement(boolean wrap)\n-            throws SQLException {\n+        protected Statement createStatement(boolean wrap) throws SQLException {\n             return new CancelStatement(super.createStatement(false),\n                 RefCountConnection.this);\n         }\n \n         protected Statement createStatement(int rsType, int rsConcur,\n-            boolean wrap)\n-            throws SQLException {\n-            return new CancelStatement(super.createStatement(rsType,\n-                rsConcur, false), RefCountConnection.this);\n+            boolean wrap) throws SQLException {\n+            return new CancelStatement(super.createStatement(rsType, rsConcur,\n+                false), RefCountConnection.this);\n         }\n \n         protected PreparedStatement prepareStatement(String sql, boolean wrap)\n             throws SQLException {\n-            return new CancelPreparedStatement(super.prepareStatement\n-                (sql, false), RefCountConnection.this);\n+            return new CancelPreparedStatement(super.prepareStatement(sql,\n+                false), RefCountConnection.this);\n         }\n \n         protected PreparedStatement prepareStatement(String sql, int rsType,\n-            int rsConcur, boolean wrap)\n-            throws SQLException {\n-            return new CancelPreparedStatement(super.prepareStatement\n-                (sql, rsType, rsConcur, false), RefCountConnection.this);\n+            int rsConcur, boolean wrap) throws SQLException {\n+            return new CancelPreparedStatement(super.prepareStatement(sql,\n+                rsType, rsConcur, false), RefCountConnection.this);\n         }\n     }\n \n     /**\n      * Statement type that adds and removes itself from the set of active\n      * statements so that it can be canceled.\n      */\n-    private class CancelStatement\n-        extends DelegatingStatement {\n+    private class CancelStatement extends DelegatingStatement {\n \n         public CancelStatement(Statement stmnt, Connection conn) {\n             super(stmnt, conn);\n         }\n \n-        public int executeUpdate(String sql)\n-            throws SQLException {\n+        public int executeUpdate(String sql) throws SQLException {\n             beforeExecuteStatement(this);\n             try {\n                 return super.executeUpdate(sql);\n@@ -1417,16 +1396,13 @@ protected ResultSet executeQuery(String sql, boolean wrap)\n      * Statement type that adds and removes itself from the set of active\n      * statements so that it can be canceled.\n      */\n-    private class CancelPreparedStatement\n-        extends DelegatingPreparedStatement {\n+    private class CancelPreparedStatement extends DelegatingPreparedStatement {\n \n-        public CancelPreparedStatement(PreparedStatement stmnt,\n-            Connection conn) {\n+        public CancelPreparedStatement(PreparedStatement stmnt, Connection conn) {\n             super(stmnt, conn);\n         }\n \n-        public int executeUpdate()\n-            throws SQLException {\n+        public int executeUpdate() throws SQLException {\n             beforeExecuteStatement(this);\n             try {\n                 return super.executeUpdate();\n@@ -1435,8 +1411,7 @@ public int executeUpdate()\n             }\n         }\n \n-        protected ResultSet executeQuery(boolean wrap)\n-            throws SQLException {\n+        protected ResultSet executeQuery(boolean wrap) throws SQLException {\n             beforeExecuteStatement(this);\n             try {\n                 return super.executeQuery(wrap);\n@@ -1445,8 +1420,7 @@ protected ResultSet executeQuery(boolean wrap)\n             }\n         }\n \n-        public int[] executeBatch()\n-            throws SQLException {\n+        public int[] executeBatch() throws SQLException {\n             beforeExecuteStatement(this);\n             try {\n                 return super.executeBatch();"},{"sha":"e5944be8e5e1db1e009b9a526540aa699697ad43","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","status":"modified","additions":51,"deletions":52,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java?ref=a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503","patch":"@@ -65,7 +65,7 @@\n  * @author Abe White\n  * @nojavadoc\n  */\n-public class JDBCStoreQuery\n+public class JDBCStoreQuery \n     extends ExpressionStoreQuery {\n \n     private static final Table INVALID = new Table();\n@@ -107,19 +107,19 @@ public FilterListener getFilterListener(String tag) {\n     }\n \n     public Object newCompilationKey() {\n-        JDBCFetchConfiguration fetch = (JDBCFetchConfiguration)\n-            ctx.getFetchConfiguration();\n+        JDBCFetchConfiguration fetch = (JDBCFetchConfiguration) ctx\n+            .getFetchConfiguration();\n         return Numbers.valueOf(fetch.getJoinSyntax());\n     }\n \n     public boolean supportsDataStoreExecution() {\n         return true;\n     }\n \n-    protected ClassMetaData[] getIndependentExpressionCandidates\n-        (ClassMetaData meta, boolean subclasses) {\n+    protected ClassMetaData[] getIndependentExpressionCandidates(\n+        ClassMetaData meta, boolean subclasses) {\n         if (!subclasses)\n-            return new ClassMapping[]{ (ClassMapping) meta };\n+            return new ClassMapping[] { (ClassMapping) meta };\n         return ((ClassMapping) meta).getIndependentAssignableMappings();\n     }\n \n@@ -132,12 +132,12 @@ protected ResultObjectProvider executeQuery(Executor ex,\n         ExpressionFactory[] facts, QueryExpressions[] exps, Object[] params,\n         boolean lrs, long startIdx, long endIdx) {\n         if (metas.length > 1 && exps[0].aggregate)\n-            throw new UserException(Localizer.forPackage(JDBCStoreQuery.class).\n-                get(\"mult-mapping-aggregate\", Arrays.asList(metas)));\n+            throw new UserException(Localizer.forPackage(JDBCStoreQuery.class)\n+                .get(\"mult-mapping-aggregate\", Arrays.asList(metas)));\n \n         ClassMapping[] mappings = (ClassMapping[]) metas;\n-        JDBCFetchConfiguration fetch = (JDBCFetchConfiguration)\n-            ctx.getFetchConfiguration();\n+        JDBCFetchConfiguration fetch = (JDBCFetchConfiguration) ctx\n+            .getFetchConfiguration();\n         JDBCFetchState fetchState = (JDBCFetchState) fetch.newFetchState();\n         if (exps[0].fetchPaths != null) {\n             fetch.addFields(Arrays.asList(exps[0].fetchPaths));\n@@ -147,8 +147,8 @@ protected ResultObjectProvider executeQuery(Executor ex,\n         int eager = calculateEagerMode(exps[0], startIdx, endIdx);\n         int subclassMode = fetch.getSubclassFetchMode((ClassMapping) base);\n         DBDictionary dict = _store.getDBDictionary();\n-        long start = (mappings.length == 1 && dict.supportsSelectStartIndex)\n-            ? startIdx : 0L;\n+        long start = (mappings.length == 1 && dict.supportsSelectStartIndex) ? startIdx\n+            : 0L;\n         long end = (dict.supportsSelectEndIndex) ? endIdx : Long.MAX_VALUE;\n \n         // add selects with populate WHERE conditions to list\n@@ -157,24 +157,25 @@ protected ResultObjectProvider executeQuery(Executor ex,\n         BitSet subclassBits = new BitSet();\n         BitSet nextBits = new BitSet();\n         boolean unionable = createWhereSelects(sels, mappings, selMappings,\n-            subclasses, subclassBits, nextBits, facts, exps, params, fetchState,\n-            subclassMode)\n+            subclasses, subclassBits, nextBits, facts, exps, params,\n+            fetchState, subclassMode)\n             && subclassMode == JDBCFetchConfiguration.EAGER_JOIN\n-            && start == 0 && end == Long.MAX_VALUE;\n+            && start == 0\n+            && end == Long.MAX_VALUE;\n \n         // we might want to use lrs settings if we can't use the range\n         if (sels.size() > 1)\n             start = 0L;\n-        lrs = lrs || (fetch.getFetchBatchSize() >= 0\n-            && (start != startIdx || end != endIdx));\n+        lrs = lrs\n+            || (fetch.getFetchBatchSize() >= 0 && (start != startIdx || end != endIdx));\n \n         ResultObjectProvider[] rops = null;\n         ResultObjectProvider rop = null;\n         if (unionable) {\n-            Union union = _store.getSQLFactory().newUnion((Select[])\n-                sels.toArray(new Select[sels.size()]));\n-            BitSet[] paged = populateUnion(union, mappings, subclasses,\n-                facts, exps, params, fetchState, lrs, eager, start, end);\n+            Union union = _store.getSQLFactory().newUnion(\n+                (Select[]) sels.toArray(new Select[sels.size()]));\n+            BitSet[] paged = populateUnion(union, mappings, subclasses, facts,\n+                exps, params, fetchState, lrs, eager, start, end);\n             union.setLRS(lrs);\n             rop = executeUnion(union, mappings, exps, paged, fetchState);\n         } else {\n@@ -209,8 +210,8 @@ protected ResultObjectProvider executeQuery(Executor ex,\n         }\n \n         // need to fake result range?\n-        if ((rops != null && endIdx != Long.MAX_VALUE)\n-            || start != startIdx || end != endIdx)\n+        if ((rops != null && endIdx != Long.MAX_VALUE) || start != startIdx\n+            || end != endIdx)\n             rop = new RangeResultObjectProvider(rop, startIdx, endIdx);\n         return rop;\n     }\n@@ -226,6 +227,7 @@ protected ResultObjectProvider executeQuery(Executor ex,\n         final BitSet[] paged = (exps[0].projections.length > 0) ? null\n             : new BitSet[mappings.length];\n         union.select(new Union.Selector() {\n+\n             public void select(Select sel, int idx) {\n                 BitSet bits = populateSelect(sel, mappings[idx], subclasses,\n                     (JDBCExpressionFactory) facts[idx], exps[idx], params,\n@@ -267,8 +269,8 @@ private ResultObjectProvider executeUnion(Union union,\n         ClassMapping[] mappings, QueryExpressions[] exps, BitSet[] paged,\n         JDBCFetchState fetchState) {\n         if (exps[0].projections.length > 0)\n-            return new ProjectionResultObjectProvider(union, _store, fetchState,\n-                exps);\n+            return new ProjectionResultObjectProvider(union, _store,\n+                fetchState, exps);\n \n         if (paged != null)\n             for (int i = 0; i < paged.length; i++)\n@@ -341,11 +343,11 @@ private boolean createWhereSelects(List sels, ClassMapping[] mappings,\n     private ClassMapping[] getVerticalMappings(ClassMapping mapping,\n         boolean subclasses, QueryExpressions exps, int subclassMode) {\n         if (!subclasses || exps.projections.length > 0)\n-            return new ClassMapping[]{ mapping };\n+            return new ClassMapping[] { mapping };\n \n         if (subclassMode != JDBCFetchConfiguration.EAGER_PARALLEL\n             || !hasVerticalSubclasses(mapping))\n-            return new ClassMapping[]{ mapping };\n+            return new ClassMapping[] { mapping };\n \n         List subs = new ArrayList(4);\n         addSubclasses(mapping, subs);\n@@ -382,7 +384,7 @@ private void addSubclasses(ClassMapping mapping, Collection subs) {\n     private static boolean hasVerticalSubclasses(ClassMapping mapping) {\n         ClassMapping[] subs = mapping.getJoinablePCSubclassMappings();\n         for (int i = 0; i < subs.length; i++)\n-            if (subs[i].getStrategy()instanceof VerticalClassStrategy)\n+            if (subs[i].getStrategy() instanceof VerticalClassStrategy)\n                 return true;\n         return false;\n     }\n@@ -405,15 +407,15 @@ private int calculateEagerMode(QueryExpressions exps, long startIdx,\n     protected Number executeDelete(Executor ex, ClassMetaData base,\n         ClassMetaData[] metas, boolean subclasses, ExpressionFactory[] facts,\n         QueryExpressions[] exps, Object[] params) {\n-        return executeBulkOperation(ex, base, metas, subclasses, facts,\n-            exps, params, null);\n+        return executeBulkOperation(ex, base, metas, subclasses, facts, exps,\n+            params, null);\n     }\n \n     protected Number executeUpdate(Executor ex, ClassMetaData base,\n         ClassMetaData[] metas, boolean subclasses, ExpressionFactory[] facts,\n         QueryExpressions[] exps, Object[] params) {\n-        return executeBulkOperation(ex, base, metas, subclasses, facts,\n-            exps, params, exps[0].updates);\n+        return executeBulkOperation(ex, base, metas, subclasses, facts, exps,\n+            params, exps[0].updates);\n     }\n \n     private Number executeBulkOperation(Executor ex, ClassMetaData base,\n@@ -430,15 +432,15 @@ private Number executeBulkOperation(Executor ex, ClassMetaData base,\n             if (!isUpdate) {\n                 // if there are any delete callbacks, we need to\n                 // execute in-memory so the callbacks are invoked\n-                LifecycleEventManager mgr = ctx.getStoreContext().getBroker().\n-                    getLifecycleEventManager();\n+                LifecycleEventManager mgr = ctx.getStoreContext().getBroker()\n+                    .getLifecycleEventManager();\n                 if (mgr.hasDeleteListeners(null, mappings[i]))\n                     return null;\n             }\n         }\n \n-        JDBCFetchConfiguration fetch = (JDBCFetchConfiguration)\n-            ctx.getFetchConfiguration();\n+        JDBCFetchConfiguration fetch = (JDBCFetchConfiguration) ctx\n+            .getFetchConfiguration();\n         DBDictionary dict = _store.getDBDictionary();\n \n         SQLBuffer[] sql = new SQLBuffer[mappings.length];\n@@ -448,8 +450,8 @@ private Number executeBulkOperation(Executor ex, ClassMetaData base,\n             jdbcFactory = (JDBCExpressionFactory) facts[i];\n             JDBCFetchState fetchState = (JDBCFetchState) fetch.newFetchState();\n             sel = jdbcFactory.evaluate(this, fetchState, exps[i], params);\n-            jdbcFactory.select(this, mappings[i], subclasses, sel,\n-                exps[i], params, fetchState, JDBCFetchConfiguration.EAGER_NONE);\n+            jdbcFactory.select(this, mappings[i], subclasses, sel, exps[i],\n+                params, fetchState, JDBCFetchConfiguration.EAGER_NONE);\n \n             // specification of the \"udpates\" map indicates that this is\n             // an update query; otherwise, this is a delete statement\n@@ -487,8 +489,7 @@ private Number executeBulkOperation(Executor ex, ClassMetaData base,\n                         }\n                 }\n             }\n-        }\n-        catch (SQLException se) {\n+        } catch (SQLException se) {\n             throw SQLExceptions.getStore(se, ctx, _store.getDBDictionary());\n         } finally {\n             try {\n@@ -577,8 +578,8 @@ protected Number executeUpdate(ClassMetaData base, ClassMetaData[] metas,\n         ClassMetaData[] metas, boolean subclasses, ExpressionFactory[] facts,\n         QueryExpressions[] exps, Object[] params, long startIdx, long endIdx) {\n         ClassMapping[] mappings = (ClassMapping[]) metas;\n-        JDBCFetchConfiguration fetch = (JDBCFetchConfiguration)\n-            ctx.getFetchConfiguration();\n+        JDBCFetchConfiguration fetch = (JDBCFetchConfiguration) ctx\n+            .getFetchConfiguration();\n         JDBCFetchState fetchState = (JDBCFetchState) fetch.newFetchState();\n         if (exps[0].fetchPaths != null) {\n             fetch.addFields(Arrays.asList(exps[0].fetchPaths));\n@@ -589,8 +590,8 @@ protected Number executeUpdate(ClassMetaData base, ClassMetaData[] metas,\n         eager = Math.min(eager, JDBCFetchConfiguration.EAGER_JOIN);\n         int subclassMode = fetch.getSubclassFetchMode((ClassMapping) base);\n         DBDictionary dict = _store.getDBDictionary();\n-        long start = (mappings.length == 1 && dict.supportsSelectStartIndex)\n-            ? startIdx : 0L;\n+        long start = (mappings.length == 1 && dict.supportsSelectStartIndex) ? startIdx\n+            : 0L;\n         long end = (dict.supportsSelectEndIndex) ? endIdx : Long.MAX_VALUE;\n \n         // add selects with populate WHERE conditions to list\n@@ -599,20 +600,19 @@ protected Number executeUpdate(ClassMetaData base, ClassMetaData[] metas,\n         BitSet subclassBits = new BitSet();\n         BitSet nextBits = new BitSet();\n         boolean unionable = createWhereSelects(sels, mappings, selMappings,\n-            subclasses, subclassBits, nextBits, facts, exps, params, fetchState,\n-            subclassMode)\n+            subclasses, subclassBits, nextBits, facts, exps, params,\n+            fetchState, subclassMode)\n             && subclassMode == JDBCFetchConfiguration.EAGER_JOIN;\n         if (sels.size() > 1)\n             start = 0L;\n \n         if (unionable) {\n-            Union union = _store.getSQLFactory().newUnion((Select[])\n-                sels.toArray(new Select[sels.size()]));\n+            Union union = _store.getSQLFactory().newUnion(\n+                (Select[]) sels.toArray(new Select[sels.size()]));\n             populateUnion(union, mappings, subclasses, facts, exps, params,\n                 fetchState, false, eager, start, end);\n             if (union.isUnion())\n-                return new String[]{ union.toSelect(false, fetch).\n-                    getSQL(true) };\n+                return new String[] { union.toSelect(false, fetch).getSQL(true) };\n             sels = Arrays.asList(union.getSelects());\n         } else {\n             Select sel;\n@@ -628,8 +628,7 @@ protected Number executeUpdate(ClassMetaData base, ClassMetaData[] metas,\n \n         String[] sql = new String[sels.size()];\n         for (int i = 0; i < sels.size(); i++)\n-            sql[i] = ((Select) sels.get(i)).toSelect(false, fetch).\n-                getSQL(true);\n+            sql[i] = ((Select) sels.get(i)).toSelect(false, fetch).getSQL(true);\n         return sql;\n     }\n }"},{"sha":"de5ddeccabc9e61d6d9ce826ad23afd495961a3e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManagerImpl.java","status":"modified","additions":10,"deletions":12,"changes":22,"blob_url":"https://github.com/apache/openjpa/blob/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManagerImpl.java?ref=a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503","patch":"@@ -37,11 +37,11 @@\n  *\n  * @author Abe White\n  */\n-class PreparedStatementManagerImpl\n+class PreparedStatementManagerImpl \n     implements PreparedStatementManager {\n \n-    private final static Localizer _loc = Localizer.forPackage\n-        (PreparedStatementManagerImpl.class);\n+    private final static Localizer _loc = Localizer\n+        .forPackage(PreparedStatementManagerImpl.class);\n \n     private final JDBCStore _store;\n     private final Connection _conn;\n@@ -76,8 +76,7 @@ public void flush(RowImpl row) {\n     /**\n      * Flush the given row.\n      */\n-    private void flushInternal(RowImpl row)\n-        throws SQLException {\n+    private void flushInternal(RowImpl row) throws SQLException {\n         // can't batch rows with auto-inc columns\n         Column[] autoAssign = null;\n         if (row.getAction() == Row.ACTION_INSERT)\n@@ -96,12 +95,11 @@ private void flushInternal(RowImpl row)\n                 if (failed != null)\n                     _exceptions.add(new OptimisticException(failed));\n                 else if (row.getAction() == Row.ACTION_INSERT)\n-                    throw new SQLException(_loc.get\n-                        (\"update-failed-no-failed-obj\", String.valueOf(count),\n-                            sql));\n+                    throw new SQLException(_loc.get(\n+                        \"update-failed-no-failed-obj\", String.valueOf(count),\n+                        sql));\n             }\n-        }\n-        catch (SQLException se) {\n+        } catch (SQLException se) {\n             throw SQLExceptions.getStore(se, row.getFailedObject(), _dict);\n         } finally {\n             try {\n@@ -118,8 +116,8 @@ else if (row.getAction() == Row.ACTION_INSERT)\n             Object val;\n             for (int i = 0; i < autoAssign.length; i++) {\n                 val = _dict.getGeneratedKey(autoAssign[i], _conn);\n-                mapping.assertJoinable(autoAssign[i]).setAutoAssignedValue\n-                    (sm, _store, autoAssign[i], val);\n+                mapping.assertJoinable(autoAssign[i]).setAutoAssignedValue(sm,\n+                    _store, autoAssign[i], val);\n             }\n         }\n     }"},{"sha":"cff4b1c2229e17ab4f9dfc62bb5bdde702568c64","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","status":"modified","additions":4,"deletions":8,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java?ref=a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503","patch":"@@ -166,8 +166,7 @@ public void run(TestResult result) {\n         _watchdog.enteringTest(this);\r\n         try {\r\n             super.run(result);\r\n-        }\r\n-        finally {\r\n+        } finally {\r\n             _watchdog.leavingTest(this);\r\n         }\r\n     }\r\n@@ -530,8 +529,7 @@ public void run() throws Exception {\n                     meth.invoke(thiz, args);\r\n                 }\r\n             });\r\n-        }\r\n-        finally {\r\n+        } finally {\r\n             multiThreadExecuting = null;\r\n         }\r\n     }\r\n@@ -806,8 +804,7 @@ public void run() {\n                         method.invoke(thz, (Object[]) null);\r\n                     } catch (Throwable t) {\r\n                         throwable = t;\r\n-                    }\r\n-                    finally {\r\n+                    } finally {\r\n                         completed = true;\r\n                     }\r\n                 }\r\n@@ -846,8 +843,7 @@ public void run() {\n \r\n             // I guess everything was OK\r\n             return true;\r\n-        }\r\n-        finally {\r\n+        } finally {\r\n             inTimeoutThread = false;\r\n         }\r\n     }\r"},{"sha":"964030c2e5251f9f4862a5c64c2c20751de5277e","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java?ref=a1f4fd3eb0c3e7e80f73c1a06bc0cb7c29249503","patch":"@@ -1074,8 +1074,7 @@ private FieldMetaData parseField(Attributes attrs)\n                     member = meta.getDescribedType().getDeclaredField(name);\n                     type = ((Field) member).getType();\n                 }\n-            }\n-            catch (Exception e) {\n+            } catch (Exception e) {\n                 throw getException(_loc.get(\"invalid-attr\", name, meta), e);\n             }\n "}]}

