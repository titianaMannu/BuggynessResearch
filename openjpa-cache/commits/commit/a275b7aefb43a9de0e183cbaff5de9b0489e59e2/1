{"sha":"a275b7aefb43a9de0e183cbaff5de9b0489e59e2","node_id":"MDY6Q29tbWl0MjA2MzY0OmEyNzViN2FlZmI0M2E5ZGUwZTE4M2NiYWZmNWRlOWIwNDg5ZTU5ZTI=","commit":{"author":{"name":"David J. Wisneski","email":"wisneskid@apache.org","date":"2007-07-19T00:45:51Z"},"committer":{"name":"David J. Wisneski","email":"wisneskid@apache.org","date":"2007-07-19T00:45:51Z"},"message":"OPENJPA-240  XMLMapping Query support for persistent field maps to XML column.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@557437 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"de7ec6c0d1e33c1bba79ddb5f4085e299372b8eb","url":"https://api.github.com/repos/apache/openjpa/git/trees/de7ec6c0d1e33c1bba79ddb5f4085e299372b8eb"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/a275b7aefb43a9de0e183cbaff5de9b0489e59e2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/a275b7aefb43a9de0e183cbaff5de9b0489e59e2","html_url":"https://github.com/apache/openjpa/commit/a275b7aefb43a9de0e183cbaff5de9b0489e59e2","comments_url":"https://api.github.com/repos/apache/openjpa/commits/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/comments","author":null,"committer":null,"parents":[{"sha":"25fbdab82bfa714ed3fded62d7322b0603fb6656","url":"https://api.github.com/repos/apache/openjpa/commits/25fbdab82bfa714ed3fded62d7322b0603fb6656","html_url":"https://github.com/apache/openjpa/commit/25fbdab82bfa714ed3fded62d7322b0603fb6656"}],"stats":{"total":1086,"additions":1080,"deletions":6},"files":[{"sha":"6352505bdb5d0595d97e507e55625568e6645263","filename":"openjpa-jdbc-5/src/main/java/org/apache/openjpa/jdbc/meta/XMLMappingRepository.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc-5/src/main/java/org/apache/openjpa/jdbc/meta/XMLMappingRepository.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc-5/src/main/java/org/apache/openjpa/jdbc/meta/XMLMappingRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc-5/src/main/java/org/apache/openjpa/jdbc/meta/XMLMappingRepository.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -0,0 +1,82 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.jdbc.meta;\r\n+\r\n+import java.util.HashMap;\r\n+import java.util.Map;\r\n+\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.XMLClassMetaData;\r\n+import org.apache.openjpa.meta.XMLMapping;\r\n+\r\n+/**\r\n+ * Repository of object/relational mapping information.\r\n+ *  (extended to include XML mapping metadata for XML columns)\r\n+ *  \r\n+ * @author Catalina Wei\r\n+ * @since 1.0.0\r\n+ */\r\n+public class XMLMappingRepository extends MappingRepository {\r\n+    // xml mapping\r\n+    protected final XMLMapping[] EMPTY_XMLMETAS;\r\n+    private final Map _xmlmetas = new HashMap();\r\n+\r\n+    public XMLMappingRepository() {\r\n+        super();\r\n+        EMPTY_XMLMETAS = newXMLClassMetaDataArray(0);\r\n+    }\r\n+    \r\n+    public synchronized XMLClassMetaData addXMLClassMetaData(FieldMetaData fmd, \r\n+        String name) {        \r\n+        XMLClassMetaData meta = newXMLClassMetaData(fmd, name);\r\n+        addXMLClassMetaData(fmd.getDeclaredType(), meta);\r\n+        return meta;\r\n+    }\r\n+    \r\n+    public XMLMapping getXMLClassMetaData(Class cls) {\r\n+        synchronized(_xmlmetas) {\r\n+            if (_xmlmetas.isEmpty())\r\n+                return null;\r\n+            else\r\n+                return (XMLClassMetaData) _xmlmetas.get(cls);\r\n+        }\r\n+    }\r\n+    \r\n+    public XMLMapping getXMLMetaData(FieldMetaData fmd) {\r\n+        XMLMapping xmlmeta = null;\r\n+        if (XMLClassMetaData.isXMLMapping(fmd.getDeclaredType())) {\r\n+            xmlmeta = getXMLClassMetaData(fmd.getDeclaredType());\r\n+            if (xmlmeta == null)\r\n+                xmlmeta = addXMLClassMetaData(fmd, fmd.getName());\r\n+        }\r\n+        return xmlmeta;\r\n+    }\r\n+    \r\n+    public synchronized void addXMLClassMetaData(Class cls, XMLMapping meta) {\r\n+        _xmlmetas.put(cls, meta);\r\n+    }    \r\n+    \r\n+    protected XMLClassMetaData newXMLClassMetaData(FieldMetaData fmd, String name) {\r\n+        return new XMLClassMetaData(fmd.getDeclaredType(), name, this);\r\n+    }\r\n+        \r\n+    protected XMLMapping[] newXMLClassMetaDataArray(int length) {\r\n+        return new XMLClassMetaData[length];\r\n+    }\r\n+}\r"},{"sha":"0037f24a1025e2e6d11d452f592f40206bca3bfe","filename":"openjpa-jdbc-5/src/main/java/org/apache/openjpa/meta/XMLClassMetaData.java","status":"added","additions":227,"deletions":0,"changes":227,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc-5/src/main/java/org/apache/openjpa/meta/XMLClassMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc-5/src/main/java/org/apache/openjpa/meta/XMLClassMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc-5/src/main/java/org/apache/openjpa/meta/XMLClassMetaData.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -0,0 +1,227 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.meta;\r\n+\r\n+import java.lang.reflect.AnnotatedElement;\r\n+import java.lang.reflect.Member;\r\n+import java.lang.reflect.Field;\r\n+import java.util.HashMap;\r\n+\r\n+import javax.xml.bind.annotation.XmlAccessType;\r\n+import javax.xml.bind.annotation.XmlAccessorType;\r\n+import javax.xml.bind.annotation.XmlAttribute;\r\n+import javax.xml.bind.annotation.XmlElement;\r\n+import javax.xml.bind.annotation.XmlRootElement;\r\n+import javax.xml.bind.annotation.XmlType;\r\n+\r\n+import org.apache.openjpa.jdbc.meta.XMLMappingRepository;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.meta.XMLMapping;\r\n+import org.apache.openjpa.meta.XMLMetaData;\r\n+import org.apache.commons.lang.StringUtils;\r\n+\r\n+/**\r\n+ * Contains metadata about a persistent field that maps to an xml column.\r\n+ * This metadata is loaded at runtime when query involves predicates\r\n+ * that navigate through xpath.\r\n+ *\r\n+ * @author Catalina Wei\r\n+ * @since 1.0.0\r\n+ */\r\n+public class XMLClassMetaData implements XMLMapping     \r\n+{\r\n+    private Class _type;\r\n+    private int _code = JavaTypes.OBJECT;\r\n+    private int _xmltype = XMLTYPE;\r\n+    private String _name = null;\r\n+    private String _xmlname = null;\r\n+    private String _xmlnamespace = null;\r\n+    private boolean _isXMLRootElement = false;\r\n+    private HashMap _fieldMap = new HashMap();\r\n+    \r\n+    /**\r\n+     * Constructor.\r\n+     * \r\n+     * @param type the class that contains XmlType annotation.\r\n+     * @name  the persistent field name that maps to xml column\r\n+     * @param repo the meta repository.\r\n+     */\r\n+    public XMLClassMetaData(Class type, String name, XMLMappingRepository repos) {\r\n+       _type = type;\r\n+       _isXMLRootElement = _type.getAnnotation(XmlRootElement.class) != null;\r\n+       if (_isXMLRootElement) {\r\n+           _xmlname = ((XmlRootElement) _type.getAnnotation\r\n+                   (XmlRootElement.class)).name();\r\n+           _xmlnamespace = ((XmlRootElement) _type.getAnnotation\r\n+                   (XmlRootElement.class)).namespace();\r\n+       }\r\n+       else {\r\n+           _xmlname = ((XmlType) _type.getAnnotation\r\n+                   (XmlType.class)).name();\r\n+           _xmlnamespace = ((XmlType) _type.getAnnotation\r\n+                   (XmlType.class)).namespace();\r\n+           _name = name;\r\n+       }\r\n+       populateFromReflection(_type, repos);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Constructor. Supply described type and repository.\r\n+     * \r\n+     * @param type the class that contains XmlType annotation.\r\n+     * @param repo the meta repository.\r\n+     */\r\n+    protected XMLClassMetaData(Class type, XMLMappingRepository repos) {\r\n+        _type = type;\r\n+        _isXMLRootElement = _type.getAnnotation(XmlRootElement.class) != null;\r\n+        if (_isXMLRootElement) {\r\n+            _xmlname = ((XmlRootElement) _type.getAnnotation\r\n+                    (XmlRootElement.class)).name();\r\n+            _xmlnamespace = ((XmlRootElement) _type.getAnnotation\r\n+                    (XmlRootElement.class)).namespace();\r\n+        }\r\n+        else {\r\n+            _xmlname = ((XmlType) _type.getAnnotation\r\n+                    (XmlType.class)).name();\r\n+            _xmlnamespace = ((XmlType) _type.getAnnotation\r\n+                    (XmlType.class)).namespace();           \r\n+        }\r\n+        populateFromReflection(_type, repos);\r\n+        repos.addXMLClassMetaData(type, this);\r\n+    }\r\n+\r\n+    /**\r\n+     * Given a class type return true if XmlType annotation exists\r\n+     * @param type\r\n+     * @return true if XmlType annotation is present else false.\r\n+     */\r\n+    public static boolean isXMLMapping(Class type) {\r\n+        return type.isAnnotationPresent(XmlType.class);\r\n+    }\r\n+    \r\n+    public void setName(String name) {\r\n+        _name = name;\r\n+    }\r\n+    \r\n+    public String getName() {\r\n+        return _name;\r\n+    }    \r\n+    \r\n+    public void setXmlname(String name) {\r\n+        _xmlname = name;\r\n+    }\r\n+    \r\n+    public String getXmlname() {\r\n+        return _isXMLRootElement ? null : _xmlname;\r\n+    }\r\n+\r\n+    public void setXmlnamespace(String name) {\r\n+        // avoid JAXB XML bind default name\r\n+        if (!StringUtils.equals(defaultName, name))\r\n+            _xmlnamespace = name;\r\n+    }\r\n+    \r\n+    public String getXmlnamespace() {\r\n+        return _xmlnamespace;\r\n+    }\r\n+\r\n+    public boolean isXmlRootElement() {\r\n+        return _isXMLRootElement;\r\n+    }\r\n+    \r\n+    public boolean isXmlElement() {\r\n+        return false;\r\n+    }\r\n+    \r\n+    public boolean isXmlAttribute() {\r\n+        return false;\r\n+    }\r\n+    \r\n+    public XMLMapping getFieldMapping(String name) {\r\n+        return (XMLMapping) _fieldMap.get(name);\r\n+    }\r\n+    \r\n+    public void setType(Class type) {\r\n+        _type = type;\r\n+    }\r\n+    \r\n+    public Class getType() {\r\n+        return _type;\r\n+    }\r\n+    \r\n+    public int getTypeCode() {\r\n+        return _code;\r\n+    }\r\n+\r\n+    public void setXmltype(int type) {\r\n+        _xmltype = type;\r\n+    }\r\n+    public int getXmltype() {\r\n+        return _xmltype;\r\n+    }\r\n+\r\n+    private synchronized void populateFromReflection(Class cls, \r\n+        XMLMappingRepository repos) {\r\n+        Member[] members;\r\n+        if (((XmlAccessorType)cls.getAnnotation(XmlAccessorType.class)).value()\r\n+                == XmlAccessType.FIELD)\r\n+            members = cls.getDeclaredFields();\r\n+        else\r\n+            members = cls.getDeclaredMethods();\r\n+        for (int i = 0; i < members.length; i++) {\r\n+            Member member = members[i];\r\n+            AnnotatedElement el = (AnnotatedElement) member;\r\n+            XMLMapping field = null;\r\n+            if (el.getAnnotation(XmlElement.class) != null) {\r\n+                String xmlname = el.getAnnotation(XmlElement.class).name();\r\n+                // avoid JAXB XML bind default name\r\n+                if (StringUtils.equals(defaultName, xmlname))\r\n+                    xmlname = member.getName();\r\n+                if (((Field) member).getType().\r\n+                        isAnnotationPresent(XmlType.class)) {\r\n+                    field = new XMLClassMetaData(((Field) member).getType(),\r\n+                            repos);\r\n+                    field.setXmltype(XMLTYPE);\r\n+                    field.setXmlname(xmlname);\r\n+                }\r\n+                else {\r\n+                    field = new XMLMetaData();\r\n+                    field.setXmltype(ELEMENT);\r\n+                    field.setXmlname(xmlname);\r\n+                    field.setXmlnamespace(el.getAnnotation(XmlElement.class)\r\n+                            .namespace());                    \r\n+                }\r\n+            }\r\n+            else if (el.getAnnotation(XmlAttribute.class) != null) {\r\n+                field = new XMLMetaData();\r\n+                field.setXmltype(XMLMetaData.ATTRIBUTE);\r\n+                String xmlname = el.getAnnotation(XmlAttribute.class).name();\r\n+                // avoid JAXB XML bind default name\r\n+                if (StringUtils.equals(defaultName, xmlname))\r\n+                    xmlname = member.getName();\r\n+                field.setXmlname(\"@\"+xmlname);\r\n+                field.setXmlnamespace(el.getAnnotation(XmlAttribute.class)\r\n+                        .namespace());                \r\n+            }\r\n+            field.setName(member.getName());\r\n+            field.setType(((Field) member).getType());                \r\n+            _fieldMap.put(member.getName(), field);\r\n+        }        \r\n+    }\r\n+}\r"},{"sha":"7445b99ed2f86de16fa385995a7ef801c377791f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AbstractVal.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AbstractVal.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AbstractVal.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AbstractVal.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -41,6 +41,10 @@ public boolean isAggregate() {\n         return false;\n     }\n \n+    public boolean isXPath() {\n+        return false;\n+    }\n+\n     public Object toDataStoreValue(Select sel, ExpContext ctx, ExpState state, \n         Object val) {\n         return val;"},{"sha":"a9caf53c2d3f86b2017087a8669ade79a936291f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -31,6 +31,7 @@\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.XMLMapping;\n import org.apache.openjpa.util.InternalException;\n \n /**\n@@ -204,4 +205,14 @@ public ConstPathExpState(ExpState constantState) {\n             this.constantState = constantState;\n         }\n     }\n+    \n+    public void get(FieldMetaData fmd, XMLMapping meta) {\n+    }\n+\n+    public void get(XMLMapping meta, String name) {\n+    }\n+\n+    public XMLMapping getXmlMapping() {\n+        return null;\n+    }\n }"},{"sha":"76eea64131e69d6f35957d18d51d8da8cbe9c34e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EndsWithExpression.java","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EndsWithExpression.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EndsWithExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EndsWithExpression.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -28,6 +28,7 @@\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n+import org.apache.openjpa.meta.XMLMapping;\n \n /**\n  * Test if one string ends with another.\n@@ -194,5 +195,13 @@ public ClassMapping getClassMapping() {\n         public FieldMapping getFieldMapping() {\n             return null;\n         }\n+        \n+        public PCPath getXPath() {\n+            return null;\n+        }\n+        \n+        public XMLMapping getXmlMapping() {\n+            return null;\n+        }\n     }\n }"},{"sha":"a4e797edd56a28f8ae19e29458e4387d867634bd","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValue.java","status":"modified","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValue.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValue.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -23,6 +23,7 @@\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.Table;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.meta.XMLMapping;\n \n /**\n  * The simplified public view of any non-operator in a query filter,\n@@ -103,4 +104,16 @@\n      * return null.\n      */\n     public FieldMapping getFieldMapping();\n+    \n+    /**\n+     * If this is an XPath, return it,\n+     * else return null;\n+     */\n+    public PCPath getXPath();\n+    \n+    /**\n+     * If this is an XPath, return XML mapping metadata,\n+     * else return null;\n+     */\n+    public XMLMapping getXmlMapping();\n }"},{"sha":"bdc84db9e134e2cd092918d5478ea2d6208bbecf","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValueImpl.java","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValueImpl.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValueImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValueImpl.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -24,6 +24,7 @@\n import org.apache.openjpa.jdbc.schema.Table;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.meta.XMLMapping;\n \n /**\n  * Implementation of {@link FilterValue} that wraps a {@link Val}.\n@@ -98,4 +99,15 @@ public ClassMapping getClassMapping() {\n     public FieldMapping getFieldMapping() {\n         return (isPath()) ? ((PCPath) _val).getFieldMapping(_state) : null;\n     }\n+    \n+    public PCPath getXPath() {\n+        if (isPath() && ((PCPath) _val).isXPath())\n+            return (PCPath) _val;\n+        else\n+            return null;\n+    }\n+    \n+    public XMLMapping getXmlMapping() {\n+        return (getXPath() == null) ? null : getXPath().getXmlMapping();\n+    }\n }"},{"sha":"47f721aefcfee331ff4839c24a8ecf7efc1dadf4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","status":"modified","additions":86,"deletions":3,"changes":89,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -40,6 +40,7 @@\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.XMLMapping;\n import org.apache.openjpa.util.UserException;\n \n /**\n@@ -55,6 +56,7 @@\n     private static final int BOUND_VAR = 1;\n     private static final int UNBOUND_VAR = 2;\n     private static final int UNACCESSED_VAR = 3;\n+    private static final int XPATH = 4;\n \n     private static final Localizer _loc = Localizer.forPackage(PCPath.class);\n \n@@ -66,6 +68,7 @@\n     private String _varName = null;\n     private Class _cast = null;\n     private boolean _cid = false;\n+    private FieldMetaData _xmlfield = null;\n \n     /**\n      * Return a path starting with the 'this' ptr.\n@@ -168,7 +171,40 @@ public void setMetaData(ClassMetaData meta) {\n     public boolean isKey() {\n         return _key;\n     }\n-\n+    \n+    public boolean isXPath() {\n+        return _type == XPATH;\n+    }\n+    \n+    public String getXPath() {\n+        StringBuffer xpath = new StringBuffer();\n+        Action action;\n+        Iterator itr = _actions.iterator();\n+        \n+        // Skip variable actions since they are not part of the xpath\n+        // until we reach the first xpath action.\n+        // The first xpath action maps to the root of an xml document.\n+        do \n+            action = (Action) itr.next(); \n+        while (action.op != Action.GET_XPATH);\n+        \n+        // Skip XmlRootElement:\n+        // We can't rely on the accuracy of the name of the root element,\n+        // because it could be set to some default by JAXB XML Binding.\n+        // The caller(DBDictionary) should start with \"/*\" or \"/*/\",\n+        // we build the remaining xpath that follows the root element.\n+        while (itr.hasNext()) {\n+            action = (Action) itr.next();\n+            if (((XMLMapping) action.data).getXmlname() != null)                 \n+                xpath.append(((XMLMapping) action.data).getXmlname());\n+            else\n+                xpath.append(\"*\");\n+            if (itr.hasNext())\n+                xpath.append(\"/\");\n+        }\n+        return xpath.toString();\n+    }\n+    \n     public String getPath() {\n         if (_actions == null)\n             return (_varName == null) ? \"\" : _varName + \".\";\n@@ -274,6 +310,36 @@ public void get(FieldMetaData field, boolean nullTraversal) {\n         _cast = null;\n         _key = false;\n     }\n+    \n+    public void get(FieldMetaData fmd, XMLMapping meta) {\n+        if (_actions == null)\n+            _actions = new LinkedList();\n+        Action action = new Action();\n+        action.op = Action.GET_XPATH;\n+        action.data = meta;\n+        _actions.add(action);\n+        _cast = null;\n+        _key = false;;\n+        _type = XPATH;\n+        _xmlfield = fmd;\n+    }\n+    \n+    public void get(XMLMapping meta, String name) {\n+        Action action = new Action();\n+        action.op = Action.GET_XPATH;\n+        action.data = meta.getFieldMapping(name);\n+        _actions.add(action);\n+        _cast = null;\n+        _key = false;;\n+        _type = XPATH;\n+    }\n+    \n+    public XMLMapping getXmlMapping() {\n+        Action act = (Action) _actions.getLast();\n+        if (act != null)\n+            return (XMLMapping) act.data;\n+        return null;\n+    }\n \n     public synchronized void getKey() {\n         if (_cid)\n@@ -288,7 +354,8 @@ public synchronized void getKey() {\n \n     public FieldMetaData last() {\n         Action act = lastFieldAction();\n-        return (act == null) ? null : (FieldMetaData) act.data;\n+        return (act == null) ? null : isXPath() ? _xmlfield :\n+            (FieldMetaData) act.data;\n     }\n \n     /**\n@@ -298,6 +365,9 @@ private Action lastFieldAction() {\n         if (_actions == null)\n             return null;\n \n+        if (isXPath())\n+            return (Action) _actions.getLast();\n+        \n         ListIterator itr = _actions.listIterator(_actions.size());\n         Action prev;\n         while (itr.hasPrevious()) {\n@@ -313,6 +383,9 @@ public Class getType() {\n         if (_cast != null)\n             return _cast;\n         Action act = lastFieldAction();\n+        if (act != null && act.op == Action.GET_XPATH)\n+            return ((XMLMapping) act.data).getType();\n+        \n         FieldMetaData fld = (act == null) ? null : (FieldMetaData) act.data;\n         boolean key = act != null && act.op == Action.GET_KEY;\n         if (fld != null) {\n@@ -373,7 +446,8 @@ else if (action.op == Action.UNBOUND_VAR) {\n                     rel.getTable());\n             } else {\n                 // move past the previous field, if any\n-                field = (FieldMapping) action.data;\n+                field = (action.op == Action.GET_XPATH) ? (FieldMapping) _xmlfield :\n+                    (FieldMapping) action.data;\n                 if (pstate.field != null) {\n                     // if this is the second-to-last field and the last is\n                     // the related field this field joins to, no need to\n@@ -416,6 +490,9 @@ else if (action.op == Action.UNBOUND_VAR) {\n                         from = from.getJoinablePCSuperclassMapping())\n                         pstate.joins = from.joinSuperclass(pstate.joins, false);\n                 }\n+                // nothing more to do from here on as we encountered an xpath action\n+                if (action.op == Action.GET_XPATH)\n+                    break;\n             }\n         }\n         if (_varName != null)\n@@ -534,6 +611,8 @@ public Object toDataStoreValue(Select sel, ExpContext ctx, ExpState state,\n         PathExpState pstate = (PathExpState) state;\n         FieldMapping field = (pstate.cmpfield != null) ? pstate.cmpfield \n             : pstate.field;\n+        if (isXPath())\n+            return val;\n         if (field != null) {\n             if (_key)\n                 return field.toKeyDataStoreValue(val, ctx.store);\n@@ -639,6 +718,9 @@ public void appendTo(Select sel, ExpContext ctx, ExpState state,\n         // (e.g., during a bulk update)\n         if (sel == null)\n             sql.append(col.getName());\n+        else if (_type == XPATH)\n+            // if this is an xpath, append xpath string\n+            sql.append(getXPath());\n         else\n             sql.append(sel.getColumnAlias(col, state.joins));\n     }\n@@ -716,6 +798,7 @@ public boolean equals(Object other) {\n         public static final int SUBQUERY = 4;\n         public static final int UNBOUND_VAR = 5;\n         public static final int CAST = 6;\n+        public static final int GET_XPATH = 7;\n \n         public int op = -1;\n         public Object data = null;"},{"sha":"bde553c96370db57a4a61e1ca42b7a54c75a2664","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StartsWithExpression.java","status":"modified","additions":18,"deletions":0,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StartsWithExpression.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StartsWithExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StartsWithExpression.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -28,6 +28,7 @@\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n+import org.apache.openjpa.meta.XMLMapping;\n import serp.util.Numbers;\n \n /**\n@@ -184,6 +185,15 @@ public ClassMapping getClassMapping() {\n         public FieldMapping getFieldMapping() {\n             return null;\n         }\n+        \n+        public PCPath getXPath() {\n+            return null;\n+        }\n+        \n+        public XMLMapping getXmlMapping() {\n+            return null;\n+        }\n+\n     }\n \n     /**\n@@ -260,5 +270,13 @@ public ClassMapping getClassMapping() {\n         public FieldMapping getFieldMapping() {\n             return null;\n         }\n+        \n+        public PCPath getXPath() {\n+            return null;\n+        }\n+        \n+        public XMLMapping getXmlMapping() {\n+            return null;\n+        }\n     }\n }"},{"sha":"f78f983e01ba7049e2ed0da476ebfdd59b3cd77f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","status":"modified","additions":120,"deletions":0,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -22,13 +22,17 @@\n import java.sql.Connection;\r\n import java.sql.DatabaseMetaData;\r\n import java.sql.SQLException;\r\n+import java.sql.Types;\r\n import java.util.Arrays;\r\n import java.util.StringTokenizer;\r\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\r\n import org.apache.openjpa.jdbc.schema.Sequence;\r\n import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n import org.apache.openjpa.util.OpenJPAException;\r\n import org.apache.openjpa.util.UnsupportedException;\r\n+import org.apache.openjpa.kernel.Filters;\r\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\r\n \r\n /**\r\n  * Dictionary for IBM DB2 database.\r\n@@ -492,4 +496,120 @@ private String appendExtendedExceptionMsg(String msg, SQLException sqle){\n     public int getDb2ServerType() {\r\n         return db2ServerType;\r\n     }\r\n+    \r\n+    protected void appendLength(SQLBuffer buf, int type) {\r\n+        if (type == Types.VARCHAR)\r\n+            buf.append(\"(\").append(Integer.toString(characterColumnSize)).\r\n+                append(\")\");\r\n+    }\r\n+\r\n+    /**\r\n+     * If this dictionary supports XML type,\r\n+     * use this method to append xml predicate.\r\n+     * \r\n+     * @param buf the SQL buffer to write the comparison\r\n+     * @param op the comparison operation to perform\r\n+     * @param lhs the left hand side of the comparison\r\n+     * @param rhs the right hand side of the comparison\r\n+     * @param lhsxml indicates whether the left operand maps to xml\r\n+     * @param rhsxml indicates whether the right operand maps to xml\r\n+     */\r\n+    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\r\n+        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\r\n+        super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\r\n+        if (lhsxml && rhsxml)\r\n+            appendXmlComparison2(buf, op, lhs, rhs);\r\n+        else if (lhsxml)\r\n+            appendXmlComparison1(buf, op, lhs, rhs);\r\n+        else \r\n+            appendXmlComparison1(buf, op, rhs, lhs);\r\n+    }\r\n+\r\n+    /**\r\n+     * Append an xml comparison predicate.\r\n+     *\r\n+     * @param buf the SQL buffer to write the comparison\r\n+     * @param op the comparison operation to perform\r\n+     * @param lhs the left hand side of the comparison (maps to xml column)\r\n+     * @param rhs the right hand side of the comparison\r\n+     */\r\n+    private void appendXmlComparison1(SQLBuffer buf, String op, \r\n+            FilterValue lhs, FilterValue rhs) {\r\n+        boolean castrhs = false;\r\n+        Class rc = Filters.wrap(rhs.getType());\r\n+        int type = 0;\r\n+        if (rhs.isConstant()) {\r\n+            type = getJDBCType(JavaTypes.getTypeCode(rc), false);\r\n+            castrhs = true;\r\n+        }\r\n+        \r\n+        appendXmlExists(buf, lhs);\r\n+\r\n+        buf.append(\" \").append(op).append(\" \");\r\n+        \r\n+        buf.append(\"$\");\r\n+        if (castrhs)\r\n+            buf.append(\"Parm\");\r\n+        else\r\n+            rhs.appendTo(buf);\r\n+        \r\n+        buf.append(\"]' PASSING \");\r\n+        appendXmlVar(buf, lhs);\r\n+        buf.append(\", \");\r\n+        \r\n+        if (castrhs)\r\n+            appendCast(buf, rhs, type);\r\n+        else\r\n+            rhs.appendTo(buf);\r\n+        \r\n+        buf.append(\" AS \\\"\");\r\n+        if (castrhs)\r\n+            buf.append(\"Parm\");\r\n+        else\r\n+            rhs.appendTo(buf);\r\n+        buf.append(\"\\\")\");\r\n+    }\r\n+    \r\n+    /**\r\n+     * Append an xml comparison predicate. (both operands map to xml column)\r\n+     *\r\n+     * @param buf the SQL buffer to write the comparison\r\n+     * @param op the comparison operation to perform\r\n+     * @param lhs the left hand side of the comparison (maps to xml column)\r\n+     * @param rhs the right hand side of the comparison (maps to xml column)\r\n+     */\r\n+    private void appendXmlComparison2(SQLBuffer buf, String op, \r\n+            FilterValue lhs, FilterValue rhs) {\r\n+        appendXmlExists(buf, lhs);\r\n+        \r\n+        buf.append(\" \").append(op).append(\" \");\r\n+        \r\n+        buf.append(\"$\").append(rhs.getColumnAlias(\r\n+            rhs.getFieldMapping().getColumns()[0])).\r\n+            append(\"/*/\");\r\n+        rhs.appendTo(buf);\r\n+        \r\n+        buf.append(\"]' PASSING \");\r\n+        appendXmlVar(buf, lhs);\r\n+        buf.append(\", \");\r\n+        appendXmlVar(buf, rhs);\r\n+        buf.append(\")\");\r\n+    }\r\n+    \r\n+    private void appendXmlVar(SQLBuffer buf, FilterValue val) {\r\n+        buf.append(val.getColumnAlias(\r\n+            val.getFieldMapping().getColumns()[0])).\r\n+            append(\" AS \").\r\n+            append(\"\\\"\").append(val.getColumnAlias(\r\n+            val.getFieldMapping().getColumns()[0])).\r\n+            append(\"\\\"\");        \r\n+    }\r\n+    \r\n+    private void appendXmlExists(SQLBuffer buf, FilterValue val) {\r\n+        buf.append(\"XMLEXISTS('\");\r\n+        buf.append(\"$\").append(val.getColumnAlias(\r\n+            val.getFieldMapping().getColumns()[0])).\r\n+            append(\"/*[\");\r\n+        val.appendTo(buf);        \r\n+    }\r\n }\r"},{"sha":"fb8b9688e02ab736c7fcb3abcbc727e7de11c3b0","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","status":"modified","additions":20,"deletions":0,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -84,6 +84,7 @@\n import org.apache.openjpa.jdbc.schema.Table;\n import org.apache.openjpa.jdbc.schema.Unique;\n import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.exps.Path;\n import org.apache.openjpa.lib.conf.Configurable;\n import org.apache.openjpa.lib.conf.Configuration;\n import org.apache.openjpa.lib.jdbc.ConnectionDecorator;\n@@ -2456,6 +2457,12 @@ public void mathFunction(SQLBuffer buf, String op, FilterValue lhs,\n      */\n     public void comparison(SQLBuffer buf, String op, FilterValue lhs,\n         FilterValue rhs) {\n+        boolean lhsxml = lhs.getXPath() != null;\n+        boolean rhsxml = rhs.getXPath() != null;\n+        if (lhsxml || rhsxml) {\n+            appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\n+            return;\n+        }\n         boolean castlhs = false;\n         boolean castrhs = false;\n         Class lc = Filters.wrap(lhs.getType());\n@@ -2484,6 +2491,15 @@ public void comparison(SQLBuffer buf, String op, FilterValue lhs,\n             rhs.appendTo(buf);\n     }\n \n+    /**\n+     * If this dictionary supports XML type,\n+     * use this method to append xml predicate.\n+     */\n+    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\n+        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\n+        assertSupport(supportsXMLColumn, \"SupportsXMLColumn\");\n+    }\n+\n     /**\n      * Append SQL for the given numeric value to the buffer, casting as needed.\n      */\n@@ -2518,9 +2534,13 @@ public void appendCast(SQLBuffer buf, FilterValue val, int type) {\n         val.appendTo(buf);\n         buf.append(mid);\n         buf.append(getTypeName(type));\n+        appendLength(buf, type);\n         buf.append(post);\n     }\n     \n+    protected void appendLength(SQLBuffer buf, int type) {        \n+    }\n+\n     ///////////\n     // DDL SQL\n     ///////////"},{"sha":"aa8ed1793b6917b7d8a3beb4b080fb92f7d9322f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","status":"modified","additions":59,"deletions":0,"changes":59,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -1038,4 +1038,63 @@ private static boolean isOraclePreparedStatement(Statement stmnt) {\n             return false;\n         }\n     }\n+    \n+    /**\n+     * If this dictionary supports XML type,\n+     * use this method to append xml predicate.\n+     * \n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison\n+     * @param rhs the right hand side of the comparison\n+     */\n+    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\n+        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\n+        super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\n+        if (lhsxml && rhsxml)\n+            appendXmlComparison2(buf, op, lhs, rhs);\n+        else if (lhsxml)\n+            appendXmlComparison1(buf, op, lhs, rhs);\n+        else \n+            appendXmlComparison1(buf, op, rhs, lhs);\n+    }\n+    \n+    /**\n+     * Append an xml comparison predicate\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison\n+     */\n+    private void appendXmlComparison1(SQLBuffer buf, String op,\n+        FilterValue lhs, FilterValue rhs) {\n+        appendXmlExtractValue(buf, lhs);\n+        buf.append(\" \").append(op).append(\" \");\n+        rhs.appendTo(buf);\n+    }\n+    \n+    /**\n+     * Append an xml comparison predicate (both operands map to xml column)\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison (maps to xml column)\n+     */\n+    private void appendXmlComparison2(SQLBuffer buf, String op, \n+        FilterValue lhs, FilterValue rhs) {\n+        appendXmlExtractValue(buf, lhs);\n+        buf.append(\" \").append(op).append(\" \");\n+        appendXmlExtractValue(buf, rhs);\n+    }\n+    \n+    private void appendXmlExtractValue(SQLBuffer buf, FilterValue val) {\n+        buf.append(\"extractValue(\").\n+            append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\",'/*/\");\n+        val.appendTo(buf);\n+        buf.append(\"')\");\n+    }\n }"},{"sha":"baa0ee2e97f8bd5f6e830d2bd0edc3e9b934c791","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","status":"modified","additions":96,"deletions":0,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -23,8 +23,11 @@\n import java.sql.SQLException;\n import java.sql.Types;\n \n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.kernel.Filters;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.JavaTypes;\n \n /**\n  * Dictionary for MS SQLServer.\n@@ -134,4 +137,97 @@ else if (\"NTEXT\".equals(typeName))\n         }\n         return cols;\n     }\n+    \n+    protected void appendLength(SQLBuffer buf, int type) {\n+        if (type == Types.VARCHAR)\n+            buf.append(\"(\").append(Integer.toString(characterColumnSize)).append(\")\");\n+    }\n+\n+    /**\n+     * If this dictionary supports XML type,\n+     * use this method to append xml predicate.\n+     * \n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison\n+     * @param rhs the right hand side of the comparison\n+     * @param lhsxml indicates whether the left operand maps to xml\n+     * @param rhsxml indicates whether the right operand maps to xml\n+     */\n+    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\n+        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\n+        super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\n+        if (lhsxml && rhsxml)\n+            appendXmlComparison2(buf, op, lhs, rhs);\n+        else if (lhsxml)\n+            appendXmlComparison1(buf, op, lhs, rhs);\n+        else \n+            appendXmlComparison1(buf, op, rhs, lhs);\n+    }\n+    /**\n+     * Append an xml comparison predicate\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison\n+     */\n+    private void appendXmlComparison1(SQLBuffer buf, String op,\n+        FilterValue lhs, FilterValue rhs) {\n+        boolean castrhs = rhs.isConstant();\n+        if (castrhs)\n+            appendXmlValue(buf, lhs);\n+        else\n+            appendXmlExist(buf, lhs);\n+        buf.append(\" \").append(op).append(\" \");\n+        if (castrhs)\n+            rhs.appendTo(buf);\n+        else {\n+            buf.append(\"sql:column(\\\"\");\n+            rhs.appendTo(buf);\n+            buf.append(\"\\\")\").\n+                append(\"]') = 1\");\n+        }\n+    }\n+    \n+    private void appendXmlExist(SQLBuffer buf, FilterValue lhs) {\n+        buf.append(lhs.getColumnAlias(\n+            lhs.getFieldMapping().getColumns()[0])).\n+            append(\".exist('\").\n+            append(\"/*[\");\n+        lhs.appendTo(buf);    \n+    }\n+    \n+    /**\n+     * Append an xml comparison predicate (both operands map to xml column)\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison (maps to xml column)\n+     */\n+    private void appendXmlComparison2(SQLBuffer buf, String op, \n+        FilterValue lhs, FilterValue rhs) {\n+        appendXmlValue(buf, lhs);\n+        buf.append(\" \").append(op).append(\" \");\n+        appendXmlValue(buf, rhs);\n+    }\n+    \n+    private void appendXmlValue(SQLBuffer buf, FilterValue val) {\n+        Class rc = Filters.wrap(val.getType());\n+        int type = getJDBCType(JavaTypes.getTypeCode(rc), false);\n+        boolean isXmlAttribute = (val.getXmlMapping() == null) ? false\n+                : val.getXmlMapping().isXmlAttribute();\n+        buf.append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\".value(\").\n+            append(\"'(/*/\");\n+        val.appendTo(buf);\n+        if (!isXmlAttribute)\n+            buf.append(\"/text()\");\n+        buf.append(\")[1]','\").\n+            append(getTypeName(type));\n+        appendLength(buf, type);\n+        buf.append(\"')\");\n+    }\n }"},{"sha":"023ee024734ddf13c66577f660ed199d0cd5363d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","status":"modified","additions":33,"deletions":2,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -30,6 +30,8 @@\n import org.apache.openjpa.lib.util.Localizer.Message;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.XMLMapping;\n import org.apache.openjpa.util.InternalException;\n import org.apache.openjpa.util.OpenJPAException;\n import org.apache.openjpa.util.UnsupportedException;\n@@ -243,6 +245,27 @@ protected ClassMetaData getMetaData(Class c, boolean required,\n     protected Value traversePath(Path path, String field) {\n         return traversePath(path, field, false, false);\n     }\n+    \n+    protected Value traverseXPath(Path path, String field) {\n+        XMLMapping meta = path.getXmlMapping();\n+        if (meta.getFieldMapping(field) == null) {\n+            throw parseException(EX_USER, \"no-field\",\n+                    new Object[]{ meta.getType(), field }, null);\n+        }\n+        else {\n+            // collection-valued xpath is not allowed\n+            int type = meta.getFieldMapping(field).getTypeCode();\n+            switch (type) {\n+                case JavaTypes.ARRAY:\n+                case JavaTypes.COLLECTION:\n+                case JavaTypes.MAP:\n+                    throw new UserException(_loc.get(\"collection-valued-path\",\n+                            field));\n+            }\n+        }\n+        path.get(meta, field);\n+        return path;\n+    }\n \n     /**\n      * Traverse the given field in the given path.\n@@ -272,6 +295,14 @@ protected Value traversePath(Path path, String field, boolean pcOnly,\n             addAccessPath(meta);\n             path.setMetaData(meta);\n         }\n+        else {\n+            // xmlsupport xpath\n+            XMLMapping xmlmeta = fmd.getRepository().getXMLMetaData(fmd);\n+            if (xmlmeta != null) {\n+                path.get(fmd, xmlmeta);\n+                return path;\n+            }\n+        }\n \n         if (meta != null || !pcOnly)\n             path.get(fmd, allowNull);\n@@ -309,11 +340,11 @@ protected void setImplicitTypes(Value val1, Value val2,\n \n         if (o1 && !o2) {\n             val1.setImplicitType(c2);\n-            if (val1.getMetaData() == null)\n+            if (val1.getMetaData() == null && !val1.isXPath())\n                 val1.setMetaData(val2.getMetaData());\n         } else if (!o1 && o2) {\n             val2.setImplicitType(c1);\n-            if (val2.getMetaData() == null)\n+            if (val2.getMetaData() == null && !val1.isXPath())\n                 val2.setMetaData(val1.getMetaData());\n         } else if (o1 && o2 && expected != null) {\n             // we never expect a pc type, so don't bother with metadata"},{"sha":"0f7226b33bde72a489d112e51b1eefc8d0fda6e1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -30,6 +30,7 @@\n import org.apache.openjpa.kernel.StoreContext;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.XMLMapping;\n \n /**\n  * A path represents a traversal into fields of a candidate object.\n@@ -184,4 +185,14 @@ public boolean equals(Object other) {\n             return ((Traversal) other).field.equals(field);\n         }\n \t}\n+\n+    public void get(FieldMetaData fmd, XMLMapping meta) {\n+    }\n+    \n+    public void get(XMLMapping meta, String name) {\n+    }\n+    \n+    public XMLMapping getXmlMapping() {\n+        return null;\n+    }\n }"},{"sha":"750f66393903eae692b9b67e0d3f4fad6c483fc2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java","status":"modified","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -19,6 +19,7 @@\n package org.apache.openjpa.kernel.exps;\n \n import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.XMLMapping;\n \n /**\n  * A path represents a traversal into fields of a candidate object.\n@@ -42,4 +43,28 @@\n      * not contain a final field.\n      */\n     public FieldMetaData last();\n+\n+    /**\n+     * Traverse into the given field that maps to xml column, and update\n+     * the current object to that field value.\n+     * \n+     * @param fmd field maps to xml column\n+     * @param meta associated xml mapping\n+     */\n+    public void get(FieldMetaData fmd, XMLMapping meta);\n+    \n+    /**\n+     * Traverse into the gevin xpath name of the current object, and update\n+     * the current object to that xpath field.\n+     * \n+     * @param meta\n+     * @param name\n+     */\n+    public void get(XMLMapping meta, String name);\n+    \n+    /**\n+     * Return the current XPath's xmlmapping metadata.\n+     * @return Return xmlmapping\n+     */\n+    public XMLMapping getXmlMapping();\n }"},{"sha":"da054c7d722a178d3f04274d3eefe1eb1e6997a8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -109,6 +109,10 @@ public boolean isVariable() {\n     public boolean isAggregate() {\n         return false;\n     }\n+    \n+    public boolean isXPath() {\n+        return false;\n+    }\n \n     public void acceptVisit(ExpressionVisitor visitor) {\n         visitor.enter(this);"},{"sha":"b9135a1f0bc214b0139bf72a5d90423d286b487f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -51,6 +51,11 @@\n      */\n     public boolean isAggregate();\n \n+    /**\n+     * Return true if this value is an XML Path.\n+     */\n+    public boolean isXPath();\n+    \n     /**\n      * Return any associated persistent type.\n      */"},{"sha":"06df6348c0825fd41b7f963cf705f11adb6e7d17","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","status":"modified","additions":6,"deletions":1,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -1088,7 +1088,7 @@ protected void setImplicitTypes(Value val1, Value val2, Class expected) {\n         if (fmd == null)\n             return;\n \n-        Class type = fmd.getType();\n+        Class type = path.isXPath() ? path.getType() : fmd.getType();\n         if (type == null)\n             return;\n \n@@ -1298,6 +1298,11 @@ else if (val.getMetaData() != null)\n         // walk through the children and assemble the path\n         boolean allowNull = !inner;\n         for (int i = 1; i < node.children.length; i++) {\n+            if (path.isXPath()) {\n+                for (int j = i; j <node.children.length; j++)\n+                    path = (Path) traverseXPath(path, node.children[j].text);\n+                return path;\n+            }\n             path = (Path) traversePath(path, node.children[i].text, pcOnly,\n                 allowNull);\n "},{"sha":"5c96ce0b68ca2df139391c01faaa15bbd4d3a734","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -1850,4 +1850,13 @@ public boolean equals(Object obj)\n \t\t\t\t&& StringUtils.equals (name, qk.name);\t\n \t\t}\n \t}\n+    \n+    /**\n+     * Return XML metadata for a given field metadata\n+     * @param fmd\n+     * @return null\n+     */\n+    public XMLMapping getXMLMetaData(FieldMetaData fmd) {\n+        return null;\n+    }\n }"},{"sha":"dbe0ac5f8b6d591318262b3d4ac56bfb6f081dd3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLMapping.java","status":"added","additions":119,"deletions":0,"changes":119,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLMapping.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLMapping.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -0,0 +1,119 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.meta;\r\n+\r\n+import java.io.Serializable;\r\n+\r\n+/**\r\n+ * Describe metadata about an xml type.\r\n+ * \r\n+ * @author Catalina Wei\r\n+ * @since 1.0.0\r\n+ */\r\n+public interface XMLMapping extends Serializable {\r\n+    /**\r\n+     * JAXB XML binding default name\r\n+     */\r\n+    public static final String defaultName = \"##default\";\r\n+    public static final int XMLTYPE = 0;\r\n+    public static final int ELEMENT = 1;\r\n+    public static final int ATTRIBUTE = 2;\r\n+\r\n+    /**\r\n+     * Return true if mapping on an XmlRootElement.\r\n+     */\r\n+    public boolean isXmlRootElement();\r\n+\r\n+    /**\r\n+     * Return true if mapping on an XmlElement.\r\n+     */\r\n+    public boolean isXmlElement();\r\n+\r\n+    /**\r\n+     * Return true if mapping on an XmlAttribute.\r\n+     */\r\n+    public boolean isXmlAttribute();\r\n+    \r\n+    /**\r\n+     * Return XMLMapping for a given field.\r\n+     * @param name the field name.\r\n+     * @return XMLMapping.\r\n+     */\r\n+    public XMLMapping getFieldMapping(String name); \r\n+    \r\n+    /**\r\n+     * Set type.\r\n+     */\r\n+    public void setType(Class type);\r\n+\r\n+    /**\r\n+     * Return type.\r\n+     */\r\n+    public Class getType();\r\n+\r\n+    /**\r\n+     * Return type code.\r\n+     */\r\n+    public int getTypeCode();\r\n+\r\n+    /**\r\n+     * Return the mapping name.\r\n+     */\r\n+    public String getName();\r\n+\r\n+    /**\r\n+     * Return xml element tag name or xml attribute name.\r\n+     */\r\n+    public String getXmlname();\r\n+\r\n+    /**\r\n+     * Return xml namespace.\r\n+     */\r\n+    public String getXmlnamespace();\r\n+\r\n+    /**\r\n+     * Set field name.\r\n+     * @param name the field name.\r\n+     */\r\n+    public void setName(String name);\r\n+\r\n+    /**\r\n+     * Set xml element or attribute name.\r\n+     * @param name the element name or attribute name\r\n+     */\r\n+    public void setXmlname(String name);\r\n+\r\n+    /**\r\n+     * Set namespace.\r\n+     * @param namespace\r\n+     */\r\n+    public void setXmlnamespace(String namespace);\r\n+\r\n+    /**\r\n+     * Set xmltype\r\n+     * @param type XMLTYPE, ELEMENT, or ATTRIBUTE\r\n+     */\r\n+    public void setXmltype(int type);\r\n+\r\n+    /**\r\n+     * Return xmltype\r\n+     * @return xmltype\r\n+     */\r\n+    public int getXmltype();\r\n+}\r"},{"sha":"60259c8abd27e4713bbb7b105a4d91879b7e0082","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLMetaData.java","status":"added","additions":111,"deletions":0,"changes":111,"blob_url":"https://github.com/apache/openjpa/blob/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/a275b7aefb43a9de0e183cbaff5de9b0489e59e2/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/XMLMetaData.java?ref=a275b7aefb43a9de0e183cbaff5de9b0489e59e2","patch":"@@ -0,0 +1,111 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.meta;\r\n+\r\n+import org.apache.commons.lang.StringUtils;\r\n+\r\n+/**\r\n+ * Contains metadata about an xml element or attribute\r\n+ *\r\n+ * @author Catalina Wei\r\n+ * @since 1.0.0\r\n+ */\r\n+public class XMLMetaData implements XMLMapping {\r\n+\r\n+    private String _name;\r\n+    private String _xmlname = null;\r\n+    private String _xmlnamespace = null;\r\n+    private Class _decType = Object.class;\r\n+    private int _decCode = JavaTypes.OBJECT;\r\n+    private Class _type = Object.class;\r\n+    private int _code = JavaTypes.OBJECT;\r\n+    private int _xmltype;    \r\n+\r\n+    public XMLMetaData() {        \r\n+    }\r\n+    \r\n+    public Class getType() {\r\n+        return (_type == null) ? _decType : _type;\r\n+    }\r\n+\r\n+    public void setType(Class type) {\r\n+        _type = type;\r\n+        if (type != null)\r\n+            setTypeCode(JavaTypes.getTypeCode(type));\r\n+    }\r\n+\r\n+    public int getTypeCode() {\r\n+        return (_type == null) ? _decCode : _code;\r\n+    }\r\n+\r\n+    // set JavaTypes code\r\n+    public void setTypeCode(int code) {\r\n+        _code = code;\r\n+    }\r\n+    \r\n+    public void setName(String name) {\r\n+        _name = name;\r\n+    }\r\n+    \r\n+    public String getName() {\r\n+        return _name;\r\n+    }\r\n+    \r\n+    public void setXmlname(String name) {\r\n+        _xmlname = name;\r\n+    }\r\n+    \r\n+    public String getXmlname() {\r\n+        return _xmlname;\r\n+    }\r\n+    \r\n+    public void setXmlnamespace(String name) {\r\n+        // avoid JAXB XML bind default name\r\n+        if (!StringUtils.equals(defaultName, name))\r\n+            _xmlnamespace = name;\r\n+    }\r\n+    \r\n+    public String getXmlnamespace() {\r\n+        return _xmlnamespace;\r\n+    }\r\n+    \r\n+    public void setXmltype(int type) {\r\n+        _xmltype = type;\r\n+    }\r\n+    \r\n+    public int getXmltype() {\r\n+        return _xmltype;\r\n+    }\r\n+    \r\n+    public boolean isXmlRootElement() {\r\n+        return false;\r\n+    }\r\n+    \r\n+    public boolean isXmlElement() {\r\n+        return _xmltype == ELEMENT;\r\n+    }\r\n+    \r\n+    public boolean isXmlAttribute() {\r\n+        return _xmltype == ATTRIBUTE;\r\n+    }\r\n+    \r\n+    public XMLMapping getFieldMapping(String name) {\r\n+        return null;\r\n+    }\r\n+}\r"}]}

