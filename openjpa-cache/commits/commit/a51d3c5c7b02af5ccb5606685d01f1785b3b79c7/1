{"sha":"a51d3c5c7b02af5ccb5606685d01f1785b3b79c7","node_id":"MDY6Q29tbWl0MjA2MzY0OmE1MWQzYzVjN2IwMmFmNWNjYjU2MDY2ODVkMDFmMTc4NWIzYjc5Yzc=","commit":{"author":{"name":"Mark Struberg","email":"struberg@apache.org","date":"2015-06-30T08:49:04Z"},"committer":{"name":"Mark Struberg","email":"struberg@apache.org","date":"2015-06-30T08:49:04Z"},"message":"OPENJPA-2600 remove Classes which break Java8 functionality.\n\nThey are not used since quite some time anyway and have been marked\nas deprecated in the past already.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@1688402 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"e911b5497fb82cc89bc4d6e66a6fe5e5ea73816b","url":"https://api.github.com/repos/apache/openjpa/git/trees/e911b5497fb82cc89bc4d6e66a6fe5e5ea73816b"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/a51d3c5c7b02af5ccb5606685d01f1785b3b79c7","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/a51d3c5c7b02af5ccb5606685d01f1785b3b79c7","html_url":"https://github.com/apache/openjpa/commit/a51d3c5c7b02af5ccb5606685d01f1785b3b79c7","comments_url":"https://api.github.com/repos/apache/openjpa/commits/a51d3c5c7b02af5ccb5606685d01f1785b3b79c7/comments","author":{"login":"struberg","id":79310,"node_id":"MDQ6VXNlcjc5MzEw","avatar_url":"https://avatars.githubusercontent.com/u/79310?v=4","gravatar_id":"","url":"https://api.github.com/users/struberg","html_url":"https://github.com/struberg","followers_url":"https://api.github.com/users/struberg/followers","following_url":"https://api.github.com/users/struberg/following{/other_user}","gists_url":"https://api.github.com/users/struberg/gists{/gist_id}","starred_url":"https://api.github.com/users/struberg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/struberg/subscriptions","organizations_url":"https://api.github.com/users/struberg/orgs","repos_url":"https://api.github.com/users/struberg/repos","events_url":"https://api.github.com/users/struberg/events{/privacy}","received_events_url":"https://api.github.com/users/struberg/received_events","type":"User","site_admin":false},"committer":{"login":"struberg","id":79310,"node_id":"MDQ6VXNlcjc5MzEw","avatar_url":"https://avatars.githubusercontent.com/u/79310?v=4","gravatar_id":"","url":"https://api.github.com/users/struberg","html_url":"https://github.com/struberg","followers_url":"https://api.github.com/users/struberg/followers","following_url":"https://api.github.com/users/struberg/following{/other_user}","gists_url":"https://api.github.com/users/struberg/gists{/gist_id}","starred_url":"https://api.github.com/users/struberg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/struberg/subscriptions","organizations_url":"https://api.github.com/users/struberg/orgs","repos_url":"https://api.github.com/users/struberg/repos","events_url":"https://api.github.com/users/struberg/events{/privacy}","received_events_url":"https://api.github.com/users/struberg/received_events","type":"User","site_admin":false},"parents":[{"sha":"72be5f17209fbe92415a2ebed59d0d25d0a3b785","url":"https://api.github.com/repos/apache/openjpa/commits/72be5f17209fbe92415a2ebed59d0d25d0a3b785","html_url":"https://github.com/apache/openjpa/commit/72be5f17209fbe92415a2ebed59d0d25d0a3b785"}],"stats":{"total":547,"additions":0,"deletions":547},"files":[{"sha":"611b15fb2448816270069d50f70dc6cb5b6937e3","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","status":"removed","additions":0,"deletions":418,"changes":418,"blob_url":"https://github.com/apache/openjpa/blob/72be5f17209fbe92415a2ebed59d0d25d0a3b785/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/72be5f17209fbe92415a2ebed59d0d25d0a3b785/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java?ref=72be5f17209fbe92415a2ebed59d0d25d0a3b785","patch":"@@ -1,418 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.openjpa.lib.util.concurrent;\n-\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.Enumeration;\n-import java.util.Set;\n-import java.util.Collection;\n-import java.util.AbstractSet;\n-import java.util.Iterator;\n-import java.util.AbstractCollection;\n-import java.util.Random;\n-import java.util.HashSet;\n-\n-import org.apache.commons.collections.set.MapBackedSet;\n-\n-/**\n- * A subclass of {@link ConcurrentHashMap} that allows null keys and values. In exchange, it weakens the contract of\n- * {@link #putIfAbsent} and the other concurrent methods added in {@link #ConcurrentHashMap}.\n- * \n- * @since 1.1.0\n- * @deprecated In Java 8, java.util.ConcurrentHashMap received an overhauled and this extension was not updated. This\n- *             class will fail to compile on Java 8. If it is compiled at a lower level and run on Java 8 it will not\n- *             work properly. For more information: https://issues.apache.org/jira/browse/OPENJPA-2441\n- */\n-@Deprecated\n-public class NullSafeConcurrentHashMap extends ConcurrentHashMap {\n-\n-    private enum Markers {\n-        NULL,\n-        MAP_BACKED_SET_DUMMY_VAL\n-    }\n-\n-    // The second argument is used within MapBackedSet as the value for\n-    // all the key-val pairs that are put into the underlying Map. This\n-    // is required for our usage since ConcurrentHashMap does not allow\n-    // null values.\n-    private Set randomKeys = MapBackedSet.decorate(\n-        new ConcurrentHashMap(), Markers.MAP_BACKED_SET_DUMMY_VAL);\n-\n-    private Random random = new Random();\n-\n-    public NullSafeConcurrentHashMap(int size, float load,\n-        int concurrencyLevel) {\n-        super(size, load, concurrencyLevel);\n-    }\n-\n-    public NullSafeConcurrentHashMap() {\n-    }\n-\n-    /**\n-     * Returns internal representation for object.\n-     */\n-    private static Object maskNull(Object o) {\n-        return (o == null ? Markers.NULL : o);\n-    }\n-\n-    /**\n-     * Returns object represented by specified internal representation.\n-     */\n-    private static Object unmaskNull(Object o) {\n-        return (o == Markers.NULL ? null : o);\n-    }\n-\n-    public Entry removeRandom() {\n-        // this doesn't just use randomEntryIterator() because that iterator\n-        // has weaker concurrency guarantees than this method. In particular,\n-        // this method will continue to attempt to remove random entries even\n-        // as other threads remove the same entries, whereas the random\n-        // iterator may return values that have been removed.\n-\n-        for (Iterator iter = randomKeys.iterator(); iter.hasNext(); ) {\n-            // randomKeys contains null-masked data\n-            Object key = iter.next();\n-            if (key != null && randomKeys.remove(key)) {\n-                Object val = super.remove(key);\n-                if (val != null)\n-                    return new EntryImpl(unmaskNull(key), unmaskNull(val));\n-            }\n-        }\n-\n-        // if randomKeys is empty, fall back to non-random behavior.\n-        for (Iterator iter = super.keySet().iterator(); iter.hasNext(); ) {\n-            Object key = iter.next();\n-            if (key == null)\n-                continue;\n-            Object val = super.remove(key);\n-            if (val != null)\n-                return new EntryImpl(unmaskNull(key), unmaskNull(val));\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * The returned data structure should not be shared among multiple\n-     * threads.\n-     */\n-    public Iterator<Entry> randomEntryIterator() {\n-        return new Iterator<Entry>() {\n-\n-            Iterator randomIter = randomKeys.iterator();\n-            Iterator nonRandomIter = NullSafeConcurrentHashMap.super.keySet()\n-                .iterator();\n-\n-            Set returned = new HashSet();\n-            Entry next;\n-            boolean nextSet = false;\n-\n-            public boolean hasNext() {\n-                // we've set the next value and we haven't returned it yet\n-                if (nextSet)\n-                    return true;\n-\n-                // compute the next value. If the computation returns null,\n-                // return false. Else, store the next value and return true.\n-                Object nextKey;\n-                Object nextValue;\n-                if (randomIter.hasNext()) {\n-                    nextKey = randomIter.next();\n-                    nextValue = NullSafeConcurrentHashMap.super.get(nextKey);\n-                    if (nextValue != null) {\n-                        returned.add(nextKey);\n-                        next = new EntryImpl(unmaskNull(nextKey),\n-                            unmaskNull(nextValue));\n-                        nextSet = true;\n-                        return true;\n-                    }\n-                }\n-\n-                while (nonRandomIter.hasNext()) {\n-                    nextKey = nonRandomIter.next();\n-\n-                    if (returned.contains(nextKey))\n-                        continue;\n-\n-                    nextValue = NullSafeConcurrentHashMap.super.get(nextKey);\n-                    if (nextValue != null) {\n-                        returned.add(nextKey);\n-                        next = new EntryImpl(unmaskNull(nextKey),\n-                            unmaskNull(nextValue));\n-                        nextSet = true;\n-                        return true;\n-                    }\n-                }\n-                return false;\n-            }\n-\n-            public Entry next() {\n-                // hasNext() will initialize this.next\n-                if (!nextSet && !hasNext())\n-                    return null;\n-\n-                // if we get here, then we're about to return a next value\n-                nextSet = false;\n-                \n-                if (containsKey(next.getKey()))\n-                    return next;\n-\n-                // something has changed since the last iteration (presumably\n-                // due to multi-threaded access to the underlying data\n-                // structure); recurse\n-                return next();\n-            }\n-\n-            public void remove() {\n-                throw new UnsupportedOperationException();\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public Object remove(Object key) {\n-        Object maskedKey = maskNull(key);\n-        Object val = unmaskNull(super.remove(maskedKey));\n-        randomKeys.remove(maskedKey);\n-        return val;\n-    }\n-\n-    @Override\n-    public boolean remove(Object key, Object value) {\n-        Object maskedKey = maskNull(key);\n-        boolean val = super.remove(maskedKey, maskNull(value));\n-        randomKeys.remove(maskedKey);\n-        return val;\n-    }\n-\n-    @Override\n-    public boolean replace(Object key, Object oldValue, Object newValue) {\n-        return super.replace(maskNull(key), maskNull(oldValue),\n-            maskNull(newValue));\n-    }\n-\n-    @Override\n-    public Object replace(Object key, Object value) {\n-        return unmaskNull(super.replace(maskNull(key), maskNull(value)));\n-    }\n-\n-    @Override\n-    public Object putIfAbsent(Object key, Object value) {\n-        Object maskedKey = maskNull(key);\n-        Object superVal = super.putIfAbsent(maskedKey, maskNull(value));\n-        addRandomKey(maskedKey);\n-        return unmaskNull(superVal);\n-    }\n-\n-    @Override\n-    public Object put(Object key, Object value) {\n-        Object maskedKey = maskNull(key);\n-        Object superVal = super.put(maskedKey, maskNull(value));\n-        addRandomKey(maskedKey);\n-        return unmaskNull(superVal);\n-    }\n-\n-    /**\n-     * Potentially adds <code>maskedKey</ccode> to the set of random keys\n-     * to be removed by {@link #removeRandom()}.\n-     *\n-     * @since 1.1.0\n-     */\n-    private void addRandomKey(Object maskedKey) {\n-        // Add one in every three keys to the set. Only do this when\n-        // there are less than 16 elements in the random key set; this\n-        // means that the algorithm will be pseudo-random for up to\n-        // 16 removes (either via removeRandom() or normal remove()\n-        // calls) that have no intervening put() calls.\n-        if (random != null && randomKeys.size() < 16 && random.nextInt(10) < 3)\n-            randomKeys.add(maskedKey);\n-    }\n-\n-    @Override\n-    public Object get(Object key) {\n-        return unmaskNull(super.get(maskNull(key)));\n-    }\n-\n-    @Override\n-    public boolean containsKey(Object key) {\n-        return super.containsKey(maskNull(key));\n-    }\n-\n-    @Override\n-    public boolean containsValue(Object value) {\n-        return super.containsValue(maskNull(value));\n-    }\n-\n-    @Override\n-    public boolean contains(Object value) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public Enumeration elements() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public Set entrySet() {\n-        return new TranslatingSet(super.entrySet()) {\n-            protected Object unmask(Object internal) {\n-                final Entry e = (Entry) internal;\n-                return new Entry() {\n-\n-                    public Object getKey() {\n-                        return unmaskNull(e.getKey());\n-                    }\n-\n-                    public Object getValue() {\n-                        return unmaskNull(e.getValue());\n-                    }\n-\n-                    public Object setValue(Object value) {\n-                        return unmaskNull(e.setValue(maskNull(value)));\n-                    }\n-\n-                    @Override\n-                    public int hashCode() {\n-                        return e.hashCode();\n-                    }\n-                };\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public Enumeration keys() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public Set keySet() {\n-        return new TranslatingSet(super.keySet()) {\n-            protected Object unmask(Object internal) {\n-                return unmaskNull(internal);\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public Collection values() {\n-        return new TranslatingCollection(super.values()) {\n-\n-            protected Object unmask(Object internal) {\n-                return unmaskNull(internal);\n-            }\n-        };\n-    }\n-\n-    private abstract class TranslatingSet extends AbstractSet {\n-\n-        private Set backingSet;\n-\n-        private TranslatingSet(Set backing) {\n-            this.backingSet = backing;\n-        }\n-\n-        protected abstract Object unmask(Object internal);\n-\n-        public Iterator iterator() {\n-            final Iterator iterator = backingSet.iterator();\n-            return new Iterator() {\n-                public boolean hasNext() {\n-                    return iterator.hasNext();\n-                }\n-\n-                public Object next() {\n-                    return unmask(iterator.next());\n-                }\n-\n-                public void remove() {\n-                    iterator.remove();\n-                }\n-            };\n-        }\n-\n-        public int size() {\n-            return backingSet.size();\n-        }\n-    }\n-\n-    private abstract class TranslatingCollection extends AbstractCollection {\n-\n-        private Collection backingCollection;\n-\n-        private TranslatingCollection(Collection backing) {\n-            this.backingCollection = backing;\n-        }\n-\n-        protected abstract Object unmask(Object internal);\n-\n-        public Iterator iterator() {\n-            final Iterator iterator = backingCollection.iterator();\n-            return new Iterator() {\n-                public boolean hasNext() {\n-                    return iterator.hasNext();\n-                }\n-\n-                public Object next() {\n-                    return unmask(iterator.next());\n-                }\n-\n-                public void remove() {\n-                    iterator.remove();\n-                }\n-            };\n-        }\n-\n-        public int size() {\n-            return backingCollection.size();\n-        }\n-    }\n-\n-    private class EntryImpl implements Entry {\n-\n-        final Object key;\n-        final Object val;\n-\n-        private EntryImpl(Object key, Object val) {\n-            this.key = key;\n-            this.val = val;\n-        }\n-\n-        public Object getKey() {\n-            return key;\n-        }\n-\n-        public Object getValue() {\n-            return val;\n-        }\n-\n-        public Object setValue(Object value) {\n-            throw new UnsupportedOperationException();\n-        }\n-    }\n-\n-    public interface KeyFilter {\n-\n-        /**\n-         * @param key may be null\n-         * @return whether or not <code>key</code> shuold be excluded\n-         */\n-        public boolean exclude(Object key);\n-    }\n-}"},{"sha":"f3e141f5cd6a6073cf57e05714dbd53c35115db0","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","status":"removed","additions":0,"deletions":129,"changes":129,"blob_url":"https://github.com/apache/openjpa/blob/72be5f17209fbe92415a2ebed59d0d25d0a3b785/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/72be5f17209fbe92415a2ebed59d0d25d0a3b785/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java?ref=72be5f17209fbe92415a2ebed59d0d25d0a3b785","patch":"@@ -1,129 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.openjpa.lib.util.concurrent;\n-\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.io.ObjectOutputStream;\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.Serializable;\n-\n-import org.apache.openjpa.lib.util.SizedMap;\n-\n-/**\n- * An implementation of {@link SizedMap} that uses JDK1.5 concurrency primitives\n- * \n- * @since 1.1.0\n- * @deprecated In Java 8, java.util.ConcurrentHashMap received an overhauled and this extension was not updated. This\n- *             class will fail to compile on Java 8. If it is compiled at a lower level and run on Java 8 it will not\n- *             work properly. For more information: https://issues.apache.org/jira/browse/OPENJPA-2441\n- */\n-@Deprecated\n-public class SizedConcurrentHashMap\n-    extends NullSafeConcurrentHashMap\n-    implements SizedMap, ConcurrentMap, Serializable {\n-\n-    private int maxSize;\n-\n-    /**\n-     * @param size the maximum size of this map. If additional elements are\n-     * put into the map, overflow will be removed via calls to\n-     * {@link #overflowRemoved}.\n-     * @param load the load factor for the underlying map\n-     * @param concurrencyLevel the concurrency level for the underlying map\n-     *\n-     * @see ConcurrentHashMap\n-     */\n-    public SizedConcurrentHashMap(int size, float load, int concurrencyLevel) {\n-        super(size, load, concurrencyLevel);\n-        setMaxSize(size);\n-    }\n-\n-    @Override\n-    public Object putIfAbsent(Object key, Object value) {\n-        if (maxSize != Integer.MAX_VALUE)\n-            removeOverflow(true);\n-        return super.putIfAbsent(key, value);\n-    }\n-\n-    @Override\n-    public Object put(Object key, Object value) {\n-        if (maxSize != Integer.MAX_VALUE)\n-            removeOverflow(true);\n-        return super.put(key, value);\n-    }\n-\n-    public int getMaxSize() {\n-        return maxSize;\n-    }\n-\n-    public void setMaxSize(int max) {\n-        if (max < 0)\n-            throw new IllegalArgumentException(String.valueOf(max));\n-        maxSize = max;\n-\n-        removeOverflow(false);\n-    }\n-\n-    /**\n-     * Equivalent to <code>removeOverflow(false)</code>.\n-     */\n-    protected void removeOverflow() {\n-        removeOverflow(false);\n-    }\n-\n-    /**\n-     * Removes overflow. If <code>forPut</code> is <code>true</code>, then\n-     * this uses <code>size() + 1</code> when computing size.\n-     */\n-    protected void removeOverflow(boolean forPut) {\n-        int sizeToCompareTo = forPut ? maxSize - 1 : maxSize;\n-        while (size() > sizeToCompareTo) {\n-            Entry entry = removeRandom();\n-            // if removeRandom() returns null, break out of the loop. Of course,\n-            // since we're not locking, the size might not actually be null\n-            // when we do this. But this prevents weird race conditions from\n-            // putting this thread into more loops.\n-            if (entry == null)\n-                break;\n-            overflowRemoved(entry.getKey(), entry.getValue());\n-        }\n-    }\n-\n-    public boolean isFull() {\n-        return size() >= maxSize;\n-    }\n-\n-    /**\n-     * This implementation does nothing.\n-     */\n-    public void overflowRemoved(Object key, Object value) {\n-    }\n-\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n-        out.defaultWriteObject();\n-        out.writeInt(maxSize);\n-    }\n-\n-    private void readObject(ObjectInputStream in)\n-        throws IOException, ClassNotFoundException {\n-        in.defaultReadObject();\n-        maxSize = in.readInt();\n-    }\n-}"}]}

