{"sha":"a7464c7e0a4162d4a574d3d31190b3ac11828eb2","node_id":"MDY6Q29tbWl0MjA2MzY0OmE3NDY0YzdlMGE0MTYyZDRhNTc0ZDNkMzExOTBiM2FjMTE4MjhlYjI=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-08-05T19:07:34Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-08-05T19:07:34Z"},"message":"OPENJPA-628: Adding more test cases for testing proxy collections in tracking changes in detached mode.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@682875 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"8a98aea8eaad06523520944e13ba173ece71867c","url":"https://api.github.com/repos/apache/openjpa/git/trees/8a98aea8eaad06523520944e13ba173ece71867c"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/a7464c7e0a4162d4a574d3d31190b3ac11828eb2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/a7464c7e0a4162d4a574d3d31190b3ac11828eb2","html_url":"https://github.com/apache/openjpa/commit/a7464c7e0a4162d4a574d3d31190b3ac11828eb2","comments_url":"https://api.github.com/repos/apache/openjpa/commits/a7464c7e0a4162d4a574d3d31190b3ac11828eb2/comments","author":null,"committer":null,"parents":[{"sha":"e41e1dd9761c718861e69afd2c44e85da02daa7d","url":"https://api.github.com/repos/apache/openjpa/commits/e41e1dd9761c718861e69afd2c44e85da02daa7d","html_url":"https://github.com/apache/openjpa/commit/e41e1dd9761c718861e69afd2c44e85da02daa7d"}],"stats":{"total":378,"additions":378,"deletions":0},"files":[{"sha":"1e7c8c09811b470431aa782caccb2ce5698b5fdd","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/proxy/TestProxyCollection.java","status":"added","additions":165,"deletions":0,"changes":165,"blob_url":"https://github.com/apache/openjpa/blob/a7464c7e0a4162d4a574d3d31190b3ac11828eb2/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/proxy/TestProxyCollection.java","raw_url":"https://github.com/apache/openjpa/raw/a7464c7e0a4162d4a574d3d31190b3ac11828eb2/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/proxy/TestProxyCollection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/proxy/TestProxyCollection.java?ref=a7464c7e0a4162d4a574d3d31190b3ac11828eb2","patch":"@@ -0,0 +1,165 @@\n+package org.apache.openjpa.persistence.proxy;\r\n+\r\n+import javax.persistence.EntityManager;\r\n+\r\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n+import org.apache.openjpa.util.ChangeTracker;\r\n+import org.apache.openjpa.util.ProxyCollection;\r\n+\r\n+/**\r\n+ * Tests proxying and change tracking of collection fields for modification in\r\n+ * detached state.\r\n+ * \r\n+ * Originally reported in\r\n+ * <A HREF=\"https://issues.apache.org/jira/browse/OPENJPA-628\">OPENJPA-628</A>\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ *\r\n+ */\r\n+public class TestProxyCollection extends SingleEMFTestCase {\r\n+\tpublic void setUp() {\r\n+\t\tsuper.setUp(CLEAR_TABLES, TreeNode.class);\r\n+\t}\r\n+\t/**\r\n+\t * Tests that a uniform tree is created with expected fan outs at each \r\n+\t * level. This is not a persistent operation, just in-memory. \r\n+\t */\r\n+\tpublic void testCreateTree() {\r\n+\t\tTreeNode root = new TreeNode();\r\n+\t\troot.setName(\"0\");\r\n+\t\tint[] fanOuts = {1,2,3};\r\n+\t\troot.createTree(fanOuts);\r\n+\t\tassertArrayEquals(fanOuts, root.getFanOuts());\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Tests that a uniform tree can be modified with different fan outs at each \r\n+\t * level. This is not a persistent operation, just in-memory. \r\n+\t */\r\n+\tpublic void testModifyTree() {\r\n+\t\tint[] fanOuts = {1,2,2,4};\r\n+\t\tint[] newFanOuts = {1,3,1,2};\r\n+\t\tTreeNode root = new TreeNode();\r\n+\t\troot.createTree(fanOuts);\r\n+\t\tassertArrayEquals(fanOuts, root.getFanOuts());\r\n+\t\t\r\n+\t\troot.modify(newFanOuts);\r\n+\t\tassertArrayEquals(newFanOuts, root.getFanOuts());\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Tests that a uniform tree is persisted and later fetched back with same\r\n+\t * number of children at every level.\r\n+\t */\r\n+\tpublic void testPersistTree() {\r\n+\t\tint[] fanOuts = {2,3,4};\r\n+\t\tverify(create(fanOuts), fanOuts);\r\n+\t}\r\n+\t\r\n+\tpublic void testAddNodeAtLeaf() {\r\n+\t\tint[] original = {1,2,3};\r\n+\t\tint[] modifier = {1,2,4}; // add new child at Level 2\r\n+\t\tcreateModifyAndMerge(original, modifier);\r\n+\t}\r\n+\t\r\n+\tpublic void testAddNewLevel() {\r\n+\t\tint[] original = {1,2,3};\r\n+\t\tint[] modifier = {1,2,3,2}; // add 2 new children at new Level \r\n+\t\tcreateModifyAndMerge(original, modifier);\r\n+\t}\r\n+\t\r\n+\tpublic void testAddAndRemove() {\r\n+\t\tint[] original = {2,3,4};\r\n+\t\tint[] modifier = {4,3,2}; // add 1 at Level 1 + remove 1 at Level 3\r\n+\t\tcreateModifyAndMerge(original, modifier);\r\n+\t}\r\n+\t\r\n+\tpublic void testAddAtAllLevel() {\r\n+\t\tint[] original = {2,3,4};\r\n+\t\tint[] modifier = {3,4,5}; // add 1 at each Level \r\n+\t\tcreateModifyAndMerge(original, modifier);\r\n+\t}\r\n+\t\r\n+\tpublic void testRemoveAtAllLevel() {\r\n+\t\tint[] original = {2,3,4};\r\n+\t\tint[] modifier = {1,2,3}; // remove 1 from each Level \r\n+\t\tcreateModifyAndMerge(original, modifier);\r\n+\t}\r\n+\t/**\r\n+\t * Create a uniform tree with original fanout.\r\n+\t * Persist.\r\n+\t * Verify in a separate persistence context that the tree is stored.\r\n+\t * Modify the tree by adding or deleting nodes according to the given \r\n+\t * modified fanouts outside a transaction.\r\n+\t * Merge the changes.\r\n+\t * Verify that the changes are merged by fetching the modified version.\r\n+\t * \r\n+\t * @param original\r\n+\t * @param modified\r\n+\t */\r\n+\tvoid createModifyAndMerge(int[] original, int[] modifier) {\r\n+\t\tTreeNode root = create(original);\r\n+\t\t\r\n+\t\tEntityManager em = emf.createEntityManager();\r\n+\t\tem.getTransaction().begin();\r\n+\t\tTreeNode modified = em.find(TreeNode.class, root.getId());\r\n+\t\tmodified.modify(modifier);\r\n+\t\tem.merge(modified);\r\n+\t\tem.getTransaction().commit();\r\n+\t\tem.clear();\r\n+\t\t\r\n+\t\tassertProxyCollection(root.getNodes(), false);\r\n+\t\t\r\n+\t\tverify(root, modifier);\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Create a uniform tree with given fan out.\r\n+\t * Persist.\r\n+\t * Verify that the tree is stored by fetching it in a separate persistence\r\n+\t * context.\r\n+\t */\r\n+\tTreeNode create(int[] original) {\r\n+\t\tTreeNode root = new TreeNode();\r\n+\t\troot.createTree(original);\r\n+\t\t\r\n+\t\tEntityManager em = emf.createEntityManager();\r\n+\t\tem.getTransaction().begin();\r\n+\t\tem.persist(root);\r\n+\t\tem.getTransaction().commit();\r\n+\t\tem.clear();\r\n+\t\t\r\n+\t\treturn root;\r\n+\t}\r\n+\t\r\n+\tvoid verify(TreeNode node, int[] fanOuts) {\r\n+\t\tEntityManager em = emf.createEntityManager();\r\n+\t\tem.getTransaction().begin();\r\n+\t\tTreeNode test = em.find(TreeNode.class, node.getId());\r\n+\t\tassertNotNull(test);\r\n+\t\tassertArrayEquals(fanOuts, test.getFanOuts());\r\n+\t}\r\n+\r\n+\t/** Asserts the given arrays have exactly same elements at the same index.\r\n+\t*/\r\n+\tvoid assertArrayEquals(int[] a, int[] b) {\r\n+\t\tassertEquals(a.length, b.length);\r\n+\t\tfor (int i = 0; i<a.length; i++)\r\n+\t\t\tassertEquals(a[i], b[i]);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Asserts that the given object is a proxy collection and whether it is \r\n+\t * tracking changes.\r\n+\t */\r\n+\tvoid assertProxyCollection(Object o, boolean tracking) {\r\n+\t\tassertTrue(o instanceof ProxyCollection);\r\n+\t\tChangeTracker tracker = ((ProxyCollection)o).getChangeTracker();\r\n+\t\tif (tracking) {\r\n+\t\t\tassertNotNull(tracker);\r\n+\t\t\tassertTrue(tracker.isTracking());\r\n+\t\t} else {\r\n+\t\t\tassertFalse(tracker.isTracking());\r\n+\t\t}\r\n+\t}\r\n+}\r"},{"sha":"da409823a0a3a2e69c936fa65d0c79a080990fc9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/proxy/TreeNode.java","status":"added","additions":213,"deletions":0,"changes":213,"blob_url":"https://github.com/apache/openjpa/blob/a7464c7e0a4162d4a574d3d31190b3ac11828eb2/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/proxy/TreeNode.java","raw_url":"https://github.com/apache/openjpa/raw/a7464c7e0a4162d4a574d3d31190b3ac11828eb2/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/proxy/TreeNode.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/proxy/TreeNode.java?ref=a7464c7e0a4162d4a574d3d31190b3ac11828eb2","patch":"@@ -0,0 +1,213 @@\n+package org.apache.openjpa.persistence.proxy;\r\n+\r\n+import java.io.PrintStream;\r\n+import java.io.Serializable;\r\n+import java.util.ArrayList;\r\n+import java.util.Collections;\r\n+import java.util.List;\r\n+\r\n+import javax.persistence.CascadeType;\r\n+import javax.persistence.Entity;\r\n+import javax.persistence.FetchType;\r\n+import javax.persistence.GeneratedValue;\r\n+import javax.persistence.Id;\r\n+import javax.persistence.OneToMany;\r\n+import javax.persistence.Table;\r\n+import javax.persistence.Version;\r\n+\r\n+import org.apache.openjpa.persistence.DetachedState;\r\n+import org.apache.openjpa.persistence.ElementDependent;\r\n+import org.apache.openjpa.persistence.jdbc.ElementJoinColumn;\r\n+import org.apache.openjpa.persistence.jdbc.OrderColumn;\r\n+\r\n+/**\r\n+ * Persistent entity for testing adding/removing elements of collection valued\r\n+ * field while in detached state.\r\n+ * \r\n+ * Node refers to a list of Nodes as children.\r\n+ * \r\n+ * Contains recursive methods to create or modify uniform subtree. Uniform\r\n+ * subtree implies that each child at a level L has equal number of\r\n+ * grand children at level L+1.\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ * \r\n+ */\r\n+@Entity\r\n+@DetachedState\r\n+public class TreeNode implements Serializable {\r\n+\t@Id\r\n+\t@GeneratedValue\r\n+\tprivate long id;\r\n+\r\n+\tprivate String name;\r\n+\r\n+\t@OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\r\n+\t@ElementJoinColumn(name = \"ParentID\")\r\n+\t@OrderColumn(name = \"Sequence\")\r\n+\t@ElementDependent\r\n+\tprivate List<TreeNode> childern = new ArrayList<TreeNode>();\r\n+\r\n+\t@Version\r\n+\tprivate int version;\r\n+\r\n+\tpublic long getId() {\r\n+\t\treturn id;\r\n+\t}\r\n+\r\n+\tpublic String getName() {\r\n+\t\treturn name;\r\n+\t}\r\n+\r\n+\tpublic void setName(String name) {\r\n+\t\tthis.name = name;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Add a child node at the end of the current list of children.\r\n+\t */\r\n+\tpublic void addNode(TreeNode node) {\r\n+\t\taddNode(node, childern.size());\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Insert a child node at the specified position in the list of children.\r\n+\t */\r\n+\tpublic void addNode(TreeNode node, int position) {\r\n+\t\tcheckSequenceRange(position);\r\n+\t\tchildern.add(position, node);\r\n+\t}\r\n+\r\n+\tpublic boolean removeNode(TreeNode node) {\r\n+\t\treturn childern.remove(node);\r\n+\t}\r\n+\r\n+\tpublic TreeNode removeNode(int sequence) {\r\n+\t\tcheckSequenceRange(sequence);\r\n+\t\treturn childern.remove(sequence);\r\n+\t}\r\n+\r\n+\tpublic TreeNode getNode(int sequence) {\r\n+\t\tcheckSequenceRange(sequence);\r\n+\t\treturn childern.get(sequence);\r\n+\t}\r\n+\r\n+\tpublic List<TreeNode> getNodes() {\r\n+\t\treturn childern;\r\n+\t}\r\n+\r\n+\tpublic void clearNodes() {\r\n+\t\tchildern.clear();\r\n+\t}\r\n+\r\n+\tpublic boolean isLeaf() {\r\n+\t\treturn childern.isEmpty();\r\n+\t}\r\n+\r\n+\tprotected void checkSequenceRange(int sequence)\r\n+\t\t\tthrows IllegalArgumentException {\r\n+\t\tint size = childern.size();\r\n+\t\tif (sequence < 0 || sequence > size)\r\n+\t\t\tthrow new IllegalArgumentException(\"Sequence number is beyond \"\r\n+\t\t\t\t\t+ \"range of 0 to \" + size + \".\");\r\n+\t}\r\n+\r\n+\tpublic int getVersion() {\r\n+\t\treturn version;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create a uniform subtree below the receiver. Uniform subtree implies that\r\n+\t * each child at a level L has equal number of grand children at level L+1.\r\n+\t * \r\n+\t * @param fanOuts\r\n+\t *            array of fan outs for children at every level.\r\n+\t */\r\n+\tpublic void createTree(int[] fanOuts) {\r\n+\t\tif (fanOuts.length == 0)\r\n+\t\t\treturn;\r\n+\t\tint[] nextFanOuts = new int[fanOuts.length];\r\n+\t\tSystem.arraycopy(fanOuts, 1, nextFanOuts, 0, fanOuts.length - 1);\r\n+\t\tfor (int j = 0; j < fanOuts[0]; j++) {\r\n+\t\t\tTreeNode child = new TreeNode();\r\n+\t\t\tchild.setName(getName() + \".\" + j);\r\n+\t\t\taddNode(child);\r\n+\t\t\tchild.createTree(nextFanOuts);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Add or remove subtree of the receiver to match the given fanOut.\r\n+\t */\r\n+\tpublic void modify(int[] fanOuts) {\r\n+\t\tif (fanOuts == null || fanOuts.length == 0)\r\n+\t\t\treturn;\r\n+\t\tint n = fanOuts[0];\r\n+\t\tint[] nextFanOuts = new int[fanOuts.length];\r\n+\t\tSystem.arraycopy(fanOuts, 1, nextFanOuts, 0, fanOuts.length - 1);\r\n+\t\tList<TreeNode> children = getNodes();\r\n+\t\tint diff = children.size() - n;\r\n+\t\tif (diff < 0) {\r\n+\t\t\tfor (int i = 0; i < -diff; i++) {\r\n+\t\t\t\tTreeNode newChild = new TreeNode();\r\n+\t\t\t\tint position = getNodes().size();\r\n+\t\t\t\tnewChild.setName(getName() + \".\" + position);\r\n+\t\t\t\taddNode(newChild);\r\n+\t\t\t}\r\n+\t\t} else if (diff > 0) {\r\n+\t\t\tfor (int i = 0; i < diff; i++) {\r\n+\t\t\t\tint position = getNodes().size() - 1;\r\n+\t\t\t\tremoveNode(position);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\tchildren = getNodes();\r\n+\t\tfor (TreeNode child : children) {\r\n+\t\t\tchild.modify(nextFanOuts);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Get the fan outs of the given receiver. Assumes that the subtree is\r\n+\t * uniform. Otherwise throws exception.\r\n+\t */\r\n+\tpublic int[] getFanOuts() {\r\n+\t\treturn getFanOuts(new int[] {});\r\n+\t}\r\n+\r\n+\tprivate int[] getFanOuts(int[] list) {\r\n+\t\tList<TreeNode> children = getNodes();\r\n+\t\tif (children.isEmpty())\r\n+\t\t\treturn list;\r\n+\t\tint[] fanOuts = new int[children.size()];\r\n+\t\tint i = 0;\r\n+\t\tfor (TreeNode child : children) {\r\n+\t\t\tfanOuts[i++] = child.getNodes().size();\r\n+\t\t}\r\n+\t\tfor (int j = 0; j < fanOuts.length - 1; j++)\r\n+\t\t\tif (fanOuts[j] != fanOuts[j + 1])\r\n+\t\t\t\tthrow new RuntimeException(\"non-uniform fanouts for children \"\r\n+\t\t\t\t\t\t+ \" of \" + getName());\r\n+\r\n+\t\tint[] newList = new int[list.length + 1];\r\n+\t\tSystem.arraycopy(list, 0, newList, 0, list.length);\r\n+\t\tnewList[list.length] = children.size();\r\n+\t\treturn children.get(0).getFanOuts(newList);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Prints this receiver and its subtree.\r\n+\t */\r\n+\tpublic void print(PrintStream out) {\r\n+\t\tprint(2, out);\r\n+\t}\r\n+\r\n+\tprivate void print(int tab, PrintStream out) {\r\n+\t\tfor (int i = 0; i < tab; i++)\r\n+\t\t\tout.print(\" \");\r\n+\t\tout.println(getName());\r\n+\t\tfor (TreeNode child : getNodes()) {\r\n+\t\t\tchild.print(tab + 2, out);\r\n+\t\t}\r\n+\t}\r\n+\r\n+}\r"}]}

