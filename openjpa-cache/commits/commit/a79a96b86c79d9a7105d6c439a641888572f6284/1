{"sha":"a79a96b86c79d9a7105d6c439a641888572f6284","node_id":"MDY6Q29tbWl0MjA2MzY0OmE3OWE5NmI4NmM3OWQ5YTcxMDVkNmM0MzlhNjQxODg4NTcyZjYyODQ=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2010-06-16T23:22:31Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2010-06-16T23:22:31Z"},"message":"OPENJPA-1686: Define generic persistent graph and relation. Implement graph as a set of edges.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@955425 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"56852f9eea1105f8063f2137d89a1ae93095734d","url":"https://api.github.com/repos/apache/openjpa/git/trees/56852f9eea1105f8063f2137d89a1ae93095734d"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/a79a96b86c79d9a7105d6c439a641888572f6284","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/a79a96b86c79d9a7105d6c439a641888572f6284","html_url":"https://github.com/apache/openjpa/commit/a79a96b86c79d9a7105d6c439a641888572f6284","comments_url":"https://api.github.com/repos/apache/openjpa/commits/a79a96b86c79d9a7105d6c439a641888572f6284/comments","author":null,"committer":null,"parents":[{"sha":"2e827c5eab3154f62e5a82045af1638fafabb7e7","url":"https://api.github.com/repos/apache/openjpa/commits/2e827c5eab3154f62e5a82045af1638fafabb7e7","html_url":"https://github.com/apache/openjpa/commit/2e827c5eab3154f62e5a82045af1638fafabb7e7"}],"stats":{"total":998,"additions":662,"deletions":336},"files":[{"sha":"400a544fed2b2820f630ad0797aea84b99c0ce98","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/AbstractGraph.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/AbstractGraph.java","raw_url":"https://github.com/apache/openjpa/raw/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/AbstractGraph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/AbstractGraph.java?ref=a79a96b86c79d9a7105d6c439a641888572f6284","patch":"@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.graph;\n+\n+import java.util.AbstractSet;\n+import java.util.Set;\n+\n+/**\n+ * Abstract implementation of a {@linkplain Graph} borrows from {@link AbstractSet abstract} implementation of \n+ * {@link Set}. The extended {@link Set#remove(Object) remove()} semantics accounts for \n+ * {@link Graph#delink(Object, Object) removal} of all relationship to the removed element.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ * @param <E> type of element of the graph.\n+ */\n+public abstract class AbstractGraph<E> extends AbstractSet<E> implements Graph<E> {\n+    /**\n+     * Removing an element from this graph has the side effect of removing all \n+     * relations directed to the removed element.\n+     */\n+    @Override\n+    public boolean remove(Object e) {\n+        E node = (E)e;\n+        Set<Relation<E, E>> rs = getRelationsTo(node);\n+        for (Relation<E,E> r : rs) {\n+            delink(r.getSource(), node);\n+        }\n+        return super.remove(e);\n+    }\n+}"},{"sha":"559311c3d2310c349dff35aca31f273546a7a26f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/City.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/City.java","raw_url":"https://github.com/apache/openjpa/raw/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/City.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/City.java?ref=a79a96b86c79d9a7105d6c439a641888572f6284","patch":"@@ -18,20 +18,20 @@\n  */\n package org.apache.openjpa.persistence.graph;\n \n+import java.io.Serializable;\n+\n import javax.persistence.Entity;\n import javax.persistence.Id;\n \n /**\n  * A simple persistent entity to become member of a graph.\n- * In this style, a type has to extend {@linkplain Vertex} - an abstract persistent type.\n- * This persistent type has its own identity.\n  * \n  * @author Pinaki Poddar\n  *\n  */\n @SuppressWarnings(\"serial\")\n @Entity\n-public class City extends Vertex<City> {\n+public class City implements Serializable {\n     @Id\n     private String name;\n "},{"sha":"ba952422a4128518b975f7d68e6204fbc717a070","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Graph.java","status":"added","additions":109,"deletions":0,"changes":109,"blob_url":"https://github.com/apache/openjpa/blob/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Graph.java","raw_url":"https://github.com/apache/openjpa/raw/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Graph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Graph.java?ref=a79a96b86c79d9a7105d6c439a641888572f6284","patch":"@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.graph;\n+\n+import java.util.Set;\n+\n+/**\n+ * Graph is an extended {@link java.util.Set Set} that is aware of {@link Relation relationship} \n+ * between its elements. The linkage between two elements is represented by a {@link Relation relation}.\n+ * <br>\n+ * The extended behavior of Set allows two member elements to be {@linkplain Graph#link(Object, Object) linked} \n+ * or {@linkplain Graph#delink(Object, Object) delinked}. \n+ * \n+ * @param <E> Type of element of the graph\n+ * \n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+public interface Graph<E> extends Set<E> {\n+    /**\n+     * Links the pair of given vertices.\n+     * If the pair is already linked then the existing relation is returned.\n+     * If either of the vertices are currently non a member of this graph,\n+     * then they are added to the graph as a side-effect of linking.\n+     *  \n+     * @param source non-null source node \n+     * @param target non-null target node\n+     * \n+     * @param <V1> generic type of source node \n+     * @param <V2> generic type of target node\n+     *\n+     * @return a relation \n+     */\n+    public <V1 extends E, V2 extends E> Relation<V1, V2> link(V1 source, V2 target);\n+\n+    /**\n+     * Breaks the relation between the given pair of nodes.\n+     * \n+     * @param source non-null source node \n+     * @param target non-null target node\n+     * \n+     * @param <V1> generic type of source node \n+     * @param <V2> generic type of target node\n+     * \n+     * @return the existing relation, if any, that had been broken. null otherwise.\n+     */\n+    public <V1 extends E, V2 extends E> Relation<V1, V2> delink(V1 source, V2 target);\n+\n+    /**\n+     * Gets the directed relation between the given pair of nodes, if exists.\n+     *  \n+     * @param source non-null source node \n+     * @param target non-null target node\n+     * \n+     * @param <V1> generic type of source node \n+     * @param <V2> generic type of target node\n+     *\n+     * @return a relation between the nodes, if exists. null otherwise. \n+     */\n+    public <V1 extends E, V2 extends E> Relation<V1, V2> getRelation(V1 source, V2 target);\n+    \n+    /**\n+     * Gets the nodes that are directly reachable from the given source node.\n+     * \n+     * @return set of target nodes. Empty set if the given source node is not connected to any other nodes.\n+     */\n+    public Set<E> getTargets(E source);\n+    \n+    \n+    /**\n+     * Gets the source nodes that are directly connected to the given target node.\n+     * \n+     * @return set of source nodes. Empty set if the given target node is not connected from any node.\n+     */\n+    public Set<E> getSources(E target);\n+    \n+    /**\n+     * Gets all the relations originating from the given source.\n+     * @param <V>\n+     * @param source\n+     * @return\n+     */\n+    public <V extends E> Set<Relation<V,E>> getRelationsFrom(V source);\n+    \n+    /**\n+     * Gets all the relations terminating on the given target.\n+     * @param <V>\n+     * @param target\n+     * @return\n+     */\n+    public <V extends E> Set<Relation<E,V>> getRelationsTo(V target);\n+}"},{"sha":"7628dfab425bfa3e5416102198904d6d7e62edc6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/People.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/People.java","raw_url":"https://github.com/apache/openjpa/raw/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/People.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/People.java?ref=a79a96b86c79d9a7105d6c439a641888572f6284","patch":"@@ -18,23 +18,24 @@\n  */\n package org.apache.openjpa.persistence.graph;\n \n+import java.io.Serializable;\n+\n import javax.persistence.Entity;\n import javax.persistence.Id;\n \n /**\n  * A simple persistent entity to become member of a graph.\n- * In this style, a type has to extend {@linkplain Vertex} - an abstract persistent type.\n- * This persistent type has its own identity.\n  * \n  * @author Pinaki Poddar\n  *\n  */\n @SuppressWarnings(\"serial\")\n @Entity\n-public class People extends Vertex<People>{\n+public class People implements Serializable {\n     @Id\n     private long ssn;\n     private String name;\n+    \n     public long getSsn() {\n         return ssn;\n     }"},{"sha":"d19e2f2aee5174b621cd8df664c75cd83620ecfd","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/PersistentGraph.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/PersistentGraph.java","raw_url":"https://github.com/apache/openjpa/raw/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/PersistentGraph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/PersistentGraph.java?ref=a79a96b86c79d9a7105d6c439a641888572f6284","patch":"@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.graph;\n+\n+import java.io.Serializable;\n+\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+import javax.persistence.MappedSuperclass;\n+\n+/**\n+ * Persistent Graph is a marker for persistent version of a {@link Graph}.\n+ * <br>\n+ * A persistent graph does not declare how the persistent state of the graph is captured and hence is abstract.\n+ * But Persistent Graph is unique to be persistent in a JPA sense, because JPA does <em>not</em> represent \n+ * container instances such as {@link java.util.Set} or {@link java.util.List} as <em>first class</em> type --\n+ * i.e. their instances do not carry a persistent identity. But declaring a graph as persistent type amounts\n+ * to represent the graph as a first class persistent type with its own persistent identity.  \n+ * <br>\n+ * Persistent Graph defines a auto-generated persistent identity.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ * @param <E> type of element.\n+ */\n+@SuppressWarnings(\"serial\")\n+@MappedSuperclass\n+public abstract class PersistentGraph<E> extends AbstractGraph<E> implements Serializable {\n+    \n+    @Id\n+    @GeneratedValue\n+    private long id;\n+    \n+    public final long getId() {\n+        return id;\n+    }\n+}"},{"sha":"4744103bb29d3fadf63ec80290df09de97dfc13c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/PersistentRelation.java","status":"added","additions":193,"deletions":0,"changes":193,"blob_url":"https://github.com/apache/openjpa/blob/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/PersistentRelation.java","raw_url":"https://github.com/apache/openjpa/raw/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/PersistentRelation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/PersistentRelation.java?ref=a79a96b86c79d9a7105d6c439a641888572f6284","patch":"@@ -0,0 +1,193 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.graph;\n+\n+import java.io.Serializable;\n+import java.util.Properties;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToMany;\n+import javax.persistence.OneToOne;\n+\n+/**\n+ * Generic, directed, attributed Relation as a first-class, persistent entity.\n+ * <br>\n+ * A relation is \n+ * <ol>\n+ * <LI>generic because Relation type is parameterized with the type of vertices it links.\n+ * <LI>directed because it distinguishes the two vertices as source and target.\n+ * <LI>attributed because any arbitrary name-value pair can be associated with a relation.\n+ * </ol>\n+ * A relation is made persistence capable by annotating its generic source and target as persistent entity.\n+ * A relation is also a <em>first-class</em> entity having its own persistent identifier.\n+ * <br>\n+ * A relation is immutable in terms of its two vertices. The properties\n+ * attached to a relation, however, can change.\n+ * <br>\n+ * @param <V1> the type of <em>source</em> vertex linked by this relation.\n+ * @param <V2> the type of <em>target</em> vertex linked by this relation.\n+ *  \n+ * @author Pinaki Poddar\n+ *\n+ */\n+@SuppressWarnings(\"serial\")\n+@Entity\n+public class PersistentRelation<V1,V2> implements Relation<V1,V2>, Serializable {\n+    /**\n+     * Relation is a first class object with its own identifier.\n+     */\n+    @Id\n+    @GeneratedValue\n+    private long id;\n+    \n+    /**\n+     * A Relation must have a non-null vertex as source.\n+     */\n+    @OneToOne(optional=false, targetEntity=Entity.class, \n+            cascade={CascadeType.PERSIST,CascadeType.MERGE, CascadeType.DETACH, CascadeType.REFRESH})\n+    private V1 source;\n+    \n+    /**\n+     * A Relation may have a non-null vertex as target.\n+     */\n+    @OneToOne(optional=true, targetEntity=Entity.class,\n+            cascade={CascadeType.PERSIST,CascadeType.MERGE, CascadeType.DETACH, CascadeType.REFRESH})\n+    private V2 target;\n+    \n+    /**\n+     * The properties of a Relation is a set of key-value pairs and is declared as \n+     * <code>java.util.Properties</code>.\n+     * <br>\n+     * Declaring the key-value pairs as <code>java.util.Properties</code> makes OpenJPA\n+     * assume that both key and value will be stored in database as String.\n+     * This is not <em>strictly</em> correct because <code>java.util.Properties</code>\n+     * declares its key and value as <code>java.lang.Object</code>. Hence it is possible for an application\n+     * to insert key and/or value that are not a String but that type information will not be preserved in\n+     * the database. Subsequently, when loaded from database the key and value\n+     * both will appear as String and hence it becomes the application's responsibility to decode the\n+     * Strings back to the actual type. While this provision loses type information, it allows the\n+     * database record to be readable and more importantly supports query that are predicated on \n+     * (equality only) key-value pairs.\n+     * <br>\n+     * Another possibility to express key-value pair as\n+     * <br>\n+     * <code>Map<String,Serializable> attrs;</code>\n+     * <br> \n+     * This will serialize the values but preserve their types. The down-side is neither a query can be \n+     * predicated on value nor are the database records readable.  \n+     * <br>\n+     * The third alternative is a Map where keys are String and values are Object \n+     * <br>\n+     * <code>Map<String,Object> attrs;</code>\n+     * This leads to the whole map being serialized as a single blob of data.\n+     */\n+    @ManyToMany(cascade={CascadeType.ALL},fetch=FetchType.LAZY)\n+    private Properties attrs;\n+    \n+    /**\n+     * Special constructor for byte code enhancement.\n+     */\n+    protected PersistentRelation() {\n+    }\n+    \n+    /**\n+     * A relation is immutable in terms of two vertices it connects.\n+     * \n+     * @param s source vertex must not be null.\n+     * @param t target vertex may or may not be null.\n+     */\n+    public PersistentRelation(V1 s, V2 t) {\n+        if (s == null)\n+            throw new NullPointerException(\"Can not create relation from a null source vertex\");\n+        source = s;\n+        target = t;\n+        attrs = new Properties();\n+    }\n+    \n+    /**\n+     * Gets generated persistent identity.\n+     */\n+    public long getId() {\n+        return id;\n+    }\n+    \n+    /**\n+     * Gets the immutable source vertex.\n+     */\n+    public V1 getSource() {\n+        return source;\n+    }\n+    \n+    /**\n+     * Gets the immutable target vertex.\n+     */\n+    public V2 getTarget() {\n+        return target;\n+    }\n+    \n+    /**\n+     * Affirms if the given attribute is associated with this relation.\n+     */\n+    public boolean hasAttribute(String attr) {\n+        return attrs.containsKey(attr);\n+    }\n+    \n+    /**\n+     * Gets the value of the given attribute.\n+     * \n+     * @return value of the given attribute. A null value does not distinguish whether\n+     * the attribute was set to a null value or the attribute was absent. \n+     */\n+    public Object getAttribute(String attr) {\n+        return attrs.get(attr);\n+    }\n+    \n+    public Properties getAttributes() {\n+        return attrs;\n+    }\n+\n+    /**\n+     * Adds the given key-value pair, overwriting any prior association to the same attribute.\n+     * \n+     * @return the same relation for fluent method-chaining\n+     */\n+    public Relation<V1,V2> addAttribute(String attr, Object v) {\n+        attrs.put(attr, v);\n+        return this;\n+    }\n+    \n+    /**\n+     * Removes the given attribute.\n+     * \n+     * @return value of the given attribute that just has been removed. A null value does not \n+     * distinguish whether the attribute was set to a null value or the attribute was absent. \n+     */\n+    public Relation<V1,V2> removeAttribute(String attr) {\n+        attrs.remove(attr);\n+        return this;\n+    }\n+    \n+    public String toString() {\n+        return source + \"->\" + target;\n+    }\n+}"},{"sha":"e8b5b1f871de9b9a5adf74af329ab84125f0ff33","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Relation.java","status":"modified","additions":32,"deletions":123,"changes":155,"blob_url":"https://github.com/apache/openjpa/blob/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Relation.java","raw_url":"https://github.com/apache/openjpa/raw/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Relation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Relation.java?ref=a79a96b86c79d9a7105d6c439a641888572f6284","patch":"@@ -18,167 +18,76 @@\n  */\n package org.apache.openjpa.persistence.graph;\n \n-import java.io.Serializable;\n import java.util.Properties;\n \n-import javax.persistence.CascadeType;\n-import javax.persistence.Entity;\n-import javax.persistence.FetchType;\n-import javax.persistence.GeneratedValue;\n-import javax.persistence.Id;\n-import javax.persistence.ManyToMany;\n-import javax.persistence.OneToOne;\n-\n /**\n- * Generic, directed, attributed Relation as a first-class entity.\n+ * Generic, directed, attributed Relation.\n  * <br>\n  * A relation is \n  * <ol>\n- * <LI>generic because the vertices it links are generically typed.\n- * <LI>directed because it distinguishes the two end points as source and target.\n- * <LI>attributed because any arbitrary name-value pair can be associated with a relation.\n+ * <LI>generic because Relation type is parameterized with the type of vertices it links.\n+ * <LI>directed because it distinguishes the two vertices as source and target.\n+ * <LI>attributed because any arbitrary key-value pair can be associated with a relation.\n  * </ol>\n+ * <br>\n  * A relation is immutable in terms of its two vertices. The properties\n- * attached to a relation can change.\n- *\n+ * associated to a relation, however, can change.\n+ * <br>\n  * @param <V1> the type of <em>source</em> vertex linked by this relation.\n  * @param <V2> the type of <em>target</em> vertex linked by this relation.\n  *  \n  * @author Pinaki Poddar\n  *\n  */\n-@SuppressWarnings(\"serial\")\n-@Entity\n-public class Relation<V1,V2> implements Serializable {\n-    /**\n-     * Relation is a first class object with its own identifier.\n-     */\n-    @Id\n-    @GeneratedValue\n-    private long id;\n-    \n-    /**\n-     * A Relation must have a non-null vertex as source.\n-     */\n-    @OneToOne(optional=false)\n-    private Vertex<V1> source;\n-    \n-    /**\n-     * A Relation must have a non-null vertex as source.\n-     */\n-    @OneToOne(optional=false)\n-    private Vertex<V2> target;\n-    \n+public interface Relation<V1,V2> {\n     /**\n-     * The properties of a Relation is a set of key-value pairs and is declared as \n-     * <code>java.util.Properties</code>.\n-     * <br>\n-     * Declaring the key-value pairs as <code>java.util.Properties</code> makes OpenJPA\n-     * assume that both key and value will be stored in database as String.\n-     * This is not <em>strictly</em> correct because <code>java.util.Properties</code>\n-     * declares its key and value as <code>java.lang.Object</code>. Hence it is possible for an application\n-     * to insert key and/or value that are not a String but that type information will not be preserved in\n-     * the database. Subsequently, when loaded from database the key and value\n-     * both will appear as String and hence it becomes the application's responsibility to decode the\n-     * Strings back to the actual type. While this provision loses type information, it allows the\n-     * database record to be readable and more importantly supports query that are predicated on \n-     * (equality only) key-value pairs.\n-     * <br>\n-     * Another possibility to express key-value pair as\n-     * <br>\n-     * <code>Map<String,Serializable> attrs;</code>\n-     * <br> \n-     * This will serialize the values but preserve their types. The down-side is neither a query can be \n-     * predicated on value nor are the database records readable.  \n-     * <br>\n-     * The third alternative is a Map where keys are String and values are Object \n-     * <br>\n-     * <code>Map<String,Object> attrs;</code>\n-     * This leads to the whole map being serialized as a single blob of data.\n+     * Gets the immutable source vertex.\n+     * \n+     * @return a non-null source vertex.\n      */\n-    @ManyToMany(cascade={CascadeType.ALL},fetch=FetchType.LAZY)\n-    private Properties attrs;\n+    public V1 getSource();\n     \n     /**\n-     * Special constructor for byte code enhancement.\n+     * Gets the immutable target vertex.\n+     * Unlike source, a target for a relation may be null.\n+     * \n+     * @return a target vertex. May be null.\n      */\n-    protected Relation() {\n-    }\n+    public V2 getTarget();\n     \n-    /**\n-     * A relation is immutable in terms of two vertices it connects.\n-     * Either vertex must not be null.\n-     */\n-    public Relation(Vertex<V1> s, Vertex<V2> t) {\n-        if (s == null)\n-            throw new NullPointerException(\"Can not create relation from a null source vertex\");\n-        if (t == null)\n-            throw new NullPointerException(\"Can not create relation to a null target vertex\");\n-        source = s;\n-        target = t;\n-        attrs = new Properties();\n-    }\n     \n     /**\n-     * Gets generated persistent identity.\n+     * Adds the given key-value pair, overwriting any prior value associated to the same key.\n+     * \n+     * @return the same relation for <em>fluent</em> method-chaining\n      */\n-    public long getId() {\n-        return id;\n-    }\n-    \n-    /**\n-     * Gets the immutable source vertex.\n-    */\n-    public Vertex<V1> getSource() {\n-        return source;\n-    }\n-    \n-    /**\n-     * Gets the immutable target vertex.\n-    */\n-    public Vertex<V2> getTarget() {\n-        return target;\n-    }\n+    public Relation<V1,V2> addAttribute(String key, Object value);\n     \n     /**\n-     * Affirms if the given attribute is associated with this relation.\n+     * Affirms if an attribute value has been associated with the given key.\n+     * \n      */\n-    public boolean hasAttribute(String attr) {\n-        return attrs.containsKey(attr);\n-    }\n+    public boolean hasAttribute(String key);\n     \n     /**\n      * Gets the value of the given attribute.\n      * \n      * @return value of the given attribute. A null value does not distinguish whether\n      * the attribute was set to a null value or the attribute was absent. \n+     * \n+     * @see #hasAttribute(String)\n      */\n-    public Object getAttribute(String attr) {\n-        return attrs.get(attr);\n-    }\n+    public Object getAttribute(String key);\n     \n-    public Properties getAttributes() {\n-        return attrs;\n-    }\n-\n     /**\n-     * Adds the given key-value pair, overwriting any prior association to the same attribute.\n+     * Removes the given attribute.\n      * \n-     * @return the same relation for fluent method-chaining\n+     * @return the modified relation for <em>fluent</em> method chaining.\n      */\n-    public Relation<V1,V2> addAttribute(String attr, Object v) {\n-        attrs.put(attr, v);\n-        return this;\n-    }\n+    public Relation<V1,V2> removeAttribute(String key);\n     \n     /**\n-     * Removes the given attribute.\n-     * \n-     * @return value of the given attribute that just has been removed. A null value does not \n-     * distinguish whether the attribute was set to a null value or the attribute was absent. \n+     * Gets the key-value pairs associated with this relation.\n      */\n-    public Relation<V1,V2> removeAttribute(String attr) {\n-        attrs.remove(attr);\n-        return this;\n-    }\n+    public Properties getAttributes();\n }"},{"sha":"5fd7db58c8197fa25d0646fa099a6407bc11091b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/RelationGraph.java","status":"added","additions":163,"deletions":0,"changes":163,"blob_url":"https://github.com/apache/openjpa/blob/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/RelationGraph.java","raw_url":"https://github.com/apache/openjpa/raw/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/RelationGraph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/RelationGraph.java?ref=a79a96b86c79d9a7105d6c439a641888572f6284","patch":"@@ -0,0 +1,163 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.graph;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n+import javax.persistence.OneToMany;\n+\n+/**\n+ * RelationGraph is a first-class persistent entity that express its persistent state as a set of\n+ * {@link Relation persistent relations}.\n+ *  \n+ * @author Pinaki Poddar\n+ *\n+ */\n+\n+@SuppressWarnings(\"serial\")\n+@Entity\n+public class RelationGraph<E> extends PersistentGraph<E>  {\n+    @OneToMany(cascade={CascadeType.PERSIST,CascadeType.MERGE, CascadeType.DETACH, CascadeType.REFRESH})\n+    private Set<PersistentRelation<E,E>> relations = new HashSet<PersistentRelation<E,E>>();\n+    \n+    /* \n+     * Links the given vertices, unless they are already connected.\n+     * \n+     * @param source non-null source vertex\n+     * @param target non-null target vertex\n+     * \n+     * @see org.apache.openjpa.persistence.graph.Graph#link(V1, V2)\n+     */\n+    public <V1 extends E,V2 extends E> Relation<V1,V2> link(V1 source, V2 target) {\n+        if (source == null)\n+            throw new NullPointerException(\"Can not link from a null source vertex\");\n+        if (target == null)\n+            throw new NullPointerException(\"Can not link to a null target vertex\");\n+        \n+        Relation<V1,V2> r = getRelation(source, target);\n+        if (r == null) {\n+            r = new PersistentRelation<V1, V2>(source, target);\n+            relations.add((PersistentRelation<E, E>) r);\n+        }\n+        return r;\n+        \n+    }\n+    \n+    /* \n+     * Delinks the given vertices, if they are currently connected.\n+     * \n+     * \n+     * @see org.apache.openjpa.persistence.graph.Graph#delink(V1, V2)\n+     */\n+    public <V1 extends E,V2 extends E> Relation<V1,V2> delink(V1 source, V2 target) {\n+        Relation<V1,V2> r = getRelation(source, target);\n+        if (r != null) {\n+            relations.remove(r);\n+        }\n+        return r;\n+        \n+    }\n+    \n+    /* \n+     * Get the relation between the given vertex.\n+     *  \n+     * @see org.apache.openjpa.persistence.graph2.Graph#getRelation(V1, V2)\n+     */\n+    public <V1 extends E,V2 extends E> Relation<V1,V2> getRelation(V1 source, V2 target) {\n+        for (Relation<?,?> r : relations) {\n+            if (r.getSource().equals(source) && r.getTarget() != null && r.getTarget().equals(target)) {\n+                return (Relation<V1,V2>)r;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * Iterator over the nodes of this graph.\n+     */\n+    public Iterator<E> iterator() {\n+        return getNodes().iterator();\n+    }\n+    \n+    public int size() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public <V extends E> Set<Relation<V, E>> getRelationsFrom(V source) {\n+        Set<Relation<V,E>> rs = new HashSet<Relation<V,E>>();\n+        for (Relation<E,E> r : relations) {\n+            if (r.getSource().equals(source) && r.getTarget() != null)\n+                rs.add((Relation<V,E>)r);\n+        }\n+        return rs;\n+    }\n+\n+    @Override\n+    public <V extends E> Set<Relation<E, V>> getRelationsTo(V target) {\n+        Set<Relation<E, V>> rs = new HashSet<Relation<E, V>>();\n+        for (Relation<?,?> r : relations) {\n+            if (r.getTarget() != null && r.getTarget().equals(target))\n+                rs.add((Relation<E, V>)r);\n+        }\n+        return rs;\n+    }\n+\n+    @Override\n+    public Set<E> getSources(Object target) {\n+        Set<E> sources = new HashSet<E>();\n+        for (Relation<E,E> r : relations) {\n+            if (r.getTarget() != null && r.getTarget().equals(target))\n+                sources.add(r.getSource());\n+        }\n+        return sources;\n+    }\n+\n+    @Override\n+    public Set<E> getTargets(Object source) {\n+        Set<E> targets = new HashSet<E>();\n+        for (Relation<E,E> r : relations) {\n+            if (r.getSource().equals(source) && r.getTarget() != null)\n+                targets.add(r.getTarget());\n+        }\n+        return targets;\n+    }\n+    \n+    public Set<E> getNodes() {\n+        Set all = new HashSet();\n+        for (Relation<?,?> r : relations) {\n+            all.add(r.getSource());\n+            if (r.getTarget() != null)\n+                all.add(r.getTarget());\n+        }\n+        return all;\n+    }\n+    \n+    @Override\n+    public boolean add(E e) {\n+        if (contains(e))\n+            return false;\n+        relations.add(new PersistentRelation<E,E>(e,null));\n+        return true;\n+    }\n+}"},{"sha":"2d24aa92ddc8a24badcfdd7aee1557177a8e0b20","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/TestPersistentGraph.java","status":"modified","additions":58,"deletions":52,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/TestPersistentGraph.java","raw_url":"https://github.com/apache/openjpa/raw/a79a96b86c79d9a7105d6c439a641888572f6284/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/TestPersistentGraph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/TestPersistentGraph.java?ref=a79a96b86c79d9a7105d6c439a641888572f6284","patch":"@@ -32,13 +32,11 @@\n import org.apache.openjpa.jdbc.meta.ValueHandler;\n import org.apache.openjpa.jdbc.meta.strats.HandlerFieldStrategy;\n import org.apache.openjpa.jdbc.meta.strats.HandlerHandlerMapTableFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.RelationCollectionInverseKeyFieldStrategy;\n import org.apache.openjpa.jdbc.meta.strats.UntypedPCValueHandler;\n import org.apache.openjpa.kernel.QueryHints;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n import org.apache.openjpa.meta.MetaDataRepository;\n-import org.apache.openjpa.persistence.OpenJPAPersistence;\n import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n \n /**\n@@ -80,23 +78,23 @@\n     };\n \n     private EntityManager em;\n-\n+    private PersistentGraph<Object> graph;\n+    \n     public void setUp() throws Exception {\n-        super.setUp(CLEAR_TABLES, Vertex.class, Relation.class, People.class, City.class);\n+        super.setUp(CLEAR_TABLES, PersistentGraph.class, RelationGraph.class,\n+                PersistentRelation.class, People.class, City.class);\n         em = emf.createEntityManager();\n-        createData();\n+        graph = createData();\n         em.clear();\n     }\n-\n+    \n     /**\n      * Verifies that fields are mapped with expected strategy or value handlers.\n      */\n     public void testMapping() {\n-        assertStrategy(People.class, \"relations\", RelationCollectionInverseKeyFieldStrategy.class, null);\n-        assertStrategy(City.class, \"relations\", RelationCollectionInverseKeyFieldStrategy.class, null);\n-        assertStrategy(Relation.class, \"source\", HandlerFieldStrategy.class, UntypedPCValueHandler.class);\n-        assertStrategy(Relation.class, \"target\", HandlerFieldStrategy.class, UntypedPCValueHandler.class);\n-        assertStrategy(Relation.class, \"attrs\", HandlerHandlerMapTableFieldStrategy.class, null);\n+        assertStrategy(PersistentRelation.class, \"source\", HandlerFieldStrategy.class, UntypedPCValueHandler.class);\n+        assertStrategy(PersistentRelation.class, \"target\", HandlerFieldStrategy.class, UntypedPCValueHandler.class);\n+        assertStrategy(PersistentRelation.class, \"attrs\", HandlerHandlerMapTableFieldStrategy.class, null);\n     }\n \n     private void printMapping(FieldMapping fm) {\n@@ -111,7 +109,7 @@ private void printMapping(FieldMapping fm) {\n     }\n \n     FieldMapping getFieldMapping(Class<?> pcClass, String field) {\n-        MappingRepository repos = (MappingRepository) OpenJPAPersistence.cast(emf).getConfiguration()\n+        MappingRepository repos = (MappingRepository) emf.getConfiguration()\n                 .getMetaDataRepositoryInstance();\n         ClassMapping cmd = repos.getMapping(pcClass, null, true);\n         assertNotNull(\"No metadata found for \" + pcClass, cmd);\n@@ -123,7 +121,7 @@ FieldMapping getFieldMapping(Class<?> pcClass, String field) {\n \n     /**\n      * Asserts that the given field of the given class has been mapped with the\n-     * given straegy or value handler.\n+     * given strategy or value handler.\n      */\n     void assertStrategy(Class<?> pcClass, String field, Class<? extends FieldStrategy> strategy,\n             Class<? extends ValueHandler> handler) {\n@@ -151,7 +149,7 @@ void assertStrategy(Class<?> pcClass, String field, Class<? extends FieldStrateg\n     }\n \n     FieldStrategy getStrategy(Class<?> cls, String field) {\n-        MetaDataRepository repos = OpenJPAPersistence.cast(emf).getConfiguration().getMetaDataRepositoryInstance();\n+        MetaDataRepository repos = emf.getConfiguration().getMetaDataRepositoryInstance();\n         ClassMetaData cmd = repos.getMetaData(cls, null, true);\n         assertNotNull(\"No metadat found for \" + cls, cmd);\n         FieldMetaData fmd = cmd.getField(field);\n@@ -168,6 +166,9 @@ FieldStrategy getStrategy(Class<?> cls, String field) {\n      */\n     public void testCreateGraph() {\n         em.getTransaction().begin();\n+        assertFalse(em.contains(graph));\n+        graph = em.find(PersistentGraph.class, graph.getId());\n+        assertNotNull(graph);\n         People[] people = new People[SSN.length];\n         for (int i = 0; i < SSN.length; i++) {\n             People p = em.find(People.class, SSN[i]);\n@@ -180,7 +181,7 @@ public void testCreateGraph() {\n             assertNotNull(c);\n             cities[i] = c;\n         }\n-        assertDataEquals(people, cities);\n+        assertDataEquals(graph, people, cities);\n \n         em.getTransaction().rollback();\n     }\n@@ -190,10 +191,11 @@ public void testCreateGraph() {\n      * correctly.\n      */\n     public void testQueryRelation() {\n-        List<Relation> relations = em.createQuery(\"select r from Relation r\", Relation.class).getResultList();\n+        String jpql = \"select r from PersistentRelation r\";\n+        List<PersistentRelation> relations = em.createQuery(jpql, PersistentRelation.class).getResultList();\n         for (Relation<?, ?> r : relations) {\n-            Vertex<?> source = r.getSource();\n-            Vertex<?> target = r.getTarget();\n+            Object source = r.getSource();\n+            Object target = r.getTarget();\n             if (source instanceof People) {\n                 int i = indexOf((People) source);\n                 if (target instanceof People) {\n@@ -204,16 +206,16 @@ public void testQueryRelation() {\n                     int j = indexOf((City) target);\n                     assertEquals(i % CITY_NAMES.length, j);\n                     assertTrue(r.getAttributes().isEmpty());\n-                } else {\n-                    fail();\n+                } else if (target != null){\n+                    fail(\"Unexpected relation \" + r);\n                 }\n             } else if (source instanceof City) {\n                 int i = indexOf((City) source);\n                 if (target instanceof City) {\n                     int j = indexOf((City) target);\n                     assertEquals(\"\"+ATTR_DISTANCE_VALUE[i][j], r.getAttribute(ATTR_DISTANCE));\n-                } else {\n-                    fail();\n+                } else if (target != null) {\n+                    fail(\"Unexpected relation \" + r);\n                 }\n             }\n         }\n@@ -224,8 +226,8 @@ public void testQueryRelation() {\n      */\n     public void testQueryRelationOnSourceParameter() {\n         People p1 = em.find(People.class, SSN[0]);\n-        String jpql = \"select r from Relation r where r.source = :node\";\n-        List<Relation> result = em.createQuery(jpql, Relation.class)\n+        String jpql = \"select r from PersistentRelation r where r.source = :node\";\n+        List<PersistentRelation> result = em.createQuery(jpql, PersistentRelation.class)\n                                   .setParameter(\"node\", p1)\n                                   .getResultList();\n         assertFalse(\"Result of [\" + jpql + \"] on source = \" + p1 + \" should not be empty\", result.isEmpty());\n@@ -235,8 +237,8 @@ public void testQueryRelationOnSourceParameter() {\n      * Tests that a relation can be queried predicated on its attribute key.\n      */\n     public void testQueryRelationOnSingleAttributeKey() {\n-        String jpql = \"select r from Relation r join r.attrs a where key(a) = :key\";\n-        List<Relation> result = em.createQuery(jpql, Relation.class)\n+        String jpql = \"select r from PersistentRelation r join r.attrs a where key(a) = :key\";\n+        List<PersistentRelation> result = em.createQuery(jpql, PersistentRelation.class)\n                                   .setParameter(\"key\", ATTR_EMOTION)\n                                   .getResultList();\n \n@@ -248,9 +250,9 @@ public void testQueryRelationOnSingleAttributeKey() {\n      * key-value pair.\n      */\n     public void testQueryRelationOnSingleAttributeKeyValue() {\n-        String jpql = \"select r from Relation r join r.attrs a where key(a) = :key and value(a) = :value\";\n+        String jpql = \"select r from PersistentRelation r join r.attrs a where key(a) = :key and value(a) = :value\";\n         String value = EMOTIONS[0][2].toString();\n-        List<Relation> result = em.createQuery(jpql, Relation.class)\n+        List<PersistentRelation> result = em.createQuery(jpql, PersistentRelation.class)\n                                   .setParameter(\"key\", ATTR_EMOTION)\n                                   .setParameter(\"value\", value)\n                                   .getResultList();\n@@ -265,10 +267,11 @@ public void testQueryRelationOnSingleAttributeKeyValue() {\n      * wrong result.\n      */\n     public void testQueryRelationOnMultipleAttributeKeyValuePairs() {\n-        String jpql = \"select r from Relation r join r.attrs a1 join r.attrs a2 \"\n-                + \"where key(a1) = :key1 and value(a1) = :value1 \" + \"and key(a2) = :key2 and value(a2) = :value2\";\n+        String jpql = \"select r from PersistentRelation r join r.attrs a1 join r.attrs a2 \"\n+                    + \"where key(a1) = :key1 and value(a1) = :value1 \" \n+                    + \"and key(a2) = :key2 and value(a2) = :value2\";\n         String value = EMOTIONS[0][2].toString();\n-        List<Relation> result = em.createQuery(jpql, Relation.class)\n+        List<PersistentRelation> result = em.createQuery(jpql, PersistentRelation.class)\n                                   .setParameter(\"key1\", ATTR_EMOTION)\n                                   .setParameter(\"value1\", value)\n                                   .setParameter(\"key2\", ATTR_SINCE)\n@@ -279,10 +282,10 @@ public void testQueryRelationOnMultipleAttributeKeyValuePairs() {\n                 + \") and key-value=(\"  + ATTR_SINCE + \",\" + SINCE + \") should not be empty\", \n                 result.isEmpty());\n \n-        String wrongJPQL = \"select r from Relation r join r.attrs a \"  \n+        String wrongJPQL = \"select r from PersistentRelation r join r.attrs a \"  \n                          + \"where key(a) = :key1 and value(a) = :value1 \"\n                          + \"and key(a) = :key2 and value(a) = :value2\";\n-        List<Relation> result2 = em.createQuery(wrongJPQL, Relation.class)\n+        List<PersistentRelation> result2 = em.createQuery(wrongJPQL, PersistentRelation.class)\n                                    .setParameter(\"key1\", ATTR_EMOTION)\n                                    .setParameter(\"value1\", value)\n                                    .setParameter(\"key2\", ATTR_SINCE)\n@@ -297,8 +300,8 @@ public void testQueryRelationOnMultipleAttributeKeyValuePairs() {\n     public void testAddRemoveAttribute() {\n         em.getTransaction().begin();\n         People p1 = em.find(People.class, SSN[0]);\n-        String jpql = \"select r from Relation r where r.source = :node\";\n-        List<Relation> r = em.createQuery(jpql, Relation.class)\n+        String jpql = \"select r from PersistentRelation r where r.source = :node\";\n+        List<PersistentRelation> r = em.createQuery(jpql, PersistentRelation.class)\n                             .setHint(QueryHints.HINT_IGNORE_PREPARED_QUERY, true)\n                             .setParameter(\"node\", p1)\n                             .getResultList();\n@@ -308,8 +311,8 @@ public void testAddRemoveAttribute() {\n         em.clear();\n         \n         em.getTransaction().begin();\n-        jpql = \"select r from Relation r join r.attrs a where key(a) = :key\";\n-        Relation newR = em.createQuery(jpql, Relation.class)\n+        jpql = \"select r from PersistentRelation r join r.attrs a where key(a) = :key\";\n+        Relation newR = em.createQuery(jpql, PersistentRelation.class)\n                           .setParameter(\"key\", \"new-key\")\n                           .getSingleResult();\n         assertNotNull(newR);\n@@ -318,9 +321,9 @@ public void testAddRemoveAttribute() {\n         em.getTransaction().commit();\n         \n         em.getTransaction().begin();\n-        jpql = \"select r from Relation r join r.attrs a where key(a) = :key\";\n+        jpql = \"select r from PersistentRelation r join r.attrs a where key(a) = :key\";\n         try {\n-            newR = em.createQuery(jpql, Relation.class)\n+            newR = em.createQuery(jpql, PersistentRelation.class)\n                           .setParameter(\"key\", \"new-key\")\n                           .getSingleResult();\n             fail(jpql + \" with new-key expected no result\");\n@@ -339,30 +342,31 @@ boolean isPopulated() {\n      * Creates a typical graph of People and Cities. The tests are sensitive to\n      * the actual values and relations set in in this method.\n      */\n-    void createData() {\n-        if (isPopulated())\n-            return;\n+    PersistentGraph<Object> createData() {\n+        PersistentGraph<Object> graph = new RelationGraph<Object>();\n+        \n         em.getTransaction().begin();\n \n         People[] people = new People[SSN.length];\n         for (int i = 0; i < SSN.length; i++) {\n             People p = new People();\n-            em.persist(p);\n+            graph.add(p);\n             p.setSsn(SSN[i]);\n             p.setName(PERSON_NAMES[i]);\n             people[i] = p;\n         }\n         City[] cities = new City[CITY_NAMES.length];\n         for (int i = 0; i < CITY_NAMES.length; i++) {\n             City c = new City();\n-            em.persist(c);\n+            graph.add(c);\n             c.setName(CITY_NAMES[i]);\n             cities[i] = c;\n         }\n         for (int i = 0; i < people.length; i++) {\n             for (int j = 0; j < people.length; j++) {\n                 if (EMOTIONS[i][j] != null) {\n-                    Relation<People, People> r = people[i].link(people[j]).addAttribute(ATTR_EMOTION, EMOTIONS[i][j]);\n+                    Relation<People, People> r = graph.link(people[i], people[j])\n+                                 .addAttribute(ATTR_EMOTION, EMOTIONS[i][j]);\n                     if (i == 0 && j == 2) {\n                         r.addAttribute(ATTR_SINCE, SINCE);\n                     }\n@@ -371,18 +375,20 @@ void createData() {\n         }\n         for (int i = 0; i < cities.length; i++) {\n             for (int j = 0; j < cities.length; j++) {\n-                cities[i].link(cities[j]).addAttribute(ATTR_DISTANCE, ATTR_DISTANCE_VALUE[i][j]);\n+                graph.link(cities[i], cities[j]).addAttribute(ATTR_DISTANCE, ATTR_DISTANCE_VALUE[i][j]);\n             }\n         }\n \n         for (int i = 0; i < people.length; i++) {\n-            people[i].link(cities[i % CITY_NAMES.length]);\n+            graph.link(people[i], cities[i % CITY_NAMES.length]);\n         }\n-\n+        em.persist(graph);\n         em.getTransaction().commit();\n+        \n+        return graph;\n     }\n \n-    void assertDataEquals(People[] people, City[] cities) {\n+    void assertDataEquals(Graph<Object> graph, People[] people, City[] cities) {\n         assertEquals(SSN.length, people.length);\n         assertEquals(CITY_NAMES.length, cities.length);\n         \n@@ -399,7 +405,7 @@ void assertDataEquals(People[] people, City[] cities) {\n             People p1 = people[i];\n             for (int j = 0; j < people.length; j++) {\n                 People p2 = people[j];\n-                Relation<People, People> r = p1.getRelationTo(p2);\n+                Relation<People, People> r = graph.getRelation(p1,p2);\n                 if (EMOTIONS[i][j] != null) {\n                     assertNotNull(r);\n                     assertEquals(EMOTIONS[i][j].toString(), r.getAttribute(ATTR_EMOTION));\n@@ -412,7 +418,7 @@ void assertDataEquals(People[] people, City[] cities) {\n             City c1 = cities[i];\n             for (int j = 0; j < cities.length; j++) {\n                 City c2 = cities[j];\n-                Relation<City, City> r12 = c1.getRelationTo(c2);\n+                Relation<City, City> r12 = graph.getRelation(c1,c2);\n                 assertNotNull(r12);\n                 assertEquals(\"\"+ATTR_DISTANCE_VALUE[i][j], r12.getAttribute(ATTR_DISTANCE));\n             }\n@@ -422,7 +428,7 @@ void assertDataEquals(People[] people, City[] cities) {\n             People p = people[i];\n             for (int j = 0; j < cities.length; j++) {\n                 City c = cities[j];\n-                Relation<People, City> r = p.getRelationTo(c);\n+                Relation<People, City> r = graph.getRelation(p,c);\n                 if (i % CITY_NAMES.length == j) {\n                     assertNotNull(r);\n                 } else {"},{"sha":"c1077f5e0f096b118ed2029653a20428858157b2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Vertex.java","status":"removed","additions":0,"deletions":155,"changes":155,"blob_url":"https://github.com/apache/openjpa/blob/2e827c5eab3154f62e5a82045af1638fafabb7e7/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Vertex.java","raw_url":"https://github.com/apache/openjpa/raw/2e827c5eab3154f62e5a82045af1638fafabb7e7/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Vertex.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Vertex.java?ref=2e827c5eab3154f62e5a82045af1638fafabb7e7","patch":"@@ -1,155 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.persistence.graph;\n-\n-import java.io.Serializable;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-import javax.persistence.CascadeType;\n-import javax.persistence.MappedSuperclass;\n-import javax.persistence.OneToMany;\n-\n-/**\n- * Vertex of a persistent graph.\n- * <br>\n- * A vertex maintains relationship to other connected vertices. \n- * An abstract vertex provides the functionality for a concrete derivation to be member of a graph. \n- * <br>\n- * A generic vertex does <em>not</em> define a persistent identity on the derived types. \n- * <br>\n- * The only persistent state maintained by a generic vertex is its ({@linkplain Relation relations}\n- * to its neighboring vertices.\n- * <br>\n- * @author Pinaki Poddar\n- *\n- * @param <V> the type of this vertex.\n- */\n-@SuppressWarnings(\"serial\")\n-\n-@MappedSuperclass\n-public abstract class Vertex<V> implements Serializable {\n-    /**\n-     * A set of relations starting from this vertex.\n-     * A vertex owns its relations in a object modeling sense but not in a JPA sense.\n-     * In a object modeling sense, a relation can not exist without its source vertex.  \n-     * In a JPA sense, the relational table for a Relation holds a foreign key to the source vertex, \n-     * so Relation is the owner of vertex-Relation relation, confusing, eh?  \n-     */\n-    @OneToMany(mappedBy=\"source\", \n-            cascade=CascadeType.ALL, \n-            orphanRemoval=true, \n-            targetEntity=Relation.class)\n-    private Set<Relation<V,?>> relations;\n-    \n-    /**\n-     * Create a relation to the given vertex from this vertex, if no such relation exists.\n-     * If a relation exists, returns the existing relation.\n-     *  \n-     * @param n a non-null vertex.\n-     */\n-    public <V2> Relation<V,V2> link(Vertex<V2> n) {\n-        if (n == null) {\n-            throw new NullPointerException(this + \" can not link to null target\");\n-        }\n-        Relation<V,V2> r = getRelationTo(n);\n-        if (r == null) {\n-            r = new Relation<V,V2>(this, n);\n-            if (relations == null) {\n-                relations = new HashSet<Relation<V,?>>();\n-            }\n-            relations.add(r);\n-        }\n-        return r;\n-    }\n-    \n-    /**\n-     * Breaks the relation, if exists, from this vertex to the given vertex.\n-     * Returns the broken link.\n-     * \n-     * @param n a vertex, possibly null.\n-     */\n-    public <V2> Relation<V,V2> delink(Vertex<V2> n) {\n-        Relation<V,V2> r = getRelationTo(n);\n-        if (r != null) {\n-            relations.remove(r);\n-        }\n-        return r;\n-    }\n-    \n-    /**\n-     * Gets the relation from this vertex to the given vertex, if exists. Null otherwise.\n-     * \n-     * @param n a vertex, possibly null.\n-     */\n-    public <V2> Relation<V,V2> getRelationTo(Vertex<V2> n) {\n-        if (n == null || relations == null)\n-            return null;\n-        for (Relation<V,?> r : relations) {\n-            if (r.getTarget().equals(n)) {\n-                return (Relation<V,V2>)r;\n-            }\n-        }\n-        return null;\n-    }\n-    \n-    /**\n-     * Affirms if the given vertex is linked from this vertex.\n-     */\n-    public boolean isRelatedTo(Vertex<V> n) {\n-        return getRelationTo(n) != null;\n-    }\n-    \n-    /**\n-     * Gets all the relations starting from this vertex.\n-     */\n-    public Set<Relation<V,?>> getRelations() {\n-        return relations;\n-    }\n-    \n-    /**\n-     * Gets all the immediate neighbors.\n-     */\n-    public Set<Vertex<?>> getNeighbours() {\n-        if (relations == null)\n-            return null;\n-        Set<Vertex<?>> neighbours = new HashSet<Vertex<?>>();\n-        for (Relation<V,?> r : relations) {\n-            neighbours.add(r.getTarget());\n-        }\n-        return neighbours;\n-    }\n-\n-    /**\n-     * Gets all the immediate neighbors of the given type.\n-     */\n-    public <T> Set<Vertex<T>> getNeighbours(Class<T> type, boolean allowSubclass) {\n-        if (relations == null)\n-            return null;\n-        Set<Vertex<T>> neighbours = new HashSet<Vertex<T>>();\n-        for (Relation<V,?> r : relations) {\n-            Vertex<?> target = r.getTarget();\n-            boolean include = allowSubclass ? type.isAssignableFrom(target.getClass()) : type == target.getClass();\n-            if (include)\n-                neighbours.add((Vertex<T>)target);\n-        }\n-        return neighbours;\n-    }\n-\n-}"}]}

