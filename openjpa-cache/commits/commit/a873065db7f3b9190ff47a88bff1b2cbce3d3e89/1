{"sha":"a873065db7f3b9190ff47a88bff1b2cbce3d3e89","node_id":"MDY6Q29tbWl0MjA2MzY0OmE4NzMwNjVkYjdmM2I5MTkwZmY0N2E4OGJmZjFiMmNiY2UzZDNlODk=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2010-06-09T02:43:46Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2010-06-09T02:43:46Z"},"message":"OPENJPA-1686: A first draft of support for generic graph. Correct mapping strategy on MappedSuperClass (they are not Embeddables)\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@952893 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"2f9f7ca149fc9a2659484a5726049a4517976b3f","url":"https://api.github.com/repos/apache/openjpa/git/trees/2f9f7ca149fc9a2659484a5726049a4517976b3f"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/a873065db7f3b9190ff47a88bff1b2cbce3d3e89","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/a873065db7f3b9190ff47a88bff1b2cbce3d3e89","html_url":"https://github.com/apache/openjpa/commit/a873065db7f3b9190ff47a88bff1b2cbce3d3e89","comments_url":"https://api.github.com/repos/apache/openjpa/commits/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/comments","author":null,"committer":null,"parents":[{"sha":"9d33fe34b8cf330a330c7d70162c23f16fdc436c","url":"https://api.github.com/repos/apache/openjpa/commits/9d33fe34b8cf330a330c7d70162c23f16fdc436c","html_url":"https://github.com/apache/openjpa/commit/9d33fe34b8cf330a330c7d70162c23f16fdc436c"}],"stats":{"total":1026,"additions":979,"deletions":47},"files":[{"sha":"d19a740017a95122ac11a1102b82928c4b935678","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -1026,7 +1026,7 @@ private boolean useInverseKeyMapping(FieldMapping field) {\n             //bi-/M-1/JoinTable ==> join table strategy\n             if (isBiMTo1JT(field)) \n                 return false;\n-            if (mapped.getTypeCode() == JavaTypes.PC)\n+            if (mapped.getTypeCode() == JavaTypes.PC || mapped.getTypeCode() == JavaTypes.PC_UNTYPED)\n                 return true;\n             if (mapped.getElement().getTypeCode() == JavaTypes.PC)\n                 return false;"},{"sha":"d7b7ea539b9ea6c5f59f1fbdaf5a0c16b87e6c08","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyInverseKeyFieldStrategy.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyInverseKeyFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyInverseKeyFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyInverseKeyFieldStrategy.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -133,7 +133,8 @@ public void map(boolean adapt) {\n         boolean criteria = vinfo.getUseClassCriteria();\n         if (mapped != null) {\n             mapped.resolve(mapped.MODE_META | mapped.MODE_MAPPING);\n-            if (!(mapped.getStrategy() instanceof RelationFieldStrategy))\n+            if (!(mapped.getStrategy() instanceof RelationFieldStrategy \n+               || mapped.getHandler() instanceof UntypedPCValueHandler))\n                 throw new MetaDataException(_loc.get(\"not-inv-relation\",\n                     field, mapped));\n             vinfo.assertNoSchemaComponents(elem, !adapt);"},{"sha":"c5c3be0779fc819af74a0648dcebcdbc2c40f601","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StoreCollectionFieldStrategy.java","status":"modified","additions":27,"deletions":2,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StoreCollectionFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StoreCollectionFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StoreCollectionFieldStrategy.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -31,6 +31,7 @@\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n import org.apache.openjpa.jdbc.meta.FieldStrategy;\n+import org.apache.openjpa.jdbc.meta.RelationId;\n import org.apache.openjpa.jdbc.meta.ValueMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n@@ -46,6 +47,7 @@\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.util.ChangeTracker;\n import org.apache.openjpa.util.Id;\n+import org.apache.openjpa.util.OpenJPAId;\n import org.apache.openjpa.util.Proxy;\n \n /**\n@@ -576,8 +578,9 @@ public void select(Select sel, int idx) {\n     protected Joins selectAll(Select sel, ClassMapping elem,\n         OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch,\n         int eagerMode) {\n-        sel.whereForeignKey(getJoinForeignKey(elem), sm.getObjectId(),\n-            field.getDefiningMapping(), store);\n+        ForeignKey fk = getJoinForeignKey(elem);\n+        Object oid = getObjectIdForJoin(fk, sm);\n+        sel.whereForeignKey(fk, oid, field.getDefiningMapping(), store);\n \n         // order first, then select so that if the projection introduces\n         // additional ordering, it will be after our required ordering\n@@ -601,4 +604,26 @@ protected ForeignKey getJoinForeignKey() {\n     boolean requiresOrderBy() {\n     \treturn List.class.isAssignableFrom(field.getProxyType());\n     }\n+    \n+    /**\n+     * Gets the identity value of the given instance that is suitable to join to the given foreign key.\n+     * The special case of the foreign key being a relation identifier will encode the value. \n+     */\n+    Object getObjectIdForJoin(ForeignKey fk, OpenJPAStateManager sm) {\n+        Object oid = sm.getObjectId();\n+        for (Column col : fk.getColumns()) {\n+            if (!col.isRelationId()) {\n+                return oid;\n+            }\n+        }\n+        \n+        FieldMapping owningField = field.getMappedByMapping();\n+        if (owningField != null && owningField.getHandler() instanceof RelationId) {\n+            return ((RelationId)owningField.getHandler()).toRelationDataStoreValue(sm, null);\n+        } \n+        if (oid instanceof OpenJPAId) {\n+            return ((OpenJPAId)oid).getIdObject();\n+        }\n+        return oid;\n+    }\n }"},{"sha":"2422c989ab661cb09577188b3818ea49a8d3b9af","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -1343,6 +1343,7 @@ private void whereForeignKey(ForeignKey fk, Object oid,\n     private void where(Object oid, ClassMapping mapping, Column[] toCols,\n         Column[] fromCols, Object[] vals, Column[] constCols, PathJoins pj,\n         JDBCStore store) {\n+        boolean relationId = fromCols[0].isRelationId(); \n         ValueMapping embed = mapping.getEmbeddingMapping();\n         if (embed != null) {\n             where(oid, embed.getFieldMapping().getDefiningMapping(),\n@@ -1352,18 +1353,17 @@ private void where(Object oid, ClassMapping mapping, Column[] toCols,\n \n         // only bother to pack pk values into array if app id\n         Object[] pks = null;\n-        if (mapping.getIdentityType() == ClassMapping.ID_APPLICATION)\n+        if (!relationId && mapping.getIdentityType() == ClassMapping.ID_APPLICATION)\n             pks = ApplicationIds.toPKValues(oid, mapping);\n \n         SQLBuffer buf = new SQLBuffer(_dict);\n         Joinable join;\n         Object val;\n         int count = 0;\n         for (int i = 0; i < toCols.length; i++, count++) {\n-            if (pks == null)\n-                val = (oid == null) ? null :\n-                        ((Id) oid).getId();\n-            else {\n+            if (pks == null) {\n+                val = (oid == null) ? null : relationId ? oid : ((Id) oid).getId();\n+            } else {\n                 // must be app identity; use pk index to get correct pk value\n                 join = mapping.assertJoinable(toCols[i]);\n                 val = pks[mapping.getField(join.getFieldIndex())."},{"sha":"71bc845ad1aba12c474143f8583bfc57fe10b1b3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaDataImpl.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaDataImpl.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaDataImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaDataImpl.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -451,7 +451,7 @@ private void resolveDeclaredType(Class type) {\n         if (meta != null)\n             _decCode = JavaTypes.PC;\n         \n-        if (meta != null && meta.isEmbeddedOnly())\n+        if (meta != null && meta.isEmbeddedOnly() && !meta.isAbstract())\n             setEmbedded(true);\n                 \n         if (!isEmbedded()) "},{"sha":"2188858d8f942c0bd876ae64a849c5f297a3bbcd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/Id.java","status":"modified","additions":4,"deletions":5,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-kernel/src/main/java/org/apache/openjpa/util/Id.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-kernel/src/main/java/org/apache/openjpa/util/Id.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/Id.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -39,7 +39,7 @@\n \n     /**\n      * Create an id from the given type and value; the value might be an\n-     * id instnace, a stringified id, or a primary key value.\n+     * id instance, a stringified id, or a primary key value.\n      */\n     public static Id newInstance(Class cls, Object val) {\n         if (val instanceof Id)\n@@ -77,13 +77,12 @@ public Id(String str, OpenJPAConfiguration conf, ClassLoader brokerLoader) {\n      */\n     public Id(String str, ClassLoader loader) {\n         if (loader == null)\n-            loader = AccessController.doPrivileged(\n-                J2DoPrivHelper.getContextClassLoaderAction());\n+            loader = AccessController.doPrivileged(J2DoPrivHelper.getContextClassLoaderAction());\n \n         if (str == null)\n             _id = 0L;\n         else {\n-            int dash = str.indexOf('-');\n+            int dash = str.indexOf(TYPE_VALUE_SEP);\n             try {\n                 type = Class.forName(str.substring(0, dash), true, loader);\n             } catch (Throwable t) {\n@@ -104,7 +103,7 @@ public Id(Class cls, String key) {\n             _id = 0L;\n         else {\n             // allow either stringified long or result of Id.toString\n-            int dash = key.indexOf('-');\n+            int dash = key.indexOf(TYPE_VALUE_SEP);\n             if (dash > 0) // don't check for -1; might be negative number\n                 key = key.substring(dash + 1);\n             _id = Long.parseLong(key);"},{"sha":"c1066220033afb138c576615c92a263cf42f3a66","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","status":"modified","additions":9,"deletions":8,"changes":17,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -24,21 +24,23 @@\n import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n \n /**\n- * Identity class extended by builtin OpenJPA identity objects.\n+ * Identity class extended by built-in OpenJPA identity objects.\n  *\n  * @author Steve Kim\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class OpenJPAId\n     implements Comparable, Serializable {\n-\n-    // cache the types' generated hashcodes\n+    public static final char TYPE_VALUE_SEP = '-';\n+    \n+    // cache the types' generated hash codes\n     private static ConcurrentReferenceHashMap _typeCache =\n         new ConcurrentReferenceHashMap(ReferenceMap.WEAK, ReferenceMap.HARD);\n \n     protected Class type;\n     protected boolean subs = true;\n \n-    // type has his based on the least-derived non-object class so that\n+    // type hash is based on the least-derived non-object class so that\n     // user-given ids with non-exact types match ids with exact types\n     private transient int _typeHash = 0;\n \n@@ -100,7 +102,7 @@ public void setManagedInstanceType(Class type, boolean subs) {\n     protected abstract boolean idEquals(OpenJPAId other);\n \n     /**\n-     * Generate the hashcode for this Id.  Cache the type's generated hashcode\n+     * Generate the hash code for this Id.  Cache the type's generated hash code\n      * so that it doesn't have to be generated each time.\n      */\n     public int hashCode() {\n@@ -134,15 +136,14 @@ public boolean equals(Object o) {\n     }\n \n     public String toString() {\n-        return type.getName() + \"-\" + getIdObject();\n+        return type.getName() + TYPE_VALUE_SEP + getIdObject();\n     }\n \n     public int compareTo(Object other) {\n         if (other == this)\n             return 0;\n         if (other == null)\n             return 1;\n-        return ((Comparable) getIdObject()).compareTo(((OpenJPAId) other).\n-            getIdObject ());\n+        return ((Comparable) getIdObject()).compareTo(((OpenJPAId) other).getIdObject ());\n \t}\n }"},{"sha":"c8d9c8c885d763541edaf03caf98619953bd9620","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/JavaVersions.java","status":"modified","additions":8,"deletions":4,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/JavaVersions.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/JavaVersions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/JavaVersions.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -164,7 +164,7 @@ public static boolean isEnumeration(Class cls) {\n         try {\n             Object type = Field.class.getMethod(\"getGenericType\",\n                 (Class[]) null).invoke(f, (Object[]) null);\n-            return collectParameterizedTypes(type);\n+            return collectParameterizedTypes(type, f.getType());\n         } catch (Exception e) {\n             return EMPTY_CLASSES;\n         }\n@@ -182,7 +182,7 @@ public static boolean isEnumeration(Class cls) {\n         try {\n             Object type = Method.class.getMethod(\"getGenericReturnType\",\n                 (Class[]) null).invoke(meth, (Object[]) null);\n-            return collectParameterizedTypes(type);\n+            return collectParameterizedTypes(type, meth.getReturnType());\n         } catch (Exception e) {\n             return EMPTY_CLASSES;\n         }\n@@ -191,10 +191,14 @@ public static boolean isEnumeration(Class cls) {\n     /**\n      * Return all parameterized classes for the given type.\n      */\n-    private static Class[] collectParameterizedTypes(Object type)\n+    private static Class[] collectParameterizedTypes(Object type, Class<?> cls)\n         throws Exception {\n-        if (PARAM_TYPE == null || !PARAM_TYPE.isInstance(type))\n+        if (PARAM_TYPE == null || !PARAM_TYPE.isInstance(type)) {\n+            if (cls.getSuperclass() != Object.class) {\n+                return collectParameterizedTypes(cls.getGenericSuperclass(), cls.getSuperclass());\n+            }\n             return EMPTY_CLASSES;\n+        }\n \n         Object[] args = (Object[]) PARAM_TYPE.getMethod\n             (\"getActualTypeArguments\", (Class[]) null).invoke(type,"},{"sha":"0fde0c8a3b37eb3b75915580abc620e34e1a3cb7","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingParser.java","status":"modified","additions":13,"deletions":8,"changes":21,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingParser.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingParser.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -1052,12 +1052,10 @@ protected void parseMemberMappingAnnotations(FieldMetaData fmd) {\n                     parseEnumerated(fm, (Enumerated) anno);\n                     break;\n                 case JOIN_COL:\n-                    parseJoinColumns(fm, fm.getValueInfo(), true,\n-                        (JoinColumn) anno);\n+                    parseJoinColumns(fm, fm.getValueInfo(), true, (JoinColumn) anno);\n                     break;\n                 case JOIN_COLS:\n-                    parseJoinColumns(fm, fm.getValueInfo(), true,\n-                        ((JoinColumns) anno).value());\n+                    parseJoinColumns(fm, fm.getValueInfo(), true, ((JoinColumns) anno).value());\n                     break;\n                 case JOIN_TABLE:\n                     parseJoinTable(fm, (JoinTable) anno);\n@@ -1670,12 +1668,19 @@ private void parseJoinColumns(FieldMapping fm, MappingInfo info,\n         List<Column> cols = new ArrayList<Column>(joins.length);\n         int unique = 0;\n         DBIdentifier sSecondary = DBIdentifier.NULL;\n+        \n         for (int i = 0; i < joins.length; i++) {\n-            cols.add(newColumn(joins[i]));\n+            Column col = newColumn(joins[i]);\n+            cols.add(col);\n             unique |= (joins[i].unique()) ? TRUE : FALSE;\n-            DBIdentifier sTable = DBIdentifier.newTable(joins[i].table(), delimit());\n-            sSecondary = trackSecondaryTable(fm, sSecondary,\n-                sTable, i);\n+            DBIdentifier sTable = DBIdentifier.NULL;\n+            if (info instanceof FieldMappingInfo && secondaryAllowed) {\n+                sTable = ((FieldMappingInfo)info).getTableIdentifier();\n+            }\n+            if (sTable.isNull()) {\n+                sTable = DBIdentifier.newTable(joins[i].table(), delimit());\n+            }\n+            sSecondary = trackSecondaryTable(fm, sSecondary, sTable, i);\n             if (!secondaryAllowed && !DBIdentifier.isNull(sSecondary))\n                 throw new MetaDataException(_loc.get(\"bad-second\", fm));\n         }"},{"sha":"e64760608473b231509f811af66210ca2680e1f1","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestEmbeddableSuperclass.java","status":"modified","additions":14,"deletions":6,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestEmbeddableSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestEmbeddableSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/compat/TestEmbeddableSuperclass.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -39,6 +39,7 @@\n /**\n  * <p>Test embeddable superclasses</p>\n  *\n+ *  <B>This is an anti-test because it validates or masks root cause of a possibly serious error.\n  *\n  * <b>Compatible testcases</b> are used to test various backwards compatibility scenarios between JPA 2.0 and JPA 1.2\n  * \n@@ -51,6 +52,7 @@\n  * <ul>\n  * <li>The proper openjpa.Compatibility value(s) must be provided in order for the testcase(s) to succeed\n  * </ul>\n+ * \n  */\n public class TestEmbeddableSuperclass\n     extends SingleEMFTestCase {\n@@ -67,15 +69,21 @@ public void testRelationMappings() {\n         assertTrue(fm.getStrategy() instanceof RelationFieldStrategy);\n \n         fm = cls.getFieldMapping(\"sup\");\n-\n-        if (OpenJPAVersion.MAJOR_RELEASE >= 2) {\n+        assertEquals(RelationFieldStrategy.class, fm.getStrategy().getClass());\n+        // This was an anti-test because it legitimizes/masks the root cause of a serious error.\n+        // The strategy for a field should not change without a valid reason.\n+        \n+//        if (OpenJPAVersion.MAJOR_RELEASE >= 2) {\n             // OPENJPA-1214 - OpenJPA 2 returns a EmbedFieldStrategy instead of\n             // a RelationFieldStrategy as in prior releases.\n-            assertTrue(fm.getStrategy() instanceof EmbedFieldStrategy);\n-        } else {\n+//            assertEquals(EmbedFieldStrategy.class, fm.getStrategy().getClass());\n+//        } else {\n             // Prior OpenJPA 1.2/1.3 behavior\n-            assertTrue(fm.getStrategy() instanceof RelationFieldStrategy);\n-        }\n+//            assertEquals(RelationFieldStrategy.class, fm.getStrategy().getClass());\n+//            \n+//        }\n+        \n+        // \n     } \n }\n "},{"sha":"7f5f82ae5daab07e33651c8c7bf0febb74c4741e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/City.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/City.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/City.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/City.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.graph;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+\n+/**\n+ * A simple persistent entity to become member of a graph.\n+ * In this style, a type has to extend {@linkplain Vertex} - an abstract persistent type.\n+ * This persistent type has its own identity.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+@SuppressWarnings(\"serial\")\n+@Entity\n+public class City extends Vertex<City> {\n+    @Id\n+    private String name;\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+}"},{"sha":"db2c3a32d14fa753422ab9f71c08ff3b47b3c1e9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/People.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/People.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/People.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/People.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.graph;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+\n+/**\n+ * A simple persistent entity to become member of a graph.\n+ * In this style, a type has to extend {@linkplain Vertex} - an abstract persistent type.\n+ * This persistent type has its own identity.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+@SuppressWarnings(\"serial\")\n+@Entity\n+public class People extends Vertex<People>{\n+    @Id\n+    private long ssn;\n+    private String name;\n+    public long getSsn() {\n+        return ssn;\n+    }\n+    public void setSsn(long ssn) {\n+        this.ssn = ssn;\n+    }\n+    public String getName() {\n+        return name;\n+    }\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+}"},{"sha":"24602ca4237462a840a08ebd698504e2e169c55f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Relation.java","status":"added","additions":184,"deletions":0,"changes":184,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Relation.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Relation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Relation.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.graph;\n+\n+import java.io.Serializable;\n+import java.util.Properties;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToMany;\n+import javax.persistence.OneToOne;\n+\n+/**\n+ * Generic, directed, attributed Relation as a first-class entity.\n+ * <br>\n+ * A relation is \n+ * <ol>\n+ * <LI>generic because the vertices it links are generically typed.\n+ * <LI>directed because it distinguishes the two end points as source and target.\n+ * <LI>attributed because any arbitrary name-value pair can be associated with a relation.\n+ * </ol>\n+ * A relation is immutable in terms of its two vertices. The properties\n+ * attached to a relation can change.\n+ *\n+ * @param <V1> the type of <em>source</em> vertex linked by this relation.\n+ * @param <V2> the type of <em>target</em> vertex linked by this relation.\n+ *  \n+ * @author Pinaki Poddar\n+ *\n+ */\n+@SuppressWarnings(\"serial\")\n+@Entity\n+public class Relation<V1,V2> implements Serializable {\n+    /**\n+     * Relation is a first class object with its own identifier.\n+     */\n+    @Id\n+    @GeneratedValue\n+    private long id;\n+    \n+    /**\n+     * A Relation must have a non-null vertex as source.\n+     */\n+    @OneToOne(optional=false)\n+    private Vertex<V1> source;\n+    \n+    /**\n+     * A Relation must have a non-null vertex as source.\n+     */\n+    @OneToOne(optional=false)\n+    private Vertex<V2> target;\n+    \n+    /**\n+     * The properties of a Relation is a set of key-value pairs and is declared as \n+     * <code>java.util.Properties</code>.\n+     * <br>\n+     * Declaring the key-value pairs as <code>java.util.Properties</code> makes OpenJPA\n+     * assume that both key and value will be stored in database as String.\n+     * This is not <em>strictly</em> correct because <code>java.util.Properties</code>\n+     * declares its key and value as <code>java.lang.Object</code>. Hence it is possible for an application\n+     * to insert key and/or value that are not a String but that type information will not be preserved in\n+     * the database. Subsequently, when loaded from database the key and value\n+     * both will appear as String and hence it becomes the application's responsibility to decode the\n+     * Strings back to the actual type. While this provision loses type information, it allows the\n+     * database record to be readable and more importantly supports query that are predicated on \n+     * (equality only) key-value pairs.\n+     * <br>\n+     * Another possibility to express key-value pair as\n+     * <br>\n+     * <code>Map<String,Serializable> attrs;</code>\n+     * <br> \n+     * This will serialize the values but preserve their types. The down-side is neither a query can be \n+     * predicated on value nor are the database records readable.  \n+     * <br>\n+     * The third alternative is a Map where keys are String and values are Object \n+     * <br>\n+     * <code>Map<String,Object> attrs;</code>\n+     * This leads to the whole map being serialized as a single blob of data.\n+     */\n+    @ManyToMany(cascade={CascadeType.ALL},fetch=FetchType.LAZY)\n+    private Properties attrs;\n+    \n+    /**\n+     * Special constructor for byte code enhancement.\n+     */\n+    protected Relation() {\n+    }\n+    \n+    /**\n+     * A relation is immutable in terms of two vertices it connects.\n+     * Either vertex must not be null.\n+     */\n+    public Relation(Vertex<V1> s, Vertex<V2> t) {\n+        if (s == null)\n+            throw new NullPointerException(\"Can not create relation from a null source vertex\");\n+        if (t == null)\n+            throw new NullPointerException(\"Can not create relation to a null target vertex\");\n+        source = s;\n+        target = t;\n+        attrs = new Properties();\n+    }\n+    \n+    /**\n+     * Gets generated persistent identity.\n+     */\n+    public long getId() {\n+        return id;\n+    }\n+    \n+    /**\n+     * Gets the immutable source vertex.\n+    */\n+    public Vertex<V1> getSource() {\n+        return source;\n+    }\n+    \n+    /**\n+     * Gets the immutable target vertex.\n+    */\n+    public Vertex<V2> getTarget() {\n+        return target;\n+    }\n+    \n+    /**\n+     * Affirms if the given attribute is associated with this relation.\n+     */\n+    public boolean hasAttribute(String attr) {\n+        return attrs.containsKey(attr);\n+    }\n+    \n+    /**\n+     * Gets the value of the given attribute.\n+     * \n+     * @return value of the given attribute. A null value does not distinguish whether\n+     * the attribute was set to a null value or the attribute was absent. \n+     */\n+    public Object getAttribute(String attr) {\n+        return attrs.get(attr);\n+    }\n+    \n+    public Properties getAttributes() {\n+        return attrs;\n+    }\n+\n+    /**\n+     * Adds the given key-value pair, overwriting any prior association to the same attribute.\n+     * \n+     * @return the same relation for fluent method-chaining\n+     */\n+    public Relation<V1,V2> addAttribute(String attr, Object v) {\n+        attrs.put(attr, v);\n+        return this;\n+    }\n+    \n+    /**\n+     * Removes the given attribute.\n+     * \n+     * @return value of the given attribute that just has been removed. A null value does not \n+     * distinguish whether the attribute was set to a null value or the attribute was absent. \n+     */\n+    public Relation<V1,V2> removeAttribute(String attr) {\n+        attrs.remove(attr);\n+        return this;\n+    }\n+}"},{"sha":"f5766773233e81721649017e074cfd3afe1a3019","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/TestPersistentGraph.java","status":"added","additions":451,"deletions":0,"changes":451,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/TestPersistentGraph.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/TestPersistentGraph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/TestPersistentGraph.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -0,0 +1,451 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.graph;\n+\n+import java.sql.Date;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.NoResultException;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.FieldStrategy;\n+import org.apache.openjpa.jdbc.meta.MappingRepository;\n+import org.apache.openjpa.jdbc.meta.ValueHandler;\n+import org.apache.openjpa.jdbc.meta.strats.HandlerFieldStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.HandlerHandlerMapTableFieldStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.RelationCollectionInverseKeyFieldStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.UntypedPCValueHandler;\n+import org.apache.openjpa.kernel.QueryHints;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.persistence.OpenJPAPersistence;\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+\n+/**\n+ * Tests basic create and query on generic persistent graph. The test creates a\n+ * graph of People and Cities. Then different queries on the graph are verified.\n+ * \n+ * @author Pinaki Poddar\n+ * \n+ */\n+public class TestPersistentGraph extends SingleEMFTestCase {\n+    private static enum Emotion {\n+        LOVES, HATES, KNOWS\n+    };\n+\n+    // Identity of People is their SSN\n+    private static final long[] SSN = { 123456781, 123456782, 123456783, 123456784, 123456785 };\n+    private static final String[] PERSON_NAMES = { \"P1\", \"P2\", \"P3\", \"P4\", \"P5\" };\n+    private static final String[] CITY_NAMES = { \"San Francisco\", \"Paris\", \"Rome\" };\n+\n+    private static final String ATTR_SINCE = \"since\";\n+    private static final Date SINCE = new Date(90, 1, 27);\n+\n+    private static final String ATTR_EMOTION = \"feels\";\n+    private static final Emotion[][] EMOTIONS = {\n+                            /*    P1             P2             P3             P4             P5       */\n+    /* P1 */new Emotion[] {          null, Emotion.LOVES, Emotion.HATES,          null, Emotion.KNOWS },\n+    /* P2 */new Emotion[] { Emotion.LOVES,          null, Emotion.LOVES,          null, Emotion.LOVES },\n+    /* P3 */new Emotion[] { Emotion.HATES, Emotion.LOVES,          null,          null, Emotion.KNOWS },\n+    /* P4 */new Emotion[] { Emotion.LOVES, Emotion.HATES, Emotion.KNOWS, Emotion.LOVES, Emotion.LOVES },\n+    /* P5 */new Emotion[] {          null, Emotion.LOVES, Emotion.KNOWS, Emotion.KNOWS,          null }, \n+    };\n+\n+    private static final String ATTR_DISTANCE = \"distance\";\n+    private static final int[][] ATTR_DISTANCE_VALUE = {\n+                       /* C1 C2 C3 */\n+    /* C1 */new int[] { 0, 200, 400 },\n+    /* C2 */new int[] { 200, 0, 500 },\n+    /* C3 */new int[] { 400, 500, 0 }\n+    };\n+\n+    private EntityManager em;\n+\n+    public void setUp() throws Exception {\n+        super.setUp(CLEAR_TABLES, Vertex.class, Relation.class, People.class, City.class);\n+        em = emf.createEntityManager();\n+        createData();\n+        em.clear();\n+    }\n+\n+    /**\n+     * Verifies that fields are mapped with expected strategy or value handlers.\n+     */\n+    public void testMapping() {\n+        assertStrategy(People.class, \"relations\", RelationCollectionInverseKeyFieldStrategy.class, null);\n+        assertStrategy(City.class, \"relations\", RelationCollectionInverseKeyFieldStrategy.class, null);\n+        assertStrategy(Relation.class, \"source\", HandlerFieldStrategy.class, UntypedPCValueHandler.class);\n+        assertStrategy(Relation.class, \"target\", HandlerFieldStrategy.class, UntypedPCValueHandler.class);\n+        assertStrategy(Relation.class, \"attrs\", HandlerHandlerMapTableFieldStrategy.class, null);\n+    }\n+\n+    private void printMapping(FieldMapping fm) {\n+        System.err.println(\"Field :\" + fm.getName());\n+        System.err.println(\"Type :\" + fm.getTypeCode() + \" \" + fm.getType());\n+        System.err.println(\"Type (declared):\" + fm.getDeclaredTypeCode() + \" \" + fm.getDeclaredType());\n+        System.err.println(\"Type Override :\" + fm.getTypeOverride());\n+        System.err.println(\"Key type  :\" + fm.getKey().getType());\n+        System.err.println(\"Key declared type  :\" + fm.getKey().getDeclaredType());\n+        System.err.println(\"Element type  :\" + fm.getElement().getType());\n+        System.err.println(\"Element declared type  :\" + fm.getElement().getDeclaredType());\n+    }\n+\n+    FieldMapping getFieldMapping(Class<?> pcClass, String field) {\n+        MappingRepository repos = (MappingRepository) OpenJPAPersistence.cast(emf).getConfiguration()\n+                .getMetaDataRepositoryInstance();\n+        ClassMapping cmd = repos.getMapping(pcClass, null, true);\n+        assertNotNull(\"No metadata found for \" + pcClass, cmd);\n+        FieldMapping fmd = cmd.getFieldMapping(field);\n+        assertNotNull(\"No metadata found for \" + pcClass.getName() + \".\" + field + \" Fields are \"\n+                + Arrays.toString(cmd.getFieldNames()), fmd);\n+        return fmd;\n+    }\n+\n+    /**\n+     * Asserts that the given field of the given class has been mapped with the\n+     * given straegy or value handler.\n+     */\n+    void assertStrategy(Class<?> pcClass, String field, Class<? extends FieldStrategy> strategy,\n+            Class<? extends ValueHandler> handler) {\n+\n+        FieldMapping fmd = getFieldMapping(pcClass, field);\n+        FieldStrategy actualStrategy = ((FieldMapping) fmd).getStrategy();\n+        assertEquals(strategy, actualStrategy.getClass());\n+        ValueHandler actualHandler = fmd.getHandler();\n+        if (handler == null) {\n+            if (actualHandler != null) {\n+                printMapping(fmd);\n+                fail(\"Expected no value handler for \" + pcClass.getName() + \".\" + field + \n+                        \" but found \" + actualHandler);\n+            }\n+        } else {\n+            if (actualHandler == null) {\n+                printMapping(fmd);\n+                fail(\"Expected a value handler for \" + pcClass.getName() + \".\" + field + \" but found null\");\n+            }\n+            if (!handler.getClass().equals(actualHandler.getClass())) {\n+                printMapping(fmd);\n+                assertEquals(handler, fmd.getHandler().getClass());\n+            }\n+        }\n+    }\n+\n+    FieldStrategy getStrategy(Class<?> cls, String field) {\n+        MetaDataRepository repos = OpenJPAPersistence.cast(emf).getConfiguration().getMetaDataRepositoryInstance();\n+        ClassMetaData cmd = repos.getMetaData(cls, null, true);\n+        assertNotNull(\"No metadat found for \" + cls, cmd);\n+        FieldMetaData fmd = cmd.getField(field);\n+        assertNotNull(\"No metadata found for \" + cls.getName() + \".\" + field + \" Fields are \"\n+                + Arrays.toString(cmd.getFieldNames()), fmd);\n+        FieldStrategy strategy = ((FieldMapping) fmd).getStrategy();\n+        System.err.println(cls.getName() + \".\" + field + \":\" + strategy.getClass().getSimpleName());\n+        return strategy;\n+    }\n+\n+    /**\n+     * Tests that the nodes retrieved from the database meets the same\n+     * assertions of the created graph.\n+     */\n+    public void testCreateGraph() {\n+        em.getTransaction().begin();\n+        People[] people = new People[SSN.length];\n+        for (int i = 0; i < SSN.length; i++) {\n+            People p = em.find(People.class, SSN[i]);\n+            assertNotNull(p);\n+            people[i] = p;\n+        }\n+        City[] cities = new City[CITY_NAMES.length];\n+        for (int i = 0; i < CITY_NAMES.length; i++) {\n+            City c = em.find(City.class, CITY_NAMES[i]);\n+            assertNotNull(c);\n+            cities[i] = c;\n+        }\n+        assertDataEquals(people, cities);\n+\n+        em.getTransaction().rollback();\n+    }\n+\n+    /**\n+     * Tests that relation can be queried and their references are set\n+     * correctly.\n+     */\n+    public void testQueryRelation() {\n+        List<Relation> relations = em.createQuery(\"select r from Relation r\", Relation.class).getResultList();\n+        for (Relation<?, ?> r : relations) {\n+            Vertex<?> source = r.getSource();\n+            Vertex<?> target = r.getTarget();\n+            if (source instanceof People) {\n+                int i = indexOf((People) source);\n+                if (target instanceof People) {\n+                    int j = indexOf((People) target);\n+                    assertNotNull(EMOTIONS[i][j]);\n+                    assertEquals(EMOTIONS[i][j].toString(), r.getAttribute(ATTR_EMOTION));\n+                } else if (target instanceof City) {\n+                    int j = indexOf((City) target);\n+                    assertEquals(i % CITY_NAMES.length, j);\n+                    assertTrue(r.getAttributes().isEmpty());\n+                } else {\n+                    fail();\n+                }\n+            } else if (source instanceof City) {\n+                int i = indexOf((City) source);\n+                if (target instanceof City) {\n+                    int j = indexOf((City) target);\n+                    assertEquals(\"\"+ATTR_DISTANCE_VALUE[i][j], r.getAttribute(ATTR_DISTANCE));\n+                } else {\n+                    fail();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests that a relation can be queried predicated on its source vertex.\n+     */\n+    public void testQueryRelationOnSourceParameter() {\n+        People p1 = em.find(People.class, SSN[0]);\n+        String jpql = \"select r from Relation r where r.source = :node\";\n+        List<Relation> result = em.createQuery(jpql, Relation.class)\n+                                  .setParameter(\"node\", p1)\n+                                  .getResultList();\n+        assertFalse(\"Result of [\" + jpql + \"] on source = \" + p1 + \" should not be empty\", result.isEmpty());\n+    }\n+\n+    /**\n+     * Tests that a relation can be queried predicated on its attribute key.\n+     */\n+    public void testQueryRelationOnSingleAttributeKey() {\n+        String jpql = \"select r from Relation r join r.attrs a where key(a) = :key\";\n+        List<Relation> result = em.createQuery(jpql, Relation.class)\n+                                  .setParameter(\"key\", ATTR_EMOTION)\n+                                  .getResultList();\n+\n+        assertFalse(\"Result of [\" + jpql + \"] on key = \" + ATTR_EMOTION + \" should not be empty\", result.isEmpty());\n+    }\n+\n+    /**\n+     * Tests that a relation can be queried predicated on a single attribute\n+     * key-value pair.\n+     */\n+    public void testQueryRelationOnSingleAttributeKeyValue() {\n+        String jpql = \"select r from Relation r join r.attrs a where key(a) = :key and value(a) = :value\";\n+        String value = EMOTIONS[0][2].toString();\n+        List<Relation> result = em.createQuery(jpql, Relation.class)\n+                                  .setParameter(\"key\", ATTR_EMOTION)\n+                                  .setParameter(\"value\", value)\n+                                  .getResultList();\n+\n+        assertFalse(\"Result of [\" + jpql + \"] on key-value (\" + ATTR_EMOTION + \",\" + value + \") should not be empty\", \n+                result.isEmpty());\n+    }\n+\n+    /**\n+     * Tests that a relation can be queried predicated on a multiple attribute\n+     * key-value pair. This requires multiple joins. Single join will produce\n+     * wrong result.\n+     */\n+    public void testQueryRelationOnMultipleAttributeKeyValuePairs() {\n+        String jpql = \"select r from Relation r join r.attrs a1 join r.attrs a2 \"\n+                + \"where key(a1) = :key1 and value(a1) = :value1 \" + \"and key(a2) = :key2 and value(a2) = :value2\";\n+        String value = EMOTIONS[0][2].toString();\n+        List<Relation> result = em.createQuery(jpql, Relation.class)\n+                                  .setParameter(\"key1\", ATTR_EMOTION)\n+                                  .setParameter(\"value1\", value)\n+                                  .setParameter(\"key2\", ATTR_SINCE)\n+                                  .setParameter(\"value2\", SINCE.toString())\n+                                  .getResultList();\n+\n+        assertFalse(\"Result of [\" + jpql + \"] on key-value = (\" + ATTR_EMOTION + \",\" + value \n+                + \") and key-value=(\"  + ATTR_SINCE + \",\" + SINCE + \") should not be empty\", \n+                result.isEmpty());\n+\n+        String wrongJPQL = \"select r from Relation r join r.attrs a \"  \n+                         + \"where key(a) = :key1 and value(a) = :value1 \"\n+                         + \"and key(a) = :key2 and value(a) = :value2\";\n+        List<Relation> result2 = em.createQuery(wrongJPQL, Relation.class)\n+                                   .setParameter(\"key1\", ATTR_EMOTION)\n+                                   .setParameter(\"value1\", value)\n+                                   .setParameter(\"key2\", ATTR_SINCE)\n+                                   .setParameter(\"value2\", SINCE.toString())\n+                                   .getResultList();\n+\n+        assertTrue(\"Result of [\" + jpql + \"] on key-value = (\" + ATTR_EMOTION + \",\" + value \n+                + \") and key-value=(\"+ ATTR_SINCE + \",\" + SINCE + \") should be empty\", \n+                result2.isEmpty());\n+    }\n+\n+    public void testAddRemoveAttribute() {\n+        em.getTransaction().begin();\n+        People p1 = em.find(People.class, SSN[0]);\n+        String jpql = \"select r from Relation r where r.source = :node\";\n+        List<Relation> r = em.createQuery(jpql, Relation.class)\n+                            .setHint(QueryHints.HINT_IGNORE_PREPARED_QUERY, true)\n+                            .setParameter(\"node\", p1)\n+                            .getResultList();\n+        assertFalse(r.isEmpty());\n+        r.get(0).addAttribute(\"new-key\", \"new-value\");\n+        em.getTransaction().commit();\n+        em.clear();\n+        \n+        em.getTransaction().begin();\n+        jpql = \"select r from Relation r join r.attrs a where key(a) = :key\";\n+        Relation newR = em.createQuery(jpql, Relation.class)\n+                          .setParameter(\"key\", \"new-key\")\n+                          .getSingleResult();\n+        assertNotNull(newR);\n+        assertEquals(\"new-value\", newR.getAttribute(\"new-key\"));\n+        newR.removeAttribute(\"new-key\");\n+        em.getTransaction().commit();\n+        \n+        em.getTransaction().begin();\n+        jpql = \"select r from Relation r join r.attrs a where key(a) = :key\";\n+        try {\n+            newR = em.createQuery(jpql, Relation.class)\n+                          .setParameter(\"key\", \"new-key\")\n+                          .getSingleResult();\n+            fail(jpql + \" with new-key expected no result\");\n+        } catch (NoResultException nre) {\n+            // this is what is expected\n+        } finally {\n+            em.getTransaction().rollback();\n+        }\n+    }\n+    \n+    boolean isPopulated() {\n+        return em.createQuery(\"select count(p) from People p\", Long.class).getSingleResult() > 0;\n+    }\n+\n+    /**\n+     * Creates a typical graph of People and Cities. The tests are sensitive to\n+     * the actual values and relations set in in this method.\n+     */\n+    void createData() {\n+        if (isPopulated())\n+            return;\n+        em.getTransaction().begin();\n+\n+        People[] people = new People[SSN.length];\n+        for (int i = 0; i < SSN.length; i++) {\n+            People p = new People();\n+            em.persist(p);\n+            p.setSsn(SSN[i]);\n+            p.setName(PERSON_NAMES[i]);\n+            people[i] = p;\n+        }\n+        City[] cities = new City[CITY_NAMES.length];\n+        for (int i = 0; i < CITY_NAMES.length; i++) {\n+            City c = new City();\n+            em.persist(c);\n+            c.setName(CITY_NAMES[i]);\n+            cities[i] = c;\n+        }\n+        for (int i = 0; i < people.length; i++) {\n+            for (int j = 0; j < people.length; j++) {\n+                if (EMOTIONS[i][j] != null) {\n+                    Relation<People, People> r = people[i].link(people[j]).addAttribute(ATTR_EMOTION, EMOTIONS[i][j]);\n+                    if (i == 0 && j == 2) {\n+                        r.addAttribute(ATTR_SINCE, SINCE);\n+                    }\n+                }\n+            }\n+        }\n+        for (int i = 0; i < cities.length; i++) {\n+            for (int j = 0; j < cities.length; j++) {\n+                cities[i].link(cities[j]).addAttribute(ATTR_DISTANCE, ATTR_DISTANCE_VALUE[i][j]);\n+            }\n+        }\n+\n+        for (int i = 0; i < people.length; i++) {\n+            people[i].link(cities[i % CITY_NAMES.length]);\n+        }\n+\n+        em.getTransaction().commit();\n+    }\n+\n+    void assertDataEquals(People[] people, City[] cities) {\n+        assertEquals(SSN.length, people.length);\n+        assertEquals(CITY_NAMES.length, cities.length);\n+        \n+        for (int i = 0; i < people.length; i++) {\n+            People p = people[i];\n+            assertEquals(SSN[i], p.getSsn());\n+            assertEquals(PERSON_NAMES[i], p.getName());\n+        }\n+        for (int i = 0; i < cities.length; i++) {\n+            City c = cities[i];\n+            assertEquals(CITY_NAMES[i], c.getName());\n+        }\n+        for (int i = 0; i < people.length; i++) {\n+            People p1 = people[i];\n+            for (int j = 0; j < people.length; j++) {\n+                People p2 = people[j];\n+                Relation<People, People> r = p1.getRelationTo(p2);\n+                if (EMOTIONS[i][j] != null) {\n+                    assertNotNull(r);\n+                    assertEquals(EMOTIONS[i][j].toString(), r.getAttribute(ATTR_EMOTION));\n+                } else {\n+                    assertNull(r);\n+                }\n+            }\n+        }\n+        for (int i = 0; i < cities.length; i++) {\n+            City c1 = cities[i];\n+            for (int j = 0; j < cities.length; j++) {\n+                City c2 = cities[j];\n+                Relation<City, City> r12 = c1.getRelationTo(c2);\n+                assertNotNull(r12);\n+                assertEquals(\"\"+ATTR_DISTANCE_VALUE[i][j], r12.getAttribute(ATTR_DISTANCE));\n+            }\n+        }\n+\n+        for (int i = 0; i < people.length; i++) {\n+            People p = people[i];\n+            for (int j = 0; j < cities.length; j++) {\n+                City c = cities[j];\n+                Relation<People, City> r = p.getRelationTo(c);\n+                if (i % CITY_NAMES.length == j) {\n+                    assertNotNull(r);\n+                } else {\n+                    assertNull(r);\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    int indexOf(People p) {\n+        for (int i = 0; i < SSN.length; i++) {\n+            if (SSN[i] == p.getSsn())\n+                return i;\n+        }\n+        return -1;\n+    }\n+\n+    int indexOf(City c) {\n+        for (int i = 0; i < CITY_NAMES.length; i++) {\n+            if (CITY_NAMES[i].equals(c.getName()))\n+                return i;\n+        }\n+        return -1;\n+    }\n+}"},{"sha":"c1077f5e0f096b118ed2029653a20428858157b2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Vertex.java","status":"added","additions":155,"deletions":0,"changes":155,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Vertex.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Vertex.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/graph/Vertex.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.graph;\n+\n+import java.io.Serializable;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.MappedSuperclass;\n+import javax.persistence.OneToMany;\n+\n+/**\n+ * Vertex of a persistent graph.\n+ * <br>\n+ * A vertex maintains relationship to other connected vertices. \n+ * An abstract vertex provides the functionality for a concrete derivation to be member of a graph. \n+ * <br>\n+ * A generic vertex does <em>not</em> define a persistent identity on the derived types. \n+ * <br>\n+ * The only persistent state maintained by a generic vertex is its ({@linkplain Relation relations}\n+ * to its neighboring vertices.\n+ * <br>\n+ * @author Pinaki Poddar\n+ *\n+ * @param <V> the type of this vertex.\n+ */\n+@SuppressWarnings(\"serial\")\n+\n+@MappedSuperclass\n+public abstract class Vertex<V> implements Serializable {\n+    /**\n+     * A set of relations starting from this vertex.\n+     * A vertex owns its relations in a object modeling sense but not in a JPA sense.\n+     * In a object modeling sense, a relation can not exist without its source vertex.  \n+     * In a JPA sense, the relational table for a Relation holds a foreign key to the source vertex, \n+     * so Relation is the owner of vertex-Relation relation, confusing, eh?  \n+     */\n+    @OneToMany(mappedBy=\"source\", \n+            cascade=CascadeType.ALL, \n+            orphanRemoval=true, \n+            targetEntity=Relation.class)\n+    private Set<Relation<V,?>> relations;\n+    \n+    /**\n+     * Create a relation to the given vertex from this vertex, if no such relation exists.\n+     * If a relation exists, returns the existing relation.\n+     *  \n+     * @param n a non-null vertex.\n+     */\n+    public <V2> Relation<V,V2> link(Vertex<V2> n) {\n+        if (n == null) {\n+            throw new NullPointerException(this + \" can not link to null target\");\n+        }\n+        Relation<V,V2> r = getRelationTo(n);\n+        if (r == null) {\n+            r = new Relation<V,V2>(this, n);\n+            if (relations == null) {\n+                relations = new HashSet<Relation<V,?>>();\n+            }\n+            relations.add(r);\n+        }\n+        return r;\n+    }\n+    \n+    /**\n+     * Breaks the relation, if exists, from this vertex to the given vertex.\n+     * Returns the broken link.\n+     * \n+     * @param n a vertex, possibly null.\n+     */\n+    public <V2> Relation<V,V2> delink(Vertex<V2> n) {\n+        Relation<V,V2> r = getRelationTo(n);\n+        if (r != null) {\n+            relations.remove(r);\n+        }\n+        return r;\n+    }\n+    \n+    /**\n+     * Gets the relation from this vertex to the given vertex, if exists. Null otherwise.\n+     * \n+     * @param n a vertex, possibly null.\n+     */\n+    public <V2> Relation<V,V2> getRelationTo(Vertex<V2> n) {\n+        if (n == null || relations == null)\n+            return null;\n+        for (Relation<V,?> r : relations) {\n+            if (r.getTarget().equals(n)) {\n+                return (Relation<V,V2>)r;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * Affirms if the given vertex is linked from this vertex.\n+     */\n+    public boolean isRelatedTo(Vertex<V> n) {\n+        return getRelationTo(n) != null;\n+    }\n+    \n+    /**\n+     * Gets all the relations starting from this vertex.\n+     */\n+    public Set<Relation<V,?>> getRelations() {\n+        return relations;\n+    }\n+    \n+    /**\n+     * Gets all the immediate neighbors.\n+     */\n+    public Set<Vertex<?>> getNeighbours() {\n+        if (relations == null)\n+            return null;\n+        Set<Vertex<?>> neighbours = new HashSet<Vertex<?>>();\n+        for (Relation<V,?> r : relations) {\n+            neighbours.add(r.getTarget());\n+        }\n+        return neighbours;\n+    }\n+\n+    /**\n+     * Gets all the immediate neighbors of the given type.\n+     */\n+    public <T> Set<Vertex<T>> getNeighbours(Class<T> type, boolean allowSubclass) {\n+        if (relations == null)\n+            return null;\n+        Set<Vertex<T>> neighbours = new HashSet<Vertex<T>>();\n+        for (Relation<V,?> r : relations) {\n+            Vertex<?> target = r.getTarget();\n+            boolean include = allowSubclass ? type.isAssignableFrom(target.getClass()) : type == target.getClass();\n+            if (include)\n+                neighbours.add((Vertex<T>)target);\n+        }\n+        return neighbours;\n+    }\n+\n+}"},{"sha":"7ba4c3222619eac8c5a81de0305b9eda1ac82fd4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/annotations/TestEmbeddableSuperclass.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/annotations/TestEmbeddableSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/annotations/TestEmbeddableSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/annotations/TestEmbeddableSuperclass.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -107,7 +107,7 @@ public void testRelationMappings() {\n         assertTrue(fm.getStrategy() instanceof RelationFieldStrategy);\n \n         fm = cls.getFieldMapping(\"sup\");\n-        assertTrue(fm.getStrategy() instanceof EmbedFieldStrategy);\n+        assertEquals(RelationFieldStrategy.class, fm.getStrategy().getClass());\n     }\n \n     public void testPersistAndFind() {"},{"sha":"da7ccd8dd30c442635cf274e5dc83cd34248273a","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -85,6 +85,7 @@\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n+import java.util.Properties;\n import java.util.Set;\n import java.util.Stack;\n import java.util.TreeSet;\n@@ -1285,7 +1286,7 @@ protected boolean handleUnknownMemberAnnotation(FieldMetaData fmd,\n     /**\n      * Convert the given class to its OpenJPA type override equivalent.\n      */\n-    private static Class<?> toOverrideType(Class<?> cls) {\n+    public static Class<?> toOverrideType(Class<?> cls) {\n         return (cls == Entity.class)\n             ? org.apache.openjpa.enhance.PersistenceCapable.class : cls;\n     }\n@@ -1506,12 +1507,12 @@ private void parseManyToMany(FieldMetaData fmd, ManyToMany anno) {\n             case JavaTypes.ARRAY:\n             case JavaTypes.COLLECTION:\n             case JavaTypes.MAP:\n-                if (JavaTypes.maybePC(fmd.getElement()))\n+                if (fmd.getDeclaredType() == Properties.class || JavaTypes.maybePC(fmd.getElement()))\n                     break;\n                 // no break\n             default:\n                 throw new MetaDataException(_loc.get(\"bad-meta-anno\", fmd,\n-                    \"OneToMany\"));\n+                    \"ManyToMany\"));\n         }\n \n         fmd.setInDefaultFetchGroup(anno.fetch() == FetchType.EAGER);"},{"sha":"aa16d80bac730ab0b967658e74c980d06e8172a5","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/a873065db7f3b9190ff47a88bff1b2cbce3d3e89/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java?ref=a873065db7f3b9190ff47a88bff1b2cbce3d3e89","patch":"@@ -33,6 +33,7 @@\n import java.util.Stack;\n \n import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n import javax.persistence.GenerationType;\n import javax.persistence.LockModeType;\n import javax.persistence.NamedQuery;\n@@ -1467,7 +1468,7 @@ protected void parseOneToOne(FieldMetaData fmd, Attributes attrs)\n         }\n         val = attrs.getValue(\"target-entity\");\n         if (val != null)\n-            fmd.setTypeOverride(classForName(val));\n+            fmd.setTypeOverride(AnnotationPersistenceMetaDataParser.toOverrideType(classForName(val)));\n         assertPC(fmd, \"OneToOne\");\n         fmd.setSerialized(false); // override any Lob annotation\n         boolean orphanRemoval = Boolean.valueOf(attrs.getValue(\n@@ -1489,7 +1490,7 @@ protected void parseManyToOne(FieldMetaData fmd, Attributes attrs)\n         }\n         val = attrs.getValue(\"target-entity\");\n         if (val != null)\n-            fmd.setTypeOverride(classForName(val));\n+            fmd.setTypeOverride(AnnotationPersistenceMetaDataParser.toOverrideType(classForName(val)));\n         assertPC(fmd, \"ManyToOne\");\n         fmd.setSerialized(false); // override any Lob annotation\n         String mapsId = attrs.getValue(\"maps-id\");"}]}

