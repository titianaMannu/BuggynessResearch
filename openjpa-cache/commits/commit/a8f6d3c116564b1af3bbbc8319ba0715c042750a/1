{"sha":"a8f6d3c116564b1af3bbbc8319ba0715c042750a","node_id":"MDY6Q29tbWl0MjA2MzY0OmE4ZjZkM2MxMTY1NjRiMWFmM2JiYmM4MzE5YmEwNzE1YzA0Mjc1MGE=","commit":{"author":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2008-01-24T01:33:48Z"},"committer":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2008-01-24T01:33:48Z"},"message":"OPENJPA-477 Making StoreManager more flexible and extensible\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@614763 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"f73b9d3f89d4ecd7fca0a7fea00b7ad822f80f1d","url":"https://api.github.com/repos/apache/openjpa/git/trees/f73b9d3f89d4ecd7fca0a7fea00b7ad822f80f1d"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/a8f6d3c116564b1af3bbbc8319ba0715c042750a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/a8f6d3c116564b1af3bbbc8319ba0715c042750a","html_url":"https://github.com/apache/openjpa/commit/a8f6d3c116564b1af3bbbc8319ba0715c042750a","comments_url":"https://api.github.com/repos/apache/openjpa/commits/a8f6d3c116564b1af3bbbc8319ba0715c042750a/comments","author":null,"committer":null,"parents":[{"sha":"8d18daabd722e39dae258ab33f74c561b4965496","url":"https://api.github.com/repos/apache/openjpa/commits/8d18daabd722e39dae258ab33f74c561b4965496","html_url":"https://github.com/apache/openjpa/commit/8d18daabd722e39dae258ab33f74c561b4965496"}],"stats":{"total":637,"additions":499,"deletions":138},"files":[{"sha":"46886b036659cbdc349d3fa11425c6e7b4f53a27","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractUpdateManager.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractUpdateManager.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractUpdateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractUpdateManager.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -181,7 +181,7 @@ protected Collection addException(Collection exceps, Exception err) {\n     /**\n      * Recursive method to insert the given instance, base class first.\n      */\n-    private void insert(OpenJPAStateManager sm, ClassMapping mapping,\n+    protected void insert(OpenJPAStateManager sm, ClassMapping mapping,\n         RowManager rowMgr, JDBCStore store, Collection customs)\n         throws SQLException {\n         Boolean custom = mapping.isCustomInsert(sm, store);\n@@ -228,7 +228,7 @@ private boolean bufferCustomInsert(Strategy strat, OpenJPAStateManager sm,\n     /**\n      * Recursive method to delete the given instance, base class last.\n      */\n-    private void delete(OpenJPAStateManager sm, ClassMapping mapping,\n+    protected void delete(OpenJPAStateManager sm, ClassMapping mapping,\n         RowManager rowMgr, JDBCStore store, Collection customs)\n         throws SQLException {\n         Boolean custom = mapping.isCustomDelete(sm, store);\n@@ -271,7 +271,7 @@ private boolean bufferCustomDelete(Strategy strat, OpenJPAStateManager sm,\n     /**\n      * Recursive method to update the given instance.\n      */\n-    private void update(OpenJPAStateManager sm, BitSet dirty,\n+    protected void update(OpenJPAStateManager sm, BitSet dirty,\n         ClassMapping mapping, RowManager rowMgr, JDBCStore store,\n         Collection customs) throws SQLException {\n         Boolean custom = mapping.isCustomUpdate(sm, store);\n@@ -300,7 +300,7 @@ private void update(OpenJPAStateManager sm, BitSet dirty,\n     /**\n      * Update version and discriminator indicators.\n      */\n-    private void updateIndicators(OpenJPAStateManager sm, ClassMapping mapping,\n+    protected void updateIndicators(OpenJPAStateManager sm, ClassMapping mapping,\n         RowManager rowMgr, JDBCStore store, Collection customs,\n         boolean versionUpdateOnly) throws SQLException {\n         while (mapping.getJoinablePCSuperclassMapping() != null)"},{"sha":"df3e36e92e9a2cc0fed7e050967641ac3e6c7dd5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCBrokerFactory.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCBrokerFactory.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -140,7 +140,7 @@ protected BrokerImpl newBrokerImpl(String user, String pass) {\n     /**\n      * Synchronize the mappings of the classes listed in the configuration.\n      */\n-    private void synchronizeMappings(ClassLoader loader) {\n+    protected void synchronizeMappings(ClassLoader loader) {\n         JDBCConfiguration conf = (JDBCConfiguration) getConfiguration();\n         String action = conf.getSynchronizeMappings();\n         if (StringUtils.isEmpty(action))"},{"sha":"003f70d4ac14f5d2b72b6c0e851ee6a7e90fd572","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","status":"modified","additions":36,"deletions":9,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -272,7 +272,7 @@ public boolean initialize(OpenJPAStateManager sm, PCState state,\n     /**\n      * Initialize a newly-loaded instance.\n      */\n-    private boolean initializeState(OpenJPAStateManager sm, PCState state,\n+    protected boolean initializeState(OpenJPAStateManager sm, PCState state,\n         JDBCFetchConfiguration fetch, ConnectionInfo info)\n         throws ClassNotFoundException, SQLException {\n         Object oid = sm.getObjectId();\n@@ -294,7 +294,7 @@ private boolean initializeState(OpenJPAStateManager sm, PCState state,\n                     Select.SUBS_EXACT);\n                 if (res == null && !selectPrimaryKey(sm, mapping, fetch))\n                     return false;\n-                if (res != null && !res.next())\n+                if (isEmptyResult(res))\n                     return false;\n             } else {\n                 ClassMapping[] mappings = mapping.\n@@ -311,16 +311,14 @@ private boolean initializeState(OpenJPAStateManager sm, PCState state,\n                 } else\n                     res = getInitializeStateUnionResult(sm, mapping, mappings,\n                         fetch);\n-                if (res != null && !res.next())\n+                if (isEmptyResult(res))\n                     return false;\n             }\n \n             // figure out what type of object this is; the state manager\n             // only guarantees to provide a base class\n             Class type;\n-            if (res == null)\n-                type = mapping.getDescribedType();\n-            else {\n+            if ((type = getType(res, mapping)) == null) {\n                 if (res.getBaseMapping() != null)\n                     mapping = res.getBaseMapping();\n                 res.startDataRequest(mapping.getDiscriminator());\n@@ -342,14 +340,43 @@ private boolean initializeState(OpenJPAStateManager sm, PCState state,\n                 // re-get the mapping in case the instance was a subclass\n                 mapping = (ClassMapping) sm.getMetaData();\n                 load(mapping, sm, fetch, res);\n-                mapping.getVersion().afterLoad(sm, this);\n+                getVersion(mapping, sm, res);\n             }\n             return true;\n         } finally {\n             if (res != null && (info == null || res != info.result))\n                 res.close();\n         }\n     }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of getting version from the result set.\n+     */\n+    protected void getVersion(ClassMapping mapping, OpenJPAStateManager sm,\n+        Result res) throws SQLException {\n+        mapping.getVersion().afterLoad(sm, this);\n+    }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of checking whether the result set is empty or not.\n+     */\n+    protected boolean isEmptyResult(Result res) throws SQLException {\n+        if (res != null && !res.next())\n+            return true;\n+        return false;\n+    }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of getting type from the result set.\n+     */\n+    protected Class getType(Result res, ClassMapping mapping){\n+        if (res == null)\n+            return mapping.getDescribedType();\n+        return null;\n+    }\n \n     /**\n      * Allow the mapping to custom load data. Return null if the mapping\n@@ -427,7 +454,7 @@ private boolean selectPrimaryKey(OpenJPAStateManager sm,\n         sel.wherePrimaryKey(sm.getObjectId(), base, this);\n         Result exists = sel.execute(this, fetch);\n         try {\n-            if (!exists.next())\n+            if (isEmptyResult(exists))\n                 return false;\n \n             // record locked?\n@@ -478,7 +505,7 @@ public boolean load(OpenJPAStateManager sm, BitSet fields,\n                 sel.wherePrimaryKey(sm.getObjectId(), mapping, this);\n                 res = sel.execute(this, jfetch, lockLevel);\n                 try {\n-                    if (!res.next())\n+                 \tif (isEmptyResult(res))\n                         return false;\n                     load(mapping, sm, jfetch, res);\n                 } finally {"},{"sha":"ccbf964e207fb24cd11d9d1b8db917eb1bef4739","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","status":"modified","additions":21,"deletions":3,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -499,11 +499,11 @@ private Number executeBulkOperation(ClassMetaData[] metas,\n             for (int i = 0; i < sql.length; i++) {\n                 stmnt = null;\n                 try {\n-                    stmnt = sql[i].prepareStatement(conn);\n-                    count += stmnt.executeUpdate();\n+                    stmnt = prepareStatement(conn, sql[i]);\n+                    count += executeUpdate(conn, stmnt, sql[i], isUpdate);                    \n                 } catch (SQLException se) {\n                     throw SQLExceptions.getStore(se, sql[i].getSQL(), \n-                    \t\t_store.getDBDictionary());\n+                        _store.getDBDictionary());\n                 } finally {\n                     if (stmnt != null)\n                         try { stmnt.close(); } catch (SQLException se) {}\n@@ -649,4 +649,22 @@ protected Number executeUpdate(ClassMetaData base, ClassMetaData[] metas,\n             sql[i] = ((Select) sels.get(i)).toSelect(false, fetch).getSQL(true);\n         return sql;\n     }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of executing update.\n+     */\n+    protected int executeUpdate(Connection conn, PreparedStatement stmnt, \n+        SQLBuffer sqlBuf, boolean isUpdate) throws SQLException {\n+        return stmnt.executeUpdate();\n+    }\n+            \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of preparing statement.\n+     */\n+    protected PreparedStatement prepareStatement(Connection conn, SQLBuffer sql)\n+        throws SQLException {\n+        return sql.prepareStatement(conn);\n+    }    \n }"},{"sha":"e08fbdea961159cc2ac9b6fbf09f82f00c762f87","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","status":"modified","additions":54,"deletions":12,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -132,18 +132,10 @@ private void lockRow(OpenJPAStateManager sm, int timeout) {\n         PreparedStatement stmnt = null;\n         ResultSet rs = null;\n         try {\n-            stmnt = sql.prepareStatement(conn);\n-            if (timeout >= 0 && dict.supportsQueryTimeout) {\n-                if (timeout < 1000) {\n-                    timeout = 1000;\n-                    if (log.isWarnEnabled())\n-                        log.warn(_loc.get(\"millis-query-timeout\"));\n-                }\n-                stmnt.setQueryTimeout(timeout / 1000);\n-            }\n-            rs = stmnt.executeQuery();\n-            if (!rs.next())\n-                throw new LockException(sm.getManagedInstance());\n+            stmnt = prepareStatement(conn, sql);\n+            setTimeout(stmnt, timeout);\n+            rs = executeQuery(conn, stmnt, sql);\n+            checkLock(rs, sm);\n         } catch (SQLException se) {\n             throw SQLExceptions.getStore(se, dict);\n         } finally {\n@@ -168,4 +160,54 @@ private void ensureStoreManagerTransaction() {\n                 log.info(_loc.get(\"start-trans-for-lock\"));\n         }\n     }\n+    \n+    public JDBCStore getStore() {\n+        return _store;\n+    }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of preparing statement.\n+     */\n+    protected PreparedStatement prepareStatement(Connection conn, SQLBuffer sql)\n+        throws SQLException {\n+        return sql.prepareStatement(conn);\n+    }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of setting query timeout.\n+     */\n+    protected void setTimeout(PreparedStatement stmnt, int timeout)\n+        throws SQLException {\n+        DBDictionary dict = _store.getDBDictionary();\n+        if (timeout >= 0 && dict.supportsQueryTimeout) {\n+            if (timeout < 1000) {\n+                timeout = 1000;\n+                if (log.isWarnEnabled())\n+                    log.warn(_loc.get(\"millis-query-timeout\"));\n+            }\n+            stmnt.setQueryTimeout(timeout / 1000);\n+        }\n+    }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of executing query.\n+     */\n+    protected ResultSet executeQuery(Connection conn, PreparedStatement stmnt, \n+        SQLBuffer sql) throws SQLException {\n+        return stmnt.executeQuery();\n+    }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of checking lock from the result set.\n+     */\n+    protected void checkLock(ResultSet rs, OpenJPAStateManager sm)\n+        throws SQLException { \n+        if (!rs.next())\n+            throw new LockException(sm.getManagedInstance());\n+        return;\n+    }\n }"},{"sha":"02c77e728f8902674a6036c0db689c6f7347c337","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManagerImpl.java","status":"modified","additions":25,"deletions":6,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManagerImpl.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -35,7 +35,6 @@\n import org.apache.openjpa.util.ApplicationIds;\n import org.apache.openjpa.util.OpenJPAException;\n import org.apache.openjpa.util.OptimisticException;\n-import org.apache.openjpa.meta.ClassMetaData;\n \n /**\n  * Basic prepared statement manager implementation.\n@@ -89,12 +88,13 @@ protected void flushInternal(RowImpl row) throws SQLException {\n \n         // prepare statement\n         String sql = row.getSQL(_dict);\n-        PreparedStatement stmnt = _conn.prepareStatement(sql);\n-\n+        PreparedStatement stmnt = prepareStatement(sql);\n+        \n         // setup parameters and execute statement\n-        row.flush(stmnt, _dict, _store);\n+        if (stmnt != null)\n+            row.flush(stmnt, _dict, _store);\n         try {\n-            int count = stmnt.executeUpdate();\n+            int count = executeUpdate(stmnt, sql, row);\n             if (count != 1) {\n                 Object failed = row.getFailedObject();\n                 if (failed != null)\n@@ -107,7 +107,8 @@ else if (row.getAction() == Row.ACTION_INSERT)\n         } catch (SQLException se) {\n             throw SQLExceptions.getStore(se, row.getFailedObject(), _dict);\n         } finally {\n-            try { stmnt.close(); } catch (SQLException se) {}\n+            if (stmnt != null)\n+               try { stmnt.close(); } catch (SQLException se) {}\n         }\n \n         // set auto assign values\n@@ -128,4 +129,22 @@ else if (row.getAction() == Row.ACTION_INSERT)\n \n     public void flush() {\n     }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of executing update.\n+     */\n+    protected int executeUpdate(PreparedStatement stmnt, String sql, \n+        RowImpl row) throws SQLException {\n+        return stmnt.executeUpdate();\n+    }\n+        \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of preparing statement.\n+     */\n+    protected PreparedStatement prepareStatement(String sql)\n+        throws SQLException {\n+        return _conn.prepareStatement(sql);\n+    }    \n }"},{"sha":"0b0044c143ca488b1f5501f740919d8b206c5686","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java","status":"modified","additions":82,"deletions":18,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/SQLStoreQuery.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -23,6 +23,7 @@\n import java.io.StringReader;\n import java.sql.Connection;\n import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n import java.sql.SQLException;\n import java.util.ArrayList;\n import java.util.Arrays;\n@@ -157,7 +158,7 @@ public boolean requiresParameterDeclarations() {\n     /**\n      * Executes the filter as a SQL query.\n      */\n-    private static class SQLExecutor\n+    protected static class SQLExecutor\n         extends AbstractExecutor {\n \n         private final ClassMetaData _meta;\n@@ -224,20 +225,14 @@ public Number executeUpdate(StoreQuery q, Object[] params) {\n \n             PreparedStatement stmnt = null;\n             try {\n-                stmnt = buf.prepareCall(conn);\n+                stmnt = prepareCall(conn, buf);\n \n                 int index = 0;\n-                for (Iterator i = paramList.iterator(); i.hasNext();)\n+                for (Iterator i = paramList.iterator(); i.hasNext() && \n+                    stmnt != null;)\n                     dict.setUnknown(stmnt, ++index, i.next(), null);\n                 \n-                int count = 0;\n-                if (_call && stmnt.execute() == false) {\n-                    count = stmnt.getUpdateCount();\n-                }\n-                else {\n-                    // native insert, update, delete\n-                    count = stmnt.executeUpdate();\n-                }\n+                int count = executeUpdate(store, conn, stmnt, buf);                \n                 return Numbers.valueOf(count);\n             } catch (SQLException se) {\n                 if (stmnt != null)\n@@ -276,20 +271,23 @@ public ResultObjectProvider executeQuery(StoreQuery q,\n             try {\n                 // use the right method depending on sel vs. proc, lrs setting\n                 if (_select && !range.lrs)\n-                    stmnt = buf.prepareStatement(conn);\n+                    stmnt = prepareStatement(conn, buf);\n                 else if (_select)\n-                    stmnt = buf.prepareStatement(conn, fetch, -1, -1);\n+                    stmnt = prepareStatement(conn, buf, fetch, -1, -1);\n                 else if (!range.lrs)\n-                    stmnt = buf.prepareCall(conn);\n+                    stmnt = prepareCall(conn, buf);\n                 else\n-                    stmnt = buf.prepareCall(conn, fetch, -1, -1);\n+                    stmnt = prepareCall(conn, buf, fetch, -1, -1);\n \n                 int index = 0;\n-                for (Iterator i = paramList.iterator(); i.hasNext();)\n+                for (Iterator i = paramList.iterator(); i.hasNext() && \n+                    stmnt != null;)\n                     dict.setUnknown(stmnt, ++index, i.next(), null);\n \n-                ResultSetResult res = new ResultSetResult(conn, stmnt,\n-                    stmnt.executeQuery(), store);\n+                ResultSet rs = executeQuery(store, conn, stmnt, buf, paramList);\n+                ResultSetResult res = stmnt != null ? \n+                    new ResultSetResult(conn, stmnt, rs, store) :\n+                    new ResultSetResult(conn, rs, dict);\n                 if (_resultMapping != null)\n                     rop = new MappedQueryResultObjectProvider(_resultMapping,\n                         store, fetch, res);\n@@ -319,5 +317,71 @@ else if (q.getContext().getCandidateType() != null)\n         public boolean isPacking(StoreQuery q) {\n             return q.getContext().getCandidateType() == null;\n         }\n+        \n+        /**\n+         * This method is to provide override for non-JDBC or JDBC-like \n+         * implementation of preparing call statement.\n+         */\n+        protected PreparedStatement prepareCall(Connection conn, SQLBuffer buf)\n+            throws SQLException {\n+            return buf.prepareCall(conn);            \n+        }\n+        \n+        /**\n+         * This method is to provide override for non-JDBC or JDBC-like \n+         * implementation of executing update.\n+         */\n+        protected int executeUpdate(JDBCStore store, Connection conn, \n+            PreparedStatement stmnt, SQLBuffer buf) \n+            throws SQLException {\n+            int count = 0;\n+            if (_call && stmnt.execute() == false) {\n+                count = stmnt.getUpdateCount();\n+            }\n+            else {\n+                // native insert, update, delete\n+                count = stmnt.executeUpdate();\n+            }\n+            return count;\n+        }\n+        \n+        /**\n+         * This method is to provide override for non-JDBC or JDBC-like \n+         * implementation of preparing call statement.\n+         */\n+        protected PreparedStatement prepareCall(Connection conn, SQLBuffer buf,\n+            JDBCFetchConfiguration fetch, int rsType, int rsConcur)\n+            throws SQLException {\n+            return buf.prepareCall(conn, fetch, rsType, rsConcur);  \n+        }\n+\n+        /**\n+         * This method is to provide override for non-JDBC or JDBC-like \n+         * implementation of preparing statement.\n+         */\n+        protected PreparedStatement prepareStatement(Connection conn, \n+            SQLBuffer buf) throws SQLException {\n+            return buf.prepareStatement(conn);\n+        }\n+        \n+        /**\n+         * This method is to provide override for non-JDBC or JDBC-like \n+         * implementation of preparing statement.\n+         */\n+        protected PreparedStatement prepareStatement(Connection conn, \n+            SQLBuffer buf, JDBCFetchConfiguration fetch, int rsType,\n+            int rsConcur) throws SQLException {\n+            return buf.prepareStatement(conn, fetch, rsType, rsConcur);\n+        }\n+        \n+        /**\n+         * This method is to provide override for non-JDBC or JDBC-like \n+         * implementation of executing query.\n+         */\n+        protected ResultSet executeQuery(JDBCStore store, Connection conn,\n+            PreparedStatement stmnt, SQLBuffer buf, List paramList)\n+            throws SQLException {\n+            return stmnt.executeQuery();\n+        }\n     }\n }"},{"sha":"026cb31d418e53ea5674510013c13919ba0c2857","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java","status":"modified","additions":47,"deletions":11,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -30,14 +30,14 @@\n import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.Index;\n import org.apache.openjpa.jdbc.schema.PrimaryKey;\n import org.apache.openjpa.jdbc.schema.Schema;\n import org.apache.openjpa.jdbc.schema.SchemaGroup;\n import org.apache.openjpa.jdbc.schema.SchemaTool;\n import org.apache.openjpa.jdbc.schema.Schemas;\n import org.apache.openjpa.jdbc.schema.Table;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.RowImpl;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.SQLExceptions;\n import org.apache.openjpa.lib.conf.Configurable;\n@@ -431,8 +431,8 @@ private void insertSequence(ClassMapping mapping, Connection conn)\n \n         PreparedStatement stmnt = null;\n         try {\n-            stmnt = insert.prepareStatement(conn);\n-            stmnt.executeUpdate();\n+            stmnt = prepareStatement(conn, insert);\n+            executeUpdate(_conf, conn, stmnt, insert, RowImpl.ACTION_INSERT);\n         } finally {\n             if (stmnt != null)\n                 try { stmnt.close(); } catch (SQLException se) {}\n@@ -464,17 +464,16 @@ protected long getSequence(ClassMapping mapping, Connection conn)\n                 null, false, dict.supportsSelectForUpdate, 0, Long.MAX_VALUE,\n                 false, true);\n \n-        PreparedStatement stmnt = select.prepareStatement(conn);\n+        PreparedStatement stmnt = prepareStatement(conn, select);\n         ResultSet rs = null;\n         try {\n-            rs = stmnt.executeQuery();\n-            if (!rs.next())\n-                return -1;\n-            return dict.getLong(rs, 1);\n+            rs = executeQuery(_conf, conn, stmnt, select);\n+            return getSequence(rs, dict);\n         } finally {\n             if (rs != null)\n                 try { rs.close(); } catch (SQLException se) {}\n-            try { stmnt.close(); } catch (SQLException se) {}\n+            if (stmnt != null)    \n+                try { stmnt.close(); } catch (SQLException se) {}\n         }\n     }\n \n@@ -522,8 +521,8 @@ protected boolean setSequence(ClassMapping mapping, Status stat, int inc,\n                     append(_seqColumn).append(\" = \").\n                     appendValue(Numbers.valueOf(cur), _seqColumn);\n \n-                stmnt = upd.prepareStatement(conn);\n-                updates = stmnt.executeUpdate();\n+                stmnt = prepareStatement(conn, upd);\n+                updates = executeUpdate(_conf, conn, stmnt, upd, RowImpl.ACTION_UPDATE);\n             } finally {\n                 if (rs != null) \n                     try { rs.close(); } catch (SQLException se) {}\n@@ -704,4 +703,41 @@ else if (ACTION_GET.equals(action) || ACTION_SET.equals(action)) {\n         public long seq = 1L;\n         public long max = 0L;\n     }\n+\n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of preparing statement.\n+     */\n+    protected PreparedStatement prepareStatement(Connection conn, SQLBuffer buf)\n+        throws SQLException {\n+        return buf.prepareStatement(conn);\n+    }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of executing update.\n+     */\n+    protected int executeUpdate(JDBCConfiguration conf, Connection conn,  \n+        PreparedStatement stmnt, SQLBuffer buf, int opcode) throws SQLException {\n+        return stmnt.executeUpdate();\n+    }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of executing query.\n+     */\n+    protected ResultSet executeQuery(JDBCConfiguration conf, Connection conn,\n+        PreparedStatement stmnt, SQLBuffer buf) throws SQLException {\n+        return stmnt.executeQuery();\n+    }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of getting sequence from the result set.\n+     */\n+    protected long getSequence(ResultSet rs, DBDictionary dict) throws SQLException {\n+        if (rs == null || !rs.next())\n+            return -1;\n+        return dict.getLong(rs, 1);\n+    }\n }"},{"sha":"0cff107e4814d26fe0dfa7604b791eb216f35b4c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -49,7 +49,7 @@\n  *\n  * @author Abe White\n  */\n-class PCPath\n+public class PCPath\n     extends AbstractVal\n     implements JDBCPath {\n \n@@ -549,7 +549,7 @@ private static boolean isJoinedField(FieldMapping src, boolean key,\n     /**\n      * Expression state.\n      */\n-    private static class PathExpState\n+    public static class PathExpState\n         extends ExpState {\n \n         public FieldMapping field = null;"},{"sha":"85d1d42d2e09304f9b17c47ff560fb786fca658f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -93,7 +93,7 @@ public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n     /**\n      * Expression state.\n      */\n-    private static class ParamExpState\n+    public static class ParamExpState\n         extends ConstExpState {\n \n         public Object sqlValue = null;"},{"sha":"b43d90a5908b9ee2a732f09505bbb63e3cc331de","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","status":"modified","additions":66,"deletions":22,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -87,7 +87,6 @@\n import org.apache.openjpa.kernel.Filters;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.exps.Path;\n-import org.apache.openjpa.kernel.exps.Literal;\n import org.apache.openjpa.lib.conf.Configurable;\n import org.apache.openjpa.lib.conf.Configuration;\n import org.apache.openjpa.lib.jdbc.ConnectionDecorator;\n@@ -1982,7 +1981,7 @@ protected void appendUpdates(Select sel, JDBCStore store, SQLBuffer sql,\n             ExpState state = val.initialize(sel, ctx, 0);\n             // JDBC Paths are always PCPaths; PCPath implements Val\n             ExpState pathState = ((Val) path).initialize(sel, ctx, 0);\n-            val.calculateValue(sel, ctx, state, (Val) path, pathState);\n+            calculateValue(val, sel, ctx, state, path, pathState);\n \n             // append the value with a null for the Select; i\n             // indicates that the\n@@ -3476,7 +3475,7 @@ protected Table newTable(ResultSet tableMeta)\n         if (str == null)\n             return new Sequence[0];\n \n-        PreparedStatement stmnt = conn.prepareStatement(str);\n+        PreparedStatement stmnt = prepareStatement(conn, str);        \n         ResultSet rs = null;\n         try {\n             int idx = 1;\n@@ -3485,21 +3484,19 @@ protected Table newTable(ResultSet tableMeta)\n             if (sequenceName != null)\n                 stmnt.setString(idx++, sequenceName);\n \n-            rs = stmnt.executeQuery();\n-            List seqList = new ArrayList();\n-            while (rs.next())\n-                seqList.add(newSequence(rs));\n-            return (Sequence[]) seqList.toArray(new Sequence[seqList.size()]);\n-        } finally {\n+            rs = executeQuery(conn, stmnt, str);\n+            return getSequence(rs);            \n+         } finally {\n             if (rs != null)\n                 try {\n                     rs.close();\n                 } catch (SQLException se) {\n                 }\n-            try {\n-                stmnt.close();\n-            } catch (SQLException se) {\n-            }\n+            if (stmnt != null)    \n+                try {\n+                    stmnt.close();\n+                } catch (SQLException se) {\n+                }\n         }\n     }\n \n@@ -3880,20 +3877,16 @@ public Object getGeneratedKey(Column col, Connection conn)\n             });\n         }\n \n-        PreparedStatement stmnt = conn.prepareStatement(query);\n+        PreparedStatement stmnt = prepareStatement(conn, query);\n         ResultSet rs = null;\n         try {\n-            rs = stmnt.executeQuery();\n-            if (!rs.next())\n-                throw new StoreException(_loc.get(\"no-genkey\"));\n-            Object key = rs.getObject(1);\n-            if (key == null)\n-                log.warn(_loc.get(\"invalid-genkey\", col));\n-            return key;\n+            rs = executeQuery(conn, stmnt, query);\n+            return getKey(rs, col);\n         } finally {\n             if (rs != null)\n                 try { rs.close(); } catch (SQLException se) {}\n-            try { stmnt.close(); } catch (SQLException se) {} \n+            if (stmnt != null)    \n+                try { stmnt.close(); } catch (SQLException se) {} \n         }\n     }\n \n@@ -4277,4 +4270,55 @@ public boolean validateDBSpecificBatchProcess (boolean disableBatch,\n             OpenJPAStateManager  sm, ClassMapping cmd ) {\n         return disableBatch;\n     }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of executing query.\n+     */\n+    protected ResultSet executeQuery(Connection conn, PreparedStatement stmnt, String sql \n+        ) throws SQLException {\n+        return stmnt.executeQuery();\n+    }\n+            \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of preparing statement.\n+     */\n+    protected PreparedStatement prepareStatement(Connection conn, String sql)\n+        throws SQLException {\n+        return conn.prepareStatement(sql);\n+    }    \n+ \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of getting sequence from the result set.\n+     */\n+    protected Sequence[] getSequence(ResultSet rs) throws SQLException {\n+        List seqList = new ArrayList();\n+        while (rs != null && rs.next())\n+            seqList.add(newSequence(rs));\n+        return (Sequence[]) seqList.toArray(new Sequence[seqList.size()]);\n+    }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of getting key from the result set.\n+     */\n+    protected Object getKey (ResultSet rs, Column col) throws SQLException {\n+        if (!rs.next())\n+            throw new StoreException(_loc.get(\"no-genkey\"));\n+        Object key = rs.getObject(1);\n+        if (key == null)\n+            log.warn(_loc.get(\"invalid-genkey\", col));\n+        return key;        \n+    }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of calculating value.\n+     */\n+    protected void calculateValue(Val val, Select sel, ExpContext ctx, \n+        ExpState state, Path path, ExpState pathState) {\n+        val.calculateValue(sel, ctx, state, (Val) path, pathState);\n+    }    \n }"},{"sha":"927024f01fd89eb0dfbc166e89991d5976710df8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -91,6 +91,17 @@ public ResultSetResult(Connection conn, Statement stmnt,\n         setStore(store);\n     }\n \n+    /**\n+     * Constructor.\n+     */\n+    public ResultSetResult(Connection conn,\n+        ResultSet rs, DBDictionary dict) {\n+        _conn = conn;\n+        _stmnt = null;\n+        _rs = rs;\n+        _dict = dict;\n+    }\n+\n     /**\n      * JDBC 2 constructor. Relies on being able to retrieve the statement\n      * from the result set, and the connection from the statement."},{"sha":"ce012a8b45e5ce053cae86de1c0baaef1466e760","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java","status":"modified","additions":10,"deletions":3,"changes":13,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -20,7 +20,6 @@\n \n import java.io.InputStream;\n import java.io.Reader;\n-import java.lang.reflect.Method;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.sql.Array;\n@@ -57,10 +56,10 @@\n public class RowImpl\n     implements Row, Cloneable {\n \n-    protected static final Object NULL = new Object();\n+    public static final Object NULL = new Object();\n     protected static final int VALID = 2 << 0;\n \n-    private static final int RAW = Integer.MIN_VALUE;\n+    public static final int RAW = Integer.MIN_VALUE;\n \n     protected byte flags = 0;\n     private final Column[] _cols;\n@@ -950,4 +949,12 @@ public void copyInto(RowImpl row, boolean whereOnly) {\n         if (isValid())\n             row.setValid(true);\n     }\n+    \n+    public Object[] getVals() {\n+        return _vals;\n+    }\n+    \n+    public int[] getTypes() {\n+        return _types;\n+    }\n }"},{"sha":"386245bcf7df3edbe6b63c4aa0125abb22abaa5e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","status":"modified","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -641,4 +641,12 @@ public Subselect clone(int sqlIndex, int paramIndex) {\n             return sub;\n         }\n     }\n+    \n+    public void setParameters(List params) {\n+        _params = params;\n+    }\n+    \n+    public List getColumns() {\n+        return _cols;\n+    }\n }"},{"sha":"6d0da80711acc39198c8961e9fec5e529aaec5e2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","status":"modified","additions":90,"deletions":34,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -297,10 +297,11 @@ public int getCount(JDBCStore store)\n         try {\n             SQLBuffer sql = toSelectCount();\n             conn = store.getConnection();\n-            stmnt = sql.prepareStatement(conn);\n-            rs = stmnt.executeQuery();\n-            rs.next();\n-            return rs.getInt(1);\n+            stmnt = prepareStatement(conn, sql, null, \n+                ResultSet.TYPE_FORWARD_ONLY, \n+                ResultSet.CONCUR_READ_ONLY, false);\n+            rs = executeQuery(conn, stmnt, sql, false, store);\n+            return getCount(rs);\n         } finally {\n             if (rs != null)\n                 try { rs.close(); } catch (SQLException se) {}\n@@ -342,31 +343,21 @@ protected Result execute(StoreContext ctx, JDBCStore store,\n         }\n \n         SQLBuffer sql = toSelect(forUpdate, fetch);\n-        int rsType = (isLRS() && supportsRandomAccess(forUpdate))\n+        boolean isLRS = isLRS();\n+        int rsType = (isLRS && supportsRandomAccess(forUpdate))\n             ? -1 : ResultSet.TYPE_FORWARD_ONLY;\n         Connection conn = store.getConnection();\n         PreparedStatement stmnt = null;\n         ResultSet rs = null;\n         try {\n-            if (isLRS())\n-                stmnt = sql.prepareStatement(conn, fetch, rsType, -1);\n+            if (isLRS) \n+                stmnt = prepareStatement(conn, sql, fetch, rsType, -1, true); \n             else\n-                stmnt = sql.prepareStatement(conn, rsType, -1);\n-\n-            // if this is a locking select and the lock timeout is greater than\n-            // the configured query timeout, use the lock timeout\n-            if (forUpdate && _dict.supportsQueryTimeout && fetch != null \n-                && fetch.getLockTimeout() > stmnt.getQueryTimeout() * 1000) {\n-                int timeout = fetch.getLockTimeout();\n-                if (timeout < 1000) {\n-                    timeout = 1000; \n-                    Log log = _conf.getLog(JDBCConfiguration.LOG_JDBC);\n-                    if (log.isWarnEnabled())\n-                        log.warn(_loc.get(\"millis-query-timeout\"));\n-                }\n-                stmnt.setQueryTimeout(timeout / 1000);\n-            }\n-            rs = stmnt.executeQuery();\n+                stmnt = prepareStatement(conn, sql, null, rsType, -1, false);\n+            \n+            setTimeout(stmnt, forUpdate, fetch);\n+            \n+            rs = executeQuery(conn, stmnt, sql, isLRS, store);\n         } catch (SQLException se) {\n             // clean up statement\n             if (stmnt != null)\n@@ -375,17 +366,8 @@ protected Result execute(StoreContext ctx, JDBCStore store,\n             throw se;\n         }\n \n-        SelectResult res = new SelectResult(conn, stmnt, rs, _dict);\n-        res.setSelect(this);\n-        res.setStore(store);\n-        res.setLocking(forUpdate);\n-        try {\n-            addEagerResults(res, this, store, fetch);\n-        } catch (SQLException se) {\n-            res.close();\n-            throw se;\n-        }\n-        return res;\n+        return getEagerResult(conn, stmnt, rs, store, fetch, forUpdate, \n+            sql.getSQL());\n     }\n \n     /**\n@@ -423,6 +405,80 @@ private static void addEagerResults(SelectResult res, SelectImpl sel,\n         }\n     }\n \n+\n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of preparing statement.\n+     */\n+    protected PreparedStatement prepareStatement(Connection conn, \n+        SQLBuffer sql, JDBCFetchConfiguration fetch, int rsType, \n+        int rsConcur, boolean isLRS) throws SQLException {\n+        if (fetch == null)\n+            return sql.prepareStatement(conn, rsType, rsConcur);\n+        else\n+            return sql.prepareStatement(conn, fetch, rsType, -1);\n+    }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of setting query timeout.\n+     */\n+    protected void setTimeout(PreparedStatement stmnt, boolean forUpdate,\n+        JDBCFetchConfiguration fetch) throws SQLException {\n+        // if this is a locking select and the lock timeout is greater than\n+        // the configured query timeout, use the lock timeout\n+        if (forUpdate && _dict.supportsQueryTimeout && fetch != null \n+            && fetch.getLockTimeout() > stmnt.getQueryTimeout() * 1000) {\n+            int timeout = fetch.getLockTimeout();\n+            if (timeout < 1000) {\n+                timeout = 1000; \n+                Log log = _conf.getLog(JDBCConfiguration.LOG_JDBC);\n+                if (log.isWarnEnabled())\n+                    log.warn(_loc.get(\"millis-query-timeout\"));\n+            }\n+            stmnt.setQueryTimeout(timeout / 1000);\n+        }\n+    }\n+\n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of executing query.\n+     */\n+    protected ResultSet executeQuery(Connection conn, PreparedStatement stmnt, \n+        SQLBuffer sql, boolean isLRS, JDBCStore store) throws SQLException {\n+        return stmnt.executeQuery();\n+    }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of getting count from the result set.\n+     */\n+    protected int getCount(ResultSet rs) throws SQLException {\n+        rs.next();\n+        return rs.getInt(1);\n+    }\n+    \n+    /**\n+     * This method is to provide override for non-JDBC or JDBC-like \n+     * implementation of executing eager selects.\n+     */\n+    protected Result getEagerResult(Connection conn, \n+        PreparedStatement stmnt, ResultSet rs, JDBCStore store, \n+        JDBCFetchConfiguration fetch, boolean forUpdate, String sqlStr) \n+        throws SQLException {\n+        SelectResult res = new SelectResult(conn, stmnt, rs, _dict);\n+        res.setSelect(this);\n+        res.setStore(store);\n+        res.setLocking(forUpdate);\n+        try {\n+            addEagerResults(res, this, store, fetch);\n+        } catch (SQLException se) {\n+            res.close();\n+            throw se;\n+        }\n+        return res;\n+    }\n+\n     /////////////////////////\n     // Select implementation\n     /////////////////////////"},{"sha":"b1f8e4201c016fc14463dc067b8936be65829e8c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -39,7 +39,7 @@\n  */\n public class Bootstrap {\n \n-    private static final Class[] FACTORY_ARGS =\n+    protected static final Class[] FACTORY_ARGS =\n         new Class[]{ ConfigurationProvider.class };\n \n     private static Localizer s_loc = Localizer.forPackage(Bootstrap.class);\n@@ -124,7 +124,7 @@ private static BrokerFactory invokeFactory(ConfigurationProvider conf,\n         return (BrokerFactory) meth.invoke(null, new Object[]{ conf });\n     }\n \n-    private static String getFactoryClassName(ConfigurationProvider conf,\n+    protected static String getFactoryClassName(ConfigurationProvider conf,\n         ClassLoader loader) {\n         try {\n             return getFactoryClass(conf, loader).getName();"},{"sha":"265fbb2e01e4b6e0e55edfaa966c894547b04ea3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":21,"deletions":5,"changes":26,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -2420,10 +2420,7 @@ else if (meta.getIdentityType() == ClassMetaData.ID_UNKNOWN)\n             }\n \n             // make sure we don't already have the instance cached\n-            StateManagerImpl other = getStateManagerImplById(id, false);\n-            if (other != null && !other.isDeleted() && !other.isNew())\n-                throw new ObjectExistsException(_loc.get(\"cache-exists\",\n-                    obj.getClass().getName(), id)).setFailedObject(obj);\n+            checkForDuplicateId(id, obj);\n \n             // if had embedded sm, null it\n             if (sm != null)\n@@ -3817,7 +3814,7 @@ void setStateManager(Object id, StateManagerImpl sm, int status) {\n                     _cache.remove(id, sm);\n                     break;\n                 case STATUS_OID_ASSIGN:\n-                    _cache.assignObjectId(id, sm);\n+                    assignObjectId(_cache, id, sm);\n                     break;\n                 case STATUS_COMMIT_NEW:\n                     _cache.commitNew(id, sm);\n@@ -4700,4 +4697,23 @@ public void remove() {\n             };\n         }\n     }\n+\n+    /**\n+     * Assign the object id to the cache. Exception will be\n+     * thrown if the id already exists in the cache. \n+     */\n+    protected void assignObjectId(Object cache, Object id, \n+        StateManagerImpl sm) {\n+        ((ManagedCache) cache).assignObjectId(id, sm); \n+    }\n+\n+    /** \n+     * This method makes sure we don't already have the instance cached\n+     */\n+    protected void checkForDuplicateId(Object id, Object obj) {\n+        StateManagerImpl other = getStateManagerImplById(id, false);\n+        if (other != null && !other.isDeleted() && !other.isNew())\n+            throw new ObjectExistsException(_loc.get(\"cache-exists\",\n+                obj.getClass().getName(), id)).setFailedObject(obj);\n+    }\n }"},{"sha":"380c2610e18cd85ed453aec8fd62de81eeb76d0a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -3001,7 +3001,7 @@ void replaceField(PersistenceCapable pc, FieldManager load, int field) {\n     /**\n      * Mark the field as loaded or unloaded.\n      */\n-    private void setLoaded(int field, boolean isLoaded) {\n+    public void setLoaded(int field, boolean isLoaded) {\n         // don't continue if loaded state is already correct; otherwise we\n         // can end up clearing _fieldImpl when we shouldn't\n         if (_loaded.get(field) == isLoaded)"},{"sha":"9ade648a9ce468627bb8f32ee4b463e58714c7d6","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","status":"modified","additions":17,"deletions":4,"changes":21,"blob_url":"https://github.com/apache/openjpa/blob/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","raw_url":"https://github.com/apache/openjpa/raw/a8f6d3c116564b1af3bbbc8319ba0715c042750a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java?ref=a8f6d3c116564b1af3bbbc8319ba0715c042750a","patch":"@@ -22,8 +22,6 @@\n import java.lang.instrument.IllegalClassFormatException;\n import java.security.ProtectionDomain;\n import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.Set;\n import javax.persistence.EntityManager;\n import javax.persistence.spi.ClassTransformer;\n import javax.persistence.spi.PersistenceProvider;\n@@ -73,7 +71,7 @@\n      */\n     public OpenJPAEntityManagerFactory createEntityManagerFactory(String name,\n         String resource, Map m) {\n-        PersistenceProductDerivation pd = new PersistenceProductDerivation();\n+        PersistenceProductDerivation pd = newPersistenceProductDerivation();\n         try {\n             Object poolValue = Configurations.removeProperty(EMF_POOL, m);\n             ConfigurationProvider cp = pd.load(resource, name, m);\n@@ -101,7 +99,7 @@ private BrokerFactory getBrokerFactory(ConfigurationProvider cp,\n         }\n         \n         if (poolValue == null || !((Boolean) poolValue).booleanValue())\n-            return Bootstrap.newBrokerFactory(cp, loader);\n+            return newBrokerFactory(cp, loader);\n         else\n             return Bootstrap.getBrokerFactory(cp, loader);\n     }\n@@ -201,4 +199,19 @@ public ClassLoader getClassLoader(Class context,\n             return _trans.transform(cl, name, previousVersion, pd, bytes);\n         }\n \t}\n+\n+    /**\n+     * Return a persistence product deviration with default setting.\n+     */\n+    public PersistenceProductDerivation newPersistenceProductDerivation() {\n+        return new PersistenceProductDerivation();\n+    }\n+\n+    /**\n+     * Return a broker factory for the given configuration and class loader.\n+     */\n+    public BrokerFactory newBrokerFactory(ConfigurationProvider cp,\n+        ClassLoader loader) {\n+        return Bootstrap.newBrokerFactory(cp, loader);\n+    }\n }"}]}

