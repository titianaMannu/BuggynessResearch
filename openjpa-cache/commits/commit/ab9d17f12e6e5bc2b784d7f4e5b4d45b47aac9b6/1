{"sha":"ab9d17f12e6e5bc2b784d7f4e5b4d45b47aac9b6","node_id":"MDY6Q29tbWl0MjA2MzY0OmFiOWQxN2YxMmU2ZTViYzJiNzg0ZDdmNGU1YjRkNDViNDdhYWM5YjY=","commit":{"author":{"name":"Fay Wang","email":"faywang@apache.org","date":"2009-03-10T17:37:57Z"},"committer":{"name":"Fay Wang","email":"faywang@apache.org","date":"2009-03-10T17:37:57Z"},"message":"OPENJPA-679: fix ReverseMappingTool problem\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@752178 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0a4c527642d50494d7c957850db16c420b549e9e","url":"https://api.github.com/repos/apache/openjpa/git/trees/0a4c527642d50494d7c957850db16c420b549e9e"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/ab9d17f12e6e5bc2b784d7f4e5b4d45b47aac9b6","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/ab9d17f12e6e5bc2b784d7f4e5b4d45b47aac9b6","html_url":"https://github.com/apache/openjpa/commit/ab9d17f12e6e5bc2b784d7f4e5b4d45b47aac9b6","comments_url":"https://api.github.com/repos/apache/openjpa/commits/ab9d17f12e6e5bc2b784d7f4e5b4d45b47aac9b6/comments","author":null,"committer":null,"parents":[{"sha":"4506244327679448c5622c388f4a6bb021425715","url":"https://api.github.com/repos/apache/openjpa/commits/4506244327679448c5622c388f4a6bb021425715","html_url":"https://github.com/apache/openjpa/commit/4506244327679448c5622c388f4a6bb021425715"}],"stats":{"total":27,"additions":12,"deletions":15},"files":[{"sha":"9d2e2b65a38a57f35ba86b82f24eb41991478e6f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","status":"modified","additions":12,"deletions":15,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/ab9d17f12e6e5bc2b784d7f4e5b4d45b47aac9b6/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","raw_url":"https://github.com/apache/openjpa/raw/ab9d17f12e6e5bc2b784d7f4e5b4d45b47aac9b6/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java?ref=ab9d17f12e6e5bc2b784d7f4e5b4d45b47aac9b6","patch":"@@ -35,7 +35,6 @@\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.strats.NoneClassStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.RelationFieldStrategy;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n@@ -54,10 +53,10 @@\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.ValueMetaData;\n import org.apache.openjpa.util.ApplicationIds;\n+import org.apache.openjpa.util.ImplHelper;\n import org.apache.openjpa.util.InternalException;\n import org.apache.openjpa.util.MetaDataException;\n import org.apache.openjpa.util.OpenJPAId;\n-import org.apache.openjpa.util.ImplHelper;\n \n /**\n  * Specialization of metadata for relational databases.\n@@ -89,7 +88,6 @@\n \n     // maps columns to joinables\n     private final Map _joinables = Collections.synchronizedMap(new HashMap());\n-    private boolean redoPrimaryKeyColumns = false;\n \n     /**\n      * Constructor. Supply described type and owning repository.\n@@ -418,18 +416,15 @@ public void setTable(Table table) {\n      */\n     public Column[] getPrimaryKeyColumns() {\n         if (getIdentityType() == ID_APPLICATION && isMapped()) {\n-            if (_cols.length == 0 || redoPrimaryKeyColumns) {            \n+            if (_cols.length == 0) {\n                 FieldMapping[] pks = getPrimaryKeyFieldMappings();\n                 Collection cols = new ArrayList(pks.length);\n                 Column[] fieldCols;\n                 for (int i = 0; i < pks.length; i++) {\n                     fieldCols = pks[i].getColumns();\n                     if (fieldCols.length == 0) {\n-                        // some pk columns depends on fk. At this moment, \n-                        // the fk may not contain complete information.\n-                        // need to redo the primary key again later on\n-                        redoPrimaryKeyColumns = true;\n-                        continue;\n+                        _cols = new Column[0];\n+                        return _cols;\n                     }\n                     for (int j = 0; j < fieldCols.length; j++)\n                         cols.add(fieldCols[j]);\n@@ -835,8 +830,11 @@ protected void resolveMapping(boolean runtime) {\n         FieldMapping[] fms = getFieldMappings();\n         for (int i = 0; i < fms.length; i++) {\n             if (fms[i].getDefiningMetaData() == this) {\n-                if (fms[i].getForeignKey() != null &&\n-                    fms[i].getStrategy() instanceof RelationFieldStrategy) {\n+                boolean fill = getMappingRepository().getMappingDefaults().\n+                    defaultMissingInfo();\n+                ForeignKey fk = fms[i].getForeignKey();\n+                if (fill && fk != null && \n+                    fk.getPrimaryKeyColumns().length == 0) { \n                     // set resolve mode to force this field mapping to be \n                     // resolved again. The need to resolve again occurs when \n                     // a primary key is a relation field with the foreign key\n@@ -845,11 +843,10 @@ protected void resolveMapping(boolean runtime) {\n                     // resolveNonRelationMapping. Since it is a relation\n                     // field, the foreign key will be constructed. However, \n                     // the primary key of the parent entity may not have been \n-                    // resolved yet, resulting in missing informaiton in the fk\n+                    // resolved yet, resulting in missing information in the fk\n                     fms[i].setResolve(MODE_META); \n-\n-                    // set strategy to null to force fk to be re-constructed\n-                    fms[i].setStrategy(null, false); \n+                    if (fms[i].getStrategy() != null)\n+                        fms[i].getStrategy().map(false);\n                 }                \n                 fms[i].resolve(MODE_MAPPING);\n             }"}]}

