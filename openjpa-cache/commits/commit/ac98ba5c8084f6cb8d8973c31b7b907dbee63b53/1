{"sha":"ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","node_id":"MDY6Q29tbWl0MjA2MzY0OmFjOThiYTVjODA4NGY2Y2I4ZDg5NzNjMzFiN2I5MDdkYmVlNjNiNTM=","commit":{"author":{"name":"Marc Prud'hommeaux","email":"mprudhom@apache.org","date":"2006-08-22T21:28:53Z"},"committer":{"name":"Marc Prud'hommeaux","email":"mprudhom@apache.org","date":"2006-08-22T21:28:53Z"},"message":"Split up the documentation into multiple chunks for easier management.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@433761 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"663b4dafdf375c2fcf3d840f1f5aaa031f79cd5d","url":"https://api.github.com/repos/apache/openjpa/git/trees/663b4dafdf375c2fcf3d840f1f5aaa031f79cd5d"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","html_url":"https://github.com/apache/openjpa/commit/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","comments_url":"https://api.github.com/repos/apache/openjpa/commits/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/comments","author":null,"committer":null,"parents":[{"sha":"d13c9fa4f6d136e83c86d4c0c7259149c5dd9857","url":"https://api.github.com/repos/apache/openjpa/commits/d13c9fa4f6d136e83c86d4c0c7259149c5dd9857","html_url":"https://github.com/apache/openjpa/commit/d13c9fa4f6d136e83c86d4c0c7259149c5dd9857"}],"stats":{"total":67736,"additions":33915,"deletions":33821},"files":[{"sha":"bdbf925cfa7acc96f2deefda33fdf4368317a362","filename":"openjpa-project/pom.xml","status":"modified","additions":10,"deletions":2,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/pom.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -47,13 +47,21 @@\n                                 basedir=\"${project.basedir}/src/doc/manual\"\n                                 destdir=\"${project.basedir}/target/filtered-site/resources/manual\"\n                                 style=\"manual-xhtml.xsl\"\n-                                classpathref=\"maven.runtime.classpath\"/>\n+                                classpathref=\"maven.runtime.classpath\">\n+                                <factory name=\"org.apache.xalan.processor.TransformerFactoryImpl\">\n+                                    <attribute name=\"http://xml.apache.org/xalan/features/optimize\" value=\"true\"/>\n+                                </factory>\n+                            </style>\n                             <style includes=\"**/manual.xml\"\n                                 force=\"true\"\n                                 basedir=\"${project.basedir}/src/doc/manual\"\n                                 destdir=\"${project.basedir}/target/filtered-site/resources/manual\"\n                                 style=\"manual-xhtml-chunk.xsl\"\n-                                classpathref=\"maven.runtime.classpath\"/>\n+                                classpathref=\"maven.runtime.classpath\">\n+                                <factory name=\"org.apache.xalan.processor.TransformerFactoryImpl\">\n+                                    <attribute name=\"http://xml.apache.org/xalan/features/optimize\" value=\"true\"/>\n+                                </factory>\n+                            </style>\n                             </tasks>\n                         </configuration>\n                         <goals>"},{"sha":"8ffda00529b9a98036962a953958cc5ff673d74d","filename":"openjpa-project/src/doc/manual/jpa_overview_arch.xml","status":"added","additions":196,"deletions":0,"changes":196,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_arch.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_arch.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_overview_arch.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,196 @@\n+\n+    <chapter id=\"jpa_overview_arch\">\n+      <title>EJB Persistence Architecture</title>\n+      <indexterm zone=\"jpa_overview_arch\">\n+        <primary>EJB</primary>\n+        <secondary>architecture</secondary>\n+      </indexterm>\n+      <para>\n+  The diagram below illustrates the relationships between the primary\n+  components of the EJB architecture.\n+  </para>\n+      <mediaobject>\n+        <imageobject>\n+<!-- PNG image data 400 x 256 (see README) -->\n+          <imagedata fileref=\"img/jpa-arch.png\" width=\"267px\"/>\n+        </imageobject>\n+        <textobject>\n+          <phrase>EJB architecture</phrase>\n+        </textobject>\n+      </mediaobject>\n+      <note>\n+        <para>\n+    A number of the depicted interfaces are only required outside of\n+    an EJB3-compliant application server.  In an application server,\n+    <classname>EntityManager</classname> instances are typically injected, \n+    rendering the <classname>EntityManagerFactory</classname> unnecessary.\n+    Also, transactions within an application server\n+    are handled using standard application server transaction controls.\n+    Thus, the <classname>EntityTransaction</classname> also goes unused.\n+    </para>\n+      </note>\n+      <itemizedlist>\n+        <listitem>\n+          <para><indexterm><primary>Persistence</primary></indexterm><emphasis role=\"bold\"><link linkend=\"jpa_overview_persistence\"><classname>Persistence</classname></link></emphasis>:\n+      The <classname>javax.persistence.Persistence</classname> class\n+      contains static helper methods to obtain \n+      <classname>EntityManagerFactory</classname> instances in a \n+      vendor-neutral fashion.\n+      </para>\n+        </listitem>\n+        <listitem>\n+          <para><indexterm><primary>EntityManagerFactory</primary></indexterm><emphasis role=\"bold\"><link linkend=\"jpa_overview_emfactory\"><classname>EntityManagerFactory</classname></link></emphasis>:  The <classname>javax.persistence.EntityManagerFactory\n+      </classname> class is a factory for <classname>\n+      EntityManager</classname>s.\n+      </para>\n+        </listitem>\n+        <listitem>\n+          <para><indexterm><primary>EntityManager</primary></indexterm><emphasis role=\"bold\"><link linkend=\"jpa_overview_em\"><classname>EntityManager</classname></link></emphasis>:\n+      The <classname>javax.persistence.EntityManager</classname> is the\n+      primary EJB persistence interface used by applications.\n+      Each <classname>EntityManager</classname> manages a set of \n+      persistent objects, and has APIs to insert new objects and delete\n+      existing ones.  When used outside the container, there is a \n+      one-to-one relationship between an \n+      <classname>EntityManager</classname> and an <classname>\n+      EntityTransaction</classname>.  <classname>\n+      EntityManager</classname>s also act as factories for\n+      <classname>Query</classname> instances.\n+      </para>\n+        </listitem>\n+        <listitem>\n+          <para><indexterm><primary>entity</primary></indexterm><emphasis role=\"bold\"><link linkend=\"jpa_overview_pc\"><classname>Entity</classname></link></emphasis>:\n+      Entites are persistent objects that represent datastore records.\n+      </para>\n+        </listitem>\n+        <listitem>\n+          <para><indexterm><primary>EntityTransaction</primary></indexterm><emphasis role=\"bold\"><link linkend=\"jpa_overview_trans\"><classname>EntityTransaction</classname></link></emphasis>:  \n+      Each <classname>EntityManager</classname> has a one-to-one\n+      relation with a single \n+      <classname>javax.persistence.EntityTransaction</classname>.  \n+      <classname>EntityTransaction</classname>s allow operations on \n+      persistent data to be grouped into units of work that either \n+      completely succeed or completely fail, leaving the datastore\n+      in its original state.  These all-or-nothing operations are\n+      important for maintaining data integrity.\n+      </para>\n+        </listitem>\n+        <listitem>\n+          <para><indexterm><primary>Query</primary></indexterm><indexterm><primary>EJB3 Persistence Query Language</primary><see>JPQL</see></indexterm><indexterm><primary>JPQL</primary></indexterm><indexterm><primary>EJB</primary><secondary>query language</secondary><see>JPQL</see></indexterm><indexterm><primary>Structured Query Language</primary><see>SQL</see></indexterm><indexterm><primary>SQL</primary></indexterm><emphasis role=\"bold\"><link linkend=\"jpa_overview_query\"><classname>Query</classname></link></emphasis>:  The\n+      <classname>javax.persistence.Query</classname> interface is\n+      implemented by each EJB vendor to find persistent objects\n+      that meet certain criteria.  EJB standardizes support\n+      for queries using both the EJB Query Language (JPQL) and\n+      the Structured Query Language (SQL).  You obtain \n+      <classname>Query</classname> instances from an\n+      <classname>EntityManager</classname>.\n+      </para>\n+        </listitem>\n+      </itemizedlist>\n+      <para>\n+  The example below illustrates how the EJB interfaces interact to\n+  execute an JPQL query and update persistent objects.  The example\n+  assumes execution outside a container.\n+  </para>\n+      <example id=\"jpa_overview_arch_interact_outside\">\n+        <title>Interaction of Interfaces Outside Container</title>\n+        <programlisting format=\"linespecific\">\n+// get an EntityManagerFactory using the Persistence class; typically \n+// the factory is cached for easy repeated use\n+EntityManagerFactory factory = Persistence.createEntityManagerFactory (null);\n+\n+// get an EntityManager from the factory\n+EntityManager em = factory.createEntityManager (PersistenceContextType.EXTENDED);\n+\n+// updates take place within transactions\n+EntityTransaction tx = em.getTransaction ();\n+tx.begin ();\n+\n+// query for all employees who work in our research division\n+// and put in over 40 hours a week average\n+Query query = em.createQuery (\"select e from Employee e where \"\n+    + \"e.division.name = 'Research' AND e.avgHours &gt; 40\");\n+List results = query.getResultList ();\n+\n+// give all those hard-working employees a raise\n+for (Object res : results)\n+{\n+    Employee emp = (Employee) res;\n+    emp.setSalary (emp.getSalary () * 1.1);\n+}\n+\n+// commit the updates and free resources\n+tx.commit ();\n+em.close ();\n+factory.close ();\n+</programlisting>\n+      </example>\n+      <para>\n+  Within a container, the <classname>EntityManager</classname> will be \n+  injected and transactional handled declaratively.  Thus, the in-container\n+  version of the example consists entirely of business logic:\n+  </para>\n+      <example id=\"jpa_overview_arch_interact_inside\">\n+        <title>Interaction of Interfaces Inside Container</title>\n+        <programlisting format=\"linespecific\">\n+// query for all employees who work in our research division\n+// and put in over 40 hours a week average - note that the EntityManager em\n+// is injected using a @Resource annotation\n+Query query = em.createQuery (\"select e from Employee e where \"\n+    + \"e.division.name = 'Research' and e.avgHours &gt; 40\");\n+List results = query.getResultList ();\n+\n+// give all those hard-working employees a raise\n+for (Object res : results)\n+{\n+    emp = (Employee) res;\n+    emp.setSalary (emp.getSalary () * 1.1);\n+} \n+</programlisting>\n+      </example>\n+      <para>\n+  The remainder of this document explores the EJB interfaces in\n+  detail.  We present them in roughly the order that you will use them as you \n+  develop your application.\n+  </para>\n+      <section id=\"jpa_overview_arch_exceptions\">\n+        <title>EJB Exceptions</title>\n+        <indexterm zone=\"jpa_overview_arch_exceptions\">\n+          <primary>EJB</primary>\n+          <secondary>exceptions</secondary>\n+          <seealso>exceptions</seealso>\n+        </indexterm>\n+        <indexterm>\n+          <primary>exceptions</primary>\n+          <secondary>EJB</secondary>\n+        </indexterm>\n+        <mediaobject>\n+          <imageobject>\n+<!-- PNG image data, 427 x 355 (see README) -->\n+            <imagedata fileref=\"img/jpa-exceptions.png\" width=\"285px\"/>\n+          </imageobject>\n+          <textobject>\n+            <phrase>EJB persistence exception architecture</phrase>\n+          </textobject>\n+        </mediaobject>\n+        <para>\n+    The diagram above depicts the EJB persistence exception architecture.  \n+    All exceptions are unchecked.  EJB persistence uses\n+    standard exceptions where appropriate, most notably <classname>\n+    IllegalArgumentException</classname>s and <classname>\n+    IllegalStateException</classname>s.  The specification also provides\n+    a few EJB-specific exceptions in the <literal>javax.persistence\n+    </literal> package.  These exceptions should be self-explanatory.  See \n+    the <ulink url=\"http://java.sun.com/javaee/5/docs/api\">Javadoc</ulink> for \n+    additional details on EJB exceptions.\n+    </para>\n+        <note>\n+          <para>\n+      All exceptions thrown by OpenJPA implement \n+      <ulink url=\"../apidocs/org/apache/openjpa/util/ExceptionInfo.html\"><classname>\n+      org.apache.openjpa.util.ExceptionInfo</classname></ulink> to provide you with\n+      additional error information.\n+      </para>\n+        </note>\n+      </section>\n+    </chapter>"},{"sha":"23b0ecfa8d5689bb8efd145fa0f83e4ed828f656","filename":"openjpa-project/src/doc/manual/jpa_overview_conclusion.xml","status":"added","additions":18,"deletions":0,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_conclusion.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_conclusion.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_overview_conclusion.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,18 @@\n+\n+    <chapter id=\"jpa_overview_conclusion\">\n+      <title>Conclusion</title>\n+      <para>\n+  This concludes our overview of the EJB persistence specification.  The\n+  <link linkend=\"jpa_tutorials_intro\">OpenJPA EJB Tutorials</link>\n+  continue your EJB education with step-by-step instructions for \n+  building simple EJB persistence applications.  The \n+  <link linkend=\"ref_guide_intro\">OpenJPA Reference Guide</link> contains \n+  detailed documentation on all aspects of the OpenJPA EJB persistence\n+  implementation and core development tools.  \n+<!-- ### JDO2MIG\n+  Finally,\n+  the <link linkend=\"gui_intro\">Workbench Guide</link> teaches you how to\n+  use the OpenJPA Development Workbench for GUI-driven development.\n+-->\n+  </para>\n+    </chapter>"},{"sha":"c927abfa51c22151f2ff4a068bd0ae26cf80b3cc","filename":"openjpa-project/src/doc/manual/jpa_overview_em.xml","status":"added","additions":714,"deletions":0,"changes":714,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_em.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_em.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_overview_em.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,714 @@\n+\n+    <chapter id=\"jpa_overview_em\">\n+      <title>EntityManager</title>\n+      <indexterm zone=\"jpa_overview_em\">\n+        <primary>EntityManager</primary>\n+      </indexterm>\n+      <mediaobject>\n+        <imageobject>\n+<!-- PNG image data, 283 x 391 (see README) -->\n+          <imagedata fileref=\"img/entitymanager.png\" width=\"189px\"/>\n+        </imageobject>\n+      </mediaobject>\n+      <para>\n+  The diagram above presents an overview of the \n+  <classname>EntityManager</classname> interface.  For a complete \n+  treatment of the <classname>EntityManager</classname> API, see the \n+  <ulink url=\"jdo-javadoc/javax/jdo/EntityManager.html\">\n+  Javadoc</ulink> documentation.  Methods whose parameter signatures consist \n+  of an ellipsis (...) are overloaded to take multiple parameter types.\n+  </para>\n+      <note>\n+        <para>\n+    OpenJPA extends the standard <classname>EntityManager</classname> \n+    interface with the \n+    <ulink url=\"../../api/openjpa/persistence/OpenJPAEntityManager.html\"><classname>org.apache.openjpa.persistence.OpenJPAEntityManager</classname></ulink> \n+    interface to provide additional functionality.\n+    </para>\n+      </note>\n+      <para>\n+  The <classname>EntityManager</classname> is the primary interface\n+  used by application developers to interact with the EJB persistence runtime.\n+  The methods of the <classname>EntityManager</classname> can be\n+  divided into the following functional categories:\n+  </para>\n+      <itemizedlist>\n+        <listitem>\n+          <para><classname>Transaction</classname> association.</para>\n+        </listitem>\n+        <listitem>\n+          <para>Entity lifecycle management.</para>\n+        </listitem>\n+        <listitem>\n+          <para>Entity identity management.</para>\n+        </listitem>\n+        <listitem>\n+          <para>Cache management.</para>\n+        </listitem>\n+        <listitem>\n+          <para><classname>Query</classname> factory.</para>\n+        </listitem>\n+        <listitem>\n+          <para>Closing.</para>\n+        </listitem>\n+      </itemizedlist>\n+      <section id=\"jpa_overview_em_trans\">\n+        <title>Transaction Association</title>\n+        <indexterm zone=\"jpa_overview_em_trans\">\n+          <primary>EntityManager</primary>\n+          <secondary>obtaining the Transaction</secondary>\n+          <seealso>transactions</seealso>\n+        </indexterm>\n+        <indexterm zone=\"jpa_overview_em_trans\">\n+          <primary>Transaction</primary>\n+          <secondary>obtaining from EntityManager</secondary>\n+        </indexterm>\n+        <programlisting format=\"linespecific\">\n+public EntityTransaction getTransaction ();\n+</programlisting>\n+        <para>\n+    Every <classname>EntityManager</classname> has a one-to-one\n+    relation with an <link linkend=\"jpa_overview_trans\"><classname>EntityTransaction</classname></link> instance. In\n+    fact, many vendors use a single class to implement both\n+    the <classname>EntityManager</classname> and \n+    <classname>EntityTransaction</classname> interfaces.  If your\n+    application requires multiple concurrent transactions, you will\n+    use multiple <classname>EntityManager</classname>s.\n+    </para>\n+        <para>\n+    You can retrieve the <classname>EntityTransaction</classname> \n+    associated with an <classname>EntityManager</classname> through the\n+    <methodname>getTransaction</methodname> method.   Note that most \n+    most EJB persistence implementations can integrate with an application\n+    server's managed transactions.  If you take advantage of this feature, \n+    you will control transactions by declarative demarcation or through\n+    the Java Transaction API (JTA) rather than through the\n+    <classname>EntityTransaction</classname>.\n+    </para>\n+      </section>\n+      <section id=\"jpa_overview_em_lifecycle\">\n+        <title>Entity Lifecycle Management</title>\n+        <indexterm zone=\"jpa_overview_em_lifecycle\">\n+          <primary>EntityManager</primary>\n+          <secondary>lifecycle operations</secondary>\n+        </indexterm>\n+        <para><classname>EntityManager</classname>s perform several actions\n+    that affect the lifecycle state of entity instances.  \n+    </para>\n+        <programlisting format=\"linespecific\">\n+public void persist (Object entity);\n+</programlisting>\n+        <para><indexterm><primary>EntityManager</primary><secondary>persist</secondary></indexterm><indexterm><primary>persist</primary><seealso>EntityManager</seealso></indexterm><indexterm><primary>persistent objects</primary><secondary>persisting</secondary></indexterm>\n+    Transitions new instances to managed.  On the next flush or commit, \n+    the newly persisted instances will be inserted into the datastore.\n+    </para>\n+        <para>\n+    For a given entity <literal>A</literal>, the <methodname>persist\n+    </methodname> method behaves as follows:\n+    </para>\n+        <itemizedlist>\n+          <listitem>\n+            <para>\n+        If <literal>A</literal> is a new entity, it becomes managed.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        If <literal>A</literal> is an existing managed entity, it is\n+        ignored.  However, the persist operation cascades as \n+        defined below.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        If <literal>A</literal> is a removed entity, it becomes managed.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        If <literal>A</literal> is a detached entity, an\n+        <classname>IllegalArgumentException</classname> is thrown.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        The persist operation recurses on all relation fields of \n+        <literal>A</literal> whose \n+        <link linkend=\"jpa_overview_meta_cascade\">cascades</link> \n+        include <literal>CascadeType.PERSIST</literal>.\n+        </para>\n+          </listitem>\n+        </itemizedlist>\n+        <para>\n+    This action can only be used in the context of an active transaction. \n+    </para>\n+        <programlisting format=\"linespecific\">\n+public void remove (Object entity);\n+</programlisting>\n+        <para><indexterm><primary>EntityManager</primary><secondary>remove</secondary></indexterm><indexterm><primary>remove</primary><seealso>EntityManager</seealso></indexterm><indexterm><primary>persistent objects</primary><secondary>deleting</secondary></indexterm>\n+    Transitions managed instances to removed.  The instances will be \n+    deleted from the datastore on the next flush or commit.  Accessing\n+    a removed entity has undefined results.\n+    </para>\n+        <para>\n+    For a given entity <literal>A</literal>, the <methodname>remove\n+    </methodname> method behaves as follows:\n+    </para>\n+        <itemizedlist>\n+          <listitem>\n+            <para>\n+        If <literal>A</literal> is a new entity, it is ignored.  \n+        However, the remove operation cascades as defined below.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        If <literal>A</literal> is an existing managed entity, it \n+        becomes removed.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        If <literal>A</literal> is a removed entity, it is ignored.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        If <literal>A</literal> is a detached entity, an\n+        <classname>IllegalArgumentException</classname> is thrown.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        The remove operation recurses on all relation fields of \n+        <literal>A</literal> whose \n+        <link linkend=\"jpa_overview_meta_cascade\">cascades</link> \n+        include <literal>CascadeType.REMOVE</literal>.\n+        </para>\n+          </listitem>\n+        </itemizedlist>\n+        <para>\n+    This action can only be used in the context of an active transaction. \n+    </para>\n+        <programlisting format=\"linespecific\">\n+public void refresh (Object entity);\n+</programlisting>\n+        <para><indexterm><primary>EntityManager</primary><secondary>refresh</secondary></indexterm><indexterm><primary>refresh</primary><seealso>EntityManager</seealso></indexterm><indexterm><primary>persistent objects</primary><secondary>refreshing state</secondary></indexterm><indexterm><primary>transactions</primary><secondary>optimistic</secondary></indexterm>\n+    Use the <methodname>refresh</methodname> action to make sure\n+    the persistent state of an instance is synchronized with the\n+    values in the datastore.  <methodname>refresh</methodname>\n+    is intended for long-running optimistic transactions in\n+    which there is a danger of seeing stale data.\n+    </para>\n+        <para>\n+    For a given entity <literal>A</literal>, the <methodname>refresh\n+    </methodname> method behaves as follows:\n+    </para>\n+        <itemizedlist>\n+          <listitem>\n+            <para>\n+        If <literal>A</literal> is a new entity, it is ignored.  \n+        However, the remove operation cascades as defined below.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        If <literal>A</literal> is an existing managed entity, its \n+        state is refreshed from the datastore.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        If <literal>A</literal> is a removed entity, it is ignored.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        If <literal>A</literal> is a detached entity, an\n+        <classname>IllegalArgumentException</classname> is thrown.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        The refresh operation recurses on all relation fields of \n+        <literal>A</literal> whose \n+        <link linkend=\"jpa_overview_meta_cascade\">cascades</link> \n+        include <literal>CascadeType.REFRESH</literal>.\n+        </para>\n+          </listitem>\n+        </itemizedlist>\n+        <programlisting format=\"linespecific\">\n+public Object merge (Object entity);\n+</programlisting>\n+        <para><indexterm><primary>EntityManager</primary><secondary>merge</secondary><seealso>detachment</seealso></indexterm><indexterm><primary>detachment</primary><secondary>EJB</secondary></indexterm><indexterm><primary>merge</primary><seealso>detachment</seealso></indexterm><indexterm><primary>data transfer object</primary></indexterm><indexterm><primary>value object</primary></indexterm>\n+    A common use case for an application running in a servlet or\n+    application server is to \"detach\" objects from all server resources,\n+    modify them, and then \"attach\" them again. For example, a servlet\n+    might store persistent data in a user session between a modification\n+    based on a series of web forms. Between each form request, the web\n+    container might decide to serialize the session, requiring that the\n+    stored persistent state be disassociated from any other\n+    resources. Similarly, a client/server application might\n+    transfer persistent objects to a client via serialization, allow the\n+    client to modify their state, and then have the client return the\n+    modified data in order to be saved. This is sometimes referred to as\n+    the <emphasis>data transfer object</emphasis> or <emphasis>value \n+    object</emphasis> pattern, and it allows fine-grained manipulation \n+    of data objects without incurring the overhead of multiple remote \n+    method invocations.\n+    </para>\n+        <para>\n+    EJB persistence provides support for this pattern by automatically\n+    detaching entities when they are serialized or when a persistence\n+    context ends (see \n+    <xref linkend=\"jpa_overview_emfactory_perscontext\"/> for an\n+    exploration of persistence contexts).  The EJB persistence \n+    <emphasis>merge</emphasis> API re-attaches detached entities.\n+    This allows you to detach a persistent instance, modify the\n+    detached instance offline, and merge the instance back into an \n+    <classname>EntityManager</classname> (either the same one that \n+    detached the instance, or a new one). The changes will then be \n+    applied to the existing instance from the datastore.  \n+    </para>\n+        <para>\n+    A detached entity maintains its persistent identity, but cannot load \n+    additional state from the datastore.  Accessing any persistent field or\n+    property that was not loaded at the time of detachment has undefined \n+    results.  Also, be sure not to alter the version or identity fields of\n+    detached instances if you plan on merging them later.\n+    </para>\n+        <para>\n+    The <methodname>merge</methodname> method returns a managed copy of the\n+    given detached entity.  Changes made to the persistent state of the\n+    detached entity are applied to this managed instance.  Because merging \n+    involves changing persistent state, you can only merge within a \n+    transaction.\n+    </para>\n+        <para>\n+    If you attempt to merge an instance whose representation has\n+    changed in the datastore since detachment, the merge operation will\n+    throw an exception, or the transaction in which you perform the \n+    merge will fail on commit, just as if a normal optimistic conflict\n+    were detected.\n+    </para>\n+        <note>\n+          <para>\n+      OpenJPA offers enhancements to EJB persistence detachment \n+      functionality, including additional options to control which \n+      fields are detached.  See <xref linkend=\"ref_guide_detach\"/> \n+      in the Reference Guide for details.\n+      </para>\n+        </note>\n+        <para>\n+    For a given entity <literal>A</literal>, the <methodname>merge\n+    </methodname> method behaves as follows:\n+    </para>\n+        <itemizedlist>\n+          <listitem>\n+            <para>\n+        If <literal>A</literal> is a detached entity, its state\n+        is copied into existing managed instance <literal>A'</literal>\n+        of the same entity identity, or a new managed copy of\n+        <literal>A</literal> is created.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        If <literal>A</literal> is a new entity, a new managed\n+        entity <literal>A'</literal> is created and the state of \n+        <literal>A</literal> is copied into <literal>A'</literal>.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        If <literal>A</literal> is an existing managed entity, it is\n+        ignored.  However, the merge operation still cascades as \n+        defined below.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        If <literal>A</literal> is a removed entity, an\n+        <classname>IllegalArgumentException</classname> is thrown.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        The merge operation recurses on all relation fields of \n+        <literal>A</literal> whose \n+        <link linkend=\"jpa_overview_meta_cascade\">cascades</link> \n+        include <literal>CascadeType.MERGE</literal>.\n+        </para>\n+          </listitem>\n+        </itemizedlist>\n+        <programlisting format=\"linespecific\">\n+public void lock (Object entity, LockModeType mode);\n+</programlisting>\n+        <para><indexterm><primary>EntityManager</primary><secondary>lock</secondary></indexterm><indexterm><primary>locking</primary><seealso>EntityManager</seealso></indexterm>\n+    This method locks the given entity using the named mode.  The\n+    <ulink url=\"http://java.sun.com/javaee/5/docs/api/javax/persistence/LockmodeType.html\"><classname>javax.persistence.LockModeType</classname></ulink> enum\n+    defines two modes:\n+    </para>\n+        <itemizedlist>\n+          <listitem>\n+            <para><literal>READ</literal>: Other transactions may concurrently \n+        read the object, but cannot concurrently update it.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><literal>WRITE</literal>: Other transactions cannot \n+        concurrently read or write the object. When a transaction\n+        is committed that holds WRITE locks on any entites, those\n+        entites will have their version incremented even if\n+        the entities themselves did not change in the transaction.\n+        </para>\n+          </listitem>\n+        </itemizedlist>\n+        <note>\n+          <para>\n+      OpenJPA has additional APIs for controlling object locking.  See\n+      <xref linkend=\"ref_guide_locking\"/> in the Reference Guide for\n+      details.\n+      </para>\n+        </note>\n+        <para>\n+    The following diagram illustrates the lifecycle of an entity with\n+    respect to the APIs presented in this section.\n+    </para>\n+        <mediaobject>\n+          <imageobject>\n+<!-- PNG image data, 445 x 337 (see README) -->\n+            <imagedata fileref=\"img/jpa-state-transitions.png\" width=\"297px\"/>\n+          </imageobject>\n+        </mediaobject>\n+      </section>\n+      <section id=\"jpa_overview_em_lifeexamples\">\n+        <title>Lifecycle Examples</title>\n+        <para>\n+    The examples below demonstrate how to use the lifecycle methods\n+    presented in the previous section.  The examples are appropriate for\n+    out-of-container use.  Within a container, <classname>\n+    EntityManager</classname>s are usually injected, and transactions are \n+    usually managed.  You would therefore omit the \n+    <methodname>createEntityManager</methodname> and <methodname>close\n+    </methodname> calls, as well as all transaction demarcation code.\n+    </para>\n+        <example id=\"jpa_overview_em_lifecycle_persist\">\n+          <title>Persisting Objects</title>\n+          <indexterm>\n+            <primary>persistent objects</primary>\n+            <secondary>persisting</secondary>\n+            <tertiary>example</tertiary>\n+          </indexterm>\n+          <programlisting format=\"linespecific\">\n+// create some objects\n+Magazine mag = new Magazine (\"1B78-YU9L\", \"JavaWorld\");\n+\n+Company pub = new Company (\"Weston House\");\n+pub.setRevenue (1750000D);\n+mag.setPublisher (pub);\n+pub.addMagazine (mag);\n+\n+Article art = new Article (\"EJB Rules!\", \"Transparent Object Persistence\");\n+art.addAuthor (new Author (\"Fred\", \"Hoyle\"));\n+mag.addArticle (art);\n+\n+// persist\n+EntityManager em = emf.createEntityManager ();\n+em.getTransaction ().begin ();\n+em.persist (mag);\n+em.persist (pub);\n+em.persist (art);\n+em.getTransaction ().commit ();\n+\n+// or we could continue using the EntityManager...\n+em.close ();\n+</programlisting>\n+        </example>\n+        <example id=\"jpa_overview_em_lifecycle_update\">\n+          <title>Updating Objects</title>\n+          <indexterm>\n+            <primary>persistent objects</primary>\n+            <secondary>updating</secondary>\n+            <tertiary>example</tertiary>\n+          </indexterm>\n+          <programlisting format=\"linespecific\">\n+Magazine.MagazineId mi = new Magazine.MagazineId ();\n+mi.isbn = \"1B78-YU9L\";\n+mi.title = \"JavaWorld\";\n+\n+// updates should always be made within transactions; note that\n+// there is no code explicitly linking the magazine or company\n+// with the transaction; EJB automatically tracks all changes\n+EntityManager em = emf.createEntityManager ();\n+em.getTransaction ().begin ();\n+Magazine mag = em.find (Magazine.class, mi);\n+mag.setPrice (5.99);\n+Company pub = mag.getPublisher ();\n+pub.setRevenue (1750000D);\n+em.getTransaction ().commit ();\n+\n+// or we could continue using the EntityManager...\n+em.close ();\n+</programlisting>\n+        </example>\n+        <example id=\"jpa_overview_em_lifecycle_delete\">\n+          <title>Removing Objects</title>\n+          <indexterm>\n+            <primary>persistent objects</primary>\n+            <secondary>deleting</secondary>\n+            <tertiary>example</tertiary>\n+          </indexterm>\n+          <programlisting format=\"linespecific\">\n+// assume we have an object id for the company whose subscriptions\n+// we want to delete\n+Object oid = ...;\n+\n+// deletes should always be made within transactions\n+EntityManager em = emf.createEntityManager ();\n+em.getTransaction ().begin ();\n+Company pub = (Company) em.find (Company.class, oid);\n+for (Subscription sub : pub.getSubscriptions ())\n+    em.remove (sub);\n+pub.getSubscriptions ().clear ();\n+em.getTransaction ().commit ();\n+\n+// or we could continue using the EntityManager...\n+em.close ();\n+</programlisting>\n+        </example>\n+        <example id=\"jpa_overview_em_detachex\">\n+          <title>Detaching and Merging</title>\n+          <para>\n+      This example demonstrates a common client/server scenario.  The\n+      client requests objects and makes changes to them, while the \n+      server handles the object lookups and transactions.\n+      </para>\n+          <programlisting format=\"linespecific\">\n+// CLIENT:\n+// requests an object with a given oid\n+Record detached = (Record) getFromServer (oid);\n+\n+...\n+\n+// SERVER:\n+// send object to client; object detaches on EM close\n+Object oid = processClientRequest ();\n+EntityManager em = emf.createEntityManager ();\n+Record record = em.find (Record.class, oid);\n+em.close ();\n+sendToClient (record);\n+\n+...\n+\n+// CLIENT:\n+// makes some modifications and sends back to server\n+detached.setSomeField (\"bar\");\n+sendToServer (detached);\n+\n+...\n+\n+// SERVER:\n+// merges the instance and commit the changes\n+Record modified = (Record) processClientRequest ();\n+EntityManager em = emf.createEntityManager ();\n+em.getTransaction ().begin ();\n+Record merged = (Record) em.merge (modified);\n+merged.setLastModified (System.currentTimeMillis ());\n+merged.setModifier (getClientIdentityCode ());\n+em.getTransaction ().commit ();\n+em.close ();\n+</programlisting>\n+        </example>\n+      </section>\n+      <section id=\"jpa_overview_em_identity\">\n+        <title>Entity Identity Management</title>\n+        <para>\n+    Each <classname>EntityManager</classname> is responsible for\n+    managing the persistent identities of the managed objects in the\n+    persistence context.  The following methods allow you to interact \n+    with the management of persistent identities.  The behavior of these\n+    methods is deeply affected by the persistence context type of the\n+    <classname>EntityManager</classname>; see \n+    <xref linkend=\"jpa_overview_emfactory_perscontext\"/> for an\n+    explanation of persistence contexts.\n+    </para>\n+        <programlisting format=\"linespecific\">\n+public &lt;T&gt; T find (Class&lt;T&gt; cls, Object oid);\n+</programlisting>\n+        <para><indexterm><primary>EntityManager</primary><secondary>find</secondary><seealso>identity</seealso></indexterm><indexterm><primary>find</primary><seealso>EntityManager</seealso></indexterm><indexterm><primary>identity</primary><secondary>retrieving objects by identity</secondary></indexterm>\n+    This method returns the persistent instance of the given type with\n+    the given persistent identity.  If the instance is already present in\n+    the current persistence context, the cached version will be returned.  \n+    Otherwise, a new instance will be constructed and loaded with \n+    state from the datastore.  If no entity with the given type and identity\n+    exists in the datastore, this method returns null.\n+    </para>\n+        <programlisting format=\"linespecific\">\n+public &lt;T&gt; T getReference (Class&lt;T&gt; cls, Object oid);\n+</programlisting>\n+        <para><indexterm><primary>EntityManager</primary><secondary>getReference</secondary><seealso>identity</seealso></indexterm><indexterm><primary>getReference</primary><seealso>EntityManager</seealso></indexterm><indexterm><primary>identity</primary><secondary>retrieving objects by identity</secondary></indexterm><indexterm><primary>EntityNotFoundException</primary></indexterm>\n+    This method is similar to <methodname>find</methodname>, but does not\n+    necessarily go to the database when the entity is not found in cache.\n+    The implementation may construct a <emphasis>hollow</emphasis> entity \n+    and return it to you instead.  Hollow entities do not have any\n+    state loaded.  The state only gets loaded when you attempt to access\n+    a persistent field.  At that time, the implementation may throw an\n+    <classname>EntityNotFoundException</classname> if it discovers that\n+    the entity does not exist in the datastore.  The implementation may\n+    also throw an <classname>EntityNotFoundException</classname> from\n+    the <methodname>getReference</methodname> method itself.  Unlike \n+    <methodname>find</methodname>, <methodname>getReference</methodname>\n+    does not return null.\n+    </para>\n+        <programlisting format=\"linespecific\">\n+public boolean contains (Object entity);\n+</programlisting>\n+        <para><indexterm><primary>EntityManager</primary><secondary>contains</secondary></indexterm><indexterm><primary>contains</primary><seealso>EntityManager</seealso></indexterm>\n+    Returns true if the given entity is part of the current persistence\n+    context, and false otherwise.  Removed entities are not considered part\n+    of the current persistence context.\n+    </para>\n+      </section>\n+      <section id=\"jpa_overview_em_cache\">\n+        <title>Cache Management</title>\n+        <indexterm zone=\"jpa_overview_em_cache\">\n+          <primary>EntityManager</primary>\n+          <secondary>cache</secondary>\n+        </indexterm>\n+        <programlisting format=\"linespecific\">\n+public void flush ();\n+</programlisting>\n+        <para><indexterm><primary>EntityManager</primary><secondary>flush</secondary></indexterm><indexterm><primary>flush</primary><seealso>EntityManager</seealso></indexterm><indexterm><primary>transactions</primary><secondary>flushing changes before commit</secondary></indexterm>\n+    The <methodname>flush</methodname> method writes any changes that have\n+    been made in the current transaction to the datastore.  If the\n+    <classname>EntityManager</classname> does not already have a \n+    connection to the datastore, it obtains one for the flush and retains\n+    it for the duration of the transaction.  Any exceptions during flush\n+    cause the transaction to be marked for rollback.\n+    See <xref linkend=\"jpa_overview_trans\"/>.\n+    </para>\n+        <para>\n+    Flushing requires an active transaction.  If there isn't a transaction\n+    in progress, the <methodname>flush</methodname> method throws a\n+    <classname>TransactionRequiredException</classname>.\n+    </para>\n+        <programlisting format=\"linespecific\">\n+public FlushModeType getFlushMode ();\n+public void setFlushMode (FlushModeType flushMode);\n+</programlisting>\n+        <para><indexterm><primary>EntityManager</primary><secondary>FlushMode</secondary></indexterm><indexterm><primary>FlushMode</primary></indexterm>\n+    The <classname>EntityManager</classname>'s <literal>FlushMode</literal>\n+    property controls whether to flush transactional changes before \n+    executing queries.  This allows the query results to take into account\n+    changes you have made during the current transaction.  Available\n+    <ulink url=\"http://java.sun.com/javaee/5/docs/api/javax/persistence/FlushModeType.html\"><classname>javax.persistence.FlushModeType</classname></ulink> constants\n+    are:\n+    </para>\n+        <itemizedlist>\n+          <listitem>\n+            <para><literal>COMMIT</literal>: Only flush when committing, or\n+        when told to do so through the <methodname>flush</methodname>\n+        method.  Query results may not take into account changes made\n+        in the current transaction.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><literal>AUTO</literal>: The implementation is permitted to\n+        flush before queries to ensure that the results reflect the\n+        most recent object state.\n+        </para>\n+          </listitem>\n+        </itemizedlist>\n+        <para>\n+    You can also set the flush mode on individual \n+    <link linkend=\"jpa_overview_query\"><classname>Query</classname></link>\n+    instances.\n+    </para>\n+        <note>\n+          <para>\n+      OpenJPA only flushes before a query if the query might be affected\n+      by data changed in the current transaction.  Additionally,\n+      OpenJPA allows fine-grained control over flushing behavior.\n+      See the Reference Guide's \n+      <xref linkend=\"ref_guide_dbsetup_retain\"/>.\n+      </para>\n+        </note>\n+        <programlisting format=\"linespecific\">\n+public void clear ();\n+</programlisting>\n+        <para><indexterm><primary>EntityManager</primary><secondary>clear</secondary></indexterm><indexterm><primary>clear</primary><seealso>EntityManager</seealso></indexterm>\n+    Clearing the <classname>EntityManager</classname> effectively ends the\n+    persistence context.  All entities managed by\n+    the <classname>EntityManager</classname> become detached. \n+    </para>\n+      </section>\n+      <section id=\"jpa_overview_em_query\">\n+        <title>Query Factory</title>\n+        <indexterm zone=\"jpa_overview_em_query\">\n+          <primary>EntityManager</primary>\n+          <secondary>as Query factory</secondary>\n+          <seealso>Query</seealso>\n+        </indexterm>\n+        <indexterm zone=\"jpa_overview_em_query\">\n+          <primary>Query</primary>\n+          <secondary>creating</secondary>\n+        </indexterm>\n+        <programlisting format=\"linespecific\">\n+public Query createQuery (String query);\n+</programlisting>\n+        <para><classname>Query</classname> objects are used to find entities\n+    matching certain criteria.  The <methodname>createQuery</methodname>\n+    method creates a query using the given EJB Query Language (JPQL) \n+    string. See <xref linkend=\"jpa_overview_query\"/> for details.\n+    </para>\n+        <programlisting format=\"linespecific\">\n+public Query createNamedQuery (String name);\n+</programlisting>\n+        <para>\n+    This method retrieves a query defined in metadata by name.  The returned\n+    <classname>Query</classname> instance is initialized with the \n+    information declared in metadata.  For more information on named \n+    queries, read <xref linkend=\"jpa_overview_query_named\"/>.\n+    </para>\n+        <programlisting format=\"linespecific\">\n+public Query createNativeQuery (String sql);\n+public Query createNativeQuery (String sql, Class resultCls);\n+public Query createNativeQuery (String sql, String resultMapping);\n+</programlisting>\n+        <para><emphasis>Native</emphasis> queries are queries in the datastore's\n+    native language.  For relational databases, this the Structured Query \n+    Language (SQL).  <xref linkend=\"jpa_overview_sqlquery\"/> elaborates\n+    on EJB persistence's native query support.  \n+    </para>\n+      </section>\n+      <section id=\"jpa_overview_em_closing\">\n+        <title>Closing</title>\n+        <indexterm zone=\"jpa_overview_em_closing\">\n+          <primary>EntityManager</primary>\n+          <secondary>closing</secondary>\n+        </indexterm>\n+        <programlisting format=\"linespecific\">\n+public boolean isOpen ();\n+public void close ();\n+</programlisting>\n+        <para>\n+    When an <classname>EntityManager</classname> is no longer\n+    needed, you should call its <methodname>close</methodname> method.\n+    Closing an <classname>EntityManager</classname> releases any resources \n+    it is using.  The persistence context ends, and the entities managed by\n+    the <classname>EntityManager</classname> become detached. \n+    Any <classname>Query</classname> instances the <classname>EntityManager\n+    </classname> created become invalid.\n+    Calling any method other than <methodname>isOpen</methodname> on a \n+    closed <classname>EntityManager</classname> results in an\n+    <classname>IllegalStateException</classname>.  You cannot close a \n+    <classname>EntityManager</classname> that is in the middle of a\n+    transaction.\n+    </para>\n+        <para>\n+    If you are in a managed environment using injected entity managers,\n+    you should not close them.  \n+    </para>\n+      </section>\n+    </chapter>"},{"sha":"2416d4373e0d00800859ad5df3098a733f50b659","filename":"openjpa-project/src/doc/manual/jpa_overview_emfactory.xml","status":"added","additions":365,"deletions":0,"changes":365,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_emfactory.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_emfactory.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_overview_emfactory.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,365 @@\n+\n+    <chapter id=\"jpa_overview_emfactory\">\n+      <title>EntityManagerFactory</title>\n+      <indexterm zone=\"jpa_overview_emfactory\">\n+        <primary>EntityManagerFactory</primary>\n+      </indexterm>\n+      <mediaobject>\n+        <imageobject>\n+<!-- PNG image data, 418 x 274 (see README) -->\n+          <imagedata fileref=\"img/entitymanagerfactory.png\" width=\"279px\"/>\n+        </imageobject>\n+      </mediaobject>\n+      <para>\n+  The <classname>EntityManagerFactory</classname> creates\n+  <classname>EntityManager</classname> instances for application\n+  use. \n+  </para>\n+      <note>\n+        <para>\n+    OpenJPA extends the standard <classname>EntityManagerFactory</classname>\n+    interface with the\n+    <ulink url=\"../../api/openjpa/persistence/OpenJPAEntityManagerFactory.html\"><classname>OpenJPAEntityManagerFactory</classname></ulink> to provide\n+    additional functionality.\n+    </para>\n+      </note>\n+      <section id=\"jpa_overview_emfactory_obtain\">\n+        <title>Obtaining an EntityManagerFactory</title>\n+        <indexterm zone=\"jpa_overview_emfactory_obtain\">\n+          <primary>EntityManagerFactory</primary>\n+          <secondary>construction</secondary>\n+        </indexterm>\n+        <indexterm>\n+          <primary>Java Connector Architecture</primary>\n+          <see>JCA</see>\n+        </indexterm>\n+        <indexterm>\n+          <primary>JCA</primary>\n+        </indexterm>\n+        <para>\n+    Within a container, you will typically use <emphasis>injection\n+    </emphasis> to access an <classname>EntityManagerFactory</classname>.\n+    There are, however, alternative mechanisms for \n+    <classname>EntityManagerFactory</classname> construction.\n+    </para>\n+        <para>\n+    Some vendors may supply public constructors for their \n+    <classname>EntityManagerFactory</classname> implementations, but\n+    we recommend using the Java Connector Architecture (JCA) in a managed \n+    environment, or the <classname>Persistence</classname> class'\n+    <methodname>createEntityManagerFactory</methodname> methods in an\n+    unmanaged environment, as described in\n+    <xref linkend=\"jpa_overview_persistence\"/>.  These strategies allow\n+    vendors to pool factories, cutting down on resource utilization.\n+    </para>\n+        <para><indexterm><primary>JNDI</primary></indexterm>\n+    JPA allows you to create and configure an\n+    <classname>EntityManagerFactory</classname>, then store it in a \n+    Java Naming and Directory Interface (JNDI) tree for later retrieval \n+    and use.\n+    </para>\n+      </section>\n+      <section id=\"jpa_overview_emfactory_em\">\n+        <title>Obtaining EntityManagers</title>\n+        <indexterm zone=\"jpa_overview_emfactory_em\">\n+          <primary>EntityManager</primary>\n+          <secondary>obtaining</secondary>\n+          <seealso>EntityManagerFactory</seealso>\n+        </indexterm>\n+        <indexterm zone=\"jpa_overview_emfactory_em\">\n+          <primary>EntityManagerFactory</primary>\n+          <secondary>obtaining EntityManagers</secondary>\n+        </indexterm>\n+        <programlisting format=\"linespecific\">\n+public EntityManager createEntityManager ();\n+public EntityManager createEntityManager (Map map);\n+</programlisting>\n+        <para>\n+    The two <methodname>createEntityManager</methodname> methods above\n+    create a new <classname>EntityManager</classname> each time they are \n+    invoked.  The optional <classname>Map</classname> is used to to supply\n+    vendor-specific settings.   If you have configured your implementation\n+    for JTA transactions and a JTA transaction is active, the returned \n+    <classname>EntityManager</classname> will be synchronized with that\n+    transaction.\n+    <!--\n+    <classname>EntityManager</classname> with a persistence context type of\n+    <literal>TRANSACTION</literal>.  The second version allows you to\n+    specify the persistence context type.  We relate the differences \n+    between persistence context types \n+    <link linkend=\"jpa_overview_emfactory_perscontext\">below</link>.\n+    -->\n+    </para>\n+        <note>\n+          <para>\n+      OpenJPA recognizes the following string keys in the map supplied to\n+      <methodname>createEntityManager</methodname>:\n+      </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+                <literal>openjpa.ConnectionUserName</literal>\n+              </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+                <literal>openjpa.ConnectionPassword</literal>\n+              </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+                <literal>openjpa.ConnectionRetainMode</literal>\n+              </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+                <literal>openjpa.TransactionMode</literal>\n+              </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>openjpa.&lt;property&gt;</literal>, where \n+          <emphasis>&lt;property&gt;</emphasis> is any JavaBean\n+          property of the \n+          <ulink url=\"../apidocs/org/apache/openjpa/persistence/OpenJPAEntityManager.html\"><classname>\n+          org.apache.openjpa.persistence.OpenJPAEntityManager</classname></ulink>.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+          <para>\n+      The last option uses reflection to configure any property of OpenJPA's\n+      <classname>EntityManager</classname> implementation with the value\n+      supplied in your map.  The first options correspond exactly to\n+      the same-named OpenJPA configuration keys described in\n+      <xref linkend=\"ref_guide_conf\"/> of the Reference Guide.\n+      </para>\n+        </note>\n+      </section>\n+      <section id=\"jpa_overview_emfactory_perscontext\">\n+        <title>Persistence Context</title>\n+        <indexterm zone=\"jpa_overview_emfactory_perscontext\">\n+          <primary>persistence context</primary>\n+        </indexterm>\n+        <indexterm>\n+          <primary>PersistenceContextType</primary>\n+          <see>persistence context</see>\n+        </indexterm>\n+        <para>\n+    A persistence context is a set of entities such that for any persistent\n+    identity there is a unique entity instance.  Within a persistence\n+    context, entities are <emphasis>managed</emphasis>.  The <classname>\n+    EntityManager</classname> controls their lifecycle, and they can access\n+    datastore resources.\n+    </para>\n+        <para>\n+    When a persistence context ends, previously-managed entities become\n+    <emphasis>detached</emphasis>.  A detached entity is no longer under\n+    the control of the <classname>EntityManager</classname>, and no longer\n+    has access to datastore resources.  We discuss detachment is detail in\n+    <xref linkend=\"jpa_overview_em_lifecycle\"/>.  For now, it is sufficient\n+    to know that detachment as has two obvious consequences:\n+    </para>\n+        <orderedlist>\n+          <listitem>\n+            <para>\n+        The detached entity cannot load any additional persistent\n+        state.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        The <classname>EntityManager</classname> will not return the\n+        detached entity from <methodname>find</methodname>, nor will\n+        queries include the detached entity in their results.  Instead,\n+        <methodname>find</methodname> method invocations and query \n+        executions that would normally incorporate the detached entity\n+        will create a new managed entity with the same identity.\n+        </para>\n+          </listitem>\n+        </orderedlist>\n+        <note>\n+          <para>\n+      OpenJPA offers several features related to detaching entities.  See\n+      <xref linkend=\"ref_guide_detach\"/> in the Reference Guide.  \n+      <xref linkend=\"ref_guide_detach_graph\"/> in particular describes\n+      how to use the <literal>DetachState</literal> setting to boost\n+      the performance of merging detached entities.\n+      </para>\n+        </note>\n+        <para> \n+    Injected <classname>EntityManager</classname>s have use a \n+    <emphasis>transaction</emphasis>, while <classname>\n+    EntityManager</classname>s obtained through the\n+    <classname>EntityManagerFactory</classname> have an <emphasis>\n+    extended</emphasis> persistence context.  We describe these persistence\n+    context types below.\n+    </para>\n+        <section id=\"jpa_overview_emfactory_perscontext_trans\">\n+          <title>Transaction Persistence Context</title>\n+          <para>\n+      Under the transaction persistence context featureSelection, an <classname>\n+      EntityManager</classname> begins a new persistence context\n+      with each transaction, and ends the context when the transaction \n+      commits or rolls back.  Within the transaction, entities you\n+      retrieve through the <classname>EntityManager</classname> or via\n+      <classname>Queries</classname> are managed entities.  They \n+      can access datastore resources to lazy-load additional \n+      persistent state as needed, and only one entity may exist for any \n+      persistent identity.\n+      </para>\n+          <para>\n+      When the transaction completes, all entities lose their \n+      association with the <classname>EntityManager</classname> and \n+      become detached.  Traversing a persistent field that wasn't\n+      already loaded now has undefined results.  And using the <classname>\n+      EntityManager</classname> or a <classname>Query</classname> to \n+      retrieve additional objects may now create new instances with the \n+      same persistent identities as detached instances. \n+      </para>\n+          <para>\n+      If you use an <classname>EntityManager</classname> with a \n+      transaction persistence context featureSelection outside of \n+      an active transaction, each method invocation creates a new \n+      persistence context, performs the method action, and ends the \n+      persistence context.  For example, consider using the\n+      <methodname>EntityManager.find</methodname> method outside \n+      of a transaction.  The <classname>EntityManager</classname> will \n+      create a temporary persistence context, perform the find operation,\n+      end the persistence context, and return the detached result object \n+      to you.  A second call with the same id will return a second \n+      detached object.\n+      </para>\n+          <para>\n+      When the next transaction begins, the <classname>EntityManager\n+      </classname> will begin a new persistence context, and will again\n+      start returning managed entities.  As you'll see in\n+      <xref linkend=\"jpa_overview_em\"/>, you can also merge the\n+      previously-detached entites back into the new persistence context.\n+      </para>\n+          <example id=\"jpa_overview_emfactory_perscontext_transex\">\n+            <title>Behavior of Transaction Persistence Context</title>\n+            <para>\n+        The following code illustrates the behavior of entites under\n+        an <classname>EntityManager</classname> using a transaction\n+        persistence context.\n+        </para>\n+            <programlisting format=\"linespecific\">\n+EntityManager em; // injected\n+...\n+\n+// outside a transaction:\n+\n+// each operation occurs in a separate persistence context, and returns \n+// a new detached instance\n+Magazine mag1 = em.find (Magazine.class, magId);\n+Magazine mag2 = em.find (Magazine.class, magId);\n+assertTrue (mag2 != mag1);\n+...\n+\n+// transaction begins:\n+\n+// within a transaction, a subsequent lookup doesn't return any of the\n+// detached objects.  however, two lookups within the same transaction\n+// return the same instance, because the persistence context spans the\n+// transaction\n+Magazine mag3 = em.find (Magazine.class, magId);\n+assertTrue (mag3 != mag1 &amp;&amp; mag3 != mag2);\n+Magazine mag4 = em.find (Magazine.class (magId);\n+assertTrue (mag4 == mag3);\n+...\n+\n+// transaction commits:\n+\n+// once again, each operation returns a new instance\n+Magazine mag5 = em.find (Magazine.class, magId);\n+assertTrue (mag5 != mag3);\n+</programlisting>\n+          </example>\n+        </section>\n+        <section id=\"jpa_overview_emfactory_perscontext_extend\">\n+          <title>Extended Persistence Context</title>\n+          <para>\n+      An <classname>EntityManager</classname> using an extended \n+      persistence context maintains the same persistence context for\n+      its entire lifecycle.  Whether inside a transaction or not, all \n+      entities returned from the <classname>EntityManager</classname> \n+      are managed, and the <classname>EntityManager</classname> never \n+      creates two entity instances to represent the same persistent \n+      identity.  Entities only become detached when you finally close \n+      the <classname>EntityManager</classname> (or when they are \n+      serialized).\n+      </para>\n+          <example id=\"jpa_overview_emfactory_perscontext_extendex\">\n+            <title>Behavior of Extended Persistence Context</title>\n+            <para>\n+        The following code illustrates the behavior of entites under\n+        an <classname>EntityManager</classname> using an extended\n+        persistence context.\n+        </para>\n+            <programlisting format=\"linespecific\">\n+EntityManagerFactory emf = ...\n+EntityManager em = emf.createEntityManager (PersistenceContextType.EXTENDED);\n+\n+// persistence context active for entire life of EM, so only one entity\n+// for a given persistent identity\n+Magazine mag1 = em.find (Magazine.class, magId);\n+Magazine mag2 = em.find (Magazine.class, magId);\n+assertTrue (mag2 == mag1);\n+\n+em.getTransaction ().begin ();\n+\n+// same persistence context active within the transaction\n+Magazine mag3 = em.find (Magazine.class, magId);\n+assertTrue (mag3 == mag1);\n+Magazine mag4 = em.find (Magazine.class (magId);\n+assertTrue (mag4 == mag1);\n+\n+em.getTransaction.commit ();\n+\n+// when the transaction commits, instance still managed\n+Magazine mag5 = em.find (Magazine.class, magId);\n+assertTrue (mag5 == mag1);\n+\n+// instance finally becomes detached when EM closes\n+em.close ();\n+</programlisting>\n+          </example>\n+        </section>\n+      </section>\n+      <section id=\"jpa_overview_emfactory_close\">\n+        <title>Closing the EntityManagerFactory</title>\n+        <indexterm zone=\"jpa_overview_emfactory_close\">\n+          <primary>EntityManagerFactory</primary>\n+          <secondary>closing</secondary>\n+        </indexterm>\n+        <programlisting format=\"linespecific\">\n+public boolean isOpen ();\n+public void close ();\n+</programlisting>\n+        <para><classname>EntityManagerFactory</classname> instances are\n+    heavyweight objects.  Each factory might maintain a metadata cache,\n+    object state cache, <classname>EntityManager</classname> pool, \n+    connection pool, and more.  If your application no longer needs an \n+    <classname>EntityManagerFactory</classname>, you should close it\n+    to free these resources.  When an <classname>EntityManagerFactory\n+    </classname> closes, all <classname>EntityManager</classname>s \n+    from that factory, and by extension all entities managed\n+    by those <classname>EntityManager</classname>s, become invalid.\n+    Attempting to close an <classname>EntityManagerFactory</classname>\n+    while one or more of its <classname>EntityManager</classname>s \n+    has an active transaction may result in an\n+    <classname>IllegalStateException</classname>.\n+    </para>\n+        <para>\n+    Closing an <classname>EntityManagerFactory</classname> should not\n+    be taken lightly.  It is much better to keep a factory open for a long\n+    period of time than to repeatedly create and close new factories.  Thus,\n+    most applications will never close the factory, or only close it when\n+    the application is exiting.  Only applications that require multiple\n+    factories with different configurations have an obvious reason to\n+    create and close multiple <classname>EntityManagerFactory\n+    </classname> instances.  Once a factory is closed, all methods except\n+    <methodname>isOpen</methodname> throw an <classname>\n+    IllegalStateException</classname>.\n+    </para>\n+      </section>\n+    </chapter>"},{"sha":"862c47ec8d038937bc7d7892a1f4699aef06f965","filename":"openjpa-project/src/doc/manual/jpa_overview_intro.xml","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_intro.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_intro.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_overview_intro.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,57 @@\n+\n+    <chapter id=\"jpa_overview_intro\">\n+      <title>Introduction</title>\n+      <para><indexterm><primary>EJB3 Persistence</primary><see>EJB</see></indexterm><indexterm><primary>EJB</primary></indexterm>\n+  Enterprise Java Beans 3.0 Persistence (EJB persistence) is a specification \n+  from Sun Microsystems for the persistence of Java objects to any relational\n+  datastore.  EJB persistence requires J2SE 1.5 (also referred to as \"Java 5\")\n+  or higher, as it makes heavy use of new Java language features such as\n+  annotations and generics.  This document provides an overview of EJB \n+  persistence.  Unless otherwise noted, the information presented\n+  applies to all EJB persistence implementations.\n+  </para>\n+      <note>\n+        <para>\n+    This document describes the Public Draft of the EJB 3.0\n+    persistence specification.\n+    </para>\n+        <para>\n+    For coverage of OpenJPA's many extensions to the EJB persistence \n+    specification, see the <link linkend=\"ref_guide_intro\">Reference\n+    Guide</link>.\n+    </para>\n+      </note>\n+      <section id=\"jpa_overview_intro_audience\">\n+        <title>Intended Audience</title>\n+        <para>\n+    This document is intended for developers who want to learn about\n+    EJB persistence in order to use it in their applications.\n+    It assumes that you have a strong knowledge of object-oriented concepts\n+    and Java, including Java 5 annotations and generics.  It also assumes\n+    some experience with relational databases and the \n+    Structured Query Language (SQL).\n+    </para>\n+      </section>\n+      <section id=\"jpa_overview_intro_transpers\">\n+        <title>Lightweight Persistence</title>\n+        <indexterm zone=\"jpa_overview_intro_transpers\">\n+          <primary>lightweight persistence</primary>\n+        </indexterm>\n+        <para><indexterm><primary>persistent data</primary></indexterm><emphasis>Persistent data</emphasis> is information that can\n+    outlive the program that creates it.  The majority of complex\n+    programs use persistent data: GUI applications need to store user \n+    preferences across program invocations, web applications track \n+    user movements and orders over long periods of time, etc.\n+    </para>\n+        <para><emphasis>Lightweight persistence</emphasis> is the storage and \n+    retrieval of persistent data with little or no work from you, the \n+    developer.  For example, Java serialization<indexterm><primary>serialization</primary></indexterm> is a form of \n+    lightweight persistence because it can be used to persist Java \n+    objects directly to a file with very little effort.  Serialization's\n+    capabilities as a lightweight persistence mechanism pale in \n+    comparison to those provided by EJB, however.  The next\n+    chapter compares EJB to serialization and other available\n+    persistence mechanisms.\n+    </para>\n+      </section>\n+    </chapter>"},{"sha":"ebb24243daee1853932bc53923ff1883c935de11","filename":"openjpa-project/src/doc/manual/jpa_overview_mapping.xml","status":"added","additions":4239,"deletions":0,"changes":4239,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_mapping.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_mapping.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_overview_mapping.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53"},{"sha":"f175c60cef35094860e7f91d2c9781f64269c538","filename":"openjpa-project/src/doc/manual/jpa_overview_meta.xml","status":"added","additions":3519,"deletions":0,"changes":3519,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_meta.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_meta.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_overview_meta.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53"},{"sha":"0c1cb15b28a7ef085fe6a6d3b3198b89b97e2d69","filename":"openjpa-project/src/doc/manual/jpa_overview_pc.xml","status":"added","additions":1058,"deletions":0,"changes":1058,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_pc.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_pc.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_overview_pc.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,1058 @@\n+\n+    <chapter id=\"jpa_overview_pc\">\n+      <title>Entity</title>\n+      <indexterm zone=\"jpa_overview_pc\">\n+        <primary>persistent classes</primary>\n+      </indexterm>\n+      <indexterm zone=\"jpa_overview_pc\">\n+        <primary>Entity</primary>\n+        <seealso>persistent classes</seealso>\n+      </indexterm>\n+      <indexterm>\n+        <primary>class</primary>\n+        <secondary>persistent</secondary>\n+        <see>persistent classes</see>\n+      </indexterm>\n+      <indexterm>\n+        <primary>persistence capable</primary>\n+        <see>Entity</see>\n+      </indexterm>\n+      <para>\n+  JPA recognizes two types of persistent classes: <emphasis>\n+  entity</emphasis> classes and <emphasis>embeddable</emphasis> classes.\n+  Each persistent instance of an entity class - each \n+  <emphasis>entity</emphasis> - represents a unique datastore\n+  record.  You can use the <classname>EntityManager</classname> to find an \n+  entity by its persistent identity (covered later in this chapter), or use \n+  a <classname>Query</classname> to find entities matching certain criteria.  \n+  </para>\n+      <para>\n+  An instance of an embeddable class, on the other hand, is only stored\n+  as part of a separate entity.  Embeddable instances have no\n+  persistent identity, and are never returned directly from the\n+  <classname>EntityManager</classname> or from a <classname>Query</classname>.\n+  </para>\n+      <para>\n+  Despite these differences, there are few differences between entity classes\n+  and embeddable classes.  In fact, writing either type\n+  of persistent class is little different than writing any other \n+  class.  There are no special parent classes to extend from, field types to \n+  use, or methods to write.  This is one important way in which JPA makes\n+  persistence transparent to you, the developer.\n+  </para>\n+      <note>\n+        <para>\n+    JPA supports both fields and JavaBean properties\n+    as persistent state.  For simplicity, however, we will\n+    refer to all persistent state as persistent fields, unless we\n+    want to note a unique aspect of persistent properties.\n+    </para>\n+      </note>\n+      <example id=\"jpa_overview_pc_pcclass\">\n+        <title>Persistent Class</title>\n+        <programlisting format=\"linespecific\">\n+package org.mag;\n+\n+/**\n+ * Example persistent class.  Notice that it looks exactly like any other\n+ * class.  JPA makes writing persistent classes completely transparent.\n+ */\n+public class Magazine\n+{\n+    private String    isbn;\n+    private String    title;\n+    private Set       articles = new HashSet ();\n+    private Article   coverArticle;\n+    private int       copiesSold;\n+    private double    price;\n+    private Company   publisher;\n+    private int       version;\n+\n+    protected Magazine ()\n+    {\n+    }\n+\n+    public Magazine (String title, String isbn)\n+    {\n+        this.title = title;\n+        this.isbn = isbn;\n+    }\n+\n+    public void publish (Company publisher, double price)\n+    {\n+        this.publisher = publisher;\n+        publisher.addMagazine (this);\n+        this.price = price;\n+    }\n+    \n+    public void sell ()\n+    {\n+        copiesSold++;\n+        publisher.addRevenue (price);\n+    }\n+\n+    public void addArticle (Article article)\n+    {\n+        articles.add (article);\n+    }\n+\n+    // rest of methods omitted\n+}\n+</programlisting>\n+      </example>\n+      <section id=\"jpa_overview_pc_restrict\">\n+        <title>Restrictions on Persistent Classes</title>\n+        <indexterm zone=\"jpa_overview_pc_restrict\">\n+          <primary>persistent classes</primary>\n+          <secondary>restrictions on</secondary>\n+        </indexterm>\n+        <para>\n+    There are very few restrictions placed on persistent classes.\n+    Still, it never hurts to familiarize yourself with exactly what\n+    JPA does and does not support.\n+    </para>\n+        <section id=\"jpa_overview_pc_no_arg\">\n+          <title>Default or No-Arg Constructor</title>\n+          <indexterm zone=\"jpa_overview_pc_no_arg\">\n+            <primary>persistent classes</primary>\n+            <secondary>no-arg constructor requirement</secondary>\n+          </indexterm>\n+          <indexterm>\n+            <primary>constructor</primary>\n+            <secondary>no-arg constructor requirement</secondary>\n+          </indexterm>\n+          <para>\n+      The JPA specification requires that all persistent\n+      classes have a no-arg constructor.  This constructor\n+      may be public or protected.  Because the compiler automatically\n+      creates a default no-arg constructor when no other constructor\n+      is defined, only classes that define constructors must also\n+      include a no-arg constructor.\n+      </para>\n+          <note>\n+            <para>\n+        OpenJPA's <emphasis>enhancer</emphasis> will automatically add a \n+        protected no-arg constructor to your class when required.  \n+        Therefore, this restriction does not apply when using\n+        OpenJPA.  See <xref linkend=\"ref_guide_pc_enhance\"/> \n+        of the Reference Guide for details.\n+        </para>\n+          </note>\n+        </section>\n+        <section id=\"jpa_overview_pc_final\">\n+          <title>Final</title>\n+          <para>\n+      Entity classes may not be final.  No method of an entity class can\n+      be final.\n+      </para>\n+          <note>\n+            <para>\n+        OpenJPA supports final classes and final methods.\n+        </para>\n+          </note>\n+        </section>\n+        <section id=\"jpa_overview_pc_id\">\n+          <title>Identity Fields</title>\n+          <indexterm zone=\"jpa_overview_pc_id\">\n+            <primary>identity fields</primary>\n+            <seealso>persistent fields</seealso>\n+          </indexterm>\n+          <indexterm zone=\"jpa_overview_pc_id\">\n+            <primary>persistent classes</primary>\n+            <secondary>JPA id requirement</secondary>\n+          </indexterm>\n+          <para>\n+      All entity classes must declare one or more fields which together\n+      form the persistent identity of an instance.  These are called \n+      <emphasis>identity</emphasis> or <emphasis>primary key</emphasis>\n+      fields.  In our <classname>Magazine</classname> class, \n+      <literal>isbn</literal> and\n+      <literal>title</literal> are identity fields, because no two \n+      magazine records in the datastore can have the same \n+      <literal>isbn</literal> and <literal>title</literal> values.\n+      <xref linkend=\"jpa_overview_meta_id\"/> will show you how to denote \n+      your identity fields in JPA metadata.  \n+      <xref linkend=\"jpa_overview_pc_identity\"/> below examines \n+      persistent identity.\n+      </para>\n+          <note>\n+            <para>\n+        OpenJPA fully supports identity fields, but does not require them.\n+        See <xref linkend=\"ref_guide_pc_oid\"/> of the Reference\n+        Guide for details.\n+        </para>\n+          </note>\n+        </section>\n+        <section id=\"jpa_overview_pc_version\">\n+          <title>Version Field</title>\n+          <indexterm zone=\"jpa_overview_pc_version\">\n+            <primary>version fields</primary>\n+            <seealso>persistent fields</seealso>\n+          </indexterm>\n+          <indexterm zone=\"jpa_overview_pc_version\">\n+            <primary>persistent classes</primary>\n+            <secondary>JPA version requirement</secondary>\n+          </indexterm>\n+          <para>\n+      The <literal>version</literal> field in our <classname>Magazine\n+      </classname> class may seem out of place.\n+      JPA uses a version field in your entity to detect\n+      concurrent modifications to the same datastore record.  When the\n+      JPA runtime detects an attempt to concurrently modify \n+      the same record, it throws an exception to the transaction \n+      attempting to commit last.  This prevents overwriting the previous\n+      commit with stale data.\n+      </para>\n+          <para>\n+      The version field is not required, but without one concurrent \n+      threads or processes might succeed in making conflicting changes \n+      to the same record at the same time.  This is unacceptable to most\n+      applications.  <xref linkend=\"jpa_overview_meta_version\"/>\n+      shows you how to designate a version field in JPA metadata.\n+      </para>\n+          <para>\n+      The version field must be an integral type (<classname>\n+      int</classname>, <classname>Long</classname>, etc) or a \n+      <classname>java.sql.Timestamp</classname>.  You should consider\n+      version fields immutable.  Changing the field value has undefined\n+      results.\n+      </para>\n+          <note>\n+            <para>\n+        OpenJPA fully supports version fields, but does not require them\n+        for concurrency detection.  OpenJPA can maintain \n+        surrogate version values or use state comparisons to detect \n+        concurrent modifications.  See \n+        <xref linkend=\"ref_guide_mapping_ejb\"/> in the Reference Guide.\n+        </para>\n+          </note>\n+        </section>\n+        <section id=\"jpa_overview_pc_restrict_inheritance\">\n+          <title>Inheritance</title>\n+          <indexterm zone=\"jpa_overview_pc_restrict_inheritance\">\n+            <primary>persistent classes</primary>\n+            <secondary>inheritance of</secondary>\n+            <seealso>inheritance</seealso>\n+          </indexterm>\n+          <indexterm>\n+            <primary>inheritance</primary>\n+            <secondary>of persistent classes</secondary>\n+          </indexterm>\n+          <para>\n+      JPA fully supports inheritance in persistent classes.  \n+      It allows persistent classes to inherit from non-persistent classes,\n+      persistent classes to inherit from other persistent classes,\n+      and non-persistent classes to inherit from persistent classes.\n+      It is even possible to form inheritance hierarchies in which\n+      persistence skips generations.  There are, however, a few \n+      important limitations:\n+      </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+          Persistent classes cannot inherit from certain\n+          natively-implemented system classes such as\n+          <classname>java.net.Socket</classname> and \n+          <classname>java.lang.Thread</classname>.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+          If a persistent class inherits from a non-persistent\n+          class, the fields of the non-persistent superclass\n+          cannot be persisted.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+          All classes in an inheritance tree must use the same\n+          identity type.  We cover entity identity in\n+          <xref linkend=\"jpa_overview_pc_identity\"/>.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+        </section>\n+        <section id=\"jpa_overview_pc_restrict_fields\">\n+          <title>Persistent Fields</title>\n+          <indexterm zone=\"jpa_overview_pc_restrict_fields\">\n+            <primary>persistent classes</primary>\n+            <secondary>field restrictions</secondary>\n+            <seealso>persistent fields</seealso>\n+          </indexterm>\n+          <indexterm>\n+            <primary>field</primary>\n+            <secondary>persistent</secondary>\n+            <see>persistent fields</see>\n+          </indexterm>\n+          <indexterm zone=\"jpa_overview_pc_restrict_fields\">\n+            <primary>persistent fields</primary>\n+            <secondary>restrictions on</secondary>\n+          </indexterm>\n+          <para>\n+      JPA manages the state of all persistent fields.\n+      Before you access persistent state, the JPA runtime\n+      makes sure that it has been loaded from the datastore.  When you \n+      set a field, the runtime records that it has changed so that \n+      the new value will be persisted.  This allows you to treat the \n+      field in exactly the same way you treat any other field - another \n+      aspect of JPA's transparency.\n+      </para>\n+          <para>\n+      JPA does not support static or final fields.\n+      It does, however, include built-in support for most \n+      common field types.  These types can be roughly divided into three \n+      categories: immutable types, mutable types, and relations.\n+      </para>\n+          <para><indexterm><primary>persistent fields</primary><secondary>immutable types</secondary></indexterm><indexterm><primary>immutable</primary><secondary>persistent field types</secondary></indexterm><emphasis>Immutable</emphasis> types, once created, cannot be   \n+      changed.  The only way to alter a persistent field of an immutable \n+      type is to assign a new value to the field.  JPA \n+      supports the following immutable types:\n+      </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+          All primitives (<classname>int, float, byte</classname>,\n+          etc)\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+          All primitive wrappers (<classname>java.lang.Integer,\n+          java.lang.Float, java.lang.Byte</classname>, etc)\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+                <classname>java.lang.String</classname>\n+              </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+                <classname>java.math.BigInteger</classname>\n+              </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+                <classname>java.math.BigDecimal</classname>\n+              </para>\n+            </listitem>\n+          </itemizedlist>\n+          <para>\n+      JPA also supports <classname>byte[]</classname> and\n+      <classname>char[]</classname> as immutable types.  That is, you\n+      can persist fields of these types, but you should not manipulate\n+      individual array indexes without resetting the array into the \n+      persistent field.\n+      </para>\n+<!-- ### EJB3 : Byte[], Character[] -->\n+          <para><indexterm><primary>persistent fields</primary><secondary>mutable types</secondary><seealso>proxies</seealso></indexterm><indexterm><primary>mutable</primary><secondary>persistent field types</secondary><seealso>persistent fields</seealso><seealso>proxies</seealso></indexterm><indexterm><primary>persistent fields</primary><secondary>user-defined types</secondary></indexterm><indexterm><primary>user-defined</primary><secondary>persistent field types</secondary><seealso>persistent fields</seealso></indexterm>\n+      Persistent fields of <emphasis>mutable</emphasis> types \n+      can be altered without assigning the field a new value.\n+      Mutable types can be modified directly through their own\n+      methods.  The JPA specification requires that\n+      implementations support the following mutable field types:\n+      </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+                <classname>java.util.Date</classname>\n+              </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+                <classname>java.util.Calendar</classname>\n+              </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+                <classname>java.sql.Date</classname>\n+              </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+                <classname>java.sql.Timestamp</classname>\n+              </para>\n+            </listitem>\n+            <listitem>\n+              <para>Enums</para>\n+            </listitem>\n+            <listitem>\n+              <para>Entity types (relations between entities)</para>\n+            </listitem>\n+            <listitem>\n+              <para>Embeddable types</para>\n+            </listitem>\n+            <listitem>\n+              <para><classname>java.util.Collection</classname>s of entities\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><classname>java.util.Set</classname>s of entities\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><classname>java.util.List</classname>s of entities\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><classname>java.util.Map</classname>s in which each entry\n+          maps the value of one of an entity's fields to that entity.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+          <para>\n+      Collection and map types may be parameterized.\n+      </para>\n+          <para><indexterm><primary>persistent fields</primary><secondary>of unknown types</secondary></indexterm><indexterm><primary>Object</primary><secondary>as persistent field type</secondary><seealso>persistent fields</seealso></indexterm>\n+      Most JPA implementations also have support for \n+      persisting serializable values as binary data in the datastore.\n+      <xref linkend=\"jpa_overview_meta\"/> has more information on\n+      persisting serializable types.\n+      </para>\n+          <note>\n+            <para>\n+        OpenJPA also supports arrays, <classname>\n+        java.lang.Number</classname>, <classname>\n+        java.util.Locale</classname>, all JDK 1.2 <classname>\n+        Set</classname>, <classname>List</classname>, and <classname>\n+        Map</classname> types, collections and maps of immutable and\n+        embedded as well as entity types, and many other mutable and \n+        immutable field types.  OpenJPA also allows you to plug in \n+        support for custom types.\n+        </para>\n+          </note>\n+        </section>\n+        <section id=\"jpa_overview_pc_restrict_conclusion\">\n+          <title>Conclusions</title>\n+          <para>\n+      This section detailed all of the restrictions JPA \n+      places on persistent classes.  While it may seem like we presented \n+      a lot of information, you will seldom find yourself hindered by \n+      these restrictions in practice.  Additionally, there are often ways\n+      of using JPA's other features to circumvent any \n+      limitations you run into.  \n+      <!-- ### EJBDOC : good transition when lifecycle listeners are\n+           ### added back as next section\n+      The next section explores a powerful JPA feature \n+      that is particularly useful for this purpose.\n+      -->\n+      </para>\n+        </section>\n+      </section>\n+      <section id=\"jpa_overview_pc_identity\">\n+        <title>Entity Identity</title>\n+        <indexterm zone=\"jpa_overview_pc_identity\">\n+          <primary>JPA</primary>\n+          <secondary>identity</secondary>\n+          <seealso>identity</seealso>\n+        </indexterm>\n+        <indexterm>\n+          <primary>entity identity</primary>\n+          <see>identity</see>\n+        </indexterm>\n+        <indexterm zone=\"jpa_overview_pc_identity\">\n+          <primary>identity</primary>\n+          <secondary>JPA</secondary>\n+        </indexterm>\n+        <para><indexterm><primary>identity</primary><secondary>numeric</secondary></indexterm><indexterm><primary>identity</primary><secondary>qualitative</secondary></indexterm><indexterm><primary>numeric identity</primary><seealso>identity</seealso></indexterm><indexterm><primary>qualitative identity</primary><seealso>identity</seealso></indexterm>\n+    Java recognizes two forms of object identity: numeric identity and\n+    qualitative identity.  If two references are \n+    <emphasis>numerically</emphasis> identical, then they refer to the \n+    same JVM instance in memory.  You can test for this using the \n+    <literal>==</literal> operator.  <emphasis>Qualitative</emphasis> \n+    identity, on the other hand, relies on some user-defined criteria to \n+    determine whether two objects are \"equal\".  You test for qualitative \n+    identity using the <methodname>equals</methodname> method.  By default,\n+    this method simply relies on numeric identity.\n+    </para>\n+        <para>\n+    JPA introduces another form of object identity, called \n+    <emphasis>entity identity</emphasis> or <emphasis>persistent \n+    identity</emphasis>.  Entity identity tests whether two persistent \n+    objects represent the same state in the datastore.\n+    </para>\n+        <para><indexterm><primary>persistent fields</primary><secondary>id</secondary></indexterm><indexterm><primary>id</primary><secondary>fields</secondary><seealso>persistent fields</seealso></indexterm>\n+     The entity identity of each persistent instance is encapsulated in its \n+    <emphasis>identity field(s)</emphasis>.  If two entities of the same \n+    type have the same identity field values, then the two \n+    entities represent the same state in the datastore.  Each entity's \n+    identity field values must be unique among all other entites of the \n+    same type.\n+    </para>\n+        <para>\n+    Identity fields must be primitives, primitive wrappers, \n+    <classname>String</classname>s, <classname>Date</classname>s,\n+    <classname>Timestamp</classname>s, or embeddable types. Notably, other \n+    entities instances can <emphasis>not</emphasis> be used as identity \n+    fields.\n+    </para>\n+        <note>\n+          <para>\n+      For legacy schemas with binary primary key columns, OpenJPA\n+      also supports using identity fields of type \n+      <classname>byte[]</classname>.  When you use a <classname>byte[]\n+      </classname> identity field, you must \n+      create an identity class.  Identity classes are covered below.\n+      </para>\n+        </note>\n+        <warning>\n+          <para>\n+      Changing the fields of an embeddable instance while it is assigned\n+      to an identity field has undefined results.  Always treat \n+      embeddable identity instances as immutable objects in your \n+      applications.\n+      </para>\n+        </warning>\n+        <para><indexterm><primary>identity</primary><secondary>uniqueness requirement</secondary></indexterm><indexterm><primary>uniquness requirement</primary><seealso>identity</seealso></indexterm>\n+    If you are dealing with a single persistence context (see\n+    <xref linkend=\"jpa_overview_emfactory_perscontext\"/>),\n+    then you do not have to compare identity fields to test \n+    whether two entity references represent the same state in the \n+    datastore.  There is a much easier way: the \n+    <literal>==</literal> operator.  JPA requires that \n+    each persistence context maintain only one JVM object to represent \n+    each unique datastore record.  Thus, entity identity is equivalent to \n+    numeric identity within a persistence context.  This is referred to as \n+    the <emphasis>uniqueness requirement</emphasis>. \n+    </para>\n+        <para>\n+    The uniqueness requirement is extremely important - without it, it\n+    would be impossible to maintain data integrity.  Think of what \n+    could happen if two different objects in the same transaction\n+    were allowed to represent the same persistent data.  If you made \n+    different modifications to each of these objects, which set of changes \n+    should be written to the datastore?  How would your application logic \n+    handle seeing two different \"versions\" of the same data?  Thanks to the\n+    uniqueness requirement, these questions do not have to be answered.\n+    </para>\n+        <section id=\"jpa_overview_pc_identitycls\">\n+          <title>Identity Class</title>\n+          <para><indexterm zone=\"jpa_overview_pc_identitycls\"><primary>identity class</primary><seealso>identity</seealso></indexterm><indexterm zone=\"jpa_overview_pc_identitycls\"><primary>identity</primary><secondary>class requirements</secondary></indexterm>\n+      If your entity has only one identity field, you can use the value of\n+      that field as the entity's identity object in all \n+      <link linkend=\"jpa_overview_em\"><classname>EntityManager\n+      </classname></link> APIs.  Otherwise, you must supply an identity \n+      class to use for identity objects.  Your identity\n+      class must meet the following criteria:\n+      </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>The class must be public.</para>\n+            </listitem>\n+            <listitem>\n+              <para>The class must be serializable.</para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+          The class must have a public no-args constructor.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+          The names of the non-static fields or properties of the \n+          class must be the same as the names of the identity fields\n+          or properties of the corresponding entity class, and the \n+          types must be identical.  \n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+          The <methodname>equals</methodname> and \n+          <methodname>hashCode</methodname> methods of the class\n+          must use the values of all fields or properties \n+          corresponding to identity fields or properties in the \n+          entity class.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+          If the class is an inner class, it must be\n+          <literal>static</literal>.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+          All entity classes related by inheritance must use the same\n+          identity class, or else each entity class must have its \n+          own identity class whose inheritance hierarchy mirrors the \n+          inheritance hierarchy of the owning entity classes (see \n+          <xref linkend=\"jpa_overview_pc_identity_hierarchy\"/>).\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+          <note>\n+            <para>\n+        Though you may still create identity classes by\n+        hand, OpenJPA provides the <classname>appidtool</classname>\n+        to automatically generate proper identity classes\n+        based on your identity fields.  See\n+        <xref linkend=\"ref_guide_pc_oid_application\"/> of the\n+        Reference Guide.\n+        </para>\n+          </note>\n+          <example id=\"jpa_overview_pc_identity_appidcode\">\n+            <title>Identity Class</title>\n+            <para>\n+        This example illustrates a proper identity class for an entity\n+        with multiple identity fields.\n+        </para>\n+            <programlisting format=\"linespecific\">\n+/**\n+ * Persistent class using application identity.\n+ */\n+public class Magazine\n+{\n+    private String isbn;    // identity field\n+    private String title;   // identity field\n+\n+    // rest of fields and methods omitted\n+\n+\n+    /**\n+     * Application identity class for Magazine.\n+     */\n+    public static class MagazineId\n+    {\n+        // each identity field in the Magazine class must have a\n+        // corresponding field in the identity class\n+        public String isbn;\n+        public String title;\n+\n+        /**\n+         * Equality must be implemented in terms of identity field\n+         * equality, and must use instanceof rather than comparing \n+         * classes directly (some JPA implementations may subclass the\n+         * identity class).\n+         */\n+        public boolean equals (Object other)\n+        {\n+            if (other == this)\n+                return true;\n+            if (!(other instanceof MagazineId))\n+                return false;\n+    \n+            MagazineId mi = (MagazineId) other;\n+            return (isbn == mi.isbn\n+                || (isbn != null &amp;&amp; isbn.equals (mi.isbn)))\n+                &amp;&amp; (title == mi.title\n+                || (title != null &amp;&amp; title.equals (mi.title)));\n+        }\n+     \n+        /**\n+         * Hashcode must also depend on identity values.\n+         */\n+        public int hashCode ()\n+        {\n+            return ((isbn == null) ? 0 : isbn.hashCode ())\n+                ^ ((title == null) ? 0 : title.hashCode ());\n+        } \n+\n+        public String toString ()\n+        {\n+            return isbn + \":\" + title;\n+        }\n+    }\n+}\n+</programlisting>\n+          </example>\n+          <section id=\"jpa_overview_pc_identity_hierarchy\">\n+            <title>Identity Hierarchies</title>\n+            <indexterm zone=\"jpa_overview_pc_identity_hierarchy\">\n+              <primary>identity</primary>\n+              <secondary>hierarchy</secondary>\n+            </indexterm>\n+            <mediaobject>\n+              <imageobject>\n+<!-- PNG image data, 320 x 267 (see README) -->\n+                <imagedata fileref=\"img/appid-hierarchy.png\" width=\"213px\"/>\n+              </imageobject>\n+            </mediaobject>\n+            <para>\n+        An alternative to having a single identity\n+        class for an entire inheritance hierarchy is to have\n+        one identity class per level in the\n+        inheritance hierarchy. The requirements for using\n+        a hierarchy of identity classes are as follows:\n+        </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para>\n+            The inheritance hierarchy of identity \n+            classes must exactly mirror the hierarchy of the\n+            persistent classes that they identify. In the example\n+            pictured above, abstract class\n+            <classname>Person</classname> is extended by abstract\n+            class <classname>Employee</classname>, which is extended\n+            by non-abstract class <classname>\n+            FullTimeEmployee</classname>, which is extended by\n+            non-abstract class <classname>Manager</classname>.\n+            The corresponding identity classes, then, are\n+            an abstract <classname>PersonId</classname> class,\n+            extended by an abstract \n+            <classname>EmployeeId</classname> class, extended by a \n+            non-abstract <classname>FullTimeEmployeeId</classname>\n+            class, extended by a non-abstract\n+            <classname>ManagerId</classname> class.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para>\n+            Subclasses in the identity hierarchy\n+            may define additional identity fields until\n+            the hierarchy becomes non-abstract. In the\n+            aforementioned example, <classname>Person</classname>\n+            defines an identity field <literal>ssn</literal>,\n+            <classname>Employee</classname> defines additional \n+            identity field <literal>userName</literal>, and \n+            <classname>FullTimeEmployee</classname> adds a final\n+            identity field, <literal>empId</literal>.  \n+            However, <classname>Manager</classname> may not define \n+            any additional identity fields, since it is a \n+            subclass of a non-abstract class.  The hierarchy of\n+            identity classes, of course, must match the identity\n+            field definitions of the persistent class hierarchy.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para>\n+            It is not necessary for each abstract class to declare \n+            identity fields.  In the previous example, the \n+            abstract <classname>Person</classname> and \n+            <classname>Employee</classname> classes could declare \n+            no identity fields, and the first concrete subclass \n+            <classname>FullTimeEmployee</classname> could define \n+            one or more identity fields.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para>\n+            All subclasses of a concrete identity class must\n+            be <methodname>equals</methodname> and <methodname>\n+            hashCode</methodname>-compatible with the concrete\n+            superclass.  This means that in our example, a\n+            <classname>ManagerId</classname> instance and a\n+            <classname>FullTimeEmployeeId</classname> instance \n+            with the same identity field values should have the\n+            same hash code, and should compare equal to each other\n+            using the <methodname>equals</methodname> method of\n+            either one.  In practice, this requirement reduces to\n+            the following coding practices:  \n+            </para>\n+                <orderedlist>\n+                  <listitem>\n+                    <para>\n+                Use <literal>instanceof</literal> instead of\n+                comparing <classname>Class</classname> objects\n+                in the <methodname>equals</methodname> methods\n+                of your identity classes.\n+                </para>\n+                  </listitem>\n+                  <listitem>\n+                    <para>\n+                An identity class that extends another \n+                non-abstract identity class should not override\n+                <methodname>equals</methodname> or \n+                <methodname>hashCode</methodname>.\n+                </para>\n+                  </listitem>\n+                </orderedlist>\n+              </listitem>\n+            </itemizedlist>\n+          </section>\n+        </section>\n+      </section>\n+      <section id=\"jpa_overview_pc_callbacks\">\n+        <title>Lifecycle Callbacks</title>\n+        <indexterm zone=\"jpa_overview_pc_callbacks\">\n+          <primary>lifecycle callbacks</primary>\n+        </indexterm>\n+        <indexterm zone=\"jpa_overview_pc_callbacks\">\n+          <primary>persistent classes</primary>\n+          <secondary>lifecycle callbacks</secondary>\n+          <seealso>lifecycle callbacks</seealso>\n+        </indexterm>\n+        <para>\n+    It is often necessary to perform various actions at different stages\n+    of a persistent object's lifecycle.  JPA includes \n+    a variety of callbacks methods for monitoring changes in the \n+    lifecycle of your persistent objects.  These callbacks can\n+    be defined on the persistent classes themselves and\n+    on non-persistent listener classes.\n+    </para>\n+        <section id=\"jpa_overview_pc_callbacks_methods\">\n+          <title>Callback Methods</title>\n+          <indexterm zone=\"jpa_overview_pc_callbacks_methods\">\n+            <primary>lifecycle callbacks</primary>\n+            <secondary>callback methods</secondary>\n+          </indexterm>\n+          <indexterm zone=\"jpa_overview_pc_callbacks_methods\">\n+            <primary>entity</primary>\n+            <secondary>callback methods</secondary>\n+          </indexterm>\n+          <para>\n+      Every persistence event has a corresponding callback method\n+      marker.  These markers are shared between persistent classes\n+      and their listeners.  You can use these markers to designate\n+      a method for callback either by annotating that method or by\n+      listing the method in the XML mapping file for a given class.\n+      The lifecycle events and their corresponding method markers are:\n+      </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para><indexterm><primary>PrePersist</primary><seealso>lifecycle callbacks</seealso></indexterm><ulink url=\"http://java.sun.com/javaee/5/docs/api/javax/persistence/PrePersist.html\"><classname>PrePersist</classname></ulink>:\n+          Methods marked with this annotation will be invoked \n+          before an object is persisted.  This could be used for \n+          assigning primary key values to persistent objects.\n+          This is equivalent to the XML element tag \n+          <literal>pre-persist</literal>.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><indexterm><primary>PostPersist</primary><seealso>lifecycle callbacks</seealso></indexterm><ulink url=\"http://java.sun.com/javaee/5/docs/api/javax/persistence/PostPersist.html\"><classname>PostPersist</classname></ulink>:\n+          Methods marked with this annotation will be invoked \n+          after an object has transitioned to the persistent state.  \n+          You might want to use such methods to update a screen\n+          after a new row is added.  This is equivalent \n+          to the XML element tag <literal>post-persist</literal>.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><indexterm><primary>PostLoad</primary><seealso>lifecycle callbacks</seealso></indexterm><ulink url=\"http://java.sun.com/javaee/5/docs/api/javax/persistence/PostLoad.html\"><classname>PostLoad</classname></ulink>:\n+          Methods marked with this annotation will be invoked after \n+          all eagerly fetched fields of your class have been\n+          loaded from the datastore.  No other persistent fields\n+          can be accessed in this method.  This is equivalent \n+          to the XML element tag <literal>post-load</literal>.\n+          </para>\n+              <para><classname>PostLoad</classname> is often used to\n+          initialize non-persistent fields whose values depend \n+          on the values of persistent fields, such as a complex\n+          datastructure.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><indexterm><primary>PreUpdate</primary><seealso>lifecycle callbacks</seealso></indexterm><ulink url=\"http://java.sun.com/javaee/5/docs/api/javax/persistence/PreUpdate.html\"><classname>PreUpdate</classname></ulink>:\n+          Methods marked with this annotation will be invoked \n+          just the persistent values in your objects are flushed\n+          to the datastore. This is equivalent to the XML element tag \n+          <literal>pre-update</literal>.\n+          </para>\n+              <para><classname>PreUpdate</classname> is the complement to\n+          <classname>PostLoad</classname>.  While methods marked\n+          with <classname>PostLoad</classname> are most often used\n+          to initialize non-persistent values from persistent data,\n+          methods annotated with <classname>PreUpdate</classname>\n+          is normally used to set persistent fields with information\n+          cached in non-persistent data.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><indexterm><primary>PostUpdate</primary><seealso>lifecycle callbacks</seealso></indexterm><ulink url=\"http://java.sun.com/javaee/5/docs/api/javax/persistence/PostUpdate.html\"><classname>PostUpdate</classname></ulink>:\n+          Methods marked with this annotation will be invoked \n+          after changes to a given instance have been stored to the \n+          datastore. This is useful for clearing stale data cached\n+          at the application layer.  This is equivalent to the \n+          XML element tag <literal>post-update</literal>.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><indexterm><primary>PreRemove</primary><seealso>lifecycle callbacks</seealso></indexterm><ulink url=\"http://java.sun.com/javaee/5/docs/api/javax/persistence/PreRemove.html\"><classname>PreRemove</classname></ulink>:\n+          Methods marked with this annotation will be invoked \n+          before an object transactions to the deleted state.  \n+          Access to persistent fields is valid within this method.\n+          You might use this method to cascade the deletion to\n+          related objects based on complex criteria, or to \n+          perform other cleanup. This is equivalent to the \n+          XML element tag <literal>pre-remove</literal>.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><indexterm><primary>PostRemove</primary><seealso>lifecycle callbacks</seealso></indexterm><ulink url=\"http://java.sun.com/javaee/5/docs/api/javax/persistence/PostRemove.html\"><classname>PostRemove</classname></ulink>:\n+          Methods marked with this annotation will be invoked after \n+          an object has been marked as to be deleted.  This is \n+          equivalent to the XML element tag \n+          <literal>post-remove</literal>.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+        </section>\n+        <section id=\"jpa_overview_callbacks_using\">\n+          <title>Using Callback Methods</title>\n+          <para>\n+      When declaring callback methods on a persistent class,\n+      any method may be used which takes no arguments and is not\n+      shared with any property access fields.  Multiple events\n+      can be assigned to a single method as well.\n+      </para>\n+          <para>\n+      Below is an example of how to declare callback methods\n+      on persistent classes:\n+      </para>\n+          <programlisting format=\"linespecific\">\n+/**\n+ * Example persistent class declaring our entity listener.\n+ */\n+@Entity\n+public class Magazine\n+{\n+    @Transient \n+    private byte[][] data;\n+\n+    @ManyToMany\n+    private List&lt;Photo&gt; photos;\n+\n+    @PostLoad\n+    public void convertPhotos ()\n+    {\n+        data = new byte[photos.size ()][];\n+        for (int i = 0; i &lt; photos.size (); i++)\n+            data[i] = photos.get (i).toByteArray ();\n+    }\n+\n+    @PreDelete\n+    public void logMagazineDeletion ()\n+    {\n+        getLog ().debug (\"deleting magazine containing\" + photos.size () \n+            + \" photos.\");\n+    }\n+}\n+\n+</programlisting>\n+          <para>\n+      In an XML mapping file, we can define the same methods \n+      without annotations:\n+      </para>\n+          <programlisting format=\"linespecific\">\n+&lt;entity class=\"Magazine\"&gt;\n+    &lt;pre-remove&gt;logMagazineDeletion&lt;/pre-remove&gt;\n+    &lt;post-load&gt;convertPhotos&lt;/post-load&gt;\n+&lt;/entity&gt;\n+</programlisting>\n+          <note>\n+            <para>\n+        We fully explore persistence metadata annotations and XML in \n+        <xref linkend=\"jpa_overview_meta\"/>.\n+        </para>\n+          </note>\n+        </section>\n+        <section id=\"jpa_overview_entity_listeners_using\">\n+          <title>Using Entity Listeners</title>\n+          <para>\n+      Mixing lifecycle event code into your persistent classes is not\n+      always ideal.  It is often more elegant to handle cross-cutting \n+      lifecycle events in a non-persistent listener class.\n+      JPA allows for this, requiring only that listener\n+      classes have a public no-arg constructor.  Like persistent \n+      classes, your listener classes can consume any number of callbacks.\n+      The callback methods must take in a single \n+      <classname>java.lang.Object</classname> argument which\n+      represents the persistent object that triggered the event.\n+      </para>\n+          <para>\n+      Entities can enumerate listeners using the \n+      <classname>EntityListeners</classname> annotation.  This annotation\n+      takes an array of listener classes as its value.\n+      </para>\n+          <para>\n+      Below is an example of how to declare an entity and its \n+      corresponding listener classes.\n+      </para>\n+          <programlisting format=\"linespecific\">\n+/**\n+ * Example persistent class declaring our entity listener.\n+ */\n+@Entity\n+@EntityListeners({ MagazineLogger.class, ... })\n+public class Magazine\n+{\n+    // ... //\n+}\n+\n+\n+/**\n+ * Example entity listener.\n+ */\n+public class MagazineLogger\n+{\n+    @PostPersist\n+    public void logAddition (Object pc)\n+    {\n+        getLog ().debug (\"Added new magazine:\" + ((Magazine) pc).getTitle ());\n+    }\n+\n+\n+    @PreRemove\n+    public void logDeletion (Object pc)\n+    {\n+        getLog ().debug (\"Removing from circulation:\" + \n+            ((Magazine) pc).getTitle ());\n+    }\n+}\n+</programlisting>\n+          <para>\n+      In XML, we define both the listeners and their callback\n+      methods as so:\n+      </para>\n+          <programlisting format=\"linespecific\">\n+&lt;entity class=\"Magazine\"&gt;\n+    &lt;entity-listeners&gt;\n+        &lt;entity-listener class=\"MagazineLogger\"&gt;\n+            &lt;post-persist&gt;logAddition&lt;/post-persist&gt;\n+            &lt;pre-remove&gt;logDeletion&lt;/pre-remove&gt;\n+        &lt;/entity-listener&gt;\n+    &lt;/entity-listeners&gt;\n+&lt;/entity&gt;\n+</programlisting>\n+        </section>\n+        <section id=\"jpa_overview_entity_listeners_exclude\">\n+          <title>Entity Listeners Hierarchy</title>\n+          <indexterm zone=\"jpa_overview_entity_listeners_exclude\">\n+            <primary>lifecycle listeners</primary>\n+            <secondary>hierarchy</secondary>\n+          </indexterm>\n+          <para>\n+      Entity listener methods are invoked in a specific order when a \n+      given event is fired. So-called <emphasis>default</emphasis> \n+      listeners are invoked first: these are listeners\n+      which have been defined in a package annotation or in the root \n+      element of XML mapping files.  Next, entity listeners are invoked\n+      in the order of the inheritance hierarchy, with superclass listeners\n+      being invoked before subclass listeners.  Finally, if an entity has\n+      multiple listeners for the same event, the listeners are invoked \n+      in declaration order.\n+      </para>\n+          <para>\n+      You can exclude default listeners and listeners defined in \n+      superclasses from the invocation chain through the use of two \n+      class-level annotations: \n+      </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para><classname>ExcludeDefaultListeners</classname>: This\n+          annotation indicates that no default listeners will be\n+          invoked for this class, or any of its subclasses. The XML\n+          equivalent is the empty\n+          <literal>exclude-default-listeners</literal> element.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><classname>ExcludeSuperclassListeners</classname>: This\n+          annotation will cause OpenJPA to skip invoking any listeners\n+          declared in superclasses.  The XML equivalent is empty the \n+          <literal>exclude-superclass-listeners</literal> element.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+        </section>\n+      </section>\n+      <section id=\"jpa_overview_pc_conclusion\">\n+        <title>Conclusions</title>\n+        <para>\n+    This chapter covered everything you need to know to write persistent\n+    class definitions in JPA.  JPA \n+    cannot use your persistent classes, however, until you complete one \n+    additional step: you must define the persistence metadata.  The next \n+    chapter explores metadata in detail.\n+    </para>\n+      </section>\n+    </chapter>"},{"sha":"bd9ff2dd691e1559498c874d883a4be68d9f601e","filename":"openjpa-project/src/doc/manual/jpa_overview_persistence.xml","status":"added","additions":219,"deletions":0,"changes":219,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_persistence.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_persistence.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_overview_persistence.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,219 @@\n+\n+    <chapter id=\"jpa_overview_persistence\">\n+      <title>Persistence</title>\n+      <indexterm zone=\"jpa_overview_persistence\">\n+        <primary>Persistence</primary>\n+      </indexterm>\n+      <indexterm zone=\"jpa_overview_persistence\">\n+        <primary>EntityManagerFactory</primary>\n+        <secondary>construction</secondary>\n+      </indexterm>\n+      <indexterm zone=\"jpa_overview_persistence\">\n+        <primary>Persistence</primary>\n+        <secondary>getEntityManagerFactory</secondary>\n+      </indexterm>\n+      <indexterm zone=\"jpa_overview_persistence\">\n+        <primary>getEntityManagerFactory</primary>\n+        <seealso>Persistence</seealso>\n+      </indexterm>\n+      <mediaobject>\n+        <imageobject>\n+<!-- PNG image data, 427 x 121 (see README) -->\n+          <imagedata fileref=\"img/persistence.png\" width=\"285px\"/>\n+        </imageobject>\n+      </mediaobject>\n+      <note>\n+        <para>\n+    OpenJPA also includes the \n+    <ulink url=\"../../api/openjpa/persistence/OpenJPAPersistence.html\"><classname>OpenJPAPersistence</classname></ulink> helper class to provide \n+    additional utility methods.\n+    </para>\n+      </note>\n+      <para>\n+  Within a container, you will typically use <emphasis>injection\n+  </emphasis> to access an <classname>EntityManagerFactory</classname>.\n+  Applications operating of a container, however,  can use the\n+  <ulink url=\"http://java.sun.com/javaee/5/docs/api/javax/persistence/Persistence.html\"><classname>Persistence</classname></ulink> class to obtain\n+  <classname>EntityManagerFactory</classname> objects in a vendor-neutral\n+  fashion.\n+  </para>\n+      <programlisting format=\"linespecific\">\n+public static EntityManagerFactory createEntityManagerFactory (String name);\n+public static EntityManagerFactory createEntityManagerFactory (String name, Map props);\n+</programlisting>\n+      <para>\n+  Each <methodname>createEntityManagerFactory</methodname> method searches\n+  the system for an <classname>EntityManagerFactory</classname> definition \n+  with the given name.  Use <literal>null</literal> for an unnamed factory.\n+  The optional map contains vendor-specific property settings used to further\n+  configure the factory.\n+  </para>\n+      <para><filename>persistence.xml</filename> files define <classname>\n+  EntityManagerFactories</classname>.  The <methodname>\n+  createEntityManagerFactory</methodname> methods search for <filename>\n+  persistence.xml</filename> files within the <filename>META-INF</filename> \n+  directory of any <literal>CLASSPATH</literal> element.  For example, if \n+  your <literal>CLASSPATH</literal> contains the <filename>conf</filename>\n+  directory, you could place an <classname>EntityManagerFactory</classname> \n+  definition in <filename>conf/META-INF/persistence.xml</filename>.\n+  </para>\n+      <section id=\"jpa_overview_persistence_xml\">\n+        <title>persistence.xml</title>\n+        <para>\n+    The <filename>persistence.xml</filename> file format obeys the following\n+    Document Type Descriptor (DTD):\n+    </para>\n+        <programlisting format=\"linespecific\">\n+&lt;!ELEMENT persistence (persistence-unit*)&gt;\n+&lt;!ELEMENT persistence-unit (description?,provider?,jta-datasource?,\n+  non-jta-datasource?,(class|jar-file|mapping-file)*,\n+  exclude-unlisted-classes?,properties?)&gt;\n+&lt;!ATTLIST persistence-unit name CDATA #REQUIRED&gt;\n+&lt;!ATTLIST persistence-unit transaction-type (JTA|RESOURCE_LOCAL) \"JTA\"&gt;\n+&lt;!ELEMENT description (#PCDATA)&gt;\n+&lt;!ELEMENT provider (#PCDATA)&gt;\n+&lt;!ELEMENT jta-datasource (#PCDATA)&gt;\n+&lt;!ELEMENT non-jta-datasource (#PCDATA)&gt;\n+&lt;!ELEMENT mapping-file (#PCDATA)&gt;\n+&lt;!ELEMENT jar-file (#PCDATA)&gt;\n+&lt;!ELEMENT class (#PCDATA)&gt;\n+&lt;!ELEMENT exclude-unlisted-classes EMPTY&gt;\n+&lt;!ELEMENT properties (property*)&gt;\n+&lt;!ELEMENT property EMPTY&gt;\n+&lt;!ATTLIST property name CDATA #REQUIRED&gt;\n+&lt;!ATTLIST property value CDATA #REQUIRED&gt;\n+</programlisting>\n+        <para>\n+    The root element of a <filename>persistence.xml</filename> file is\n+    <literal>persistence</literal>, which then contains one or more\n+    <literal>persistence-unit</literal> definitions. \n+    Each persistence unit describes the configuration for the entity\n+    managers created by the persistence unit's entity manager factory. \n+    The persistence unit can specify these elements and attribtues.\n+    </para>\n+        <itemizedlist>\n+          <listitem>\n+            <para><literal>name</literal>: This is the name you pass to the\n+        <methodname>Persistence.createEntityManagerFactory</methodname>\n+        methods described above. The name attribute is required.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><literal>transaction-type</literal>: Whether to use managed\n+        (<literal>JTA</literal>) or local \n+        (<literal>RESOURCE_LOCAL</literal>) transaction management.\n+        Defaults to <literal>JTA</literal>.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><literal>provider</literal>: If you are using a third-party\n+        JPA vendor, this element names its implementation of the \n+        <ulink url=\"http://java.sun.com/javaee/5/docs/api/javax/persistence/spi/PersistenceProvider.html\"><classname>PersistenceProvider</classname></ulink> bootstrapping\n+        interface. \n+        </para>\n+            <note>\n+              <para>\n+          Set the <literal>provider</literal> to <classname>\n+          org.apache.openjpa.persistence.PersistenceProviderImpl</classname>\n+          to use OpenJPA. \n+          </para>\n+            </note>\n+          </listitem>\n+          <listitem>\n+            <para><literal>jta-data-source</literal>: The JNDI name of a JDBC\n+        <classname>DataSource</classname> that is automatically enlisted\n+        in JTA transactions.  This may be an XA <classname>\n+        DataSource</classname>.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><literal>non-jta-data-source</literal>: The JNDI name of a JDBC\n+        <classname>DataSource</classname> that is not enlisted\n+        in JTA transactions.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><literal>mapping-file</literal>*: The resource names of\n+        XML mapping files for entities and embeddable classes.\n+        You can also specify mapping information in an <filename>\n+        orm.xml</filename> file in your <filename>META-INF</filename>\n+        directory. If present, the <filename>orm.xml</filename>\n+        mapping file will be read automatically.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><literal>jar-file</literal>*: The names of jar files containing\n+        entities and embeddable classes.  The implementation will scan\n+        the jar for annotated classes.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><literal>class</literal>*: The class names of entities and\n+        embeddable classes.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><literal>properties</literal>: This element contains nested\n+        <literal>property</literal> elements used to specify \n+        vendor-specific settings.  Each <literal>property</literal>\n+        has a name attribute and a value attribute.\n+        </para>\n+            <note>\n+              <para>\n+          The Reference Guide's <xref linkend=\"ref_guide_conf\"/>\n+          describes OpenJPA's configuration properties.\n+          </para>\n+            </note>\n+          </listitem>\n+        </itemizedlist>\n+        <para>\n+    Here is a typical <filename>persistence.xml</filename> file for a\n+    non-EE environment:\n+    </para>\n+        <example id=\"jpa_overview_persistence_xmlex\">\n+          <title>persistence.xml</title>\n+          <programlisting format=\"linespecific\">\n+&lt;?xml version=\"1.0\"?&gt;\n+&lt;persistence&gt;\n+  &lt;persistence-unit name=\"openjpa\"&gt;\n+    &lt;provider&gt;org.apache.openjpa.persistence.PersistenceProviderImpl&lt;/provider&gt;\n+    &lt;class&gt;tutorial.Animal&lt;/class&gt;\n+    &lt;class&gt;tutorial.Dog&lt;/class&gt;\n+    &lt;class&gt;tutorial.Rabbit&lt;/class&gt;\n+    &lt;class&gt;tutorial.Snake&lt;/class&gt;\n+    &lt;properties&gt;\n+      &lt;property name=\"openjpa.ConnectionURL\" value=\"jdbc:hsqldb:tutorial_database\"/&gt;\n+      &lt;property name=\"openjpa.ConnectionDriverName\" value=\"org.hsqldb.jdbcDriver\"/&gt;\n+      &lt;property name=\"openjpa.ConnectionUserName\" value=\"sa\"/&gt;\n+      &lt;property name=\"openjpa.ConnectionPassword\" value=\"\"/&gt;\n+      &lt;property name=\"openjpa.Log\" value=\"DefaultLevel=WARN, Tool=INFO\"/&gt;\n+    &lt;/properties&gt;\n+  &lt;/persistence-unit&gt;\n+&lt;/persistence&gt;\n+</programlisting>\n+        </example>\n+      </section>\n+      <section id=\"jpa_overview_persistence_use\">\n+        <title>Non-EE Use</title>\n+        <para>\n+    The example below demonstrates the <classname>Persistence</classname>\n+    class in action.  You will typically execute code like this on \n+    application startup, then cache the resulting factory for future use.\n+    This bootstrapping code is only necessary in non-EE environments; in \n+    an EE environment <classname>EntityManagerFactories</classname> are \n+    typically injected.  \n+    </para>\n+        <example id=\"jpa_overview_persistence_getemfactory\">\n+          <title>Obtaining an EntityManagerFactory</title>\n+          <programlisting format=\"linespecific\">\n+// if your persistence.xml file does not contain all settings already, you\n+// can add vendor settings to a map \n+Properties props = new Properties ();\n+...\n+\n+// create the factory defined by the \"openjpa\" entity-manager entry\n+EntityManagerFactory emf = Persistence.createEntityManagerFactory (\"openjpa\", props);\n+</programlisting>\n+        </example>\n+      </section>\n+    </chapter>"},{"sha":"e212749484ec4aa7e90c492611634f4850818aa4","filename":"openjpa-project/src/doc/manual/jpa_overview_query.xml","status":"added","additions":2587,"deletions":0,"changes":2587,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_query.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_query.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_overview_query.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53"},{"sha":"5c3105c02acd8957b498050e4efa55c4c5a2dd7d","filename":"openjpa-project/src/doc/manual/jpa_overview_sqlquery.xml","status":"added","additions":338,"deletions":0,"changes":338,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_sqlquery.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_sqlquery.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_overview_sqlquery.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,338 @@\n+\n+    <chapter id=\"jpa_overview_sqlquery\">\n+      <title>SQL Queries</title>\n+      <indexterm zone=\"jpa_overview_sqlquery\">\n+        <primary>SQL queries</primary>\n+        <seealso>Query</seealso>\n+      </indexterm>\n+      <indexterm>\n+        <primary>Query</primary>\n+        <secondary>SQL</secondary>\n+        <see>SQL queries</see>\n+      </indexterm>\n+      <indexterm>\n+        <primary>SQL</primary>\n+        <secondary>queries</secondary>\n+        <see>SQL queries</see>\n+      </indexterm>\n+      <indexterm>\n+        <primary>Native</primary>\n+        <secondary>queries</secondary>\n+        <see>SQL queries</see>\n+      </indexterm>\n+      <para>\n+  JPQL is a powerful query language, but there are times when it is \n+  not enough.  Maybe you're migrating a JDBC application to JPA\n+  on a strict deadline, and you don't have time to translate your existing \n+  SQL selects to JPQL.  Or maybe a certain query requires\n+  database-specific SQL your JPA implementation doesn't support.  \n+  Or maybe your DBA has spent hours crafting the perfect select statement \n+  for a query in your application's critical path.  Whatever the reason, SQL \n+  queries can remain an essential part of an application.\n+  </para>\n+      <para>\n+  You are probably familiar with executing SQL queries by obtaining a \n+  <classname>java.sql.Connection</classname>, using the JDBC APIs to create\n+  a <classname>Statement</classname>, and executing that <classname>Statement\n+  </classname> to obtain a <classname>ResultSet</classname>.  And of course, \n+  you are free to continue using this low-level approach to SQL execution in \n+  your JPA applications.  However, JPA also supports executing SQL queries \n+  through the <classname>javax.persistence.Query</classname>\n+  interface introduced in <xref linkend=\"jpa_overview_query\"/>.\n+  Using a JPA SQL query, you can retrieve either persistent objects\n+  or projections of column values.  The following sections detail each use.\n+  </para>\n+      <section id=\"jpa_overview_sqlquery_create\">\n+        <title>Creating SQL Queries</title>\n+        <indexterm zone=\"jpa_overview_sqlquery_create\">\n+          <primary>SQL queries</primary>\n+          <secondary>creating</secondary>\n+        </indexterm>\n+        <para>\n+    The <classname>EntityManager</classname> has two factory methods\n+    suitable for creating SQL queries:\n+    </para>\n+        <programlisting format=\"linespecific\">\n+public Query createNativeQuery (String sqlString, Class resultClass);\n+public Query createNativeQuery (String sqlString, String resultSetMapping);\n+</programlisting>\n+        <para>\n+    The first method is used to create a new <classname>Query</classname> \n+    instance that will return instances of the specified class.\n+    </para>\n+        <para>\n+    The second method uses a <literal>SqlResultSetMapping</literal>\n+    to determine the type of object or objects to return.\n+    The example below shows these methods in action.\n+    </para>\n+        <example id=\"jpa_overview_sqlquery_createex\">\n+          <title>Creating a SQL Query</title>\n+          <programlisting format=\"linespecific\">\n+EntityManager em = ...;\n+Query query = em.createNativeQuery (\"SELECT * FROM MAG\", Magazine.class);\n+processMagazines (query.getResultList ());\n+</programlisting>\n+        </example>\n+        <note>\n+          <para><indexterm><primary>SQL queries</primary><secondary>stored procedures</secondary></indexterm><indexterm><primary>stored procedures</primary><secondary>as queries</secondary><seealso>Query</seealso></indexterm>\n+      In addition to SELECT statements, OpenJPA supports stored procedure\n+      invocations as SQL queries.  OpenJPA will assume any SQL that does \n+      not begin with the <literal>SELECT</literal> keyword (ignoring\n+      case) is a stored procedure call, and invoke it as such at the\n+      JDBC level.\n+      </para>\n+        </note>\n+      </section>\n+      <section id=\"jpa_overview_sqlquery_obj\">\n+        <title>Retrieving Persistent Objects with SQL</title>\n+        <indexterm zone=\"jpa_overview_sqlquery_obj\">\n+          <primary>SQL queries</primary>\n+          <secondary>retrieving persistent objects</secondary>\n+        </indexterm>\n+        <indexterm zone=\"jpa_overview_sqlquery_obj\">\n+          <primary>persistent objects</primary>\n+          <secondary>retrieving with SQL</secondary>\n+          <seealso>SQL queries</seealso>\n+        </indexterm>\n+        <para>\n+    When you give a SQL <classname>Query</classname> a candidate class, it \n+    will return persistent instances of that class.  At a minimum, your \n+    SQL must select the \n+    class' primary key columns, discriminator column (if mapped), and\n+    version column (also if mapped).  The JPA runtime uses the values\n+    of the primary key columns to construct each result object's identity,\n+    and possibly to match it with a persistent object already in the \n+    <classname>EntityManager</classname>'s cache.  When an object is \n+    not already cached, the\n+    implementation creates a new object to represent the current result\n+    row.  It might use the discriminator column value to make sure it \n+    constructs an object of the correct subclass.  Finally, the query \n+    records available version column data for use in optimistic concurrency\n+    checking, should you later change the result object and flush it back \n+    to the database.\n+    </para>\n+        <para>\n+    Aside from the primary key, discriminator, and version columns, any \n+    columns you select are used to populate the persistent fields of each \n+    result object.  JPA implementations will compete on how effectively \n+    they map your selected data to your persistent instance fields.\n+    </para>\n+        <para>\n+    Let's make the discussion above concrete with an example.  It uses\n+    the following simple mapping between a class and the database:\n+    </para>\n+        <mediaobject>\n+          <imageobject>\n+<!-- PNG image data, 320 x 149 (see README) -->\n+            <imagedata fileref=\"img/sqlquery-featureSelection.png\" width=\"213px\"/>\n+          </imageobject>\n+        </mediaobject>\n+        <example id=\"jpa_overview_sqlquery_objex\">\n+          <title>Retrieving Persistent Objects</title>\n+          <programlisting format=\"linespecific\">\n+Query query = em.createNativeQuery (\"SELECT ISBN, TITLE, PRICE, \"\n+    + \"VERS FROM MAG WHERE PRICE &gt; 5 AND PRICE &lt; 10\", Magazine.class);\n+List&lt;Magazine&gt; results = query.getResultList ();\n+for (Magazine mag : results)\n+    processMagazine (mag);\n+</programlisting>\n+        </example>\n+        <para>\n+    The query above works as advertised, but isn't very flexible.  Let's\n+    update it to take in parameters for the minimum and maximum price, \n+    so we can reuse it to find magazines in any price range:\n+    </para>\n+        <example id=\"jpa_overview_sqlquery_obj_paramex\">\n+          <title>SQL Query Parameters</title>\n+          <programlisting format=\"linespecific\">\n+Query query = em.createNativeQuery (\"SELECT ISBN, TITLE, PRICE, \"\n+    + \"VERS FROM MAG WHERE PRICE &gt; ?1 AND PRICE &lt; ?2\", Magazine.class);\n+\n+query.setParameter (1, 5d);\n+query.setParameter (2, 10d);\n+\n+List&lt;Magazine&gt; results = query.getResultList ();\n+for (Magazine mag : results)\n+    processMagazine (mag);\n+</programlisting>\n+        </example>\n+        <para><indexterm><primary>SQL queries</primary><secondary>parameters</secondary></indexterm><indexterm><primary>parameters</primary><secondary>in SQL queries</secondary><seealso>SQL queries</seealso></indexterm>\n+    Like JDBC prepared statements, SQL queries represent parameters with\n+    question marks, but are followed by an integer to represent its\n+    index.\n+    </para>\n+      </section>\n+<!--\n+  <section id=\"jpa_overview_sqlquery_proj\">\n+    <title>SQL Projections</title>\n+    <indexterm zone=\"jpa_overview_sqlquery_proj\">\n+      <primary>SQL queries</primary>\n+      <secondary>projections</secondary>\n+    </indexterm>\n+    <indexterm zone=\"jpa_overview_sqlquery_proj\">\n+      <primary>projections</primary>\n+      <secondary>of column data</secondary>\n+      <seealso>SQL queries</seealso>\n+    </indexterm>\n+    <para>\n+    SQL queries without a candidate class are treated as projections of\n+    column data.  If you select a single column, the query returns\n+    a list of <classname>Object</classname>s.  If you select multiple\n+    columns, it returns a list of <classname>Object[]</classname>s.\n+    In either case, each column value is obtained using the \n+    <methodname>java.sql.ResultSet.getObject</methodname> method.  The \n+    following example demonstrates a query for the values of the \n+    <literal>ISBN</literal> and <literal>VERS</literal> columns of all \n+    <literal>MAG</literal> table records, using the data featureSelection we \n+    defined in <xref linkend=\"jpa_overview_sqlquery_obj\"/>.\n+    </para>\n+    <example id=\"jpa_overview_sqlquery_projex\">\n+      <title>Column Projection</title>\n+<programlisting>\n+Query query = em.newQuery (\"javax.persistence.query.SQL\", \n+    \"SELECT ISBN, VERS FROM MAG\");\n+List results = query.getResultList ();\n+for (Iterator itr = results.iterator (); itr.hasNext ();)\n+{\n+    Object[] data = (Object[]) results.next ();\n+    processISBNAndVersion (data[0], data[1]);\n+}\n+</programlisting>\n+      <para>\n+      Notice that in the code above, we did not set a candidate class. \n+      Therefore, the query is treated as a projection.\n+      </para>\n+    </example>\n+    <para>\n+    <indexterm>\n+      <primary>SQL queries</primary>\n+      <secondary>result class</secondary>\n+    </indexterm>\n+    Our discussion of JPQL query result classes in \n+    <xref linkend=\"jpa_overview_query_resultcls\"/> also \n+    applies to SQL queries.  As with JPQL queries, SQL queries can \n+    automatically pack their results into objects of a specified type.  \n+    JPA uses the <methodname>java.sql.ResultSetMetaData.getColumnLabel\n+    </methodname> method to match each column alias to the result class' \n+    public fields and JavaBean setter methods.  Here is a modification of \n+    our example above that packs the selected column values into JavaBean\n+    instances.\n+    </para>\n+    <example id=\"jpa_overview_sqlquery_proj_labelex\">\n+      <title>Result Class</title>\n+<programlisting>\n+public class Identity\n+{\n+    private String id;\n+    private int versionNumber;\n+\n+    public void setId (String id)\n+    {\n+        this.id = id;\n+    }\n+\n+    public String getId ()\n+    {\n+        return id;\n+    }\n+\n+    public void setVersionNumber (int versionNumber)\n+    {\n+        this.versionNumber = versionNumber;\n+    }\n+ \n+    public int getVersionNumber ()\n+    {\n+        return versionNumber;\n+    }\n+}\n+\n+Query query = em.createNativeQuery (\"javax.persistence.query.SQL\", \n+    \"SELECT ISBN AS id, VERS AS versionNumber FROM MAG\", Identity.class);\n+List results = query.getResultList ();\n+for (Iterator itr = results.iterator (); itr.hasNext ();)\n+    processIdentity ((Identity) itr.next ());\n+</programlisting>\n+    </example>\n+  </section>\n+  <section id=\"jpa_overview_sqlquery_named\">\n+    <title>Named SQL Queries</title>\n+    <indexterm zone=\"jpa_overview_sqlquery_named\">\n+      <primary>SQL queries</primary>\n+      <secondary>named</secondary>\n+      <see>named queries</see>\n+    </indexterm>\n+    <indexterm zone=\"jpa_overview_sqlquery_named\">\n+      <primary>named queries</primary>\n+      <secondary>SQL</secondary>\n+    </indexterm>\n+    <para>\n+    We discussed how to write named JPQL queries in\n+    <xref linkend=\"jpa_overview_query_named\"/>.  Named queries, however,\n+    are not limited to JPQL.  By setting the <literal>query</literal>\n+    element's <literal>language</literal> attribute to <literal>\n+    javax.persistence.query.SQL</literal>, you can define a named SQL query.  A \n+    named SQL query within a <literal>class</literal> element queries for\n+    instances of that class; a named SQL query outside of a <literal>class\n+    </literal> element acts as a column data projection.  \n+    </para>\n+    <example id=\"jpa_overview_sqlquery_namedex\">\n+      <title>Named SQL Queries</title>\n+<programlisting>\n+<![CDATA[<?xml version=\"1.0\"?>\n+<jdoquery>\n+    <query name=\"salesReport\" language=\"javax.persistence.query.SQL\">\n+        SELECT TITLE, PRICE * COPIES FROM MAG\n+    </query>\n+    <package name=\"org.mag\">\n+        <class name=\"Magazine\">\n+            <query name=\"findByTitle\" language=\"javax.persistence.query.SQL\">\n+                SELECT * FROM MAG WHERE TITLE = ?\n+            </query>\n+        </class>\n+    </package>\n+</jdoquery>]]>\n+</programlisting>\n+      <para>\n+      The <literal>salesReport</literal> query above returns the title\n+      and revenue generated for each <classname>Magazine</classname>.\n+      Because it is a projection, it does not have a candidate class, and\n+      so we specify it at the root level.\n+      </para>\n+      <para>\n+      The <literal>findByTitle</literal> query returns the <classname>\n+      Magazine</classname> with the title given on execution.  The code \n+      below executes both queries.\n+      </para>\n+<programlisting>\n+EntityManager em = ...;\n+Query query = em.newNamedQuery (null, \"salesReport\");\n+List sales = query.getResultList ();\n+for (Iterator itr = sales.iterator (); itr.hasNext ();)\n+{\n+    Object[] salesData = (Object[]) itr.next ();\n+    processSalesData ((String) salesData[0], (Number) salesData[1]);\n+}\n+\n+query = em.newNamedQuery (Magazine.class, \"findByTitle\");\n+query.setUnique (true);\n+Magazine jdj = (Magazine) query.execute (\"JDJ\"); \n+</programlisting>\n+    </example>\n+  </section>\n+  <section id=\"jpa_overview_sqlquery_conclusion\">\n+    <title>Conclusion</title>\n+    <para>\n+    If you've used relational databases extensively, you might be tempted\n+    to perform all your JPA queries with SQL.  Try to resist this \n+    temptation.  SQL queries tie your application to the particulars of\n+    your current table featureSelection and database vendor.  If you stick with JPQL,\n+    on the other hand, you can port your application to other schemas and \n+    database vendors without any changes to your code.  Additionally,\n+    most JPA implementations already produce highly optimized SQL from\n+    your JPQL filters, and many are able to cache JPQL query results\n+    for added performance. \n+    </para>\n+  </section>\n+  -->\n+    </chapter>"},{"sha":"3c7f38737abb8f99467877c79eaa0e764007af39","filename":"openjpa-project/src/doc/manual/jpa_overview_trans.xml","status":"added","additions":234,"deletions":0,"changes":234,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_trans.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_trans.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_overview_trans.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,234 @@\n+\n+    <chapter id=\"jpa_overview_trans\">\n+      <title>Transaction</title>\n+      <indexterm zone=\"jpa_overview_trans\">\n+        <primary>transactions</primary>\n+        <seealso>Transaction</seealso>\n+      </indexterm>\n+      <para>\n+  Transactions are critical to maintaining data integrity.  They are \n+  used to group operations into units of work that act in an \n+  all-or-nothing fashion.  Transactions have the following qualities:\n+  </para>\n+      <itemizedlist>\n+        <listitem>\n+          <para><indexterm><primary>atomicity</primary><seealso>transactions</seealso></indexterm><indexterm><primary>transactions</primary><secondary>atomicity</secondary></indexterm><emphasis>Atomicity</emphasis>.  Atomicity refers to the\n+      all-or-nothing property of transactions.  Either every \n+      data update in the transaction completes successfully, or they\n+      all fail, leaving the datastore in its original state.  A\n+      transaction cannot be only partially successful.\n+      </para>\n+        </listitem>\n+        <listitem>\n+          <para><indexterm><primary>consistency</primary><seealso>transactions</seealso></indexterm><indexterm><primary>transactions</primary><secondary>consistency</secondary></indexterm><emphasis>Consistency</emphasis>.  Each transaction takes the\n+      datastore from one consistent state to another consistent\n+      state.  \n+      </para>\n+        </listitem>\n+        <listitem>\n+          <para><indexterm><primary>isolation</primary><seealso>transactions</seealso></indexterm><indexterm><primary>transactions</primary><secondary>isolation</secondary></indexterm><emphasis>Isolation</emphasis>.  Transactions are isolated from\n+      each other.  When you are reading persistent data in one\n+      transaction, you cannot \"see\" the changes that are being made\n+      to that data in other transactions.  Similarly,\n+      the updates you make in one transaction cannot conflict with\n+      updates made in concurrent transactions.  The form of\n+      conflict resolution employed depends on whether you are using\n+      pessimistic or optimistic transactions.  Both types are\n+      described later in this chapter.\n+      </para>\n+        </listitem>\n+        <listitem>\n+          <para><indexterm><primary>durability</primary><seealso>transactions</seealso></indexterm><indexterm><primary>transactions</primary><secondary>durability</secondary></indexterm><emphasis>Durability</emphasis>.  The effects of successful\n+      transactions are durable; the updates made to persistent data\n+      last for the lifetime of the datastore.\n+      </para>\n+        </listitem>\n+      </itemizedlist>\n+      <para><indexterm><primary>ACID</primary><seealso>transactions</seealso></indexterm><indexterm><primary>transactions</primary><secondary>ACID</secondary></indexterm>\n+  Together, these qualities are called the ACID properties of\n+  transactions.  To understand why these properties are so important\n+  to maintaining data integrity, consider the following example:\n+  </para>\n+      <para>\n+  Suppose you create an application to manage bank accounts.  The \n+  application includes a method to transfer funds from one user to\n+  another, and it looks something like this:\n+  </para>\n+      <programlisting format=\"linespecific\">\n+public void transferFunds (User from, User to, double amnt)\n+{\n+    from.decrementAccount (amnt);\n+    to.incrementAccount (amnt);\n+}\n+</programlisting>\n+      <para>\n+  Now suppose that user Alice wants to transfer 100 dollars to user Bob.\n+  No problem; you simply invoke your \n+  <methodname>transferFunds</methodname> method, supplying Alice in the\n+  <literal>from</literal> parameter, Bob in the <literal>to</literal>\n+  parameter, and <literal>100.00</literal> as the <literal>amnt</literal>.\n+  The first line of the method is executed, and 100 dollars is subtracted\n+  from Alice's account.  But then, something goes wrong.  An unexpected\n+  exception occurs, or the hardware fails, and your method never\n+  completes.\n+  </para>\n+      <para>\n+  You are left with a situation in which the 100 dollars has simply \n+  disappeared.  Thanks to the first line of your method, it is no longer\n+  in Alice's account, and yet it was never transferred to Bob's account \n+  either.  The datastore is in an inconsistent state.\n+  </para>\n+      <para>\n+  The importance of transactions should now be clear.  If the two lines\n+  of the <methodname>transferFunds</methodname> method had been placed \n+  together in a transaction, it would be impossible for only the\n+  first line to succeed.  Either the funds would be transferred \n+  properly or they would not be transferred at all, and an exception\n+  would be thrown.  Money could never vanish into thin air, and the data \n+  store could never get into an inconsistent state.  \n+  </para>\n+      <section id=\"jpa_overview_trans_types\">\n+        <title>Transaction Types</title>\n+        <indexterm zone=\"jpa_overview_trans_types\">\n+          <primary>transactions</primary>\n+          <secondary>types</secondary>\n+        </indexterm>\n+        <para>\n+    There are two major types of transactions: pessimistic transactions \n+    and optimistic transactions.  Each type has both advantages and \n+    disadvantages.\n+    </para>\n+        <para><indexterm><primary>transactions</primary><secondary>pessimistic</secondary></indexterm><indexterm><primary>pessimistic transactions</primary><see>transactions, pessimistic</see></indexterm><indexterm><primary>deadlock</primary><seealso>transactions</seealso></indexterm>\n+    Pessimistic transactions generally lock the datastore records they\n+    act on, preventing other concurrent transactions from using the\n+    same data.  This avoids conflicts between transactions, but \n+    consumes database resources.  Additionally, locking records\n+    can result in <emphasis>deadlock</emphasis>, a situation in which two \n+    transactions are both waiting for the other to release its locks before\n+    completing.  The results of a deadlock are datastore-dependent; \n+    usually one transaction is forcefully rolled back after some specified \n+    timeout interval, and an exception is thrown.\n+    </para>\n+        <para><indexterm><primary>transactions</primary><secondary>datastore</secondary></indexterm><indexterm><primary>datastore transactions</primary><see>transactions, datastore</see></indexterm>\n+    This document will often use the term <emphasis>datastore</emphasis>\n+    transaction in place of <emphasis>pessimistic</emphasis> transaction.\n+    This is to acknowledge that some datastores do not support pessimistic \n+    semantics, and that the exact meaning of a non-optimistic JPA \n+    transaction is dependent on the datastore.  Most of the \n+    time, a datastore transaction is equivalent to a pessimistic \n+    transaction.  \n+    </para>\n+        <para><indexterm><primary>transactions</primary><secondary>optimistic</secondary></indexterm><indexterm><primary>optimistic transactions</primary><see>transactions, optimistic</see></indexterm>\n+    Optimistic transactions consume less resources than\n+    pessimistic/datastore transactions, but only at the expense of \n+    reliability.  Because optimistic transactions do not lock datastore \n+    records, two transactions might change the same persistent information\n+    at the same time, and the conflict will not be detected until\n+    the second transaction attempts to flush or commit.  At this time, the\n+    second transaction will realize that another transaction has \n+    concurrently modified the same records (usually through a timestamp\n+    or versioning system), and will throw an appropriate exception.\n+    Note that optimistic transactions still maintain data integrity;\n+    they are simply more likely to fail in heavily concurrent \n+    situations.\n+    </para>\n+        <para>\n+    Despite their drawbacks, optimistic transactions are the best choice\n+    for most applications.  They offer better performance, better\n+    scalability, and lower risk of hanging due to deadlock.  \n+    </para>\n+        <note>\n+          <para>\n+      OpenJPA uses optimistic semantics by default, but supports both \n+      optimistic and datastore transactions.\n+      OpenJPA also offers advanced locking and versioning APIs for \n+      fine-grained control over database resource allocation and object \n+      versioning.  See <xref linkend=\"ref_guide_locking\"/> and\n+      <xref linkend=\"ref_guide_lock_groups\"/> of the Reference Guide for \n+      details on locking.  <xref linkend=\"jpa_overview_meta_version\"/>\n+      of this document covers standard object versioning.\n+      <!-- ### EJBDOC : link additional strats when available from JPA -->\n+      </para>\n+        </note>\n+      </section>\n+      <section id=\"jpa_overview_trans_ejb3\">\n+        <title>The EntityTransaction Interface</title>\n+        <indexterm zone=\"jpa_overview_trans_ejb3\">\n+          <primary>Transaction</primary>\n+          <seealso>transactions</seealso>\n+        </indexterm>\n+        <mediaobject>\n+          <imageobject>\n+<!-- PNG image data, 193 x 157 (see README) -->\n+            <imagedata fileref=\"img/jpa-transaction.png\" width=\"129px\"/>\n+          </imageobject>\n+        </mediaobject>\n+        <para>\n+    JPA integrates with your container's <emphasis>managed\n+    </emphasis> transactions, allowing you to use the container's \n+    declarative transaction demarcation and its Java Transaction API (JTA) \n+    implementation for transaction management.  \n+    Outside of a container, though, you must demarcate transactions\n+    manually through JPA.  The <classname>\n+    EntityTransaction</classname> interface controls unmanaged transactions\n+    in JPA.  \n+    </para>\n+        <programlisting format=\"linespecific\">\n+public void begin ();\n+public void commit ();\n+public void rollback ();\n+</programlisting>\n+        <para><indexterm><primary>Transaction</primary><secondary>demarcation</secondary></indexterm><indexterm><primary>transactions</primary><secondary>demarcating</secondary></indexterm><indexterm><primary>Transaction</primary><secondary>begin</secondary></indexterm><indexterm><primary>Transaction</primary><secondary>commit</secondary></indexterm><indexterm><primary>Transaction</primary><secondary>rollback</secondary></indexterm>\n+    The <methodname>begin</methodname>, <methodname>commit</methodname>,\n+    and <methodname>rollback</methodname> methods demarcate transaction\n+    boundaries.  The methods should be self-explanatory: \n+    <methodname>begin</methodname> starts a transaction, \n+    <methodname>commit</methodname> attempts to commit the transaction's\n+    changes to the datastore, and <methodname>rollback</methodname>\n+    aborts the transaction, in which case the datastore is \n+    \"rolled back\" to its previous state.  JPA \n+    implementations will automatically roll back transactions if any \n+    exception is thrown during the commit process.\n+    </para>\n+        <para>\n+    Unless you are using an extended persistence context, committing or\n+    rolling back also ends the persistence context.  All managed entites\n+    will be detached from the <classname>EntityManager</classname>.\n+    </para>\n+        <programlisting format=\"linespecific\">\n+public boolean isActive ();\n+</programlisting>\n+        <para><indexterm><primary>Transaction</primary><secondary>isActive</secondary></indexterm>\n+    Finally, the <methodname>isActive</methodname> method returns \n+    <literal>true</literal> if the transaction is in progress \n+    (<methodname>begin</methodname> has been called more recently than \n+    <methodname>commit</methodname> or \n+    <methodname>rollback</methodname>), and <literal>false</literal> \n+    otherwise.\n+    </para>\n+        <example id=\"jpa_overview_trans_group\">\n+          <title>Grouping Operations with Transactions</title>\n+          <programlisting format=\"linespecific\">\n+public void transferFunds (EntityManager em, User from, User to, double amnt)\n+{\n+    // note: it would be better practice to move the transaction demarcation\n+    // code out of this method, but for the purposes of example...\n+    Transaction trans = em.getTransaction ();\n+    trans.begin ();\n+    try\n+    {\n+        from.decrementAccount (amnt);\n+        to.incrementAccount (amnt);\n+        trans.commit ();\n+    }\n+    catch (RuntimeException re)\n+    {\n+        if (trans.isActive ())\n+            trans.rollback ();   // or could attempt to fix error and retry\n+        throw re;\n+    }\n+}\n+</programlisting>\n+        </example>\n+      </section>\n+    </chapter>"},{"sha":"ef3212985bc063a8f397d0bec591beecffe57dcf","filename":"openjpa-project/src/doc/manual/jpa_overview_why.xml","status":"added","additions":371,"deletions":0,"changes":371,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_why.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_overview_why.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_overview_why.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,371 @@\n+\n+    <chapter id=\"jpa_overview_why\">\n+      <title>Why JPA?</title>\n+      <indexterm zone=\"jpa_overview_why\">\n+        <primary>JPA</primary>\n+        <secondary>why</secondary>\n+      </indexterm>\n+      <para>\n+  Java developers who need to store and retrieve persistent \n+  data already have several options available to them:\n+  serialization, JDBC, JDO, proprietary object-relational mapping tools, \n+  object databases, and EJB 2 entity beans.  Why introduce yet   \n+  another persistence framework?  The answer to this question is that with\n+  the exception of JDO, each of the aforementioned persistence solutions\n+  has severe limitations.  JPA attempts to overcome these\n+  limitations, as illustrated by the table below.\n+  </para>\n+      <table tocentry=\"1\">\n+        <title>Persistence Mechanisms</title>\n+        <tgroup cols=\"8\" align=\"left\" colsep=\"1\" rowsep=\"1\">\n+          <colspec colname=\"sup\"/>\n+          <colspec colname=\"ser\"/>\n+          <colspec colname=\"jdbc\"/>\n+          <colspec colname=\"or\"/>\n+          <colspec colname=\"objdb\"/>\n+          <colspec colname=\"ejb2\"/>\n+          <colspec colname=\"jdo\"/>\n+          <colspec colname=\"ejb3\"/>\n+          <thead>\n+            <row>\n+              <entry colname=\"sup\">Supports:</entry>\n+              <entry colname=\"ser\">Serialization</entry>\n+              <entry colname=\"jdbc\">JDBC</entry>\n+              <entry colname=\"or\">ORM</entry>\n+              <entry colname=\"objdb\">ODB</entry>\n+              <entry colname=\"ejb2\">EJB 2</entry>\n+              <entry colname=\"jdo\">JDO</entry>\n+              <entry colname=\"ejb3\">JPA</entry>\n+            </row>\n+          </thead>\n+          <tbody>\n+            <row>\n+              <entry colname=\"sup\">Java Objects</entry>\n+              <entry colname=\"ser\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"jdbc\">No</entry>\n+              <entry colname=\"or\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"objdb\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"ejb2\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"jdo\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"ejb3\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"sup\">Advanced OO Concepts</entry>\n+              <entry colname=\"ser\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"jdbc\">No</entry>\n+              <entry colname=\"or\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"objdb\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"ejb2\">No</entry>\n+              <entry colname=\"jdo\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"ejb3\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"sup\">Transactional Integrity</entry>\n+              <entry colname=\"ser\">No</entry>\n+              <entry colname=\"jdbc\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"or\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"objdb\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"ejb2\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"jdo\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"ejb3\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"sup\">Concurrency</entry>\n+              <entry colname=\"ser\">No</entry>\n+              <entry colname=\"jdbc\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"or\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"objdb\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"ejb2\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"jdo\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"ejb3\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"sup\">Large Data Sets</entry>\n+              <entry colname=\"ser\">No</entry>\n+              <entry colname=\"jdbc\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"or\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"objdb\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"ejb2\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"jdo\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"ejb3\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"sup\">Existing Schema</entry>\n+              <entry colname=\"ser\">No</entry>\n+              <entry colname=\"jdbc\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"or\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"objdb\">No</entry>\n+              <entry colname=\"ejb2\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"jdo\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"ejb3\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"sup\">\n+            Relational and Non-Relational Stores\n+          </entry>\n+              <entry colname=\"ser\">No</entry>\n+              <entry colname=\"jdbc\">No</entry>\n+              <entry colname=\"or\">No</entry>\n+              <entry colname=\"objdb\">No</entry>\n+              <entry colname=\"ejb2\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"jdo\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"ejb3\">No</entry>\n+            </row>\n+            <row>\n+              <entry colname=\"sup\">Queries</entry>\n+              <entry colname=\"ser\">No</entry>\n+              <entry colname=\"jdbc\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"or\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"objdb\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"ejb2\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"jdo\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"ejb3\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"sup\">Strict Standards / Portability</entry>\n+              <entry colname=\"ser\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"jdbc\">No</entry>\n+              <entry colname=\"or\">No</entry>\n+              <entry colname=\"objdb\">No</entry>\n+              <entry colname=\"ejb2\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"jdo\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"ejb3\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"sup\">Simplicity</entry>\n+              <entry colname=\"ser\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"jdbc\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"or\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"objdb\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"ejb2\">No</entry>\n+              <entry colname=\"jdo\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+              <entry colname=\"ejb3\">\n+                <emphasis role=\"bold\">Yes</emphasis>\n+              </entry>\n+            </row>\n+          </tbody>\n+        </tgroup>\n+      </table>\n+      <itemizedlist>\n+        <listitem>\n+          <para><indexterm><primary>serialization</primary></indexterm><indexterm><primary>JPA</primary><secondary>vs serialization</secondary></indexterm><emphasis>Serialization</emphasis> is Java's \n+      built-in mechanism for transforming an object graph into a\n+      series of bytes, which can then be sent over the network or\n+      stored in a file.  Serialization is very easy to use, \n+      but it is also very limited.  It must store and retrieve the\n+      entire object graph at once, making it unsuitable for\n+      dealing with large amounts of data.  It cannot undo changes \n+      that are made to objects if an error occurs while updating\n+      information, making it unsuitable for applications that \n+      require strict data integrity.  Multiple threads or programs\n+      cannot read and write the same serialized data concurrently\n+      without conflicting with each other.  It provides no query\n+      capabilities.  All these factors make serialization useless \n+      for all but the most trivial persistence needs.\n+      </para>\n+        </listitem>\n+        <listitem>\n+          <para><indexterm><primary>Java Database Connectivity</primary><see>JDBC</see></indexterm><indexterm><primary>JDBC</primary></indexterm><indexterm><primary>JPA</primary><secondary>vs JDBC</secondary></indexterm>\n+      Many developers use the \n+      <emphasis>Java Database Connectivity</emphasis> (JDBC) APIs to\n+      manipulate persistent data in relational databases.  JDBC \n+      overcomes most of the shortcomings of serialization:\n+      it can handle large amounts of data, has mechanisms to ensure\n+      data integrity, supports concurrent access to information, and \n+      has a sophisticated query language in SQL.  Unfortunately, JDBC\n+      does not duplicate serialization's ease of use.  The relational\n+      paradigm used by JDBC was not designed for storing objects,\n+      and therefore forces you to either abandon\n+      object-oriented programming for the portions of your code \n+      that deal with persistent data, or to find a way of mapping \n+      object-oriented concepts like inheritance to relational \n+      databases yourself.  \n+      </para>\n+        </listitem>\n+        <listitem>\n+          <para><indexterm><primary>object-relational mapping</primary><see>ORM</see></indexterm><indexterm><primary>ORM</primary></indexterm><indexterm><primary>JPA</primary><secondary>vs ORM products</secondary></indexterm>\n+      There are many proprietary software products that can perform the\n+      mapping between objects and relational database tables for you.\n+      These <emphasis>object-relational mapping</emphasis> (ORM) \n+      frameworks allow you to focus on the object featureSelection and not concern\n+      yourself with the mismatch between \n+      the object-oriented and relational paradigms.  Unfortunately, \n+      each of these product has its own set of APIs.\n+      Your code becomes tied to the proprietary interfaces of a single\n+      vendor.  If the vendor raises prices, fails to fix show-stopping \n+      bugs, or falls behind in features, you cannot switch to another \n+      product without rewriting all of your persistence code.   This is \n+      referred to as vendor lock-in.\n+      </para>\n+        </listitem>\n+        <listitem>\n+          <para><indexterm><primary>object database</primary><see>ODB</see></indexterm><indexterm><primary>ODB</primary></indexterm><indexterm><primary>JPA</primary><secondary>vs ODBs</secondary></indexterm><indexterm><primary>ODBMG</primary></indexterm>\n+      Rather than map objects to relational databases, some software\n+      companies have developed a form of database designed \n+      specifically to store objects.  These\n+      <emphasis>object databases</emphasis> (ODBs) are often much\n+      easier to use than object-relational mapping software.\n+      The Object Database Management Group (ODMG) was formed to create\n+      a standard API for accessing object databases; few object\n+      database vendors, however, comply with the ODMG's \n+      recommendations.  Thus, vendor lock-in plagues object databases\n+      as well.  Many companies are also hesitant to switch from\n+      tried-and-true relational systems to the relatively unknown object\n+      database technology.  Fewer data-analysis tools are available\n+      for object database systems, and there are vast quantities of\n+      data already stored in older relational databases.  For all of\n+      these reasons and more, object databases have not caught on\n+      as well as their creators hoped.\n+      </para>\n+        </listitem>\n+        <listitem>\n+          <para><indexterm><primary>Enterprise Java Beans</primary><see>EJB</see></indexterm><indexterm><primary>EJB</primary></indexterm><indexterm><primary>JPA</primary><secondary>vs EJB 2</secondary></indexterm>\n+      The Enterprise Edition of the Java platform introduced entity\n+      Enterprise Java Beans (EJBs).  EJB 2.x entities are components that\n+      represent persistent information in a datastore.  Like \n+      object-relational mapping solutions, EJB 2.x entities provide\n+      an object-oriented view of persistent data.  Unlike \n+      object-relational software, however, EJB 2.x entities are not\n+      limited to relational databases; the persistent information they\n+      represent may come from an Enterprise Information System (EIS) or\n+      other storage device.  Also, EJB 2.x entities use a strict standard,\n+      making them portable across vendors.  Unfortunately, the EJB 2.x \n+      standard is somewhat limited in the object-oriented concepts it can \n+      represent.  Advanced features like inheritance, polymorphism, and \n+      complex relations are absent.  Additionally, EBJ 2.x entities are\n+      difficult to code, and they require heavyweight and often expensive\n+      application servers to run.\n+      </para>\n+        </listitem>\n+        <listitem>\n+          <para><indexterm><primary>JDO</primary></indexterm><indexterm><primary>JPA</primary><secondary>vs JDO</secondary></indexterm>\n+      The JDO specification uses an API that is strikingly similar to\n+      JPA.  JDO, however, supports non-relational databases, \n+      a feature that some argue dilutes the specification.\n+      </para>\n+        </listitem>\n+      </itemizedlist>\n+      <para><indexterm><primary>JPA</primary></indexterm>\n+  JPA combines the best features from each of the persistence \n+  mechanisms listed above.  Creating entities under JPA\n+  is as simple as creating serializable classes.  JPA supports the\n+  large data sets, data consistency, concurrent use, and query capabilities of\n+  JDBC.  Like object-relational software and object databases, JPA\n+  allows the use of advanced object-oriented concepts such as inheritance. \n+  JPA avoids vendor lock-in by relying on a strict specification\n+  like JDO and EJB 2.x entities.  JPA focuses on relational \n+  databases.  And like JDO, JPA is extremely easy to use.\n+  </para>\n+      <note>\n+        <para>\n+    OpenJPA typically stores data in relational databases, but can be \n+    customized for use with non-relational datastores as well.\n+    </para>\n+      </note>\n+      <para>\n+  JPA is not ideal for every application.  For many applications,\n+  though, it provides an exciting alternative to other persistence mechanisms.\n+  </para>\n+    </chapter>"},{"sha":"2a7e427c28cfb72f52a0f0a9a24215705f066dd8","filename":"openjpa-project/src/doc/manual/jpa_resources.xml","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_resources.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_resources.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_resources.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,39 @@\n+\n+  <appendix id=\"jpa_resources\">\n+    <title>JPA Resources</title>\n+    <itemizedlist>\n+      <listitem>\n+        <para>\n+          <ulink url=\"http://java.sun.com/aboutJava/communityprocess/jsr/jsr_220_dataobj.html\">\n+      EJB 3 JSR page</ulink>\n+        </para>\n+      </listitem>\n+      <listitem>\n+        <para>\n+          <ulink url=\"http://java.sun.com/products/ejb\">Sun EJB page</ulink>\n+        </para>\n+      </listitem>\n+      <listitem>\n+        <para>\n+          <ulink url=\"http://java.sun.com/javaee/5/docs/api/index.html\">Locally mirrored \n+      javax.persistence Javadoc</ulink>\n+        </para>\n+      </listitem>\n+      <listitem>\n+        <para>\n+          <ulink url=\"../../api/index.html\">OpenJPA API Javadoc</ulink>\n+        </para>\n+      </listitem>\n+      <listitem>\n+        <para>\n+          <ulink url=\"../apidocs/index.html\">Full OpenJPA Javadoc</ulink>\n+        </para>\n+      </listitem>\n+      <listitem>\n+        <para>\n+          <ulink url=\"Persistence.pdf\">Locally mirrored JPA\n+      specification</ulink>\n+        </para>\n+      </listitem>\n+    </itemizedlist>\n+  </appendix>"},{"sha":"b9fffb79366dd61276f56a8a91d4f939c8baa44f","filename":"openjpa-project/src/doc/manual/jpa_tutorials.xml","status":"added","additions":1704,"deletions":0,"changes":1704,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_tutorials.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/jpa_tutorials.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/jpa_tutorials.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,1704 @@\n+\n+    <chapter id=\"jpa_tutorials\">\n+      <title>JPA Tutorials</title>\n+      <section id=\"jpa_tutorials_intro\">\n+        <title>OpenJPA Tutorials</title>\n+        <para>\n+  These tutorials provide step-by-step examples of how to use various\n+  facets of the OpenJPA system. They assume a general knowledge \n+  of JPA and Java. For more information on these subjects, see\n+  the following URLs:\n+  </para>\n+        <itemizedlist>\n+          <listitem>\n+            <para>\n+              <ulink url=\"http://java.sun.com/\">Sun's Java site</ulink>\n+            </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+              <link linkend=\"jpa_overview_intro\">JPA Overview Document</link>\n+            </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+              <link linkend=\"jpa_resources\">Links to JPA</link>\n+            </para>\n+          </listitem>\n+        </itemizedlist>\n+        <section id=\"jpa_tutorial_requirements\">\n+          <title>Tutorial Requirements</title>\n+          <para>\n+    These tutorials require that JDK 1.5 or greater be installed\n+    on your computer, and that <literal>java</literal> and \n+    <literal>javac</literal> are in your <literal>PATH</literal> when \n+    you open a command shell.\n+    </para>\n+        </section>\n+      </section>\n+      <section id=\"jpa_tutorial\">\n+        <title>OpenJPA Tutorial</title>\n+        <para>\n+  In this tutorial you will become familiar with the basic tools and \n+  development processes under OpenJPA by creating a simple JPA application.\n+  </para>\n+        <section id=\"jpa_tutorial_chapter1\">\n+          <title>The Pet Shop</title>\n+          <para>\n+    Imagine that you have decided to create a software toolkit to be used \n+    by pet shop operators. This toolkit must provide a number of solutions \n+    to common problems encountered at pet shops. Industry analysts indicate\n+    that the three most desired features are inventory maintenance, \n+    inventory growth simulation, and behavioral analysis. Not one to \n+    question the sage advice of experts, you choose to attack these three\n+    problems first.\n+    </para>\n+          <para>\n+    According to the aforementioned experts, most pet shops focus on three \n+    types of animals only: dogs, rabbits, and snakes. This ontology \n+    suggests the following class hierarchy:\n+    </para>\n+          <para>\n+            <screen format=\"linespecific\">\n+                       Animal\n+                         ^\n+                         |\n+               +--------------------+\n+               |         |          |\n+              Dog      Rabbit     Snake\n+         </screen>\n+          </para>\n+          <section id=\"jpa_tutorial_files\">\n+            <title>Included Files</title>\n+            <para>\n+      We have provided an implementation of <classname>Animal</classname>\n+      and <classname>Dog</classname> classes, plus some helper classes \n+      and files to create the initial schema and populate the database \n+      with some sample dogs. Let's take a closer look at these classes.\n+      </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para><ulink url=\"../../../tutorial/persistence/AnimalMaintenance.java\"><classname>\n+          tutorial.persistence.AnimalMaintenance</classname></ulink>:\n+          Provides some utility methods for examining and \n+          manipulating the animals stored in the database. We will\n+          fill in method definitions in \n+          <xref linkend=\"jpa_tutorial_chapter3\"/>.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><ulink url=\"../../../tutorial/persistence/Animal.java\"><classname>tutorial.persistence.Animal</classname></ulink>:\n+          This is the superclass of all animals that this pet store \n+          software can handle.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><ulink url=\"../../../tutorial/persistence/Dog.java\"><classname>tutorial.persistence.Dog</classname></ulink>: \n+          Contains data and methods specific to dogs.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><ulink url=\"../../../tutorial/persistence/Rabbit.java\"><classname>tutorial.persistence.Rabbit</classname></ulink>: \n+          Contains data and \n+          methods specific to rabbits. It will be used in \n+          <xref linkend=\"jpa_tutorial_chapter4\"/>.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><ulink url=\"../../../tutorial/persistence/Snake.java\"><classname>tutorial.persistence.Snake</classname></ulink>: \n+          Contains data and \n+          methods specific to snakes. It will be used in \n+          <xref linkend=\"jpa_tutorial_chapter5\"/>.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><ulink url=\"../../../META-INF/persistence.xml\"><filename>../../META-INF/persistence.xml</filename></ulink>:\n+          This XML file contains OpenJPA-specific and standard JPA \n+          configuration settings.\n+          </para>\n+                <para>\n+          It is important to load all persistent entity classes at\n+          startup so that OpenJPA can match database discriminator values\n+          to entity classes.  Often this happens automatically.  \n+          Some parts of this tutorial, however, do require that all \n+          entity classes be loaded explicitly.  The JPA\n+          standard includes persistent class listings in its XML\n+          configuration format.  Add the following lines to <filename>\n+          ../../META-INF/persistence.xml</filename> between the\n+          <literal>&lt;provider&gt;</literal> and the\n+          <literal>&lt;properties&gt;</literal> elements:\n+          </para>\n+                <programlisting format=\"linespecific\">\n+&lt;class&gt;tutorial.persistence.Animal&lt;/class&gt;\n+&lt;class&gt;tutorial.persistence.Dog&lt;/class&gt;\n+</programlisting>\n+              </listitem>\n+              <listitem>\n+                <para><ulink url=\"../../../tutorial/persistence/solutions\"><filename>solutions</filename></ulink>: The solutions \n+          directory contains the complete solutions to this tutorial,\n+          including finished versions of the\n+          <filename>.java</filename> files listed above.\n+          </para>\n+              </listitem>\n+            </itemizedlist>\n+          </section>\n+          <section id=\"jpa_tutorial_utilities\">\n+            <title>Important Utilities</title>\n+            <itemizedlist>\n+              <listitem>\n+                <para><command>java</command>: Runs main methods in specified \n+          Java classes.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><command>javac</command>: Compiles <filename>.java\n+          </filename> files into <filename>.class</filename> \n+          files that can be executed by <command>java</command>.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><indexterm><primary>openjpac</primary></indexterm><command>openjpac</command>:\n+          Runs the OpenJPA enhancer against the specified\n+          classes. More information is available in\n+          <xref linkend=\"ref_guide_pc_enhance\"/> of the Reference \n+          Guide.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><indexterm><primary>mappingtool</primary></indexterm><command>mappingtool</command>: A \n+          utility that can be used to create and maintain the \n+          object-relational mappings and schema of all persistent\n+          classes in a JDBC-compliant datastore.  This functionality \n+          allows the underlying mappings and schema to be easily \n+          kept up-to-date with the Java classes in the system. See \n+          <xref linkend=\"ref_guide_mapping\"/>\n+          of the Reference Guide for more information.\n+          </para>\n+              </listitem>\n+            </itemizedlist>\n+          </section>\n+        </section>\n+        <section id=\"jpa_tutorial_chapter2\">\n+          <title>Getting Started</title>\n+          <para>\n+    Let's compile the initial classes and see them in action. To do\n+    so, we must compile the <filename>.java</filename> files, as we would \n+    with any Java project, and then pass the resulting classes through\n+    the OpenJPA enhancer:\n+    </para>\n+          <note>\n+            <para><indexterm><primary>CLASSPATH</primary></indexterm>\n+      Be sure that your <envar>CLASSPATH</envar> is set correctly. \n+      Note that your OpenJPA\n+      install directory should be in the <envar>CLASSPATH</envar>, as\n+      the tutorial classes are located in the <literal>\n+      tutorial/persistence</literal> directory under your OpenJPA install \n+      directory, and are in the <literal>tutorial.persistence</literal> \n+      package.\n+      </para>\n+          </note>\n+          <orderedlist>\n+            <listitem>\n+              <para>\n+        Make sure you are in the <filename>\n+        tutorial/persistence</filename> \n+        directory.  All examples throughout the tutorial assume that\n+        you are in this directory.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        Examine <filename>Animal.java</filename>,\n+        <filename>Dog.java</filename>, and\n+        <filename>SeedDatabase.java</filename>\n+        </para>\n+              <para>\n+        These files are good examples of the simplicity JPA\n+        engenders.  As noted earlier, persisting an object or \n+        manipulating an object's persistent data requires almost no \n+        JPA-specific code.\n+        For a very simple example of creating persistent objects,\n+        please see the <literal>seed</literal> method of\n+        <filename>SeedDatabase.java</filename>. Note the objects are\n+        created with normal Java \n+        constructors. The files <filename>Animal.java</filename> and\n+        <filename>Dog.java</filename> are also good examples of\n+        how JPA allows you to manipulate persistent data \n+        without writing any specific JPA code, by providing\n+        simple annotations.\n+        </para>\n+              <para>\n+        Let's take a look at the <filename>Animal.java</filename> file.\n+        Notice that the class is a Plain Old Java Object (POJO), with\n+        several annotations describing how the class is mapped into\n+        a relational database.  First, let's examine the class level\n+        annotations:\n+        </para>\n+              <programlisting format=\"linespecific\">\n+@Entity(name=\"Animal\")\n+@Table(name=\"JPA_TUT_ANIMAL\")\n+@Inheritance(strategy=InheritanceType.SINGLE_TABLE)\n+@DiscriminatorColumn(name=\"SPECIES\", length=100)\n+public abstract class Animal\n+{\n+    ...\n+}\n+</programlisting>\n+              <para>\n+        The annotations serve to map the class into the database.  For\n+        more information on these and other annotations, see\n+        <xref linkend=\"jpa_overview_meta\"/> and\n+        <xref linkend=\"jpa_overview_mapping\"/>.\n+        </para>\n+              <orderedlist>\n+                <listitem>\n+                  <para><command>@Entity</command>: This annotation indicates\n+            that instances of this class may be persistent entities.\n+            The value of the <command>name</command> attribute is\n+            the entity name, and is used in queries, etc.\n+            </para>\n+                </listitem>\n+                <listitem>\n+                  <para><command>@Table</command>: This annotation is used\n+            to map the entity to a primary table.  The value of the\n+            <command>name</command> attribute specifies the name\n+            of the relational table to use as the primary table.\n+            </para>\n+                </listitem>\n+                <listitem>\n+                  <para><command>@Inheritance</command>: When multiple classes\n+            in an inheritance hierarchy are persistent entity types,\n+            it is important to describe how the inheritance\n+            hierarchy is mapped.  Setting the value of the\n+            <command>strategy</command> attribute to\n+            <command>InheritanceType.SINGLE_TABLE</command>\n+            indicates that the primary table for all subclasses\n+            shall be the same table as for the superclass.\n+            </para>\n+                </listitem>\n+                <listitem>\n+                  <para><command>@DiscriminatorColumn</command>: With a\n+            <command>SINGLE_TABLE</command> inheritance mapping\n+            strategy, instances of multiple classes will be stored\n+            in the same table.  This annotation describes a column\n+            in that table that is used to determine the type of\n+            an instance whose data is stored in a particular row.\n+            The <command>name</command> attribute is the name of\n+            the column, and the <command>length</command> attribute\n+            indicates the size of the column.  By default, the\n+            unqualified class name for the instance is stored\n+            in the discriminator column.  To store a different\n+            value for a type, use the <command>@DiscriminatorValue\n+            </command> annotation.\n+            </para>\n+                </listitem>\n+              </orderedlist>\n+              <para>\n+        Let's take a look at our class' field annotations.\n+        We have chosen to use <emphasis>field access</emphasis> for\n+        our entities, meaning the persistence implementation will \n+        get and set persistent state directly through our class'\n+        declared fields.  We could have chosen to use <emphasis>\n+        property access</emphasis>, in which the implementation \n+        accesses persistent state through our JavaBean getter and\n+        setter methods.  In that case, we would have annotated our\n+        getter methods rather than our fields.\n+        </para>\n+              <programlisting format=\"linespecific\">\n+@Id\n+@GeneratedValue\n+@Column(name=\"ID\")\n+private long id;\n+\n+@Basic @Column(name=\"ANIMAL_NAME\")\n+private String name = null;\n+\n+@Basic @Column(name=\"COST\")\n+private float price = 0f;\n+</programlisting>\n+              <para>\n+        The annotations serve to map the fields into the database.  For\n+        more information on these and other annotations, see\n+        <xref linkend=\"jpa_overview_meta\"/>.\n+        </para>\n+              <orderedlist>\n+                <listitem>\n+                  <para><command>@Id</command>: This annotation indicates that\n+            the field is to be mapped to a primary key column in\n+            the database.  \n+            </para>\n+                </listitem>\n+                <listitem>\n+                  <para><command>@GeneratedValue</command>:\n+            Indicates that the implementation will generate a \n+            value for the field automatically.\n+            </para>\n+                </listitem>\n+                <listitem>\n+                  <para><command>@Column</command>: This annotation describes\n+            the column to which the field will be mapped.  The\n+            <command>name</command> attribute specifies the name\n+            of the column.\n+            </para>\n+                </listitem>\n+                <listitem>\n+                  <para><command>@Basic</command>: This annotation indicates\n+            that the field is simply mapped into a column.  There\n+            are other annotations that indicate entity\n+            relationships and other more complex mappings.\n+            </para>\n+                </listitem>\n+              </orderedlist>\n+            </listitem>\n+            <listitem>\n+              <para>Compile the <filename>.java</filename> files.</para>\n+              <programlisting format=\"linespecific\">\n+javac *.java\n+</programlisting>\n+              <para>\n+        You can use any java compiler instead of \n+        <command>javac</command>.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>Enhance the persistent classes.</para>\n+              <programlisting format=\"linespecific\">\n+openjpac -p persistence.xml Animal.java Dog.java\n+</programlisting>\n+              <para>\n+        This step runs the OpenJPA enhancer on the \n+        <filename>Animal.java</filename> and\n+        <filename>Dog.java</filename> files mentioned above.\n+        See <xref linkend=\"ref_guide_pc_enhance\"/> of the Reference \n+        Guide for more information on the enhancer, including how to\n+        use automatic runtime enhancement.\n+        </para>\n+              <note>\n+                <para>\n+          The <literal>-p</literal> flag points the enhancer to your\n+          <filename>persistence.xml</filename> configuration file.\n+          All OpenJPA tools look for default configuration in a\n+          resource called <filename>openjpa.xml</filename> or\n+          <filename>META-INF/openjpa.xml</filename>.  Thus you\n+          can avoid passing the <literal>-p</literal> argument to\n+          tools by using this configuration file name in place of\n+          <filename>persistence.xml</filename>.  See\n+          <xref linkend=\"ref_guide_conf\"/> in the Reference Guide\n+          for details on OpenJPA configuration.\n+          </para>\n+              </note>\n+            </listitem>\n+          </orderedlist>\n+          <section id=\"jpa_tutorial_chapter2_datastore\">\n+            <title>Configuring the Datastore</title>\n+            <para>\n+      Now that we've compiled the source files and enhanced the\n+      persistent classes, we're ready to set up the database. \n+      <ulink url=\"http://hsqldb.sourceforge.net\">Hypersonic SQL</ulink>,\n+      a pure Java relational database, is included in the OpenJPA \n+      distribution. \n+      We have included this database because it is simple to set up and \n+      has a small memory footprint; however, you can use this tutorial \n+      with any of the relational databases that we support.  You can also\n+      write your own plugin for any database that we do not support. For \n+      the sake of simplicity, this tutorial only describes how to set up\n+      connectivity to a Hypersonic SQL database. For more\n+      information on how to connect to a different database or\n+      how to add support for other databases, see\n+      <xref linkend=\"ref_guide_dbsetup\"/> of the \n+      Reference Guide.\n+      </para>\n+            <orderedlist>\n+              <listitem>\n+                <para><indexterm><primary>mappingtool</primary></indexterm>\n+          Create the object-relational mappings and database schema.\n+          </para>\n+                <programlisting format=\"linespecific\">\n+mappingtool -p persistence.xml Animal.java Dog.java\n+</programlisting>\n+                <para>\n+          This command propagates the necessary schema for the\n+          specified classes to the database configured in \n+          <filename>persistence.xml</filename>.  If you are \n+          using the default Hypersonic SQL setup, the first time you \n+          run the mapping tool Hypersonic will create\n+          <filename>tutorial_database.properties</filename> and\n+          <filename>tutorial_database.script</filename> database\n+          files in your current directory.  To \n+          delete the database, just delete these files.\n+          </para>\n+                <para>\n+          By default, JPA uses object-relational mapping\n+          information stored in annotations in your source files.\n+          <xref linkend=\"jpa_overview_mapping\"/> of the\n+          JPA Overview will help you understand mapping\n+          annotations.\n+          Additionally, <xref linkend=\"ref_guide_mapping\"/> of the \n+          Reference Guide describes your other mapping options in \n+          detail.\n+          </para>\n+                <para>\n+          </para>\n+                <para>\n+          If you are curious, you can view the schema OpenJPA \n+          created for the tutorial classes with OpenJPA's schema tool: \n+          </para>\n+                <programlisting format=\"linespecific\">\n+schematool -p persistence.xml -a reflect -f tmp.schema\n+</programlisting>\n+                <para>\n+          This will create a <filename>tmp.schema</filename> file\n+          with an XML representation of the database schema.  The\n+          XML should be self explanatory; see\n+          <xref linkend=\"ref_guide_schema_xml\"/>\n+          of the Reference Guide for details.  You may delete the\n+          <filename>tmp.schema</filename> file before proceeding.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para>Populate the database with sample data.</para>\n+                <programlisting format=\"linespecific\">\n+java tutorial.persistence.SeedDatabase\n+</programlisting>\n+              </listitem>\n+            </orderedlist>\n+            <para>\n+      Congratulations! You have now created an JPA-accessible\n+      persistent store, and seeded it with some sample data.\n+      </para>\n+          </section>\n+        </section>\n+        <section id=\"jpa_tutorial_chapter3\">\n+          <title>Inventory Maintenance</title>\n+          <para>\n+    The most important element of a successful pet store product, say the \n+    experts, is an inventory maintenance mechanism. So, let's work on the \n+    <classname>Animal</classname> and <classname>Dog</classname> classes a\n+    bit to permit user interaction with the database.\n+    </para>\n+          <para>\n+    This chapter should familiarize you with some of the basics of the \n+    <ulink url=\"../../ejb-3_0-pr-spec-persistence.pdf\">JPA \n+    specification</ulink> and the mechanics of compiling and enhancing \n+    persistent classes. You will also become familiar with the mapping \n+    tool for propagating the persistent schema into the database.\n+    </para>\n+          <para>\n+    First, let's add some code to\n+    <filename>AnimalMaintenance.java</filename> that allows us to examine\n+    the animals currently in the database. \n+    </para>\n+          <orderedlist>\n+            <listitem>\n+              <para>\n+        Add code to <filename>AnimalMaintenance.java</filename>.\n+        </para>\n+              <para>\n+        Modify the <methodname>getAnimals</methodname> method of \n+        <filename>AnimalMaintenance.java</filename> to look like this:\n+        </para>\n+              <programlisting format=\"linespecific\">\n+    /**\n+     *  Return a list of animals that match the specified query filter.\n+     *\n+     *  @param  filter      the JPQL filter to apply to the query\n+     *  @param  cls         the class of animal to query on\n+     *  @param  em          the EntityManager to obtain the query from\n+     */\n+    public static List getAnimals (String filter, EntityManager em)\n+    {\n+        // Execute a query for the specified filter.\n+        Query query = em.createQuery (filter);\n+        return query.getResultList ();\n+    }\n+</programlisting>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        Compile <filename>AnimalMaintenance.java</filename>.\n+        </para>\n+              <programlisting format=\"linespecific\">\n+javac AnimalMaintenance.java\n+</programlisting>\n+            </listitem>\n+            <listitem>\n+              <para>Take a look at the animals in the database.</para>\n+              <programlisting format=\"linespecific\">\n+java tutorial.persistence.AnimalMaintenance list Animal\n+</programlisting>\n+              <para>\n+        Notice that <methodname>list</methodname> optionally takes a\n+        query filter. Let's explore the database some more, this time \n+        using filters:\n+        </para>\n+              <programlisting format=\"linespecific\">\n+java tutorial.persistence.AnimalMaintenance list \"select a from Animal a where a.name = 'Binney'\"\n+java tutorial.persistence.AnimalMaintenance list \"select a from Animal a where a.price &lt;= 50\"\n+</programlisting>\n+              <para>\n+        The Java Persistence Query Language (JPQL) is designed to look \n+        and behave much like an object oriented SQL dialect. The\n+        <literal>name</literal> and <literal>price</literal> fields\n+        identified in the above queries map to the member fields of\n+        those names in <classname>\n+        tutorial.persistence.Animal</classname>.  \n+        More details on JPQL syntax is available in\n+        <xref linkend=\"jpa_overview_query\"/> of the JPA Overview.  \n+        </para>\n+            </listitem>\n+          </orderedlist>\n+          <para>\n+    Great! Now that we can see the contents of the database,\n+    let's add some code that lets us add and remove animals.\n+    </para>\n+          <section id=\"jpa_tutorial_chapter3_persist\">\n+            <title>Persisting Objects</title>\n+            <para>\n+      As new dogs are born or acquired, the store owner will\n+      need to add new records to the inventory database. In this\n+      section, we'll write the code to handle additions through\n+      the <classname>tutorial.persistence.AnimalMaintenance</classname> \n+      class.\n+      </para>\n+            <para>\n+      This section will familiarize you with the mechanism for\n+      storing persistent instances in a JPA entity\n+      manager. We will create a new dog, obtain a\n+      <classname>Transaction</classname> from a \n+      <classname>EntityManager</classname>, and, within the \n+      transaction, make the new dog object persistent.\n+      </para>\n+            <para><classname>tutorial.persistence.AnimalMaintenance</classname> \n+      provides a reflection-based facility for creating any type of \n+      animal, provided that the animal has a two-argument constructor\n+      whose first argument corresponds to the name of the animal\n+      and whose second argument is an implementation-specific \n+      primitive. This reflection-based system is in place to keep this \n+      tutorial short and remove repetitive creation mechanisms. It is \n+      not a required part of the JPA specification.\n+      </para>\n+            <orderedlist>\n+              <listitem>\n+                <para>Add the following code to <filename>\n+          AnimalMaintenance.java</filename>.\n+          </para>\n+                <para>\n+          Modify the <methodname>persistObject</methodname> method of \n+          <filename>AnimalMaintenance.java</filename> to look like \n+          this:\n+          </para>\n+                <programlisting format=\"linespecific\">\n+    /**\n+     *  Performs the actual JPA work of putting &lt;code&gt;object&lt;/code&gt;\n+     *  into the data store.\n+     *\n+     *  @param  object  the object to persist in the data store\n+     */\n+    public static void persistObject (EntityManager em, Object object)\n+    {\n+        // Mark the beginning of the unit of work boundary.\n+        em.getTransaction ().begin ();\n+\n+        em.persist (object);\n+\n+        // Mark the end of the unit of work boundary,\n+        // and record all inserts in the database.\n+        em.getTransaction ().commit ();\n+        System.out.println (\"Added \" + object);\n+    }\n+</programlisting>\n+                <note>\n+                  <para>In the above code, we pass in an\n+          <classname>EntityManager</classname>.\n+          <classname>EntityManager</classname>s may be either\n+          container managed or application managed.  In this tutorial,\n+          because we're operating outside a container, we're using\n+          application managed <classname>EntityManager</classname>s.\n+          In managed environments,\n+          <classname>EntityManager</classname>s are typically\n+          container managed, and thus injected or looked up via JNDI.\n+          Application managed <classname>EntityManager</classname>s\n+          can be used in both managed and unmanaged environments, and\n+          are created by an\n+          <classname>EntityManagerFactory</classname>.  An\n+          <classname>EntityManagerFactory</classname> can be obtained\n+          from the\n+          <classname>javax.persistence.Persistence</classname> class.\n+          This class provides some convenience methods for\n+          obtaining an <classname>EntityManagerFactory</classname>.\n+          </para>\n+                </note>\n+              </listitem>\n+              <listitem>\n+                <para>\n+          Recompile <filename>AnimalMaintenance.java</filename>.\n+          </para>\n+                <programlisting format=\"linespecific\">\n+javac AnimalMaintenance.java\n+</programlisting>\n+              </listitem>\n+            </orderedlist>\n+            <para>\n+      You now have a mechanism for adding new dogs to the database. Go \n+      ahead and add some by running\n+      <command>java tutorial.persistence.AnimalMaintenance add Dog &lt;name&gt; &lt;price&gt;</command> \n+      For example:\n+      </para>\n+            <programlisting format=\"linespecific\">\n+java tutorial.persistence.AnimalMaintenance add Dog Fluffy 35\n+</programlisting>\n+            <para>\n+      You can view the contents of the database with:\n+      </para>\n+            <programlisting format=\"linespecific\">\n+java tutorial.persistence.AnimalMaintenance list Dog\n+</programlisting>\n+          </section>\n+          <section id=\"jpa_tutorial_chapter3_delete\">\n+            <title>Deleting Objects</title>\n+            <para>\n+      What if someone decides to buy one of the dogs? The store owner \n+      will need to remove that animal from the database, since it is no \n+      longer in the inventory. \n+      </para>\n+            <para>\n+      This section demonstrates how to remove data from the datastore.\n+      </para>\n+            <orderedlist>\n+              <listitem>\n+                <para>\n+          Add the following code to <filename>AnimalMaintenance.java\n+          </filename>.\n+          </para>\n+                <para>\n+          Modify the <methodname>deleteObjects</methodname> method of \n+          <filename>AnimalMaintenance.java</filename> to look like \n+          this:\n+          </para>\n+                <programlisting format=\"linespecific\">\n+    /**\n+     *  Performs the actual JPA work of removing \n+     *  &lt;code&gt;objects&lt;/code&gt; from the datastore.\n+     *\n+     *  @param  objects     the objects to persist in the datastore\n+     *  @param  em          the EntityManager to delete with\n+     */\n+    public static void deleteObjects (Collection objects, EntityManager em)\n+    {\n+        // Mark the beginning of the unit of work boundary.\n+        em.getTransaction ().begin ();\n+\n+        // This method removes the objects in 'objects' from the data store.\n+        for (Object ob : objects)\n+        {\n+            System.out.println (\"Removed animal: \" + ob);\n+            em.remove (ob);\n+        }\n+\n+        // Mark the end of the unit of work boundary, and record all\n+        // deletes in the database.\n+        em.getTransaction ().commit ();\n+    }\n+</programlisting>\n+              </listitem>\n+              <listitem>\n+                <para>\n+          Recompile <filename>AnimalMaintenance.java</filename>.\n+          </para>\n+                <programlisting format=\"linespecific\">\n+javac AnimalMaintenance.java\n+</programlisting>\n+              </listitem>\n+              <listitem>\n+                <para>Remove some animals from the database.</para>\n+                <programlisting format=\"linespecific\">\n+java tutorial.persistence.AnimalMaintenance remove &lt;query&gt;\n+</programlisting>\n+                <para>\n+          Where <replaceable>&lt;query&gt;</replaceable> is a query \n+          string like those used for listing animals above.\n+          </para>\n+              </listitem>\n+            </orderedlist>\n+            <para>\n+      All right. We now have a basic pet shop inventory\n+      management system. From this base, we will add some of the\n+      more advanced features suggested by our industry experts.\n+      </para>\n+          </section>\n+        </section>\n+        <section id=\"jpa_tutorial_chapter4\">\n+          <title>Inventory Growth</title>\n+          <para>\n+    Now that we have the basic pet store framework in place, let's add \n+    support for the next pet in our list: the rabbit. The rabbit is a bit \n+    different than the dog; pet stores sell them all for the same price, \n+    but gender is critically important since rabbits reproduce rather \n+    easily and quickly. Let's put together a class representing a rabbit.\n+    </para>\n+          <para>\n+    In this chapter, you will see some more queries and write a \n+    bidirectional relation between objects.\n+    </para>\n+          <para>\n+    Provided with this tutorial is a file called \n+    <filename>Rabbit.java</filename> which contains a sample \n+    <classname>Rabbit</classname> implementation. \n+    </para>\n+          <orderedlist>\n+            <listitem>\n+              <para>\n+        Examine <filename>Rabbit.java</filename>.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        The Rabbit class above contains a bidirectional \n+        relationship between parents and children. From the Java side \n+        of things, a bidirectional relationship is simply a\n+        pair of fields that are conceptually linked. There is no \n+        special Java work necessary to express bidirectionality. \n+        However, you must identify the relationship as bidirectional\n+        using JPA <link linkend=\"jpa_overview_meta\">\n+        annotations</link> so the mapping tool can create the most \n+        efficient schema.\n+        </para>\n+              <para>\n+        Insert this snippet of code immediately\n+        <emphasis>before</emphasis> the <literal>children</literal>\n+        field declaration in the <filename>Rabbit.java</filename> file.\n+        </para>\n+              <programlisting format=\"linespecific\">\n+    @ManyToMany\n+    @JoinTable(name=\"RABBIT_CHILDREN\",\n+        joinColumns=@JoinColumn(name=\"PARENT_ID\"),\n+        inverseJoinColumns=@JoinColumn(name=\"CHILD_ID\"))\n+</programlisting>\n+              <para>\n+        The <literal>@ManyToMany</literal> annotation indicates that\n+        <literal>children</literal> is one side of a many-to-many \n+        relation.  <literal>@JoinTable</literal> describes how this \n+        relation maps to a database join table.  The annotation's \n+        <literal>joinColumns</literal> name the join table's foreign \n+        key columns linking to the owning instance (the parent).  In \n+        this case, column <literal>RABBIT_CHILDREN.PARENT_ID</literal> \n+        is a foreign key to the parent's <literal>ID</literal> primary \n+        key column.  Similarly, the <literal>inverseJoinColumns\n+        </literal> attribute denotes the foreign key columns linking to\n+        the collection elements (the children).\n+        For more details on the <literal>@JoinTable</literal>\n+        annotation, see <xref linkend=\"jpa_overview_mapping\"/> of the \n+        JPA Overview.  \n+        </para>\n+              <para>\n+        Now we'll map the other side of this bidirectional relation,\n+        the <literal>parents</literal> field.\n+        Insert the following snippet of code immediately\n+        <emphasis>before</emphasis> the <command>parents</command>\n+        field declaration in the <filename>Rabbit.java</filename> file.\n+        The <literal>mappedBy</literal> attribute identifies the name\n+        of the owning side of the relation.\n+        </para>\n+              <programlisting format=\"linespecific\">\n+    @ManyToMany(mappedBy=\"children\")\n+</programlisting>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        Compile <filename>Rabbit.java</filename>.\n+        </para>\n+              <programlisting format=\"linespecific\">\n+javac Rabbit.java\n+</programlisting>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        Enhance the <classname>Rabbit</classname> class.\n+        </para>\n+              <programlisting format=\"linespecific\">\n+openjpac -p persistence.xml Rabbit.java\n+</programlisting>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        Refresh the object-relational mappings and database schema.\n+        </para>\n+              <programlisting format=\"linespecific\">\n+mappingtool -p persistence.xml Rabbit.java\n+</programlisting>\n+            </listitem>\n+          </orderedlist>\n+          <para>\n+    Now that we have a Rabbit class, let's get some preliminary rabbit \n+    data into the database. \n+    </para>\n+          <orderedlist>\n+            <listitem>\n+              <para>\n+        Add a <literal>&lt;class&gt;</literal> entry for <classname>\n+        Rabbit</classname> to \n+        <filename>../../META-INF/persistence.xml</filename>.\n+        </para>\n+              <programlisting format=\"linespecific\">\n+&lt;class&gt;tutorial.persistence.Rabbit&lt;/class&gt;\n+</programlisting>\n+            </listitem>\n+            <listitem>\n+              <para>Create some rabbits.</para>\n+              <para>\n+        Run the following commands a few times to add some male\n+        and female rabbits to the database:\n+        </para>\n+              <programlisting format=\"linespecific\">\n+java tutorial.persistence.AnimalMaintenance add Rabbit &lt;name&gt; false\n+java tutorial.persistence.AnimalMaintenance add Rabbit &lt;name&gt; true\n+</programlisting>\n+              <para>\n+        Now run some breeding iterations.\n+        </para>\n+              <programlisting format=\"linespecific\">\n+java tutorial.persistence.Rabbit breed 2\n+</programlisting>\n+            </listitem>\n+            <listitem>\n+              <para>Look at your new rabbits.</para>\n+              <programlisting format=\"linespecific\">\n+java tutorial.persistence.AnimalMaintenance list Rabbit\n+java tutorial.persistence.AnimalMaintenance details \"select r from Rabbit r where r.name = '&lt;name&gt;'\"\n+</programlisting>\n+            </listitem>\n+          </orderedlist>\n+        </section>\n+        <section id=\"jpa_tutorial_chapter5\">\n+          <title>Behavioral Analysis</title>\n+          <para>\n+    Often, pet stores sell snakes as well as rabbits and dogs.  Pet stores \n+    are primarily concerned with a snake's length; much like rabbits, pet \n+    store operators usually sell them all for a flat rate.\n+    </para>\n+          <para>\n+    This chapter demonstrates more queries, schema manipulation, \n+    and additional relation types.\n+    </para>\n+          <para>\n+    Provided with this tutorial is a file called <filename>Snake.java\n+    </filename> which contains a sample <classname>Snake</classname> \n+    implementation. Let's get it compiled and loaded:\n+    </para>\n+          <orderedlist>\n+            <listitem>\n+              <para>\n+        Examine and compile <filename>Snake.java</filename>.\n+        </para>\n+              <programlisting format=\"linespecific\">\n+javac Snake.java\n+</programlisting>\n+            </listitem>\n+            <listitem>\n+              <para>Enhance the class.</para>\n+              <programlisting format=\"linespecific\">\n+openjpac -p persistence.xml Snake.java\n+</programlisting>\n+            </listitem>\n+            <listitem>\n+              <para>Refresh the mappings and database.</para>\n+              <para>\n+        As we have created a new persistent class, we must \n+        map it to the database and change the schema to match.  So\n+        run the mapping tool:\n+        </para>\n+              <programlisting format=\"linespecific\">\n+mappingtool -p persistence.xml Snake.java\n+</programlisting>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        Add a <literal>&lt;class&gt;</literal> entry for <classname>\n+        Snake</classname> to \n+        <filename>../../META-INF/persistence.xml</filename>.\n+        </para>\n+              <programlisting format=\"linespecific\">\n+&lt;class&gt;tutorial.persistence.Snake&lt;/class&gt;\n+</programlisting>\n+            </listitem>\n+          </orderedlist>\n+          <para>\n+    Once you have compiled everything, add a few snakes to the database \n+    using:\n+    </para>\n+          <programlisting format=\"linespecific\">\n+java tutorial.persistence.AnimalMaintenance add Snake \"name\" &lt;length&gt;\n+</programlisting>\n+          <para>\n+    Where <replaceable>&lt;length&gt;</replaceable> is the length in feet \n+    for the new snake. To see the new snakes in the database, run:\n+    </para>\n+          <programlisting format=\"linespecific\">\n+java tutorial.persistence.AnimalMaintenance list Snake\n+</programlisting>\n+          <para>\n+    Unfortunately for the massively developing rabbit population, snakes \n+    often eat rabbits. Any good inventory system should be able to capture \n+    this behavior. So, let's add some code to <filename>Snake.java\n+    </filename> to support the snake's eating behavior.\n+    </para>\n+          <para>\n+    First, let's modify <filename>Snake.java</filename> to contain a\n+    list of eaten rabbits.\n+    </para>\n+          <orderedlist>\n+            <listitem>\n+              <para>\n+        Add the following code snippets to\n+        <filename>Snake.java</filename>.\n+        </para>\n+              <programlisting format=\"linespecific\">\n+    // This list will be persisted into the database as\n+    // a one-to-many relation.\n+    @OneToMany(mappedBy=\"eater\")\n+    private Set&lt;Rabbit&gt; giTract = new HashSet&lt;Rabbit&gt; ();\n+</programlisting>\n+              <para>\n+        Note that we specified a <literal>mappedBy</literal>\n+        attribute in this example. This is because the relation is \n+        bidirectional; that is, the rabbit has knowledge of which \n+        snake ate it. We could have left out the \n+        <literal>eater</literal> field and instead created a \n+        standard unidirectional relation.  In fact, in a bidirectional\n+        many-to-one relation, the many side must always be the owner.\n+        </para>\n+              <para>\n+        For more information on types of relations, see \n+        <xref linkend=\"jpa_overview_mapping_field\"/> of the \n+        JPA Overview.\n+        </para>\n+              <para>\n+          Modify the <literal>toString (boolean)</literal> method to\n+        output the giTract list.\n+        </para>\n+              <programlisting format=\"linespecific\">\n+    public String toString (boolean detailed)\n+    {\n+        StringBuffer buf = new StringBuffer (1024);\n+        buf.append (\"Snake \").append (getName ());\n+\n+        if (detailed)\n+        {\n+            buf.append (\" (\").append (length).append (\" feet long) sells for \");\n+            buf.append (getPrice ()).append (\" dollars.\");\n+            buf.append (\"  Its gastrointestinal tract contains:\\n\");\n+            for (Rabbit rabbit : giTract)\n+                buf.append (\"\\t\").append (rabbit).append (\"\\n\");\n+        }\n+        else\n+            buf.append (\"; ate \" + giTract.size () + \" rabbits.\");\n+\n+        return buf.toString ();\n+    }\n+</programlisting>\n+              <para>\n+        Add the following methods.\n+        </para>\n+              <programlisting format=\"linespecific\">\n+    /**\n+     *  Kills the specified rabbit and eats it.\n+     */\n+    public void eat (Rabbit dinner)\n+    {\n+        // Consume the rabbit.\n+        dinner.kill ();\n+        dinner.setEater (this);\n+        giTract.add (dinner);\n+        System.out.println (\"Snake \" + getName () + \" ate rabbit \" \n+            + dinner.getName () + \".\");\n+    }\n+\n+\n+    /**\n+     *  Locates the specified snake and tells it to eat a rabbit.\n+     */\n+    public static void eat (EntityManager em, String filter)\n+    {\n+        em.getTransaction ().begin ();\n+\n+        // Find the desired snake(s) in the data store.\n+        Query query = em.createQuery (filter);\n+        List&lt;Snake&gt; results = query.getResultList ();\n+        if (results.isEmpty ())\n+        {\n+            System.out.println (\"No snakes matching '\" + filter + \"' found\");\n+            return;\n+        }\n+\n+        Query uneatenQuery = em.createQuery\n+            (\"select r from Rabbit r where r.isDead = false\");\n+        Random random = new Random ();\n+        for (Snake snake : results)\n+        {\n+            // Run a query for a rabbit whose 'isDead' field indicates\n+            // that it is alive.\n+            List&lt;Rabbit&gt; menu = uneatenQuery.getResultList ();\n+            if (menu.isEmpty ())\n+            {\n+                System.out.println (\"No live rabbits in DB.\");\n+                break;\n+            }\n+\n+            // Select a random rabbit from the list.\n+            Rabbit dinner = menu.get (random.nextInt (menu.size ()));\n+\n+            // Perform the eating.\n+            System.out.println (snake + \" is eating:\");\n+            snake.eat (dinner);\n+        }\n+\n+        em.getTransaction ().commit ();\n+    }\n+\n+\n+    public static void main (String[] args)\n+    {\n+        if (args.length == 2 &amp;&amp; args[0].equals (\"eat\"))\n+        {\n+            EntityManagerFactory emf = Persistence.\n+                createEntityManagerFactory (null);\n+            EntityManager em = emf.createEntityManager ();\n+            eat (em, args[1]);\n+            em.close ();\n+            emf.close ();\n+            return;\n+        }\n+\n+        // If we get here, something went wrong.\n+        System.out.println (\"Usage:\");\n+        System.out.println (\"  java tutorial.persistence.Snake eat \"\n+            + \"\\\"snakequery\\\"\");\n+    }\n+</programlisting>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        Add an <literal>eater</literal> field to \n+        <filename>Rabbit.java</filename>, and a getter and setter.\n+        </para>\n+              <programlisting format=\"linespecific\">\n+    @ManyToOne @JoinColumn(name=\"EATER_ID\")\n+    private Snake eater;\n+\n+    ...\n+\n+    public Snake getEater ()\n+    {\n+        return eater;\n+    }\n+\n+\n+    public void setEater (Snake snake)\n+    {\n+        eater = snake;\n+    }\n+</programlisting>\n+              <para>\n+        The <literal>@ManyToOne</literal> annotation indicates that this\n+        is the many side of the bidirectional relation.  The many side\n+        must always be the owner in this type of relation.  The\n+        <literal>@JoinColumn</literal> describes the foreign key\n+        that joins the rabbit table to the snake table.  The rabbit\n+        table has an <literal>EATER_ID</literal> column that is a\n+        foreign key to the <literal>ID</literal> primary key column\n+        of the snake table.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        Compile <filename>Snake.java</filename> and \n+        <filename>Rabbit.java</filename> and enhance the classes.\n+        </para>\n+              <programlisting format=\"linespecific\">\n+javac Snake.java Rabbit.java\n+openjpac -p persistence.xml Snake.java Rabbit.java\n+</programlisting>\n+            </listitem>\n+            <listitem>\n+              <para>Refresh the mappings and database.</para>\n+              <programlisting format=\"linespecific\">\n+mappingtool -p persistence.xml Snake.java Rabbit.java\n+</programlisting>\n+            </listitem>\n+          </orderedlist>\n+          <para>\n+    Now, experiment with the following commands:\n+    </para>\n+          <programlisting format=\"linespecific\">\n+java tutorial.persistence.Snake eat \"select s from Snake s where s.name = '&lt;name&gt;'\"\n+java tutorial.persistence.AnimalMaintenance details \"select s from Snake s where s.name = '&lt;name&gt;'\"\n+</programlisting>\n+          <section id=\"jpa_tutorial_chapter5_query\">\n+            <title>Complex Queries</title>\n+            <para>\n+      Imagine that one of the snakes in the database was named Killer. \n+      To find out which rabbits Killer ate, we could run either of the \n+      following two queries:\n+      </para>\n+            <programlisting format=\"linespecific\">\n+java tutorial.persistence.AnimalMaintenance details \"select s from Snake s where s.name = 'Killer'\"\n+java tutorial.persistence.AnimalMaintenance list \"select r from Rabbit r where r.eater.name = 'Killer'\"\n+</programlisting>\n+            <para>\n+      The first query is snake-centric - the query runs against the \n+      <classname>Snake</classname> class, looking for all snakes named\n+      Killer and providing a detailed listing of them. The second is \n+      rabbit-centric - it examines the rabbits in the database for \n+      instances whose <literal>eater</literal> is named Killer.\n+      This second query demonstrates the that simple java 'dot' syntax\n+      is used when traversing an to-one field in a query.\n+      </para>\n+            <para>\n+      It is also possible to traverse collection fields.  Imagine that \n+      there was a rabbit called Roger in the datastore and that one of \n+      the snakes ate it. In order to determine who ate Roger Rabbit, you \n+      could run a query like this:\n+      </para>\n+            <programlisting format=\"linespecific\">\n+java tutorial.persistence.AnimalMaintenance details \"select s from Snake s inner join s.giTract r where r.name = 'Roger'\"\n+</programlisting>\n+          </section>\n+        </section>\n+        <section id=\"jpa_tutorial-chapter6\">\n+          <title>Extra Features</title>\n+          <para>\n+    Congratulations! You are now the proud author of a pet store inventory \n+    suite. Now that you have all the major features of the pet store \n+    software implemented, it's time to add some extra features. You're on \n+    your own; think of some features that you think a pet store should have,\n+    or just explore the features of JPA.\n+    </para>\n+          <para>\n+    Here are a couple of suggestions to get you started:\n+    </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>Animal pricing.</para>\n+              <para>\n+        Modify <classname>Animal</classname> to contain an inventory \n+        cost and a resale price.  Calculate the real dollar amount \n+        eaten by the snakes (the sum of the inventory costs of all the \n+        consumed rabbits), and the cost assuming that all the eaten \n+        rabbits would have been sold had they been alive. Ignore the \n+        fact that the rabbits, had they lived, would have created more \n+        rabbits, and the implications of the reduced food costs due to \n+        the not-quite-as-hungry snakes and the smaller number of \n+        rabbits.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>Dog categorization.</para>\n+              <para>\n+              Modify <classname>Dog</classname> to have a\n+        relation to a new class called <classname>Breed</classname>, \n+        which contains a name identifying the breed of the dog and a \n+        description of the breed. Put together an admin tool for\n+              breeds and for associating dogs and breeds.\n+        </para>\n+            </listitem>\n+          </itemizedlist>\n+        </section>\n+      </section>\n+<!-- ### EJBDOC \n+      &ejb3-reverse-tutorial.xml;\n+  -->\n+      <section id=\"jpa_j2ee_tutorial\">\n+        <title>J2EE Tutorial</title>\n+        <para>\n+  By deploying OpenJPA into a J2EE environment, you can maintain the \n+  simplicity and performance of OpenJPA, while leveraging J2EE \n+  technologies such as container managed transactions (JTA/JTS), \n+  enterprise objects with remote invocation (EJB), and managed \n+  deployment of multi-tiered applications via an application \n+  server.  This tutorial will demonstrate how to deploy OpenJPA-based \n+  J2EE applications and showcase some basic enterprise JPA\n+  design techniques. The tutorial's sample application models\n+  a basic garage catalog system.  While the application is \n+  relatively trivial, the code has been constructed to illustrate \n+  simple patterns and solutions to common problems when using \n+  OpenJPA in an enterprise environment.\n+  </para>\n+        <section id=\"jpa_j2ee_tutorial_requirements\">\n+          <title>Prerequisites for the OpenJPA J2EE Tutorial</title>\n+          <para>\n+    This tutorial assumes that you have installed OpenJPA and \n+    setup your classpath according to the installation instructions \n+    appropriate for your platform.  In addition, this \n+    tutorial requires that you have installed and configured a \n+    J2EE-compliant application server, such as WebLogic or JBoss,\n+    running on JDK 1.5.  If you use a different\n+    application server not listed here, this tutorial may be adaptable to \n+    your application server with small changes; refer to your application\n+    server's documentation for any specific classpath and deployment \n+    descriptor requirements. \n+    </para>\n+          <para>\n+    This tutorial assumes a reasonable level of experience with \n+    OpenJPA and JPA.  We provide a number of other \n+    tutorials for basic concepts, including enhancement, schema \n+    mapping, and configuration.  This tutorial also assumes a \n+    basic level of experience with J2EE components, including \n+    session beans, JNDI, JSP, and EAR/WAR/JAR packaging.  Sun and/or \n+    your application server company may provide tutorials to get \n+    familiar with these components.\n+    </para>\n+          <para>\n+    In addition, this tutorial uses Ant to build the deployment \n+    archives.  While this is the preferred way of building\n+    a deployment of the tutorial, one can easily build the \n+    appropriate JAR, WAR, and EAR files by hand, although that \n+    is outside the scope of this document.\n+    </para>\n+        </section>\n+        <section id=\"jpa_j2ee_tutorial_installation_types\">\n+          <title>J2EE Installation Types</title>\n+          <para>\n+    Every application server has a different installation process \n+    for installing J2EE components.  OpenJPA can be installed in a \n+    number of ways, which may or may not be appropriate to your \n+    application server.  While this document focuses mainly upon \n+    using OpenJPA as a JCA resource,  there are other ways to use \n+    OpenJPA in a J2EE environment.\n+    </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para><literal>JPA</literal>:  J2EE 5 allows for the\n+        automatic injection of \n+        <classname>EntityManager</classname> instances\n+        into the J2EE context. \n+        <!-- ### EJBDOC ###--></para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>JCA</literal>:  OpenJPA implements the \n+        JCA 1.0 spec, and the openjpa-persistence.rar file that comes in \n+        the <filename>jca/persistence</filename> directory of the \n+        distribution can be installed as any other JCA connection \n+        resource.  This is the preferred way to integrate OpenJPA into a \n+        pre-J2EE 5 environment.  It allows for simple installation \n+        (usually involving uploading or copying openjpa-persistence.rar \n+        into the application server's deployment directory), and \n+        guided configuration on many appservers<!--\n+        doesn't work yet , as well as dynamic reloading \n+        for upgrading OpenJPA to a newer version-->.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        Manual Binding into JNDI: Your application may require\n+        some needs in initializing OpenJPA that go beyond the \n+        JPA and JCA specifications.  In this case, you can\n+        manually instantiate OpenJPA and place it into the JNDI tree.\n+        This process, however, is not seamless and can require a \n+        fair bit of custom application server code to bind an \n+        instance of \n+        <classname>org.apache.openjpa.persistence.EntityManagerFactoryImpl</classname>\n+        into JNDI. \n+        </para>\n+            </listitem>\n+          </itemizedlist>\n+        </section>\n+        <section id=\"jpa_j2ee_tutorial_installing_sample\">\n+          <title>Installing the J2EE Sample Application</title>\n+          <para>\n+    Installing the sample application involves first compiling\n+    and building a deployment archive (.ear) file.  This file\n+    then needs to be deployed into your application server.\n+    </para>\n+          <section id=\"jpa_j2ee_tutorial_building_sample\">\n+            <title>Compiling and Building The Sample Application</title>\n+            <para>\n+      Navigate to the <filename>samples/persistence/j2ee</filename> \n+      directory of your OpenJPA installation.\n+      </para>\n+            <para>\n+      Ensure that the JNDI name in the setSessionContext() method in\n+      ejb/CarBean.java matches your JCA installation. This defaults to\n+      <literal>java:/openjpa-ejb</literal>, but the actual value will depend\n+      on the configuration of your JCA deploy and your application \n+      server's JNDI context.  E.g. the default name for a WebLogic 9 \n+      install would be simply <literal>openjpa-ejb</literal>.\n+      </para>\n+            <para>\n+      Compile the source files in place both in this base directory \n+      as well as the nested <filename>ejb</filename> and \n+      <filename>jsp</filename> directories:\n+      </para>\n+            <programlisting format=\"linespecific\">\n+javac *.java  ejb/*.java jsp/*.java\n+</programlisting>\n+            <para>\n+      Enhance the Car class. \n+      </para>\n+            <programlisting format=\"linespecific\">\n+openjpac -p persistence.xml Car.java\n+</programlisting>\n+            <para>\n+      Run the mapping tool; make sure that your <filename>\n+      META-INF/persistence.xml</filename> file includes the same \n+      connection information (e.g. Driver, URL, etc.) as your \n+      JCA installation.  You should update your JCA configuration\n+      to include <classname>samples.persistence.j2ee.Car</classname>\n+      in the <link linkend=\"openjpa.MetaDataFactory\">MetaDataFactory</link> \n+      property:\n+      </para>\n+            <programlisting format=\"linespecific\">\n+&lt;config-property name=\"MetaDataFactory\"&gt;Types=samples.persistence.j2ee.Car&lt;/config-property/&gt;\n+</programlisting>\n+            <programlisting format=\"linespecific\">\n+mappingtool -p persistence.xml Car.java\n+</programlisting>\n+            <para>\n+      Build an J2EE application archive by running Ant against the \n+      <filename>build.xml</filename>.  This will create \n+      <filename>openjpa-persistence-j2ee-sample.ear</filename>.  This ear \n+      can now be deployed to your appserver.  Be sure to add the class\n+      <classname>samples.j2ee.Car</classname> to the\n+      <literal>openjpa.PersistentClasses</literal> OpenJPA configuration\n+      property.  This will automatically register the Entity.\n+      </para>\n+            <programlisting format=\"linespecific\">\n+ant -f build.xml\n+</programlisting>\n+          </section>\n+          <section id=\"jpa_j2ee_tutorial_sample_jboss\">\n+            <title>Deploying Sample To JBoss</title>\n+            <para>\n+      Place the ear file in the <filename>deploy</filename> \n+      directory of your JBoss installation.  You can use the \n+      above hints to view the JNDI tree to see if \n+      <classname>samples.j2ee.ejb.CarHome</classname> was \n+      deployed to JNDI.\n+      </para>\n+          </section>\n+          <section id=\"jpa_j2ee_tutorial_sample_weblogic\">\n+            <title>Deploying Sample To WebLogic 9</title>\n+            <para>\n+      Place the ear file in the <filename>autodeploy</filename>\n+      directory of your WebLogic domain.  Production mode (see your \n+      startWebLogic.sh/cmd file) should be set to false to enable \n+      auto-deployment.  If the application was installed correctly, \n+      you should see <computeroutput>openjpa-persistence-j2ee-sample\n+      </computeroutput> listed in the Deployments section of the admin \n+      console.  In addition you should find <literal>CarHome</literal> \n+      listed in the JNDI tree under \n+      <computeroutput>AdminServer-&gt;samples-&gt;j2ee-&gt;ejb\n+      </computeroutput>.  Ensure that you have added the class\n+      <classname>samples.j2ee.Car</classname> to the\n+      <literal>openjpa.PersistentClasses</literal> OpenJPA configuration\n+      property in the <literal>META-INF/ra.xml</literal> file.\n+      </para>\n+          </section>\n+<!-- TODO \n+    <section id=\"jpa_j2ee_tutorial_sample_weblogic8\">\n+      <title>Deploying Sample To WebLogic 8.1</title>\n+      <para>\n+      Create a new directory named <filename>\n+      openjpa-persistence-j2ee-sample.ear</filename>\n+      in the <filename>applications</filename> directory of\n+      your WebLogic domain.  Extract the EAR file (without copying\n+      the EAR file) to this new directory:\n+      </para>\n+<programlisting>\n+applications> mkdir openjpa-persistence-j2ee-sample.ear\n+applications> cd openjpa-persistence-j2ee-sample.ear\n+openjpa-persistence-j2ee-sample.ear> jar -xvf /path/to/openjpa-persistence-j2ee-sample.ear\n+</programlisting>\n+      <para>\n+      Deploy the application by using the admin console\n+      (Deployments -&gt; Applications -&gt; Deploy a new Application.\n+      Select <literal>openjpa-persistence-j2ee-sample.ear</literal> and \n+      deploy to the proper server targets.  If you have installed the\n+      application correctly, you should find CarHome\n+      listed in the JNDI tree under\n+      <computeroutput>myserver-&gt;samples-&gt;j2ee-&gt;ejb\n+      </computeroutput>.\n+      </para>\n+    </section>\n+    <section id=\"jpa_j2ee_tutorial_sample_sunone\">\n+      <title>Deploying Sample To SunONE / Sun JES</title>\n+      <para>\n+      Browse to the admin console in your web browser. Select \n+      <computeroutput>Applications/ Enterprise Applications\n+      </computeroutput> from the left navigation panel.  Select \n+      <computeroutput>Deploy... </computeroutput> and in the \n+      following screen upload the <filename>\n+      openjpa-persistence-j2ee-sample.ear</filename> \n+      file to the server.  Apply your changes by selecting the \n+      link in the upper right portion of the page.  You should \n+      now see <computeroutput>openjpa-persistence-j2ee-sample\n+      </computeroutput> listed \n+      in the Enterprise Applications folder of the navigation panel.\n+      </para>\n+    </section>\n+    <section id=\"jpa_j2ee_tutorial_sample_jrun\">\n+      <title>Deploying Sample To JRun</title>\n+      <para>\n+      Browse to the admin console in your web browser. Select \n+      <computeroutput>J2EE Components\n+      </computeroutput> from the left navigation panel.  Select \n+      <computeroutput>Add</computeroutput> under the\n+      <computeroutput>Enterprise Applications</computeroutput>\n+      heading. Select the <filename>openjpa-persistence-j2ee-sample.ear\n+      </filename> file and hit <computeroutput>Deploy</computeroutput>.\n+      You should now see <computeroutput>Sample-OpenJPAJ2EE</computeroutput>\n+      listed in the top-level folder of the navigation panel.\n+      Select it, and then select the\n+      <computeroutput>sample-ejb.jar#CarEJB</computeroutput>\n+      component under\n+      <computeroutput>Enterprise JavaBeans</computeroutput>\n+      section, then change the <computeroutput>JNDI Name</computeroutput>\n+      for the bean from the default value to\n+      <computeroutput>samples.j2ee.ejb.CarHome</computeroutput> and hit\n+      <computeroutput>Apply</computeroutput>.\n+      </para>\n+      <para>\n+      If the OpenJPA resource adapter and the sample EAR are both\n+      configured correctly, you should now be able to access\n+      your sample application at JRun's deploy URL (e.g.,\n+      <literal>http://localhost:8100/sample/</literal>).\n+      </para>\n+    </section>\n+    <section id=\"jpa_j2ee_tutorial_sample_websphere\">\n+      <title>Deploying Sample To WebSphere</title>\n+      <para>\n+      Browse to the admin console in your web browser.  Select \n+      <computeroutput>Applications / Install New Application\n+      </computeroutput> from the left navigation panel.  Select \n+      the path to your <filename>openjpa-persistence-j2ee-sample.ear\n+      </filename> file and press <computeroutput>Next</computeroutput>.\n+      </para>\n+      <para>\n+      On the following screen, leave the options at the default \n+      and select <computeroutput>Next</computeroutput>.  On the following\n+      screen (<computeroutput>Install New Application->Step 1\n+      </computeroutput>), ensure that the <computeroutput>Deploy EJBs\n+      </computeroutput> option is checked.  Leave other options at their \n+      defaults.\n+      </para>\n+      <para>\n+      Move on to Step 2.  On this screen enter <literal>\n+      samples.j2ee.ejb.CarHome</literal> as the JNDI name for the \n+      <classname>Car</classname> EJB.  Continue through the \n+      remaining steps leaving options at the defaults.  Select \n+      <computeroutput>Finish</computeroutput> and ensure that \n+      the application is deployed correctly.\n+      </para>\n+      <para>\n+      Save the changes to the domain configuration by either \n+      selecting the <computeroutput>Save</computeroutput> link \n+      that appears after the installation is complete or by \n+      selecting <computeroutput>Save</computeroutput> from the top menu.\n+      </para>\n+      <para>\n+      To verify your installation, select <computeroutput>Applications \n+      / Enterprise Applications</computeroutput> from the left \n+      navigation panel.  <computeroutput>Sample-OpenJPAJ2EE</computeroutput> \n+      should be listed in the list.  If the application has not \n+      started already, select the checkbox next to <computeroutput>\n+      Sample-OpenJPAJ2EE</computeroutput>\n+      and select <computeroutput>Start</computeroutput>.  \n+      </para>\n+    </section>\n+    <section id=\"jpa_j2ee_tutorial_sample_borland\">\n+      <title>Deploying Sample To Borland Enterprise Server 5.2</title>\n+      <para>\n+      Deploy the EAR file using iastool or the console.  Note\n+      that you may have to include the JDO library in your\n+      stub generation process.  Also be sure that you have \n+      followed the JCA instructions for\n+      BES as well as editing the ejb/CarBean.java file to\n+      point to <literal>serial://openjpa-ejb</literal> JNDI location.\n+      You should be able to see the CarEJB located in JNDI\n+      located at the home classname.\n+      </para>\n+    </section>\n+    -->\n+        </section>\n+        <section id=\"jpa_j2ee_tutorial_using\">\n+          <title>Using The Sample Application</title>\n+          <para>\n+    The sample application installs itself into the web layer at the \n+    context root of sample.  By browsing to \n+    <computeroutput>http://yourserver:yourport/openjpa-persistence-j2ee-sample\n+    </computeroutput>, you should be presented with a simple \n+    list page with no cars.  You can edit, add, delete car instances.\n+    In addition, you can query on the underlying <classname>Car</classname>\n+    instances by passing in an JPQL query into the marked form (such as\n+    <computeroutput>select car from Car car where car.featureSelection=\"Some Model\"</computeroutput>).\n+    </para>\n+        </section>\n+        <section id=\"jpa_j2ee_tutorial_architecture\">\n+          <title>Sample Architecture</title>\n+          <para>\n+    The garage application is a simple enterprise application that \n+    demonstrates some of the basic concepts necessary when \n+    using OpenJPA in the enterprise layer.\n+    </para>\n+          <para>\n+    The core featureSelection wraps a stateless session bean facade around \n+    an entity.  Using a session bean provides both a remote interface \n+    for various clients as well as providing a transactional context in \n+    which to work (and thus avoiding any explicit transactional code).  \n+    </para>\n+          <para>\n+    This session bean uses the JPA's detachment \n+    capabilities to provide an automatic Data Transfer Object mechanism\n+    for the primary communication between the\n+    application server and the (possibly remote) client. The <classname>Car\n+    </classname> instance will be used as the primary object upon\n+    which the client will work.\n+    </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para><literal>samples/persistence/j2ee/Car.java</literal>:\n+        The core of the sample application.  This is the \n+        entity class that OpenJPA will use to persist the \n+        application data.  \n+        Instances of this class will also fill the role of \n+        data transfer object (DTO) for EJB clients.  \n+        To accomplish this, <classname>Car</classname> implements \n+        <classname>java.io.Serializable</classname> \n+        so that remote clients can access cars as parameters\n+        and return values from the EJB.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>\n+        samples/persistence/j2ee/jsp/SampleUtilities.java</literal>:\n+        This is a simple facade to aggregate some common J2EE \n+        behavior into some static methods.  \n+        By placing all of the functionality into a single \n+        facade class, we can reduce code maintenance of our JSPs.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>samples/persistence/j2ee/ejb/Car*.java</literal>:\n+        The source for the <classname>CarEJB</classname> session bean.  \n+        Clients can use the <classname>CarHome</classname> \n+        and <classname>CarRemote</classname> interfaces to \n+        find, manipulate, and persist changes to \n+        <classname>Car</classname> transfer object \n+        instances.  By using J2EE transactional features,\n+        the implementation code in <filename>CarBean.java</filename> \n+        can be focused almost entirely upon business and \n+        persistence logic without worrying about transactions. \n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>samples/persistence/j2ee/jsp/*.jsp</literal>:\n+        The web presentation client.  These JSPs are not aware of the\n+        JPA; they simply use the <classname>CarEJB</classname> session \n+        bean and the <classname>Car</classname> transfer object to do \n+        all the work.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>samples/persistence/j2ee/resources/*</literal>:\n+        Files required to deploy to the various appservers, \n+        including J2EE deployment descriptors, WAR/ EJB/ EAR \n+        descriptors, as well as appserver specific files.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>samples/persistence/j2ee/build.xml</literal>:\n+        A simple Ant build file to help in creating a J2EE EAR file.\n+        </para>\n+            </listitem>\n+          </itemizedlist>\n+        </section>\n+        <section id=\"jpa_j2ee_tutorial_notes\">\n+          <title>Code Notes and J2EE Tips</title>\n+          <orderedlist>\n+            <listitem>\n+              <para>\n+        Entity classes are excellent \n+        candidates for the Data Transfer Object Pattern.   \n+        This pattern attempts to reduce network load, as well \n+        as group business logic into concise units.  \n+        For example, <methodname>CarBean.edit</methodname> allows you \n+        to ensure that all values are correct before committing a \n+        transaction, instead of sequentially calling getters and \n+        setters on the session facade.  This is especially true when \n+        using RMI such as from a Swing based application \n+        connecting to an application server.\n+        </para>\n+              <para><classname>CarEJB</classname> works as a session bean facade \n+        to demarcate transactions, provide finder methods, and \n+        encapsulate complex business logic at the server level.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para><methodname>EntityManager.close()</methodname> \n+        should be called at the end of every EJB method.  \n+        In addition to ensuring that your code will not attempt to \n+        access a closed <classname>EntityManager</classname>, it \n+        allows OpenJPA to free up unused resources.\n+        Since an <classname>EntityManager</classname> is created \n+        for every transaction, this can increase the scalability\n+        of your application.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        You should not use <methodname>\n+        EntityManager.getTransaction()</methodname> when using JTA\n+        to manage your transactions. Instead, OpenJPA will integrate with\n+        JTA to automatically govern transactions based on your EJB\n+        transaction configuration.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        While serialization of entity instances is relatively \n+        straightforward, there are several things to keep in mind:\n+        </para>\n+              <itemizedlist>\n+                <listitem>\n+                  <para>\n+            While \"default fetch group\" values will always be \n+            returned to the client upon serialization, lazily \n+            loaded fields will not as the \n+            <classname>EntityManager</classname> will \n+            have been closed before those fields attempt to \n+            serialize.  You can either access those fields \n+            before serialization, configure the fetch type of the\n+            relationships, or configure your JPQL queries to \n+            eagerly fetch data.\n+            </para>\n+                </listitem>\n+              </itemizedlist>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        It is not necessarily required that you use EJBs and \n+        container-managed transactions to demarcate transactions, \n+        although that is probably the most common method.  \n+        In EJBs using bean managed transactions, you can control\n+        transactions through the\n+        <classname>javax.transaction.UserTransaction</classname> interface.\n+        Furthermore, outside of session beans you can control the \n+        JPA layer's transaction via the \n+        <classname>javax.persistence.EntityTransaction</classname> \n+        interface.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para><classname>EntityManager</classname>s are allocated on a \n+        per-Transaction basis. \n+        Calling <methodname>getEntityManager</methodname> from \n+        the same <classname>EntityManagerFactory</classname> \n+        within the same EJB method call will always return the same\n+        entity manager, although the user-visible object may be \n+        proxied, so might not compare equal using the \n+        <literal>==</literal> operator.  \n+        </para>\n+            </listitem>\n+          </orderedlist>\n+        </section>\n+      </section>\n+    </chapter>"},{"sha":"4a24cd98b52b12245554427c0a33959d8235c8ba","filename":"openjpa-project/src/doc/manual/manual.xml","status":"modified","additions":76,"deletions":33819,"changes":33895,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/manual.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/manual.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/manual.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53"},{"sha":"52abf8fbcaf44fc25111433e15db78dcc396a83c","filename":"openjpa-project/src/doc/manual/openjpa_intro.xml","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/openjpa_intro.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/openjpa_intro.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/openjpa_intro.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,61 @@\n+\n+    <chapter id=\"openjpa_intro\">\n+      <title>OpenJPA <phrase>JPA</phrase></title>\n+      <indexterm zone=\"openjpa_intro\">\n+        <primary>OpenJPA <phrase>JPA</phrase></primary>\n+      </indexterm>\n+      <para>\n+  OpenJPA is Apache's implementation of Sun's\n+  <phrase>Java Persistence API (JPA) specification</phrase>\n+  \n+  \n+  for the transparent persistence of Java objects.\n+  This document provides an overview of\n+  <phrase>the JPA standard</phrase>\n+  \n+  \n+  and technical details on the use of OpenJPA <phrase>JPA</phrase>.\n+  </para>\n+      <para>\n+  To quickly get started with JPA, you may want to begin at\n+  <xref linkend=\"jpa_tutorial\"/>.\n+  If you would prefer to start with an introduction to the concepts of JPA,\n+  begin with <xref linkend=\"jpa_overview_intro\"/>.\n+  </para>\n+      <section id=\"openjpa_intro_about\">\n+        <title>About This Document</title>\n+        <para>\n+    This document is intended for OpenJPA users.  It is divided into several \n+    parts:\n+    </para>\n+        <itemizedlist>\n+          <listitem>\n+            <para>\n+        The <link linkend=\"jpa_overview_intro\">JPA Overview</link> \n+        describes the fundamentals of JPA.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        In the <link linkend=\"tutorials\">OpenJPA <phrase>JPA</phrase> \n+        Tutorials</link> you will develop simple persistent applications\n+        using OpenJPA.  Through the tutorials' hands-on approach, you\n+        will become comfortable with the core tools and development\n+        processes under OpenJPA <phrase>JPA</phrase>.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        The <link linkend=\"ref_guide_intro\">OpenJPA <phrase>JPA</phrase> \n+        Reference Guide</link> contains detailed documentation on all \n+        aspects of OpenJPA <phrase>JPA</phrase>.  Browse through this guide to \n+        familiarize yourself with the many advanced features and \n+        customization opportunities OpenJPA provides.  Later, you can use \n+        the guide when you need details on a specific aspect of OpenJPA \n+        <phrase>JPA</phrase>.\n+        </para>\n+          </listitem>\n+        </itemizedlist>\n+      </section>\n+\n+    </chapter>"},{"sha":"709660ab9b92370df79ccda6f48768c05b5f2df5","filename":"openjpa-project/src/doc/manual/ref_guide_caching.xml","status":"added","additions":1088,"deletions":0,"changes":1088,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_caching.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_caching.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_caching.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,1088 @@\n+\n+    <chapter id=\"ref_guide_caching\">\n+      <title>Caching</title>\n+      <para>\n+  OpenJPA utilizes several configurable caches to maximize performance.\n+  This chapter explores OpenJPA's data cache, query cache, and query compilation\n+  cache.\n+  </para>\n+      <section id=\"ref_guide_cache\">\n+        <title>Data Cache</title>\n+        <indexterm zone=\"ref_guide_cache\">\n+          <primary>caching</primary>\n+          <secondary>data cache</secondary>\n+        </indexterm>\n+        <para>\n+  The OpenJPA data cache is an optional cache of persistent object data that\n+  operates at the <classname>EntityManagerFactory</classname>\n+  level. This cache is designed to significantly increase\n+  performance while remaining in full compliance with the JPA\n+  standard. This means that turning on the caching option can\n+  transparently increase the performance of your application, with\n+  no changes to your code.\n+  </para>\n+        \n+        <para>\n+  OpenJPA's data cache is not related to the <classname>EntityManager\n+  </classname> cache dictated by the JPA specification. The JPA \n+  specification mandates behavior for the <classname>EntityManager</classname>\n+  cache aimed at guaranteeing transaction isolation when operating on\n+  persistent objects. \n+  </para>\n+        <para>\n+  OpenJPA's data cache is designed to\n+  provide significant performance increases over cacheless\n+  operation, while guaranteeing that behavior will be\n+  identical in both cache-enabled and cacheless operation.\n+  </para>\n+        <para>\n+  There are five ways to access data via the OpenJPA APIs:\n+  standard relation traversal, large result set relation traversal, \n+  queries, looking up an object by id, and iteration over an \n+  <classname>Extent</classname>. OpenJPA's cache plugin accelerates three of \n+  these mechanisms. It does not provide any caching of large result set \n+  relations or <classname>Extent</classname> iterators. If you find yourself \n+  in need of higher-performance <classname>Extent</classname> iteration, see \n+  <xref linkend=\"ref_guide_cache_limits_extent\"/>.\n+  <table><title>Data access methods</title><tgroup cols=\"2\" align=\"left\" colsep=\"1\" rowsep=\"1\"><colspec colname=\"access-method\"/><colspec colname=\"cacheable\"/><thead><row><entry colname=\"access-method\">Access method</entry><entry colname=\"cacheable\">Uses cache</entry></row></thead><tbody><row><entry colname=\"access-method\">\n+            Standard relation traversal\n+          </entry><entry colname=\"cacheable\">Yes</entry></row><row><entry colname=\"access-method\">\n+            Large result set relation traversal\n+          </entry><entry colname=\"cacheable\">No</entry></row><row><entry colname=\"access-method\">Query</entry><entry colname=\"cacheable\">Yes</entry></row><row><entry colname=\"access-method\">\n+            Lookups by object id\n+          </entry><entry colname=\"cacheable\">Yes</entry></row><row><entry colname=\"access-method\">\n+            Iteration over an <classname>Extent</classname>\n+          </entry><entry colname=\"cacheable\">No</entry></row></tbody></tgroup></table>\n+  </para>\n+        <para>\n+  When enabled, the cache is checked before making a trip to the\n+  datastore. Data is stored in the cache when objects are\n+  committed and when persistent objects are loaded from the\n+  datastore.\n+  </para>\n+        <para>\n+  OpenJPA's data cache can in both single-JVM and multi-JVM environments. \n+  Multi-JVM caching is achieved through the use of the distributed event \n+  notification framework described in <xref linkend=\"ref_guide_event\"/>,\n+  or through one of OpenJPA's integrations with third-party distributed caches\n+  (see <xref linkend=\"ref_guide_datacacheintegrations\"/>).\n+  </para>\n+        <para>\n+  The single JVM mode of operation maintains and shares a data\n+  cache across all <classname>EntityManager</classname>\n+  instances obtained from a particular\n+  <classname>EntityManagerFactory</classname>. This is not\n+  appropriate for use in a distributed environment, as caches in\n+  different JVMs or created from different\n+  <classname>EntityManagerFactory</classname> objects will\n+  not be synchronized.\n+  </para>\n+        <section id=\"ref_guide_cache_conf\">\n+          <title>Data Cache Configuration</title>\n+          <para>\n+    To enable the basic single-factory cache set the\n+    <link linkend=\"openjpa.DataCache\"><literal>openjpa.DataCache</literal></link>\n+    property to <literal>true</literal>, and set the\n+    <link linkend=\"openjpa.RemoteCommitProvider\"><literal>\n+    openjpa.RemoteCommitProvider</literal></link> property to \n+    <literal>sjvm</literal>:\n+    </para>\n+          <example id=\"ref_guide_cache_conf_sjvm\">\n+            <title>Single-JVM Data Cache</title>\n+            <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.DataCache\" value=\"true\"/&gt;\n+&lt;property name=\"openjpa.RemoteCommitProvider\" value=\"sjvm\"/&gt;\n+</programlisting>\n+          </example>\n+          <para>\n+    To configure the data cache to remain up-to-date in a distributed\n+    environment, set the <link linkend=\"openjpa.RemoteCommitProvider\"><literal>\n+    openjpa.RemoteCommitProvider</literal></link> property appropriately, or\n+    integrate OpenJPA with a third-party caching solution.\n+    Remote commit providers are described in\n+    <xref linkend=\"ref_guide_event\"/>.  \n+    <xref linkend=\"ref_guide_datacacheintegrations\"/> enumerates supported\n+    third-party caching solutions.\n+    </para>\n+          <para><indexterm><primary>caching</primary><secondary>size</secondary></indexterm>\n+    OpenJPA's default implementation maintains a least-recently-used map \n+    of object ids to cache data. By default,\n+    1000 elements are kept in cache. This can be adjusted by setting\n+    the <literal>CacheSize</literal> property in your plugin string - see \n+    below for an example.  Objects that are pinned into the cache are not \n+    counted when determining if the cache size exceeds the maximum.\n+    </para>\n+          <para>\n+    Expired objects are moved to a soft reference map, so they may stick \n+    around for a little while longer. You can control\n+    the number of soft references OpenJPA keeps with the <literal>\n+    SoftReferenceSize</literal> property.  Soft references are unlimited by\n+    default.  Set to 0 to disable soft references completely.\n+    </para>\n+          <example id=\"ref_guide_cache_conf_size\">\n+            <title>Data Cache Size</title>\n+            <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.DataCache\" value=\"true(CacheSize=5000, SoftReferenceSize=0)\"/&gt;\n+</programlisting>\n+          </example>\n+          <para><indexterm><primary>caching</primary><secondary>timeout</secondary></indexterm>\n+    You can specify a cache timeout value for a class by setting the \n+    timeout <link linkend=\"ref_guide_meta_ext\">metadata extension</link>\n+    to the amount of time in milliseconds a class's data is valid. Use a \n+    value of -1 for no expiration.  This is the default value.\n+    </para>\n+          <example id=\"ex_timeout_cache\">\n+            <title>Data Cache Timeout</title>\n+            <para>\n+      Timeout <classname>Employee</classname> objects after 10 seconds.\n+      </para>\n+            <programlisting format=\"linespecific\">\n+@Entity\n+@DataCache(timeout=10000)\n+public class Employee\n+{\n+    ...\n+}\n+</programlisting>\n+          </example>\n+          <para>\n+    See the <ulink url=\"../apidocs/org/apache/openjpa/persistence/DataCache.html\"><classname>org.apache.openjpa.persistence.DataCache</classname></ulink> Javadoc\n+    for more information on the <classname>DataCache</classname> annotation.\n+    </para>\n+          <para><indexterm><primary>caching</primary><secondary>cron-style invalidation</secondary></indexterm>\n+    A cache can specify that it should be cleared at certain times\n+    rather than using data timeouts.  The\n+    <literal>EvictionSchedule</literal> property of OpenJPA's \n+    cache implementation accepts a <literal>cron</literal>\n+    style eviction schedule.  The format of this property is a \n+    whitespace-separated list of five tokens, where the \n+    <literal>*</literal> symbol (asterisk), indicates match all.  The \n+    tokens are, in order:\n+    </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>Minute</para>\n+            </listitem>\n+            <listitem>\n+              <para>Hour of Day</para>\n+            </listitem>\n+            <listitem>\n+              <para>Day of Month</para>\n+            </listitem>\n+            <listitem>\n+              <para>Month</para>\n+            </listitem>\n+            <listitem>\n+              <para>Day of Week</para>\n+            </listitem>\n+          </itemizedlist>\n+          <para>\n+    For example, the following <literal>openjpa.DataCache</literal> setting\n+    schedules the default cache to evict values\n+    from the cache at 15 and 45 minutes past 3 PM on Sunday.\n+    </para>\n+          <programlisting format=\"linespecific\">\n+true(EvictionSchedule='15,45 15 * * 1')\n+</programlisting>\n+          <para><indexterm><primary>caching</primary><secondary>named caches</secondary></indexterm>\n+    It is also possible for different persistence-capable classes to use\n+    different caches. This is achieved by specifying a cache name in\n+    a <link linkend=\"ref_guide_meta_ext\">metadata extension</link>.\n+    </para>\n+          <example id=\"ex_non_default_cache\">\n+            <title>Named Data Cache Specification</title>\n+            <programlisting format=\"linespecific\">\n+import org.apache.openjpa.persistence.*;\n+\n+@Entity\n+@DataCache(name=\"small-cache\", timeout=10000)\n+public class Employee\n+{\n+    ...\n+}\n+</programlisting>\n+          </example>\n+          <para>\n+    See the <ulink url=\"../apidocs/org/apache/openjpa/persistence/DataCache.html\"><classname>org.apache.openjpa.persistence.DataCache</classname></ulink> Javadoc\n+    for more information on the <classname>DataCache</classname> annotation.\n+    </para>\n+          <para>\n+    The metadata above will cause instances of the <classname>Employee\n+    </classname> class to be stored in a cache named <literal>\n+    small-cache</literal>. \n+    This <literal>small-cache</literal> cache can be explicitly configured \n+    in the <literal>openjpa.DataCache</literal> plugin string, or can be\n+    implicitly defined, in which case it will take on the same\n+    default configuration properties as the default cache identified\n+    in the <literal>openjpa.DataCache</literal> property.\n+    </para>\n+          <example id=\"ref_guide_cache_named\">\n+            <title>Named Data Cache Configuration</title>\n+            <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.DataCache\" value=\"true, true(Name=small-cache, CacheSize=100)\"/&gt;\n+</programlisting>\n+          </example>\n+        </section>\n+        <section id=\"ref_guide_cache_use\">\n+          <title>Data Cache Usage</title>\n+          <para>\n+    The <literal>org.apache.openjpa.datacache</literal> package defines OpenJPA's\n+    data caching framework.  While you may use this framework directly\n+    (see its <ulink url=\"../apidocs/org/apache/openjpa/datacache/package-summary.html\">\n+    Javadoc</ulink> for details), its APIs are meant primarily for \n+    service providers.  In fact, <xref linkend=\"ref_guide_cache_extension\"/>\n+    below has tips on how to use this package to extend OpenJPA's caching \n+    service yourself.\n+    </para>\n+          <para>\n+    Rather than use the low-level <literal>org.apache.openjpa.datacache</literal>\n+    package APIs, JPA users should typically access the data \n+    cache through OpenJPA's high-level \n+    <ulink url=\"../../api/openjpa/persistence/StoreCache.html\"><classname>org.apache.openjpa.persistence.StoreCache</classname></ulink> facade.  \n+    This facade has methods to pin and unpin records, evict data from the \n+    cache, and more.  \n+    </para>\n+          <programlisting format=\"linespecific\">\n+public StoreCache getStoreCache ();\n+public StoreCache getStoreCache (String name);\n+</programlisting>\n+          <para>\n+    You obtain the <classname>StoreCache</classname> through the\n+    <methodname>OpenJPAEntityManagerFactory.getStoreCache</methodname> methods.\n+    When you have multiple data caches configured as in the \n+    <literal>small-cache</literal> example above, the <classname>\n+    StoreCache</classname> can act as a unified facade over all your\n+    caches.  For every oid parameter to the <classname>StoreCache\n+    </classname> methods, it determines the correct data cache for that \n+    oid's corresponding persistent class, and dynamically delegates to \n+    that cache.\n+    </para>\n+          <para>\n+    If you know that you want to access a certain data cache and no others,\n+    the <ulink url=\"../../api/openjpa/persistence/OpenJPAEntityManagerFactory.html\"><methodname>OpenJPAEntityManagerFactory.getStoreCache(String name)\n+    </methodname></ulink> method returns a <classname>StoreCache</classname>\n+    interface to a particular named data cache.\n+    </para>\n+          <example id=\"ref_guide_cache_access_ejb\">\n+            <title>Accessing the StoreCache</title>\n+            <programlisting format=\"linespecific\">\n+import org.apache.openjpa.persistence.*;\n+\n+...\n+\n+OpenJPAEntityManagerFactory kemf = OpenJPAPersistence.cast (emf);\n+StoreCache cache = kemf.getStoreCache ();\n+...\n+StoreCache smallCache = kemf.getStoreCache (\"small-cache\");\n+...\n+</programlisting>\n+          </example>\n+          <programlisting format=\"linespecific\">\n+public void evict (Class cls, Object oid);\n+public void evictAll ();\n+public void evictAll (Class cls, Object... oids);\n+public void evictAll (Class cls, Collection oids);\n+</programlisting>\n+          <para>\n+    The <methodname>evict</methodname> methods tell the cache to release \n+    data.  Each method takes an entity class and one or more identity \n+    values, and releases the cached data for the corresponding persistent \n+    instances.  The <methodname>evictAll</methodname> method with no \n+    arguments clears the cache.  Eviction is useful when the datastore is \n+    changed by a separate process outside OpenJPA's control.  In this \n+    scenario, you typically\n+    have to manually evict the data from the datastore cache; otherwise the\n+    OpenJPA runtime, oblivious to the changes, will maintain its stale copy.\n+    </para>\n+          <programlisting format=\"linespecific\">\n+public void pin (Class cls, Object oid);\n+public void pinAll (Class cls, Object... oids);\n+public void pinAll (Class cls, Collection oids);\n+public void unpin (Class cls, Object oid);\n+public void unpinAll (Class cls, Object... oids);\n+public void unpinAll (Class cls, Collection oids);\n+</programlisting>\n+          <para>\n+    Most caches are of limited size.  Pinning an identity to the cache\n+    ensures that the cache will mill not kick the data for the corresponding\n+    instance out of the cache, unless you manually evict it.  Note that even\n+    after manual eviction, the data will get pinned again the next time it \n+    is fetched from the store.  You can only remove a pin and make the data\n+    once again available for normal cache overflow eviction through the\n+    <methodname>unpin</methodname> methods.  Use pinning when you want a \n+    guarantee that a certain object will always be available from cache, \n+    rather than requiring a datastore trip.\n+    </para>\n+          <example id=\"ref_guide_cache_use_ejb\">\n+            <title>StoreCache Usage</title>\n+            <programlisting format=\"linespecific\">\n+import org.apache.openjpa.persistence.*;\n+\n+...\n+\n+OpenJPAEntityManagerFactory kemf = OpenJPAPersistence.cast (emf);\n+StoreCache cache = kemf.getStoreCache ();\n+cache.pin (Magazine.class, popularMag.getId ());\n+cache.evict (Magazine.class, changedMag.getId ());\n+</programlisting>\n+          </example>\n+          <para>\n+    See the <classname>StoreCache</classname> \n+    <ulink url=\"../../api/openjpa/persistence/StoreCache.html\">Javadoc</ulink>\n+    for information on additional functionality it provides.\n+    Also, <xref linkend=\"ref_guide_runtime\"/> discusses OpenJPA's other \n+    extensions to the standard set of JPA runtime interfaces.\n+    </para>\n+          <para>\n+    The examples above include calls to <methodname>evict</methodname> to\n+    manually remove data from the data cache.  Rather than evicting objects \n+    from the data cache directly, you can also configure OpenJPA to \n+    automatically evict objects from the data cache when\n+    you use the <classname>OpenJPAEntityManager</classname>'s eviction APIs.\n+    </para>\n+          <example id=\"ref_guide_cache_pmevict\">\n+            <title>Automatic Data Cache Eviction</title>\n+            <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.BrokerImpl\" value=\"EvictFromDataCache=true\"/&gt;\n+</programlisting>\n+            <programlisting format=\"linespecific\">\n+import org.apache.openjpa.persistence.*;\n+\n+...\n+\n+OpenJPAEntityManager kem = OpenJPAPersistence.cast (em);\n+kem.evict (changedMag);  // will evict from data cache also\n+</programlisting>\n+          </example>\n+        </section>\n+        <section id=\"ref_guide_cache_query\">\n+          <title>Query Cache</title>\n+          <indexterm zone=\"ref_guide_cache_query\">\n+            <primary>caching</primary>\n+            <secondary>query cache</secondary>\n+          </indexterm>\n+          <indexterm zone=\"ref_guide_cache_query\">\n+            <primary>Query</primary>\n+            <secondary>result caching</secondary>\n+          </indexterm>\n+          <para>\n+    In addition to the data cache, the <literal>org.apache.openjpa.datacache</literal>\n+    package defines service provider interfaces for a query cache.\n+    The query cache is enabled by default when the data cache\n+    is enabled. The query cache stores the object ids returned by\n+    query executions. When you run a query, OpenJPA assembles a key based on\n+    the query properties and the parameters used at execution time,\n+    and checks for a cached query result. If one is found, the\n+    object ids in the cached result are looked up, and the resultant\n+    persistence-capable objects are returned. Otherwise, the query\n+    is executed against the database, and the object ids loaded by\n+    the query are put into the cache. The object id list is not\n+    cached until the list returned at query execution time is fully\n+    traversed.\n+    </para>\n+          <para>\n+    OpenJPA exposes a high-level interface to the query cache through\n+    the <ulink url=\"../../api/openjpa/persistence/QueryResultCache.html\"><classname>org.apache.openjpa.persistence.QueryResultCache</classname></ulink> class.\n+    You can access this class through the <classname>\n+    OpenJPAEntityManagerFactory</classname>.\n+    </para>\n+          <example id=\"ref_guide_cache_queryaccess\">\n+            <title>Accessing the QueryResultCache</title>\n+            <programlisting format=\"linespecific\">\n+import org.apache.openjpa.persistence.*;\n+\n+...\n+\n+OpenJPAEntityManagerFactory kemf = OpenJPAPersistence.cast (emf);\n+QueryResultCache qcache = kemf.getQueryResultCache ();\n+</programlisting>\n+          </example>\n+          <para>\n+    The default query cache implementation caches 100 query\n+    executions in a least-recently-used cache. This can be changed\n+    by setting the cache size in the <literal>CacheSize</literal>\n+    plugin property.  Like the data cache, the query cache also has a\n+    backing soft reference map.  The <literal>SoftReferenceSize</literal>\n+    property controls the size of this map.  It is disabled by default.\n+    </para>\n+          <example id=\"ref_guide_cache_cachesize\">\n+            <title>Query Cache Size</title>\n+            <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.QueryCache\" value=\"CacheSize=1000, SoftReferenceSize=100\"/&gt;\n+</programlisting>\n+          </example>\n+          <para>\n+    To disable the query cache completely, set the \n+    <literal>openjpa.QueryCache</literal> property to <literal>false</literal>:\n+    </para>\n+          <example id=\"ref_guide_cache_disablequery\">\n+            <title>Disabling the Query Cache</title>\n+            <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.QueryCache\" value=\"false\"/&gt;\n+</programlisting>\n+          </example>\n+          <para>\n+    There are certain situations in which the query cache is bypassed:\n+    </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+        Caching is not used for in-memory queries (queries in which \n+        the candidates are a collection instead of a class or \n+        <classname>Extent</classname>).\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        Caching is not used in transactions that have \n+        <literal>IgnoreChanges</literal> set to <literal>false</literal>\n+        and in which modifications to classes in the query's access \n+        path have occurred. If none of the classes in the access path \n+        have been touched, then cached results are still valid and\n+        are used.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        Caching is not used in pessimistic transactions, since OpenJPA \n+        must go to the database to lock the appropriate rows.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        Caching is not used when the the data cache does not have any\n+        cached data for an id in a query result.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        Queries that use persistence-capable objects as parameters are\n+        only cached if the parameter is directly compared to field,\n+        as in:\n+        </para>\n+              <programlisting format=\"linespecific\">\n+select e from Employee e where e.company.address = :addr\n+</programlisting>\n+              <para>\n+        If you extract field values from the parameter in your query\n+        string, or if the parameter is used in collection element\n+        comparisons, the query is not cached.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        Queries that result in projections of custom field types or\n+        <classname>BigDecimal</classname> or \n+        <classname>BigInteger</classname> fields are not cached.\n+        </para>\n+            </listitem>\n+          </itemizedlist>\n+          <para>\n+    Cache results are removed from the cache when instances of\n+    classes in a cached query's access path are touched. That is, if\n+    a query accesses data in class <classname>A</classname>, and instances \n+    of class <classname>A</classname> are modified, deleted, or inserted, \n+    then the cached query result is dropped from the cache.\n+    </para>\n+          <para>\n+    It is possible to tell the query cache that a class has been altered. \n+    This is only necessary when the changes occur via direct modification \n+    of the database outside of OpenJPA's control.  You can also evict \n+    individual queries, or clear the entire cache.\n+    </para>\n+          <programlisting format=\"linespecific\">\n+public void evict (Query q);\n+public void evictAll (Class cls);\n+public void evictAll ();\n+</programlisting>\n+          <para>\n+    For JPA queries with parameters, set the desired parameter values\n+    into the <ulink url=\"http://java.sun.com/javaee/5/docs/api/javax/persistence/Query.html\"><classname>Query</classname></ulink> instance before calling the\n+    above methods.\n+    </para>\n+          <example id=\"ref_guide_cache_query_classchange\">\n+            <title>Evicting Queries</title>\n+            <programlisting format=\"linespecific\">\n+import org.apache.openjpa.persistence.*;\n+\n+...\n+\n+OpenJPAEntityManagerFactory kemf = OpenJPAPersistence.cast (emf);\n+QueryResultCache qcache = kemf.getQueryResultCache ();\n+\n+// evict all queries that can be affected by changes to Magazines\n+qcache.evictAll (Magazine.class);\n+\n+// evict an individual query with parameters\n+EntityManager em = emf.createEntityManager ();\n+Query q = em.createQuery (...).\n+    setParameter (0, paramVal0).\n+    setParameter (1, paramVal1);\n+qcache.evict (q);\n+</programlisting>\n+          </example>\n+          <para>\n+    When using one of OpenJPA's distributed cache implementations, it is\n+    necessary to perform this in every JVM - the change notification is \n+    not propagated automatically. When using a coherent cache \n+    implementation such as OpenJPA's Tangosol cache implementation, it is not \n+    necessary to do this in every JVM (although it won't hurt to do so), \n+    as the cache results are stored directly in the coherent cache.\n+    </para>\n+          <para>\n+    Queries can also be pinned and unpinned\n+    through the <classname>QueryResultCache</classname>.  The semantics of\n+    these operations are the same as pinning and unpinning data from the\n+    data cache.\n+    </para>\n+          <programlisting format=\"linespecific\">\n+public void pin (Query q);\n+public void unpin (Query q);\n+</programlisting>\n+          <para>\n+    For JPA queries with parameters, set the desired parameter values\n+    into the <ulink url=\"http://java.sun.com/javaee/5/docs/api/javax/persistence/Query.html\"><classname>Query</classname></ulink> instance before calling the\n+    above methods.\n+    </para>\n+          <para>\n+    The following example shows these APIs in action.\n+    </para>\n+          <example id=\"ref_guide_cache_query_pin\">\n+            <title>Pinning, and Unpinning Query Results</title>\n+            <programlisting format=\"linespecific\">\n+import org.apache.openjpa.persistence.*;\n+\n+...\n+\n+OpenJPAEntityManagerFactory kemf = OpenJPAPersistence.cast (emf);\n+QueryResultCache qcache = kemf.getQueryResultCache ();\n+EntityManager em = emf.createEntityManager ();\n+\n+Query pinQuery = em.createQuery (...).\n+    setParameter (0, paramVal0).\n+    setParameter (1, paramVal1);\n+qcache.pin (pinQuery);\n+Query unpinQuery = em.createQuery (...).\n+    setParameter (0, paramVal0).\n+    setParameter (1, paramVal1);\n+qcache.unpin (unpinQuery);\n+</programlisting>\n+          </example>\n+          <para>\n+    Pinning data into the cache instructs the cache to not expire the \n+    pinned results when cache flushing occurs. However, pinned results \n+    will be removed from the cache if an event occurs that invalidates the \n+    results.\n+    </para>\n+<!--\n+    ### known issues:\n+      - timeouts of query cache data based on access path timeouts\n+      - distributed cache\n+        - fire class change notifications\n+      - tangosol\n+        - either fire ccn's or store queries in cache\n+      - access path\n+    -->\n+          <para>\n+    You can disable caching on a per-<classname>EntityManager\n+    </classname> or per-<classname>Query</classname> basis:\n+    </para>\n+          <example id=\"ref_guide_cache_query_disable\">\n+            <title>Disabling and Enabling Query Caching</title>\n+            <programlisting format=\"linespecific\">\n+import org.apache.openjpa.persistence.*;\n+\n+...\n+\n+// temporarily disable query caching for all queries created from em\n+OpenJPAEntityManager kem = OpenJPAPersistence.cast (em);\n+kem.getFetchPlan ().setQueryResultCache (false);\n+\n+// re-enable caching for a particular query\n+OpenJPAQuery kq = kem.createQuery (...);\n+kq.getFetchPlan ().setQueryResultCache (true);\n+</programlisting>\n+            <programlisting format=\"linespecific\">\n+import org.apache.openjpa.jdo.*;\n+\n+...\n+\n+// temporarily disable query caching for all queries created from pm\n+PersistenceManager pm = ...;\n+OpenJPAFetchPlan fetch = (OpenJPAFetchPlan) pm.getFetchPlan ();\n+fetch.setQueryResultCache (false);\n+\n+// re-enable caching for a particular query\n+Query q = pm.newQuery (...);\n+OpenJPAFetchPlan fetch = OpenJPAJDOHelper.cast (pm.getFetchPlan ());\n+fetch.setQueryResultCache (true);\n+</programlisting>\n+          </example>\n+        </section>\n+        <section id=\"ref_guide_cache_concurrent\">\n+          <title>The Concurrent Data Cache</title>\n+          <para>\n+    The <emphasis>concurrent</emphasis> is a new data cache plugin for OpenJPA.\n+    It has not been as thoroughly tested as OpenJPA's standard data cache. \n+    The concurrent cache can, however, offer considerably greater \n+    performance and scalability characteristics compared to the standard \n+    cache when the following conditions are met:  \n+    </para>\n+          <orderedlist>\n+            <listitem>\n+              <para>\n+        The cache is big enough to hold all of your commonly-used data.  \n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        Your application is heavily concurrent.\n+        </para>\n+            </listitem>\n+          </orderedlist>\n+          <para>\n+    Additionally, this cache does not fully index its contents by class,\n+    but rather just keeps track of which clasess are in the cache. It \n+    services requests to drop given classes by checking to see if any \n+    instances of that class might be in the cache, and then clearing the\n+    entire cache. This inefficiency can easily be worked around with careful\n+    cache partitioning.\n+    </para>\n+          <para>\n+    To use the concurrent data cache instead of the standard data cache, \n+    set your <literal>openjpa.DataCache</literal> property to \n+    <literal>concurrent</literal> instead of <literal>true</literal>.\n+    Or, you can mix concurrent and standard caches in a set of named\n+    caches.\n+    </para>\n+          <para>\n+    The concurrent cache has the following configuration parameters:\n+    </para>\n+          <orderedlist>\n+            <listitem>\n+              <para><literal>CacheSize</literal>: The maximum number of \n+        objects that this cache will hold. The default is 1000 objects. \n+        This setting differs from the setting for the default data cache\n+        in that instances that are pinned into cache do count towards \n+        this limit.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>Name</literal>: The unique name of the cache.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>EvictionSchedule</literal>: A cron-style eviction\n+        schedule that this cache should follow.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>LRUThresholdRatio</literal>: The ratio above which \n+        this implementation should start applying its \n+        least-recently-used algorithm to prepare for eviction should \n+        the need arise. Default is 80%. Values should be integers \n+        between 1 and 100.\n+        </para>\n+            </listitem>\n+          </orderedlist>\n+          <example id=\"ref_guide_cache_concurrent_conf\">\n+            <title>Concurrent Data Cache Configuration</title>\n+            <para>\n+      The following configuration uses the standard OpenJPA cache as the\n+      primary cache and a named concurrent cache as a secondary cache.\n+      Various classes can be configured to use this secondary cache in\n+      their metadata.\n+      </para>\n+            <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.DataCache\" value=\"true, concurrent(Name=secondary)\"/&gt;\n+</programlisting>\n+          </example>\n+        </section>\n+        <section id=\"ref_guide_datacacheintegrations\">\n+          <title>Third-Party Integrations</title>\n+          <para>\n+    OpenJPA includes built-in integrations with Tangosol Coherence and\n+    GemStone GemFire caching products.\n+    </para>\n+          <section id=\"ref_guide_cache_tangosol\">\n+            <title>Tangosol Integration</title>\n+            <indexterm zone=\"ref_guide_cache_tangosol\">\n+              <primary>caching</primary>\n+              <secondary>tangosol integration</secondary>\n+            </indexterm>\n+            <para>\n+      The OpenJPA data cache can integrate with Tangosol's Coherence caching\n+      system.  To use Tangosol integration, set the \n+      <link linkend=\"openjpa.DataCache\"><literal>openjpa.DataCache</literal></link> configuration property to <literal>tangosol</literal>, with\n+      the appropriate plugin properties for your Tangosol setup.  For \n+      example:\n+      </para>\n+            <example id=\"ref_guide_cache_tangosol_conf\">\n+              <title>Tangosol Cache Configuration</title>\n+              <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.DataCache\" value=\"tangosol(TangosolCacheName=openjpa)\"/&gt;\n+</programlisting>\n+            </example>\n+            <para>\n+      The Tangosol cache understands the following properties:\n+      </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para><literal>TangosolCacheName</literal>: The name of the \n+          Tangosol Coherence cache to use.  Defaults to \n+          <literal>openjpa</literal>.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>TangosolCacheType</literal>: The type of Tangosol \n+          Coherence cache to use (optional).  Valid values are\n+          <literal>named</literal>, <literal>distributed</literal>, or\n+          <literal>replicated</literal>. Defaults to <literal>\n+          named</literal>, which means that the cache is looked \n+          up via the <literal>\n+          com.tangosol.net.CacheFactory.getCache(String)</literal>\n+          method. This method looks up the cached by name as\n+          defined in the Coherence configuration.\n+          </para>\n+                <note>\n+                  <para>\n+            As of this writing, it is not possible to use a Tangosol\n+            Coherence 1.2.2 distributed cache type with Apple's OS X\n+            1.3.1 JVM. Use their replicated cache instead.\n+            </para>\n+                </note>\n+              </listitem>\n+              <listitem>\n+                <para><literal>ClearOnClose</literal>: Whether the Tangosol\n+          named cache should be completely cleared when the\n+          <phrase><classname>EntityManagerFactory</classname></phrase>\n+          \n+          \n+          is closed.  Defaults to <literal>false</literal>.\n+          </para>\n+              </listitem>\n+            </itemizedlist>\n+            <para>\n+      The OpenJPA query cache can also integrate with Tangosol's Coherence \n+      caching system.  To use Tangosol query cache integration, set the \n+      <link linkend=\"openjpa.QueryCache\"><literal>openjpa.QueryCache</literal></link> configuration property to <literal>tangosol</literal>, \n+      with the appropriate plugin properties for your Tangosol setup.  \n+      For example:\n+      </para>\n+            <example id=\"ref_guide_cache_tangosol_query_conf\">\n+              <title>Tangosol Query Cache Configuration</title>\n+              <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.QueryCache\" value=\"tangosol(TangosolCacheName=openjpa-query)\"/&gt;\n+</programlisting>\n+            </example>\n+            <para>\n+      The Tangosol query cache understands the same properties as the \n+      data cache, with a default Tangosol cache name of \n+      <literal>openjpa-query</literal>.\n+      </para>\n+          </section>\n+          <section id=\"ref_guide_cache_gemfire\">\n+            <title>GemStone GemFire Integration</title>\n+            <para>\n+      The OpenJPA data cache can integrate with GemStone's GemFire v3.5.1\n+      caching system.\n+      later. To use GemFire in OpenJPA you will need to change your\n+      <literal>gemfire.properties</literal> to have the property \n+      <literal>enable-shared-memory=true</literal>.  You will also need \n+      to add both OpenJPA and GemFire to your classpath and then start \n+      a GemFire server.\n+      </para>\n+            <programlisting format=\"linespecific\">\n+prompt&gt; gemfire start\n+</programlisting>\n+            <para>\n+      By default, the GemFire data cache will use a GemFire region of \n+      <literal>root/openjpa-data-cache</literal> and the GemFire query cache \n+      will use a region of <literal>root/openjpa-query-cache</literal>. This \n+      can be changed be setting the optional property \n+      <literal>GemFireCacheName</literal>. \n+      </para>\n+            <example id=\"ref_guide_datacacheintegrations_gemfire_conf\">\n+              <title>GemFire Cache Configuration</title>\n+              <para><filename>persistence.xml</filename>:\n+        </para>\n+              <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.DataCache\" \n+    value=\"gemfire(GemFireCacheName=/root/my-openjpa-data-cache)\"/&gt;\n+&lt;property name=\"openjpa.QueryCache\" \n+    value=\"gemfire(GemFireCacheName=/root/my-openjpa-query-cache)\"/&gt;\n+</programlisting>\n+              <para>GemFire <filename>cache.xml</filename>:</para>\n+              <programlisting format=\"linespecific\">\n+...\n+    &lt;shared-root-region name=\"root\"&gt;\n+        &lt;region-attributes&gt;\n+        ...\n+        &lt;/region-attributes&gt;\n+        &lt;region name=\"My-openjpa-data-cache\"&gt;\n+            &lt;region-attributes&gt;\n+            &lt;/region-attributes&gt;\n+        &lt;/region&gt;\n+        &lt;region name=\"My-openjpa-query-cache\"&gt;\n+            &lt;region-attributes&gt;\n+            &lt;/region-attributes&gt;\n+        &lt;/region&gt;\n+    &lt;/shared-root-region&gt;\n+    ...\n+</programlisting>\n+            </example>\n+            <para>\n+      If you set GemFire for both <literal>openjpa.DataCache</literal> and \n+      <literal>openjpa.QueryCache</literal> you aren't required to \n+      specify a <literal>openjpa.RemoteCommitProvider</literal> unless you \n+      are registering your own <classname>\n+      RemoteCommitListener</classname>s.\n+      </para>\n+            <para>\n+      Some notes regarding using GemFire with OpenJPA:\n+      </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para>\n+          Custom field types mapped with externalizers or custom \n+          mappings must be serializable.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para>\n+          The <link linkend=\"openjpa.DynamicDataStructs\"><literal>\n+          openjpa.DynamicDataStructs</literal></link> option\n+          is not supported.\n+          </para>\n+              </listitem>\n+            </itemizedlist>\n+          </section>\n+        </section>\n+        <section id=\"ref_guide_cache_extension\">\n+          <title>Cache Extension</title>\n+          <indexterm zone=\"ref_guide_cache_extension\">\n+            <primary>caching</primary>\n+            <secondary>data cache</secondary>\n+            <tertiary>extension</tertiary>\n+          </indexterm>\n+          <indexterm zone=\"ref_guide_cache_extension\">\n+            <primary>caching</primary>\n+            <secondary>query cache</secondary>\n+            <tertiary>extension</tertiary>\n+          </indexterm>\n+          <para>\n+    The provided data cache classes can be easily extended to\n+    add additional functionality. If you are adding new behavior,\n+    you should extend <classname>org.apache.openjpa.datacache.DataCacheImpl</classname>. \n+    To use your own storage mechanism, extend\n+    <classname>org.apache.openjpa.datacache.AbstractDataCache</classname>, or implement\n+    <classname>org.apache.openjpa.datacache.DataCache</classname> directly.\n+    If you want to implement a distributed cache that uses an\n+    unsupported method for communications, create an implementation\n+    of <classname>org.apache.openjpa.event.RemoteCommitProvider</classname>. This \n+    process is described in greater detail in \n+    <xref linkend=\"ref_guide_event_customization\"/>.\n+    </para>\n+          <para>\n+    The query cache is just as easy to extend.  Add functionality by \n+    extending the default \n+    <classname>org.apache.openjpa.datacache.QueryCacheImpl</classname>.  Implement your\n+    own storage mechanism for query results by extending \n+    <classname>org.apache.openjpa.datacache.AbstractQueryCache</classname> or implementing\n+    the <classname>org.apache.openjpa.datacache.QueryCache</classname> interface directly.\n+    </para>\n+        </section>\n+        <section id=\"ref_guide_cache_notes\">\n+          <title>Important Notes</title>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+        The default cache implementations <emphasis>do not</emphasis> \n+        automatically refresh objects in other <classname>\n+        EntityManager</classname>s\n+        when the cache is updated or invalidated. This behavior would \n+        not be compliant with the JPA specification.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        Invoking <methodname>OpenJPAEntityManager.evict</methodname>\n+        <emphasis>does not</emphasis> result in\n+        the corresponding data being dropped from the data cache, unless\n+        you have set the proper configuration options as explained \n+        above (see <xref linkend=\"ref_guide_cache_pmevict\"/>).  Other \n+        methods related to the <classname>EntityManager</classname>\n+        cache also do not effect the data cache.\n+        </para>\n+              <para>\n+        The data cache \n+        assumes that it is up-to-date with respect to the datastore, \n+        so it is effectively an in-memory extension of the database. To \n+        manipulate the data cache, you should generally use the data\n+        cache facades presented in this chapter.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        You must specify a <classname>org.apache.openjpa.event.RemoteCommitProvider\n+        </classname> (via the <link linkend=\"openjpa.RemoteCommitProvider\"><literal>openjpa.RemoteCommitProvider</literal></link> \n+        property) in order to use the data cache, even when using the \n+        cache in a single-JVM mode.  When using it in a single-JVM \n+        context, set this property to <literal>sjvm</literal>.\n+        </para>\n+            </listitem>\n+          </itemizedlist>\n+        </section>\n+        <section id=\"datastore_cache_issues\">\n+          <title>Known Issues and Limitations</title>\n+          <indexterm zone=\"datastore_cache_issues\">\n+            <primary>caching</primary>\n+            <secondary>issues and limitations</secondary>\n+          </indexterm>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+        When using datastore (pessimistic) transactions in concert \n+        with the distributed caching implementations, it is possible \n+        to read stale data when reading data outside a transaction.\n+        </para>\n+              <para>\n+        For example, if you have two JVMs (JVM A and JVM B) both \n+        communicating with each other, and JVM A obtains a data\n+        store lock on a particular object's underlying data, it is\n+        possible for JVM B to load the data from the cache without\n+        going to the datastore, and therefore load data that should\n+        be locked. This will only happen if JVM B attempts to read\n+        data that is already in its cache during the period between\n+        when JVM A locked the data and JVM B received and processed\n+        the invalidation notification.\n+        </para>\n+              <para>\n+        This problem is impossible to solve without putting together a \n+        two-phase commit system for cache notifications, which would \n+        add significant overhead to the caching implementation. As a \n+        result, we recommend that people use optimistic locking when \n+        using data caching. If you do not, then understand that some \n+        of your non-transactional data may not be consistent with the \n+        datastore.\n+        </para>\n+              <para>\n+        Note that when loading objects in a transaction, the \n+        appropriate datastore transactions will be obtained. So,\n+        transactional code will maintain its integrity.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para><classname>Extent</classname>s are not cached. So, if you plan \n+        on iterating over a list of all the objects in an \n+        <classname>Extent</classname> on a regular basis, you will \n+        only benefit from caching if you do so with a \n+        <classname>Query</classname> instead:\n+        </para>\n+              <example id=\"ref_guide_cache_limits_extent\">\n+                <title>Query Replaces Extent</title>\n+                <programlisting format=\"linespecific\">\n+import org.apache.openjpa.persistence.*;\n+\n+...\n+\n+OpenJPAEntityManager kem = OpenJPAPersistence.cast (em);\n+Extent extent = kem.getExtent (Magazine.class, false);\n+\n+// This iterator does not benefit from caching...\n+Iterator uncachedIterator = extent.iterator ();\n+\n+// ... but this one does.\n+OpenJPAQuery extentQuery = kem.createQuery (...);\n+extentQuery.setSubclasses (false);\n+Iterator cachedIterator = extentQuery.getResultList ().iterator ();\n+</programlisting>\n+              </example>\n+            </listitem>\n+          </itemizedlist>\n+        </section>\n+      </section>\n+      <section id=\"ref_guide_cache_querycomp\">\n+        <title>Query Compilation Cache</title>\n+        <indexterm zone=\"ref_guide_cache_querycomp\">\n+          <primary>caching</primary>\n+          <secondary>query compilation cache</secondary>\n+        </indexterm>\n+        <para>\n+    The query compilation cache is a <classname>Map</classname> used to\n+    cache parsed query strings.  As a result, most queries are\n+    only parsed once in OpenJPA, and cached thereafter.  You can control the\n+    compilation cache through the \n+    <link linkend=\"openjpa.QueryCompilationCache\"><literal>\n+    openjpa.QueryCompilationCache</literal></link> configuration property.\n+    This property accepts a plugin string (see \n+    <xref linkend=\"ref_guide_conf_plugins\"/>) describing the\n+    <classname>Map</classname> used to associate query strings and their \n+    parsed form.  This property accepts the following aliases:\n+    </para>\n+        <table>\n+          <title>Pre-defined aliases</title>\n+          <tgroup cols=\"2\" align=\"left\" colsep=\"1\" rowsep=\"1\">\n+            <colspec colname=\"alias\"/>\n+            <colspec colname=\"value\"/>\n+            <colspec colname=\"notes\"/>\n+            <thead>\n+              <row>\n+                <entry colname=\"alias\">Alias</entry>\n+                <entry colname=\"value\">Value</entry>\n+                <entry colname=\"notes\">Notes</entry>\n+              </row>\n+            </thead>\n+            <tbody>\n+              <row>\n+                <entry colname=\"alias\">\n+                  <literal>true</literal>\n+                </entry>\n+                <entry colname=\"value\">\n+                  <literal>openjpa.util.CacheMap</literal>\n+                </entry>\n+                <entry colname=\"notes\">\n+              The default option.  Uses a \n+              <ulink url=\"../apidocs/org/apache/openjpa/util/CacheMap.html\"><literal>CacheMap</literal></ulink> to store \n+              compilation data.  <literal>CacheMap</literal> uses\n+              a least-recently-used strategy for a fixed number \n+              of cache entries, and an optional soft reference \n+              map for entries that are moved out of the LRU \n+              space. So, for applications that have a \n+              monotonically increasing number of distinct queries,\n+              this option can be used to ensure that a fixed \n+              amount of memory is used by the cache.\n+            </entry>\n+              </row>\n+              <row>\n+                <entry colname=\"alias\">\n+                  <literal>all</literal>\n+                </entry>\n+                <entry colname=\"value\">\n+                  <literal>java.util.HashMap</literal>\n+                </entry>\n+                <entry colname=\"notes\">\n+              This is the fastest option, but compilation data is\n+              never dropped from the cache, so if you use a large \n+              number of dynamic queries, this option may result in\n+              ever-increasing memory usage. Note that if your \n+              queries only differ in the values of the parameters,\n+              this should not be an issue.\n+            </entry>\n+              </row>\n+              <row>\n+                <entry colname=\"alias\">\n+                  <literal>false</literal>\n+                </entry>\n+                <entry colname=\"value\">\n+                  <emphasis>none</emphasis>\n+                </entry>\n+                <entry colname=\"notes\">\n+              Disables the compilation cache.\n+            </entry>\n+              </row>\n+            </tbody>\n+          </tgroup>\n+        </table>\n+      </section>\n+    </chapter>"},{"sha":"a15975edc9e0d3c3d602fe8a6e2d7acf628485ab","filename":"openjpa-project/src/doc/manual/ref_guide_conf.xml","status":"added","additions":2954,"deletions":0,"changes":2954,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_conf.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_conf.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_conf.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53"},{"sha":"5f290218cbc55b8e6a12f70aefdfc24a0abe84dd","filename":"openjpa-project/src/doc/manual/ref_guide_dbsetup.xml","status":"added","additions":2861,"deletions":0,"changes":2861,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_dbsetup.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_dbsetup.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_dbsetup.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53"},{"sha":"2a8b8bdfb531f02c246e11fa09eddf8299a88438","filename":"openjpa-project/src/doc/manual/ref_guide_deploy.xml","status":"added","additions":224,"deletions":0,"changes":224,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_deploy.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_deploy.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_deploy.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,224 @@\n+\n+    <chapter id=\"ref_guide_deploy\">\n+      <title>Deployment</title>\n+      <para>\n+  OpenJPA deployment includes choosing a factory deployment strategy,\n+  and in a managed environment, optionally integrating with your application\n+  server's managed and XA transactions.  This chapter examines each aspect\n+  of deployment in turn.\n+  </para>\n+      <section id=\"ref_guide_deploy_factory\">\n+        <title>Factory Deployment</title>\n+        <para>\n+    OpenJPA offers several \n+    <phrase><classname>EntityManagerFactory</classname></phrase>\n+    \n+    \n+    deployment options.\n+    </para>\n+        <section id=\"ref_guide_deploy_factory_standalone\">\n+          <title>Standalone Deployment</title>\n+          <indexterm zone=\"ref_guide_deploy_factory_standalone\">\n+            <primary>deployment</primary>\n+            <secondary>standalone</secondary>\n+            <seealso>Persistence</seealso>\n+          </indexterm>\n+          <para>\n+      The JPA Overview describes the \n+      <classname>javax.persistence.Persistence</classname> class.  You \n+      can use <classname>Persistence</classname> to obtain \n+      <classname>EntityManagerFactory</classname> instances, as \n+      demonstrated in <xref linkend=\"jpa_overview_persistence\"/>.\n+      OpenJPA also extends <classname>Persistence</classname> to add\n+      additional <classname>EntityManagerFactory</classname> \n+      creation methods.  The\n+      <classname>org.apache.openjpa.persistence.OpenJPAPersistence</classname> class\n+      <ulink url=\"../../api/openjpa/persistence/OpenJPAPersistence.html\">\n+      Javadoc</ulink> details these extensions.\n+      </para>\n+          <para>\n+      After obtaining the factory, you can cache it for all \n+      <phrase><classname>EntityManager</classname></phrase>\n+       \n+      \n+      creation duties.\n+      </para>\n+        </section>\n+        <section id=\"ref_guide_deploy_inject\">\n+          <title>EntityManager Injection</title>\n+<!-- ### EJBDOC -->\n+          <para>\n+      To be decided.\n+      </para>\n+        </section>\n+        <section id=\"ref_guide_deploy_jca_ejb\">\n+          <title>OpenJPA JCA Deployment</title>\n+          <indexterm zone=\"ref_guide_deploy_jca_ejb\">\n+            <primary>deployment</primary>\n+            <secondary>JCA</secondary>\n+            <seealso>JCA</seealso>\n+          </indexterm>\n+          <indexterm zone=\"ref_guide_deploy_jca_ejb\">\n+            <primary>JCA</primary>\n+            <secondary>deployment</secondary>\n+          </indexterm>\n+          <para>\n+      OpenJPA can deploy OpenJPA through the Java Connector Architecture\n+      (JCA) in any JCA-compliant application server that supports\n+      JDK 1.5 (all EJB 3 implementations require JDK 1.5).  We present\n+      the deployment steps for the most common servers below.\n+      </para>\n+          <section id=\"ref_guide_deploy_jca_jpa_weblogic9\">\n+            <title>WebLogic 9</title>\n+            <indexterm zone=\"ref_guide_deploy_jca_jpa_weblogic9\">\n+              <primary>Weblogic</primary>\n+            </indexterm>\n+            <indexterm zone=\"ref_guide_deploy_jca_jpa_weblogic9\">\n+              <primary>JCA</primary>\n+              <secondary>Weblogic 9</secondary>\n+            </indexterm>\n+            <para><!-- ### JDO2MIG : everything in system path for now -->\n+        First, ensure that your JDBC driver is in your system classpath.\n+        In addition, you will be adding the OpenJPA and specification API\n+        jars to the system classpath.  You can accomplish this by\n+        editing <filename>startWebLogic.sh/.cmd</filename>.\n+        </para>\n+            <warning>\n+              <para>Currently WebLogic ships with an old version\n+          of the EJB 3 libraries.  Be sure to put \n+          <filename>org.apache.openjpa.jar</filename> in the <emphasis>beginning\n+          </emphasis> of the <literal>CLASSPATH</literal>.</para>\n+            </warning>\n+            <para>\n+        The next step is to deploy \n+        <filename>openjpa-persistence.rar</filename> from the \n+        <filename>jca/persistence</filename> directory of your OpenJPA\n+        installation.  Copy this file to the <filename>autodeploy\n+        </filename> directory of your domain.  \n+        </para>\n+            <para>\n+        We will now extract <filename>META-INF/ra.xml</filename>\n+        and <filename>META-INF/weblogic-ra.xml</filename>\n+        to edit our configuration:\n+        </para>\n+            <programlisting format=\"linespecific\">\n+jar xvf openjpa-ejb.rar META-INF/ra.xml META-INF/weblogic-ra.xml\n+</programlisting>\n+            <para>\n+        Now you should configure OpenJPA JCA by editing\n+        <filename>META-INF/ra.xml</filename> substituting\n+        <literal>config-property-value</literal> stanzas\n+        with your own values.  You can comment out\n+        properties (config-property stanzas) which you are\n+        not using or you can leave them at their default settings.\n+        Edit <filename>META-INF/weblogic-ra.xml</filename>\n+        to configure the JNDI location to which you\n+        want OpenJPA to be bound.\n+        </para>\n+            <para>\n+        Now we can re-jar the manifest files back into the \n+        <filename>RAR</filename> file.\n+        </para>\n+            <programlisting format=\"linespecific\">\n+jar uvf openjpa-ejb.rar META-INF/ra.xml META-INF/weblogic-ra.xml\n+rm META-INF/ra.xml META-IN/weblogic-ra.xml\n+rmdir META-INF\n+</programlisting>\n+            <para>\n+        Now you can start WebLogic and WebLogic should\n+        deploy OpenJPA for you.  If you have installed OpenJPA correctly, \n+        at this point, one should be able to see OpenJPA bound to the \n+        JNDI location which you specified earlier.\n+        </para>\n+          </section>\n+        </section>\n+      </section>\n+      <section id=\"ref_guide_enterprise_xa\">\n+        <title>XA Transactions</title>\n+        <indexterm zone=\"ref_guide_enterprise_xa\">\n+          <primary>transactions</primary>\n+          <secondary>XA</secondary>\n+        </indexterm>\n+        <indexterm>\n+          <primary>XA transactions</primary>\n+          <see>transactions</see>\n+        </indexterm>\n+        <para>\n+    The X/Open Distributed Transaction Processing (X/Open DTP)\n+    featureSelection, designed by <ulink url=\"http://www.xopen.org\">Open Group</ulink>\n+    (a vendor consortium), defines a standard communication architecture\n+    that provides the following:\n+    </para>\n+        <itemizedlist>\n+          <listitem>\n+            <para>\n+        Concurrent execution of applications on shared resources.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        Coordination of transactions across applications.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        Components, interfaces, and protocols that define the \n+        architecture and provide portability of applications.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para>Atomicity of transaction systems.</para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+        Single-thread control and sequential function-calling.\n+        </para>\n+          </listitem>\n+        </itemizedlist>\n+        <para>\n+    The X/Open DTP XA standard defines the application programming\n+    interfaces that a resource manager uses to communicate\n+    with a transaction manager. The XA interfaces enable resource\n+    managers to join transactions, to perform two-phase commit,\n+    and to recover in-doubt transactions following a failure.\n+    </para>\n+        <section id=\"ref_guide_enterprise_xa_req\">\n+          <title>Using OpenJPA with XA Transactions</title>\n+          <para>\n+      OpenJPA supports XA-compliant transactions when used in a properly\n+      configured managed environment. The following components are \n+      required:\n+      </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+          A managed environment that provides an XA compliant \n+          transaction manager. Examples of this are application \n+          servers such as JBoss and WebLogic.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+          Instances of a <classname>javax.sql.XADataSource</classname>\n+          for each of the <classname>DataSource</classname>s that \n+          OpenJPA will use.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+          <para>\n+      Given these components, setting up OpenJPA to participate in \n+      distributed transactions is a simple two-step process:\n+      </para>\n+          <orderedlist>\n+            <listitem>\n+              <para>\n+          Point OpenJPA at an enlisted \n+          <classname>XADataSource</classname>, and configure a \n+          second non-enlisted data source.\n+          See <xref linkend=\"ref_guide_dbsetup_thirdparty_enlist\"/>.\n+          </para>\n+            </listitem>\n+          </orderedlist>\n+        </section>\n+      </section>\n+    </chapter>"},{"sha":"d95e5771540255568654511092a4bbd0dca1bdd3","filename":"openjpa-project/src/doc/manual/ref_guide_integration.xml","status":"added","additions":419,"deletions":0,"changes":419,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_integration.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_integration.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_integration.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,419 @@\n+\n+    <chapter id=\"ref_guide_integration\">\n+      <title>Third Party Integration</title>\n+      <para>\n+  OpenJPA provides a number of mechanisms for integrating with third-party \n+  tools. The following chapter will illustrate these integration features.\n+  </para>\n+      <section id=\"ref_guide_integration_ant\">\n+        <title>Apache Ant</title>\n+        <indexterm zone=\"ref_guide_integration_ant\">\n+          <primary>Ant</primary>\n+        </indexterm>\n+        <para>\n+    Ant is a very popular tool for building Java projects. It is similar to\n+    the <literal>make</literal> command, but is Java-centric and has\n+    more modern features. Ant is open source, and can be downloaded\n+    from Apache's Ant web page at\n+    <ulink url=\"http://jakarta.apache.org/ant/\">\n+    http://jakarta.apache.org/ant/</ulink>.\n+    Ant has become the de-facto standard build tool for Java, and\n+    many commercial integrated development environments provide\n+    some support for using ant build files. The remainder of this\n+    section assumes familiarity with writing Ant\n+    <filename>build.xml</filename> files.\n+    </para>\n+        <para>\n+    OpenJPA provides pre-built Ant task definitions for all bundled tools:\n+    </para>\n+        <itemizedlist>\n+          <listitem>\n+            <para>\n+              <link linkend=\"ref_guide_integration_enhance\">Enhancer\n+        Task</link>\n+            </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+              <link linkend=\"ref_guide_integration_appidtool\">Application\n+        Identity Tool Task</link>\n+            </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+              <link linkend=\"ref_guide_integration_mappingtool\">Mapping \n+        Tool Task</link>\n+            </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+              <link linkend=\"ref_guide_integration_revmappingtool\">Reverse\n+        Mapping Tool Task</link>\n+            </para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+              <link linkend=\"ref_guide_integration_schematool\">Schema Tool\n+        Task</link>\n+            </para>\n+          </listitem>\n+        </itemizedlist>\n+        <para>\n+    The source code for all the ant tasks is provided with the distribution\n+    under the <filename>src</filename> directory. This allows you\n+    to customize various aspects of the ant tasks in order to better \n+    integrate into your development environment.\n+    </para>\n+        <section id=\"ref_guide_integration_conf\">\n+          <title>Common Ant Configuration Options</title>\n+          <indexterm>\n+            <primary>Ant</primary>\n+            <secondary>configuration options</secondary>\n+          </indexterm>\n+          <para>\n+      All OpenJPA tasks accept a nested <literal>config</literal>\n+      element, which defines the configuration environment in which\n+      the specified task will run. The attributes for the\n+      <literal>config</literal> tag are defined by the \n+      <ulink url=\"../apidocs/org/apache/openjpa/jdbc/conf/JDBCConfiguration.html\"><classname>JDBCConfiguration</classname></ulink> bean methods. \n+      Note that excluding the <literal>config</literal> element \n+      will cause the Ant task to use the default system configuration \n+      mechanism, such as the configuration defined in the \n+      <phrase><filename>org.apache.openjpa.xml</filename></phrase>\n+      \n+      \n+      file.\n+      </para>\n+          <para>\n+      Following is an example of how to use the nested\n+      <literal>config</literal> tag in a <filename>build.xml</filename> \n+      file:\n+      </para>\n+          <example id=\"ref_guide_integration_conf_config\">\n+            <title>Using the &lt;config&gt; Ant Tag</title>\n+            <programlisting format=\"linespecific\">\n+&lt;mappingtool&gt;\n+  &lt;fileset dir=\"${basedir}\"&gt;\n+    &lt;include name=\"**/featureSelection/*.java\" /&gt;\n+  &lt;/fileset&gt;\n+  &lt;config connectionUserName=\"scott\" connectionPassword=\"tiger\"\n+    connectionURL=\"jdbc:oracle:thin:@saturn:1521:solarsid\"\n+    connectionDriverName=\"oracle.jdbc.driver.OracleDriver\" /&gt;\n+&lt;/mappingtool&gt;\n+</programlisting>\n+          </example>\n+          <para>\n+      It is also possible to specify a <literal>properties</literal> \n+      or <literal>propertiesFile</literal> attribute on the \n+      <literal>config</literal> tag, which will be used to \n+      locate a properties resource or file. The resource will be \n+      loaded relative to the current CLASSPATH.\n+      </para>\n+          <example id=\"ref_guide_integration_props\">\n+            <title>Using the Properties Attribute of the &lt;config&gt; \n+        Tag</title>\n+            <programlisting format=\"linespecific\">\n+&lt;mappingtool&gt;\n+  &lt;fileset dir=\"${basedir}\"&gt;\n+    &lt;include name=\"**/featureSelection/*.java\"/&gt;\n+  &lt;/fileset&gt;\n+  &lt;config properties=\"openjpa-dev.properties\"/&gt;\n+&lt;/mappingtool&gt;\n+</programlisting>\n+          </example>\n+          <example id=\"ref_guide_integration_propsfile\">\n+            <title>Using the PropertiesFile Attribute of the &lt;config&gt; \n+        Tag</title>\n+            <programlisting format=\"linespecific\">\n+&lt;mappingtool&gt;\n+  &lt;fileset dir=\"${basedir}\"&gt;\n+    &lt;include name=\"**/featureSelection/*.java\"/&gt;\n+  &lt;/fileset&gt;\n+  &lt;config propertiesFile=\"../conf/openjpa-dev.properties\"/&gt;\n+&lt;/mappingtool&gt;\n+</programlisting>\n+          </example>\n+          <para>\n+      Tasks also accept a nested <literal>classpath</literal> \n+      element, which you can use in place of the default classpath.\n+      The <literal>classpath</literal> argument behaves the same \n+      as it does for Ant's standard <literal>javac</literal>\n+      element. It is sometimes the case that projects are compiled\n+      to a separate directory than the source tree. If the target\n+      path for compiled classes is not included in the project's\n+      classpath, then a <literal>classpath</literal> element\n+      that includes the target class directory needs to be included so \n+      the enhancer and mapping tool can locate the relevant classes.\n+      </para>\n+          <para>\n+      Following is an example of using a <literal>classpath</literal> tag:\n+      </para>\n+          <example id=\"ref_guide_integration_conf_classpath\">\n+            <title>Using the &lt;classpath&gt; Ant Tag</title>\n+            <programlisting format=\"linespecific\">\n+&lt;openjpac&gt;\n+  &lt;fileset dir=\"${basedir}/source\"&gt;\n+    &lt;include name=\"**/featureSelection/*.java\" /&gt;\n+  &lt;/fileset&gt;\n+  &lt;classpath&gt;\n+    &lt;pathelement location=\"${basedir}/classes\"/&gt;\n+    &lt;pathelement location=\"${basedir}/source\"/&gt;\n+    &lt;pathelement path=\"${java.class.path}\"/&gt;\n+  &lt;/classpath&gt;\n+&lt;/openjpac&gt;\n+</programlisting>\n+          </example>\n+          <para>\n+      Finally, tasks that invoke code-generation tools like the\n+      application identity tool and reverse mapping tool accept a nested\n+      <literal>codeformat</literal> element.  See the code formatting\n+      documentation in <xref linkend=\"ref_guide_conf_devtools_format\"/>\n+      for a list of code formatting attributes.\n+      </para>\n+          <example id=\"ref_guide_integration_conf_codeformat\">\n+            <title>Using the &lt;codeformat&gt; Ant Tag</title>\n+            <programlisting format=\"linespecific\">\n+&lt;reversemappingtool package=\"com.xyz.jdo\" directory=\"${basedir}/src\"&gt;\n+  &lt;codeformat tabSpaces=\"4\" spaceBeforeParen=\"true\" braceOnSameLine=\"false\"/&gt;\n+&lt;/reversemappingtool&gt;\n+</programlisting>\n+          </example>\n+        </section>\n+        <section id=\"ref_guide_integration_enhance\">\n+          <title>Enhancer Ant Task</title>\n+          <indexterm zone=\"ref_guide_integration_enhance\">\n+            <primary>Ant</primary>\n+            <secondary>enhancer task</secondary>\n+          </indexterm>\n+          <indexterm zone=\"ref_guide_integration_enhance\">\n+            <primary>enhancer</primary>\n+            <secondary>Ant task</secondary>\n+          </indexterm>\n+          <para>\n+      The enhancer task allows you to invoke the OpenJPA enhancer\n+      directly from within the Ant build process.  The task's \n+      parameters correspond exactly to the long versions of the \n+      command-line arguments to <link linkend=\"ref_guide_pc_enhance\"><literal>openjpac</literal></link>.\n+      </para>\n+          <para>  \n+      The enhancer task accepts a nested <literal>fileset</literal> tag \n+      to specify the files that should be processed. You can specify \n+      <filename>.java</filename> or <filename>.class</filename> files.\n+      If you do not specify any files, the task will run on the classes \n+      listed in your <link linkend=\"openjpa.MetaDataFactory\"><literal>\n+      openjpa.MetaDataFactory</literal></link> property.\n+      </para>\n+          <para>\n+      Following is an example of using the enhancer task\n+      in a <filename>build.xml</filename> file:\n+      </para>\n+          <example id=\"ref_guide_integration_enhance_task\">\n+            <title>Invoking the Enhancer from Ant</title>\n+            <programlisting format=\"linespecific\">\n+&lt;target name=\"enhance\"&gt;\n+  &lt;!-- define the openjpac task; this can be done at the top of the    --&gt;\n+  &lt;!-- build.xml file, so it will be available for all targets      --&gt;\n+  &lt;taskdef name=\"openjpac\" classname=\"org.apache.openjpa.ant.PCEnhancerTask\"/&gt;\n+\n+  &lt;!-- invoke enhancer on all .jdo files below the current directory --&gt;\n+  &lt;openjpac&gt;\n+    &lt;fileset dir=\".\"&gt;\n+      &lt;include name=\"**/featureSelection/*.java\" /&gt;\n+    &lt;/fileset&gt;\n+  &lt;/openjpac&gt;\n+&lt;/target&gt;\n+</programlisting>\n+          </example>\n+        </section>\n+        <section id=\"ref_guide_integration_appidtool\">\n+          <title>Application Identity Tool Ant Task</title>\n+          <indexterm zone=\"ref_guide_integration_enhance\">\n+            <primary>Ant</primary>\n+            <secondary>application identity tool task</secondary>\n+          </indexterm>\n+          <indexterm zone=\"ref_guide_integration_enhance\">\n+            <primary>application identity tool</primary>\n+            <secondary>Ant task</secondary>\n+          </indexterm>\n+          <para>\n+      The application identity tool task allows you to invoke the \n+      application identity tool directly from within the Ant build \n+      process.  The task's parameters correspond exactly to the long \n+      versions of the command-line arguments to\n+      <link linkend=\"ref_guide_pc_appid_appidtool\"><literal>appidtool</literal></link>.\n+      </para>\n+          <para>  \n+      The application identity tool task accepts a nested \n+      <literal>fileset</literal> tag to specify the files that should be \n+      processed. You can specify \n+      <filename>.java</filename> or <filename>.class</filename> files.\n+      If you do not specify any files, the task will run on the classes \n+      listed in your <link linkend=\"openjpa.MetaDataFactory\"><literal>\n+      openjpa.MetaDataFactory</literal></link> property.\n+      </para>\n+          <para>\n+      Following is an example of using the application identity tool task\n+      in a <filename>build.xml</filename> file:\n+      </para>\n+          <example id=\"ref_guide_integration_appidtool_task\">\n+            <title>Invoking the Application Identity Tool from Ant</title>\n+            <programlisting format=\"linespecific\">\n+&lt;target name=\"appids\"&gt;\n+  &lt;!-- define the appidtool task; this can be done at the top of     --&gt;\n+  &lt;!-- the build.xml file, so it will be available for all targets   --&gt;\n+  &lt;taskdef name=\"appidtool\" classname=\"org.apache.openjpa.ant.ApplicationIdToolTask\"/&gt;\n+\n+  &lt;!-- invoke tool on all .jdo files below the current directory     --&gt;\n+  &lt;appidtool&gt;\n+    &lt;fileset dir=\".\"&gt;\n+      &lt;include name=\"**/featureSelection/*.java\" /&gt;\n+    &lt;/fileset&gt;\n+    &lt;codeformat spaceBeforeParen=\"true\" braceOnSameLine=\"false\"/&gt;\n+  &lt;/appidtool&gt;\n+&lt;/target&gt;\n+</programlisting>\n+          </example>\n+        </section>\n+        <section id=\"ref_guide_integration_mappingtool\">\n+          <title>Mapping Tool Ant Task</title>\n+          <indexterm zone=\"ref_guide_integration_mappingtool\">\n+            <primary>Ant</primary>\n+            <secondary>mapping tool task</secondary>\n+          </indexterm>\n+          <indexterm zone=\"ref_guide_integration_mappingtool\">\n+            <primary>mapping tool</primary>\n+            <secondary>Ant task</secondary>\n+          </indexterm>\n+          <para>\n+      The mapping tool task allows you to directly invoke the\n+      mapping tool from within the Ant build process.  It is useful for\n+      making sure that the database schema and object-relational mapping\n+      data is always synchronized with your persistent class definitions,\n+      without needing to remember to invoke the mapping tool manually.\n+      The task's parameters correspond exactly to the long versions of\n+      the command-line arguments to the \n+      <link linkend=\"ref_guide_mapping_mappingtool\"><literal>\n+      mappingtool</literal></link>.\n+      </para>\n+          <para>  \n+      The mapping tool task accepts a nested \n+      <literal>fileset</literal> tag to specify the files that should be \n+      processed. You can specify \n+      <filename>.java</filename> or <filename>.class</filename> files.\n+      If you do not specify any files, the task will run on the classes \n+      listed in your <link linkend=\"openjpa.MetaDataFactory\"><literal>\n+      openjpa.MetaDataFactory</literal></link> property.\n+      </para>\n+          <para>\n+      Following is an example of a <filename>build.xml</filename>\n+      target that invokes the mapping tool:\n+      </para>\n+          <example id=\"ref_guide_integration_mappingtool_task\">\n+            <title>Invoking the Mapping Tool from Ant</title>\n+            <programlisting format=\"linespecific\">\n+&lt;target name=\"refresh\"&gt;\n+  &lt;!-- define the mappingtool task; this can be done at the top of --&gt;\n+  &lt;!-- the build.xml file, so it will be available for all targets --&gt;\n+  &lt;taskdef name=\"mappingtool\" classname=\"org.apache.openjpa.jdbc.ant.MappingToolTask\"/&gt;\n+\n+  &lt;!-- add the schema components for all .jdo files below the      --&gt;\n+  &lt;!-- current directory                                           --&gt;\n+  &lt;mappingtool action=\"buildSchema\"&gt;\n+    &lt;fileset dir=\".\"&gt;\n+      &lt;include name=\"**/*.jdo\" /&gt;\n+    &lt;/fileset&gt;\n+  &lt;/mappingtool&gt;\n+&lt;/target&gt;\n+</programlisting>\n+          </example>\n+        </section>\n+        <section id=\"ref_guide_integration_revmappingtool\">\n+          <title>Reverse Mapping Tool Ant Task</title>\n+          <indexterm zone=\"ref_guide_integration_revmappingtool\">\n+            <primary>Ant</primary>\n+            <secondary>reverse mapping tool task</secondary>\n+          </indexterm>\n+          <indexterm zone=\"ref_guide_integration_revmappingtool\">\n+            <primary>reverse mapping tool</primary>\n+            <secondary>Ant task</secondary>\n+          </indexterm>\n+          <para>\n+      The reverse mapping tool task allows you to directly invoke the\n+      reverse mapping tool from within Ant.  While many users will only \n+      run the reverse mapping process once, others will make it part of \n+      their build process.  The task's parameters correspond exactly to \n+      the long versions of the command-line arguments to the \n+      <link linkend=\"ref_guide_pc_reverse_reversemappingtool\"><literal>\n+      reversemappingtool</literal></link>.\n+      </para>\n+          <para>\n+      Following is an example of a <filename>build.xml</filename>\n+      target that invokes the reverse mapping tool:\n+      </para>\n+          <example id=\"ref_guide_integration_revmappingtool_task\">\n+            <title>Invoking the Reverse Mapping Tool from Ant</title>\n+            <programlisting format=\"linespecific\">\n+&lt;target name=\"reversemap\"&gt;\n+  &lt;!-- define the reversemappingtool task; this can be done at the top of --&gt;\n+  &lt;!-- the build.xml file, so it will be available for all targets        --&gt;\n+  &lt;taskdef name=\"reversemappingtool\" \n+    classname=\"org.apache.openjpa.jdbc.ant.ReverseMappingToolTask\"/&gt;\n+\n+  &lt;!-- reverse map the entire database --&gt;\n+  &lt;reversemappingtool package=\"com.xyz.featureSelection\" directory=\"${basedir}/src\"\n+    customizerProperties=\"${basedir}/conf/reverse.properties\"&gt;\n+    &lt;codeformat tabSpaces=\"4\" spaceBeforeParen=\"true\" braceOnSameLine=\"false\"/&gt;\n+  &lt;/reversemappingtool&gt;\n+&lt;/target&gt;\n+</programlisting>\n+          </example>\n+        </section>\n+        <section id=\"ref_guide_integration_schematool\">\n+          <title>Schema Tool Ant Task</title>\n+          <indexterm zone=\"ref_guide_integration_schematool\">\n+            <primary>Ant</primary>\n+            <secondary>schema tool task</secondary>\n+          </indexterm>\n+          <indexterm zone=\"ref_guide_integration_schematool\">\n+            <primary>schema tool</primary>\n+            <secondary>Ant task</secondary>\n+          </indexterm>\n+          <para>\n+      The schema tool task allows you to directly invoke the\n+      schema tool from within the Ant build process.\n+      The task's parameters correspond exactly to the long versions\n+      of the command-line arguments to the \n+      <link linkend=\"ref_guide_schema_schematool\"><literal>\n+      schematool</literal></link>.\n+      </para>\n+          <para>\n+      Following is an example of a <filename>build.xml</filename>\n+      target that invokes the schema tool:\n+      </para>\n+          <example id=\"ref_guide_integration_schematool_task\">\n+            <title>Invoking the Schema Tool from Ant</title>\n+            <programlisting format=\"linespecific\">\n+&lt;target name=\"schema\"&gt;\n+  &lt;!-- define the schematool task; this can be done at the top of  --&gt;\n+  &lt;!-- the build.xml file, so it will be available for all targets --&gt;\n+  &lt;taskdef name=\"schematool\" classname=\"org.apache.openjpa.jdbc.ant.SchemaToolTask\"/&gt;\n+\n+  &lt;!-- add the schema components for all .schema files below the   --&gt;\n+  &lt;!-- current directory                                           --&gt;\n+  &lt;schematool action=\"add\"&gt;\n+    &lt;fileset dir=\".\"&gt;\n+      &lt;include name=\"**/*.schema\" /&gt;\n+    &lt;/fileset&gt;\n+  &lt;/schematool&gt;\n+&lt;/target&gt;\n+</programlisting>\n+          </example>\n+        </section>\n+      </section>\n+      <section id=\"ref_guide_integration_maven\">\n+        <title>Maven</title>\n+        <indexterm zone=\"ref_guide_integration_maven\">\n+          <primary>Maven</primary>\n+        </indexterm>\n+      </section>\n+    </chapter>"},{"sha":"8037d97aa3784f273f904019178cdafb79f51fe5","filename":"openjpa-project/src/doc/manual/ref_guide_intro.xml","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_intro.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_intro.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_intro.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,28 @@\n+\n+    <chapter id=\"ref_guide_intro\">\n+      <title>Introduction</title>\n+      <para>\n+  OpenJPA <phrase>JPA</phrase> is a JDBC-based implementation of the JPA \n+  standard.  This document is a reference for the \n+  configuration and use of OpenJPA <phrase>JPA</phrase>. \n+  </para>\n+      <section id=\"ref_guide_intro_audience\">\n+        <title>Intended Audience</title>\n+        <para>\n+    This document is intended for OpenJPA <phrase>JPA</phrase> developers.  It \n+    assumes strong knowledge of Java, familiarity with the eXtensible \n+    Markup Language (XML), and an understanding of JPA.\n+    If you are not familiar with JPA, please read the\n+    <link linkend=\"jpa_overview_intro\">JPA Overview</link> \n+    before proceeding.  We also strongly recommend taking OpenJPA's hands-on \n+    <link linkend=\"tutorials\">tutorials</link> to get comfortable \n+    with OpenJPA basics.\n+    </para>\n+        <para>\n+    Certain sections of this guide cover advanced topics such as\n+    custom object-relational mapping, enterprise integration, and using\n+    OpenJPA with third-party tools.  These sections assume prior experience \n+    with the relevant subject.\n+    </para>\n+      </section>\n+    </chapter>"},{"sha":"309e83c422cc1b2b190f58deeb8a0761adf2d097","filename":"openjpa-project/src/doc/manual/ref_guide_logging.xml","status":"added","additions":439,"deletions":0,"changes":439,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_logging.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_logging.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_logging.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,439 @@\n+\n+    <chapter id=\"ref_guide_logging\">\n+      <title>Logging</title>\n+      <indexterm zone=\"ref_guide_logging\">\n+        <primary>logging</primary>\n+      </indexterm>\n+      <indexterm zone=\"ref_guide_logging\">\n+        <primary>Log</primary>\n+      </indexterm>\n+      <para>\n+  Logging is an important means of gaining insight into your application's\n+  runtime behavior.  OpenJPA\n+  provides a flexible logging system that integrates with many\n+  existing runtime systems, such as application servers and servlet\n+  runners.\n+  </para>\n+      <para>\n+  There are four built-in logging plugins: a \n+  <link linkend=\"ref_guide_logging_openjpa\">default logging framework</link>\n+  that covers most needs, a <link linkend=\"ref_guide_logging_log4j\">\n+  Log4J</link> delegate, an <link linkend=\"ref_guide_logging_commons\">\n+  Apache Commons Logging</link> delegate, and a \n+  <link linkend=\"ref_guide_logging_noop\">no-op</link> implementation for\n+  disabling logging.\n+  </para>\n+      <warning>\n+        <para>\n+    Logging can have a negative impact on performance. Disable\n+    verbose logging (such as logging of SQL statements) before\n+    running any performance tests. It is advisable to limit or\n+    disable logging for a production system. You can\n+    disable logging altogether by setting\n+    the <literal>openjpa.Log</literal> property\n+    to <literal>none</literal>.\n+    </para>\n+      </warning>\n+      <section id=\"ref_guide_logging_channels\">\n+        <title>Logging Channels</title>\n+        <indexterm zone=\"ref_guide_logging_channels\">\n+          <primary>logging</primary>\n+          <secondary>channels</secondary>\n+        </indexterm>\n+        <para>\n+    Logging is done over a number of <emphasis>logging channels</emphasis>,\n+    each of which has a <emphasis>logging level</emphasis> which controls\n+    the verbosity of log messages recorded for the channel.  OpenJPA uses\n+    the following logging channels:\n+    </para>\n+        <itemizedlist>\n+          <listitem>\n+            <para><literal>openjpa.Tool</literal>: Messages issued by the OpenJPA\n+        command line and Ant tools.  Most messages\n+        are basic statements detailing which classes or files the \n+        tools are running on.  Detailed output is only available via\n+        the logging category the tool belongs to, such as \n+        <literal>openjpa.Enhance</literal> for the enhancer\n+        (see <xref linkend=\"ref_guide_pc_enhance\"/>) or\n+        <literal>openjpa.MetaData</literal> for the mapping tool\n+        (see <xref linkend=\"ref_guide_mapping_mappingtool\"/>).\n+        This logging category is provided so that you can\n+        get a general idea of what a tool is doing without having to\n+        manipulate logging settings that might also affect runtime\n+        behavior.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><indexterm><primary>configuration</primary><secondary>log messages</secondary></indexterm><literal>openjpa.Configuration</literal>: Messages issued\n+        by the configuration framework.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><indexterm><primary>enhancement</primary><secondary>log messages</secondary></indexterm><literal>openjpa.Enhance</literal>: Messages pertaining to\n+        enhancement and runtime class generation.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><indexterm><primary>metadata</primary><secondary>log messages</secondary></indexterm><literal>openjpa.MetaData</literal>: Details about the generation \n+        of metadata and object-relational mappings.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><literal>openjpa.Runtime</literal>: General OpenJPA runtime messages.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><indexterm><primary>Query</primary><secondary>log messages</secondary></indexterm><literal>openjpa.Query</literal>: Messages about queries.\n+        Query strings and any parameter values, if applicable, will be \n+        logged to the <literal>TRACE</literal> level at execution\n+        time. Information about possible performance concerns\n+        will be logged to the <literal>INFO</literal> level.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><indexterm><primary>remote</primary><secondary>log messages</secondary></indexterm><literal>openjpa.Remote</literal>: Remote connection and execution\n+        messages.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><indexterm><primary>caching</primary><secondary>log messages</secondary></indexterm><literal>openjpa.DataCache</literal>: Messages from the L2 data \n+        cache plugins.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><indexterm><primary>JDBC</primary><secondary>log messages</secondary></indexterm><literal>openjpa.jdbc.JDBC</literal>: JDBC connection information.\n+        General JDBC information will be logged to the <literal>TRACE\n+        </literal> level.  Information about possible performance \n+        concerns will be logged to the <literal>INFO</literal> level.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><indexterm><primary>SQL</primary><secondary>log messages</secondary></indexterm><literal>openjpa.jdbc.SQL</literal>: This is the most common \n+        logging channel to use.  Detailed information about the \n+        execution of SQL statements will be sent to the \n+        <literal>TRACE</literal> level.  It is useful to enable this \n+        channel if you are curious about the exact SQL that OpenJPA \n+        issues to the datastore.\n+        </para>\n+            <para>\n+        When using the built-in OpenJPA logging facilities, you can \n+        enable SQL logging by adding <literal>SQL=TRACE</literal> to\n+        your <literal>openjpa.Log</literal> property.\n+        </para>\n+            <para>\n+        OpenJPA can optionally reformat the logged SQL to\n+        make it easier to read. To enable pretty-printing,\n+        add <literal>PrettyPrint=true</literal> to the\n+        <link linkend=\"openjpa.ConnectionFactoryProperties\"><literal>\n+        openjpa.ConnectionFactoryProperties</literal></link>\n+        property. You can control how many columns wide the\n+        pretty-printed SQL will be with the \n+        <literal>PrettyPrintLineLength</literal> property. The default \n+        line length is 60 columns.</para>\n+            <para>\n+        While pretty printing makes things easier to read, it can make \n+        output harder to process with tools like grep.\n+        </para>\n+            <para>\n+        Pretty-printing properties configuration might look like so:\n+        </para>\n+            <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.Log\" value=\"SQL=TRACE\"/&gt;\n+&lt;property name=\"openjpa.ConnectionFactoryProperties\" \n+    value=\"MaxActive=100, PrettyPrint=true, PrettyPrintLineLength=72\"/&gt;\n+</programlisting>\n+          </listitem>\n+          <listitem>\n+            <para><indexterm><primary>schema</primary><secondary>log messages</secondary></indexterm><literal>openjpa.jdbc.Schema</literal>: Details about operations \n+        on the database schema.\n+        </para>\n+          </listitem>\n+        </itemizedlist>\n+      </section>\n+      <section id=\"ref_guide_logging_openjpa\">\n+        <title>OpenJPA Logging</title>\n+        <indexterm zone=\"ref_guide_logging_openjpa\">\n+          <primary>logging</primary>\n+          <secondary>default</secondary>\n+        </indexterm>\n+        <para>\n+    By default, OpenJPA uses a basic logging framework with the following\n+    output format:\n+    </para>\n+        <para><literal>millis</literal><literal>level</literal>  [<literal>thread name</literal>] <literal>channel</literal> - <literal>message</literal></para>\n+        <para>\n+    For example, when loading an application that uses OpenJPA, a message \n+    like the following will be sent to the <literal>openjpa.Runtime</literal>\n+    channel:\n+    </para>\n+        <programlisting format=\"linespecific\">\n+2107  INFO   [main] openjpa.Runtime - Starting OpenJPA 4.0.0\n+</programlisting>\n+        <para>\n+    The default logging system accepts the following parameters:\n+    </para>\n+        <itemizedlist>\n+          <listitem>\n+            <para><literal>File</literal>: The name of the file to log to, or\n+        <literal>stdout</literal> or <literal>stderr</literal> to send\n+        messages to standard out and standard error, respectively.\n+        By default, OpenJPA sends log messages to standard error.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><literal>DefaultLevel</literal>: The default logging level of\n+        unconfigured channels.  Recognized values are <literal>\n+        TRACE, DEBUG, INFO, WARN,</literal> and <literal>ERROR\n+        </literal>.  Defaults to <literal>INFO</literal>.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><literal>DiagnosticContext</literal>: A string that will \n+        be prepended to all log messages.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><literal>&lt;channel&gt;</literal>: Using the last token of\n+        the <link linkend=\"ref_guide_logging_channels\">logging channel \n+        </link> name, you can configure the log level to\n+        use for that channel.  See the examples below.\n+        </para>\n+          </listitem>\n+        </itemizedlist>\n+        <example id=\"ref_guide_logging_openjpa_std_ex\">\n+          <title>Standard OpenJPA Log Configuration</title>\n+          <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.Log\" value=\"DefaultLevel=WARN, Runtime=INFO, Tool=INFO\"/&gt;\n+</programlisting>\n+        </example>\n+        <example id=\"ref_guide_logging_openjpa_sql_ex\">\n+          <title>Standard OpenJPA Log Configuration + All SQL Statements</title>\n+          <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.Log\" value=\"DefaultLevel=WARN, Runtime=INFO, Tool=INFO, SQL=TRACE\"/&gt;\n+</programlisting>\n+        </example>\n+        <example id=\"ref_guide_logging_openjpa_file\">\n+          <title>Logging to a File</title>\n+          <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.Log\" value=\"File=/tmp/org.apache.openjpa.log, DefaultLevel=WARN, Runtime=INFO, Tool=INFO\"/&gt;\n+</programlisting>\n+        </example>\n+      </section>\n+      <section id=\"ref_guide_logging_noop\">\n+        <title>Disabling Logging</title>\n+        <indexterm zone=\"ref_guide_logging_noop\">\n+          <primary>logging</primary>\n+          <secondary>disabling</secondary>\n+        </indexterm>\n+        <para>\n+    Disabling logging can be useful to analyze performance without\n+    any I/O overhead or to reduce verbosity at the console. To do\n+    this, set the <literal>openjpa.Log</literal> property\n+    to <literal>none</literal>.\n+    </para>\n+        <para>\n+    Disabling logging permanently, however, will cause all warnings\n+    to be consumed.  We recommend using one of the\n+    more sophisticated mechanisms described in this chapter.\n+    </para>\n+      </section>\n+      <section id=\"ref_guide_logging_log4j\">\n+        <title>Log4J</title>\n+        <indexterm zone=\"ref_guide_logging_log4j\">\n+          <primary>logging</primary>\n+          <secondary>Log4j</secondary>\n+        </indexterm>\n+        <para>\n+    When <literal>openjpa.Log</literal> is set\n+    to <literal>log4j</literal>, OpenJPA will delegate to Log4J for logging.\n+    In a standalone application, Log4J logging levels are\n+    controlled by a resource named <filename>log4j.properties</filename>, \n+    which should be available as a top-level resource (either at the top \n+    level of a jar file, or in the root of one of\n+    the <literal>CLASSPATH</literal> directories). When deploying to\n+    a web or EJB application server, Log4J configuration is often\n+    performed in a <filename>log4j.xml</filename> file instead of a\n+    properties file. For further details on configuring Log4J,\n+    please see the \n+    <ulink url=\"http://jakarta.apache.org/log4j/docs/manual.html\">Log4J\n+    Manual</ulink>. We present an example \n+    <filename>log4j.properties</filename> file below.\n+    </para>\n+        <example id=\"ref_guide_logging_log4j_ex\">\n+          <title>Standard Log4J Logging</title>\n+          <programlisting format=\"linespecific\">\n+log4j.rootCategory=WARN, console\n+log4j.category.openjpa.Tool=INFO\n+log4j.category.openjpa.Runtime=INFO\n+log4j.category.openjpa.Remote=WARN\n+log4j.category.openjpa.DataCache=WARN\n+log4j.category.openjpa.MetaData=WARN\n+log4j.category.openjpa.Enhance=WARN\n+log4j.category.openjpa.Query=WARN\n+log4j.category.openjpa.jdbc.SQL=WARN\n+log4j.category.openjpa.jdbc.JDBC=WARN\n+log4j.category.openjpa.jdbc.Schema=WARN\n+\n+log4j.appender.console=org.apache.log4j.ConsoleAppender\n+</programlisting>\n+        </example>\n+      </section>\n+      <section id=\"ref_guide_logging_commons\">\n+        <title>Apache Commons Logging</title>\n+        <indexterm zone=\"ref_guide_logging_commons\">\n+          <primary>logging</primary>\n+          <secondary>Apache Commons</secondary>\n+        </indexterm>\n+        <para>\n+    Set the <literal>openjpa.Log</literal> property to <literal>commons\n+    </literal> to use the\n+    <ulink url=\"http://jakarta.apache.org/commons/logging.html\">\n+    Apache Jakarta Commons Logging</ulink> thin library for issuing\n+    log messages. The Commons Logging libraries act as a wrapper\n+    around a number of popular logging APIs, including the\n+    <ulink url=\"http://jakarta.apache.org/log4j/docs/index.html\">\n+    Jakarta Log4J</ulink> project, and the native\n+    <ulink url=\"http://java.sun.com/j2se/1.4/docs/api/java/util/logging/package-summary.html\">\n+    java.util.logging</ulink> package in JDK 1.4.  If neither of these\n+    libraries are available, then logging will fall back to using simple \n+    console logging.\n+    </para>\n+        <para>\n+    When using the Commons Logging framework in conjunction with\n+    Log4J, configuration will be the same as was discussed in the\n+    Log4J section above.\n+    </para>\n+        <section id=\"ref_guide_logging_jdk14\">\n+          <title>JDK 1.4 java.util.logging</title>\n+          <indexterm zone=\"ref_guide_logging_jdk14\">\n+            <primary>logging</primary>\n+            <secondary>JDK 1.4</secondary>\n+          </indexterm>\n+          <para>\n+      When using JDK 1.4 or higher in conjunction with OpenJPA's\n+      Commons Logging support, logging will proceed through Java's\n+      built-in logging provided by the\n+      <ulink url=\"http://java.sun.com/j2se/1.4/docs/api/java/util/logging/package-summary.html\">\n+      java.util.logging</ulink> package. For details on\n+      configuring the built-in logging system, please see the\n+      <ulink url=\"http://java.sun.com/j2se/1.4/docs/guide/util/logging/overview.html\">\n+      Java Logging Overview</ulink>.\n+      </para>\n+          <para>\n+      By default, JDK 1.4's logging package looks in\n+      the <filename> JAVA_HOME/lib/logging.properties</filename>\n+      file for logging configuration. This can be overridden with\n+      the <literal> java.util.logging.config.file</literal> system\n+      property. For example:\n+      </para>\n+          <programlisting format=\"linespecific\">\n+java -Djava.util.logging.config.file=mylogging.properties com.company.MyClass\n+</programlisting>\n+          <example id=\"ref_guide_logging_jdk14_propfile\">\n+            <title>JDK 1.4 Log Properties</title>\n+            <programlisting format=\"linespecific\">\n+# specify the handlers to create in the root logger\n+# (all loggers are children of the root logger)\n+# the following creates two handlers\n+handlers=java.util.logging.ConsoleHandler, java.util.logging.FileHandler\n+    \n+# set the default logging level for the root logger\n+.level=ALL\n+    \n+# set the default logging level for new ConsoleHandler instances\n+java.util.logging.ConsoleHandler.level=INFO\n+\n+# set the default logging level for new FileHandler instances\n+java.util.logging.FileHandler.level=ALL\n+\n+# set the default formatter for new ConsoleHandler instances\n+java.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatter\n+\n+# set the default logging level for all OpenJPA logs\n+openjpa.Tool.level=INFO\n+openjpa.Runtime.level=INFO\n+openjpa.Remote.level=INFO\n+openjpa.DataCache.level=INFO\n+openjpa.MetaData.level=INFO\n+openjpa.Enhance.level=INFO\n+openjpa.Query.level=INFO\n+openjpa.jdbc.SQL.level=INFO\n+openjpa.jdbc.JDBC.level=INFO\n+openjpa.jdbc.Schema.level=INFO\n+</programlisting>\n+          </example>\n+        </section>\n+      </section>\n+      <section id=\"ref_guide_logging_custom\">\n+        <title>Custom Log</title>\n+        <indexterm zone=\"ref_guide_logging_custom\">\n+          <primary>logging</primary>\n+          <secondary>custom</secondary>\n+        </indexterm>\n+        <para>\n+    If none of available logging systems meet your needs, you can configure\n+    the logging system with a custom logger.  You might use\n+    custom logging to integrate with a proprietary logging framework used \n+    by some applications servers, or for logging to a graphical component \n+    for GUI applications.\n+    </para>\n+        <para>\n+    A custom logging framework must include an implementation of the\n+    <ulink url=\"../apidocs/org/apache/openjpa/lib/log/LogFactory.html\"><classname>org.apache.openjpa.lib.log.LogFactory</classname></ulink> interface.\n+    We present a custom <classname>LogFactory</classname> below.\n+    </para>\n+        <example id=\"ref_guide_logging_custom_ex\">\n+          <title>Custom Logging Class</title>\n+          <programlisting format=\"linespecific\">\n+package com.xyz;\n+\n+import org.apache.openjpa.lib.log.*;\n+\n+public class CustomLogFactory\n+    implements LogFactory\n+{   \n+    private String _prefix = \"CUSTOM LOG\";\n+\n+    public void setPrefix (String prefix)\n+    {\n+        _prefix = prefix;\n+    }\n+ \n+    public Log getLog (String channel)\n+    {\n+        // Return a simple extension of AbstractLog that will log\n+        // everything to the System.err stream. Note that this is \n+        // roughly equivalent to OpenJPA's default logging behavior.\n+        return new AbstractLog ()\n+        {\n+            protected boolean isEnabled (short logLevel)\n+            {\n+                // log all levels\n+                return true;\n+            }\n+\n+            protected void log (short type, String message, Throwable t)\n+            {\n+                // just send everything to System.err\n+                System.err.println (_prefix + \": \" + type + \": \"\n+                    + message + \": \" + t);\n+            }\n+        };\n+    }\n+}</programlisting>\n+        </example>\n+        <para>\n+    To make OpenJPA use your custom log factory, set the \n+    <link linkend=\"openjpa.Log\"><literal>openjpa.Log</literal></link> \n+    configuration property to your factory's full class name.  Because\n+    this property is a plugin property (see \n+    <xref linkend=\"ref_guide_conf_plugins\"/>), you can also pass parameters\n+    to your factory.  For example, to use the example factory above and\n+    set its prefix to \"LOG MSG\", you would set the \n+    <literal>openjpa.Log</literal> property to the following string:\n+    </para>\n+        <programlisting format=\"linespecific\">\n+com.xyz.CustomLogFactory(Prefix=\"LOG MSG\")\n+</programlisting>\n+      </section>\n+    </chapter>"},{"sha":"dd8bcd6dc31cb62686e6b21a2b673bfbbb30bf04","filename":"openjpa-project/src/doc/manual/ref_guide_mapping.xml","status":"added","additions":3162,"deletions":0,"changes":3162,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_mapping.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_mapping.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_mapping.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53"},{"sha":"19b081535f8c2d1edae1e0cfe7fc5283fc849997","filename":"openjpa-project/src/doc/manual/ref_guide_meta.xml","status":"added","additions":976,"deletions":0,"changes":976,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_meta.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_meta.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_meta.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,976 @@\n+\n+    <chapter id=\"ref_guide_meta\">\n+      <title>Metadata</title>\n+      <para>\n+  The JPA Overview covers JPA metadata in \n+  <xref linkend=\"jpa_overview_meta\"/>.\n+  This chapter discusses OpenJPA's extensions to standard JPA metadata.\n+  </para>\n+      <section id=\"ref_guide_meta_factory\">\n+        <title>Metadata Factory</title>\n+        <indexterm zone=\"ref_guide_meta_factory\">\n+          <primary>metadata</primary>\n+          <secondary>loading and storing</secondary>\n+          <see>MetaDataFactory</see>\n+        </indexterm>\n+        <para>\n+    The <link linkend=\"openjpa.MetaDataFactory\"><literal>openjpa.MetaDataFactory\n+    </literal></link> configuration property controls metadata loading and\n+    storing.  This property takes a plugin string (see \n+    <xref linkend=\"ref_guide_conf_plugins\"/>) describing\n+    a concrete <ulink url=\"../apidocs/org/apache/openjpa/meta/MetaDataFactory.html\"><classname>org.apache.openjpa.meta.MetaDataFactory</classname></ulink> implementation.\n+    A metadata factory can load mapping information as well as persistence \n+    metadata, or it can leave mapping information to a separate \n+    <emphasis>mapping factory</emphasis> (see \n+    <xref linkend=\"ref_guide_mapping_factory\"/>).  \n+    OpenJPA recognizes the following built-in metadata factories:\n+    </para>\n+        <itemizedlist>\n+          <listitem>\n+            <para><literal>jpa</literal>: Standard JPA metadata.  \n+        This is an alias for the \n+        <ulink url=\"../apidocs/org/apache/openjpa/persistence/PersistenceMetaDataFactory.html\"><classname>\n+        org.apache.openjpa.persistence.PersistenceMetaDataFactory</classname></ulink>.\n+        </para>\n+          </listitem>\n+        </itemizedlist>\n+        <para>\n+    The standard metadata factories all accept the following properties for\n+    locating persistent classes.  Each property represents a different \n+    mechanism for locating persistent types; you can choose the mechanism or\n+    combination of mechanisms that are most convenient.  See \n+    <xref linkend=\"ref_guide_pc_pcclasses\"/> for a discussion of when it\n+    is necessary to list your persistent classes. \n+    </para>\n+        <itemizedlist>\n+          <listitem>\n+            <para><literal>Types</literal>: A semicolon-separated list of \n+        fully-qualified persistent class names.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><literal>Resources</literal>: A semicolon-separated list of\n+        resource paths to metadata files or jar archives.  \n+        Each jar archive will be scanned for \n+        <phrase>annotated JPA entities</phrase>\n+        \n+        \n+        .\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><literal>URLs</literal>: A semicolon-separated list of URLs\n+        of metadata files or jar archives.  \n+        Each jar archive will be scanned for \n+        <phrase>annotated JPA entities</phrase>\n+        \n+        \n+        .\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><literal>ClasspathScan</literal>: A semicolon-separated list of\n+        directories or jar archives listed in your classpath.\n+        Each directory and jar archive will be scanned for \n+        <phrase>annotated JPA entities</phrase>\n+        \n+        \n+        .\n+        </para>\n+          </listitem>\n+        </itemizedlist>\n+        <example id=\"ref_guide_meta_stdfactoryex\">\n+          <title>Setting a Standard Metadata Factory</title>\n+          <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.MetaDataFactory\" value=\"jpa\"/&gt;\n+</programlisting>\n+        </example>\n+        <example id=\"ref_guide_meta_customfactoryex\">\n+          <title>Setting a Custom Metadata Factory</title>\n+          <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.MetaDataFactory\" value=\"com.xyz.CustomMetaDataFactory\"/&gt;\n+</programlisting>\n+        </example>\n+      </section>\n+      <section id=\"ref_guide_meta_ejb\">\n+        <title>Additional JPA Metadata</title>\n+        <indexterm zone=\"ref_guide_meta_ejb\">\n+          <primary>metadata</primary>\n+          <secondary>JPA additions</secondary>\n+        </indexterm>\n+        <para>\n+    This section describes OpenJPA's core additions to standard entity\n+    metadata.  We present the object-relational mapping syntax to\n+    support these additions in <xref linkend=\"ref_guide_mapping_ejb\"/>.\n+    Finally, <xref linkend=\"ref_guide_meta_ext\"/> covers additional \n+    extensions to  JPA metadata that allow you to access auxiliary\n+    OpenJPA features.\n+    </para>\n+        <section id=\"ref_guide_meta_jpa_datastoreid\">\n+          <title>Datastore Identity</title>\n+          <indexterm zone=\"ref_guide_meta_jpa_datastoreid\">\n+            <primary>identity</primary>\n+            <secondary>datastore</secondary>\n+          </indexterm>\n+          <para>\n+      JPA typically requires you to declare one or more\n+      <literal>Id</literal> fields to act as primary keys.  OpenJPA, however,\n+      can create and maintain a surrogate primary key value when you do\n+      not declare any <literal>Id</literal> fields.  This form of \n+      persistent identity is called <emphasis>datastore \n+      identity</emphasis>.  <xref linkend=\"ref_guide_pc_oid\"/> discusses \n+      OpenJPA's support for datastore identity in JPA.  We\n+      cover how to map your datastore identity primary key column in\n+      <xref linkend=\"ref_guide_mapping_jpa_datastoreid\"/>\n+      </para>\n+        </section>\n+        <section id=\"ref_guide_meta_jpa_version\">\n+          <title>Surrogate Version</title>\n+          <indexterm zone=\"ref_guide_meta_jpa_version\">\n+            <primary>version</primary>\n+            <secondary>surrogate</secondary>\n+          </indexterm>\n+          <para>\n+      Just as OpenJPA can maintain your entity's identity without any\n+      <literal>Id</literal> fields, OpenJPA can maintain your entity's\n+      optimistic version without any <literal>Version</literal> fields.\n+      <xref linkend=\"ref_guide_mapping_jpa_version\"/> shows you how\n+      to map surrogate version columns.\n+      </para>\n+        </section>\n+        <section id=\"ref_guide_meta_jpa_persistent\">\n+          <title>Persistent Field Values</title>\n+          <indexterm zone=\"ref_guide_meta_jpa_persistent\">\n+            <primary>persistent fields</primary>\n+          </indexterm>\n+          <para>\n+      JPA defines <literal>Basic</literal>,\n+      <literal>Lob</literal>, <literal>Embedded</literal>, \n+      <literal>ManyToOne</literal>, and <literal>OneToOne</literal> \n+      persistence strategies for direct field values.  OpenJPA supports all \n+      of these standard strategies, but adds one of its own: \n+      <literal>Persistent</literal>.  The \n+      <ulink url=\"../apidocs/org/apache/openjpa/persistence/Persistent.html\"><classname>org.apache.openjpa.persistence.Persistent</classname></ulink> metadata\n+      annotation can represent any direct field value, including\n+      custom types.  It has the following properties:\n+      </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para><literal>FetchType fetch</literal>: Whether to load the\n+          field eagerly or lazily.  Corresponds exactly to the\n+          same-named property of standard JPA annotations\n+          such as <link linkend=\"jpa_overview_meta_basic\"><classname>\n+          Basic</classname></link>. Defaults to\n+          <literal>FetchType.EAGER</literal>.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>CascadeType[] cascade</literal>: Array of enum\n+          values defining cascade behavior for this field.  \n+          Corresponds exactly to the same-named property of standard\n+          JPA annotations such as \n+          <link linkend=\"jpa_overview_meta_manytoone\"><classname>\n+          ManyToOne</classname></link>. Defaults to empty array.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>String mappedBy</literal>: Names the field in the\n+          related entity that maps this bidirectional relation.\n+          Corresponds to the same-named property of standard JPA \n+          annotations such as \n+          <link linkend=\"jpa_overview_meta_onetoone\"><classname>\n+          OneToOne</classname></link>.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>boolean optional</literal>: Whether the value can\n+          be null.  Corresponds to the same-named property of standard\n+          JPA annotations such as \n+          <link linkend=\"jpa_overview_meta_manytoone\"><classname>\n+          ManyToOne</classname></link>, but can apply to non-entity\n+          object values as well. Defaults to <literal>true</literal>.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>boolean embedded</literal>: Set this property to\n+          <literal>true</literal> if the field value is stored as\n+          an embedded object.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+          <para>\n+      Though you can use the <classname>Persistent</classname> annotation\n+      in place of most of the standard direct field annotations mentioned\n+      above, we recommend primarily using it for non-standard and custom\n+      types for which no standard JPA annotation exists.  For example,\n+      <xref linkend=\"ref_guide_mapping_jpa_columns\"/> demonstrates the\n+      use of the <classname>Persistent</classname> annotation to denote\n+      a persistent <classname>java.awt.Point</classname> field.\n+      </para>\n+        </section>\n+        <section id=\"ref_guide_meta_jpa_persistent_coll\">\n+          <title>Persistent Collection Fields</title>\n+          <indexterm zone=\"ref_guide_meta_jpa_persistent_coll\">\n+            <primary>persistent fields</primary>\n+            <secondary>collection metadata</secondary>\n+          </indexterm>\n+          <para>\n+      JPA standardizes support for collections of entities with the\n+      <literal>OneToMany</literal> and <literal>ManyToMany</literal>\n+      persistence strategies.  OpenJPA expands collection support to handle\n+      collections of simple types (primitive wrappers, \n+      <classname>String</classname>s, etc), custom types, and embedded \n+      objects.\n+      </para>\n+          <para>\n+      The\n+      <ulink url=\"../apidocs/org/apache/openjpa/persistence/PersistentCollection.html\"><classname>org.apache.openjpa.persistence.PersistentCollection</classname></ulink>\n+      metadata annotation represents a persistent collection field.\n+      It has the following properties:\n+      </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para><literal>Class elementType</literal>: The class of the\n+          collection elements.  This information is usually taken \n+          from the parameterized collection element type.  You must \n+          supply it explicitly, however, if your field isn't a \n+          parameterized type.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>FetchType fetch</literal>: Whether to load the\n+          collection eagerly or lazily.  Corresponds exactly to the\n+          same-named property of standard JPA annotations\n+          such as <link linkend=\"jpa_overview_meta_basic\"><classname>\n+          Basic</classname></link>. Defaults to\n+          <literal>FetchType.LAZY</literal>.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>String mappedBy</literal>: Names the field in the\n+          related entity that maps this bidirectional relation.\n+          Corresponds to the same-named property of standard JPA \n+          annotations such as \n+          <link linkend=\"jpa_overview_meta_manytomany\"><classname>\n+          ManyToMany</classname></link>.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>CascadeType[] elementCascade</literal>: Array of \n+          enum values defining cascade behavior for the collection \n+          elements.  Corresponds exactly to the <literal>cascade\n+          </literal> property of standard JPA annotations\n+          such as <link linkend=\"jpa_overview_meta_manytomany\"><classname>ManyToMany</classname></link>. Defaults to \n+          empty array.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>boolean elementEmbedded</literal>: Set this\n+          property to <literal>true</literal> if the elements are\n+          stored as embedded objects.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+          <para><xref linkend=\"ref_guide_mapping_jpa_coll\"/> contains several \n+      examples of using <classname>PersistentCollection</classname> to \n+      mark non-standard collection fields persistent.\n+      </para>\n+        </section>\n+        <section id=\"ref_guide_meta_jpa_persistent_map\">\n+          <title>Persistent Map Fields</title>\n+          <indexterm zone=\"ref_guide_meta_jpa_persistent_map\">\n+            <primary>persistent fields</primary>\n+            <secondary>map metadata</secondary>\n+          </indexterm>\n+          <para>\n+      JPA has limited support for maps.  OpenJPA introduces the \n+      <ulink url=\"../apidocs/org/apache/openjpa/persistence/PersistentMap.html\"><classname>org.apache.openjpa.persistence.PersistentMap</classname></ulink>\n+      metadata annotation to represent a persistent map field.\n+      It has the following properties:\n+      </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para><literal>Class keyType</literal>: The class of the\n+          map keys.  This information is usually taken \n+          from the parameterized map key type.  You must \n+          supply it explicitly, however, if your field isn't a \n+          parameterized type.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>Class elementType</literal>: The class of the\n+          map values.  This information is usually taken \n+          from the parameterized map value type.  You must \n+          supply it explicitly, however, if your field isn't a \n+          parameterized type.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>FetchType fetch</literal>: Whether to load the\n+          collection eagerly or lazily.  Corresponds exactly to the\n+          same-named property of standard JPA annotations\n+          such as <link linkend=\"jpa_overview_meta_basic\"><classname>\n+          Basic</classname></link>. Defaults to\n+          <literal>FetchType.LAZY</literal>.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>CascadeType[] keyCascade</literal>: Array of \n+          enum values defining cascade behavior for the map \n+          keys.  Corresponds exactly to the <literal>cascade\n+          </literal> property of standard JPA annotations\n+          such as <link linkend=\"jpa_overview_meta_manytoone\"><classname>ManyToOne</classname></link>. Defaults to \n+          empty array.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>CascadeType[] elementCascade</literal>: Array of \n+          enum values defining cascade behavior for the map \n+          values.  Corresponds exactly to the <literal>cascade\n+          </literal> property of standard JPA annotations\n+          such as <link linkend=\"jpa_overview_meta_manytoone\"><classname>ManyToOne</classname></link>. Defaults to \n+          empty array.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>boolean keyEmbedded</literal>: Set this\n+          property to <literal>true</literal> if the map keys are\n+          stored as embedded objects.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>boolean elementEmbedded</literal>: Set this\n+          property to <literal>true</literal> if the map values are\n+          stored as embedded objects.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+          <para>\n+      Map keys and values in OpenJPA can be entities, simple types\n+      (primitive wrappers, <classname>String</classname>s, etc),\n+      custom types, or embedded objects.\n+      <xref linkend=\"ref_guide_mapping_jpa_map\"/> contains several \n+      examples of using <classname>PersistentMap</classname> to annotate \n+      persistent map fields.\n+      </para>\n+        </section>\n+      </section>\n+      <section id=\"ref_guide_meta_ext\">\n+        <title>Metadata Extensions</title>\n+        <indexterm zone=\"ref_guide_meta_ext\">\n+          <primary>metadata</primary>\n+          <secondary>extensions</secondary>\n+        </indexterm>\n+        <para>\n+    OpenJPA extends standard metadata to allow you to access advanced OpenJPA \n+    functionality. This section covers persistence metadata extensions; we \n+    discuss mapping metadata extensions in \n+    <xref linkend=\"ref_guide_mapping_ext\"/>. \n+    All metadata extensions are optional; OpenJPA will rely on its defaults\n+    when no explicit data is provided.\n+    </para>\n+        <section id=\"ref_guide_meta_class\">\n+          <title>Class Extensions</title>\n+          <para>\n+      OpenJPA recognizes the following class extensions:\n+      </para>\n+          <section id=\"fetch-groups\">\n+            <title>Fetch Groups</title>\n+            <indexterm zone=\"data-cache\">\n+              <primary>metadata</primary>\n+              <secondary>extensions</secondary>\n+              <tertiary>fetch groups</tertiary>\n+              <seealso>fetch groups</seealso>\n+            </indexterm>\n+            <para>\n+        \n+        The \n+        <ulink url=\"../apidocs/org/apache/openjpa/persistence/FetchGroups.html\"><classname>org.apache.openjpa.persistence.FetchGroups</classname></ulink>\n+        and <ulink url=\"../apidocs/org/apache/openjpa/persistence/FetchGroup.html\"><classname>org.apache.openjpa.persistence.FetchGroup</classname></ulink>\n+        annotations allow you to define fetch groups in your JPA \n+        entities.  <xref linkend=\"ref_guide_fetch\"/> discusses OpenJPA's \n+        support for fetch groups in general; see \n+        <xref linkend=\"ref_guide_fetch_custom\"/> for how to use these\n+        annotations in particular.\n+        </para>\n+          </section>\n+          <section id=\"data-cache\">\n+            <title>Data Cache</title>\n+            <indexterm zone=\"data-cache\">\n+              <primary>metadata</primary>\n+              <secondary>extensions</secondary>\n+              <tertiary>data cache</tertiary>\n+              <seealso>caching</seealso>\n+            </indexterm>\n+            <para><xref linkend=\"ref_guide_cache\"/> examines caching in OpenJPA.  \n+        Metadata extensions allow individual classes to override \n+        system caching defaults.\n+        </para>\n+            <para>\n+        OpenJPA defines the \n+        <ulink url=\"../apidocs/org/apache/openjpa/persistence/DataCache.html\"><classname>org.apache.openjpa.persistence.DataCache</classname></ulink>\n+        annotation for caching information.  This annotation has the\n+        following properties:\n+        </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para><literal>boolean enabled</literal>: Whether to cache\n+            data for instances of the class.  Defaults to\n+            <literal>true</literal> for base classes, or the\n+            superclass value for subclasses.  If you set this \n+            property to <literal>false</literal>, all other \n+            properties are ignored.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>String name</literal>: Place data for instances\n+            of the class in a named cache.  By default, instance \n+            data is placed in the same cache as superclass data, or\n+            the default cache configured through\n+            the <link linkend=\"openjpa.DataCache\"><literal>\n+            openjpa.DataCache</literal></link> configuration property\n+            for base classes.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>int timeout</literal>: The number of \n+            milliseconds data for the class remains valid.  Use\n+            -1 for no timeout.  Defaults to the\n+            <link linkend=\"openjpa.DataCacheTimeout\"><literal>\n+            openjpa.DataCacheTimeout</literal></link> property value.\n+            </para>\n+              </listitem>\n+            </itemizedlist>\n+            <para>\n+        The <literal>data-cache</literal> key accepts the \n+        following values:\n+        </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para><literal>true</literal>: Use the default cache, as\n+            configured by the <link linkend=\"openjpa.DataCache\"><literal>openjpa.DataCache</literal></link> configuration \n+            property. This is the default when no extension is \n+            given, unless a superclass names a different cache.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>false</literal>: Data for instances of this \n+            class should not be cached.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>&lt;cache-name&gt;</literal>:  Place data for\n+            instances of this class into the cache with name \n+            <literal>&lt;cache-name&gt;</literal>.\n+            </para>\n+              </listitem>\n+            </itemizedlist>\n+          </section>\n+          <section id=\"detached-state-field\">\n+            <title>Detached State</title>\n+            <indexterm zone=\"detached-state-field\">\n+              <primary>metadata</primary>\n+              <secondary>extensions</secondary>\n+              <tertiary>detached state field</tertiary>\n+              <seealso>detachment</seealso>\n+            </indexterm>\n+            <para>\n+        The OpenJPA <link linkend=\"ref_guide_pc_enhance\">enhancer</link> \n+        may add a synthetic field to detachable classes to hold detached\n+        state (see <xref linkend=\"ref_guide_detach_graph\"/> \n+        for details).  You can instead declare your own detached state \n+        field or supress the creation of a detached state field \n+        altogether.  In the latter case, your class must not use \n+        <link linkend=\"ref_guide_pc_oid\">datastore identity</link>,\n+        and should declare a version field to detect optimistic \n+        concurrency errors during detached modifications.\n+        </para>\n+            <para>\n+        OpenJPA defines the \n+        <ulink url=\"../apidocs/org/apache/openjpa/persistence/DetachedState.html\"><classname>org.apache.openjpa.persistence.DetachedState</classname></ulink> annotation for controlling detached state.  When used\n+        to annotate a class, <classname>DetachedState</classname>\n+        recognizes the following properties:\n+        </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para><literal>boolean enabled</literal>: Set to false to\n+            suppress the use of detached state.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>String fieldName</literal>: Use this property \n+            to declare your own detached state field.  The field\n+            must be of type <classname>Object</classname>.  \n+            Typically this property is only used if the field is\n+            inherited from a non-persisted superclass.  If the field\n+            is declared in your entity class, you will typically\n+            annotate the field directly, as described below.\n+            </para>\n+              </listitem>\n+            </itemizedlist>\n+            <para>\n+        If you declare your own detached state field, you can annotate\n+        that field with <classname>DetachedState</classname> directly,\n+        rather than placing the annotation at the class level and using\n+        the <literal>fieldName</literal> property.  When placed on a\n+        field, <classname>DetachedState</classname> acts as a marker \n+        annotation; it does not recognize any properties.  Your \n+        annotated field must be of type <classname>Object</classname>.\n+        </para>\n+          </section>\n+          <section id=\"lock-groups\">\n+            <title>Lock Groups</title>\n+            <para>\n+        OpenJPA requires you to pre-declare subclass lock groups in the\n+        least-derived mapped class.  \n+        <phrase>\n+        The JPA \n+        <ulink url=\"../apidocs/org/apache/openjpa/persistence/LockGroups.html\"><classname>org.apache.openjpa.persistence.LockGroups</classname></ulink>\n+        annotation accepts an array of lock group names.\n+        </phrase>\n+        \n+        For details on lock groups, see \n+        <xref linkend=\"ref_guide_lock_groups_and_subclasses\"/>.\n+        </para>\n+          </section>\n+          <section id=\"auditable\">\n+            <title>Auditable</title>\n+            <para>\n+        Reserved for future use.\n+        </para>\n+          </section>\n+        </section>\n+        <section id=\"ref_guide_meta_field\">\n+          <title>Field Extensions</title>\n+          <para>\n+      OpenJPA recognizes the following field extensions:\n+      </para>\n+          <section id=\"dependent\">\n+            <title>Dependent</title>\n+            <indexterm zone=\"data-cache\">\n+              <primary>metadata</primary>\n+              <secondary>extensions</secondary>\n+              <tertiary>dependent</tertiary>\n+            </indexterm>\n+            <para>\n+        In a <emphasis>dependent</emphasis> relation, the referenced\n+        object is deleted whenever the owning object is deleted, or \n+        whenever the relation is severed by nulling or resetting the \n+        owning field.  For example, if the \n+        <literal>Magazine.coverArticle</literal> field is marked \n+        dependent, then setting <literal>Magazine.coverArticle</literal>\n+        to a new <classname>Article</classname> instance will \n+        automatically delete the old <classname>Article</classname> \n+        stored in the field.  Similarly, deleting a <classname>Magazine\n+        </classname> object will automatically delete its current cover\n+        <classname>Article</classname>.\n+        You can prevent an orphaned dependent object from being deleted\n+        by assigning it to another relation in the same transaction.\n+        </para>\n+            <para>\n+        \n+        OpenJPA offers a family of marker annotations to\n+        denote dependent relations in JPA entities:\n+        </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para><ulink url=\"../apidocs/org/apache/openjpa/persistence/Dependent.html\"><classname>\n+            org.apache.openjpa.persistence.Dependent</classname></ulink>: Marks\n+            a direct relation as dependent.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para><ulink url=\"../apidocs/org/apache/openjpa/persistence/ElementDependent.html\"><classname>\n+            org.apache.openjpa.persistence.ElementDependent</classname></ulink>: \n+            Marks the entity elements of a collection, array, or \n+            map field as dependent.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para><ulink url=\"../apidocs/org/apache/openjpa/persistence/KeyDependent.html\"><classname>\n+            org.apache.openjpa.persistence.KeyDependent</classname></ulink>: \n+            Marks the key entities in a map field as dependent.\n+            </para>\n+              </listitem>\n+            </itemizedlist>\n+          </section>\n+          <section id=\"lrs\">\n+            <title>LRS</title>\n+            <indexterm zone=\"lrs\">\n+              <primary>metadata</primary>\n+              <secondary>extensions</secondary>\n+              <tertiary>lrs</tertiary>\n+              <seealso>large result sets</seealso>\n+            </indexterm>\n+            <para>\n+        This boolean extension, denoted by \n+        <phrase>\n+        the JPA <ulink url=\"../apidocs/org/apache/openjpa/persistence/LRS.html\"><classname>org.apache.openjpa.persistence.LRS</classname></ulink> annotation,\n+        </phrase>\n+        \n+        \n+        indicates that a field should use \n+        OpenJPA's special large result set collection or map proxies.  \n+        A complete description of large result set proxies is \n+        available in <xref linkend=\"ref_guide_pc_scos_proxy_lrs\"/>.\n+        </para>\n+          </section>\n+          <section id=\"order-by\">\n+            <title>Order-By</title>\n+            <indexterm zone=\"order-by\">\n+              <primary>metadata</primary>\n+              <secondary>extensions</secondary>\n+              <tertiary>order-by</tertiary>\n+            </indexterm>\n+            <para><phrase>\n+        The JPA Overview's \n+        <xref linkend=\"jpa_overview_meta_orderby\"/> describes JPA's \n+        <literal>OrderBy</literal> annotation for loading the elements\n+        of collection fields in a prescribed order.\n+        </phrase>\n+        \n+        \n+        \n+        Ordering syntax is as follows:\n+        </para>\n+            <programlisting format=\"linespecific\">\n+#element|&lt;field name&gt;[ asc|ascending|desc|descending][, ...]\n+</programlisting>\n+            <para>\n+        The token <literal>#element</literal> represents the element\n+        value.  Simple element types such as strings and primitive\n+        wrappers are sorted based on their natural ordering.  If the\n+        collection holds persistent objects, its elements are sorted \n+        based on the natural ordering of the objects' primary key \n+        values.  By substituting a field name for the <literal>\n+        #element</literal> token, you can order a collection of \n+        persistent objects by an arbitrary field in the related type,\n+        rather than by primary key.\n+        </para>\n+            <para>\n+        The field name or <literal>#element</literal> token may be\n+        followed by the keywords <literal>asc/ascending</literal> or \n+        <literal>desc/descending</literal> in either all-upper or \n+        all-lower case to mandate ascending and descending order.\n+        If the direction is omitted, OpenJPA defaults to ascending order.\n+        </para>\n+            <para>\n+        Note that the defined ordering is only applied when the \n+        collection is loaded from the datastore.  It is not maintained\n+        by OpenJPA as you modify the collection in memory.\n+        </para>\n+            <para>\n+        The following ordering string orders a collection by its \n+        element values in descending order:\n+        </para>\n+            <programlisting format=\"linespecific\">\n+\"#element desc\"\n+</programlisting>\n+            <para>\n+        The following ordering string orders a collection of \n+        <classname>Author</classname> objects by each author's last\n+        name in ascending order.  If two last names are equal, the\n+        authors are ordered by first name in ascending order.\n+        </para>\n+            <programlisting format=\"linespecific\">\n+\"firstName, lastName\"\n+</programlisting>\n+          </section>\n+          <section id=\"inverse-logical\">\n+            <title>Inverse-Logical</title>\n+            <indexterm zone=\"inverse-logical\">\n+              <primary>metadata</primary>\n+              <secondary>extensions</secondary>\n+              <tertiary>inverse-logical</tertiary>\n+              <seealso>bidirectional relations</seealso>\n+            </indexterm>\n+            <para>\n+        This extension names the inverse field in a logical \n+        bidirectional relation.  \n+        <phrase>\n+        To create a logical bidrectional relation in OpenJPA, use the\n+        <ulink url=\"../apidocs/org/apache/openjpa/persistence/InverseLogical.html\"><classname>org.apache.openjpa.persistence.InverseLogical</classname></ulink> \n+        annotation.\n+        </phrase>\n+        \n+        We discuss logical bidirectional relations and this extension\n+        in detail in <xref linkend=\"ref_guide_inverses\"/>.\n+        </para>\n+          </section>\n+          <section id=\"lock-group\">\n+            <title>Lock Group</title>\n+            <indexterm zone=\"lock-group\">\n+              <primary>metadata</primary>\n+              <secondary>extensions</secondary>\n+              <tertiary>lock group</tertiary>\n+              <seealso>locking</seealso>\n+            </indexterm>\n+            <para>\n+        Lock groups allow for fine-grained optimistic locking \n+        concurrency.  \n+        Use\n+        <phrase>\n+        OpenJPA's \n+        <ulink url=\"../apidocs/org/apache/openjpa/persistence/LockGroup.html\"><classname>org.apache.openjpa.persistence.LockGroup</classname></ulink>\n+        annotation\n+        </phrase>\n+        \n+        \n+        to name the lock group for a field.  You can exclude a field \n+        from optimistic locking with a value of <literal>none</literal>.\n+        We discuss lock groups and this extension further in \n+        <xref linkend=\"ref_guide_lock_groups\"/>.\n+        </para>\n+          </section>\n+          <section id=\"read-only\">\n+            <title>Read-Only</title>\n+            <indexterm zone=\"read-only\">\n+              <primary>metadata</primary>\n+              <secondary>extensions</secondary>\n+              <tertiary>read-only</tertiary>\n+              <seealso>persistent fields</seealso>\n+            </indexterm>\n+            <indexterm zone=\"read-only\">\n+              <primary>persistent fields</primary>\n+              <secondary>read only</secondary>\n+            </indexterm>\n+            <para>\n+        The read-only extension makes a field unwritable.  The \n+        extension only applies to existing persistent objects; new \n+        object fields are always writeable.\n+        </para>\n+            <para>\n+        To mark a field read-only in JPA metadata, set the\n+        <ulink url=\"../apidocs/org/apache/openjpa/persistence/ReadOnly.html\"><classname>org.apache.openjpa.persistence.ReadOnly</classname></ulink>\n+        annotation to a\n+        <ulink url=\"../apidocs/org/apache/openjpa/persistence/UpdateAction.html\"><classname>org.apache.openjpa.persistence.UpdateAction</classname></ulink>\n+        enum value.  The <classname>UpdateAction</classname> enum\n+        includes:\n+        </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para><literal>UpdateAction.IGNORE</literal>: Updates to the \n+            field are completely ignored.  The field is not \n+            considered dirty.\n+            The new value will not even get stored in the\n+            OpenJPA <link linkend=\"ref_guide_cache\">data cache</link>.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>UpdateAction.RESTRICT</literal>: Any attempt \n+            to change the field will result in an immediate \n+            exception.\n+            </para>\n+              </listitem>\n+            </itemizedlist>\n+          </section>\n+          <section id=\"type\">\n+            <title>Type</title>\n+            <indexterm zone=\"type\">\n+              <primary>metadata</primary>\n+              <secondary>extensions</secondary>\n+              <tertiary>type</tertiary>\n+              <seealso>persistent fields</seealso>\n+            </indexterm>\n+            <para>\n+        OpenJPA has three levels of support for relations:\n+        </para>\n+            <orderedlist>\n+              <listitem>\n+                <para>\n+            Relations that hold a reference to an object of a \n+            concrete persistent class are supported by storing \n+            the primary key values of the related instance in \n+            the database.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para>\n+            Relations that hold a reference to an object of an\n+            unknown persistent class are supported by storing \n+            the stringified identity value of the related \n+            instance.  This level of support does not allow \n+            queries across the relation.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para>\n+            Relations that hold an unknown object or interface.\n+            The only way to support these relations is to \n+            serialize their value to the database.  This does \n+            not allow you to query the field, and is not very \n+            efficient.\n+            </para>\n+              </listitem>\n+            </orderedlist>\n+            <para>\n+        Clearly, when you declare a field's type to be another\n+        persistence-capable class, OpenJPA uses level 1 support.  \n+        By default, OpenJPA assumes that any interface-typed fields \n+        you declare will be implemented only by other persistent \n+        classes, and assigns interfaces level 2 support.  The exception\n+        to this rule is the <classname>java.io.Serializable</classname> \n+        interface.  If you declare a field to be of type \n+        <classname>Serializable</classname>, OpenJPA lumps it\n+        together with <classname>java.lang.Object</classname>\n+        fields and other non-interface, unrecognized field types,\n+        which are all assigned level 3 support.\n+        </para>\n+            <para>\n+        With OpenJPA's type family of metadata extensions, you can \n+        control the level of support given to your \n+        unknown/interface-typed fields.  Setting the value of this \n+        extension to \n+        <phrase><classname>Entity</classname></phrase>\n+        \n+        \n+        \n+        indicates that the field value will always be some persistent \n+        object, and gives level 2 support.  Setting the value of this\n+        extension to the class of a concrete persistent\n+        type is even better; it gives you level 1 \n+        support (just as if you had declared your field to be\n+        of that type in the first place).  Setting this extension\n+        to <classname>Object</classname> uses level 3 \n+        support.  This is useful when you have an interface\n+        relation that may <emphasis role=\"bold\">not</emphasis> \n+        hold other persistent objects (recall that OpenJPA \n+        assumes interface fields will always hold persistent\n+        instances by default).\n+        </para>\n+            <para>\n+        This extension is also used with OpenJPA's externalization feature,\n+        described in <xref linkend=\"ref_guide_pc_extern\"/>.\n+        </para>\n+            <para>\n+        OpenJPA defines the following type annotations for field \n+        values, collection, array, and map elements, and map keys,\n+        respectively:\n+        </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para>\n+                  <ulink url=\"../apidocs/org/apache/openjpa/persistence/Type.html\">\n+                    <classname>org.apache.openjpa.persistence.Type</classname>\n+                  </ulink>\n+                </para>\n+              </listitem>\n+              <listitem>\n+                <para>\n+                  <ulink url=\"../apidocs/org/apache/openjpa/persistence/ElementType.html\">\n+                    <classname>org.apache.openjpa.persistence.ElementType\n+            </classname>\n+                  </ulink>\n+                </para>\n+              </listitem>\n+              <listitem>\n+                <para>\n+                  <ulink url=\"../apidocs/org/apache/openjpa/persistence/KeyType.html\">\n+                    <classname>org.apache.openjpa.persistence.KeyType\n+            </classname>\n+                  </ulink>\n+                </para>\n+              </listitem>\n+            </itemizedlist>\n+          </section>\n+          <section id=\"externalizer\">\n+            <title>Externalizer</title>\n+            <indexterm zone=\"externalizer\">\n+              <primary>metadata</primary>\n+              <secondary>extensions</secondary>\n+              <tertiary>externalizer</tertiary>\n+              <seealso>externalization</seealso>\n+            </indexterm>\n+            <para>\n+        The \n+        <phrase>\n+        JPA \n+        <ulink url=\"../apidocs/org/apache/openjpa/persistence/Externalizer.html\"><classname>org.apache.openjpa.persistence.Externalizer</classname></ulink>\n+        annotation\n+        </phrase>\n+        \n+        \n+        names a method to transform a field value into a value of \n+        another type.  See <xref linkend=\"ref_guide_pc_extern\"/>\n+        for details.\n+        </para>\n+          </section>\n+          <section id=\"factory\">\n+            <title>Factory</title>\n+            <indexterm zone=\"factory\">\n+              <primary>metadata</primary>\n+              <secondary>extensions</secondary>\n+              <tertiary>factory</tertiary>\n+              <seealso>externalization</seealso>\n+            </indexterm>\n+            <para>\n+        The \n+        <phrase>\n+        JPA <ulink url=\"../apidocs/org/apache/openjpa/persistence/Factory.html\"><classname>org.apache.openjpa.persistence.Factory</classname></ulink>\n+        annotation\n+        </phrase>\n+        \n+        \n+        names a method to re-create a field value from its \n+        externalized form.  See <xref linkend=\"ref_guide_pc_extern\"/> \n+        for details.\n+        </para>\n+          </section>\n+          <section id=\"external-values\">\n+            <title>External Values</title>\n+            <indexterm zone=\"factory\">\n+              <primary>metadata</primary>\n+              <secondary>extensions</secondary>\n+              <tertiary>external values</tertiary>\n+              <seealso>externalization</seealso>\n+            </indexterm>\n+            <para>\n+        The \n+        <phrase>\n+        JPA \n+        <ulink url=\"../apidocs/org/apache/openjpa/persistence/ExternalValues.html\"><classname>org.apache.openjpa.persistence.ExternalValues</classname></ulink>\n+        annotation\n+        </phrase>\n+        \n+        \n+        declares values for transformation of simple fields\n+        to different constant values in the datastore.\n+        See <xref linkend=\"ref_guide_pc_extern_values\"/> for details.\n+        </para>\n+          </section>\n+        </section>\n+        <section id=\"ref_guide_meta_example\">\n+          <title>Example</title>\n+          <para>\n+      The following example shows you how to specify extensions in \n+      metadata.\n+      </para>\n+          <example id=\"ref_guide_metaex\">\n+            <title>OpenJPA Metadata Extensions</title>\n+            <programlisting format=\"linespecific\">\n+import org.apache.openjpa.persistence.*;\n+\n+@Entity\n+@DataCache(enabled=false)\n+public class Magazine\n+{\n+    @ManyToMany\n+    @LRS\n+    @LockGroup(LockGroup.NONE)\n+    private Collection&lt;Subscriber&gt; subscribers;\n+\n+    @ExternalValues({\"true=1\", \"false=2\"})\n+    @Type(int.class)\n+    private boolean weekly;\n+\n+    @PersistentCollection\n+    @OrderBy(\"#element DESC\")\n+    private List&lt;String&gt; subtitles;\n+\n+    ...\n+}\n+</programlisting>\n+          </example>\n+        </section>\n+      </section>\n+    </chapter>"},{"sha":"cd6cc93eb6398071adcccf436a42ab5170d1df98","filename":"openjpa-project/src/doc/manual/ref_guide_optimization.xml","status":"added","additions":666,"deletions":0,"changes":666,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_optimization.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_optimization.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_optimization.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,666 @@\n+\n+    <chapter id=\"ref_guide_optimization\">\n+      <title>Optimization Guidelines</title>\n+      <indexterm zone=\"ref_guide_optimization\">\n+        <primary>optimization guidelines</primary>\n+      </indexterm>\n+      <para>\n+  There are numerous techniques you can use in order to ensure that OpenJPA \n+  operates in the fastest and most efficient manner. Following are some \n+  guidelines. Each describes what impact it will have on performance and\n+  scalability. Note that general guidelines regarding performance or\n+  scalability issues are just that - guidelines. Depending on the\n+  particular characteristics of your application, the optimal settings\n+  may be considerably different than what is outlined below.\n+  </para>\n+      <para>\n+  In the following table, each row is labeled with a list of\n+  italicized keywords. These keywords identify what characteristics\n+  the row in question may improve upon.  Many of the rows are marked with \n+  one or both of the <emphasis>performance</emphasis> and \n+  <emphasis>scalability</emphasis> labels. It is important to bear\n+  in mind the differences between performance and scalability (for the\n+  most part, we are referring to system-wide scalability, and not\n+  necessarily only scalability within a single JVM). The\n+  performance-related hints will probably improve the performance of\n+  your application for a given user load, whereas the\n+  scalability-related hints will probably increase the total number of\n+  users that your application can service. Sometimes, increasing\n+  performance will decrease scalability, and vice versa. Typically,\n+  options that reduce the amount of work done on the database server\n+  will improve scalability, whereas those that push more work onto the\n+  server will have a negative impact on scalability.\n+  </para>\n+      <table>\n+        <title>Optimization Guidelines</title>\n+        <tgroup cols=\"2\" align=\"left\" colsep=\"1\" rowsep=\"1\">\n+          <colspec colname=\"name\"/>\n+          <colspec colname=\"desc\" colwidth=\"4*\"/>\n+          <tbody valign=\"top\">\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Optimize database indexes</emphasis>\n+                <para>\n+                  <emphasis>performance, scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\"> \n+          The default set of indexes created by OpenJPA's mapping \n+          tool may not always be the most appropriate for your \n+          application. Manually setting indexes in your mapping\n+          metadata or manually manipulating database indexes to \n+          include frequently-queried fields (as well as dropping \n+          indexes on rarely-queried fields) can yield significant \n+          performance benefits.\n+          <para>\n+          A database must do extra work on insert, update, and\n+          delete to maintain an index. This extra work will benefit\n+          selects with WHERE clauses, which will execute much faster\n+          when the terms in the WHERE clause are appropriately\n+          indexed. So, for a read-mostly application, appropriate\n+          indexing will slow down updates (which are rare) but greatly\n+          accelerate reads. This means that the system as a whole will\n+          be faster, and also that the database will experience less\n+          load, meaning that the system will be more scalable.\n+          </para>\n+          <para>\n+          Bear in mind that over-indexing is a bad thing, both\n+          for scalability and performance, especially for applications\n+          that perform lots of inserts, updates, or deletes.\n+          </para>\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Use the best JDBC driver</emphasis>\n+                <para>\n+                  <emphasis>performance, scalability, reliability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\"> \n+          The JDBC driver provided by the database vendor is not \n+          always the fastest and most efficient. Some JDBC drivers \n+          do not support features like batched statements, the lack \n+          of which can significantly slow down OpenJPA's data access\n+          and increase load on the database, reducing system \n+          performance and scalability.\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">JVM optimizations</emphasis>\n+                <para>\n+                  <emphasis>performance, reliability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\"> \n+          Manipulating various parameters of the Java Virtual Machine\n+          (such as hotspot compilation modes and the maximum memory)\n+          can result in performance improvements. For more details\n+          about optimizing the JVM execution environment, please see \n+          <ulink url=\"http://java.sun.com/docs/hotspot/PerformanceFAQ.html\"/>.\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Use the data cache</emphasis>\n+                <para>\n+                  <emphasis>performance, scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\"> \n+          Using OpenJPA's <link linkend=\"ref_guide_cache\">data and \n+          query caching</link> features can often result \n+          in a dramatic improvement in performance. Additionally, \n+          these caches can significantly reduce the amount of load on\n+          the database, increasing the scalability characteristics of\n+          your application.  Also, be sure to read about the \n+          <link linkend=\"ref_guide_cache_concurrent\">concurrent cache\n+          </link> option to see if it fits your needs.\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Set <literal>LargeTransaction\n+          </literal> to true, or set <literal>PopulateDataCache\n+          </literal> to false</emphasis>\n+                <para>\n+                  <emphasis>performance vs. scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\"> \n+          When using OpenJPA's <link linkend=\"ref_guide_cache\">data \n+          caching</link> features (available in OpenJPA JDO \n+          Performance Pack and Enterprise Edition) \n+          in a transaction that will delete, modify, or create \n+          a very large number of objects you can set <literal>\n+          LargeTransaction</literal> to true and perform periodic \n+          flushes during your transaction to reduce its memory \n+          requirements.  See the Javadoc:\n+          <phrase><ulink url=\"javadoc/openjpa/persistence/OpenJPAEntityManager.html\">\n+          OpenJPAEntityManager.setLargeTransaction</ulink></phrase>\n+          \n+          \n+          Note that transactions in large mode have to\n+          more aggressively flush items from the data cache.\n+          <para>\n+          If your transaction will visit objects that you know\n+          are very unlikely to be accessed by other transactions,\n+          for example an exhaustive report run only once a month,\n+          you can turn off population of the data cache so that\n+          the transaction doesn't fill the entire data cache with\n+          objects that won't be accessed again.\n+          Again, see the Javadoc: \n+          <phrase><ulink url=\"javadoc/openjpa/persistence/OpenJPAEntityManager.html\">\n+          OpenJPAEntityManager.setPopulateDataCache</ulink></phrase>\n+          \n+          \n+          </para>\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Disable logging, performance \n+          tracking</emphasis>\n+                <para>\n+                  <emphasis>performance</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\"> \n+          Developer options such as verbose logging and the \n+          JDBC performance tracker can result in serious performance \n+          hits for your application. Before evaluating OpenJPA's\n+          performance, these options should all be disabled.\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Set <literal>IgnoreChanges</literal> \n+          to true, or set <literal>FlushBeforeQueries</literal> to \n+          true</emphasis>\n+                <para>\n+                  <emphasis>performance vs. scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\">\n+          When both the <link linkend=\"openjpa.IgnoreChanges\"><literal>openjpa.IgnoreChanges</literal></link> and \n+          <link linkend=\"openjpa.FlushBeforeQueries\"><literal>\n+          openjpa.FlushBeforeQueries</literal></link> properties are set\n+          to false, OpenJPA needs to consider in-memory dirty instances \n+          during queries.  This can sometimes result in OpenJPA needing \n+          to evaluate the entire extent objects in order to \n+          return the correct query results, which can have drastic \n+          performance consequences.  If it is appropriate for your \n+          application, configuring \n+          <literal>FlushBeforeQueries</literal>\n+          to automatically flush before queries involving dirty\n+          objects will ensure that this never\n+          happens. Setting <literal>IgnoreChanges</literal> to \n+          false will result in a small performance hit even if \n+          <literal>FlushBeforeQueries</literal> is true, as \n+          incremental flushing is not as efficient overall as \n+          delaying all flushing to a single operation during commit. \n+          This is because incrementally flushing decreases OpenJPA's \n+          ability to maximize statement batching, and increases \n+          resource utilization.\n+          <para>\n+          Note that the default setting of \n+          <literal>FlushBeforeQueries</literal> is \n+          <literal>with-connection</literal>, which means that data \n+          will be flushed only if a dedicated connection is already \n+          in use by the <classname>EntityManager</classname>. \n+          So, the default value may not be appropriate for you.\n+          </para>\n+          \n+          \n+          <para>\n+          Setting <literal>IgnoreChanges</literal> to \n+          <literal>true</literal> will help performance, since dirty\n+          objects can be ignored for queries, meaning that \n+          incremental flushing or client-side processing\n+          is not necessary. It will also improve scalability, since \n+          overall database server usage is diminished.  On the other \n+          hand, setting <literal>IgnoreChanges</literal> to \n+          <literal>false</literal> will have a negative impact on\n+          scalability, even when using automatic flushing before\n+          queries, since more operations will be performed on the\n+          database server.\n+          </para>\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Configure <literal>\n+          openjpa.ConnectionRetainMode</literal> appropriately</emphasis>\n+                <para>\n+                  <emphasis>performance vs. scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\">\n+          The <link linkend=\"openjpa.ConnectionRetainMode\"><literal>\n+          ConnectionRetainMode</literal></link> configuration option \n+          controls when OpenJPA will obtain a connection, and how long \n+          it will hold that connection. The optimal settings for this\n+          option will vary considerably depending on the particular \n+          behavior of your application. You may even benefit from \n+          using different retain modes for different parts of your\n+          application.\n+          <para>\n+          The default setting of <literal>on-demand</literal> \n+          minimizes the amount of time that OpenJPA holds onto a \n+          datastore connection. This is generally the best option \n+          from a scalability standpoind, as database resources are \n+          held for a minimal amount of time. However, if your \n+          connection pool is overly small relative to the number of \n+          concurrent sessions that need access to the \n+          database, or if your <classname>DataSource</classname> is \n+          not efficient at managing its pool, then this default value \n+          could cause undesirable pool contention.\n+          </para>\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Ensure that batch updates are \n+          available</emphasis>\n+                <para>\n+                  <emphasis>performance, scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\"> \n+          When performing bulk inserts, updates, or deletes, OpenJPA \n+          will use batched statements. If this feature is not \n+          available in your JDBC driver, then OpenJPA will need to \n+          issue multiple SQL statements instead of a single batch \n+          statement.\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Use \n+          flat inheritance</emphasis>\n+                <para>\n+                  <emphasis>performance, scalability vs. disk space</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\"> \n+          Mapping inheritance hierarchies to a single database table\n+          is faster for most operations than other strategies\n+          employing multiple tables. If it is appropriate for your \n+          application, you should use this strategy whenever possible.\n+          <para>\n+          However, this strategy will require more disk \n+          space on the database side. Disk space is relatively \n+          inexpensive, but if your object featureSelection is particularly \n+          large, it can become a factor.\n+          </para>\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">High sequence increment</emphasis>\n+                <para>\n+                  <emphasis>performance, scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\"> \n+          For applications that perform large bulk inserts, the \n+          retrieval of sequence numbers can be a bottleneck. \n+          Increasing sequence increments and using table-based rather\n+          than native database sequences can reduce or eliminate \n+          this bottleneck. In some cases,\n+          implementing your own sequence factory can further optimize\n+          sequence number retrieval.\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Use optimistic transactions</emphasis>\n+                <para>\n+                  <emphasis>performance, scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\"> \n+          Using datastore transactions translates into pessimistic \n+          database row locking, which can be a performance hit \n+          (depending on the database). If appropriate for your \n+          application, optimistic transactions are typically faster \n+          than datastore transactions.\n+          <para>\n+          Optimistic transactions provide the same transactional\n+          guarantees as datastore transactions, except that you must\n+          handle a potential optimistic verification exception at the\n+          end of a transaction instead of assuming that a transaction\n+          will successfully complete. In many applications, it is\n+          unlikely that different concurrent transactions will operate\n+          on the same set of data at the same time, so optimistic\n+          verification increases the concurrency, and therefore both\n+          the performance and scalability characteristics, of the\n+          application. A common approach to handling optimistic\n+          verification exceptions is to simply present the end user\n+          with the fact that concurrent modifications happened, and\n+          require that the user redo any work.\n+          </para>\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Use query aggregates and projections\n+          </emphasis>\n+                <para>\n+                  <emphasis>performance, scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\">\n+          Using aggregates to compute reporting data on the database\n+          server can drastically speed up queries.  Similarly, using\n+          projections when you are interested in specific\n+          object fields or relations rather than the entire object\n+          state can reduce the amount of data OpenJPA must transfer\n+          from the database to your application.\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Always close resources</emphasis>\n+                <para>\n+                  <emphasis>scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\">\n+                <para>  \n+          Under certain settings, <classname>\n+          EntityManager</classname>s, OpenJPA <classname>Extent\n+          </classname> iterators, and <classname>Query</classname> \n+          results may be backed by resources in the database.  \n+          </para>\n+                <para>\n+          For example, if you have\n+          configured OpenJPA to use scrollable cursors and lazy object\n+          instantiation by default, each query result will hold open \n+          a <classname>ResultSet</classname> object, which, in turn, \n+          will hold open a <classname>Statement</classname> object \n+          (preventing it from being re-used).  Garbage collection \n+          will clean up these resources, so it is never necessary to \n+          explicitly close them, but it is always faster if it is \n+          done at the application level.\n+          </para>\n+              </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Optimize connection pool \n+          settings</emphasis>\n+                <para>\n+                  <emphasis>performance, scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\">\n+                <para>\n+            OpenJPA's built-in connection pool's default settings may\n+          not be optimal for all applications. For applications that\n+          instantiate and close many <classname>\n+          EntityManager</classname>s (such as a\n+          web application), increasing the size of the connection\n+          pool will reduce the overhead of waiting on free connections\n+          or opening new connections.  \n+          </para>\n+                <para>\n+          You may want to tune the \n+          prepared statement pool size with the connection pool size.\n+          </para>\n+              </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Use detached state managers</emphasis>\n+                <para>\n+                  <emphasis>performance</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\">\n+                <para>\n+          Attaching and even persisting instances can be more \n+          efficient when your detached objects use detached state \n+          managers.  By default, OpenJPA does not use detached state \n+          managers when serializing an instance across tiers.  See \n+          <xref linkend=\"ref_guide_detach_graph\"/> for how to force\n+          OpenJPA to use detached state managers across tiers, and for\n+          other options for more efficient attachment.\n+          </para>\n+                <para>\n+          The downside of using a detached state manager\n+          across tiers is that your enhanced persistent classes and\n+          the OpenJPA libraries must be available on the client tier.\n+          </para>\n+              </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Utilize the <classname>\n+          EntityManager</classname> cache</emphasis>\n+                <para>\n+                  <emphasis>performance, scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\"> \n+          When possible and appropriate, re-using <classname>\n+          EntityManager</classname>s and setting the \n+          <link linkend=\"openjpa.RetainState\"><literal>\n+          RetainState</literal></link> configuration option to \n+          <literal>true</literal> may result in significant \n+          performance gains, since the <classname>\n+          EntityManager</classname>'s built-in\n+          object cache will be used.\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Enable multithreaded operation only \n+          when necessary</emphasis>\n+                <para>\n+                  <emphasis>performance</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\">\n+          OpenJPA respects the <link linkend=\"openjpa.Multithreaded\"><literal>openjpa.Multithreaded</literal></link> option in\n+          that it does not impose synchronization overhead for\n+          applications that set this value to \n+          <literal>false</literal>. If your application is \n+          guaranteed to only use single-threaded access to OpenJPA\n+          resources and persistent objects, setting this option to \n+          <literal>false</literal> will result\n+          in the elimination of synchronization overhead, and may \n+          result in a modest performance increase.\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Enable large data set \n+          handling</emphasis>\n+                <para>\n+                  <emphasis>performance, scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\">\n+          If you execute queries that return large numbers of objects\n+          or have relations (collections or maps) that are large, and\n+          if you often only access parts of these data sets, enabling\n+          <link linkend=\"ref_guide_dbsetup_lrs\">large result set \n+          handling</link> where appropriate can\n+          dramatically speed up your application, since OpenJPA will\n+          bring the data sets into memory from the database only as\n+          necessary.\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Disable large data set handling\n+          </emphasis>\n+                <para>\n+                  <emphasis>performance, scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\">\n+          If you have enabled scrollable result sets and on-demand \n+          loading but do you not require it, consider disabling it \n+          again.  Some JDBC drivers and databases (SQLServer for \n+          example) are much slower when used with scrolling result \n+          sets.\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Use short discriminator values, or\n+          turn off the discriminator\n+          </emphasis>\n+                <para>\n+                  <emphasis>performance, scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\">\n+          The default discriminator strategy of storing the class\n+          name in the discriminator column is quite robust, in that \n+          it can handle any class and needs no configuration, but \n+          the downside of this robustness is that it puts a \n+          relatively lengthy string into each row of the database. \n+          With a little application-specific configuration, you can \n+          easily reduce this to a single character or integer. This \n+          can result in significant performance gains when dealing \n+          with many small objects, \n+          since the subclass indicator data can become a significant \n+          proportion of the data transferred between the JVM and \n+          the database.\n+          <para>\n+          Alternately, if certain persistent classes in your \n+          application do not make use of inheritance, then you can \n+          disable the discriminator for these classes altogether.\n+          </para>\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Use the <classname>\n+          DynamicSchemaFactory</classname></emphasis>\n+                <para>\n+                  <emphasis>performance, validation</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\">\n+          If you are using a <link linkend=\"openjpa.jdbc.SchemaFactory\"><literal>openjpa.jdbc.SchemaFactory</literal></link> setting\n+          of something other than the default of <literal>\n+          dynamic</literal>, consider switching back.  While other\n+          factories can ensure that object-relational mapping \n+          information is valid when a persistent class is first used,\n+          this can be a slow process.  Though the validation is only \n+          performed once for each class, switching back to the\n+          <classname>DynamicSchemaFactory</classname> \n+          can reduce the warm-up time for your application.\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Do not use XA transactions</emphasis>\n+                <para>\n+                  <emphasis>performance, scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\"><link linkend=\"ref_guide_enterprise_xa\">XA transactions\n+          </link> can be orders of magnitude slower than standard \n+          transactions. Unless distributed transaction functionality \n+          is required by your application, use standard transactions.\n+          <para>\n+          Recall that XA transactions are distinct from\n+          managed transactions - managed transaction services\n+          such as that provided by EJB declarative transactions\n+          can be used both with XA and non-XA transactions. XA\n+          transactions should only be used when a given business\n+          transaction involves multiple different transactional\n+          resources (an Oracle database and an IBM transactional\n+          message queue, for example).\n+          </para></entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Use <classname>Set</classname>s \n+          instead of <classname>List/Collection</classname>s\n+          </emphasis>\n+                <para>\n+                  <emphasis>performance, scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\">\n+          There is a small amount of extra overhead for OpenJPA to \n+          maintain collections where each element is not guaranteed \n+          to be unique.  If your application does not require \n+          duplicates for a collection, you should always declare your\n+          fields to be of type <classname>Set, SortedSet, \n+          HashSet,</classname> or <classname>TreeSet</classname>.\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Use query parameters instead of\n+          encoding search data in filter strings</emphasis>\n+                <para>\n+                  <emphasis>performance</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\">\n+          If your queries depend on parameter data only known at\n+          runtime, you should use query parameters rather than\n+          dynamically building different query strings. OpenJPA\n+          performs aggressive caching of query compilation\n+          data, and the effectiveness of this cache is diminished if\n+          multiple query filters are used where a single one could\n+          have sufficed.\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Tune your fetch groups\n+          appropriately</emphasis>\n+                <para>\n+                  <emphasis>performance, scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\">\n+          The <link linkend=\"ref_guide_fetch\">fetch groups</link>\n+          used when loading an object control how much data is\n+          eagerly loaded, and by extension, which fields must be\n+          lazily loaded at a future time. The ideal fetch group\n+          configuration loads all the data that is needed in one\n+          fetch, and no extra fields - this minimizes both the\n+          amount of data transferred from the database, and the\n+          number of trips to the database.\n+          <para>\n+          If extra fields are specified in the fetch groups\n+          (in particular, large fields such as binary data, or\n+          relations to other persistence-capable objects), then\n+          network overhead (for the extra data) and database\n+          processing (for any necessary additional joins) will\n+          hurt your application's performance. If too few fields\n+          are specified in the fetch groups, then OpenJPA will have\n+          to make additional trips to the database to load\n+          additional fields as necessary.\n+          </para>\n+          </entry>\n+            </row>\n+            <row>\n+              <entry colname=\"name\">\n+                <emphasis role=\"bold\">Use eager fetching</emphasis>\n+                <para>\n+                  <emphasis>performance, scalability</emphasis>\n+                </para>\n+              </entry>\n+              <entry colname=\"desc\">\n+          Using <link linkend=\"ref_guide_perfpack_eager\">eager \n+          fetching</link> when loading subclass data or traversing \n+          relations for each instance in a large collection of \n+          results can speed up data loading by orders of magnitude.\n+          </entry>\n+            </row>\n+          </tbody>\n+        </tgroup>\n+      </table>\n+    </chapter>"},{"sha":"c57352fb1b45f10fe0dbfce4018f1aea35090949","filename":"openjpa-project/src/doc/manual/ref_guide_pc.xml","status":"added","additions":2488,"deletions":0,"changes":2488,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_pc.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_pc.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_pc.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53"},{"sha":"d94259de4541a943319ec064fb5b702713814038","filename":"openjpa-project/src/doc/manual/ref_guide_remote.xml","status":"added","additions":604,"deletions":0,"changes":604,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_remote.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_remote.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_remote.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,604 @@\n+\n+    <chapter id=\"ref_guide_remote\">\n+      <title>Remote and Offline Operation</title>\n+      <indexterm zone=\"ref_guide_remote\">\n+        <primary>remote</primary>\n+      </indexterm>\n+      <indexterm>\n+        <primary>offline</primary>\n+        <see>remote</see>\n+      </indexterm>\n+      <para>\n+  The standard JPA runtime environment is \n+  <emphasis>local</emphasis> and <emphasis>online</emphasis>.  It is \n+  <emphasis>local</emphasis> in that components such as \n+  <classname>EntityManager</classname>s and queries connect directly to\n+  the datastore and execute their actions in the same JVM as the code using \n+  them.  It is <emphasis>online</emphasis> in that all changes to managed \n+  objects must be made in the context of an active <classname>\n+  EntityManager</classname>.  \n+  These two properties, combined with the fact that <classname>\n+  EntityManager</classname>s cannot be serialized for storage or network \n+  transfer, make the standard JPA runtime difficult to \n+  incorporate into some enterprise and client/server program designs.\n+  </para>\n+      <para>\n+  OpenJPA extends the standard runtime to add <emphasis>remote</emphasis>\n+  and <emphasis>offline</emphasis> capabilities in the form of enhanced\n+  <link linkend=\"ref_guide_detach\">Detach and Attach APIs</link> and\n+  <link linkend=\"ref_guide_event\">Remote Commit Events</link>.\n+  The following sections explain these capabilities in detail.\n+  </para>\n+      <section id=\"ref_guide_detach\">\n+        <title>Detach and Attach</title>\n+        <indexterm zone=\"ref_guide_detach\">\n+          <primary>detachment</primary>\n+        </indexterm>\n+        <indexterm>\n+          <primary>attachment</primary>\n+          <see>detachment</see>\n+        </indexterm>\n+<!-- ### EJBDOC : more specific links to EM detach discussion -->\n+        <para>\n+    The JPA Overview describes the specification's standard \n+    detach and attach APIs in <xref linkend=\"jpa_overview_em\"/>.  \n+    This section enumerates OpenJPA's enhancements to the standard behavior.\n+    </para>\n+        <section id=\"ref_guide_detach_behavior\">\n+          <title>Detach Behavior</title>\n+          <indexterm zone=\"ref_guide_detach_behavior\">\n+            <primary>detachment</primary>\n+            <secondary>behavior</secondary>\n+          </indexterm>\n+          <para>\n+      In JPA, objects detach automatically when they are\n+      serialized or when a <link linkend=\"jpa_overview_emfactory_perscontext\">persistence \n+      context</link> ends.  The specification does not define any way to\n+      explicitly detach objects.  The extended \n+      <ulink url=\"../../api/openjpa/persistence/OpenJPAEntityManager.html\"><classname>OpenJPAEntityManager</classname></ulink>, however, allows \n+      you to explicitly detach objects at any time.\n+      </para>\n+          <programlisting format=\"linespecific\">\n+public Object detach (Object pc):\n+public Object[] detachAll (Object... pcs):\n+public Collection detachAll (Collection pcs):\n+</programlisting>\n+          <para>\n+      Each detach method returns detached copies of the given instances.\n+      The copy mechanism is similar to serialization, except that only \n+      certain fields are traversed. We will see how to control which \n+      fields are detached in a later section.\n+      </para>\n+          <para><indexterm><primary>detachment</primary><secondary>of dirty objects</secondary></indexterm>\n+      When detaching an instance that has been modified in the current\n+      transaction (and thus made dirty), the current transaction\n+      is flushed. This means that when subsequently re-attaching \n+      the detached instances, OpenJPA assumes that the transaction from \n+      which they were originally detached was committed; if \n+      it has been rolled back, then the re-attachment process will throw \n+      an optimistic concurrency exception.\n+      </para>\n+          <para>\n+      You can stop OpenJPA from assuming the transaction will commit by\n+      invoking <methodname>OpenJPAEntityManager.setRollbackOnly</methodname> \n+      prior to detaching your objects.  Setting the \n+      <literal>RollbackOnly</literal> flag prevents OpenJPA from flushing \n+      when detaching dirty objects; instead OpenJPA just runs its pre-flush \n+      actions (see the \n+      <methodname>OpenJPAEntityManager.preFlush</methodname>\n+      <ulink url=\"../../api/openjpa/persistence/OpenJPAEntityManager.html\">\n+      Javadoc</ulink> for details).\n+      </para>\n+          <para>\n+      This allows you to use the same \n+      instances in multiple attach/modify/detach/rollback cycles.  \n+      Alternatively, you might also prevent a flush by making your \n+      modifications outside of a transaction (with \n+      <literal>NontransactionalWrite</literal> enabled) before detaching.\n+      </para>\n+        </section>\n+        <section id=\"ref_guide_attach_behavior\">\n+          <title>Attach Behavior</title>\n+          <indexterm zone=\"ref_guide_attach_behavior\">\n+            <primary>attachment</primary>\n+            <secondary>behavior</secondary>\n+          </indexterm>\n+          <para>\n+      When attaching, OpenJPA uses several strategies to determine the \n+      optimal way to merge changes made to the detached instance.  As \n+      you will see, these strategies can even be used to attach changes \n+      made to a transient instance which was never detached in the first \n+      place.\n+      </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+          If the instance was detached and \n+          <link linkend=\"ref_guide_detach_graph\">detached state</link>\n+          is enabled, OpenJPA will use the detached state to determine \n+          the object's version and primary key values.  In addition,\n+          this state will tell OpenJPA which fields were loaded at the \n+          time of detach, and in turn where to expect changes.  Loaded\n+          detached fields with null values will set the attached\n+          instance's corresponding fields to null.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+          If the instance has\n+          <phrase>\n+          a <literal>Version</literal> field,\n+          </phrase>\n+          \n+          \n+          OpenJPA will consider the object detached if the version\n+          field has a non-default value, and new otherwise.  \n+          </para>\n+              <para>\n+          When attaching null fields in these cases, OpenJPA cannot \n+          distinguish between a field that was unloaded and one that\n+          was intentionally set to null. In this case, OpenJPA will use \n+          the current \n+          <link linkend=\"ref_guide_detach_graph\">detach state</link>\n+          setting to determine how to handle null fields: \n+          fields that would have been included in the detached state \n+          are treated as loaded, and will in turn set the \n+          corresponding attached field to null.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+          If neither of the above cases apply, OpenJPA will check to\n+          see if an instance with the same primary key values exists\n+          in the database.  If so, the object is considered detached.\n+          Otherwise, it is considered new.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+          <para>\n+      These strategies will be assigned on a per-instance basis,\n+      such that during the attachment of an object graph more than\n+      one of the above strategies may be used.\n+      </para>\n+          <para>\n+      If you attempt to attach a versioned instance whose representation \n+      has changed in the datastore since detachment, OpenJPA will throw an\n+      optimistic concurrency exception upon commit or flush, just as if \n+      a normal optimistic conflict was detected. When attaching an \n+      instance whose database record has \n+      been deleted since detaching, or when attaching a detached \n+      instance into a manager that has a stale version of the object, \n+      OpenJPA will throw an optimistic concurrency exception\n+      from the attach method. In these cases, OpenJPA sets the \n+      <literal>RollbackOnly</literal> flag on the transaction.\n+      </para>\n+        </section>\n+        <section id=\"ref_guide_detach_graph\">\n+          <title>Defining the Detached Object Graph</title>\n+          <indexterm zone=\"ref_guide_detach_graph\">\n+            <primary>detachment</primary>\n+            <secondary>defining the object graph</secondary>\n+          </indexterm>\n+          <para>\n+      When detached objects lose their association with the OpenJPA\n+      runtime, they also lose the ability to load additional state\n+      from the datastore.  It is important, therefore, to populate objects\n+      with all the persistent state you will need before detaching them.\n+      While you are free to do this manually, OpenJPA includes\n+      facilities for automatically populating objects when they detach.\n+      The <link linkend=\"openjpa.DetachState\"><literal>openjpa.DetachState\n+      </literal></link> configuration property determines which fields\n+      and relations are detached by default.   All settings are recursive.\n+      They are:\n+      </para>\n+          <orderedlist>\n+            <listitem>\n+              <para><literal>loaded</literal>: Detach all fields and relations \n+          that are already loaded, but don't include unloaded fields \n+          in the detached graph.  This is the default.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>fgs</literal>: Detach all fields and relations in \n+          the default fetch group, and any other fetch groups that \n+          you have added to the current\n+          <link linkend=\"ref_guide_runtime\">fetch \n+          configuration</link>.  For more information on custom \n+          fetch groups, see <xref linkend=\"ref_guide_fetch\"/>.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>all</literal>: Detach all fields and relations.  \n+          Be very careful when\n+          using this mode; if you have a highly-connected domain \n+          featureSelection, you could end up bringing every object in the\n+          database into memory!\n+          </para>\n+            </listitem>\n+          </orderedlist>\n+          <para>\n+        Any field that is not included in the set determined by the detach\n+      mode is set to its Java default value in the detached instance.\n+      </para>\n+          <para>\n+      The <literal>openjpa.DetachState</literal> option is actually a \n+      plugin string (see <xref linkend=\"ref_guide_conf_plugins\"/>) that\n+      allows you to also configure the following options related to\n+      detached state:\n+      </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para><literal>DetachedStateField</literal>: As described in \n+          <xref linkend=\"ref_guide_attach_behavior\"/> above, OpenJPA can\n+          take advantage of a <emphasis>detached state field\n+          </emphasis> to make the attach process more efficient.\n+          This field is added by the enhancer and is not visible to\n+          your application.  Set this property to one of the\n+          following values:\n+          </para>\n+              <itemizedlist>\n+                <listitem>\n+                  <para><literal>transient</literal>: Use a transient \n+              detached state field.  This gives the benefits of\n+              a detached state field to local objects that are\n+              never serialized, but retains\n+              serialization compatibility for client tiers without\n+              access to the enhanced versions of your classes. \n+              This is the default.\n+              </para>\n+                </listitem>\n+                <listitem>\n+                  <para><literal>true</literal>: Use a non-transient \n+              detached state field so that objects crossing\n+              serialization barriers can still be attached \n+              efficiently.  This requires, however, that your\n+              client tier have the enhanced versions of your\n+              classes and the OpenJPA libraries.\n+              </para>\n+                </listitem>\n+                <listitem>\n+                  <para><literal>false</literal>: Do not use a detached\n+              state field.\n+              </para>\n+                </listitem>\n+              </itemizedlist>\n+              <para>\n+          You can override the setting of this property or declare\n+          your own detached state field on individual classes using \n+          OpenJPA's metadata extensions.  See \n+          <xref linkend=\"ref_guide_detach_field\"/> below.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>DetachedStateManager</literal>: Whether to use a\n+          detached state manager.  A detached state manager makes\n+          attachment much more efficient.  Like a detached state \n+          field, however, it breaks serialization compatibility with\n+          the unenhanced class if it isn't transient.\n+          </para>\n+              <para>\n+          This setting piggybacks on the <literal>DetachedStateField\n+          </literal> setting above.  If your detached state field is \n+          transient, the detached state manager will also be \n+          transient. If the detached state field is disabled, the \n+          detached state manager will also be disabled.  This is \n+          typically what you'll want.  By setting <literal>\n+          DetachedStateField</literal> to true (or transient) and \n+          setting this property to false, however, you can use a \n+          detached state field <emphasis role=\"bold\">without\n+          </emphasis> using a detached state manager.   This may be \n+          useful for debugging or for legacy OpenJPA users who find \n+          differences between OpenJPA's behavior with a detached state \n+          manager and OpenJPA's older behavior without one.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>AccessUnloaded</literal>: Whether to allow access\n+          to unloaded fields of detached objects.  Defaults to true.\n+          Set to false to throw an exception whenever an unloaded\n+          field is accessed.  This option is only available when you\n+          use detached state managers, as determined by the settings\n+          above.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+          <example id=\"ref_guide_detach_graph_confex\">\n+            <title>Configuring Detached State</title>\n+            <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.DetachState\" value=\"fgs(DetachedStateField=true)\"/&gt;\n+</programlisting>\n+          </example>\n+          <para>\n+      You can also alter the set of fields that will be included in the\n+      detached graph at runtime.\n+      <ulink url=\"../../api/openjpa/persistence/OpenJPAEntityManager.html\"><classname>OpenJPAEntityManager</classname></ulink>s expose the \n+      following APIs for controlling detached state:\n+      </para>\n+          <programlisting format=\"linespecific\">\n+public static final int DETACH_LOADED;\n+public static final int DETACH_FGS;\n+public static final int DETACH_ALL;\n+public int getDetachState ();\n+public void setDetachState (int mode);\n+</programlisting>\n+          <section id=\"ref_guide_detach_field\">\n+            <title>Detached State Field</title>\n+            <indexterm zone=\"ref_guide_detach_field\">\n+              <primary>detachment</primary>\n+              <secondary>detached state field</secondary>\n+            </indexterm>\n+            <para>\n+        When the detached state field is enabled, the OpenJPA enhancer \n+        adds an additional field to the enhanced version of your class.\n+        This field of type <classname>Object</classname>.  OpenJPA uses\n+        this field for bookkeeping information, such as the versioning\n+        data needed to detect optimistic concurrency violations when the\n+        object is re-attached. \n+        </para>\n+            <para>\n+        It is possible to define this detached state field yourself.\n+        Declaring this field in your class metadata prevents the \n+        enhancer from adding any extra fields to the class, and keeps \n+        the enhanced class serialization-compatible with \n+        the unenhanced version.\n+        The detached state field must not be persistent.\n+        See <xref linkend=\"detached-state-field\"/> for details on\n+        how to declare a detached state field.\n+        </para>\n+            <programlisting format=\"linespecific\">\n+import org.apache.openjpa.persistence.*;\n+\n+@Entity\n+public class Magazine\n+    implements Serializable\n+{\n+    private String name;\n+    @DetachedState private Object state;\n+    ...\n+}\n+</programlisting>\n+          </section>\n+        </section>\n+      </section>\n+      <section id=\"ref_guide_event\">\n+        <title>Remote Event Notification Framework</title>\n+        <indexterm zone=\"ref_guide_event\">\n+          <primary>remote</primary>\n+          <secondary>events</secondary>\n+        </indexterm>\n+        <indexterm>\n+          <primary>events</primary>\n+          <secondary>remote</secondary>\n+          <see>remote, events</see>\n+        </indexterm>\n+        <para><indexterm><primary>remote</primary><secondary>events</secondary><tertiary>RemoteCommitProvider</tertiary></indexterm><indexterm><primary>remote</primary><secondary>events</secondary><tertiary>RemoteCommitListener</tertiary></indexterm>\n+  The remote event notification framework allows a subset of the \n+  information available through OpenJPA's transaction events (see \n+  <xref linkend=\"ref_guide_runtime_pm_event\"/>) to be broadcast to remote \n+  listeners.  OpenJPA's <link linkend=\"ref_guide_cache\">data cache</link>, for \n+  example, uses remote events to remain synchronized when deployed in \n+  multiple JVMs.\n+  </para>\n+        \n+        <para>\n+  To enable remote events, you must configure the <classname>\n+  EntityManagerFactory</classname> to use a  \n+  <literal>RemoteCommitProvider</literal> (see below). \n+  </para>\n+        <para>\n+  When a <literal>RemoteCommitProvider</literal> is properly configured, you \n+  can register <ulink url=\"../apidocs/org/apache/openjpa/event/RemoteCommitListener.html\"><classname>RemoteCommitListener</classname></ulink>s that will be alerted \n+  with a list of modified object ids whenever a transaction on a remote \n+  machine successfully commits.\n+  </para>\n+        <section id=\"ref_guide_event_conf\">\n+          <title>Remote Commit Provider Configuration</title>\n+          <indexterm zone=\"ref_guide_event_conf\">\n+            <primary>remote</primary>\n+            <secondary>events</secondary>\n+            <tertiary>configuration</tertiary>\n+          </indexterm>\n+          <para>\n+    OpenJPA includes built in remote commit providers for JMS and TCP \n+    communication.\n+    </para>\n+          <section id=\"ref_guide_event_conf_jms\">\n+            <title>JMS</title>\n+            <indexterm zone=\"ref_guide_event_conf_jms\">\n+              <primary>remote</primary>\n+              <secondary>events</secondary>\n+              <tertiary>JMS</tertiary>\n+            </indexterm>\n+            <para>\n+      OpenJPA includes built in remote commit providers for JMS and TCP\n+      communication.  The JMS remote commit provider can be configured by \n+      setting the <link linkend=\"openjpa.RemoteCommitProvider\"><literal>\n+      openjpa.RemoteCommitProvider</literal></link> property\n+      to contain the appropriate configuration properties. The JMS\n+      provider understands the following properties:\n+      </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para><literal>Topic</literal>: The topic that the remote commit\n+          provider should publish notifications to and subscribe\n+          to for notifications sent from other JVMs.  Defaults to\n+          <literal>topic/OpenJPACommitProviderTopic</literal></para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>TopicConnectionFactory</literal>: The JNDI name of\n+          a <classname>javax.jms.TopicConnectionFactory</classname>\n+          factory to use for finding topics.  Defaults to <literal>\n+          java:/ConnectionFactory</literal>. This setting may\n+          vary depending on the application server in use; consult\n+          the application server's documentation for details\n+          of the default JNDI name for the \n+          <classname>javax.jms.TopicConnectionFactory</classname>\n+          instance. For example, under Weblogic, the JNDI name\n+          for the TopicConnectionFactory is\n+          <literal>javax.jms.TopicConnectionFactory</literal>.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>ExceptionReconnectAttempts</literal>: The number of\n+          times to attempt to reconnect if the JMS system notifies \n+          OpenJPA of a serious connection error.  Defaults to 0, meaning\n+          OpenJPA will log the error but otherwise ignore it, hoping the\n+          connection is still valid.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>*</literal>: All other configuration properties \n+          will be interpreted as settings to pass to the JNDI \n+          <classname>InitialContext</classname> on construction.  For\n+          example, you might set the <literal>java.naming.provider.url\n+          </literal> property to the URL of the context provider.\n+          </para>\n+              </listitem>\n+            </itemizedlist>\n+            <para>\n+      To configure a factory to use the JMS provider, your properties \n+      might look like the following:\n+      </para>\n+            <note>\n+              <para>\n+        Because of the nature of JMS, it is important that you invoke\n+        <methodname>EntityManagerFactory.close</methodname>\n+        when finished with a factory.  If you do not do so, a daemon \n+        thread will stay up in the JVM, preventing the JVM from exiting.\n+        </para>\n+            </note>\n+          </section>\n+          <section id=\"ref_guide_event_conf_tcp\">\n+            <title>TCP</title>\n+            <indexterm zone=\"ref_guide_event_conf_tcp\">\n+              <primary>remote</primary>\n+              <secondary>events</secondary>\n+              <tertiary>TCP</tertiary>\n+            </indexterm>\n+            <para>\n+      The TCP remote commit provider has several options that are\n+      defined as host specifications containing a host name or IP\n+      address and an optional port separated by a colon. For example,\n+      the host specification <literal>saturn.bea.com:1234</literal>\n+      represents an <classname>InetAddress</classname> retrieved by \n+      invoking <methodname>InetAddress.getByName (\"saturn.bea.com\")\n+      </methodname> and a port of 1234.\n+      </para>\n+            <para><indexterm><primary>TCP provider</primary></indexterm>\n+      The TCP provider can be configured by setting the <literal>\n+      openjpa.RemoteCommitProvider</literal> plugin property to contain the \n+      appropriate configuration settings. The TCP provider understands the\n+      following properties:\n+      </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para><literal>Port</literal>: The TCP port that the provider \n+          should listen on for commit notifications.  Defaults to \n+          5636.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>Addresses</literal>: A semicolon-separated list of \n+          IP addresses to which notifications should be sent. No \n+          default value.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>NumBroadcastThreads</literal>: The number of \n+          threads to create for the purpose of transmitting events to\n+          peers.  You sould increase this value as the number of \n+          concurrent transactions increases. The maximum number of \n+          concurrent transactions is a function of the size of the \n+          connection pool.  See the the <literal>MaxActive</literal> \n+          property of\n+          <literal>openjpa.ConnectionFactoryProperties</literal> in\n+          <xref linkend=\"ref_guide_dbsetup_builtin\"/>.\n+          Setting a value of 0 will result in behavior where the\n+          thread invoking <methodname>commit</methodname> will \n+          perform the broadcast directly.  Defaults to 2.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>RecoveryTimeMillis</literal>: Amount of time to \n+          wait in milliseconds before attempting to reconnect to a \n+          peer of the cluster when connectivity to the peer is lost. \n+          Defaults to 15000.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>MaxIdle</literal>: The number of TCP sockets \n+          (channels) to keep open to each peer in the cluster for \n+          the transmission of events.  Defaults to 2.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>MaxActive</literal>: The maximum allowed number \n+          of TCP sockets (channels) to open simultaneously \n+          between each peer in the cluster.\n+          Defaults to 2.\n+          </para>\n+              </listitem>\n+            </itemizedlist>\n+            <para>\n+      To configure a factory to use the TCP provider, your properties \n+      might look like the following:\n+      </para>\n+            <example id=\"ref_guide_event_conf_tcpex\">\n+              <title>TCP Remote Commit Provider Configuration</title>\n+              <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.RemoteCommitProvider\" \n+    value=\"tcp(Addresses=10.0.1.10;10.0.1.11;10.0.1.12;10.0.1.13)\"/&gt;\n+</programlisting>\n+            </example>\n+          </section>\n+          <section id=\"ref_guide_event_conf_common\">\n+            <title>Common Properties</title>\n+            <indexterm zone=\"ref_guide_event_conf_common\">\n+              <primary>remote</primary>\n+              <secondary>events</secondary>\n+              <tertiary>common properties</tertiary>\n+            </indexterm>\n+            <para>\n+      In addition to the provider-specific configuration options above,\n+      all providers accept the following plugin properties:\n+      </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para><literal>TransmitPersistedObjectIds</literal>: Whether \n+          remote commit events will include the object ids of \n+          instances persisted in the transaction.  By default only \n+          the class names of types persisted in the transaction are \n+          sent.  This results in smaller events and more efficient \n+          network utilization.  If you have registered your own \n+          remote commit listeners, however, you may require the \n+          persisted object ids as well.\n+          </para>\n+              </listitem>\n+            </itemizedlist>\n+            <para>\n+      To transmit persisted object ids in our remote commit events\n+      using the JMS provider, we modify the previous example as follows:\n+      </para>\n+          </section>\n+        </section>\n+        <section id=\"ref_guide_event_customization\">\n+          <title>Customization</title>\n+          <indexterm zone=\"ref_guide_event_customization\">\n+            <primary>remote</primary>\n+            <secondary>events</secondary>\n+            <tertiary>customization</tertiary>\n+          </indexterm>\n+          <para>\n+    You can develop additional mechanisms for remote event notification be\n+    by creating an implementation of the \n+    <ulink url=\"../apidocs/org/apache/openjpa/event/RemoteCommitProvider.html\"><classname>\n+    RemoteCommitProvider</classname></ulink> interface, possibly by \n+    extending the \n+    <ulink url=\"../apidocs/org/apache/openjpa/event/AbstractRemoteCommitProvider.html\"><classname>AbstractRemoteCommitProvider</classname></ulink>\n+    abstract class. For details on particular customization needs,\n+    contact us at <ulink url=\"mailto:support@solarmetric.com\">\n+    support@solarmetric.com</ulink>.\n+    </para>\n+        </section>\n+      </section>\n+    </chapter>"},{"sha":"f33dce1cabcc1b60175b398f84c64cf24f46af9c","filename":"openjpa-project/src/doc/manual/ref_guide_runtime.xml","status":"added","additions":1441,"deletions":0,"changes":1441,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_runtime.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/ref_guide_runtime.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_runtime.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,1441 @@\n+\n+    <chapter id=\"ref_guide_runtime\">\n+      <title>Runtime Extensions</title>\n+      <para>\n+  This chapter describes OpenJPA extensions to the standard \n+  <phrase>JPA</phrase>\n+  \n+  \n+  interfaces, and outlines some additional features of the OpenJPA runtime.\n+  </para>\n+      <section id=\"ref_guide_runtime_arch\">\n+        <title>Architecture</title>\n+        <para>\n+    Internally, OpenJPA does not adhere to any persistence specification.  The\n+    OpenJPA kernel has its own set of APIs and components.  Specifications like\n+    JPA and JDO are simply different \"personalities\" that can\n+    OpenJPA's native kernel can adopt.\n+    </para>\n+        <para>\n+    As a OpenJPA <phrase>JPA</phrase> user, you will not normally see beneath OpenJPA's\n+    JPA personality.  OpenJPA allows you to access its feature set\n+    without leaving the comfort of JPA.  Where OpenJPA goes beyond standard \n+    JPA functionality, we have crafted JPA-specific APIs to \n+    each OpenJPA extension for as seamless an experience as possible.\n+    </para>\n+        <para>\n+    When writing OpenJPA plugins or otherwise extending the OpenJPA runtime, \n+    however, you will use OpenJPA's native APIs.  So that you won't feel lost,\n+    the list below associates each specification interface with \n+    its backing native OpenJPA component:\n+    </para>\n+        <itemizedlist>\n+          <listitem>\n+            <para><classname>javax.persistence.EntityManagerFactory</classname>:\n+        <emphasis><classname>org.apache.openjpa.kernel.BrokerFactory</classname></emphasis></para>\n+          </listitem>\n+          <listitem>\n+            <para><classname>javax.persistence.EntityManager</classname>:\n+        <emphasis><classname>org.apache.openjpa.kernel.Broker</classname></emphasis></para>\n+          </listitem>\n+          <listitem>\n+            <para><classname>javax.persistence.Query</classname>:\n+        <emphasis><classname>org.apache.openjpa.kernel.Query</classname></emphasis></para>\n+          </listitem>\n+          <listitem>\n+            <para><classname>org.apache.openjpa.persistence.Extent</classname>:\n+        <emphasis><classname>org.apache.openjpa.kernel.Extent</classname></emphasis></para>\n+          </listitem>\n+          <listitem>\n+            <para><classname>org.apache.openjpa.persistence.StoreCache</classname>:\n+        <emphasis><classname>org.apache.openjpa.datacache.DataCache</classname></emphasis></para>\n+          </listitem>\n+          <listitem>\n+            <para><classname>org.apache.openjpa.persistence.QueryResultCache</classname>:\n+        <emphasis><classname>org.apache.openjpa.datacache.QueryCache</classname></emphasis></para>\n+          </listitem>\n+          <listitem>\n+            <para><classname>org.apache.openjpa.persistence.FetchPlan</classname>:\n+        <emphasis><classname>org.apache.openjpa.kernel.FetchConfiguration</classname></emphasis></para>\n+          </listitem>\n+          <listitem>\n+            <para><classname>org.apache.openjpa.persistence.Generator</classname>:\n+        <emphasis><classname>org.apache.openjpa.kernel.Seq</classname></emphasis></para>\n+          </listitem>\n+        </itemizedlist>\n+        <para>\n+    The <link linkend=\"ref_guide_runtime_openjpapersistence\"><classname>\n+    org.apache.openjpa.persistence.OpenJPAPersistence</classname></link> helper allows you \n+    to convert between <classname>EntityManagerFactories</classname> and\n+    <classname>BrokerFactories</classname>, \n+    <classname>EntityManager</classname>s and\n+    <classname>Broker</classname>s. \n+    </para>\n+        <section id=\"ref_guide_runtime_pmextension\">\n+          <title>Broker Customization</title>\n+          <indexterm zone=\"ref_guide_runtime_pmextension\">\n+            <primary>OpenJPAEntityManager</primary>\n+            <secondary>extending</secondary>\n+          </indexterm>\n+          <para>\n+      Some advanced users may want to add capabilities to OpenJPA's internal\n+      <ulink url=\"../apidocs/org/apache/openjpa/kernel/BrokerImpl.html\"><classname>org.apache.openjpa.kernel.BrokerImpl</classname></ulink>.\n+      You can configure OpenJPA to use a custom subclass of\n+      <classname>BrokerImpl</classname> through the \n+      <link linkend=\"openjpa.BrokerImpl\"><literal>openjpa.BrokerImpl</literal></link> configuration property.  Set this property to the full \n+      class name of your custom subclass.\n+      </para>\n+          <para>\n+      As a <link linkend=\"ref_guide_conf_plugins\">plugin string</link>, \n+      you can also use this property to configure the <classname>\n+      BrokerImpl</classname> with the following properties:\n+      </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para><literal>EvictFromDataCache</literal>: When evicting an\n+          object through the <methodname>OpenJPAEntityManager.evict\n+          </methodname> methods, whether to also evict it from the \n+          OpenJPA's <link linkend=\"ref_guide_cache\">data cache</link>.\n+          Defaults to <literal>false</literal>.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+          <example id=\"ref_guide_runtime_pm_evictex\">\n+            <title>Evict from Data Cache</title>\n+            <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.BrokerImpl\" value=\"EvictFromDataCache=true\"/&gt;\n+</programlisting>\n+          </example>\n+        </section>\n+      </section>\n+      <section id=\"ref_guide_runtime_ejb\">\n+        <title>JPA Extensions</title>\n+        <para>\n+    The following sections outline the runtime interfaces you can use\n+    to access OpenJPA-specific functionality from JPA.  Each \n+    interface contains services and convenience methods missing from the \n+    JPA specification.  OpenJPA strives to use the same naming \n+    conventions and API patterns as standard JPA methods in all\n+    extensions, so that OpenJPA JDO APIs feel as much as possible like \n+    standard JPA.\n+    </para>\n+        <para>\n+    You may have noticed the examples throughout this document using the\n+    <methodname>OpenJPAPersistence.cast</methodname> methods to cast from\n+    standard JPA interfaces to OpenJPA extended interfaces. \n+    This is the recommended practice.  Some application server vendors\n+    may proxy OpenJPA's JPA implementation, preventing a straight\n+    cast.  <classname>OpenJPAPersistence</classname>'s <methodname>cast\n+    </methodname> methods work around these proxies.\n+    </para>\n+        <programlisting format=\"linespecific\"> \n+public static OpenJPAEntityManagerFactory cast (EntityManagerFactory emf);\n+public static OpenJPAEntityManager cast (EntityManager em);\n+public static OpenJPAQuery cast (Query q);\n+</programlisting>\n+        <para>\n+    We provide additional information on the <classname>OpenJPAPersistence\n+    </classname> helper <link linkend=\"ref_guide_runtime_openjpapersistence\">\n+    below</link>.\n+    </para>\n+        <section id=\"ref_guide_runtime_emfactory\">\n+          <title>OpenJPAEntityManagerFactory</title>\n+          <indexterm zone=\"ref_guide_runtime_emfactory\">\n+            <primary>OpenJPAEntityManagerFactory</primary>\n+          </indexterm>\n+          <indexterm>\n+            <primary>EntityManagerFactory</primary>\n+            <secondary>OpenJPA extensions</secondary>\n+            <see>OpenJPAEntityManagerFactory</see>\n+          </indexterm>\n+          <para>\n+      The <classname>org.apache.openjpa.persistence.OpenJPAEntityManagerFactory</classname>\n+      interface extends the basic <classname>\n+      javax.persistence.EntityManagerFactory</classname> with \n+      OpenJPA-specific features.  The <classname>OpenJPAEntityManagerFactory\n+      </classname> offers APIs to obtain \n+      managed and unmanaged <classname>EntityManager</classname>s from \n+      the same factory, to access the OpenJPA data and query caches, and to \n+      perform other OpenJPA-specific operations.  See the\n+      <ulink url=\"../../api/openjpa/persistence/OpenJPAEntityManagerFactory.html\">\n+      interface Javadoc</ulink> for details.\n+      </para>\n+        </section>\n+        <section id=\"ref_guide_runtime_em\">\n+          <title>OpenJPAEntityManager</title>\n+          <indexterm zone=\"ref_guide_runtime_em\">\n+            <primary>OpenJPAEntityManager</primary>\n+          </indexterm>\n+          <indexterm>\n+            <primary>EntityManager</primary>\n+            <secondary>OpenJPA extensions</secondary>\n+            <see>OpenJPAEntityManager</see>\n+          </indexterm>\n+          <para>\n+      All OpenJPA <classname>EntityManager</classname>s implement the \n+      <ulink url=\"../../api/openjpa/persistence/OpenJPAEntityManager.html\"><classname>org.apache.openjpa.persistence.OpenJPAEntityManager</classname></ulink> \n+      interface.  This interface extends the standard <classname>\n+      javax.persistence.EntityManager</classname>.  Just as the\n+      standard <classname>EntityManager</classname> is the primary \n+      window into JPA services, the <classname>\n+      OpenJPAEntityManager</classname> is the primary window from JPA\n+      into OpenJPA-specific functionality.  We strongly \n+      encourage you to investigate the API extensions this interface \n+      contains.\n+      </para>\n+        </section>\n+        <section id=\"ref_guide_runtime_ejbquery\">\n+          <title>OpenJPAQuery</title>\n+          <indexterm zone=\"ref_guide_runtime_ejbquery\">\n+            <primary>OpenJPAQuery</primary>\n+          </indexterm>\n+          <indexterm>\n+            <primary>Query</primary>\n+            <secondary>OpenJPA extensions</secondary>\n+            <see>OpenJPAQuery</see>\n+          </indexterm>\n+          <para>\n+      OpenJPA extends JPA's standard query functionality with the\n+      <classname>org.apache.openjpa.persistence.OpenJPAQuery</classname> interface.  See \n+      its <ulink url=\"../../api/openjpa/persistence/OpenJPAQuery.html\">Javadoc\n+      </ulink> for details on the convenience methods it provides.\n+      </para>\n+        </section>\n+        <section id=\"ref_guide_runtime_ejbextent\">\n+          <title>Extent</title>\n+          <indexterm zone=\"ref_guide_runtime_ejbextent\">\n+            <primary>Extent</primary>\n+          </indexterm>\n+          <indexterm>\n+            <primary>Extent</primary>\n+            <secondary>OpenJPA extensions</secondary>\n+            <see>OpenJPAExtent</see>\n+          </indexterm>\n+          <para>\n+      An <classname>Extent</classname> is a logical view of all persistent\n+      instances of a given entity class, possibly including subclasses. \n+      OpenJPA adds the <ulink url=\"../../api/openjpa/persistence/Extent.html\"><classname>org.apache.openjpa.persistence.Extent</classname></ulink> class \n+      to the set of Java Persistence APIs.  The following code illustrates\n+      iterating over all instances of the <classname>Magazine</classname>\n+      entity, without subclasses:\n+      </para>\n+          <example id=\"ref_guide_runtime_ejbextentex\">\n+            <title>Using a JPA Extent</title>\n+            <programlisting format=\"linespecific\">\n+import org.apache.openjpa.persistence.*;\n+\n+...\n+\n+OpenJPAEntityManager kem = OpenJPAPersistence.cast (em);\n+Extent&lt;Magazine&gt; mags = kem.getExtent (Magazine.class, false);\n+for (Magazine m : mags)\n+    processMagazine (m);\n+</programlisting>\n+          </example>\n+        </section>\n+        <section id=\"ref_guide_runtime_ejbcache\">\n+          <title>StoreCache</title>\n+          <indexterm zone=\"ref_guide_runtime_ejbcache\">\n+            <primary>StoreCache</primary>\n+          </indexterm>\n+          <para>\n+      In addition to the <classname>EntityManager</classname> object\n+      cache mandated by the JPA specification, OpenJPA includes\n+      a flexible datastore-level cache.  You can access this cache\n+      from your JPA code using the \n+      <ulink url=\"../../api/openjpa/persistence/StoreCache.html\"><classname>\n+      org.apache.openjpa.persistence.StoreCache</classname></ulink> facade.  \n+      <xref linkend=\"ref_guide_cache\"/> has detailed information on\n+      OpenJPA's data caching system, including the \n+      <classname>StoreCache</classname> facade.\n+      </para>\n+        </section>\n+        <section id=\"ref_guide_runtime_ejbquerycache\">\n+          <title>QueryResultCache</title>\n+          <indexterm zone=\"ref_guide_runtime_ejbquerycache\">\n+            <primary>QueryResultCache</primary>\n+          </indexterm>\n+          <para>\n+      OpenJPA can cache query results as well as persistent object data.  The\n+      <ulink url=\"../../api/openjpa/persistence/QueryResultCache.html\"><classname>org.apache.openjpa.persistence.QueryResultCache</classname></ulink> \n+      is an JPA-flavored facade to OpenJPA's internal query cache.  See\n+      <xref linkend=\"ref_guide_cache_query\"/> for details on query caching\n+      in OpenJPA.\n+      </para>\n+        </section>\n+        <section id=\"ref_guide_runtime_ejbfetch\">\n+          <title>FetchPlan</title>\n+          <indexterm zone=\"ref_guide_runtime_ejbfetch\">\n+            <primary>FetchPlan</primary>\n+          </indexterm>\n+          <indexterm>\n+            <primary>eager fetching</primary>\n+            <seealso>FetchPlan</seealso>\n+          </indexterm>\n+          <para>\n+      Many of the aforementioned OpenJPA interfaces give you access to a \n+      <classname>org.apache.openjpa.persistence.FetchPlan</classname>\n+      instance.  The <classname>FetchPlan</classname> allows you\n+      to exercise some control over how objects are fetched from the \n+      datastore, including <link linkend=\"ref_guide_dbsetup_lrs\">large \n+      result set support</link>, <link linkend=\"ref_guide_fetch\">custom \n+      fetch groups</link>, and <link linkend=\"ref_guide_locking\">lock \n+      levels</link>.  \n+      </para>\n+          <para>\n+      OpenJPA goes one step further, extending <classname>FetchPlan\n+      </classname> with\n+      <ulink url=\"../../api/openjpa/persistence/jdbc/JDBCFetchPlan.html\"><classname>org.apache.openjpa.persistence.jdbc.JDBCFetchPlan</classname></ulink> to add additional JDBC-specific tuning methods.\n+      Unless you have customized OpenJPA to use a non-relational back-end\n+      (see <xref linkend=\"ref_guide_enterprise_abstractstore\"/>), all\n+      <classname>FetchPlan</classname>s in OpenJPA implement\n+      <classname>JDBCFetchPlan</classname>, so feel free to cast\n+      to this interface.\n+      </para>\n+          <para>\n+      Fetch plans pass on from parent components to child\n+      components.  The <classname>EntityManagerFactory</classname> \n+      settings (via your configuration properties) for things like the \n+      fetch size, result set type, and custom fetch groups are passed on \n+      to the fetch plan of the <classname>\n+      EntityManager</classname>s it produces.  The settings \n+      of each <classname>EntityManager</classname>, in turn, are passed \n+      on to each <classname>Query</classname> and <classname>Extent\n+      </classname> it returns.  Note that the opposite, however, is not \n+      true.  Modifying the fetch plan of a \n+      <classname>Query</classname> or <classname>Extent</classname> does \n+      not affect the <classname>EntityManager</classname>'s configuration.\n+      Likewise, modifying an <classname>EntityManager</classname>'s \n+      configuration does not affect the <classname>\n+      EntityManagerFactory</classname>.\n+      </para>\n+          <para><xref linkend=\"ref_guide_fetch\"/> includes examples using\n+      <classname>FetchPlan</classname>s.\n+      </para>\n+        </section>\n+        <section id=\"ref_guide_runtime_openjpapersistence\">\n+          <title>OpenJPAPersistence</title>\n+          <indexterm zone=\"ref_guide_runtime_openjpapersistence\">\n+            <primary>OpenJPAPersistence</primary>\n+          </indexterm>\n+          <para><ulink url=\"../../api/openjpa/persistence/OpenJPAPersistence.html\"><classname>org.apache.openjpa.persistence.OpenJPAPersistence</classname></ulink> is \n+      a static helper class that adds OpenJPA-specific utility methods to \n+      <classname>javax.persistence.Persistence</classname>.\n+      </para>\n+        </section>\n+      </section>\n+      <section id=\"ref_guide_locking\">\n+        <title>Object Locking</title>\n+        <indexterm zone=\"ref_guide_locking\">\n+          <primary>locking</primary>\n+        </indexterm>\n+        <para>\n+  Controlling how and when objects are locked is an important part of \n+  maximizing the performance of your application under load.  This section\n+  describes OpenJPA's APIs for explicit locking, as well as its rules for\n+  implicit locking.\n+  </para>\n+        <section id=\"ref_guide_locking_default\">\n+          <title>Configuring Default Locking</title>\n+          <indexterm zone=\"ref_guide_locking_default\">\n+            <primary>locking</primary>\n+            <secondary>defaults configuration</secondary>\n+          </indexterm>\n+          <para><indexterm><primary>locking</primary><secondary>levels</secondary></indexterm><indexterm><primary>ReadLockLevel</primary></indexterm><indexterm><primary>WriteLockLevel</primary></indexterm>\n+    You can control OpenJPA's default transactional read and write lock levels\n+    through the <link linkend=\"openjpa.ReadLockLevel\"><literal>\n+    openjpa.ReadLockLevel</literal></link> and \n+    <link linkend=\"openjpa.WriteLockLevel\"><literal>openjpa.WriteLockLevel\n+    </literal></link> configuration properties.  Each property accepts a \n+    value of <literal>none</literal>, <literal>read</literal>, \n+    <literal>write</literal>, or a number corresponding to a lock\n+    level defined by the <link linkend=\"ref_guide_locking_lockmgr\">lock \n+    manager</link> in use.  These properties apply only to non-optimistic \n+    transactions; during optimistic transactions, OpenJPA never locks objects \n+    by default.\n+    </para>\n+          <para><indexterm><primary>LockTimeout</primary></indexterm><indexterm><primary>locking</primary><secondary>timeout</secondary></indexterm>\n+    You can control the default amount of time OpenJPA will wait when trying \n+    to obtain locks through the <link linkend=\"openjpa.LockTimeout\"><literal>\n+    openjpa.LockTimeout</literal></link> configuration property.  Set this\n+    property to the number of milliseconds you are willing to wait for\n+    a lock before OpenJPA will throw an exception, or to -1 for no limit.  It\n+    defaults to -1.\n+    </para>\n+          <example id=\"ref_guide_locking_default_conf\">\n+            <title>Setting Default Lock Levels</title>\n+            <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.ReadLockLevel\" value=\"none\"/&gt;\n+&lt;property name=\"openjpa.WriteLockLevel\" value=\"write\"/&gt;\n+&lt;property name=\"openjpa.LockTimeout\" value=\"30000\"/&gt;\n+</programlisting>\n+          </example>\n+        </section>\n+        <section id=\"ref_guide_locking_runtime\">\n+          <title>Configuring Lock Levels at Runtime</title>\n+          <indexterm zone=\"ref_guide_locking_runtime\">\n+            <primary>locking</primary>\n+            <secondary>runtime configuration</secondary>\n+          </indexterm>\n+          <para>\n+    At runtime, you can override the default lock levels through the\n+    <classname>FetchPlan</classname> interface described above.\n+    At the beginning of each\n+    datastore transaction, OpenJPA initializes the <classname>\n+    EntityManager</classname>'s fetch plan with the default lock \n+    levels and timeouts described in the previous section.  By changing the\n+    fetch plan's locking properties, you can control how objects \n+    loaded at different points in the transaction are locked.  You can \n+    also use the fetch plan of an individual \n+    <classname>Query</classname> to apply your locking changes only to \n+    objects loaded through that <classname>Query</classname>.\n+    </para>\n+          <programlisting format=\"linespecific\">\n+public LockModeType getReadLockMode ();\n+public FetchPlan setReadLockMode (LockModeType mode);\n+public LockModeType getWriteLockMode ();\n+public FetchPlan setWriteLockMode (LockModeType mode);\n+long getLockTimeout ();\n+FetchPlan setLockTimeout (long timeout);\n+</programlisting>\n+          <para>\n+    Controlling locking through these runtime APIs works even during\n+    optimistic transactions.  At the end of the transaction, OpenJPA resets \n+    the fetch plan's lock levels to <literal>none</literal>.\n+    You cannot lock objects outside of a transaction.\n+    </para>\n+          <example id=\"ref_guide_locking_fetch\">\n+            <title>Setting Runtime Lock Levels</title>\n+            <programlisting format=\"linespecific\">\n+import org.apache.openjpa.persistence.*;\n+\n+...\n+\n+EntityManager em = ...;\n+em.getTransaction ().begin ();\n+\n+// load stock we know we're going to update at write lock mode\n+Query q = em.createQuery (\"select s from Stock s where symbol = :s\");\n+q.setParameter (\"s\", symbol);\n+OpenJPAQuery kq = OpenJPAPersistence.cast (q);\n+FetchPlan fetch = kq.getFetchPlan ();\n+fetch.setReadLockMode (LockModeType.WRITE);\n+fetch.setLockTimeout (3000); // 3 seconds\n+Stock stock = (Stock) q.getSingleResult ();\n+\n+// load an object we don't need locked at none lock mode\n+fetch = (OpenJPAPersistence.cast (em)).getFetchPlan ();\n+fetch.setReadLockMode (null);\n+Market market = em.find (Market.class, marketId);\n+\n+stock.setPrice (market.calculatePrice (stock));\n+em.getTransaction ().commit ();\n+</programlisting>\n+          </example>\n+        </section>\n+        <section id=\"ref_guide_locking_apis\">\n+          <title>Object Locking APIs</title>\n+          <indexterm zone=\"ref_guide_locking_apis\">\n+            <primary>locking</primary>\n+            <secondary>runtime APIs</secondary>\n+          </indexterm>\n+          <para>\n+    In addition to allowing you to control implicit locking levels, OpenJPA\n+    provides explicit APIs to lock objects and to retrieve their current\n+    lock level.\n+    </para>\n+          <programlisting format=\"linespecific\">\n+public LockModeType OpenJPAEntityManager.getLockMode (Object pc);\n+</programlisting>\n+          <para>\n+    Returns the level at which the given object is currently locked.\n+    </para>\n+          <para>\n+    In addition to the standard \n+    <ulink url=\"http://java.sun.com/javaee/5/docs/api/javax/persistence/EntityManager.html\"><methodname>EntityManager.lock (Object, LockModeType)</methodname></ulink> method, the\n+    <ulink url=\"../../api/openjpa/persistence/OpenJPAEntityManager.html\"><classname>OpenJPAEntityManager</classname></ulink> exposes the following\n+    methods to lock objects explicitly:\n+    </para>\n+          <programlisting format=\"linespecific\">\n+public void lock (Object pc);\n+public void lock (Object pc, LockModeType mode, long timeout);\n+public void lockAll (Object... pcs);\n+public void lockAll (Object... pcs, LockModeType mode, long timeout);\n+public void lockAll (Collection pcs);\n+public void lockAll (Collection pcs, LockModeType mode, long timeout);\n+</programlisting>\n+          <para>\n+    Methods that do not take a lock level or timeout parameter default\n+    to the current fetch plan.  The example below demonstrates\n+    these methods in action.\n+    </para>\n+          <example id=\"ref_guide_locking_explicit\">\n+            <title>Locking APIs</title>\n+            <programlisting format=\"linespecific\">\n+import org.apache.openjpa.persistence.*;\n+\n+// retrieve the lock level of an object\n+OpenJPAEntityManager kem = OpenJPAPersistence.cast (em);\n+Stock stock = ...;\n+LockModeType level = kem.getLockMode (stock);\n+if (level == OpenJPAModeType.WRITE) ...\n+\n+...\n+\n+kem.setOptimistic (true);\n+kem.getTransaction ().begin ();\n+\n+// override default of not locking during an opt trans to lock stock object\n+kem.lock (stock, LockModeType.WRITE, 1000);\n+stock.setPrice (market.calculatePrice (stock));\n+\n+kem.getTransaction ().commit ();\n+</programlisting>\n+          </example>\n+        </section>\n+        <section id=\"ref_guide_locking_lockmgr\">\n+          <title>Lock Manager</title>\n+          <indexterm zone=\"ref_guide_locking_lockmgr\">\n+            <primary>locking</primary>\n+            <secondary>LockManager</secondary>\n+          </indexterm>\n+          <para><indexterm><primary>LockManager</primary></indexterm>\n+    OpenJPA delegates the actual work of locking objects to the system's\n+    <ulink url=\"../apidocs/org/apache/openjpa/kernel/LockManager.html\"><classname>\n+    org.apache.openjpa.kernel.LockManager</classname></ulink>.  This plugin is controlled\n+    by the <link linkend=\"openjpa.LockManager\"><literal>openjpa.LockManager\n+    </literal></link> configuration property.  You can write your own lock\n+    manager, or use one of the bundled options:\n+    </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para><literal>pessimistic</literal>: This is an alias for the \n+        <ulink url=\"../apidocs/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.html\"><classname>org.apache.openjpa.jdbc.kernel.PessimisticLockManager</classname></ulink>, which uses SELECT FOR UPDATE statements (or the \n+        database's equivalent) to lock the database rows corresponding\n+        to locked objects.  This lock manager does not distinguish\n+        between read locks and write locks; all locks are write locks. \n+        </para>\n+              <para>\n+        The <literal>pessimistic</literal> LockManager can be\n+        configued to additionally perform the version checking\n+        and incrementing behavior of the <literal>version</literal>\n+        lock manager described below by setting its\n+        <literal>VersionCheckOnReadLock</literal>\n+        and <literal>VersionUpdateOnWriteLock</literal> properties:\n+        </para>\n+              <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.LockManager\" value=\"pessimistic(VersionCheckOnReadLock=true,VersionUpdateOnWriteLock=true)\"/&gt;\n+</programlisting>\n+            </listitem>\n+            <listitem>\n+              <para><literal>none</literal>: An alias for the \n+        <ulink url=\"../apidocs/org/apache/openjpa/kernel/NoneLockManager.html\"><classname>org.apache.openjpa.kernel.NoneLockManager</classname></ulink>, \n+        which does not perform any locking at all.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>sjvm</literal>: An alias for the \n+        <ulink url=\"../apidocs/org/apache/openjpa/kernel/SingleJVMExclusiveLockManager.html\"><classname>org.apache.openjpa.kernel.SingleJVMExclusiveLockManager\n+        </classname></ulink>.  This lock manager uses in-memory mutexes\n+        to obtain exclusive locks on object ids.  It does not perform\n+        any database-level locking.  Also, it does not distinguish\n+        between read and write locks; all locks are write locks.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>version</literal>: An alias for the \n+        <ulink url=\"../apidocs/org/apache/openjpa/kernel/VersionLockManager.html\"><classname>org.apache.openjpa.kernel.VersionLockManager\n+        </classname></ulink>.  This lock manager does not perform\n+        any exclusive locking, but instead ensures read consistency\n+        by verifying that the version of all read-locked instances\n+        is unchanged at the end of the transaction. Furthermore, a\n+        write lock will force an increment to the version at the\n+        end of the transaction, even if the object is not\n+        otherwise modified. This ensures read consistency with\n+        non-blocking behavior.\n+        </para>\n+              <para>\n+        This is the default <literal>openjpa.LockManager</literal>\n+        setting in JPA.\n+        </para>\n+            </listitem>\n+          </itemizedlist>\n+          <note>\n+            <para>\n+      In order for the <literal>version</literal> lock manager\n+      to prevent the dirty read phenomenon, the underlying data\n+      store's transaction isolation level must be set to\n+      the equivalent of \"read committed\" or higher.\n+      </para>\n+          </note>\n+          <example id=\"ref_guide_locking_disable\">\n+            <title>Disabling Locking</title>\n+            <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.LockManager\" value=\"none\"/&gt;\n+</programlisting>\n+          </example>\n+        </section>\n+        <section id=\"ref_guide_locking_rules\">\n+          <title>Rules for Locking Behavior</title>\n+          <indexterm zone=\"ref_guide_locking_rules\">\n+            <primary>locking</primary>\n+            <secondary>behavior</secondary>\n+          </indexterm>\n+          <indexterm zone=\"ref_guide_locking_rules\">\n+            <primary>lazy loading</primary>\n+            <secondary>locking behavior</secondary>\n+          </indexterm>\n+          <para>\n+    Advanced persistence concepts like lazy-loading and object uniquing \n+    create several locking corner-cases.  The rules below outline OpenJPA's \n+    implicit locking behavior in these cases. \n+    </para>\n+          <orderedlist>\n+            <listitem>\n+              <para>\n+        When an object's state is first read within a transaction, the \n+        object is locked at the fetch plan's current read lock\n+        level.  Future reads of additional lazy state for the object \n+        will use the same read lock level, even if the fetch \n+        plan's level has changed.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        When an object's state is first modified within a transaction, \n+        the object is locked at the write lock level in effect when\n+        the object was first read, even if the fetch plan's \n+        level has changed.  If the object was not read previously, the \n+        current write lock level is used.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        When objects are accessed through a persistent relation field,\n+        the related objects are loaded with the fetch plan's \n+        current lock levels, not the lock levels of the object owning \n+        the field.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        Whenever an object is accessed within a transaction,\n+        the object is re-locked at the current read lock\n+        level.  The current read and write lock levels become those that\n+        the object \"remembers\" according to rules one and two above.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        If you lock  an object explicitly through the APIs demonstrated\n+        above, it is re-locked at the specified level.  This level \n+        also becomes both the read and write level that the object \n+        \"remembers\" according to rules one and two above.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        When an object is already locked at a given lock level, \n+        re-locking at a lower level has no effect.  Locks cannot be\n+        downgraded during a transaction.\n+        </para>\n+            </listitem>\n+          </orderedlist>\n+        </section>\n+        <section id=\"ref_guide_locking_issues\">\n+          <title>Known Issues and Limitations</title>\n+          <indexterm zone=\"ref_guide_locking_issues\">\n+            <primary>locking</primary>\n+            <secondary>caveats</secondary>\n+          </indexterm>\n+          <para>\n+    Due to performance concerns and database limitations, locking cannot\n+    be perfect.  You should be aware of the issues outlined in this \n+    section, as they may affect your application.\n+    </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+        Typically, during optimistic transactions OpenJPA does not \n+        start an actual database transaction until you flush or the \n+        optimistic transaction commits.  This allows for very long-lived\n+        transactions without consuming database resources.\n+        When using the default lock manager, however, OpenJPA must begin a \n+        database transaction whenever you decide to lock an object \n+        during an optimistic transaction.  This is because the\n+        default lock manager uses database locks, and databases cannot\n+        lock rows without a transaction in progress.  OpenJPA will log\n+        an INFO message to the <literal>openjpa.Runtime</literal> logging\n+        channel when it begins a datastore transaction just to lock\n+        an object.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+        In order to maintain reasonable performance levels when \n+        loading object state, OpenJPA can only guarantee that an \n+        object is locked at the proper lock level <emphasis>after\n+        </emphasis> the state has been retrieved from the database.\n+        This means that it is technically possible for another \n+        transaction to \"sneak in\" and modify the database record after\n+        OpenJPA retrieves the state, but before it locks the object.  The\n+        only way to positively guarantee that the object is locked and\n+        has the most recent state to refresh the object after locking \n+        it.\n+        </para>\n+              <para>\n+        When using the default lock manager, the case above can only\n+        occur when OpenJPA cannot issue the state-loading SELECT as a\n+        locking statement due to database limitations.  For example, \n+        some databases cannot lock SELECTs that use joins.\n+        The default lock manager will log an INFO message to the\n+        <literal>openjpa.Runtime</literal> logging channel whenever it \n+        cannot lock the initial SELECT due to database limitations.\n+        By paying attention to these log messages, you can see where \n+        you might consider using an object refresh to guarantee that \n+        you have the most recent state, or where you might rethink the \n+        way you load the state in question to circumvent the database\n+        limitations that prevent OpenJPA from issuing a locking SELECT in \n+        the first place.\n+        </para>\n+            </listitem>\n+          </itemizedlist>\n+        </section>\n+      </section>\n+      <section id=\"ref_guide_savepoints\">\n+        <title>Savepoints</title>\n+        <indexterm zone=\"ref_guide_savepoints\">\n+          <primary>savepoint</primary>\n+        </indexterm>\n+        <para>\n+  Savepoints allow for fine grained control over the transactional behavior\n+  of your application.  OpenJPA's savepoint API allow you to set intermediate\n+  rollback points in your transaction.  You can then choose to rollback \n+  changes made only after a specific savepoint, then commit or continue \n+  making new changes in the transaction.  This feature is useful for \n+  multi-stage transactions, such as editing a set of objects over several \n+  web pages or user screens.  Savepoints also provide more flexibilty \n+  to conditional transaction behavior, such as choosing to commit or \n+  rollback a portion of the transaction based on the results of the \n+  changes.  This chapter describes how to use and configure OpenJPA savepoints.\n+  </para>\n+        <section id=\"reg_guide_savepoints_using\">\n+          <title>Using Savepoints</title>\n+          <para>\n+    OpenJPA's\n+    <phrase><ulink url=\"../../api/openjpa/persistence/OpenJPAEntityManager.html\"><classname>OpenJPAEntityManager</classname></ulink></phrase>\n+    \n+    \n+    have the following methods to control savepoint behavior.\n+    Note that the savepoints work in tandem with the current\n+    transaction.  This means that savepoints require an open transaction, \n+    and that a rollback of the transaction will rollback all of \n+    the changes in the transaction regardless of any savepoints set.\n+    </para>\n+          <programlisting format=\"linespecific\">\n+void setSavepoint (String name);\n+void releaseSavepoint (String name);\n+void rollbackToSavepoint (String name);\n+</programlisting>\n+          <para>\n+    To set a savepoint, simply call <methodname>setSavepoint</methodname>, \n+    passing in a symbolic savepoint name.  \n+    This savepoint will define a point at which you can preserve\n+    the state of transactional objects for the duration of the current\n+    transaction.\n+    </para>\n+          <para>\n+    Having set a named savepoint, you can rollback changes made after that\n+    point by calling <methodname>rollbackToSavepoint</methodname>.  This \n+    method will keep the current transaction active,\n+    while restoring all transactional instances back to their saved state.\n+    Instances that were deleted after the save point will no longer\n+    be marked for deletion.  Similarly, transient instances that were\n+    made persistent after the savepoint will become transient again.  \n+    Savepoints made after this savepoint will be released and no longer \n+    valid, although you can still set new savepoints.  Savepoints will also\n+    be cleared after the current transaction is committed or rolled back.\n+    </para>\n+          <para>\n+    If a savepoint is no longer needed, you can release any resources\n+    such as in memory state and datastore resources by calling\n+    <methodname>releaseSavepoint</methodname>.\n+    This method should not be called for savepoints that have been \n+    released automatically through other means, such as commit of a \n+    transaction or rollback to a prior savepoint.  While savepoints\n+    made after this savepoint will also be released, there are no other\n+    effects on the current transaction.\n+    </para>\n+          <para>\n+    The following simple example illustrates setting, releasing, and\n+    rolling back to a savepoint.\n+    </para>\n+          <example id=\"ref_guide_savepoints_example\">\n+            <title>Using Savepoints</title>\n+            <programlisting format=\"linespecific\">\n+import org.apache.openjpa.persistence.*;\n+\n+...\n+\n+OpenJPAEntityManager kem = OpenJPAPersistence.cast (em);\n+kem.getTransaction ().begin ();\n+\n+Magazine mag = kem.find (Magazine.class, id);\n+mag.setPageCount (300);\n+kem.setSavepoint (\"pages\");\n+\n+mag.setPrice (mag.getPageCount () * pricePerPage);\n+// we decide to release pages since price depends on pages.\n+kem.releaseSavepoint (\"pages\");\n+kem.setSavepoint (\"price\");\n+\n+mag.setPrice (testPrice);\n+...\n+\n+// we determine the test price is not good\n+kem.rollbackToSavepoint (\"price\");\n+\n+// the price is now restored to mag.getPageCount () * pricePerPage\n+kem.getTransaction ().commit ();\n+</programlisting>\n+          </example>\n+        </section>\n+        <section id=\"ref_guide_savepoints_conf\">\n+          <title>Configuring Savepoints</title>\n+          <para>\n+    OpenJPA uses the <ulink url=\"javadoc/openjpa/kernel/SavepointManager\"><classname>org.apache.openjpa.kernel.SavepointManager</classname></ulink> \n+    <link linkend=\"ref_guide_conf_plugins\">plugin</link> to handle\n+    perserving the savepoint state.  OpenJPA includes the following\n+    <classname>SavepointManager</classname> plugins:\n+    </para>\n+          <itemizedlist>\n+            <listitem>\n+              <para><literal>in-mem</literal>: The default.  This is an alias\n+        for the <ulink url=\"org.apache.openjpa.kernel.InMemorySavepointManager\"><classname>org.apache.openjpa.kernel.InMemorySavepointManager</classname></ulink>.  This plugin stores all state, including field \n+        values, in memory.  Due to this behavior, each set savepoint \n+        is designed for small to medium transactional object counts.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>jdbc</literal>: This is an alias for the <ulink url=\"org.apache.openjpa.jdbc.kernel.JDBCSavepointManager\"><classname>\n+        org.apache.openjpa.jdbc.kernel.JDBCSavepointManager</classname></ulink>.\n+        This plugin requires <literal>JDBC 3</literal> and <classname>\n+        java.sql.Savepoint</classname> support to operate.  Note that \n+        this plugin implements savepoints by issuing a flush to the \n+        database.\n+        </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>oracle</literal>: This is an alias for the <ulink url=\"org.apache.openjpa.jdbc.sql.OracleSavepointManager\"><classname>\n+        org.apache.openjpa.jdbc.sql.OracleSavepointManager</classname></ulink>.\n+        This plugin operates similarly to the <literal>JDBC</literal>\n+        plugin; however, it uses Oracle-specific calls.\n+        This plugin requires using the Oracle JDBC driver and database,\n+        versions <literal>9.2</literal> or higher.  Note that this \n+        plugin implements savepoints by issuing a flush to the database.\n+        </para>\n+            </listitem>\n+          </itemizedlist>\n+        </section>\n+      </section>\n+      <section id=\"ref_guide_enterprise_queryext\">\n+        <title>Query Language Extensions</title>\n+        <indexterm zone=\"ref_guide_enterprise_queryext\">\n+          <primary>Query</primary>\n+          <secondary>language extensions</secondary>\n+          <seealso>JPQL</seealso>\n+        </indexterm>\n+        <para>\n+  JPQL is a powerful, easy-to-use query language, but you may\n+  occasionally find it limiting in some way. To circumvent the\n+  limitations of JPQL, OpenJPA provides extensions to the JPQL language, and\n+  allows you to extend it as well.\n+  </para>\n+<!-- ### EJBDOC : remove note when parser upgraded -->\n+        <warning>\n+          <para>\n+    The JPQL parser in this release does not yet allow extensions.  They\n+    will be made available to JPQL users in a future release.\n+    </para>\n+        </warning>\n+        <section id=\"ref_guide_enterprise_queryext_jdoql\">\n+          <title>Filter Extensions</title>\n+          <indexterm zone=\"ref_guide_enterprise_queryext_jdoql\">\n+            <primary>JPQL</primary>\n+            <secondary>language extension</secondary>\n+          </indexterm>\n+          <para>\n+    Filter extensions are custom methods that you can use in your\n+    query filter, having, ordering, and result strings.  OpenJPA provides \n+    some built-in filter extensions, and you can develop your own custom \n+    extensions as needed. You can optionally preface all filter extensions \n+    with <literal>ext:</literal> in your query string.  For example, the \n+    following example uses a hypothetical <literal>firstThreeChars\n+    </literal> extension to search for cities whose name begins with\n+    the 3 characters 'H', 'a', 'r'.\n+    </para>\n+          <example id=\"ref_guide_enterprise_queryext_jdoql_ext\">\n+            <title>Basic Filter Extension</title>\n+            <programlisting format=\"linespecific\">\n+Query q = em.createQuery (\"select c from City c where c.name.ext:firstThreeChars () = 'Har'\");\n+List results = q.getResultList ();\n+</programlisting>\n+          </example>\n+          <para>\n+    Note that it is perfectly OK to chain together extensions.  For\n+    example, let's modify our search above to be case-insensitive using\n+    another hypothetical extension, <literal>equalsIgnoreCase</literal>:\n+    </para>\n+          <example id=\"ref_guide_enterprise_queryext_jdoql_chain\">\n+            <title>Chaining Filter Extensions</title>\n+            <programlisting format=\"linespecific\">\n+Query query = em.createQuery (\"select c from City c where \"\n+    + \"c.name.ext:firstThreeChars ().ext:equalsIgnoreCase ('Har')\");\n+List results = q.getResultList ();\n+</programlisting>\n+          </example>\n+          <para>\n+    Finally, when using filter extensions you must be aware that any\n+    SQL-specific extensions can only execute against the database, and \n+    cannot be used for in-memory queries (recall that OpenJPA executes queries\n+    in-memory when you supply a candidate collection rather than a \n+    class, or when you set the <literal>IgnoreChanges</literal>\n+    and <literal>FlushBeforeQueries</literal> properties to \n+    <literal>false</literal> and you execute a query within a transaction \n+    in which you've modified data that may affect the results).\n+    </para>\n+          <section id=\"ref_guide_enterprise_queryext_jdoql_included\">\n+            <title>Included Filter Extensions</title>\n+            <para>\n+      OpenJPA includes two default filter extensions to enhance the power\n+      of your queries.\n+      </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para><indexterm><primary>JPQL</primary><secondary>language extension</secondary><tertiary>getColumn</tertiary></indexterm><literal>getColumn</literal>: Places the proper alias for\n+          the given column name into the SELECT statement that is \n+          issued.  This extension cannot be used for in-memory \n+          queries.  When traversing relations, the column is assumed \n+          to be in the primary table of the related type.\n+          </para>\n+                <programlisting format=\"linespecific\">\n+select e from Employee e where e.company.address.ext:getColumn ('ID') = 5\n+</programlisting>\n+              </listitem>\n+              <listitem>\n+                <para><indexterm><primary>JPQL</primary><secondary>language extension</secondary><tertiary>sql</tertiary></indexterm><literal>sql</literal>: Embeds the given SQL argument\n+          into the SELECT statement.\n+          This extension cannot be used for in-memory queries.\n+          </para>\n+                <programlisting format=\"linespecific\">\n+select p from Product p where p.price &lt; ext:sql ('(SELECT AVG(PRICE) FROM PRODUCTS)')\n+</programlisting>\n+              </listitem>\n+            </itemizedlist>\n+          </section>\n+          <section id=\"ref_guide_enterprise_queryext_jdoql_custom\">\n+            <title>Developing Custom Filter Extensions</title>\n+            <indexterm zone=\"ref_guide_enterprise_queryext_jdoql_custom\">\n+              <primary>JPQL</primary>\n+              <secondary>language extension</secondary>\n+              <tertiary>custom</tertiary>\n+            </indexterm>\n+            <para>\n+      You can write your own extensions by implementing the\n+      <ulink url=\"../apidocs/org/apache/openjpa/jdbc/kernel/exps/JDBCFilterListener.html\"><classname>org.apache.openjpa.jdbc.kernel.exps.JDBCFilterListener</classname></ulink> interface.  View the Javadoc documentation for details.  \n+      Additionally, the source for all of OpenJPA's built-in query \n+      extensions is included in your OpenJPA download to get you started.  \n+      The built-in extensions reside in the <filename>\n+      src/openjpa/kernel/exps</filename> and <filename>\n+      src/openjpa/jdbc/kernel/exps</filename> directories of your \n+      distribution.\n+      </para>\n+          </section>\n+          <section id=\"ref_guide_enterprise_queryext_jdoql_conf\">\n+            <title>Configuring Filter Extensions</title>\n+            <indexterm zone=\"ref_guide_enterprise_queryext_jdoql_conf\">\n+              <primary>JPQL</primary>\n+              <secondary>language extension</secondary>\n+              <tertiary>configuration</tertiary>\n+            </indexterm>\n+            <para>\n+      There are two ways to register your custom filter extensions with \n+      OpenJPA:\n+      </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para><emphasis>Registration by properties:</emphasis>\n+          You can register custom filter extensions by setting the\n+          <link linkend=\"openjpa.FilterListeners\"><literal>\n+          openjpa.FilterListeners</literal></link> configuration \n+          property to a comma-separated list of plugin strings\n+          (see <xref linkend=\"ref_guide_conf_plugins\"/>)\n+          describing your extensions classes.  Extensions \n+          registered in this fashion must have a public no-arg \n+          constructor.  They must also be thread safe, because they \n+          will be shared across all queries.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><emphasis>Per-query registration:</emphasis>  You can \n+          register filter extensions for an \n+          individual <classname>Query</classname> through the\n+          <methodname>OpenJPAQuery.addFilterListener</methodname>\n+          method.  You might use per-query registration for very \n+          specific extensions that do not apply globally.\n+          </para>\n+                <para>\n+          See the <classname>OpenJPAQuery</classname>\n+          <ulink url=\"../../api/openjpa/persistence/OpenJPAQuery.html\">Javadoc\n+          </ulink> for details.\n+          </para>\n+              </listitem>\n+            </itemizedlist>\n+          </section>\n+        </section>\n+        <section id=\"ref_guide_aggregates_custom\">\n+          <title>Aggregate Extensions</title>\n+          <indexterm zone=\"ref_guide_aggregates_custom\">\n+            <primary>JPQL</primary>\n+            <secondary>aggregate extension</secondary>\n+          </indexterm>\n+          <para>\n+    Just as you can write your own filter methods, you can write your \n+    own query aggregates by implementing the\n+    <ulink url=\"../apidocs/org/apache/openjpa/jdbc/kernel/exps/JDBCAggregateListener.html\"><classname>org.apache.openjpa.jdbc.kernel.exps.JDBCAggregateListener</classname></ulink> interface.  View the Javadoc documentation for details.  When\n+    using your custom aggregates in result or having query clauses, you can\n+    optionally prefix the function name with <literal>ext:</literal> to \n+    identify it as an extension.\n+    </para>\n+          <section id=\"ref_guide_aggregates_conf\">\n+            <title>Configuring Query Aggregates</title>\n+            <indexterm zone=\"ref_guide_aggregates_conf\">\n+              <primary>JPQL</primary>\n+              <secondary>aggregate extension</secondary>\n+              <tertiary>configuration</tertiary>\n+            </indexterm>\n+            <para>\n+      There are two ways to register your custom query aggregates with \n+      OpenJPA:\n+      </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para><emphasis>Registration by properties:</emphasis>\n+          You can register custom query aggregates by setting the\n+          <link linkend=\"openjpa.AggregateListeners\"><literal>\n+          openjpa.AggregateListeners</literal></link> configuration \n+          property to a comma-separated list of plugin strings \n+          (see <xref linkend=\"ref_guide_conf_plugins\"/>)\n+          describing your aggregate implementation.  Aggregates \n+          registered in this fashion must have a public\n+          no-arg constructor.  They must also be thread safe,\n+          because they will be shared across all queries.\n+          </para>\n+              </listitem>\n+              <listitem>\n+                <para><emphasis>Per-query registration:</emphasis> \n+          You can register query aggregates for an individual \n+          <classname>Query</classname> through the \n+          <methodname>OpenJPAQuery.addAggregateListener</methodname>\n+          method.  You might use per-query registration for\n+          very specific aggregates that do not apply globally.\n+          </para>\n+                <para>\n+          See the <classname>OpenJPAQuery</classname>\n+          <ulink url=\"../../api/openjpa/persistence/OpenJPAQuery.html\">Javadoc\n+          </ulink> for details.\n+          </para>\n+              </listitem>\n+            </itemizedlist>\n+          </section>\n+        </section>\n+        <section id=\"ref_guide_enterprise_methodql\">\n+          <title>MethodQL</title>\n+          <indexterm zone=\"ref_guide_enterprise_methodql\">\n+            <primary>MethodQL</primary>\n+          </indexterm>\n+          <indexterm>\n+            <primary>Query</primary>\n+            <secondary>MethodQL</secondary>\n+            <see>MethodQL</see>\n+          </indexterm>\n+          <para>\n+    If JPQL and SQL queries do not match your needs, OpenJPA also allows you \n+    to name a Java method to use to load a set of objects.\n+    In a <emphasis>MethodQL</emphasis> query, the query string \n+    names a static method to invoke to determine the matching objects:\n+    </para>\n+          <programlisting format=\"linespecific\">\n+import org.apache.openjpa.persistence.*;\n+\n+...\n+\n+// the method query language is 'openjpa.MethodQL'.\n+// set the query string to the method to execute, including full class name; if\n+// the class is in the candidate class' package or in the query imports, you\n+// can omit the package; if the method is in the candidate class, you can omit\n+// the class name and just specify the method name\n+OpenJPAEntityManager kem = OpenJPAPersistence.cast (emf);\n+OpenJPAQuery q = kem.createQuery (\"openjpa.MethodQL\", \"com.xyz.Finder.getByName\");\n+\n+// set the type of objects that the method returns\n+q.setResultClass (Person.class);\n+\n+// parameters are passed the same way as in standard queries\n+q.setParameter (\"firstName\", \"Fred\").setParameter (\"lastName\", \"Lucas\");\n+\n+// this executes your method to get the results\n+List results = q.getResultList ();\n+</programlisting>\n+          <para>\n+    For datastore queries, the method must have the following signature:\n+    </para>\n+          <programlisting format=\"linespecific\">\n+public static <ulink url=\"../apidocs/org/apache/openjpa/lib/rop/ResultObjectProvider.html\">ResultObjectProvider</ulink> xxx(<ulink url=\"../apidocs/org/apache/openjpa/kernel/StoreContext.html\">StoreContext</ulink> ctx, \n+    <ulink url=\"../apidocs/org/apache/openjpa/meta/ClassMetaData.html\">ClassMetaData</ulink> meta, boolean subclasses, Map params, <ulink url=\"../apidocs/org/apache/openjpa/kernel/FetchConfiguration.html\">FetchConfiguration</ulink> fetch)\n+</programlisting>\n+          <para>\n+    The returned result object provider should produce objects of the \n+    candidate class that match the method's search criteria.  If the\n+    returned objects do not have all fields in the given fetch configuration\n+    loaded, OpenJPA will make additional trips to the datastore as necessary\n+    to fill in the data for the missing fields.\n+    </para>\n+          <para>\n+    In-memory execution is slightly different, taking in one object\n+    at a time and returning a boolean on whether the object matches the\n+    query:\n+    </para>\n+          <programlisting format=\"linespecific\">\n+public static boolean xxx(<ulink url=\"../apidocs/org/apache/openjpa/kernel/StoreContext.html\">StoreContext</ulink> ctx, <ulink url=\"../apidocs/org/apache/openjpa/meta/ClassMetaData.html\">ClassMetaData</ulink> meta, \n+    boolean subclasses, Object obj, Map params, <ulink url=\"../apidocs/org/apache/openjpa/kernel/FetchConfiguration.html\">FetchConfiguration</ulink> fetch)\n+</programlisting>\n+          <para>\n+    In both method versions, the given <literal>params</literal> map \n+    contains the names and values of all the parameters for the query.\n+    </para>\n+        </section>\n+      </section>\n+      <section id=\"ref_guide_sequence\">\n+        <title>Generators</title>\n+        <indexterm zone=\"ref_guide_sequence\">\n+          <primary>generators</primary>\n+          <secondary>Seq interface</secondary>\n+        </indexterm>\n+        <para>\n+    The JPA Overview's <xref linkend=\"jpa_overview_mapping\"/> details\n+    using generators to automatically populate identity fields in JPA.\n+    </para>\n+        <para>\n+    OpenJPA represents all generators internally with the \n+    <ulink url=\"../apidocs/org/apache/openjpa/kernel/Seq.html\"><classname>org.apache.openjpa.kernel.Seq</classname></ulink> interface.  This \n+    interface supplies all the context you need to create your own custom\n+    generators, including the current persistence environment,\n+    the JDBC <classname>DataSource</classname>, and other essentials.  \n+    The <ulink url=\"../apidocs/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.html\"><classname>org.apache.openjpa.jdbc.kernel.AbstractJDBCSeq</classname></ulink> helps\n+    you create custom JDBC-based sequences.\n+    OpenJPA also supplies the following built-in <classname>Seq</classname>s:\n+    </para>\n+        <itemizedlist>\n+          <listitem>\n+            <para><indexterm><primary>generators</primary><secondary>table</secondary></indexterm><literal>table</literal>: This is OpenJPA's default implementation.\n+        It is an alias for the\n+        <ulink url=\"../apidocs/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.html\"><classname>org.apache.openjpa.jdbc.kernel.TableJDBCSeq</classname></ulink>\n+        class.  The <classname>TableJDBCSeq</classname> uses a special\n+        single-row table to store a global sequence number.  If the \n+        table does not already exist, it is created the first time you \n+        run the <link linkend=\"ref_guide_mapping_mappingtool\">\n+        mapping tool</link>'s on a class that requires it.  You can also\n+        use the class' <methodname>main</methodname> method or the\n+        <literal>sequencetable</literal> shell/bat script to manipulate\n+        the table; see the <methodname>TableJDBCSeq.main</methodname> \n+        method Javadoc for usage details.\n+        </para>\n+            <para>\n+        This <classname>Seq</classname> has the following properties:\n+        </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para><literal>Table</literal>: The name of the sequence \n+            number table to use.  Defaults to \n+            <literal>OPENJPA_SEQUENCE_TABLE</literal>.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>PrimaryKeyColumn</literal>: The name of\n+            the primary key column for the sequence table.\n+            Defaults to <literal>ID</literal>.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>SequenceColumn</literal>:  The name of \n+            the column that will hold the current sequence\n+            value.  Defaults to <literal>SEQUENCE_VALUE</literal>.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>Allocate</literal>: The number of values to\n+            allocate on each database trip.  Defaults to \n+            50, meaning the class will set aside the next 50 \n+            numbers each time it accesses the sequence table, which\n+            in turn means it only has to make a database trip to \n+            get new sequence numbers once every 50 sequence number\n+            requests.\n+            </para>\n+              </listitem>\n+            </itemizedlist>\n+          </listitem>\n+          <listitem>\n+            <para><indexterm><primary>generators</primary><secondary>class-table</secondary></indexterm><literal>class-table</literal>: This is an alias for the\n+        <ulink url=\"../apidocs/org/apache/openjpa/jdbc/kernel/ClassTableJDBCSeq.html\"><classname>org.apache.openjpa.jdbc.kernel.ClassTableJDBCSeq\n+        </classname></ulink>.  This <classname>Seq</classname> is like\n+        the <classname>TableJDBCSeq</classname> above, but maintains a \n+        separate table row, and therefore a separate sequence number,\n+        for each base persistent class. It has all the properties of \n+        the <classname>TableJDBCSeq</classname>.  Its table name \n+        defaults to <literal>OPENJPA_SEQUENCES_TABLE</literal>.  It\n+        also adds the following properties:\n+        </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para><literal>IgnoreUnmapped</literal>: Whether to ignore\n+            unmapped base classes, and instead use one row per\n+            least-derived mapped class.  Defaults to\n+            <literal>false</literal>.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>UseAliases</literal>: Whether to use\n+            each class' entity name as the primary key value of each\n+            row, rather than the full class name.  Defaults to\n+            <literal>false</literal>.\n+            </para>\n+              </listitem>\n+            </itemizedlist>\n+            <para>\n+        As with the <classname>TableJDBCSeq</classname>, the <classname>\n+        ClassTableJDBCSeq</classname> creates its table automatically\n+        during mapping tool runs.  However, you can manually manipulate\n+        the table through the class' <methodname>main</methodname> \n+        method, or through the <literal>classsequencetable</literal>\n+        shell/bat script.  See the Javadoc for the <methodname>\n+        ClassTableJDBCSeq.main</methodname> method for usage details.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><indexterm><primary>generators</primary><secondary>value-table</secondary></indexterm><literal>value-table</literal>: This is an alias for the\n+        <ulink url=\"../apidocs/org/apache/openjpa/jdbc/kernel/ValueTableJDBCSeq.html\"><classname>org.apache.openjpa.jdbc.kernel.ValueTableJDBCSeq\n+        </classname></ulink>.  This <classname>Seq</classname> is like\n+        the <classname>ClassTableJDBCSeq</classname> above, but has\n+        an arbitrary number of rows for sequence values, rather than\n+        a fixed pattern of one row per class.   Its table\n+        defaults to <literal>OPENJPA_SEQUENCES_TABLE</literal>.\n+        It has all the properties of the \n+        <classname>TableJDBCSeq</classname>, plus:\n+        </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para><literal>PrimaryKeyValue</literal>: The primary key\n+            value used by this instance.  \n+            </para>\n+              </listitem>\n+            </itemizedlist>\n+            <para>\n+        As with the <classname>TableJDBCSeq</classname>, the <classname>\n+        ValueTableJDBCSeq</classname> creates its table automatically \n+        during mapping tool runs.  However, you can manually manipulate\n+        the table through the class' <methodname>main</methodname> \n+        method, or through the <literal>valuesequencetable</literal>\n+        shell/bat script.  See the Javadoc for the <methodname>\n+        ValueTableJDBCSeq.main</methodname> method for usage details.\n+        </para>\n+          </listitem>\n+          <listitem>\n+            <para><indexterm><primary>generators</primary><secondary>native</secondary></indexterm><literal>native</literal>: This is an alias for the\n+        <ulink url=\"../apidocs/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.html\"><classname>org.apache.openjpa.jdbc.kernel.NativeJDBCSeq</classname></ulink>.\n+        Many databases have a concept of \"native sequences\" - a \n+        built-in mechanism for obtaining incrementing \n+        numbers.  For example, in Oracle, you can create a database \n+        sequence with a statement like <literal>CREATE SEQUENCE \n+        MYSEQUENCE</literal>.  Sequence values can then be \n+        atomically obtained and incremented with the statement \n+        <literal>SELECT MYSEQUENCE.NEXTVAL FROM DUAL</literal>.\n+        OpenJPA provides support for this common mechanism of \n+        sequence generation with the <classname>\n+        NativeJDBCSeq</classname>, which accepts the following \n+        properties:\n+        </para>\n+            <itemizedlist>\n+              <listitem>\n+                <para><literal>Sequence</literal>: The name of the database \n+            sequence.  Defaults to <literal>OPENJPA_SEQUENCE</literal>.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>InitialValue</literal>: The initial sequence\n+            value.  Defaults to 1.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>Increment</literal>: The amount the sequence\n+            increments.  Defaults to 1.\n+            </para>\n+              </listitem>\n+              <listitem>\n+                <para><literal>Allocate</literal>: Some database can allocate\n+            values in-memory to service subsequent sequence requests\n+            faster. \n+            </para>\n+              </listitem>\n+            </itemizedlist>\n+          </listitem>\n+          <listitem>\n+            <para><indexterm><primary>generators</primary><secondary>time</secondary></indexterm><literal>time</literal>: This is an alias for the\n+        <ulink url=\"../apidocs/org/apache/openjpa/kernel/TimeSeededSeq.html\"><classname>org.apache.openjpa.kernel.TimeSeededSeq</classname></ulink>.\n+        This type uses an in-memory static counter, initialized to the \n+        current time in milliseconds and monotonically incremented for \n+        each value requested.  It is only suitable for single-JVM \n+        environments.\n+        </para>\n+          </listitem>\n+        </itemizedlist>\n+        <para>\n+    You can use JPA <literal>SequenceGenerator</literal>s to describe any\n+    built-in <classname>Seq</classname>s or your own <classname>Seq\n+    </classname> implementation.  Set the <literal>sequenceName</literal> \n+    attribute to a plugin string describing your choice.  See \n+    <xref linkend=\"jpa_overview_mapping_sequence\"/> in the JPA\n+    Overview for details on defining <literal>SequenceGenerator</literal>s.\n+    </para>\n+        <para>\n+    See <xref linkend=\"ref_guide_conf_plugins\"/> for plugin string \n+    formatting.\n+    </para>\n+        <example id=\"ref_guide_sequence_named\">\n+          <title>Named Seq Sequence</title>\n+          <programlisting format=\"linespecific\">\n+@Entity\n+@Table(name=\"AUTO\")\n+public class Author\n+{\n+    @Id\n+    @GeneratedValue(strategy=GenerationType.SEQUENCE, generator=\"AuthorSeq\")\n+    @SequenceGenerator(name=\"AuthorSeq\" sequence=\"table(Table=AUTO_SEQ, Increment=100)\")\n+    @Column(name=\"AID\")\n+    private long id;\n+ \n+    ...\n+}\n+</programlisting>\n+          <para>\n+      Note that if you want to use a plugin string without any arguments,\n+      you must still suffix the plugin type with <literal>()</literal>\n+      to differentiate it from a sequence name in the <literal>\n+      SequenceGenerator.sequence</literal> attribute:\n+      </para>\n+          <programlisting format=\"linespecific\">\n+@SequenceGenerator(name=\"AuthorSeq\", sequence=\"table()\")\n+</programlisting>\n+        </example>\n+        <para>\n+    OpenJPA maintains a <emphasis>system</emphasis> sequence to generate \n+    datastore identity values for classes that do not declare a specific \n+    datastore identity strategy.  You can configure the system sequence \n+    through the <link linkend=\"openjpa.Sequence\"><literal>openjpa.Sequence\n+    </literal></link> configuration property.  This property accepts a \n+    plugin string describing a <classname>Seq</classname> instance.\n+    </para>\n+        <example id=\"ref_guide_sequence_systemex\">\n+          <title>System Sequence Configuration</title>\n+          <programlisting format=\"linespecific\">\n+&lt;property name=\"openjpa.Sequence\" value=\"table(Table=OPENJPASEQ, Increment=100)\"/&gt;\n+</programlisting>\n+        </example>\n+        <para>\n+    In JPA, set your <literal>GeneratedValue</literal> \n+    annotation's <literal>strategy</literal> attribute to \n+    <literal>AUTO</literal> to use the configured system sequence.  Or,\n+    because <literal>AUTO</literal> is the default strategy, use the\n+    annotation without attributes:\n+    </para>\n+        <programlisting format=\"linespecific\">\n+@GeneratedValue\n+private long id;\n+</programlisting>\n+        <section id=\"ref_guide_sequence_runtime\">\n+          <title>Runtime Access</title>\n+          <indexterm zone=\"ref_guide_sequence_runtime\">\n+            <primary>Sequence</primary>\n+            <secondary>runtime access</secondary>\n+          </indexterm>\n+          <para>\n+      OpenJPA allows you to access named generators at runtime\n+      through the <methodname>OpenJPAEntityManager.getNamedGenerator\n+      </methodname> method:\n+      </para>\n+          <programlisting format=\"linespecific\">\n+public Generator getNamedGenerator (String name);\n+</programlisting>\n+          <para>\n+      The returned <ulink url=\"../../api/openjpa/persistence/Generator.html\"><classname>org.apache.openjpa.persistence.Generator</classname></ulink> is a \n+      facade over an internal OpenJPA <classname>Seq</classname>.\n+      </para>\n+          <para>\n+      The <classname>OpenJPAEntityManager</classname> includes \n+      additional APIs to retrieve the identity generator of any class, \n+      or the generator of any field.  With these APIs, you do not have\n+      to know the generator name.  Additionally, they allow you to access\n+      the implicit generator used by default for datastore identity\n+      classes.  See the \n+      <ulink url=\"../../api/openjpa/persistence/OpenJPAEntityManager.html\">\n+      Javadoc</ulink> for the <methodname>\n+      OpenJPAEntityManager.getIdentityGenerator</methodname> and \n+      <methodname>OpenJPAEntityManager.getFieldGenerator</methodname> \n+      methods for API details.  \n+      </para>\n+        </section>\n+      </section>\n+      <section id=\"ref_guide_runtime_pm_event\">\n+        <title>Transaction Events</title>\n+        <indexterm zone=\"ref_guide_runtime_pm_event\">\n+          <primary>transactions</primary>\n+          <secondary>events</secondary>\n+        </indexterm>\n+        <para>\n+    The OpenJPA runtime supports\n+    broadcasting transaction-related events.  By registering one or more\n+    <ulink url=\"../apidocs/org/apache/openjpa/event/TransactionListener.html\"><classname>org.apache.openjpa.event.TransactionListener</classname></ulink>s, you can \n+    receive notifications when transactions begin, flush, rollback, commit,\n+    and more.  Where appropriate, event notifications include the set of \n+    persistence-capable objects participating in the transaction.\n+    </para>\n+        <programlisting format=\"linespecific\">\n+public void addTransactionListener (Object listener);\n+public void removeTransactionListener (Object listener);\n+</programlisting>\n+        <para>\n+    These <classname>OpenJPAEntityManager</classname> methods allow you\n+    to add and remove listeners.\n+    </para>\n+        <para>\n+    For details on the transaction framework, see the <literal>\n+    org.apache.openjpa.event</literal> package\n+    <ulink url=\"../apidocs/org/apache/openjpa/event/package.html\">Javadoc</ulink>.\n+    Also see <xref linkend=\"ref_guide_event\"/> for a description of\n+    OpenJPA's remote event support.\n+    </para>\n+      </section>\n+      <section id=\"ref_guide_enterprise_abstractstore\">\n+        <title>Non-Relational Stores</title>\n+        <para>\n+    It is possible to adapt OpenJPA to access a non-relational datastore\n+    by creating an implementation of the \n+    <ulink url=\"../apidocs/org/apache/openjpa/kernel/StoreManager.html\"><literal>org.apache.openjpa.kernel.StoreManager</literal></ulink> interface. OpenJPA\n+    provides an abstract <literal>StoreManager</literal> implementation to \n+    facilitate this process. See the <literal>org.apache.openjpa.abstractstore</literal> \n+    package <ulink url=\"../apidocs/org/apache/openjpa/abstractstore\">Javadoc</ulink> for \n+    details.  \n+    \n+    </para>\n+      </section>\n+    </chapter>"},{"sha":"17c8a24a5d146cd55947cd0209ccc6eb495d48a9","filename":"openjpa-project/src/doc/manual/samples_guide.xml","status":"added","additions":137,"deletions":0,"changes":137,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/samples_guide.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/samples_guide.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/samples_guide.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,137 @@\n+\n+    <chapter id=\"samples_guide\">\n+      <title>OpenJPA Sample Code</title>\n+      <para>\n+  The OpenJPA distribution comes with a number of examples that\n+  illustrate the usage of various features.\n+  </para>\n+<!--\n+  This is information on the sample application. It will be included\n+  in the documentation (see doc/openjpa/samples-guide.xml). It will also\n+  automatically be converted into a README.txt file in this directory\n+  in the \"release.org.apache.openjpa.releasedocs\" build target phase of the release.\n+-->\n+      <section id=\"samples_guide_interop\">\n+        <title>JDO - JPA Persistence Interoperability</title>\n+        <para>This sample demonstrates how to combine JDO and JPA in a single\n+application. The <filename>MachineMain.java</filename> program uses both\n+<classname>EntityManager</classname>s and <classname>PersistenceManager</classname>s \n+in a single transaction including persist, delete and query operations.</para>\n+        <para>The sample includes both annotated persistent classes as well as JDOR \n+metadata information.  The application can switch to either system simply\n+by changing the bootstrap mechanism.  Depending on which configuration\n+system you use, OpenJPA will read the corresponding metadata format.  You can\n+override some or all of this behavior using OpenJPA's configuration options, \n+such as <link linkend=\"openjpa.MetaDataFactory\">openjpa.MetaDataFactory</link>.</para>\n+        <para>To use this sample, you should ensure that either a <filename>jdo.properties</filename>\n+or <filename>persistence.xml</filename> are in the <filename>META-INF</filename> directory \n+in your <envar>CLASSPATH</envar>. The rest of the files for this sample are located in the \n+<filename>samples/mixed</filename> directory of the OpenJPA installation.  This tutorial requires JDK 5.  \n+To run this tutorial:</para>\n+        <itemizedlist>\n+          <listitem>\n+            <para>Ensure that your environment is set properly as described in the\n+  README and that your current path is in the mixed sample directory.</para>\n+          </listitem>\n+          <listitem>\n+            <para>\n+  You may want to edit <literal>ConnectionURL</literal> to point to an absolute \n+    URL (e.g. <filename>C:/openjpa/mixed-sample-db</filename>) if using a file-based database like \n+  <literal>HSQL</literal>.</para>\n+          </listitem>\n+          <listitem>\n+            <para>Include the list of persistent classes in your configuration file.  For\n+  JPA, you will want to add the following lines to \n+  <filename>persistence.xml</filename> before the <literal>&lt;property&gt;</literal> lines:\n+  </para>\n+            <programlisting format=\"linespecific\">\n+&lt;class&gt;samples.mixed.Machine&lt;/class&gt;\n+&lt;class&gt;samples.mixed.Crane&lt;/class&gt;\n+&lt;class&gt;samples.mixed.Bulldozer&lt;/class&gt;\n+&lt;class&gt;samples.mixed.Operator&lt;/class&gt;\n+</programlisting>\n+            <para>\n+  If you are using JDO, point the metadata factory at the <filename>.jdo</filename>\n+resource containing your persistent classes:\n+  </para>\n+            <programlisting format=\"linespecific\">\n+openjpa.MetaDataFactory: Resources=samples/mixed/package.jdo\n+</programlisting>\n+          </listitem>\n+          <listitem>\n+            <para>Compile the classes:\n+  \n+  </para>\n+            <para>\n+              <userinput>javac *.java</userinput>\n+            </para>\n+          </listitem>\n+          <listitem>\n+            <para>You should then proceed to pass in the configuration file you are using\n+  to the enhancer:\n+\n+  </para>\n+            <para>\n+              <userinput>openjpac -p persistence.xml Machine.java Crane.java Bulldozer.java Operator.java</userinput>\n+            </para>\n+            <para>\n+    or\n+  </para>\n+            <para>\n+              <userinput>jdoc -p jdo.properties Machine.java Crane.java Bulldozer.java Operator.java</userinput>\n+            </para>\n+          </listitem>\n+          <listitem>\n+            <para>Similarly, you should pass in the same argument to <literal>mappingtool</literal>:\n+\n+  </para>\n+            <para>\n+              <userinput>mappingtool -p persistence.xml -a buildSchema Machine.java Crane.java Bulldozer.java Operator.java</userinput>\n+            </para>\n+            <para>\n+    or\n+  </para>\n+            <para>\n+              <userinput>mappingtool -p jdo.properties -a buildSchema Machine.java Crane.java Bulldozer.java Operator.java</userinput>\n+            </para>\n+          </listitem>\n+          <listitem>\n+            <para>You can now run the sample application.  The first argument is\n+  which operation you want the program to run.  The second argument tells \n+  the application which bootstrap system to use:\n+\n+  </para>\n+            <para>\n+              <userinput>java samples.mixed.MachineMain &lt;create | delete&gt; &lt;jdo | jpa&gt;</userinput>\n+            </para>\n+          </listitem>\n+        </itemizedlist>\n+      </section>\n+      <section id=\"samples_guide_ejbdiv\">\n+        <title>JPA</title>\n+<!--\n+  This is information on the sample application. It will be included\n+  in the documentation (see doc/openjpa/samples-guide.xml). It will also\n+  automatically be converted into a README.txt file in this directory\n+  in the \"release.jdo.releasedocs\" build target phase of the release.\n+-->\n+        <section id=\"samples_guide_model_humres_ejb\">\n+          <title>Sample Human Resources Model</title>\n+          <para>The files for this sample are located in the <filename>samples/persistence/models/humres</filename> \n+directory of the OpenJPA installation.  This sample demonstrates the mapping of \n+an example \"Human Resources\" schema. The following concepts are illustrated\n+in this sample:</para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>Value Mappings</para>\n+            </listitem>\n+            <listitem>\n+              <para>One to One Mappings</para>\n+            </listitem>\n+            <listitem>\n+              <para>One to Many Mappings (with and without inverses)</para>\n+            </listitem>\n+          </itemizedlist>\n+        </section>\n+      </section>\n+    </chapter>"},{"sha":"ba4bd295014f344a7f4a24f44c2a2ca182c4eee9","filename":"openjpa-project/src/doc/manual/supported_databases.xml","status":"added","additions":623,"deletions":0,"changes":623,"blob_url":"https://github.com/apache/openjpa/blob/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/supported_databases.xml","raw_url":"https://github.com/apache/openjpa/raw/ac98ba5c8084f6cb8d8973c31b7b907dbee63b53/openjpa-project/src/doc/manual/supported_databases.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/supported_databases.xml?ref=ac98ba5c8084f6cb8d8973c31b7b907dbee63b53","patch":"@@ -0,0 +1,623 @@\n+\n+  <appendix id=\"supported_databases\">\n+    <title>Supported Databases</title>\n+    <para>\n+  Following is a table of the database and JDBC driver\n+  versions that are supported by OpenJPA <phrase>JPA</phrase>.\n+  <table tocentry=\"1\"><title>Supported Databases and JDBC Drivers</title><tgroup rowsep=\"1\" colsep=\"1\" align=\"left\" cols=\"4\"><colspec colname=\"dbname\"/><colspec colname=\"dbversion\"/><colspec colname=\"drivname\"/><colspec colname=\"drivversion\"/><thead><row><entry colname=\"dbname\">Database Name</entry><entry colname=\"dbversion\">Database Version</entry><entry colname=\"drivname\">JDBC Driver Name</entry><entry colname=\"drivversion\">JDBC Driver Version</entry></row></thead><tbody><row><entry colname=\"dbname\">Apache Derby</entry><entry colname=\"dbversion\">10.1.2.1</entry><entry colname=\"drivname\">Apache Derby Embedded JDBC Driver</entry><entry colname=\"drivversion\">10.1.2.1</entry></row><row><entry colname=\"dbname\">Borland Interbase</entry><entry colname=\"dbversion\">7.1.0.202</entry><entry colname=\"drivname\">Interclient</entry><entry colname=\"drivversion\">4.5.1</entry></row><row><entry colname=\"dbname\">Borland JDataStore</entry><entry colname=\"dbversion\">6.0</entry><entry colname=\"drivname\">\n+            Borland JDataStore\n+          </entry><entry colname=\"drivversion\">6.0</entry></row><row><entry colname=\"dbname\">DB2</entry><entry colname=\"dbversion\">8.1</entry><entry colname=\"drivname\">\n+            IBM DB2 JDBC Universal Driver\n+          </entry><entry colname=\"drivversion\">1.0.581</entry></row><row><entry colname=\"dbname\">Empress</entry><entry colname=\"dbversion\">8.62</entry><entry colname=\"drivname\">\n+            Empress Category 2 JDBC Driver\n+          </entry><entry colname=\"drivversion\">8.62</entry></row><row><entry colname=\"dbname\">Firebird</entry><entry colname=\"dbversion\">1.5</entry><entry colname=\"drivname\">JayBird JCA/JDBC driver</entry><entry colname=\"drivversion\">1.0.1</entry></row><row><entry colname=\"dbname\">Hypersonic Database Engine</entry><entry colname=\"dbversion\">1.8.0</entry><entry colname=\"drivname\">Hypersonic</entry><entry colname=\"drivversion\">1.8.0</entry></row><row><entry colname=\"dbname\">Informix Dynamic Server</entry><entry colname=\"dbversion\">9.30.UC10</entry><entry colname=\"drivname\">Informix JDBC driver</entry><entry colname=\"drivversion\">2.21.JC2</entry></row><row><entry colname=\"dbname\">InterSystems Cache</entry><entry colname=\"dbversion\">5.0</entry><entry colname=\"drivname\">Cache JDBC Driver</entry><entry colname=\"drivversion\">5.0</entry></row><row><entry colname=\"dbname\">Microsoft Access</entry><entry colname=\"dbversion\">9.0 (a.k.a. \"2000\")</entry><entry colname=\"drivname\">\n+            DataDirect SequeLink\n+          </entry><entry colname=\"drivversion\">5.4.0038</entry></row><row><entry colname=\"dbname\">Microsoft SQL Server</entry><entry colname=\"dbversion\">\n+            9.00.1399 (SQL Server 2005)\n+          </entry><entry colname=\"drivname\">SQLServer</entry><entry colname=\"drivversion\">1.0.809.102</entry></row><row><entry colname=\"dbname\">Microsoft Visual FoxPro</entry><entry colname=\"dbversion\">7.0</entry><entry colname=\"drivname\">\n+            DataDirect SequeLink\n+          </entry><entry colname=\"drivversion\">5.4.0038</entry></row><row><entry colname=\"dbname\">MySQL</entry><entry colname=\"dbversion\">3.23.43-log</entry><entry colname=\"drivname\">MySQL Driver</entry><entry colname=\"drivversion\">3.0.14</entry></row><row><entry colname=\"dbname\">Oracle</entry><entry colname=\"dbversion\">8.1,9.2,10.1</entry><entry colname=\"drivname\">Oracle JDBC driver</entry><entry colname=\"drivversion\">10.2.0.1.0</entry></row><row><entry colname=\"dbname\">Pointbase</entry><entry colname=\"dbversion\">4.4</entry><entry colname=\"drivname\">Pointbase JDBC driver</entry><entry colname=\"drivversion\">4.4 (4.4) </entry></row><row><entry colname=\"dbname\">PostgreSQL</entry><entry colname=\"dbversion\">7.2.1</entry><entry colname=\"drivname\">PostgreSQL Native Driver</entry><entry colname=\"drivversion\">7.2 (7.2)</entry></row><row><entry colname=\"dbname\">\n+            Sybase Adaptive Server Enterprise\n+          </entry><entry colname=\"dbversion\">12.5</entry><entry colname=\"drivname\">jConnect</entry><entry colname=\"drivversion\">5.5 (5.5)</entry></row></tbody></tgroup></table>\n+    </para>\n+    <section id=\"dbsupport_derby\">\n+      <title>Apache Derby</title>\n+      <example id=\"example_props_derby\">\n+        <title>Example properties for Derby</title>\n+        <programlisting format=\"linespecific\">\n+openjpa.ConnectionDriverName: org.apache.derby.jdbc.EmbeddedDriver\n+openjpa.ConnectionURL: jdbc:derby:DB_NAME;create=true\n+</programlisting>\n+      </example>\n+    </section>\n+    <section id=\"dbsupport_interbase\">\n+      <title>Borland Interbase</title>\n+      <example id=\"example_props_interbase\">\n+        <title>Example properties for Interbase</title>\n+        <programlisting format=\"linespecific\">\n+openjpa.ConnectionDriverName: interbase.interclient.Driver\n+openjpa.ConnectionURL: jdbc:interbase://SERVER_NAME:SERVER_PORT/DB_PATH\n+</programlisting>\n+      </example>\n+      <section id=\"dbsupport_interbase_issues\">\n+        <title>Known issues with Interbase</title>\n+        <para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+            Interbase does not support record locking, so datastore\n+            transactions cannot use the pessimistic lock manager.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            Interbase does not support the\n+            <literal>LOWER</literal>, <literal>SUBSTRING</literal>,\n+            or <literal>INSTR</literal> SQL functions,\n+            which means that\n+            <methodname>toLowerCase()</methodname>,\n+            <methodname>indexOf()</methodname>,\n+            and <methodname>substring()</methodname>\n+            methods in <phrase>JPA</phrase>QL cannot be used.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+        </para>\n+      </section>\n+    </section>\n+    <section id=\"dbsupport_jdatastore\">\n+      <title>JDataStore</title>\n+      <example id=\"example_props_jdatastore\">\n+        <title>Example properties for JDataStore</title>\n+        <programlisting format=\"linespecific\">\n+openjpa.ConnectionDriverName: com.borland.datastore.jdbc.DataStoreDriver\n+openjpa.ConnectionURL: jdbc:borland:dslocal:db-jdatastore.jds;create=true\n+</programlisting>\n+      </example>\n+    </section>\n+    <section id=\"dbsupport_db2\">\n+      <title>IBM DB2</title>\n+      <example id=\"example_props_db2\">\n+        <title>Example properties for IBM DB2</title>\n+        <programlisting format=\"linespecific\">\n+openjpa.ConnectionDriverName: com.ibm.db2.jcc.DB2Driver\n+openjpa.ConnectionURL: jdbc:db2://SERVER_NAME:SERVER_PORT/DB_NAME\n+</programlisting>\n+      </example>\n+      <section id=\"dbsupport_db2_issues\">\n+        <title>Known issues with DB2</title>\n+        <para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>Floats and doubles may lose precision when stored.</para>\n+            </listitem>\n+            <listitem>\n+              <para>Empty char values are stored as NULL.</para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+      Fields of type BLOB and CLOB are limited to 1M. This number can be \n+      increased by extending <classname>DB2Dictionary</classname>.\n+      </para>\n+            </listitem>\n+          </itemizedlist>\n+        </para>\n+      </section>\n+    </section>\n+    <section id=\"dbsupport_empress\">\n+      <title>Empress</title>\n+      <example id=\"example_props_empress\">\n+        <title>Example properties for Empress</title>\n+        <programlisting format=\"linespecific\">\n+openjpa.ConnectionDriverName: empress.jdbc.empressDriver\n+openjpa.ConnectionURL: jdbc:empress://SERVER=yourserver;PORT=6322;DATABASE=yourdb\n+</programlisting>\n+      </example>\n+      <section id=\"dbsupport_empress_issues\">\n+        <title>Known issues with Empress</title>\n+        <para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+            Empress enforces pessimistic semantics (lock \n+            on read) when not using \n+            <literal>AllowConcurrentRead</literal> property\n+            (which bypasses row locking) for \n+            <classname>EmpressDictionary</classname>.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            Only the category 2 non-local driver is supported.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+        </para>\n+      </section>\n+    </section>\n+    <section id=\"dbsupport_hypersonic\">\n+      <title>Hypersonic</title>\n+      <example id=\"example_props_hypersonic\">\n+        <title>Example properties for Hypersonic</title>\n+        <programlisting format=\"linespecific\">\n+openjpa.ConnectionDriverName: org.hsqldb.jdbcDriver\n+openjpa.ConnectionURL: jdbc:hsqldb:DB_NAME\n+</programlisting>\n+      </example>\n+      <section id=\"dbsupport_hypersonic_issues\">\n+        <title>Known issues with Hypersonic</title>\n+        <para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+            Hypersonic does not properly support foreign key\n+            constraints.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            Hypersonic does not support pessimistic locking,\n+            so non-optimistic transactions will fail unless\n+            the <literal>SimulateLocking</literal> property\n+            is set for the <link linkend=\"openjpa.jdbc.DBDictionary\">\n+            openjpa.jdbc.DBDictionary</link>\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+        </para>\n+      </section>\n+    </section>\n+    <section id=\"dbsupport_firebird\">\n+      <title>Firebird</title>\n+      <example id=\"example_props_firebird\">\n+        <title>Example properties for Firebird</title>\n+        <programlisting format=\"linespecific\">\n+openjpa.ConnectionDriverName: org.firebirdsql.jdbc.FBDriver\n+openjpa.ConnectionURL: jdbc:firebirdsql://SERVER_NAME:SERVER_PORT/DB_PATH\n+</programlisting>\n+      </example>\n+      <section id=\"dbsupport_firebird_issues\">\n+        <title>Known issues with Firebird</title>\n+        <para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+          The Firebird JDBC driver does not have proper support\n+          for batch updates, so batch updates are disabled.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+          Firebird does not support auto-increment columns.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            Firebird does not support the\n+            <literal>LOWER</literal>, <literal>SUBSTRING</literal>,\n+            or <literal>INSTR</literal> SQL functions,\n+            which means that\n+            <methodname>toLowerCase()</methodname>,\n+            <methodname>indexOf()</methodname>,\n+            and <methodname>substring()</methodname>\n+            methods in <phrase>JPA</phrase>QL cannot be used.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+        </para>\n+      </section>\n+    </section>\n+    <section id=\"dbsupport_informix\">\n+      <title>Informix</title>\n+      <example id=\"example_props_informix\">\n+        <title>Example properties for Informix Dynamic Server</title>\n+        <programlisting format=\"linespecific\">\n+openjpa.ConnectionDriverName: com.informix.jdbc.IfxDriver\n+openjpa.ConnectionURL: \\\n+  jdbc:informix-sqli://SERVER_NAME:SERVER_PORT/DB_NAME:INFORMIXSERVER=SERVER_ID\n+</programlisting>\n+      </example>\n+      <section id=\"dbsupport_informix_issues\">\n+        <title>Known issues with Informix</title>\n+        <para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+          none\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+        </para>\n+      </section>\n+    </section>\n+    <section id=\"dbsupport_intersystems_cache\">\n+      <title>InterSystems Cache</title>\n+      <example id=\"example_props_intersystems_cache\">\n+        <title>Example properties for InterSystems Cache</title>\n+        <programlisting format=\"linespecific\">\n+openjpa.ConnectionDriverName: com.intersys.jdbc.CacheDriver\n+openjpa.ConnectionURL: jdbc:Cache://SERVER_NAME:SERVER_PORT/DB_NAME\n+</programlisting>\n+      </example>\n+      <section id=\"dbsupport_intersystems_cache_issues\">\n+        <title>Known issues with InterSystems Cache</title>\n+        <para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+          Support for Cache is done via SQL access over JDBC, not\n+          through their object database APIs.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+        </para>\n+      </section>\n+    </section>\n+    <section id=\"dbsupport_access\">\n+      <title>Microsoft Access</title>\n+      <example id=\"example_props_access\">\n+        <title>Example properties for Microsoft Access</title>\n+        <programlisting format=\"linespecific\">\n+openjpa.ConnectionDriverName: com.ddtek.jdbc.sequelink.SequeLinkDriver\n+openjpa.ConnectionURL: jdbc:sequelink://SERVER_NAME:SERVER_PORT\n+</programlisting>\n+      </example>\n+      <section id=\"dbsupport_access_issues\">\n+        <title>Known issues with Microsoft Access</title>\n+        <para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>Using the Sun JDBC-ODBC bridge to connect\n+      is not supported.</para>\n+            </listitem>\n+          </itemizedlist>\n+        </para>\n+      </section>\n+    </section>\n+    <section id=\"dbsupport_sqlserver\">\n+      <title>Microsoft SQL Server</title>\n+      <example id=\"example_props_sqlserver\">\n+        <title>Example properties for Microsoft SQLServer</title>\n+        <programlisting format=\"linespecific\">\n+openjpa.ConnectionDriverName: com.microsoft.sqlserver.jdbc.SQLServerDriver\n+openjpa.ConnectionURL: \\\n+    jdbc:sqlserver://SERVER_NAME:1433;DatabaseName=DB_NAME;selectMethod=cursor;sendStringParametersAsUnicode=false\n+</programlisting>\n+      </example>\n+      <section id=\"dbsupport_sqlserver_issues\">\n+        <title>Known issues with SQL Server</title>\n+        <para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+            SQL Server date fields are accurate only to the\n+            nearest 3 milliseconds, possibly resulting in\n+            precision loss in stored dates.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            The ConnectionURL must always contain the\n+            \"<literal>selectMethod=cursor</literal>\" string.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            Adding <literal>sendStringParametersAsUnicode=false\n+            </literal> to the ConnectionURL may significantly \n+            increase performance.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            The Microsoft SQL Server driver only emulates\n+            batch updates. The DataDirect JDBC driver has\n+            true support for batch updates, and may result\n+            in a significant performance gain.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            Floats and doubles may lose precision when stored.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para><literal>TEXT</literal> columns cannot be used\n+            in queries.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+        </para>\n+      </section>\n+    </section>\n+    <section id=\"dbsupport_foxpro\">\n+      <title>Microsoft FoxPro</title>\n+      <example id=\"example_props_foxpro\">\n+        <title>Example properties for Microsoft FoxPro</title>\n+        <programlisting format=\"linespecific\">\n+openjpa.ConnectionDriverName: com.ddtek.jdbc.sequelink.SequeLinkDriver\n+openjpa.ConnectionURL: jdbc:sequelink://SERVER_NAME:SERVER_PORT\n+</programlisting>\n+      </example>\n+      <section id=\"dbsupport_foxpro_issues\">\n+        <title>Known issues with Microsoft FoxPro</title>\n+        <para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>Using the Sun JDBC-ODBC bridge to connect\n+      is not supported.</para>\n+            </listitem>\n+          </itemizedlist>\n+        </para>\n+      </section>\n+    </section>\n+    <section id=\"dbsupport_mysql\">\n+      <title>MySQL</title>\n+      <example id=\"example_props_mysql\">\n+        <title>Example properties for MySQL</title>\n+        <programlisting format=\"linespecific\">\n+openjpa.ConnectionDriverName: com.mysql.jdbc.Driver\n+openjpa.ConnectionURL: jdbc:mysql://SERVER_NAME/DB_NAME\n+</programlisting>\n+      </example>\n+      <section id=\"dbsupport_mysql_issues\">\n+        <title>Known issues with MySQL</title>\n+        <para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+            The default table types that MySQL uses do not\n+            support transactions, which will prevent OpenJPA from\n+            being able to roll back transactions. Use the \n+            <literal>InnoDB</literal> table type\n+            for any tables that OpenJPA will access.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            MySQL does not support sub-selects in versions\n+            prior to 4.1, and are disabled by default. Some\n+            operations (such as the <function>isEmpty()</function>\n+            method in a query) will fail due to this. If\n+            you are using MySQL 4.1 or later, you can lift\n+            this restriction by setting the\n+            <literal>SupportsSubselect=true</literal> parameter\n+            of the <link linkend=\"openjpa.jdbc.DBDictionary\">openjpa.jdbc.DBDictionary</link> property.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            Rollback due to database error or optimistic lock\n+            violation is not supported unless the table type\n+            is one of the MySQL transactional types. Explicit\n+            calls to <function>rollback()</function> before a \n+            transaction has been committed, however, are\n+            always supported.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            Floats and doubles may lose precision when stored\n+            in some datastores.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            When storing a field of type\n+            <classname>java.math.BigDecimal</classname>, some\n+            datastores will add extraneous trailing 0 \n+            characters, causing an equality mismatch between\n+            the field that is stored and the field that is\n+            retrieved.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            Some version of the MySQL JDBC driver have a bug\n+            that prevents OpenJPA from being able to interrogate\n+            the database for foreign keys. Version\n+            3.0.14 (or higher) of the MySQL driver is required\n+            in order to get around this bug.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+        </para>\n+      </section>\n+    </section>\n+    <section id=\"dbsupport_oracle\">\n+      <title>Oracle</title>\n+      <example id=\"example_props_oracle\">\n+        <title>Example properties for Oracle</title>\n+        <programlisting format=\"linespecific\">\n+openjpa.ConnectionDriverName: oracle.jdbc.driver.OracleDriver\n+openjpa.ConnectionURL: jdbc:oracle:thin:@SERVER_NAME:1521:DB_NAME\n+</programlisting>\n+      </example>\n+      <section id=\"dbsupport_oracle_query_hints\">\n+        <title>Using Query Hints with Oracle</title>\n+        <para>\n+      Oracle has support for \"query hints\", which are formatted\n+      comments embedded in SQL that provide some hint for\n+      how the query should be executed. These hints are usually\n+      designed to provide suggestions to the Oracle query\n+      optimizer for how to efficiently perform a certainly query,\n+      and aren't typically needed for any but the most intensive\n+      queries.\n+      </para>\n+        <example id=\"dbsupport_oracle_query_hints_ex\">\n+          <title>Using Oracle Hints</title>\n+          <programlisting format=\"linespecific\">\n+Query query = pm.createQuery (...);\n+query.addExtension (org.apache.openjpa.jdbc.sql.OracleDictionary.SELECT_HINT,\n+    \"/*+ first_rows(100) */\");\n+List results = (List) query.execute ();\n+</programlisting>\n+          <programlisting format=\"linespecific\">\n+Query query = em.createQuery (...);\n+query.setHint (org.apache.openjpa.jdbc.sql.OracleDictionary.SELECT_HINT,\n+    \"/*+ first_rows(100) */\");\n+List results = query.getResultList ();\n+</programlisting>\n+        </example>\n+      </section>\n+      <section id=\"dbsupport_oracle_issues\">\n+        <title>Known issues with Oracle</title>\n+        <para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+            The Oracle JDBC driver has significant differences\n+            between different versions. It is important to\n+            use the officially supported version of the driver\n+            (10.2.0.1.0), which is backward compatible\n+            with previous versions of the Oracle server.\n+            It can be downloaded from \n+            <ulink url=\"http://www.oracle.com/technology/software/tech/java/sqlj_jdbc/htdocs/jdbc101040.html\">http://www.oracle.com/technology/software/tech/java/sqlj_jdbc/htdocs/jdbc101040.html</ulink>.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            For VARCHAR fields, <literal>null</literal>\n+            and a blank string are equivalent. This means that\n+            an object that stores a null string field will\n+            have it get read back as a blank string.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            Oracle corp's JDBC driver for Oracle has only limited\n+            support for batch updates. The result for OpenJPA is\n+            that in some cases, the exact object that failed an\n+            optimistic lock check cannot be determined, and OpenJPA\n+            will throw an <classname>OptimisticVerificationException</classname> with\n+            more failed objects than actually failed.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            Oracle cannot store numbers with more than 38 digits\n+            in numeric columns.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            Floats and doubles may lose precision when stored.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            CLOB columns cannot be used in queries.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+        </para>\n+      </section>\n+    </section>\n+    <section id=\"dbsupport_pointbase\">\n+      <title>Pointbase</title>\n+      <example id=\"example_props_pointbase\">\n+        <title>Example properties for Pointbase</title>\n+        <programlisting format=\"linespecific\">\n+openjpa.ConnectionDriverName: com.pointbase.jdbc.jdbcUniversalDriver\n+openjpa.ConnectionURL: \\\n+    jdbc:pointbase:DB_NAME,database.home=pointbasedb,create=true,cache.size=10000,database.pagesize=30720\n+</programlisting>\n+      </example>\n+      <section id=\"dbsupport_pointbase_issues\">\n+        <title>Known issues with Pointbase</title>\n+        <para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+      Fields of type BLOB and CLOB are limited to 1M. This number can be \n+      increased by extending <classname>PointbaseDictionary</classname>.\n+      </para>\n+            </listitem>\n+          </itemizedlist>\n+        </para>\n+      </section>\n+    </section>\n+    <section id=\"dbsupport_postgresql\">\n+      <title>PostgreSQL</title>\n+      <example id=\"example_props_postgresql\">\n+        <title>Example properties for PostgreSQL</title>\n+        <programlisting format=\"linespecific\">\n+openjpa.ConnectionDriverName: org.postgresql.Driver\n+openjpa.ConnectionURL: jdbc:postgresql://SERVER_NAME:5432/DB_NAME\n+</programlisting>\n+      </example>\n+      <section id=\"dbsupport_postgresql_issues\">\n+        <title>Known issues with PostgreSQL</title>\n+        <para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+            Floats and doubles may lose precision when stored.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            PostgreSQL cannot store very low and very high dates.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            Empty string/char values are stored as NULL.\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+        </para>\n+      </section>\n+    </section>\n+    <section id=\"dbsupport_sybase\">\n+      <title>Sybase Adaptive Server</title>\n+      <example id=\"example_props_sybase\">\n+        <title>Example properties for Sybase</title>\n+        <programlisting format=\"linespecific\">\n+openjpa.ConnectionDriverName: com.sybase.jdbc2.jdbc.SybDriver\n+openjpa.ConnectionURL: \\\n+    jdbc:sybase:Tds:SERVER_NAME:4100/DB_NAME?ServiceName=DB_NAME&amp;BE_AS_JDBC_COMPLIANT_AS_POSSIBLE=true\n+</programlisting>\n+      </example>\n+      <section id=\"dbsupport_sybase_issues\">\n+        <title>Known issues with Sybase</title>\n+        <para>\n+          <itemizedlist>\n+            <listitem>\n+              <para>\n+            The \"<literal>DYNAMIC_PREPARE</literal>\" parameter\n+            of the Sybase JDBC driver cannot be used with OpenJPA.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            Datastore locking cannot be used when manipulating\n+            many-to-many relations using the default OpenJPA\n+            schema created by the schematool,\n+            unless an auto-increment primary key field is\n+            manually added to the table.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            Persisting a zero-length string results in a\n+            string with a single space characted being returned\n+            from Sybase, Inc.'s JDBC driver.\n+          </para>\n+            </listitem>\n+            <listitem>\n+              <para>\n+            The <literal>BE_AS_JDBC_COMPLIANT_AS_POSSIBLE</literal>\n+            is required in order to use datastore (pessimistic)\n+            locking. Failure to set this property may lead\n+            to obscure errors like \"<literal>FOR UPDATE can\n+            not be used in a SELECT which is not part of\n+            the declaration of a cursor or which is not\n+            inside a stored procedure.</literal>\".\n+          </para>\n+            </listitem>\n+          </itemizedlist>\n+        </para>\n+      </section>\n+    </section>\n+  </appendix>"}]}

