{"sha":"aecff50b27d17904a7b9cb6de00df032f01425dd","node_id":"MDY6Q29tbWl0MjA2MzY0OmFlY2ZmNTBiMjdkMTc5MDRhN2I5Y2I2ZGUwMGRmMDMyZjAxNDI1ZGQ=","commit":{"author":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-12-21T17:08:38Z"},"committer":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-12-21T17:08:38Z"},"message":"Stop enhancing entity identity classes to make non-public properties public for\naccess by the various identity object manipulation methods of the enhanced \nentity class.  This caused problems with runtime enhancement if the identity \nclass was loaded before the entity class.  Instead, rely on reflection to \naccess non-public identity class members.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@489408 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"3f7b3e23b477447486c5c5d1b3b4991716340580","url":"https://api.github.com/repos/apache/openjpa/git/trees/3f7b3e23b477447486c5c5d1b3b4991716340580"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/aecff50b27d17904a7b9cb6de00df032f01425dd","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/aecff50b27d17904a7b9cb6de00df032f01425dd","html_url":"https://github.com/apache/openjpa/commit/aecff50b27d17904a7b9cb6de00df032f01425dd","comments_url":"https://api.github.com/repos/apache/openjpa/commits/aecff50b27d17904a7b9cb6de00df032f01425dd/comments","author":null,"committer":null,"parents":[{"sha":"fee371db063db7e4eb1172603b4bd0b07a115c1d","url":"https://api.github.com/repos/apache/openjpa/commits/fee371db063db7e4eb1172603b4bd0b07a115c1d","html_url":"https://github.com/apache/openjpa/commit/fee371db063db7e4eb1172603b4bd0b07a115c1d"}],"stats":{"total":1332,"additions":821,"deletions":511},"files":[{"sha":"2c4446b47822ff0aac6b5ac6a4e25614e42638c6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","status":"modified","additions":118,"deletions":158,"changes":276,"blob_url":"https://github.com/apache/openjpa/blob/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","raw_url":"https://github.com/apache/openjpa/raw/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java?ref=aecff50b27d17904a7b9cb6de00df032f01425dd","patch":"@@ -101,7 +101,6 @@\n     public static final int ENHANCE_AWARE = 2 << 0;\n     public static final int ENHANCE_INTERFACE = 2 << 1;\n     public static final int ENHANCE_PC = 2 << 2;\n-    public static final int ENHANCE_OID = 2 << 3;\n \n     private static final String PRE = \"pc\";\n     private static final Class PCTYPE = PersistenceCapable.class;\n@@ -205,14 +204,6 @@ public BCClass getBytecode() {\n         return _pc;\n     }\n \n-    /**\n-     * Return the bytecode representations of any oid classes that must be\n-     * manipulated.\n-     */\n-    public Collection getObjectIdBytecode() {\n-        return (_oids == null) ? Collections.EMPTY_LIST : _oids;\n-    }\n-\n     /**\n      * Return the metadata for the class being manipulated, or null if not\n      * a persistent type.\n@@ -311,8 +302,6 @@ public int run() {\n                 if (interfaces[i].getName().equals(PCTYPE.getName())) {\n                     if (_log.isTraceEnabled())\n                         _log.trace(_loc.get(\"pc-type\", _pc.getType()));\n-                    if (_meta != null && enhanceObjectId())\n-                        return ENHANCE_OID;\n                     return ENHANCE_NONE;\n                 }\n             }\n@@ -335,8 +324,6 @@ public int run() {\n                 addAttachDetachCode();\n                 addSerializationCode();\n                 addCloningCode();\n-                if (enhanceObjectId())\n-                    ret |= ENHANCE_OID;\n                 runAuxiliaryEnhancers();\n                 return ret;\n             }\n@@ -1535,14 +1522,43 @@ private void addCopyKeyFieldsToObjectIdMethod(boolean fieldManager)\n         FieldMetaData[] fmds = _meta.getDeclaredFields();\n         Class type;\n         String name;\n+        Field field;\n+        Method setter;\n+        boolean reflect;\n         for (int i = 0; i < fmds.length; i++) {\n             if (!fmds[i].isPrimaryKey())\n                 continue;\n+            code.aload().setLocal(id);\n \n             name = fmds[i].getName();\n             type = fmds[i].getObjectIdFieldType();\n+            if (_meta.getAccessType() == ClassMetaData.ACCESS_FIELD) {\n+                setter = null;\n+                field = Reflection.findField(oidType, name, true);\n+                reflect = !Modifier.isPublic(field.getModifiers());\n+                if (reflect) {\n+                    code.constant().setValue(oidType);\n+                    code.constant().setValue(name);\n+                    code.constant().setValue(true);\n+                    code.invokestatic().setMethod(Reflection.class, \n+                        \"findField\", Field.class, new Class[] { Class.class,\n+                        String.class, boolean.class });\n+                }\n+            } else {\n+                field = null;\n+                setter = Reflection.findSetter(oidType, name, type, true);\n+                reflect = !Modifier.isPublic(setter.getModifiers());\n+                if (reflect) {\n+                    code.constant().setValue(oidType);\n+                    code.constant().setValue(name);\n+                    setClassConstant(code, type);\n+                    code.constant().setValue(true);\n+                    code.invokestatic().setMethod(Reflection.class, \n+                        \"findSetter\", Method.class, new Class[] { Class.class,\n+                        String.class, Class.class, boolean.class });\n+                }\n+            }\n \n-            code.aload().setLocal(id);\n             if (fieldManager) {\n                 code.aload().setParam(0);\n                 code.constant().setValue(i);\n@@ -1554,7 +1570,7 @@ private void addCopyKeyFieldsToObjectIdMethod(boolean fieldManager)\n                 // if the type of this field meta data is\n                 // non-primitive and non-string, be sure to cast\n                 // to the appropriate type.\n-                if (!type.isPrimitive()\n+                if (!reflect && !type.isPrimitive()\n                     && !type.getName().equals(String.class.getName()))\n                     code.checkcast().setType(type);\n             } else {\n@@ -1566,19 +1582,49 @@ private void addCopyKeyFieldsToObjectIdMethod(boolean fieldManager)\n                     addExtractObjectIdFieldValueCode(code, fmds[i]);\n             }\n \n-            if (_meta.getAccessType() == ClassMetaData.ACCESS_FIELD)\n-                code.putfield().setField(findDeclaredField(oidType, name));\n+            if (reflect && field != null) {\n+                code.invokestatic().setMethod(Reflection.class, \"set\", \n+                    void.class, new Class[] { Object.class, Field.class,\n+                    (type.isPrimitive()) ? type : Object.class });\n+            } else if (reflect) { \n+                code.invokestatic().setMethod(Reflection.class, \"set\", \n+                    void.class, new Class[] { Object.class, Method.class,\n+                    (type.isPrimitive()) ? type : Object.class });\n+            } else if (field != null)\n+                code.putfield().setField(field);\n             else\n-                code.invokevirtual().setMethod(findDeclaredMethod\n-                    (oidType, \"set\" + StringUtils.capitalize(name),\n-                        new Class[]{ type }));\n+                code.invokevirtual().setMethod(setter);\n         }\n         code.vreturn();\n \n         code.calculateMaxStack();\n         code.calculateMaxLocals();\n     }\n \n+    /**\n+     * Works around a bug in serp when primitive type constants. \n+     */\n+    private static void setClassConstant(Code code, Class type) {\n+        if (type == boolean.class) \n+            code.getstatic().setField(Boolean.class, \"TYPE\", Class.class);\n+        else if (type == byte.class) \n+            code.getstatic().setField(Byte.class, \"TYPE\", Class.class);\n+        else if (type == char.class) \n+            code.getstatic().setField(Character.class, \"TYPE\", Class.class);\n+        else if (type == double.class) \n+            code.getstatic().setField(Double.class, \"TYPE\", Class.class);\n+        else if (type == float.class) \n+            code.getstatic().setField(Float.class, \"TYPE\", Class.class);\n+        else if (type == int.class) \n+            code.getstatic().setField(Integer.class, \"TYPE\", Class.class);\n+        else if (type == long.class) \n+            code.getstatic().setField(Long.class, \"TYPE\", Class.class);\n+        else if (type == short.class) \n+            code.getstatic().setField(Short.class, \"TYPE\", Class.class);\n+        else\n+            code.constant().setValue(type);\n+    }\n+\n     /**\n      * Add code to extract the id of the given primary key relation field for\n      * setting into an objectid instance.\n@@ -1788,9 +1834,11 @@ private void addCopyKeyFieldsFromObjectIdMethod(boolean fieldManager)\n         // this.<field> = id.<field>\n         // or for single field identity: id.getId ()\n         FieldMetaData[] fmds = _meta.getDeclaredFields();\n+        String name;\n         Class type;\n         Class unwrapped;\n-        String name;\n+        Field field;\n+        Method getter;\n         for (int i = 0; i < fmds.length; i++) {\n             if (!fmds[i].isPrimaryKey())\n                 continue;\n@@ -1840,11 +1888,41 @@ private void addCopyKeyFieldsFromObjectIdMethod(boolean fieldManager)\n                             code.invokespecial().setMethod(type, \"<init>\",\n                                 void.class, new Class[]{ unwrapped });\n                     }\n-                } else if (_meta.getAccessType() == ClassMetaData.ACCESS_FIELD)\n-                    code.getfield().setField(findDeclaredField(oidType, name));\n-                else // property\n-                    code.invokevirtual().setMethod(findDeclaredGetterMethod\n-                        (oidType, StringUtils.capitalize(name)));\n+                } else if (_meta.getAccessType() == ClassMetaData.ACCESS_FIELD){\n+                    field = Reflection.findField(oidType, name, true);\n+                    if (Modifier.isPublic(field.getModifiers()))\n+                        code.getfield().setField(field);\n+                    else {\n+                        // Reflection.getXXX(oid, Reflection.findField(...));\n+                        code.constant().setValue(oidType);\n+                        code.constant().setValue(name);\n+                        code.constant().setValue(true);\n+                        code.invokestatic().setMethod(Reflection.class,\n+                            \"findField\", Field.class, new Class[] { \n+                            Class.class, String.class, boolean.class });\n+                        code.invokestatic().setMethod\n+                            (getReflectionGetterMethod(type, Field.class));\n+                        if (!type.isPrimitive() && type != Object.class)\n+                            code.checkcast().setType(type);\n+                    }\n+                } else {\n+                    getter = Reflection.findGetter(oidType, name, true);\n+                    if (Modifier.isPublic(getter.getModifiers()))\n+                        code.invokevirtual().setMethod(getter);\n+                    else {\n+                        // Reflection.getXXX(oid, Reflection.findGetter(...));\n+                        code.constant().setValue(oidType);\n+                        code.constant().setValue(name);\n+                        code.constant().setValue(true);\n+                        code.invokestatic().setMethod(Reflection.class,\n+                            \"findGetter\", Method.class, new Class[] { \n+                            Class.class, String.class, boolean.class });\n+                        code.invokestatic().setMethod\n+                            (getReflectionGetterMethod(type, Method.class));\n+                        if (!type.isPrimitive() && type != Object.class)\n+                            code.checkcast().setType(type);\n+                    }\n+                }\n             }\n \n             if (fieldManager)\n@@ -1910,6 +1988,19 @@ private Class unwrapSingleFieldIdentity(FieldMetaData fmd) {\n         }\n     }\n \n+    /**\n+     * Return the proper getter method of the {@link Reflection} helper for\n+     * a field or getter method of the given type.\n+     */\n+    private Method getReflectionGetterMethod(Class type, Class argType)\n+        throws NoSuchMethodException {\n+        String name = \"get\";\n+        if (type.isPrimitive())\n+            name += StringUtils.capitalize(type.getName());\n+        return Reflection.class.getMethod(name, new Class[] { Object.class, \n+            argType }); \n+    }\n+\n     /**\n      * Return the proper fetch method of the ObjectIdFieldSupplier for\n      * a field of the given type.\n@@ -2727,123 +2818,6 @@ private void addCloningCode() {\n         }\n     }\n \n-    /**\n-     * Enhance the PC's object id class.\n-     */\n-    private boolean enhanceObjectId()\n-        throws IOException {\n-        Class cls = _meta.getObjectIdType();\n-        if (cls == null)\n-            return false;\n-\n-        FieldMetaData[] pks = _meta.getPrimaryKeyFields();\n-        int access = _meta.getAccessType();\n-        if (_meta.isOpenJPAIdentity()) {\n-            if (pks[0].getDeclaredTypeCode() != JavaTypes.OID)\n-                return false;\n-            cls = pks[0].getDeclaredType();\n-            access = pks[0].getEmbeddedMetaData().getAccessType();\n-            pks = pks[0].getEmbeddedMetaData().getFields();\n-        }\n-\n-        String cap;\n-        for (int i = 0; i < pks.length; i++) {\n-            if (access == ClassMetaData.ACCESS_FIELD)\n-                makeObjectIdFieldPublic(findDeclaredField(cls,\n-                    pks[i].getName()));\n-            else // property\n-            {\n-                cap = StringUtils.capitalize(pks[i].getName());\n-                makeObjectIdMethodPublic(findDeclaredGetterMethod(cls, cap));\n-                makeObjectIdMethodPublic(findDeclaredMethod(cls, \"set\" + cap,\n-                    new Class[]{ pks[i].getDeclaredType() }));\n-            }\n-        }\n-        return _oids != null;\n-    }\n-\n-    /**\n-     * Find the given (possibly private) field.\n-     */\n-    private Field findDeclaredField(Class cls, String name) {\n-        if (cls == null || cls == Object.class)\n-            return null;\n-\n-        try {\n-            return cls.getDeclaredField(name);\n-        } catch (NoSuchFieldException nsfe) {\n-            return findDeclaredField(cls.getSuperclass(), name);\n-        } catch (Exception e) {\n-            throw new GeneralException(e);\n-        }\n-    }\n-\n-    /**\n-     * Return the getter method for the given capitalized property name.\n-     */\n-    private Method findDeclaredGetterMethod(Class cls, String baseName) {\n-        Method meth = findDeclaredMethod(cls, \"get\" + baseName, null);\n-        if (meth != null)\n-            return meth;\n-        return findDeclaredMethod(_meta.getObjectIdType(), \"is\" + baseName,\n-            null);\n-    }\n-\n-    /**\n-     * Find the given (possibly private) method.\n-     */\n-    private Method findDeclaredMethod(Class cls, String name, Class[] params) {\n-        if (cls == null || cls == Object.class)\n-            return null;\n-\n-        try {\n-            return cls.getDeclaredMethod(name, params);\n-        } catch (NoSuchMethodException nsme) {\n-            return findDeclaredMethod(cls.getSuperclass(), name, params);\n-        } catch (Exception e) {\n-            throw new GeneralException(e);\n-        }\n-    }\n-\n-    /**\n-     * Ensure that the given oid field is public.\n-     */\n-    private void makeObjectIdFieldPublic(Field field) {\n-        if (Modifier.isPublic(field.getModifiers()))\n-            return;\n-\n-        BCClass bc = getObjectIdBytecode(field.getDeclaringClass());\n-        bc.getDeclaredField(field.getName()).makePublic();\n-    }\n-\n-    /**\n-     * Ensure that the given oid method is public.\n-     */\n-    private void makeObjectIdMethodPublic(Method meth) {\n-        if (Modifier.isPublic(meth.getModifiers()))\n-            return;\n-\n-        BCClass bc = getObjectIdBytecode(meth.getDeclaringClass());\n-        bc.getDeclaredMethod(meth.getName(), meth.getParameterTypes()).\n-            makePublic();\n-    }\n-\n-    /**\n-     * Return the bytecode for the given oid class, creating and caching it\n-     * if necessary.\n-     */\n-    private BCClass getObjectIdBytecode(Class cls) {\n-        BCClass bc = _pc.getProject().loadClass(cls);\n-        if (_oids == null)\n-            _oids = new ArrayList(3);\n-        if (!_oids.contains(bc)) {\n-            if (_log.isTraceEnabled())\n-                _log.trace(_loc.get(\"enhance-oid\", bc.getName()));\n-            _oids.add(bc);\n-        }\n-        return bc;\n-    }\n-\n     /**\n      * Gets the auxiliary enhancers registered as {@link Services services}.\n      */\n@@ -3716,22 +3690,8 @@ else if (status == ENHANCE_INTERFACE)\n             else if (status == ENHANCE_AWARE) {\n                 log.info(_loc.get(\"enhance-aware\"));\n                 enhancer.record();\n-            } else {\n+            } else\n                 enhancer.record();\n-                if ((status & ENHANCE_OID) != 0) {\n-                    if (log.isInfoEnabled()) {\n-                        Collection oids = enhancer.getObjectIdBytecode();\n-                        StringBuffer buf = new StringBuffer();\n-                        for (Iterator oiditr = oids.iterator();\n-                            oiditr.hasNext();) {\n-                            buf.append(((BCClass) oiditr.next()).getName());\n-                            if (oiditr.hasNext())\n-                                buf.append(\", \");\n-                        }\n-                        log.info(_loc.get(\"enhance-running-oids\", buf));\n-                    }\n-                }\n-            }\n             project.clear();\n         }\n         return true;"},{"sha":"c62e402aaab150b06d21a48f28eca4180216c521","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","status":"modified","additions":9,"deletions":7,"changes":16,"blob_url":"https://github.com/apache/openjpa/blob/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java?ref=aecff50b27d17904a7b9cb6de00df032f01425dd","patch":"@@ -21,8 +21,10 @@\n import java.util.LinkedList;\n import java.util.Map;\n \n+import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.lib.util.ReferenceMap;\n import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n+import org.apache.openjpa.util.UserException;\n \n /**\n  * Tracks registered persistence-capable classes.\n@@ -33,14 +35,13 @@\n public class PCRegistry {\n     // DO NOT ADD ADDITIONAL DEPENDENCIES TO THIS CLASS\n \n-    // intentionally left unlocalized to minimize dependencies\n-    private static final String COPY_NO_ID = \"Cannot copy identity for \"\n-        + \"abstract class \";\n-    private static final String NO_META = \"No metadata found for class \";\n+    private static final Localizer _loc = Localizer.forPackage\n+        (PCRegistry.class);\n \n     // map of pc classes to meta structs; weak so the VM can GC classes\n     private static final Map _metas = new ConcurrentReferenceHashMap\n         (ReferenceMap.WEAK, ReferenceMap.HARD);\n+\n     // register class listeners\n     private static final Collection _listeners = new LinkedList();\n \n@@ -151,7 +152,7 @@ public static void copyKeyFieldsToObjectId(Class pcClass, FieldSupplier fm,\n         Object oid) {\n         Meta meta = getMeta(pcClass);\n         if (meta.pc == null)\n-            throw new IllegalStateException(COPY_NO_ID + pcClass.getName());\n+            throw new UserException(_loc.get(\"copy-no-id\", pcClass));\n \n         meta.pc.pcCopyKeyFieldsToObjectId(fm, oid);\n     }\n@@ -164,7 +165,7 @@ public static void copyKeyFieldsFromObjectId(Class pcClass,\n         FieldConsumer fm, Object oid) {\n         Meta meta = getMeta(pcClass);\n         if (meta.pc == null)\n-            throw new IllegalStateException(COPY_NO_ID + pcClass.getName());\n+            throw new UserException(_loc.get(\"copy-no-id\", pcClass));\n \n         meta.pc.pcCopyKeyFieldsFromObjectId(fm, oid);\n     }\n@@ -219,7 +220,8 @@ public static boolean isRegistered(Class cls) {\n     private static Meta getMeta(Class pcClass) {\n         Meta ret = (Meta) _metas.get(pcClass);\n         if (ret == null)\n-            throw new IllegalStateException(NO_META + pcClass.getName());\n+            throw new IllegalStateException(_loc.get(\"no-meta\", pcClass).\n+                getMessage());\n         return ret;\n     }\n "},{"sha":"c038f74c96ae43024f26750282bc7f08c35a8601","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/Reflection.java","status":"added","additions":537,"deletions":0,"changes":537,"blob_url":"https://github.com/apache/openjpa/blob/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/Reflection.java","raw_url":"https://github.com/apache/openjpa/raw/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/Reflection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/Reflection.java?ref=aecff50b27d17904a7b9cb6de00df032f01425dd","patch":"@@ -0,0 +1,537 @@\n+package org.apache.openjpa.enhance;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.GeneralException; \n+import org.apache.openjpa.util.UserException; \n+\n+/**\n+ * Reflection utilities used to support and augment enhancement.  Used both\n+ * at enhancement time and at runtime.\n+ *\n+ * @author Abe White\n+ */\n+public class Reflection {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (Reflection.class);\n+\n+    /**\n+     * Return the getter method matching the given property name, optionally\n+     * throwing an exception if none.\n+     */\n+    public static Method findGetter(Class cls, String prop, boolean mustExist) {\n+        prop = StringUtils.capitalize(prop);\n+        String name = \"get\" + prop;\n+        try {\n+            for (Class c = cls; c != null && c != Object.class; \n+                c = c.getSuperclass()) {\n+                try {\n+                    return c.getDeclaredMethod(name, (Class[]) null);\n+                } catch (NoSuchMethodException nsme) {\n+                    try {\n+                        Method m = c.getDeclaredMethod(\"is\" + prop, \n+                            (Class[]) null);\n+                        if (m != null && (m.getReturnType() == boolean.class\n+                            || m.getReturnType() == Boolean.class))\n+                            return m;\n+                    } catch (NoSuchMethodException nsme2) {\n+                    }\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new GeneralException(e);\n+        }\n+\n+        if (mustExist)\n+            throw new UserException(_loc.get(\"bad-getter\", cls, prop));\n+        return null;\n+    }\n+\n+    /**\n+     * Return the setter method matching the given property name, optionally\n+     * throwing an exception if none.  The property must also have a getter.\n+     */\n+    public static Method findSetter(Class cls, String prop, boolean mustExist) {\n+        Method getter = findGetter(cls, prop, mustExist);\n+        return (getter == null) ? null \n+            : findSetter(cls, prop, getter.getReturnType(), mustExist);\n+    }\n+\n+    /**\n+     * Return the setter method matching the given property name, optionally\n+     * throwing an exception if none.\n+     */\n+    public static Method findSetter(Class cls, String prop, Class param,\n+        boolean mustExist) {\n+        String name = \"set\" + StringUtils.capitalize(prop);\n+        Class[] params = new Class[] { param };\n+        try {\n+            for (Class c = cls; c != null && c != Object.class; \n+                c = c.getSuperclass()) {\n+                try {\n+                    return c.getDeclaredMethod(name, params);\n+                } catch (NoSuchMethodException nsme) {\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new GeneralException(e);\n+        }\n+\n+        if (mustExist)\n+            throw new UserException(_loc.get(\"bad-setter\", cls, prop));\n+        return null;\n+    }\n+\n+    /**\n+     * Return the field with the given name, optionally throwing an exception \n+     * if none.\n+     */\n+    public static Field findField(Class cls, String name, boolean mustExist) {\n+        try {\n+            for (Class c = cls; c != null && c != Object.class; \n+                c = c.getSuperclass()) {\n+                try {\n+                    return c.getDeclaredField(name);\n+                } catch (NoSuchFieldException nsfe) {\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new GeneralException(e);\n+        }\n+\n+        if (mustExist)\n+            throw new UserException(_loc.get(\"bad-field\", cls, name));\n+        return null;\n+    }\n+\n+    /**\n+     * Return the value of the given field in the given object.\n+     */\n+    public static Object get(Object target, Field field) {\n+        if (target == null || field == null)\n+            return null;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            return field.get(target);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Make the given member accessible if it isn't already.\n+     */\n+    private static void makeAccessible(AccessibleObject ao, int mods) {\n+        try {\n+            if (!Modifier.isPublic(mods) && !ao.isAccessible())\n+                ao.setAccessible(true);\n+        } catch (SecurityException se) {\n+            throw new UserException(_loc.get(\"reflect-security\", ao)).\n+                setFatal(true);\n+        }\n+    }\n+\n+    /**\n+     * Wrap the given reflection exception as a runtime exception.\n+     */\n+    private static RuntimeException wrapReflectionException(Throwable t) {\n+        if (t instanceof InvocationTargetException)\n+            t = ((InvocationTargetException) t).getTargetException();    \n+        if (t instanceof RuntimeException)\n+            return (RuntimeException) t;\n+        return new GeneralException(t);\n+    }\n+\n+    /**\n+     * Return the value of the given field in the given object.\n+     */\n+    public static boolean getBoolean(Object target, Field field) {\n+        if (target == null || field == null)\n+            return false;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            return field.getBoolean(target);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Return the value of the given field in the given object.\n+     */\n+    public static byte getByte(Object target, Field field) {\n+        if (target == null || field == null)\n+            return (byte) 0;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            return field.getByte(target);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Return the value of the given field in the given object.\n+     */\n+    public static char getChar(Object target, Field field) {\n+        if (target == null || field == null)\n+            return (char) 0;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            return field.getChar(target);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Return the value of the given field in the given object.\n+     */\n+    public static double getDouble(Object target, Field field) {\n+        if (target == null || field == null)\n+            return 0D;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            return field.getDouble(target);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Return the value of the given field in the given object.\n+     */\n+    public static float getFloat(Object target, Field field) {\n+        if (target == null || field == null)\n+            return 0F;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            return field.getFloat(target);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Return the value of the given field in the given object.\n+     */\n+    public static int getInt(Object target, Field field) {\n+        if (target == null || field == null)\n+            return 0;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            return field.getInt(target);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Return the value of the given field in the given object.\n+     */\n+    public static long getLong(Object target, Field field) {\n+        if (target == null || field == null)\n+            return 0L;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            return field.getLong(target);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Return the value of the given field in the given object.\n+     */\n+    public static short getShort(Object target, Field field) {\n+        if (target == null || field == null)\n+            return (short) 0;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            return field.getShort(target);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Return the return value of the given getter in the given object.\n+     */\n+    public static Object get(Object target, Method getter) {\n+        if (target == null || getter == null)\n+            return null;\n+        makeAccessible(getter, getter.getModifiers());\n+        try {\n+            return getter.invoke(target, (Object[]) null);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Return the return value of the given getter in the given object.\n+     */\n+    public static boolean getBoolean(Object target, Method getter) {\n+        Object o = get(target, getter);\n+        return (o == null) ? false : ((Boolean) o).booleanValue();\n+    }\n+\n+    /**\n+     * Return the return value of the given getter in the given object.\n+     */\n+    public static byte getByte(Object target, Method getter) {\n+        Object o = get(target, getter);\n+        return (o == null) ? (byte) 0 : ((Number) o).byteValue();\n+    }\n+\n+    /**\n+     * Return the return value of the given getter in the given object.\n+     */\n+    public static char getChar(Object target, Method getter) {\n+        Object o = get(target, getter);\n+        return (o == null) ? (char) 0 : ((Character) o).charValue();\n+    }\n+\n+    /**\n+     * Return the return value of the given getter in the given object.\n+     */\n+    public static double getDouble(Object target, Method getter) {\n+        Object o = get(target, getter);\n+        return (o == null) ? 0D : ((Number) o).doubleValue();\n+    }\n+\n+    /**\n+     * Return the return value of the given getter in the given object.\n+     */\n+    public static float getFloat(Object target, Method getter) {\n+        Object o = get(target, getter);\n+        return (o == null) ? 0F : ((Number) o).floatValue();\n+    }\n+\n+    /**\n+     * Return the return value of the given getter in the given object.\n+     */\n+    public static int getInt(Object target, Method getter) {\n+        Object o = get(target, getter);\n+        return (o == null) ? 0 : ((Number) o).intValue();\n+    }\n+\n+    /**\n+     * Return the return value of the given getter in the given object.\n+     */\n+    public static long getLong(Object target, Method getter) {\n+        Object o = get(target, getter);\n+        return (o == null) ? 0L : ((Number) o).longValue();\n+    }\n+\n+    /**\n+     * Return the return value of the given getter in the given object.\n+     */\n+    public static short getShort(Object target, Method getter) {\n+        Object o = get(target, getter);\n+        return (o == null) ? (short) 0 : ((Number) o).shortValue();\n+    }\n+\n+    /**\n+     * Set the value of the given field in the given object.\n+     */\n+    public static void set(Object target, Field field, Object value) {\n+        if (target == null || field == null)\n+            return;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            field.set(target, value);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Set the value of the given field in the given object.\n+     */\n+    public static void set(Object target, Field field, boolean value) {\n+        if (target == null || field == null)\n+            return;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            field.setBoolean(target, value);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Set the value of the given field in the given object.\n+     */\n+    public static void set(Object target, Field field, byte value) {\n+        if (target == null || field == null)\n+            return;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            field.setByte(target, value);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Set the value of the given field in the given object.\n+     */\n+    public static void set(Object target, Field field, char value) {\n+        if (target == null || field == null)\n+            return;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            field.setChar(target, value);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Set the value of the given field in the given object.\n+     */\n+    public static void set(Object target, Field field, double value) {\n+        if (target == null || field == null)\n+            return;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            field.setDouble(target, value);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Set the value of the given field in the given object.\n+     */\n+    public static void set(Object target, Field field, float value) {\n+        if (target == null || field == null)\n+            return;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            field.setFloat(target, value);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Set the value of the given field in the given object.\n+     */\n+    public static void set(Object target, Field field, int value) {\n+        if (target == null || field == null)\n+            return;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            field.setInt(target, value);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Set the value of the given field in the given object.\n+     */\n+    public static void set(Object target, Field field, long value) {\n+        if (target == null || field == null)\n+            return;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            field.setLong(target, value);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Set the value of the given field in the given object.\n+     */\n+    public static void set(Object target, Field field, short value) {\n+        if (target == null || field == null)\n+            return;\n+        makeAccessible(field, field.getModifiers());\n+        try {\n+            field.setShort(target, value);\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Invoke the given setter on the given object.\n+     */\n+    public static void set(Object target, Method setter, Object value) {\n+        if (target == null || setter == null)\n+            return;\n+        makeAccessible(setter, setter.getModifiers());\n+        try {\n+            setter.invoke(target, new Object[] { value });\n+        } catch (Throwable t) {\n+            throw wrapReflectionException(t);\n+        }\n+    }\n+\n+    /**\n+     * Invoke the given setter on the given object.\n+     */\n+    public static void set(Object target, Method setter, boolean value) {\n+        set(target, setter, (value) ? Boolean.TRUE : Boolean.FALSE);\n+    }\n+\n+    /**\n+     * Invoke the given setter on the given object.\n+     */\n+    public static void set(Object target, Method setter, byte value) {\n+        set(target, setter, new Byte(value));\n+    }\n+\n+    /**\n+     * Invoke the given setter on the given object.\n+     */\n+    public static void set(Object target, Method setter, char value) {\n+        set(target, setter, new Character(value));\n+    }\n+\n+    /**\n+     * Invoke the given setter on the given object.\n+     */\n+    public static void set(Object target, Method setter, double value) {\n+        set(target, setter, new Double(value));\n+    }\n+\n+    /**\n+     * Invoke the given setter on the given object.\n+     */\n+    public static void set(Object target, Method setter, float value) {\n+        set(target, setter, new Float(value));\n+    }\n+\n+    /**\n+     * Invoke the given setter on the given object.\n+     */\n+    public static void set(Object target, Method setter, int value) {\n+        set(target, setter, new Integer(value));\n+    }\n+\n+    /**\n+     * Invoke the given setter on the given object.\n+     */\n+    public static void set(Object target, Method setter, long value) {\n+        set(target, setter, new Long(value));\n+    }\n+\n+    /**\n+     * Invoke the given setter on the given object.\n+     */\n+    public static void set(Object target, Method setter, short value) {\n+        set(target, setter, new Short(value));\n+    }\n+}"},{"sha":"4afadcb7dc44f2953dedf9f315b2cf8d81826256","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","status":"modified","additions":16,"deletions":24,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","raw_url":"https://github.com/apache/openjpa/raw/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java?ref=aecff50b27d17904a7b9cb6de00df032f01425dd","patch":"@@ -25,6 +25,7 @@\n import java.util.Date;\n import java.util.List;\n \n+import org.apache.openjpa.enhance.Reflection;\n import org.apache.openjpa.kernel.exps.AggregateListener;\n import org.apache.openjpa.kernel.exps.FilterListener;\n import org.apache.openjpa.lib.util.Localizer;\n@@ -854,16 +855,8 @@ public static Object hintToGetter(Object target, String hintKey) {\n         if (target == null || hintKey == null)\n             return null;\n \n-        Method getter = ImplHelper.getGetter(target.getClass(), hintKey);\n-        try {\n-            return getter.invoke(target, (Object[]) null);\n-        } catch (Exception e) {\n-            Throwable t = e;\n-            if (e instanceof InvocationTargetException)\n-                t = ((InvocationTargetException) e).getTargetException();\n-            throw new UserException(_loc.get(\"bad-getter-hint\",\n-                target.getClass(), hintKey)).setCause(t);\n-        }\n+        Method getter = Reflection.findGetter(target.getClass(), hintKey, true);\n+        return Reflection.get(target, getter);\n     }\n \n     /**\n@@ -874,22 +867,21 @@ public static void hintToSetter(Object target, String hintKey,\n         if (target == null || hintKey == null)\n             return;\n \n-        Method setter = ImplHelper.getSetter(target.getClass(), hintKey);\n-        try {\n-            if (value instanceof String) {\n-                if (\"null\".equals(value))\n-                    value = null;\n-                else\n+        Method setter = Reflection.findSetter(target.getClass(), hintKey, true);\n+        if (value instanceof String) {\n+            if (\"null\".equals(value))\n+                value = null;\n+            else {\n+                try {\n                     value = Strings.parse((String) value,\n                         setter.getParameterTypes()[0]);\n+                } catch (Exception e) {\n+                    throw new UserException(_loc.get(\"bad-setter-hint-arg\",\n+                        hintKey, value, setter.getParameterTypes()[0])).\n+                        setCause(e);\n+                }\n             }\n-            setter.invoke(target, new Object[]{ value });\n-        } catch (Exception e) {\n-            Throwable t = e;\n-            if (e instanceof InvocationTargetException)\n-                t = ((InvocationTargetException) e).getTargetException();\n-            throw new UserException(_loc.get(\"bad-setter-hint\",\n-\t\t\t\ttarget.getClass (), hintKey, value)).setCause (t);\n-\t\t}\n+        }\n+        Reflection.set(target, setter, value);\n \t}\n }"},{"sha":"7231d262de15b014577ae0c41f97bbcbd4641852","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","status":"modified","additions":21,"deletions":37,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java?ref=aecff50b27d17904a7b9cb6de00df032f01425dd","patch":"@@ -24,6 +24,7 @@\n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.enhance.StateManager;\n+import org.apache.openjpa.enhance.Reflection;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n import org.apache.openjpa.meta.JavaTypes;\n@@ -689,30 +690,17 @@ private Object getValue(int field) {\n             return null;\n \n         FieldMetaData fmd = getMetaData().getField(field);\n-        try {\n-            if (fmd.getBackingMember() instanceof Field)\n-                return ((Field) fmd.getBackingMember()).get(_oid);\n-            if (fmd.getBackingMember() instanceof Method)\n-                return ((Method) fmd.getBackingMember()).\n-                    invoke(_oid, (Object[]) null);\n-\n-            if (fmd.getDefiningMetaData().getAccessType()\n-                == ClassMetaData.ACCESS_FIELD)\n-                return _oid.getClass().getField(fmd.getName()).get(_oid);\n-\n-            // property\n-            Method meth;\n-            try {\n-                meth = _oid.getClass().getMethod(\"get\"\n-                    + StringUtils.capitalize(fmd.getName()), (Class[]) null);\n-            } catch (NoSuchMethodException nsme) {\n-                meth = _oid.getClass().getMethod(\"is\"\n-                    + StringUtils.capitalize(fmd.getName()), (Class[]) null);\n-            }\n-            return meth.invoke(_oid, (Object[]) null);\n-        } catch (Exception e) {\n-            throw new GeneralException(e);\n-        }\n+        if (fmd.getBackingMember() instanceof Field)\n+            return Reflection.get(_oid, (Field) fmd.getBackingMember());\n+        if (fmd.getBackingMember() instanceof Method)\n+            return Reflection.get(_oid, (Method) fmd.getBackingMember());\n+\n+        if (fmd.getDefiningMetaData().getAccessType()\n+            == ClassMetaData.ACCESS_FIELD)\n+            return Reflection.get(_oid, Reflection.findField(_oid.getClass(), \n+                fmd.getName(), true));\n+        return Reflection.get(_oid, Reflection.findGetter(_oid.getClass(),\n+            fmd.getName(), true));\n     }\n \n     /**\n@@ -731,18 +719,14 @@ private void setValue(int field, Object val, boolean forceInst) {\n             return;\n \n         FieldMetaData fmd = getMetaData().getField(field);\n-        try {\n-            if (fmd.getBackingMember() instanceof Field)\n-                ((Field) fmd.getBackingMember()).set(_oid, val);\n-            else if (fmd.getDefiningMetaData().getAccessType()\n-                == ClassMetaData.ACCESS_FIELD)\n-                _oid.getClass().getField(fmd.getName()).set(_oid, val);\n-            else // property\n-                _oid.getClass().getMethod(\"set\" + StringUtils.capitalize\n-                    (fmd.getName()), new Class[]{ fmd.getDeclaredType() }).\n-                    invoke(_oid, new Object[]{ val });\n-        } catch (Exception e) {\n-            throw new GeneralException(e);\n-        }\n+        if (fmd.getBackingMember() instanceof Field)\n+            Reflection.set(_oid, (Field) fmd.getBackingMember(), val);\n+        else if (fmd.getDefiningMetaData().getAccessType()\n+            == ClassMetaData.ACCESS_FIELD) {\n+            Reflection.set(_oid, Reflection.findField(_oid.getClass(), \n+                fmd.getName(), true), val);\n+        } else\n+            Reflection.set(_oid, Reflection.findSetter(_oid.getClass(),\n+                fmd.getName(), fmd.getDeclaredType(), true), val);\n \t}\n }"},{"sha":"0323e25b56fad210b61210c2e9ee7a97ffc0abe6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java","status":"modified","additions":1,"deletions":4,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java","raw_url":"https://github.com/apache/openjpa/raw/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java?ref=aecff50b27d17904a7b9cb6de00df032f01425dd","patch":"@@ -285,10 +285,7 @@ private static Member findSet(String alias, Class type, Field[] fields,\n         }\n \n         // check setter methods\n-        String setName = \"set\" + Character.toUpperCase(alias.charAt(0));\n-        if (alias.length() > 1)\n-            setName = setName + alias.substring(1);\n-\n+        String setName = \"set\" + StringUtils.capitalize(alias);\n         Method method = null;\n         boolean eqName = false;\n         Class[] params;"},{"sha":"b2e6d2b6c7cb2550e721e96750c902cc42d48870","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","status":"modified","additions":5,"deletions":42,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/AbstractMetaDataDefaults.java?ref=aecff50b27d17904a7b9cb6de00df032f01425dd","patch":"@@ -22,6 +22,7 @@\n \n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.enhance.PCRegistry;\n+import org.apache.openjpa.enhance.Reflection;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.util.InternalException;\n@@ -183,8 +184,8 @@ private boolean populateFromPCRegistry(ClassMetaData meta) {\n                 if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD)\n                     member = cls.getDeclaredField(fieldNames[i]);\n                 else\n-                    member = getBackingMethod(meta.getDescribedType(),\n-                        fieldNames[i], fieldTypes[i]);\n+                    member = Reflection.findGetter(meta.getDescribedType(),\n+                        fieldNames[i], true);\n                 fmd = meta.addDeclaredField(fieldNames[i], fieldTypes[i]);\n                 fmd.backingMember(member);\n                 populate(fmd);\n@@ -310,53 +311,15 @@ public Member getBackingMember(FieldMetaData fmd) {\n             if (fmd.getDefiningMetaData().getAccessType() ==\n                 ClassMetaData.ACCESS_FIELD)\n                 return fmd.getDeclaringType().getDeclaredField(fmd.getName());\n-            return getBackingMethod(fmd.getDeclaringType(), fmd.getName(),\n-                fmd.getDeclaredType());\n+            return Reflection.findGetter(fmd.getDeclaringType(), fmd.getName(),\n+                true);\n         } catch (OpenJPAException ke) {\n             throw ke;\n         } catch (Exception e) {\n             throw new InternalException(e);\n         }\n     }\n \n-    /**\n-     * Return the method backing the given field metadata. Looks for\n-     * \"get\" and \"is\" methods with no parameters by default. This looks\n-     * for elements defined in <code>cls</code> and its superclasses.\n-     */\n-    private Method getBackingMethod(Class cls, String name,\n-        Class methReturnType)\n-        throws NoSuchMethodException {\n-        String clsName = cls.getName();\n-        String capName = StringUtils.capitalize(name);\n-        boolean isBoolean = methReturnType == boolean.class\n-            || methReturnType == Boolean.class;\n-        do {\n-            try {\n-                return cls.getDeclaredMethod(\"get\" + capName, (Class[]) null);\n-            } catch (NoSuchMethodException e) {\n-            }\n-\n-            if (isBoolean) {\n-                try {\n-                    return cls.getDeclaredMethod(\"is\" + capName,\n-                        (Class[]) null);\n-                } catch (NoSuchMethodException e) {\n-                }\n-            }\n-            // ### EJB3: recursion should be limited to manageable types,\n-            // ### including embeddable and embeddable superclass\n-            cls = cls.getSuperclass();\n-        }\n-        while (cls != null);\n-\n-        if (!isBoolean)\n-            throw new UserException(_loc.get(\"pc-registry-no-method\",\n-                name, clsName, \"get\" + capName));\n-        throw new UserException(_loc.get(\"pc-registry-no-boolean-method\",\n-            new String[]{ name, clsName, \"get\" + capName, \"is\" + capName }));\n-    }\n-\n     public Class getUnimplementedExceptionType() {\n         return UnsupportedOperationException.class;\n     }"},{"sha":"4796d2a3e633eb1eff0268288b9810f6b4e7cd8e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","status":"modified","additions":38,"deletions":87,"changes":125,"blob_url":"https://github.com/apache/openjpa/blob/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java?ref=aecff50b27d17904a7b9cb6de00df032f01425dd","patch":"@@ -36,6 +36,7 @@\n import org.apache.openjpa.datacache.DataCache;\n import org.apache.openjpa.enhance.PCRegistry;\n import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.enhance.Reflection;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.meta.SourceTracker;\n import org.apache.openjpa.lib.util.Localizer;\n@@ -1894,95 +1895,45 @@ private void validateAppIdClassPKs(ClassMetaData meta,\n             throw new MetaDataException(_loc.get(\"no-pk\", _type));\n \n         // check that the oid type contains all pk fields\n-        try {\n-            Field f;\n-            Method m;\n-            String cap;\n-            int type;\n-            Class c;\n-            int access = meta.getAccessType();\n-            for (int i = 0; i < fmds.length; i++) {\n-                switch (fmds[i].getDeclaredTypeCode()) {\n-                    case JavaTypes.ARRAY:\n-                        c = fmds[i].getDeclaredType().getComponentType();\n-                        if (c == byte.class || c == Byte.class\n-                            || c == char.class || c == Character.class) {\n-                            c = fmds[i].getDeclaredType();\n-                            break;\n-                        }\n-                        // else no break\n-                    case JavaTypes.PC_UNTYPED:\n-                    case JavaTypes.COLLECTION:\n-                    case JavaTypes.MAP:\n-                    case JavaTypes.OID: // we're validating embedded fields\n-                        throw new MetaDataException(_loc.get(\"bad-pk-type\",\n-                            fmds[i]));\n-                    default:\n-                        c = fmds[i].getObjectIdFieldType();\n-                }\n-\n-                if (access == ACCESS_FIELD) {\n-                    f = findField(oid, fmds[i].getName(), runtime);\n-                    if (f == null || !f.getType().isAssignableFrom(c))\n-                        throw new MetaDataException(_loc.get(\"invalid-id\",\n-                            _type)).setFailedObject(fmds[i].getName());\n-                } else if (access == ACCESS_PROPERTY) {\n-                    cap = StringUtils.capitalize(fmds[i].getName());\n-                    type = fmds[i].getDeclaredTypeCode();\n-\n-                    m = findMethod(oid, \"get\" + cap, null, runtime);\n-                    if (m == null && (type == JavaTypes.BOOLEAN\n-                        || type == JavaTypes.BOOLEAN_OBJ))\n-                        m = findMethod(oid, \"is\" + cap, null, runtime);\n-                    if (m == null || !m.getReturnType().isAssignableFrom(c))\n-                        throw new MetaDataException(_loc.get(\"invalid-id\",\n-                            _type)).setFailedObject(\"get\" + cap);\n-\n-                    m = findMethod(oid, \"set\" + cap,\n-                        new Class[]{ fmds[i].getDeclaredType() }, runtime);\n-                    if (m == null || m.getReturnType() != void.class)\n-                        throw new MetaDataException(_loc.get(\"invalid-id\",\n-                            _type)).setFailedObject(\"set\" + cap);\n-                }\n+        Field f;\n+        Method m;\n+        Class c;\n+        for (int i = 0; i < fmds.length; i++) {\n+            switch (fmds[i].getDeclaredTypeCode()) {\n+                case JavaTypes.ARRAY:\n+                    c = fmds[i].getDeclaredType().getComponentType();\n+                    if (c == byte.class || c == Byte.class\n+                        || c == char.class || c == Character.class) {\n+                        c = fmds[i].getDeclaredType();\n+                        break;\n+                    }\n+                    // else no break\n+                case JavaTypes.PC_UNTYPED:\n+                case JavaTypes.COLLECTION:\n+                case JavaTypes.MAP:\n+                case JavaTypes.OID: // we're validating embedded fields\n+                    throw new MetaDataException(_loc.get(\"bad-pk-type\",\n+                        fmds[i]));\n+                default:\n+                    c = fmds[i].getObjectIdFieldType();\n             }\n-        } catch (OpenJPAException ke) {\n-            throw ke;\n-        } catch (Throwable t) {\n-            throw new MetaDataException(_loc.get(\"invalid-id\", _type)).\n-                setCause(t);\n-        }\n-    }\n-\n-    /**\n-     * Find the named field, recursing to superclasses if necessary.\n-     */\n-    private static Field findField(Class c, String name, boolean pub)\n-        throws Exception {\n-        if (c == null || c == Object.class)\n-            return null;\n-\n-        try {\n-            return (pub) ? c.getField(name) : c.getDeclaredField(name);\n-        } catch (NoSuchFieldException nsfe) {\n-            return (pub) ? null : findField(c.getSuperclass(), name, false);\n-        }\n-    }\n \n-    /**\n-     * Find the named method, recursing to superclasses if necessary.\n-     */\n-    private static Method findMethod(Class c, String name, Class[] params,\n-        boolean pub)\n-        throws Exception {\n-        if (c == null || c == Object.class)\n-            return null;\n-\n-        try {\n-            return (pub) ? c.getMethod(name, params)\n-                : c.getDeclaredMethod(name, params);\n-        } catch (NoSuchMethodException nsfe) {\n-            return (pub) ? null : findMethod(c.getSuperclass(), name, params,\n-                false);\n+            if (meta.getAccessType() == ACCESS_FIELD) {\n+                f = Reflection.findField(oid, fmds[i].getName(), false);\n+                if (f == null || !f.getType().isAssignableFrom(c))\n+                    throw new MetaDataException(_loc.get(\"invalid-id\",\n+                        _type, fmds[i].getName()));\n+            } else if (meta.getAccessType() == ACCESS_PROPERTY) {\n+                m = Reflection.findGetter(oid, fmds[i].getName(), false);\n+                if (m == null || !m.getReturnType().isAssignableFrom(c))\n+                    throw new MetaDataException(_loc.get(\"invalid-id\",\n+                        _type, fmds[i].getName()));\n+                m = Reflection.findSetter(oid, fmds[i].getName(),\n+                    fmds[i].getDeclaredType(), false);\n+                if (m == null || m.getReturnType() != void.class)\n+                    throw new MetaDataException(_loc.get(\"invalid-id\",\n+                        _type, fmds[i].getName()));\n+            }\n         }\n     }\n "},{"sha":"d2d4db43b33cf8740274db1f6f752af58f69df4a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java","status":"modified","additions":56,"deletions":93,"changes":149,"blob_url":"https://github.com/apache/openjpa/blob/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java","raw_url":"https://github.com/apache/openjpa/raw/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ApplicationIds.java?ref=aecff50b27d17904a7b9cb6de00df032f01425dd","patch":"@@ -16,14 +16,14 @@\n package org.apache.openjpa.util;\n \n import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n import java.util.Date;\n \n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.enhance.FieldManager;\n import org.apache.openjpa.enhance.PCRegistry;\n import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.enhance.Reflection;\n import org.apache.openjpa.kernel.ObjectIdStateManager;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.StoreManager;\n@@ -84,24 +84,15 @@\n         if (meta.isObjectIdTypeShared())\n             oid = ((ObjectId) oid).getId();\n         Class oidType = oid.getClass();\n-        try {\n-            Field field;\n-            Method meth;\n-            for (int i = 0; i < fmds.length; i++) {\n-                if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD) {\n-                    field = oidType.getField(fmds[i].getName());\n-                    pks[i] = field.get(oid);\n-                } else { // property\n-                    meth = ImplHelper.getGetter(oidType, fmds[i].getName());\n-                    pks[i] = meth.invoke(oid, (Object[]) null);\n-                }\n-            }\n-            return pks;\n-        } catch (OpenJPAException ke) {\n-            throw ke;\n-        } catch (Throwable t) {\n-            throw new GeneralException(t);\n+        for (int i = 0; i < fmds.length; i++) {\n+            if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD)\n+                pks[i] = Reflection.get(oid, Reflection.findField(oidType, \n+                    fmds[i].getName(), true));\n+            else\n+                pks[i] = Reflection.get(oid, Reflection.findGetter(oidType,\n+                    fmds[i].getName(), true));\n         }\n+        return pks;\n     }\n \n     /**\n@@ -133,19 +124,19 @@ public static Object fromPKValues(Object[] pks, ClassMetaData meta) {\n                 case JavaTypes.INT:\n                 case JavaTypes.INT_OBJ:\n                     if (!convert && !(val instanceof Integer))\n-                        throw new ClassCastException(\"!(x instanceof Byte)\");\n+                        throw new ClassCastException(\"!(x instanceof Integer)\");\n                     return new IntId(meta.getDescribedType(),\n                         ((Number) val).intValue());\n                 case JavaTypes.LONG:\n                 case JavaTypes.LONG_OBJ:\n                     if (!convert && !(val instanceof Long))\n-                        throw new ClassCastException(\"!(x instanceof Byte)\");\n+                        throw new ClassCastException(\"!(x instanceof Long)\");\n                     return new LongId(meta.getDescribedType(),\n                         ((Number) val).longValue());\n                 case JavaTypes.SHORT:\n                 case JavaTypes.SHORT_OBJ:\n                     if (!convert && !(val instanceof Short))\n-                        throw new ClassCastException(\"!(x instanceof Byte)\");\n+                        throw new ClassCastException(\"!(x instanceof Short)\");\n                     return new ShortId(meta.getDescribedType(),\n                         ((Number) val).shortValue());\n                 case JavaTypes.STRING:\n@@ -174,41 +165,29 @@ public static Object fromPKValues(Object[] pks, ClassMetaData meta) {\n \n         // default to reflection\n         Class oidType = meta.getObjectIdType();\n+        Object copy = null;\n         try {\n-            // create a new id\n-            Object copy = oidType.newInstance();\n-\n-            // set each field\n-            FieldMetaData[] fmds = meta.getPrimaryKeyFields();\n-            Field field;\n-            Method meth;\n-            Class[] paramTypes = null;\n-            Object[] params = null;\n-            for (int i = 0; i < fmds.length; i++) {\n-                if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD) {\n-                    field = oidType.getField(fmds[i].getName());\n-                    field.set(copy, (convert) ? JavaTypes.convert(pks[i],\n-                        fmds[i].getObjectIdFieldTypeCode()) : pks[i]);\n-                } else { // property\n-                    if (paramTypes == null)\n-                        paramTypes = new Class[1];\n-                    paramTypes[0] = fmds[i].getDeclaredType();\n-                    meth = oidType.getMethod(\"set\" + StringUtils.capitalize\n-                        (fmds[i].getName()), paramTypes);\n-                    if (params == null)\n-                        params = new Object[1];\n-                    params[0] = (convert) ? JavaTypes.convert(pks[i],\n-                        fmds[i].getObjectIdFieldTypeCode()) : pks[i];\n-                    meth.invoke(copy, params);\n-                }\n-            }\n-\n-            if (meta.isObjectIdTypeShared())\n-                copy = new ObjectId(meta.getDescribedType(), copy);\n-            return copy;\n+            copy = oidType.newInstance();\n         } catch (Throwable t) {\n             throw new GeneralException(t);\n         }\n+\n+        FieldMetaData[] fmds = meta.getPrimaryKeyFields();\n+        Object val;\n+        for (int i = 0; i < fmds.length; i++) {\n+            val = (convert) ? JavaTypes.convert(pks[i],\n+                fmds[i].getObjectIdFieldTypeCode()) : pks[i];\n+            if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD)\n+                Reflection.set(copy, Reflection.findField(oidType, \n+                    fmds[i].getName(), true), val); \n+            else\n+                Reflection.set(copy, Reflection.findSetter(oidType, \n+                    fmds[i].getName(), fmds[i].getDeclaredType(), true), val);\n+        }\n+\n+        if (meta.isObjectIdTypeShared())\n+            copy = new ObjectId(meta.getDescribedType(), copy);\n+        return copy;\n     }\n \n     /**\n@@ -306,39 +285,31 @@ private static Object copy(Object oid, ClassMetaData meta,\n             return null;\n \n         Class oidType = oid.getClass();\n+        Object copy = null;\n         try {\n-            Object copy = oidType.newInstance();\n-            Field field;\n-            Method meth;\n-            String cap;\n-            Class[] paramTypes = null;\n-            Object[] params = null;\n-            for (int i = 0; i < fmds.length; i++) {\n-                if (fmds[i].getManagement() != FieldMetaData.MANAGE_PERSISTENT)\n-                    continue;\n-\n-                if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD) {\n-                    field = oidType.getField(fmds[i].getName());\n-                    field.set(copy, field.get(oid));\n+            copy = oidType.newInstance();\n+        } catch (Throwable t) {\n+            throw new GeneralException(t);\n+        }\n+\n+        Field field;\n+        Object val;\n+        for (int i = 0; i < fmds.length; i++) {\n+            if (fmds[i].getManagement() != FieldMetaData.MANAGE_PERSISTENT)\n+                continue;\n+\n+            if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD) {\n+                    field = Reflection.findField(oidType, fmds[i].getName(),\n+                        true);\n+                    Reflection.set(copy, field, Reflection.get(oid, field));\n                 } else { // property\n-                    if (paramTypes == null)\n-                        paramTypes = new Class[1];\n-                    paramTypes[0] = fmds[i].getObjectIdFieldType();\n-                    cap = StringUtils.capitalize(fmds[i].getName());\n-                    meth = oidType.getMethod(\"set\" + cap, paramTypes);\n-                    if (params == null)\n-                        params = new Object[1];\n-                    params[0] = ImplHelper.getGetter(oidType, cap).\n-                        invoke(oid, (Object[]) null);\n-                    meth.invoke(copy, params);\n+                    val = Reflection.get(oid, Reflection.findGetter(oidType,\n+                        fmds[i].getName(), true));\n+                    Reflection.set(copy, Reflection.findSetter(oidType, fmds[i].\n+                        getName(), fmds[i].getObjectIdFieldType(), true), val);\n                 }\n             }\n             return copy;\n-        } catch (OpenJPAException ke) {\n-            throw ke;\n-        } catch (Throwable t) {\n-            throw new GeneralException(t);\n-        }\n     }\n \n     /**\n@@ -352,19 +323,11 @@ public static Object get(Object oid, FieldMetaData fmd) {\n \n         ClassMetaData meta = fmd.getDefiningMetaData();\n         Class oidType = oid.getClass();\n-        try {\n-            if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD)\n-                return oidType.getField(fmd.getName()).get(oid);\n-\n-            // property\n-            String cap = StringUtils.capitalize(fmd.getName());\n-            return ImplHelper.getGetter(oidType, cap).\n-                invoke(oid, (Object[]) null);\n-        } catch (OpenJPAException ke) {\n-            throw ke;\n-        } catch (Throwable t) {\n-            throw new GeneralException(t);\n-        }\n+        if (meta.getAccessType() == ClassMetaData.ACCESS_FIELD)\n+            return Reflection.get(oid, Reflection.findField(oidType, \n+                fmd.getName(), true));\n+        return Reflection.get(oid, Reflection.findGetter(oidType, fmd.getName(),\n+            true));\n     }\n \n     /**"},{"sha":"575fa21ef10c565ce44ada81205deb30a6fd9242","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","status":"modified","additions":0,"deletions":33,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","raw_url":"https://github.com/apache/openjpa/raw/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java?ref=aecff50b27d17904a7b9cb6de00df032f01425dd","patch":"@@ -15,7 +15,6 @@\n  */\n package org.apache.openjpa.util;\n \n-import java.lang.reflect.Method;\n import java.util.ArrayList;\n import java.util.BitSet;\n import java.util.Collection;\n@@ -51,38 +50,6 @@\n     private static final Localizer _loc = Localizer.forPackage\n         (ImplHelper.class);\n \n-    /**\n-     * Return the getter method matching the given property name.\n-     */\n-    public static Method getGetter(Class cls, String prop) {\n-        prop = StringUtils.capitalize(prop);\n-        try {\n-            return cls.getMethod(\"get\" + prop, (Class[]) null);\n-        } catch (Exception e) {\n-            try {\n-                return cls.getMethod(\"is\" + prop, (Class[]) null);\n-            } catch (Exception e2) {\n-                throw new UserException(_loc.get(\"bad-getter\", cls,\n-                    prop)).setCause(e);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Return the setter method matching the given property name.\n-     */\n-    public static Method getSetter(Class cls, String prop) {\n-        Method getter = getGetter(cls, prop);\n-        prop = StringUtils.capitalize(prop);\n-        try {\n-            return cls.getMethod(\"set\" + prop,\n-                new Class[]{ getter.getReturnType() });\n-        } catch (Exception e) {\n-            throw new UserException(_loc.get(\"bad-setter\", cls, prop)).\n-                setCause(e);\n-        }\n-    }\n-\n     /**\n      * Helper for store manager implementations. This method simply delegates\n      * to the proper singular method for each state manager."},{"sha":"e0f32bf7ec7c4a3633f0699cdb2b9110afe50983","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/enhance/localizer.properties","status":"modified","additions":7,"deletions":2,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/resources/org/apache/openjpa/enhance/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/resources/org/apache/openjpa/enhance/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/enhance/localizer.properties?ref=aecff50b27d17904a7b9cb6de00df032f01425dd","patch":"@@ -12,6 +12,13 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n+copy-no-oid: Cannot copy identity for abstract type \"{0}\".\n+no-meta: No registered metadata for type \"{0}\".\n+bad-getter: Missing getter for property \"{1}\" in type \"{0}\". \n+bad-setter: Missing setter for property \"{1}\" in type \"{0}\". \n+bad-field: Missing field for property \"{1}\" in type \"{0}\".\n+reflect-security: Unable to access \"{0}\" via reflection.  Make sure OpenJPA \\\n+    has the \"suppressAccessChecks\" permission.\n needs-runtime-enhance: \"{0}\" requires runtime enhancement: {1}\n runtime-enhance-pcclasses: You have enabled runtime enhancement, but have not \\\n \tspecified the set of persistent classes.  OpenJPA must look for metadata \\\n@@ -35,7 +42,6 @@ pers-aware: Type \"{0}\" has no metadata; enhancing as persistence aware. \\\n \tmetadata files are not named properly. See the documentation on metadata \\\n \tplacement for more information.\n enhance-running: Enhancer running on type \"{0}\".\n-enhance-running-oids: Enhancer running on oid: {0}\n enhance-aware: The class does not have metadata - enhanced as persistence-aware.\n enhance-norun: The class is already persistence capable - no enhancement \\\n \tperformed.\n@@ -59,7 +65,6 @@ enhance-uid-access: An IllegalAccessException occured when trying to \\\n \tbug in JDK 1.4+ when using a custom ClassLoader to enhance a \\\n \tclass that implements java.io.Serializable. If compatibility with \\\n \tnon-enhanced versions of \"{0}\" is not needed, this warning can be ignored.\n-enhance-oid: Enhancing object id type \"{0}\" to allow member access. \n enhance-defcons-extern: Type \"{0}\" requires a public constructor to support \\\n     detach on serialize.  Making default constructor public.\n cons-access: An error occurred trying to instantiate a custom storage class."},{"sha":"afd0726d2297895eba82a10cdb092bc4b8f61bda","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","status":"modified","additions":2,"deletions":4,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties?ref=aecff50b27d17904a7b9cb6de00df032f01425dd","patch":"@@ -341,10 +341,8 @@ bad-agg-listener-hint: Query hint value \"{0}\" ({1}) cannot be converted into \\\n \tan aggregate listener.\n bad-filter-listener-hint: Query hint value \"{0}\" ({1}) cannot be converted \\\n \tinto a filter listener.\n-bad-getter-hint: Invoking the getter for hint key \"{0}\" on \"{1}\" caused \\\n-\tan error.\n-bad-setter-hint: Invoking the setter for hint key \"{0}\" on \"{1}\" with \\\n-\tvalue \"{2}\" caused an error.\n+bad-setter-hint-arg: In query hint \"{0}\", cannot convert hint value \"{1}\" to \\\n+    type \"{2}\".\n detach-val-mismatch: The instance \"{0}\" is managed by another context and \\\n \tcannot be inspected for field values.\n detach-val-badsm: The instance \"{0}\" has an unknown state manager which \\"},{"sha":"fd14c38acf028edc12326c2ada932cc2eaf3343d","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","status":"modified","additions":1,"deletions":11,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties?ref=aecff50b27d17904a7b9cb6de00df032f01425dd","patch":"@@ -165,9 +165,7 @@ no-pk: Concrete type \"{0}\" with application identity does not declare any \\\n \tprimary key fields.\n invalid-id: The id class specified by type \"{0}\" does not match the \\\n \tprimary key fields of the class.  Make sure your identity class has the \\\n-\tsame primary keys as your persistent type, that the access types are the \\\n-\tsame, and if you are getting this error at runtime, that you have \\\n-\tyour persistent class since last compiling your identity class.\n+\tsame primary keys as your persistent type.  Mismatched property: \"{1}\"\n null-cons: The id class specified by type \"{0}\" does not have public a \\\n \tno-args constructor.\n hc-method: The identity class specified by type \"{0}\" is not valid, as the \\\n@@ -242,14 +240,6 @@ val-not-one-pk: The map value type of field \"{0}\" a derived key must be a \\\n # show up with the prefix will not be included in the list of\n # extensions that are validated by generic tools (such as the enhancer)\n extension-datastore-prefix: jdbc-\n-pc-registry-no-method: No method was found for the persistent property \"{0}\" \\\n-\tdeclared in \"{1}\" or one of its superclasses. Searched for a method called \\\n-\t\"{2}\".\n-pc-registry-no-boolean-method: No method was found for the persistent property \\\n-\t\"{0}\" declared in \"{1}\" or one of its superclasses. Searched for methods \\\n-\tcalled \"{2}\" and \"{3}\".\n-pc-registry-no-field: No field was found for the persistent property \"{0}\" \\\n-\tdeclared in \"{1}\" or one of its superclasses.\n nonpc-field-orderable: Cannot order \"{0}\" on \"{1}\", because {0} is not a \\\n \trelation to another persistent type.  For non-relation fields, you can \\\n \tonly order on the field element values themselves, represented by \\"},{"sha":"84adb8e60fe9373a956fa33f88cb506e134a419f","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/util/localizer.properties","status":"modified","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/resources/org/apache/openjpa/util/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-kernel/src/main/resources/org/apache/openjpa/util/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/util/localizer.properties?ref=aecff50b27d17904a7b9cb6de00df032f01425dd","patch":"@@ -67,5 +67,3 @@ dup-oid: A duplicate object id exception has occurred.  Each object you \\\n unique: A unique constraint violation has occurred. \n ref-integrity: A referential integrity constraint has occurred.\n no-store-exts: No store-specific facade found matching \"{0}\".  Using default.\n-bad-getter: Missing getter for property \"{1}\" in type \"{0}\". \n-bad-setter: Missing setter for property \"{1}\" in type \"{0}\". "},{"sha":"e836dd17ed38dd9d0b012fc6e98ba7b22ce7cca4","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerFactoryImpl.java","status":"modified","additions":7,"deletions":5,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerFactoryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerFactoryImpl.java?ref=aecff50b27d17904a7b9cb6de00df032f01425dd","patch":"@@ -28,6 +28,7 @@\n import javax.persistence.EntityManagerFactory;\n \n import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.enhance.Reflection;\n import org.apache.openjpa.kernel.AutoDetach;\n import org.apache.openjpa.kernel.Broker;\n import org.apache.openjpa.kernel.BrokerFactory;\n@@ -38,7 +39,6 @@\n import org.apache.openjpa.lib.conf.ProductDerivations;\n import org.apache.openjpa.lib.conf.Value;\n import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.util.ImplHelper;\n import org.apache.openjpa.util.OpenJPAException;\n import serp.util.Strings;\n \n@@ -211,7 +211,7 @@ else if (obj == null)\n                 continue; \n             prop = prop.substring(prefix.length());\n             try {\n-                setter = ImplHelper.getSetter(em.getClass(), prop);\n+                setter = Reflection.findSetter(em.getClass(), prop, true);\n             } catch (OpenJPAException ke) {\n                 if (errs == null)\n                     errs = new LinkedList<RuntimeException>();\n@@ -228,11 +228,13 @@ else if (obj == null)\n                         val = Strings.parse((String) val,\n                             setter.getParameterTypes()[0]);\n                 }\n-                setter.invoke(em, new Object[]{ val });\n-            } catch (Exception e) {\n+                Reflection.set(em, setter, val);\n+            } catch (Throwable t) {\n+                while (t.getCause() != null)\n+                    t = t.getCause();\n                 ArgumentException err = new ArgumentException(_loc.get\n                     (\"bad-em-prop\", prop, entry.getValue()),\n-                    new Throwable[]{ e }, null, true);\n+                    new Throwable[]{ t }, null, true);\n                 if (errs == null)\n                     errs = new LinkedList<RuntimeException>();\n                 errs.add(err);"},{"sha":"bdce0c80a70cad78d75e1d46533e6f2f49812023","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataDefaults.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/aecff50b27d17904a7b9cb6de00df032f01425dd/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceMetaDataDefaults.java?ref=aecff50b27d17904a7b9cb6de00df032f01425dd","patch":"@@ -43,6 +43,7 @@\n import javax.persistence.PreUpdate;\n import javax.persistence.Transient;\n \n+import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.meta.AbstractMetaDataDefaults;\n import org.apache.openjpa.meta.ClassMetaData;\n@@ -282,8 +283,8 @@ protected boolean isDefaultPersistent(ClassMetaData meta, Member member,\n             try {\n                 // check for setters for methods\n                 Method setter = meta.getDescribedType().getDeclaredMethod(\"set\"\n-                    + name.substring(0, 1).toUpperCase() + name.substring(1),\n-                    new Class[] { ((Method) member).getReturnType() });\n+                    + StringUtils.capitalize(name), new Class[] { \n+                    ((Method) member).getReturnType() });\n                 if (setter == null)\n                     return false;\n             } catch (Exception e) {"}]}

