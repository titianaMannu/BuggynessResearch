{"sha":"b119e2b9594eaa6e4ca9f7ceaf85cd43f6eaf6a0","node_id":"MDY6Q29tbWl0MjA2MzY0OmIxMTllMmI5NTk0ZWFhNmU0Y2E5ZjdjZWFmODVjZDQzZjZlYWY2YTA=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2009-12-11T20:33:32Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2009-12-11T20:33:32Z"},"message":"OPENJPA-1050: Use generic types whenever possible. Replace ordered map with native implementation wrapper. \n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@889801 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0ad5203bedaa965d76b00201d4ee6453cb25cb63","url":"https://api.github.com/repos/apache/openjpa/git/trees/0ad5203bedaa965d76b00201d4ee6453cb25cb63"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/b119e2b9594eaa6e4ca9f7ceaf85cd43f6eaf6a0","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/b119e2b9594eaa6e4ca9f7ceaf85cd43f6eaf6a0","html_url":"https://github.com/apache/openjpa/commit/b119e2b9594eaa6e4ca9f7ceaf85cd43f6eaf6a0","comments_url":"https://api.github.com/repos/apache/openjpa/commits/b119e2b9594eaa6e4ca9f7ceaf85cd43f6eaf6a0/comments","author":null,"committer":null,"parents":[{"sha":"4715cc737b411f1f5e8604251c74f8570f1c645a","url":"https://api.github.com/repos/apache/openjpa/commits/4715cc737b411f1f5e8604251c74f8570f1c645a","html_url":"https://github.com/apache/openjpa/commit/4715cc737b411f1f5e8604251c74f8570f1c645a"}],"stats":{"total":115,"additions":58,"deletions":57},"files":[{"sha":"5a6af97e160ec1ce8174dfd6cc1619e512cbe2fe","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","status":"modified","additions":49,"deletions":50,"changes":99,"blob_url":"https://github.com/apache/openjpa/blob/b119e2b9594eaa6e4ca9f7ceaf85cd43f6eaf6a0/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/b119e2b9594eaa6e4ca9f7ceaf85cd43f6eaf6a0/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java?ref=b119e2b9594eaa6e4ca9f7ceaf85cd43f6eaf6a0","patch":"@@ -29,21 +29,19 @@\n import java.util.List;\n import java.util.ListIterator;\n import java.util.Map;\n+import java.util.concurrent.locks.ReentrantLock;\n \n-import org.apache.commons.collections.map.LinkedMap;\n import org.apache.commons.lang.ObjectUtils;\n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.kernel.exps.AggregateListener;\n-import org.apache.openjpa.kernel.exps.FilterListener;\n import org.apache.openjpa.kernel.exps.Constant;\n+import org.apache.openjpa.kernel.exps.FilterListener;\n import org.apache.openjpa.kernel.exps.Literal;\n-import org.apache.openjpa.kernel.exps.Parameter;\n import org.apache.openjpa.kernel.exps.Path;\n import org.apache.openjpa.kernel.exps.QueryExpressions;\n import org.apache.openjpa.kernel.exps.Val;\n-import org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.rop.EagerResultList;\n import org.apache.openjpa.lib.rop.MergedResultObjectProvider;\n@@ -52,20 +50,21 @@\n import org.apache.openjpa.lib.rop.ResultObjectProvider;\n import org.apache.openjpa.lib.util.J2DoPrivHelper;\n import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.OrderedMap;\n import org.apache.openjpa.lib.util.ReferenceHashSet;\n-import java.util.concurrent.locks.ReentrantLock;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.meta.MetaDataRepository;\n import org.apache.openjpa.util.GeneralException;\n+import org.apache.openjpa.util.ImplHelper;\n import org.apache.openjpa.util.InvalidStateException;\n-import org.apache.openjpa.util.NonUniqueResultException;\n import org.apache.openjpa.util.NoResultException;\n+import org.apache.openjpa.util.NonUniqueResultException;\n import org.apache.openjpa.util.OpenJPAException;\n import org.apache.openjpa.util.UnsupportedException;\n import org.apache.openjpa.util.UserException;\n-import org.apache.openjpa.util.ImplHelper;\n+\n import serp.util.Numbers;\n import serp.util.Strings;\n \n@@ -75,6 +74,7 @@\n  * @author Abe White\n  * @nojavadoc\n  */\n+@SuppressWarnings(\"serial\")\n public class QueryImpl\n     implements Query {\n \n@@ -90,7 +90,7 @@\n     private ReentrantLock _lock;\n \n     // unparsed state\n-    private Class _class = null;\n+    private Class<?> _class = null;\n     private boolean _subclasses = true;\n     private boolean _readOnly = false;\n     private String _query = null;\n@@ -102,31 +102,30 @@\n     private transient ResultPacker _packer = null;\n \n     // candidates\n-    private transient Collection _collection = null;\n+    private transient Collection<?> _collection = null;\n     private transient Extent _extent = null;\n \n     // listeners\n-    private Map _filtListeners = null;\n-    private Map _aggListeners = null;\n+    private Map<String,FilterListener> _filtListeners = null;\n+    private Map<String,AggregateListener> _aggListeners = null;\n \n     // configuration for loading objects\n     private FetchConfiguration _fc = null;\n     private boolean _ignoreChanges = false;\n-    private Class _resultMappingScope = null;\n+    private Class<?> _resultMappingScope = null;\n     private String _resultMappingName = null;\n \n     // these fields should only be used directly after we have a compilation,\n     // because their values may be encoded in the query string\n     private Boolean _unique = null;\n-    private Class _resultClass = null;\n+    private Class<?> _resultClass = null;\n     private transient long _startIdx = 0;\n     private transient long _endIdx = Long.MAX_VALUE;\n     private transient boolean _rangeSet = false;\n \n     // remember the list of all the results we have returned so we\n     // can free their resources when close or closeAll is called\n-    private transient final Collection _resultLists = new ReferenceHashSet\n-        (ReferenceHashSet.WEAK);\n+    private transient final Collection<ResultList<?>> _resultLists = new ReferenceHashSet(ReferenceHashSet.WEAK);\n \n     /**\n      * Construct a query managed by the given broker.\n@@ -211,7 +210,7 @@ public void addFilterListener(FilterListener listener) {\n             assertOpen();\n             assertNotReadOnly();\n             if (_filtListeners == null)\n-                _filtListeners = new HashMap(5);\n+                _filtListeners = new HashMap<String,FilterListener>(5);\n             _filtListeners.put(listener.getTag(), listener);\n         } finally {\n             unlock();\n@@ -230,9 +229,11 @@ public void removeFilterListener(FilterListener listener) {\n         }\n     }\n \n-    public Collection getFilterListeners() {\n-        return (_filtListeners == null) ? Collections.EMPTY_LIST\n-            : _filtListeners.values();\n+    public Collection<FilterListener> getFilterListeners() {\n+        if (_filtListeners == null) \n+            return Collections.emptyList();\n+        else\n+            return _filtListeners.values();\n     }\n \n     public FilterListener getFilterListener(String tag) {\n@@ -260,7 +261,7 @@ public void addAggregateListener(AggregateListener listener) {\n             assertOpen();\n             assertNotReadOnly();\n             if (_aggListeners == null)\n-                _aggListeners = new HashMap(5);\n+                _aggListeners = new HashMap<String,AggregateListener>(5);\n             _aggListeners.put(listener.getTag(), listener);\n         } finally {\n             unlock();\n@@ -279,9 +280,11 @@ public void removeAggregateListener(AggregateListener listener) {\n         }\n     }\n \n-    public Collection getAggregateListeners() {\n-        return (_aggListeners == null) ? Collections.EMPTY_LIST\n-            : _aggListeners.values();\n+    public Collection<AggregateListener> getAggregateListeners() {\n+        if (_aggListeners == null) \n+            return Collections.emptyList();\n+        else\n+            return _aggListeners.values();\n     }\n \n     public AggregateListener getAggregateListener(String tag) {\n@@ -311,7 +314,7 @@ public Extent getCandidateExtent() {\n         // in case the user has a reference to it and might use it)\n         lock();\n         try {\n-            Class cls = getCandidateType();\n+            Class<?> cls = getCandidateType();\n             if (_extent == null && _collection == null && _broker != null\n                 && cls != null) {\n                 _extent = _broker.newExtent(cls, _subclasses);\n@@ -361,12 +364,12 @@ public void setCandidateExtent(Extent candidateExtent) {\n         }\n     }\n \n-    public Collection getCandidateCollection() {\n+    public Collection<?> getCandidateCollection() {\n         assertOpen();\n         return _collection;\n     }\n \n-    public void setCandidateCollection(Collection candidateCollection) {\n+    public void setCandidateCollection(Collection<?> candidateCollection) {\n         if (!_storeQuery.supportsInMemoryExecution())\n             throw new UnsupportedException(_loc.get(\"query-nosupport\",\n                 _language));\n@@ -428,7 +431,7 @@ public Class getResultMappingScope() {\n         return _resultMappingScope;\n     }\n \n-    public void setResultMapping(Class scope, String name) {\n+    public void setResultMapping(Class<?> scope, String name) {\n         lock();\n         try {\n             assertOpen();\n@@ -1170,13 +1173,12 @@ private void updateInMemory(Object ob, Object[] params, StoreQuery q) {\n     /**\n      * Trace log that the query is executing.\n      */\n-    private void logExecution(int op, LinkedMap types, Object[] params) {\n-        Map pmap = Collections.EMPTY_MAP;\n+    private void logExecution(int op, OrderedMap<Object, Class<?>> types, Object[] params) {\n+        OrderedMap<Object, Object> pmap = new OrderedMap<Object, Object>();\n         if (params.length > 0) {\n-            pmap = new HashMap((int) (params.length * 1.33 + 1));\n             if (types != null && types.size() == params.length) {\n                 int i = 0;\n-                for (Iterator itr = types.keySet().iterator(); itr.hasNext();)\n+                for (Iterator<Object> itr = types.keySet().iterator(); itr.hasNext();)\n                     pmap.put(itr.next(), params[i++]);\n             } else {\n                 for (int i = 0; i < params.length; i++)\n@@ -1189,7 +1191,7 @@ private void logExecution(int op, LinkedMap types, Object[] params) {\n     /**\n      * Trace log that the query is executing.\n      */\n-    private void logExecution(int op, Map params) {\n+    private void logExecution(int op, Map<?, ?> params) {\n         String s = _query;\n         if (StringUtils.isEmpty(s))\n             s = toString();\n@@ -1542,7 +1544,7 @@ public boolean hasGrouping() {\n         }\n     }\n \n-    public LinkedMap getParameterTypes() {\n+    public OrderedMap<Object,Class<?>> getParameterTypes() {\n         lock();\n         try {\n             return compileForExecutor().getParameterTypes(_storeQuery);\n@@ -1702,28 +1704,26 @@ protected void assertParameters(StoreQuery q, StoreQuery.Executor ex,\n         if (!q.requiresParameterDeclarations() || !isParsedQuery())\n             return;\n \n-        LinkedMap paramTypes = ex.getParameterTypes(q);\n+        OrderedMap<Object,Class<?>> paramTypes = ex.getParameterTypes(q);\n         int typeCount = paramTypes.size();\n         if (typeCount > params.length)\n             throw new UserException(_loc.get(\"unbound-params\",\n                 paramTypes.keySet()));\n \n-        Iterator itr = paramTypes.entrySet().iterator();\n-        Map.Entry entry;\n+        Iterator<Map.Entry<Object,Class<?>>> itr = paramTypes.entrySet().iterator();\n+        Map.Entry<Object,Class<?>> entry;\n         for (int i = 0; itr.hasNext(); i++) {\n-            entry = (Map.Entry) itr.next();\n-            if (((Class) entry.getValue()).isPrimitive() && params[i] == null)\n-                throw new UserException(_loc.get(\"null-primitive-param\",\n-                    entry.getKey()));\n+            entry = itr.next();\n+            if (entry.getValue().isPrimitive() && params[i] == null)\n+                throw new UserException(_loc.get(\"null-primitive-param\", entry.getKey()));\n         }\n     }\n     \n-    protected void assertParameters(StoreQuery q, StoreQuery.Executor ex, \n-        Map params) {\n+    protected void assertParameters(StoreQuery q, StoreQuery.Executor ex, Map params) {\n         if (!q.requiresParameterDeclarations())\n             return;\n \n-        LinkedMap paramTypes = ex.getParameterTypes(q);\n+        OrderedMap<Object,Class<?>> paramTypes = ex.getParameterTypes(q);\n         for (Object actual : params.keySet()) {\n             if (!paramTypes.containsKey(actual))\n             throw new UserException(_loc.get(\"unbound-params\",\n@@ -1735,14 +1735,13 @@ protected void assertParameters(StoreQuery q, StoreQuery.Executor ex,\n                 expected, params.keySet()));\n         }\n \n-        Iterator itr = paramTypes.entrySet().iterator();\n-        Map.Entry entry;\n+        Iterator<Map.Entry<Object, Class<?>>> itr = paramTypes.entrySet().iterator();\n+        Map.Entry<Object, Class<?>> entry;\n         for (int i = 0; itr.hasNext(); i++) {\n-            entry = (Map.Entry) itr.next();\n-            if (((Class) entry.getValue()).isPrimitive() \n+            entry = itr.next();\n+            if (entry.getValue().isPrimitive() \n                 && params.get(entry.getKey()) == null)\n-                throw new UserException(_loc.get(\"null-primitive-param\",\n-                    entry.getKey()));\n+                throw new UserException(_loc.get(\"null-primitive-param\", entry.getKey()));\n         }\n     }\n \n@@ -1987,7 +1986,7 @@ public boolean hasGrouping(StoreQuery q) {\n             return _executors[0].hasGrouping(q);\n         }\n \n-        public LinkedMap getParameterTypes(StoreQuery q) {\n+        public OrderedMap<Object,Class<?>> getParameterTypes(StoreQuery q) {\n             return _executors[0].getParameterTypes(q);\n         }\n         "},{"sha":"8aa40ecbc0fba086ef0d5e4ea79ee303ab9ab3b4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","status":"modified","additions":9,"deletions":7,"changes":16,"blob_url":"https://github.com/apache/openjpa/blob/b119e2b9594eaa6e4ca9f7ceaf85cd43f6eaf6a0/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/b119e2b9594eaa6e4ca9f7ceaf85cd43f6eaf6a0/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java?ref=b119e2b9594eaa6e4ca9f7ceaf85cd43f6eaf6a0","patch":"@@ -27,7 +27,9 @@\n import org.apache.openjpa.kernel.exps.Constant;\n import org.apache.openjpa.kernel.exps.FilterListener;\n import org.apache.openjpa.kernel.exps.QueryExpressions;\n+import org.apache.openjpa.kernel.exps.Value;\n import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.lib.util.OrderedMap;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n \n@@ -43,11 +45,11 @@\n     extends QueryOperations, Serializable {\n \n     // linkedmap doesn't allow a size of 0, so use 1\n-    public static final LinkedMap EMPTY_PARAMS = new LinkedMap(1, 1F);\n+    public static final OrderedMap<Object, Class<?>> EMPTY_PARAMS = new OrderedMap<Object, Class<?>>();\n     public static final ClassMetaData[] EMPTY_METAS = new ClassMetaData[0];\n     public static final String[] EMPTY_STRINGS = new String[0];\n     public static final Object[] EMPTY_OBJECTS = new Object[0];\n-    public static final Class[] EMPTY_CLASSES = new Class[0];\n+    public static final Class<?>[] EMPTY_CLASSES = new Class[0];\n     public static final boolean[] EMPTY_BOOLEANS = new boolean[0];\n \n     /**\n@@ -280,7 +282,7 @@ public Object getOrderingValue(StoreQuery q, Object[] params,\n          * Return the expected types of the projections used by this query,\n          * or an empty array if not a projection.\n          */\n-        public Class[] getProjectionTypes(StoreQuery q);\n+        public Class<?>[] getProjectionTypes(StoreQuery q);\n \n         /**\n          * Return an array of all persistent classes used in this query, or\n@@ -310,7 +312,7 @@ public Object getOrderingValue(StoreQuery q, Object[] params,\n          * {@link Map#entrySet}'s {@link Iterator} must return values in the\n          * order in which they were declared or used.\n          */\n-        public LinkedMap getParameterTypes(StoreQuery q);\n+        public OrderedMap<Object, Class<?>> getParameterTypes(StoreQuery q);\n         \n         /**\n          * Return an array from the given user parameter values.\n@@ -324,20 +326,20 @@ public Object getOrderingValue(StoreQuery q, Object[] params,\n          * \n          * @since 2.0.0\n          */\n-        public Object[] toParameterArray(StoreQuery q, Map userParams);\n+        public Object[] toParameterArray(StoreQuery q, Map<?,?> userParams);\n \n         /**\n          * Returns the result class, if any.\n          */\n-        public Class getResultClass(StoreQuery q);\n+        public Class<?> getResultClass(StoreQuery q);\n         \n         public ResultShape<?> getResultShape(StoreQuery q);\n \n         /**\n          * Return a map of {@link FieldMetaData} to update\n          * {@link Constant}s, in cases where this query is for a bulk update.\n \t \t */\n-\t\tpublic Map getUpdates (StoreQuery q);\n+\t\tpublic Map<FieldMetaData,Value> getUpdates (StoreQuery q);\n \t\t\n         /**\n          * Return the parsed query expressions for our candidate types."}]}

