{"sha":"b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","node_id":"MDY6Q29tbWl0MjA2MzY0OmIyYzFlOGYxNmZmYjRmYTEyOTI0OWJhODhkZWJhNGQ3NjJhZGM2YzM=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2008-03-25T03:37:56Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2008-03-25T03:37:56Z"},"message":"OPENJPA-544. Get rid of JDK1.4 support, fold the jdk1.5 modules into their siblings, get rid of some ugly reflection that was there for 1.5 support, and move to the java.util.concurrent collections classes. This includes a wrapper around ConcurrentHashMap that allows nulls, since the old OpenJPA concurrent map allowed nulls and we rely on that behavior. The implication is that putIfAbsent() and some of the other special JDK1.5 methods don't obey the same contracts as in the java.util.concurrent package.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@640685 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0ba6943b181476e3bc6a5b0dd693ef19adf4d4c8","url":"https://api.github.com/repos/apache/openjpa/git/trees/0ba6943b181476e3bc6a5b0dd693ef19adf4d4c8"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","html_url":"https://github.com/apache/openjpa/commit/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","comments_url":"https://api.github.com/repos/apache/openjpa/commits/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/comments","author":null,"committer":null,"parents":[{"sha":"6af619cd891e793efe4c239f4e4815b89d119d49","url":"https://api.github.com/repos/apache/openjpa/commits/6af619cd891e793efe4c239f4e4815b89d119d49","html_url":"https://github.com/apache/openjpa/commit/6af619cd891e793efe4c239f4e4815b89d119d49"}],"stats":{"total":43937,"additions":18404,"deletions":25533},"files":[{"sha":"53d38694399270acaf6d3cd0b1149ef2d4a1c0f8","filename":"openjpa-all/pom.xml","status":"modified","additions":3,"deletions":16,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-all/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-all/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-all/pom.xml?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -84,15 +84,14 @@\n \n             <!--\n                 create enhancer pre-main attribute\n-                copied from openjpa-kernel-5/pom.xml\n             -->\n             <plugin>\n                 <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-jar-plugin</artifactId>\n                 <configuration>\n-                    <archive>\r\n-                        <manifest>\r\n-                           <mainClass>org.apache.openjpa.conf.OpenJPAVersion</mainClass>\r\n+                    <archive>\n+                        <manifest>\n+                           <mainClass>org.apache.openjpa.conf.OpenJPAVersion</mainClass>\n                         </manifest>\n                         <manifestEntries>\n                             <Premain-Class>\n@@ -118,24 +117,12 @@\n             <version>${pom.version}</version>\n             <scope>provided</scope>\n         </dependency>\n-        <dependency>\n-            <groupId>org.apache.openjpa</groupId>\n-            <artifactId>openjpa-kernel-5</artifactId>\n-            <version>${pom.version}</version>\n-            <scope>provided</scope>\n-        </dependency>\n         <dependency>\n             <groupId>org.apache.openjpa</groupId>\n             <artifactId>openjpa-jdbc</artifactId>\n             <version>${pom.version}</version>\n             <scope>provided</scope>\n         </dependency>\n-        <dependency>\n-            <groupId>org.apache.openjpa</groupId>\n-            <artifactId>openjpa-jdbc-5</artifactId>\n-            <version>${pom.version}</version>\n-            <scope>provided</scope>\n-        </dependency>\n         <dependency>\n             <groupId>org.apache.openjpa</groupId>\n             <artifactId>openjpa-persistence</artifactId>"},{"sha":"3e822aabe1e0410e4a3671c7ea30ee9c1ec09496","filename":"openjpa-jdbc-5/pom.xml","status":"removed","additions":0,"deletions":59,"changes":59,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-jdbc-5/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-jdbc-5/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc-5/pom.xml?ref=6af619cd891e793efe4c239f4e4815b89d119d49","patch":"@@ -1,59 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<!--\n- Licensed to the Apache Software Foundation (ASF) under one\n- or more contributor license agreements.  See the NOTICE file\n- distributed with this work for additional information\n- regarding copyright ownership.  The ASF licenses this file\n- to you under the Apache License, Version 2.0 (the\n- \"License\"); you may not use this file except in compliance\n- with the License.  You may obtain a copy of the License at\n- \n- http://www.apache.org/licenses/LICENSE-2.0\n- \n- Unless required by applicable law or agreed to in writing,\n- software distributed under the License is distributed on an\n- \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- KIND, either express or implied.  See the License for the\n- specific language governing permissions and limitations\n- under the License.   \n--->\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n-         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n-    <modelVersion>4.0.0</modelVersion>\n-    <groupId>org.apache.openjpa</groupId>\n-    <artifactId>openjpa-jdbc-5</artifactId>\n-    <packaging>jar</packaging>\n-    <name>OpenJPA JDBC 1.5</name>\n-    <description>OpenJPA JDBC 1.5</description>\n-    <url>http://openjpa.apache.org</url>\n-    <parent>\n-        <groupId>org.apache.openjpa</groupId>\n-        <artifactId>openjpa-parent</artifactId>\n-        <version>1.1.0-SNAPSHOT</version>\n-    </parent>\n-    <dependencies>\n-        <dependency>\n-            <groupId>org.apache.openjpa</groupId>\n-            <artifactId>openjpa-jdbc</artifactId>\n-            <version>${pom.version}</version>\n-            <scope>compile</scope>\n-        </dependency>\n-\t    <dependency>\n-\t\t    <groupId>javax.xml.bind</groupId>\n-\t\t    <artifactId>jaxb-api</artifactId>\n-\t    </dependency>\n-    </dependencies>\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-compiler-plugin</artifactId>\n-                <configuration>\n-                    <source>1.5</source>\n-                    <target>1.5</target>\n-                </configuration>\n-            </plugin>\n-        </plugins>\n-    </build>\n-</project>"},{"sha":"49d5cf691b4d6213d99181d55176681195c69b3f","filename":"openjpa-jdbc/pom.xml","status":"modified","additions":6,"deletions":22,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-jdbc/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-jdbc/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/pom.xml?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -32,33 +32,17 @@\n         <artifactId>openjpa-parent</artifactId>\n         <version>1.1.0-SNAPSHOT</version>\n     </parent>\n-    <profiles>\n-        <profile>\n-            <id>java14-validate</id>\n-            <activation><property><name>java14.jar</name></property></activation>\n-            <build>\n-                <pluginManagement>\n-                    <plugins>\n-                        <plugin>\n-                            <artifactId>maven-compiler-plugin</artifactId>\n-                            <configuration>\n-                                <compilerArguments>\n-                                    <bootclasspath>${java14.jar}</bootclasspath>\n-                                </compilerArguments>\n-                            </configuration>\n-                        </plugin>\n-                    </plugins>\n-                </pluginManagement>\n-            </build>\n-        </profile>\n-    </profiles>\n     <dependencies>\n         <dependency>\n             <groupId>org.apache.openjpa</groupId>\n             <artifactId>openjpa-kernel</artifactId>\n             <version>${pom.version}</version>\n             <scope>compile</scope>\n         </dependency>\n+        <dependency>\n+            <groupId>javax.xml.bind</groupId>\n+            <artifactId>jaxb-api</artifactId>\n+        </dependency>\n         <dependency>\n             <groupId>hsqldb</groupId>\n             <artifactId>hsqldb</artifactId>\n@@ -70,8 +54,8 @@\n             <plugin>\n                 <artifactId>maven-compiler-plugin</artifactId>\n                 <configuration>\n-                    <source>1.4</source>\n-                    <target>1.4</target>\n+                    <source>1.5</source>\n+                    <target>1.5</target>\n                 </configuration>\n             </plugin>\n         </plugins>"},{"sha":"e0b2c0be4a18cea343dbbc46a7c29ab76863f053","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBC3SavepointManager.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBC3SavepointManager.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBC3SavepointManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBC3SavepointManager.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","previous_filename":"openjpa-jdbc-5/src/main/java/org/apache/openjpa/jdbc/kernel/JDBC3SavepointManager.java"},{"sha":"7f28dadda517aa79a2ae391ba3f8c0b8c34aa0cc","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaultsImpl.java","status":"modified","additions":6,"deletions":4,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaultsImpl.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaultsImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaultsImpl.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -25,6 +25,7 @@\n \n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n import org.apache.openjpa.jdbc.meta.strats.UntypedPCValueHandler;\n+import org.apache.openjpa.jdbc.meta.strats.EnumValueHandler;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n import org.apache.openjpa.jdbc.schema.Index;\n@@ -457,10 +458,11 @@ public Object getStrategy(ValueMapping vm, Class type, boolean adapt) {\n         if (_stringifyUnmapped && vm.getTypeMapping() != null\n             && !vm.getTypeMapping().isMapped())\n             return UntypedPCValueHandler.getInstance();\n-        if (_ordinalEnum && !vm.isSerialized()\n-            && JavaVersions.isEnumeration(type))\n-            return \"org.apache.openjpa.jdbc.meta.strats.EnumValueHandler\"\n-                + \"(StoreOrdinal=true)\";\n+        if (type.isEnum() && !vm.isSerialized()) {\n+            EnumValueHandler enumHandler = new EnumValueHandler();\n+            enumHandler.setStoreOrdinal(_ordinalEnum);\n+            return enumHandler;\n+        }\n         return null;\n     }\n "},{"sha":"98cbd39eb3837f15a5ccdc66d61222580d06645c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","status":"modified","additions":0,"deletions":9,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -102,13 +102,6 @@\n \n     private static final Localizer _loc = Localizer.forPackage\n         (MappingRepository.class);\n-    private static final Map _handlers = new HashMap();\n-\n-    static {\n-        // register default value handlers\n-        _handlers.put(\"java.lang.Enum\",\n-            \"org.apache.openjpa.jdbc.meta.strats.EnumValueHandler\");\n-    }\n \n     private transient DBDictionary _dict = null;\n     private transient MappingDefaults _defaults = null;\n@@ -949,8 +942,6 @@ private Object mappedStrategy(ValueMapping val, Class type,\n             return null;\n \n         Object strat = _defaults.getStrategy(val, type, adapting);\n-        if (strat == null)\n-            strat = _handlers.get(type.getName());\n \n         // recurse on superclass so that, for example, a registered handler\n         // for java.lang.Enum will work on all enums"},{"sha":"4d2cf63d6190ff0ce877b670c3ebb3ad141d04f4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EnumValueHandler.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EnumValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EnumValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EnumValueHandler.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","previous_filename":"openjpa-jdbc-5/src/main/java/org/apache/openjpa/jdbc/meta/strats/EnumValueHandler.java"},{"sha":"7008ec062300ae41a88ab8d1d2b35dea9ff52082","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/XMLValueHandler.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/XMLValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/XMLValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/XMLValueHandler.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","previous_filename":"openjpa-jdbc-5/src/main/java/org/apache/openjpa/jdbc/meta/strats/XMLValueHandler.java"},{"sha":"6099e45297e8ed51b29a77a463e4e8c70d4c1a39","filename":"openjpa-kernel-5/pom.xml","status":"removed","additions":0,"deletions":61,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-kernel-5/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-kernel-5/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/pom.xml?ref=6af619cd891e793efe4c239f4e4815b89d119d49","patch":"@@ -1,61 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<!--\n- Licensed to the Apache Software Foundation (ASF) under one\n- or more contributor license agreements.  See the NOTICE file\n- distributed with this work for additional information\n- regarding copyright ownership.  The ASF licenses this file\n- to you under the Apache License, Version 2.0 (the\n- \"License\"); you may not use this file except in compliance\n- with the License.  You may obtain a copy of the License at\n- \n- http://www.apache.org/licenses/LICENSE-2.0\n- \n- Unless required by applicable law or agreed to in writing,\n- software distributed under the License is distributed on an\n- \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- KIND, either express or implied.  See the License for the\n- specific language governing permissions and limitations\n- under the License.   \n--->\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n-         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n-    <modelVersion>4.0.0</modelVersion>\n-    <groupId>org.apache.openjpa</groupId>\n-    <artifactId>openjpa-kernel-5</artifactId>\n-    <packaging>jar</packaging>\n-    <name>OpenJPA Kernel 1.5</name>\n-    <description>OpenJPA Kernel 1.5</description>\n-    <url>http://openjpa.apache.org</url>\n-    <parent>\n-        <groupId>org.apache.openjpa</groupId>\n-        <artifactId>openjpa-parent</artifactId>\n-        <version>1.1.0-SNAPSHOT</version>\n-    </parent>\n-    <dependencies>\n-        <dependency>\n-            <groupId>org.apache.openjpa</groupId>\n-            <artifactId>openjpa-kernel</artifactId>\n-            <version>${pom.version}</version>\n-            <scope>compile</scope>\n-        </dependency>\n-        <dependency>\n-            <groupId>org.apache.openjpa</groupId>\n-            <artifactId>openjpa-lib-5</artifactId>\n-            <version>${pom.version}</version>\n-            <scope>compile</scope>\n-        </dependency>\n-    </dependencies>\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-compiler-plugin</artifactId>\n-                <configuration>\n-                    <source>1.5</source>\n-                    <target>1.5</target>\n-                </configuration>\n-            </plugin>\n-        </plugins>\n-    </build>\n-</project>"},{"sha":"6372f26318a68f0dfb22af7f820be48a5b1c2bd8","filename":"openjpa-kernel/pom.xml","status":"modified","additions":2,"deletions":22,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/pom.xml?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -32,26 +32,6 @@\n         <artifactId>openjpa-parent</artifactId>\r\n         <version>1.1.0-SNAPSHOT</version>\r\n     </parent>\r\n-    <profiles>\r\n-        <profile>\r\n-            <id>java14-validate</id>\r\n-            <activation><property><name>java14.jar</name></property></activation>\r\n-            <build>\r\n-                <pluginManagement>\r\n-                    <plugins>\r\n-                        <plugin>\r\n-                            <artifactId>maven-compiler-plugin</artifactId>\r\n-                            <configuration>\r\n-                                <compilerArguments>\r\n-                                    <bootclasspath>${java14.jar}</bootclasspath>\r\n-                                </compilerArguments>\r\n-                            </configuration>\r\n-                        </plugin>\r\n-                    </plugins>\r\n-                </pluginManagement>\r\n-            </build>\r\n-        </profile>\r\n-    </profiles>\r\n     <dependencies>\r\n         <dependency>\r\n             <groupId>org.apache.openjpa</groupId>\r\n@@ -80,8 +60,8 @@\n             <plugin>\r\n                 <artifactId>maven-compiler-plugin</artifactId>\r\n                 <configuration>\r\n-                    <source>1.4</source>\r\n-                    <target>1.4</target>\r\n+                    <source>1.5</source>\r\n+                    <target>1.5</target>\r\n                 </configuration>\r\n             </plugin>\r\n             <plugin>\r"},{"sha":"b59bd09090d0cd06a7edcb796d343ae7c6164e01","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -25,7 +25,7 @@\n import org.apache.openjpa.lib.conf.Configuration;\r\n import org.apache.openjpa.lib.conf.PluginValue;\r\n import org.apache.openjpa.lib.util.concurrent.ConcurrentMap;\r\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n import org.apache.openjpa.lib.util.ParseException;\r\n import org.apache.openjpa.util.CacheMap;\r\n \r"},{"sha":"9e7c732b14e56a491e1ce784e2fd07db134cc72b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","status":"modified","additions":455,"deletions":455,"changes":910,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,455 +1,455 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.datacache;\n-\n-import java.util.ArrayList;\n-import java.util.BitSet;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\n-import org.apache.openjpa.event.RemoteCommitEvent;\n-import org.apache.openjpa.event.RemoteCommitListener;\n-import org.apache.openjpa.lib.conf.Configurable;\n-import org.apache.openjpa.lib.conf.Configuration;\n-import org.apache.openjpa.lib.log.Log;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\n-\n-/**\n- * Abstract {@link DataCache} implementation that provides various\n- * statistics, logging, and timeout functionality common across cache\n- * implementations.\n- *\n- * @author Patrick Linskey\n- * @author Abe White\n- */\n-public abstract class AbstractDataCache\n-    extends AbstractConcurrentEventManager\n-    implements DataCache, Configurable {\n-\n-    private static final BitSet EMPTY_BITSET = new BitSet(0);\n-\n-    private static final Localizer s_loc =\n-        Localizer.forPackage(AbstractDataCache.class);\n-\n-    /**\n-     * The configuration set by the system.\n-     */\n-    protected OpenJPAConfiguration conf;\n-\n-    /**\n-     * The log to use.\n-     */\n-    protected Log log;\n-\n-    private String _name = null;\n-    private boolean _closed = false;\n-    private String _schedule = null;\n-\n-    public String getName() {\n-        return _name;\n-    }\n-\n-    public void setName(String name) {\n-        _name = name;\n-    }\n-\n-    public String getEvictionSchedule() {\n-        return _schedule;\n-    }\n-\n-    public void setEvictionSchedule(String s) {\n-        _schedule = s;\n-    }\n-\n-    public void initialize(DataCacheManager manager) {\n-        if (_schedule != null && !\"\".equals(_schedule)) {\n-            DataCacheScheduler scheduler = manager.getDataCacheScheduler();\n-            if (scheduler != null)\n-                scheduler.scheduleEviction(this, _schedule);\n-        }\n-    }\n-\n-    public void commit(Collection additions, Collection newUpdates,\n-        Collection existingUpdates, Collection deletes) {\n-        // remove all objects in deletes list\n-        removeAllInternal(deletes);\n-\n-        // next, add all the new additions\n-        putAllInternal(additions);\n-        putAllInternal(newUpdates);\n-\n-        // possibly add the existing updates, depending on the\n-        // semantics of the cache, as dictated by recacheUpdates()\n-        if (recacheUpdates())\n-            putAllInternal(existingUpdates);\n-\n-        if (log.isTraceEnabled()) {\n-            Collection addIds = new ArrayList(additions.size());\n-            Collection upIds = new ArrayList(newUpdates.size());\n-            Collection exIds = new ArrayList(existingUpdates.size());\n-\n-            for (Iterator iter = additions.iterator(); iter.hasNext();)\n-                addIds.add(((DataCachePCData) iter.next()).getId());\n-            for (Iterator iter = newUpdates.iterator(); iter.hasNext();)\n-                upIds.add(((DataCachePCData) iter.next()).getId());\n-            for (Iterator iter = existingUpdates.iterator(); iter.hasNext();)\n-                exIds.add(((DataCachePCData) iter.next()).getId());\n-\n-            log.trace(s_loc.get(\"cache-commit\",\n-                new Object[]{ addIds, upIds, exIds, deletes }));\n-        }\n-    }\n-\n-    public boolean contains(Object key) {\n-        DataCachePCData o = getInternal(key);\n-        if (o != null && o.isTimedOut()) {\n-            o = null;\n-            removeInternal(key);\n-            if (log.isTraceEnabled())\n-                log.trace(s_loc.get(\"cache-timeout\", key));\n-        }\n-        return o != null;\n-    }\n-\n-    public BitSet containsAll(Collection keys) {\n-        if (keys.isEmpty())\n-            return EMPTY_BITSET;\n-\n-        BitSet set = new BitSet(keys.size());\n-        int i = 0;\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n-            if (contains(iter.next()))\n-                set.set(i);\n-        return set;\n-    }\n-\n-    public DataCachePCData get(Object key) {\n-        DataCachePCData o = getInternal(key);\n-        if (o != null && o.isTimedOut()) {\n-            o = null;\n-            removeInternal(key);\n-            if (log.isTraceEnabled())\n-                log.trace(s_loc.get(\"cache-timeout\", key));\n-        }\n-\n-        if (log.isTraceEnabled()) {\n-            if (o == null)\n-                log.trace(s_loc.get(\"cache-miss\", key));\n-            else\n-                log.trace(s_loc.get(\"cache-hit\", key));\n-        }\n-\n-        return o;\n-    }\n-\n-    public DataCachePCData put(DataCachePCData data) {\n-        DataCachePCData o = putInternal(data.getId(), data);\n-        if (log.isTraceEnabled())\n-            log.trace(s_loc.get(\"cache-put\", data.getId()));\n-        return (o == null || o.isTimedOut()) ? null : o;\n-    }\n-\n-    public void update(DataCachePCData data) {\n-        if (recacheUpdates())\n-            putInternal(data.getId(), data);\n-    }\n-\n-    public DataCachePCData remove(Object key) {\n-        DataCachePCData o = removeInternal(key);\n-        if (o != null && o.isTimedOut())\n-            o = null;\n-        if (log.isTraceEnabled()) {\n-            if (o == null)\n-                log.trace(s_loc.get(\"cache-remove-miss\", key));\n-            else\n-                log.trace(s_loc.get(\"cache-remove-hit\", key));\n-        }\n-        return o;\n-    }\n-\n-    public BitSet removeAll(Collection keys) {\n-        if (keys.isEmpty())\n-            return EMPTY_BITSET;\n-\n-        BitSet set = new BitSet(keys.size());\n-        int i = 0;\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n-            if (remove(iter.next()) != null)\n-                set.set(i);\n-        return set;\n-    }\n-\n-    /**\n-     * Remove the objects of the given class from the cache.\n-     */\n-    public void removeAll(Class cls, boolean subClasses) {\n-        removeAllInternal(cls, subClasses);\n-    }\n-\n-    public boolean pin(Object key) {\n-        boolean bool = pinInternal(key);\n-        if (log.isTraceEnabled()) {\n-            if (bool)\n-                log.trace(s_loc.get(\"cache-pin-hit\", key));\n-            else\n-                log.trace(s_loc.get(\"cache-pin-miss\", key));\n-        }\n-        return bool;\n-    }\n-\n-    public BitSet pinAll(Collection keys) {\n-        if (keys.isEmpty())\n-            return EMPTY_BITSET;\n-\n-        BitSet set = new BitSet(keys.size());\n-        int i = 0;\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n-            if (pin(iter.next()))\n-                set.set(i);\n-        return set;\n-    }\n-\n-    public void pinAll(Class cls, boolean subs) {\n-        if (log.isWarnEnabled())\n-            log.warn(s_loc.get(\"cache-class-pin\", getName()));\n-    }\n-\n-    public boolean unpin(Object key) {\n-        boolean bool = unpinInternal(key);\n-        if (log.isTraceEnabled()) {\n-            if (bool)\n-                log.trace(s_loc.get(\"cache-unpin-hit\", key));\n-            else\n-                log.trace(s_loc.get(\"cache-unpin-miss\", key));\n-        }\n-        return bool;\n-    }\n-\n-    public BitSet unpinAll(Collection keys) {\n-        if (keys.isEmpty())\n-            return EMPTY_BITSET;\n-\n-        BitSet set = new BitSet(keys.size());\n-        int i = 0;\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n-            if (unpin(iter.next()))\n-                set.set(i);\n-        return set;\n-    }\n-\n-    public void unpinAll(Class cls, boolean subs) {\n-        if (log.isWarnEnabled())\n-            log.warn(s_loc.get(\"cache-class-unpin\", getName()));\n-    }\n-\n-    public void clear() {\n-        clearInternal();\n-        if (log.isTraceEnabled())\n-            log.trace(s_loc.get(\"cache-clear\", getName()));\n-    }\n-\n-    public void close() {\n-        close(true);\n-    }\n-\n-    protected void close(boolean clear) {\n-        if (!_closed) {\n-            if (clear)\n-                clearInternal();\n-            _closed = true;\n-        }\n-    }\n-\n-    public boolean isClosed() {\n-        return _closed;\n-    }\n-\n-    public void addExpirationListener(ExpirationListener listen) {\n-        addListener(listen);\n-    }\n-\n-    public boolean removeExpirationListener(ExpirationListener listen) {\n-        return removeListener(listen);\n-    }\n-\n-    public String toString() {\n-        return \"[\" + super.toString() + \":\" + _name + \"]\";\n-    }\n-\n-    /**\n-     * This method is part of the {@link RemoteCommitListener} interface. If\n-     * your cache subclass relies on OpenJPA for clustering support, make it\n-     * implement <code>RemoteCommitListener</code>. This method will take\n-     * care of invalidating entries from remote commits.\n-     */\n-    public void afterCommit(RemoteCommitEvent event) {\n-        if (_closed)\n-            return;\n-\n-        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\n-            removeAllTypeNamesInternal(event.getUpdatedTypeNames());\n-            removeAllTypeNamesInternal(event.getDeletedTypeNames());\n-        } else {\n-            // drop all the committed OIDs, excepting brand\n-            // new OIDs. brand new OIDs either won't be in\n-            // the cache, or if they are, will be more up to date\n-            removeAllInternal(event.getUpdatedObjectIds());\n-            removeAllInternal(event.getDeletedObjectIds());\n-        }\n-    }\n-\n-    /**\n-     * Invoke when a key is removed from this cache. Propagates the\n-     * expiration event on to all expiration listeners registered\n-     * with this class.\n-     */\n-    protected void keyRemoved(Object key, boolean expired) {\n-        // Notify any expiration listeners of the expiration.\n-        if (hasListeners())\n-            fireEvent(new ExpirationEvent(this, key, expired));\n-\n-        if (expired && log.isTraceEnabled())\n-            log.trace(s_loc.get(\"cache-expired\", key));\n-    }\n-\n-    /**\n-     * Return <code>true</code> if updates to data already in the\n-     * cache (either in {@link #commit} or the {@link #update})\n-     * should be put back into the cache. Returns false by default.\n-     */\n-    protected boolean recacheUpdates() {\n-        return false;\n-    }\n-\n-    /**\n-     * Return the object for the given oid.\n-     */\n-    protected abstract DataCachePCData getInternal(Object oid);\n-\n-    /**\n-     * Add the given object to the cache, returning the old object under the\n-     * given oid.\n-     */\n-    protected abstract DataCachePCData putInternal(Object oid,\n-        DataCachePCData pc);\n-\n-    /**\n-     * All all of the given objects to the cache.\n-     */\n-    protected void putAllInternal(Collection pcs) {\n-        DataCachePCData pc;\n-        for (Iterator iter = pcs.iterator(); iter.hasNext();) {\n-            pc = (DataCachePCData) iter.next();\n-            putInternal(pc.getId(), pc);\n-        }\n-    }\n-\n-    /**\n-     * Remove the object under the given oid from the cache.\n-     */\n-    protected abstract DataCachePCData removeInternal(Object oid);\n-\n-    /**\n-     * Evict objects in cache by class.\n-     */\n-    protected abstract void removeAllInternal(Class cls, boolean subclasses);\n-\n-    /**\n-     * Remove all objects under the given oids from the cache.\n-     */\n-    protected void removeAllInternal(Collection oids) {\n-        for (Iterator iter = oids.iterator(); iter.hasNext();)\n-            removeInternal(iter.next());\n-    }\n-\n-    /**\n-     * Remove all objects of the given class names from the cache.\n-     */\n-    protected void removeAllTypeNamesInternal(Collection classNames) {\n-        Collection classes = Caches.addTypesByName(conf, classNames, null);\n-        if (classes == null)\n-            return;\n-\n-        Class cls;\n-        for (Iterator iter = classes.iterator(); iter.hasNext();) {\n-            cls = (Class) iter.next();\n-            if (log.isTraceEnabled())\n-                log.trace(s_loc.get(\"cache-removeclass\", cls.getName()));\n-            removeAllInternal(cls, false);\n-        }\n-    }\n-\n-    /**\n-     * Clear the cache.\n-     */\n-    protected abstract void clearInternal();\n-\n-    /**\n-     * Pin an object to the cache.\n-     */\n-    protected abstract boolean pinInternal(Object oid);\n-\n-    /**\n-     * Unpin an object from the cache.\n-     */\n-    protected abstract boolean unpinInternal(Object oid);\n-\n-    // ---------- Configurable implementation ----------\n-\n-    public void setConfiguration(Configuration conf) {\n-        this.conf = (OpenJPAConfiguration) conf;\n-        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\n-    }\n-\n-    public void startConfiguration() {\n-    }\n-\n-    public void endConfiguration() {\n-        if (_name == null)\n-            setName(NAME_DEFAULT);\n-    }\n-\n-    // ---------- AbstractEventManager implementation ----------\n-\n-    protected void fireEvent(Object event, Object listener) {\n-        ExpirationListener listen = (ExpirationListener) listener;\n-        ExpirationEvent ev = (ExpirationEvent) event;\n-        try {\n-            listen.onExpire(ev);\n-        } catch (Exception e) {\n-            if (log.isWarnEnabled())\n-                log.warn(s_loc.get(\"exp-listener-ex\"), e);\n-\t\t}\n-\t}\n-\n-    /**\n-     * Returns the objects for the given key List.\n-     */\n-    public Map getAll(List keys) {\n-        Map resultMap = new HashMap(keys.size());\n-        for(int i=0; i<keys.size(); i++)\n-            resultMap.put(keys.get(i), get(keys.get(i)));\n-        return resultMap;\n-    }\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.BitSet;\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.event.RemoteCommitEvent;\r\n+import org.apache.openjpa.event.RemoteCommitListener;\r\n+import org.apache.openjpa.lib.conf.Configurable;\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\r\n+\r\n+/**\r\n+ * Abstract {@link DataCache} implementation that provides various\r\n+ * statistics, logging, and timeout functionality common across cache\r\n+ * implementations.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ */\r\n+public abstract class AbstractDataCache\r\n+    extends AbstractConcurrentEventManager\r\n+    implements DataCache, Configurable {\r\n+\r\n+    private static final BitSet EMPTY_BITSET = new BitSet(0);\r\n+\r\n+    private static final Localizer s_loc =\r\n+        Localizer.forPackage(AbstractDataCache.class);\r\n+\r\n+    /**\r\n+     * The configuration set by the system.\r\n+     */\r\n+    protected OpenJPAConfiguration conf;\r\n+\r\n+    /**\r\n+     * The log to use.\r\n+     */\r\n+    protected Log log;\r\n+\r\n+    private String _name = null;\r\n+    private boolean _closed = false;\r\n+    private String _schedule = null;\r\n+\r\n+    public String getName() {\r\n+        return _name;\r\n+    }\r\n+\r\n+    public void setName(String name) {\r\n+        _name = name;\r\n+    }\r\n+\r\n+    public String getEvictionSchedule() {\r\n+        return _schedule;\r\n+    }\r\n+\r\n+    public void setEvictionSchedule(String s) {\r\n+        _schedule = s;\r\n+    }\r\n+\r\n+    public void initialize(DataCacheManager manager) {\r\n+        if (_schedule != null && !\"\".equals(_schedule)) {\r\n+            DataCacheScheduler scheduler = manager.getDataCacheScheduler();\r\n+            if (scheduler != null)\r\n+                scheduler.scheduleEviction(this, _schedule);\r\n+        }\r\n+    }\r\n+\r\n+    public void commit(Collection additions, Collection newUpdates,\r\n+        Collection existingUpdates, Collection deletes) {\r\n+        // remove all objects in deletes list\r\n+        removeAllInternal(deletes);\r\n+\r\n+        // next, add all the new additions\r\n+        putAllInternal(additions);\r\n+        putAllInternal(newUpdates);\r\n+\r\n+        // possibly add the existing updates, depending on the\r\n+        // semantics of the cache, as dictated by recacheUpdates()\r\n+        if (recacheUpdates())\r\n+            putAllInternal(existingUpdates);\r\n+\r\n+        if (log.isTraceEnabled()) {\r\n+            Collection addIds = new ArrayList(additions.size());\r\n+            Collection upIds = new ArrayList(newUpdates.size());\r\n+            Collection exIds = new ArrayList(existingUpdates.size());\r\n+\r\n+            for (Iterator iter = additions.iterator(); iter.hasNext();)\r\n+                addIds.add(((DataCachePCData) iter.next()).getId());\r\n+            for (Iterator iter = newUpdates.iterator(); iter.hasNext();)\r\n+                upIds.add(((DataCachePCData) iter.next()).getId());\r\n+            for (Iterator iter = existingUpdates.iterator(); iter.hasNext();)\r\n+                exIds.add(((DataCachePCData) iter.next()).getId());\r\n+\r\n+            log.trace(s_loc.get(\"cache-commit\",\r\n+                new Object[]{ addIds, upIds, exIds, deletes }));\r\n+        }\r\n+    }\r\n+\r\n+    public boolean contains(Object key) {\r\n+        DataCachePCData o = getInternal(key);\r\n+        if (o != null && o.isTimedOut()) {\r\n+            o = null;\r\n+            removeInternal(key);\r\n+            if (log.isTraceEnabled())\r\n+                log.trace(s_loc.get(\"cache-timeout\", key));\r\n+        }\r\n+        return o != null;\r\n+    }\r\n+\r\n+    public BitSet containsAll(Collection keys) {\r\n+        if (keys.isEmpty())\r\n+            return EMPTY_BITSET;\r\n+\r\n+        BitSet set = new BitSet(keys.size());\r\n+        int i = 0;\r\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n+            if (contains(iter.next()))\r\n+                set.set(i);\r\n+        return set;\r\n+    }\r\n+\r\n+    public DataCachePCData get(Object key) {\r\n+        DataCachePCData o = getInternal(key);\r\n+        if (o != null && o.isTimedOut()) {\r\n+            o = null;\r\n+            removeInternal(key);\r\n+            if (log.isTraceEnabled())\r\n+                log.trace(s_loc.get(\"cache-timeout\", key));\r\n+        }\r\n+\r\n+        if (log.isTraceEnabled()) {\r\n+            if (o == null)\r\n+                log.trace(s_loc.get(\"cache-miss\", key));\r\n+            else\r\n+                log.trace(s_loc.get(\"cache-hit\", key));\r\n+        }\r\n+\r\n+        return o;\r\n+    }\r\n+\r\n+    public DataCachePCData put(DataCachePCData data) {\r\n+        DataCachePCData o = putInternal(data.getId(), data);\r\n+        if (log.isTraceEnabled())\r\n+            log.trace(s_loc.get(\"cache-put\", data.getId()));\r\n+        return (o == null || o.isTimedOut()) ? null : o;\r\n+    }\r\n+\r\n+    public void update(DataCachePCData data) {\r\n+        if (recacheUpdates())\r\n+            putInternal(data.getId(), data);\r\n+    }\r\n+\r\n+    public DataCachePCData remove(Object key) {\r\n+        DataCachePCData o = removeInternal(key);\r\n+        if (o != null && o.isTimedOut())\r\n+            o = null;\r\n+        if (log.isTraceEnabled()) {\r\n+            if (o == null)\r\n+                log.trace(s_loc.get(\"cache-remove-miss\", key));\r\n+            else\r\n+                log.trace(s_loc.get(\"cache-remove-hit\", key));\r\n+        }\r\n+        return o;\r\n+    }\r\n+\r\n+    public BitSet removeAll(Collection keys) {\r\n+        if (keys.isEmpty())\r\n+            return EMPTY_BITSET;\r\n+\r\n+        BitSet set = new BitSet(keys.size());\r\n+        int i = 0;\r\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n+            if (remove(iter.next()) != null)\r\n+                set.set(i);\r\n+        return set;\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove the objects of the given class from the cache.\r\n+     */\r\n+    public void removeAll(Class cls, boolean subClasses) {\r\n+        removeAllInternal(cls, subClasses);\r\n+    }\r\n+\r\n+    public boolean pin(Object key) {\r\n+        boolean bool = pinInternal(key);\r\n+        if (log.isTraceEnabled()) {\r\n+            if (bool)\r\n+                log.trace(s_loc.get(\"cache-pin-hit\", key));\r\n+            else\r\n+                log.trace(s_loc.get(\"cache-pin-miss\", key));\r\n+        }\r\n+        return bool;\r\n+    }\r\n+\r\n+    public BitSet pinAll(Collection keys) {\r\n+        if (keys.isEmpty())\r\n+            return EMPTY_BITSET;\r\n+\r\n+        BitSet set = new BitSet(keys.size());\r\n+        int i = 0;\r\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n+            if (pin(iter.next()))\r\n+                set.set(i);\r\n+        return set;\r\n+    }\r\n+\r\n+    public void pinAll(Class cls, boolean subs) {\r\n+        if (log.isWarnEnabled())\r\n+            log.warn(s_loc.get(\"cache-class-pin\", getName()));\r\n+    }\r\n+\r\n+    public boolean unpin(Object key) {\r\n+        boolean bool = unpinInternal(key);\r\n+        if (log.isTraceEnabled()) {\r\n+            if (bool)\r\n+                log.trace(s_loc.get(\"cache-unpin-hit\", key));\r\n+            else\r\n+                log.trace(s_loc.get(\"cache-unpin-miss\", key));\r\n+        }\r\n+        return bool;\r\n+    }\r\n+\r\n+    public BitSet unpinAll(Collection keys) {\r\n+        if (keys.isEmpty())\r\n+            return EMPTY_BITSET;\r\n+\r\n+        BitSet set = new BitSet(keys.size());\r\n+        int i = 0;\r\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n+            if (unpin(iter.next()))\r\n+                set.set(i);\r\n+        return set;\r\n+    }\r\n+\r\n+    public void unpinAll(Class cls, boolean subs) {\r\n+        if (log.isWarnEnabled())\r\n+            log.warn(s_loc.get(\"cache-class-unpin\", getName()));\r\n+    }\r\n+\r\n+    public void clear() {\r\n+        clearInternal();\r\n+        if (log.isTraceEnabled())\r\n+            log.trace(s_loc.get(\"cache-clear\", getName()));\r\n+    }\r\n+\r\n+    public void close() {\r\n+        close(true);\r\n+    }\r\n+\r\n+    protected void close(boolean clear) {\r\n+        if (!_closed) {\r\n+            if (clear)\r\n+                clearInternal();\r\n+            _closed = true;\r\n+        }\r\n+    }\r\n+\r\n+    public boolean isClosed() {\r\n+        return _closed;\r\n+    }\r\n+\r\n+    public void addExpirationListener(ExpirationListener listen) {\r\n+        addListener(listen);\r\n+    }\r\n+\r\n+    public boolean removeExpirationListener(ExpirationListener listen) {\r\n+        return removeListener(listen);\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        return \"[\" + super.toString() + \":\" + _name + \"]\";\r\n+    }\r\n+\r\n+    /**\r\n+     * This method is part of the {@link RemoteCommitListener} interface. If\r\n+     * your cache subclass relies on OpenJPA for clustering support, make it\r\n+     * implement <code>RemoteCommitListener</code>. This method will take\r\n+     * care of invalidating entries from remote commits.\r\n+     */\r\n+    public void afterCommit(RemoteCommitEvent event) {\r\n+        if (_closed)\r\n+            return;\r\n+\r\n+        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\r\n+            removeAllTypeNamesInternal(event.getUpdatedTypeNames());\r\n+            removeAllTypeNamesInternal(event.getDeletedTypeNames());\r\n+        } else {\r\n+            // drop all the committed OIDs, excepting brand\r\n+            // new OIDs. brand new OIDs either won't be in\r\n+            // the cache, or if they are, will be more up to date\r\n+            removeAllInternal(event.getUpdatedObjectIds());\r\n+            removeAllInternal(event.getDeletedObjectIds());\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Invoke when a key is removed from this cache. Propagates the\r\n+     * expiration event on to all expiration listeners registered\r\n+     * with this class.\r\n+     */\r\n+    protected void keyRemoved(Object key, boolean expired) {\r\n+        // Notify any expiration listeners of the expiration.\r\n+        if (hasListeners())\r\n+            fireEvent(new ExpirationEvent(this, key, expired));\r\n+\r\n+        if (expired && log.isTraceEnabled())\r\n+            log.trace(s_loc.get(\"cache-expired\", key));\r\n+    }\r\n+\r\n+    /**\r\n+     * Return <code>true</code> if updates to data already in the\r\n+     * cache (either in {@link #commit} or the {@link #update})\r\n+     * should be put back into the cache. Returns false by default.\r\n+     */\r\n+    protected boolean recacheUpdates() {\r\n+        return false;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the object for the given oid.\r\n+     */\r\n+    protected abstract DataCachePCData getInternal(Object oid);\r\n+\r\n+    /**\r\n+     * Add the given object to the cache, returning the old object under the\r\n+     * given oid.\r\n+     */\r\n+    protected abstract DataCachePCData putInternal(Object oid,\r\n+        DataCachePCData pc);\r\n+\r\n+    /**\r\n+     * All all of the given objects to the cache.\r\n+     */\r\n+    protected void putAllInternal(Collection pcs) {\r\n+        DataCachePCData pc;\r\n+        for (Iterator iter = pcs.iterator(); iter.hasNext();) {\r\n+            pc = (DataCachePCData) iter.next();\r\n+            putInternal(pc.getId(), pc);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove the object under the given oid from the cache.\r\n+     */\r\n+    protected abstract DataCachePCData removeInternal(Object oid);\r\n+\r\n+    /**\r\n+     * Evict objects in cache by class.\r\n+     */\r\n+    protected abstract void removeAllInternal(Class cls, boolean subclasses);\r\n+\r\n+    /**\r\n+     * Remove all objects under the given oids from the cache.\r\n+     */\r\n+    protected void removeAllInternal(Collection oids) {\r\n+        for (Iterator iter = oids.iterator(); iter.hasNext();)\r\n+            removeInternal(iter.next());\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove all objects of the given class names from the cache.\r\n+     */\r\n+    protected void removeAllTypeNamesInternal(Collection classNames) {\r\n+        Collection classes = Caches.addTypesByName(conf, classNames, null);\r\n+        if (classes == null)\r\n+            return;\r\n+\r\n+        Class cls;\r\n+        for (Iterator iter = classes.iterator(); iter.hasNext();) {\r\n+            cls = (Class) iter.next();\r\n+            if (log.isTraceEnabled())\r\n+                log.trace(s_loc.get(\"cache-removeclass\", cls.getName()));\r\n+            removeAllInternal(cls, false);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Clear the cache.\r\n+     */\r\n+    protected abstract void clearInternal();\r\n+\r\n+    /**\r\n+     * Pin an object to the cache.\r\n+     */\r\n+    protected abstract boolean pinInternal(Object oid);\r\n+\r\n+    /**\r\n+     * Unpin an object from the cache.\r\n+     */\r\n+    protected abstract boolean unpinInternal(Object oid);\r\n+\r\n+    // ---------- Configurable implementation ----------\r\n+\r\n+    public void setConfiguration(Configuration conf) {\r\n+        this.conf = (OpenJPAConfiguration) conf;\r\n+        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n+    }\r\n+\r\n+    public void startConfiguration() {\r\n+    }\r\n+\r\n+    public void endConfiguration() {\r\n+        if (_name == null)\r\n+            setName(NAME_DEFAULT);\r\n+    }\r\n+\r\n+    // ---------- AbstractEventManager implementation ----------\r\n+\r\n+    protected void fireEvent(Object event, Object listener) {\r\n+        ExpirationListener listen = (ExpirationListener) listener;\r\n+        ExpirationEvent ev = (ExpirationEvent) event;\r\n+        try {\r\n+            listen.onExpire(ev);\r\n+        } catch (Exception e) {\r\n+            if (log.isWarnEnabled())\r\n+                log.warn(s_loc.get(\"exp-listener-ex\"), e);\r\n+\t\t}\r\n+\t}\r\n+\r\n+    /**\r\n+     * Returns the objects for the given key List.\r\n+     */\r\n+    public Map getAll(List keys) {\r\n+        Map resultMap = new HashMap(keys.size());\r\n+        for(int i=0; i<keys.size(); i++)\r\n+            resultMap.put(keys.get(i), get(keys.get(i)));\r\n+        return resultMap;\r\n+    }\r\n+}\r"},{"sha":"6adbd8bc58e4e1ef1e2ea28e14188d64e73280e7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","status":"modified","additions":322,"deletions":322,"changes":644,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,322 +1,322 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.datacache;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Set;\n-\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\n-import org.apache.openjpa.event.RemoteCommitEvent;\n-import org.apache.openjpa.event.RemoteCommitListener;\n-import org.apache.openjpa.lib.conf.Configurable;\n-import org.apache.openjpa.lib.conf.Configuration;\n-import org.apache.openjpa.lib.log.Log;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashSet;\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.meta.MetaDataRepository;\n-import org.apache.openjpa.util.Id;\n-\n-/**\n- * Abstract {@link QueryCache} implementation that provides various\n- * statistics, logging, and timeout functionality common across cache\n- * implementations.\n- *\n- * @author Patrick Linskey\n- * @author Abe White\n- */\n-public abstract class AbstractQueryCache\n-    extends AbstractConcurrentEventManager \n-    implements QueryCache, Configurable {\n-\n-    private static final Localizer s_loc =\n-        Localizer.forPackage(AbstractQueryCache.class);\n-\n-    /**\n-     * The configuration set by the system.\n-     */\n-    protected OpenJPAConfiguration conf;\n-\n-    /**\n-     * The log to use.\n-     */\n-    protected Log log;\n-\n-    private boolean _closed = false;\n-\n-    public void initialize(DataCacheManager manager) {\n-    }\n-\n-    public void onTypesChanged(TypesChangedEvent ev) {\n-        writeLock();\n-        Collection keys = null;\n-        try {\n-            if (hasListeners())\n-                fireEvent(ev);\n-            keys = keySet();\n-        } finally {\n-            writeUnlock();\n-        }\n-\n-        QueryKey qk;\n-        List removes = null;\n-        for (Iterator iter = keys.iterator(); iter.hasNext();) {\n-            qk = (QueryKey) iter.next();\n-            if (qk.changeInvalidatesQuery(ev.getTypes())) {\n-                if (removes == null)\n-                    removes = new ArrayList();\n-                removes.add(qk);\n-            }\n-        }\n-        if (removes != null)\n-            removeAllInternal(removes);\n-    }\n-\n-    public QueryResult get(QueryKey key) {\n-        QueryResult o = getInternal(key);\n-        if (o != null && o.isTimedOut()) {\n-            o = null;\n-            removeInternal(key);\n-            if (log.isTraceEnabled())\n-                log.trace(s_loc.get(\"cache-timeout\", key));\n-        }\n-\n-        if (log.isTraceEnabled()) {\n-            if (o == null)\n-                log.trace(s_loc.get(\"cache-miss\", key));\n-            else\n-                log.trace(s_loc.get(\"cache-hit\", key));\n-        }\n-        return o;\n-    }\n-\n-    public QueryResult put(QueryKey qk, QueryResult oids) {\n-        QueryResult o = putInternal(qk, oids);\n-        if (log.isTraceEnabled())\n-            log.trace(s_loc.get(\"cache-put\", qk));\n-        return (o == null || o.isTimedOut()) ? null : o;\n-    }\n-\n-    public QueryResult remove(QueryKey key) {\n-        QueryResult o = removeInternal(key);\n-        if (o != null && o.isTimedOut())\n-            o = null;\n-        if (log.isTraceEnabled()) {\n-            if (o == null)\n-                log.trace(s_loc.get(\"cache-remove-miss\", key));\n-            else\n-                log.trace(s_loc.get(\"cache-remove-hit\", key));\n-        }\n-        return o;\n-    }\n-\n-    public boolean pin(QueryKey key) {\n-        boolean bool = pinInternal(key);\n-        if (log.isTraceEnabled()) {\n-            if (bool)\n-                log.trace(s_loc.get(\"cache-pin-hit\", key));\n-            else\n-                log.trace(s_loc.get(\"cache-pin-miss\", key));\n-        }\n-        return bool;\n-    }\n-\n-    public boolean unpin(QueryKey key) {\n-        boolean bool = unpinInternal(key);\n-        if (log.isTraceEnabled()) {\n-            if (bool)\n-                log.trace(s_loc.get(\"cache-unpin-hit\", key));\n-            else\n-                log.trace(s_loc.get(\"cache-unpin-miss\", key));\n-        }\n-        return bool;\n-    }\n-\n-    public void clear() {\n-        clearInternal();\n-        if (log.isTraceEnabled())\n-            log.trace(s_loc.get(\"cache-clear\", \"<query-cache>\"));\n-    }\n-\n-    public void close() {\n-        close(true);\n-    }\n-\n-    protected void close(boolean clear) {\n-        if (!_closed) {\n-            if (clear)\n-                clearInternal();\n-            _closed = true;\n-        }\n-    }\n-\n-    public boolean isClosed() {\n-        return _closed;\n-    }\n-\n-    public void addTypesChangedListener(TypesChangedListener listen) {\n-        addListener(listen);\n-    }\n-\n-    public boolean removeTypesChangedListener(TypesChangedListener listen) {\n-        return removeListener(listen);\n-    }\n-\n-    /**\n-     * This method is part of the {@link RemoteCommitListener} interface. If\n-     * your cache subclass relies on OpenJPA for clustering support, make it\n-     * implement <code>RemoteCommitListener</code>. This method will take\n-     * care of invalidating entries from remote commits, by delegating to\n-     * {@link #onTypesChanged}.\n-     */\n-    public void afterCommit(RemoteCommitEvent event) {\n-        if (_closed)\n-            return;\n-\n-        // drop all committed classes\n-        Set classes = Caches.addTypesByName(conf,\n-            event.getPersistedTypeNames(), null);\n-        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\n-            classes = Caches.addTypesByName(conf, event.getUpdatedTypeNames(),\n-                classes);\n-            classes = Caches.addTypesByName(conf, event.getDeletedTypeNames(),\n-                classes);\n-        } else {\n-            classes = addTypes(event.getUpdatedObjectIds(), classes);\n-            classes = addTypes(event.getDeletedObjectIds(), classes);\n-        }\n-        if (classes != null)\n-            onTypesChanged(new TypesChangedEvent(this, classes));\n-    }\n-\n-    /**\n-     * Build up a set of classes for the given oids.\n-     */\n-    private Set addTypes(Collection oids, Set classes) {\n-        if (oids.isEmpty())\n-            return classes;\n-        if (classes == null)\n-            classes = new HashSet();\n-\n-        MetaDataRepository repos = conf.getMetaDataRepositoryInstance();\n-        ClassMetaData meta;\n-        Object oid;\n-        for (Iterator itr = oids.iterator(); itr.hasNext();) {\n-            oid = itr.next();\n-            if (oid instanceof Id)\n-                classes.add(((Id) oid).getType());\n-            else {\n-                // ok if no metadata for oid; that just means the pc type\n-                // probably hasn't been loaded into this JVM yet, and therefore\n-                // there's no chance that it's in the cache anyway\n-                meta = repos.getMetaData(oid, null, false);\n-                if (meta != null)\n-                    classes.add(meta.getDescribedType());\n-            }\n-        }\n-        return classes;\n-    }\n-\n-    /**\n-     * Return a threadsafe view of the keys in this cache. This collection\n-     * must be iterable without risk of concurrent modification exceptions.\n-     * It does not have to implement contains() efficiently or use set\n-     * semantics.\n-     */\n-    protected abstract Collection keySet();\n-\n-    /**\n-     * Return the list for the given key.\n-     */\n-    protected abstract QueryResult getInternal(QueryKey qk);\n-\n-    /**\n-     * Add the given result to the cache, returning the old result under the\n-     * given key.\n-     */\n-    protected abstract QueryResult putInternal(QueryKey qk, QueryResult oids);\n-\n-    /**\n-     * Remove the result under the given key from the cache.\n-     */\n-    protected abstract QueryResult removeInternal(QueryKey qk);\n-\n-    /**\n-     * Remove all results under the given keys from the cache.\n-     */\n-    protected void removeAllInternal(Collection qks) {\n-        for (Iterator iter = qks.iterator(); iter.hasNext();)\n-            removeInternal((QueryKey) iter.next());\n-    }\n-\n-    /**\n-     * Clear the cache.\n-     */\n-    protected abstract void clearInternal();\n-\n-    /**\n-     * Pin an object to the cache.\n-     */\n-    protected abstract boolean pinInternal(QueryKey qk);\n-\n-    /**\n-     * Unpin an object from the cache.\n-     */\n-    protected abstract boolean unpinInternal(QueryKey qk);\n-\n-    // ---------- Configurable implementation ----------\n-\n-    public void setConfiguration(Configuration conf) {\n-        this.conf = (OpenJPAConfiguration) conf;\n-        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\n-    }\n-\n-    public void startConfiguration() {\n-    }\n-\n-    public void endConfiguration() {\n-    }\n-\n-    // ---------- AbstractEventManager implementation ----------\n-\n-    protected void fireEvent(Object event, Object listener) {\n-        TypesChangedListener listen = (TypesChangedListener) listener;\n-        TypesChangedEvent ev = (TypesChangedEvent) event;\n-        try {\n-            listen.onTypesChanged(ev);\n-        } catch (Exception e) {\n-            if (log.isWarnEnabled())\n-                log.warn(s_loc.get(\"exp-listener-ex\"), e);\n-        }\n-    }\n-\n-    /**\n-     * Individual query results will be registered as types changed\n-     * listeners. We want such query results to be gc'd once\n-     * the only reference is held by the list of expiration listeners.\n-     */\n-    protected Collection newListenerCollection() {\n-        return new ConcurrentReferenceHashSet (ConcurrentReferenceHashSet.WEAK);\n-\t}\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.HashSet;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Set;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.event.RemoteCommitEvent;\r\n+import org.apache.openjpa.event.RemoteCommitListener;\r\n+import org.apache.openjpa.lib.conf.Configurable;\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\r\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashSet;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+import org.apache.openjpa.util.Id;\r\n+\r\n+/**\r\n+ * Abstract {@link QueryCache} implementation that provides various\r\n+ * statistics, logging, and timeout functionality common across cache\r\n+ * implementations.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ */\r\n+public abstract class AbstractQueryCache\r\n+    extends AbstractConcurrentEventManager \r\n+    implements QueryCache, Configurable {\r\n+\r\n+    private static final Localizer s_loc =\r\n+        Localizer.forPackage(AbstractQueryCache.class);\r\n+\r\n+    /**\r\n+     * The configuration set by the system.\r\n+     */\r\n+    protected OpenJPAConfiguration conf;\r\n+\r\n+    /**\r\n+     * The log to use.\r\n+     */\r\n+    protected Log log;\r\n+\r\n+    private boolean _closed = false;\r\n+\r\n+    public void initialize(DataCacheManager manager) {\r\n+    }\r\n+\r\n+    public void onTypesChanged(TypesChangedEvent ev) {\r\n+        writeLock();\r\n+        Collection keys = null;\r\n+        try {\r\n+            if (hasListeners())\r\n+                fireEvent(ev);\r\n+            keys = keySet();\r\n+        } finally {\r\n+            writeUnlock();\r\n+        }\r\n+\r\n+        QueryKey qk;\r\n+        List removes = null;\r\n+        for (Iterator iter = keys.iterator(); iter.hasNext();) {\r\n+            qk = (QueryKey) iter.next();\r\n+            if (qk.changeInvalidatesQuery(ev.getTypes())) {\r\n+                if (removes == null)\r\n+                    removes = new ArrayList();\r\n+                removes.add(qk);\r\n+            }\r\n+        }\r\n+        if (removes != null)\r\n+            removeAllInternal(removes);\r\n+    }\r\n+\r\n+    public QueryResult get(QueryKey key) {\r\n+        QueryResult o = getInternal(key);\r\n+        if (o != null && o.isTimedOut()) {\r\n+            o = null;\r\n+            removeInternal(key);\r\n+            if (log.isTraceEnabled())\r\n+                log.trace(s_loc.get(\"cache-timeout\", key));\r\n+        }\r\n+\r\n+        if (log.isTraceEnabled()) {\r\n+            if (o == null)\r\n+                log.trace(s_loc.get(\"cache-miss\", key));\r\n+            else\r\n+                log.trace(s_loc.get(\"cache-hit\", key));\r\n+        }\r\n+        return o;\r\n+    }\r\n+\r\n+    public QueryResult put(QueryKey qk, QueryResult oids) {\r\n+        QueryResult o = putInternal(qk, oids);\r\n+        if (log.isTraceEnabled())\r\n+            log.trace(s_loc.get(\"cache-put\", qk));\r\n+        return (o == null || o.isTimedOut()) ? null : o;\r\n+    }\r\n+\r\n+    public QueryResult remove(QueryKey key) {\r\n+        QueryResult o = removeInternal(key);\r\n+        if (o != null && o.isTimedOut())\r\n+            o = null;\r\n+        if (log.isTraceEnabled()) {\r\n+            if (o == null)\r\n+                log.trace(s_loc.get(\"cache-remove-miss\", key));\r\n+            else\r\n+                log.trace(s_loc.get(\"cache-remove-hit\", key));\r\n+        }\r\n+        return o;\r\n+    }\r\n+\r\n+    public boolean pin(QueryKey key) {\r\n+        boolean bool = pinInternal(key);\r\n+        if (log.isTraceEnabled()) {\r\n+            if (bool)\r\n+                log.trace(s_loc.get(\"cache-pin-hit\", key));\r\n+            else\r\n+                log.trace(s_loc.get(\"cache-pin-miss\", key));\r\n+        }\r\n+        return bool;\r\n+    }\r\n+\r\n+    public boolean unpin(QueryKey key) {\r\n+        boolean bool = unpinInternal(key);\r\n+        if (log.isTraceEnabled()) {\r\n+            if (bool)\r\n+                log.trace(s_loc.get(\"cache-unpin-hit\", key));\r\n+            else\r\n+                log.trace(s_loc.get(\"cache-unpin-miss\", key));\r\n+        }\r\n+        return bool;\r\n+    }\r\n+\r\n+    public void clear() {\r\n+        clearInternal();\r\n+        if (log.isTraceEnabled())\r\n+            log.trace(s_loc.get(\"cache-clear\", \"<query-cache>\"));\r\n+    }\r\n+\r\n+    public void close() {\r\n+        close(true);\r\n+    }\r\n+\r\n+    protected void close(boolean clear) {\r\n+        if (!_closed) {\r\n+            if (clear)\r\n+                clearInternal();\r\n+            _closed = true;\r\n+        }\r\n+    }\r\n+\r\n+    public boolean isClosed() {\r\n+        return _closed;\r\n+    }\r\n+\r\n+    public void addTypesChangedListener(TypesChangedListener listen) {\r\n+        addListener(listen);\r\n+    }\r\n+\r\n+    public boolean removeTypesChangedListener(TypesChangedListener listen) {\r\n+        return removeListener(listen);\r\n+    }\r\n+\r\n+    /**\r\n+     * This method is part of the {@link RemoteCommitListener} interface. If\r\n+     * your cache subclass relies on OpenJPA for clustering support, make it\r\n+     * implement <code>RemoteCommitListener</code>. This method will take\r\n+     * care of invalidating entries from remote commits, by delegating to\r\n+     * {@link #onTypesChanged}.\r\n+     */\r\n+    public void afterCommit(RemoteCommitEvent event) {\r\n+        if (_closed)\r\n+            return;\r\n+\r\n+        // drop all committed classes\r\n+        Set classes = Caches.addTypesByName(conf,\r\n+            event.getPersistedTypeNames(), null);\r\n+        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\r\n+            classes = Caches.addTypesByName(conf, event.getUpdatedTypeNames(),\r\n+                classes);\r\n+            classes = Caches.addTypesByName(conf, event.getDeletedTypeNames(),\r\n+                classes);\r\n+        } else {\r\n+            classes = addTypes(event.getUpdatedObjectIds(), classes);\r\n+            classes = addTypes(event.getDeletedObjectIds(), classes);\r\n+        }\r\n+        if (classes != null)\r\n+            onTypesChanged(new TypesChangedEvent(this, classes));\r\n+    }\r\n+\r\n+    /**\r\n+     * Build up a set of classes for the given oids.\r\n+     */\r\n+    private Set addTypes(Collection oids, Set classes) {\r\n+        if (oids.isEmpty())\r\n+            return classes;\r\n+        if (classes == null)\r\n+            classes = new HashSet();\r\n+\r\n+        MetaDataRepository repos = conf.getMetaDataRepositoryInstance();\r\n+        ClassMetaData meta;\r\n+        Object oid;\r\n+        for (Iterator itr = oids.iterator(); itr.hasNext();) {\r\n+            oid = itr.next();\r\n+            if (oid instanceof Id)\r\n+                classes.add(((Id) oid).getType());\r\n+            else {\r\n+                // ok if no metadata for oid; that just means the pc type\r\n+                // probably hasn't been loaded into this JVM yet, and therefore\r\n+                // there's no chance that it's in the cache anyway\r\n+                meta = repos.getMetaData(oid, null, false);\r\n+                if (meta != null)\r\n+                    classes.add(meta.getDescribedType());\r\n+            }\r\n+        }\r\n+        return classes;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a threadsafe view of the keys in this cache. This collection\r\n+     * must be iterable without risk of concurrent modification exceptions.\r\n+     * It does not have to implement contains() efficiently or use set\r\n+     * semantics.\r\n+     */\r\n+    protected abstract Collection keySet();\r\n+\r\n+    /**\r\n+     * Return the list for the given key.\r\n+     */\r\n+    protected abstract QueryResult getInternal(QueryKey qk);\r\n+\r\n+    /**\r\n+     * Add the given result to the cache, returning the old result under the\r\n+     * given key.\r\n+     */\r\n+    protected abstract QueryResult putInternal(QueryKey qk, QueryResult oids);\r\n+\r\n+    /**\r\n+     * Remove the result under the given key from the cache.\r\n+     */\r\n+    protected abstract QueryResult removeInternal(QueryKey qk);\r\n+\r\n+    /**\r\n+     * Remove all results under the given keys from the cache.\r\n+     */\r\n+    protected void removeAllInternal(Collection qks) {\r\n+        for (Iterator iter = qks.iterator(); iter.hasNext();)\r\n+            removeInternal((QueryKey) iter.next());\r\n+    }\r\n+\r\n+    /**\r\n+     * Clear the cache.\r\n+     */\r\n+    protected abstract void clearInternal();\r\n+\r\n+    /**\r\n+     * Pin an object to the cache.\r\n+     */\r\n+    protected abstract boolean pinInternal(QueryKey qk);\r\n+\r\n+    /**\r\n+     * Unpin an object from the cache.\r\n+     */\r\n+    protected abstract boolean unpinInternal(QueryKey qk);\r\n+\r\n+    // ---------- Configurable implementation ----------\r\n+\r\n+    public void setConfiguration(Configuration conf) {\r\n+        this.conf = (OpenJPAConfiguration) conf;\r\n+        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n+    }\r\n+\r\n+    public void startConfiguration() {\r\n+    }\r\n+\r\n+    public void endConfiguration() {\r\n+    }\r\n+\r\n+    // ---------- AbstractEventManager implementation ----------\r\n+\r\n+    protected void fireEvent(Object event, Object listener) {\r\n+        TypesChangedListener listen = (TypesChangedListener) listener;\r\n+        TypesChangedEvent ev = (TypesChangedEvent) event;\r\n+        try {\r\n+            listen.onTypesChanged(ev);\r\n+        } catch (Exception e) {\r\n+            if (log.isWarnEnabled())\r\n+                log.warn(s_loc.get(\"exp-listener-ex\"), e);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Individual query results will be registered as types changed\r\n+     * listeners. We want such query results to be gc'd once\r\n+     * the only reference is held by the list of expiration listeners.\r\n+     */\r\n+    protected Collection newListenerCollection() {\r\n+        return new ConcurrentReferenceHashSet (ConcurrentReferenceHashSet.WEAK);\r\n+\t}\r\n+}\r"},{"sha":"6224fe80c510fc51211971195b338796e746c23d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","status":"modified","additions":248,"deletions":248,"changes":496,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,248 +1,248 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.datacache;\n-\n-import java.security.AccessController;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.Calendar;\n-import java.util.Date;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.StringTokenizer;\n-\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\n-import org.apache.openjpa.lib.log.Log;\n-import org.apache.openjpa.lib.util.J2DoPrivHelper;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n-import org.apache.openjpa.util.InvalidStateException;\n-import org.apache.openjpa.util.UserException;\n-import serp.util.Strings;\n-\n-/**\n- * Cron-style cache eviction. Understands schedules based on cron format:\n- * <code>minute hour mday month wday</code>\n- * For example:\n- * <code>15,30 6,19 2,10 1 2 </code>\n- * Would run at 15 and 30 past the 6AM and 7PM, on the 2nd and 10th\n- * of January when its a Monday.\n- *\n- * @author Steve Kim\n- */\n-public class DataCacheScheduler\n-    implements Runnable {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (DataCacheScheduler.class);\n-\n-    private Map _caches = new ConcurrentHashMap();\n-    private boolean _stop = false;\n-    private int _interval = 2;\n-    private Log _log;\n-    private Thread _thread;\n-\n-    public DataCacheScheduler(OpenJPAConfiguration conf) {\n-        _log = conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_DATACACHE);\n-    }\n-\n-    /**\n-     * The interval time in minutes between cache checks. Defaults to 2.\n-     */\n-    public int getInterval() {\n-        return _interval;\n-    }\n-\n-    /**\n-     * The interval time in minutes between cache checks. Defaults to 2.\n-     */\n-    public void setInterval(int interval) {\n-        _interval = interval;\n-    }\n-\n-    /**\n-     * Stop the associated thread if there and stop the current runnable.\n-     */\n-    public synchronized void stop() {\n-        _stop = true;\n-    }\n-\n-    private boolean isStopped() {\n-        return _stop;\n-    }\n-\n-    /**\n-     * Schedule the given cache for eviction. Starts the scheduling thread\n-     * if not started.\n-     */\n-    public synchronized void scheduleEviction(DataCache cache, String times) {\n-        if (times == null)\n-            return;\n-\n-        Schedule schedule = new Schedule(times);\n-        _caches.put(cache, schedule);\n-        _stop = false;\n-        if (_thread == null) {\n-            _thread = (Thread) AccessController.doPrivileged(J2DoPrivHelper\n-                .newDaemonThreadAction(this, _loc.get(\"scheduler-name\")\n-                    .getMessage()));\n-            _thread.start();\n-            if (_log.isTraceEnabled())\n-                _log.trace(_loc.get(\"scheduler-start\", _thread.getName()));\n-        }\n-    }\n-\n-    /**\n-     * Remove the given cache from scheduling.\n-     */\n-    public synchronized void removeFromSchedule(DataCache cache) {\n-        _caches.remove(cache);\n-        if (_caches.size() == 0)\n-            stop();\n-    }\n-\n-    public void run() {\n-        if (_log.isTraceEnabled())\n-            _log.trace(_loc.get(\"scheduler-interval\", _interval + \"\"));\n-\n-        Date lastRun = new Date();\n-        DateFormat fom = new SimpleDateFormat(\"E HH:mm:ss\");\n-        while (!isStopped()) {\n-            try {\n-                Thread.sleep(_interval * 60 * 1000);\n-\n-                Date now = new Date();\n-                DataCache cache;\n-                Schedule schedule;\n-                Map.Entry entry;\n-                for (Iterator i = _caches.entrySet().iterator(); i.hasNext();) {\n-                    entry = (Map.Entry) i.next();\n-                    cache = (DataCache) entry.getKey();\n-                    schedule = (Schedule) entry.getValue();\n-                    if (schedule.matches(lastRun, now)) {\n-                        if (_log.isTraceEnabled())\n-                            _log.trace(_loc.get(\"scheduler-clear\",\n-                                cache.getName(), fom.format(now)));\n-                        evict(cache);\n-                    }\n-                }\n-                lastRun = now;\n-            } catch (Exception e) {\n-                throw new InvalidStateException(_loc.get(\"scheduler-fail\"), e).\n-                    setFatal(true);\n-            }\n-        }\n-\n-        _log.info(_loc.get(\"scheduler-stop\"));\n-        synchronized (this) {\n-            if (isStopped())\n-                _thread = null; // be sure to deref the thread so it can restart\n-        }\n-    }\n-\n-    protected void evict(DataCache cache) {\n-        cache.clear();\n-    }\n-\n-    /**\n-     * Simple class which represents the given time schedule.\n-     */\n-    private static class Schedule {\n-\n-        static final int[] WILDCARD = new int[0];\n-        static final int[] UNITS = {\n-            Calendar.MONTH,\n-            Calendar.DAY_OF_MONTH,\n-            Calendar.DAY_OF_WEEK,\n-            Calendar.HOUR_OF_DAY,\n-            Calendar.MINUTE\n-        };\n-        final int[] month;\n-        final int[] dayOfMonth;\n-        final int[] dayOfWeek;\n-        final int[] hour;\n-        final int[] min;\n-\n-        public Schedule(String date) {\n-            StringTokenizer token = new StringTokenizer(date, \" \\t\");\n-            if (token.countTokens() != 5)\n-                throw new UserException(_loc.get(\"bad-count\", date)).\n-                    setFatal(true);\n-            try {\n-                min = parse(token.nextToken(), 0, 60);\n-                hour = parse(token.nextToken(), 0, 24);\n-                dayOfMonth = parse(token.nextToken(), 1, 31);\n-                month = parse(token.nextToken(), 1, 13);\n-                dayOfWeek = parse(token.nextToken(), 1, 8);\n-            } catch (Throwable t) {\n-                throw new UserException(_loc.get(\"bad-schedule\", date), t).\n-                    setFatal(true);\n-            }\n-        }\n-\n-        private int[] parse(String token, int min, int max) {\n-            if (\"*\".equals(token.trim()))\n-                return WILDCARD;\n-            String[] tokens = Strings.split(token, \",\", 0);\n-            int [] times = new int[tokens.length];\n-            for (int i = 0; i < tokens.length; i++) {\n-                try {\n-                    times[i] = Integer.parseInt(tokens[i]);\n-                } catch (Throwable t) {\n-                    throw new UserException(_loc.get(\"not-number\", token)).\n-                        setFatal(true);\n-                }\n-                if (times[i] < min || times[i] >= max)\n-                    throw new UserException(_loc.get(\"not-range\", token,\n-                        String.valueOf(min), String.valueOf(max))).\n-                        setFatal(true);\n-            }\n-            return times;\n-        }\n-\n-        boolean matches(Date last, Date now) {\n-            Calendar time = Calendar.getInstance();\n-            time.setTime(now);\n-            time.set(Calendar.SECOND, 0);\n-            time.set(Calendar.MILLISECOND, 0);\n-\n-            int[][] all =\n-                new int[][]{ month, dayOfMonth, dayOfWeek, hour, min };\n-            return matches(last, now, time, all, 0);\n-        }\n-\n-        private boolean matches(Date last, Date now, Calendar time,\n-            int[][] times, int depth) {\n-            if (depth == UNITS.length) {\n-                Date compare = time.getTime();\n-                return compare.compareTo(last) >= 0 &&\n-                    compare.compareTo(now) < 0;\n-            }\n-\n-            if (times[depth] != WILDCARD) {\n-                for (int i = 0; i < times[depth].length; i++) {\n-                    time.set(UNITS[depth], times[depth][i]);\n-                    if (matches(last, now, time, times, depth + 1))\n-                        return true;\n-                }\n-            }\n-            return matches(last, now, time, times, depth + 1);\n-\t\t}\n-\t}\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.security.AccessController;\r\n+import java.text.DateFormat;\r\n+import java.text.SimpleDateFormat;\r\n+import java.util.Calendar;\r\n+import java.util.Date;\r\n+import java.util.Iterator;\r\n+import java.util.Map;\r\n+import java.util.StringTokenizer;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import org.apache.openjpa.util.InvalidStateException;\r\n+import org.apache.openjpa.util.UserException;\r\n+import serp.util.Strings;\r\n+\r\n+/**\r\n+ * Cron-style cache eviction. Understands schedules based on cron format:\r\n+ * <code>minute hour mday month wday</code>\r\n+ * For example:\r\n+ * <code>15,30 6,19 2,10 1 2 </code>\r\n+ * Would run at 15 and 30 past the 6AM and 7PM, on the 2nd and 10th\r\n+ * of January when its a Monday.\r\n+ *\r\n+ * @author Steve Kim\r\n+ */\r\n+public class DataCacheScheduler\r\n+    implements Runnable {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (DataCacheScheduler.class);\r\n+\r\n+    private Map _caches = new ConcurrentHashMap();\r\n+    private boolean _stop = false;\r\n+    private int _interval = 2;\r\n+    private Log _log;\r\n+    private Thread _thread;\r\n+\r\n+    public DataCacheScheduler(OpenJPAConfiguration conf) {\r\n+        _log = conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n+    }\r\n+\r\n+    /**\r\n+     * The interval time in minutes between cache checks. Defaults to 2.\r\n+     */\r\n+    public int getInterval() {\r\n+        return _interval;\r\n+    }\r\n+\r\n+    /**\r\n+     * The interval time in minutes between cache checks. Defaults to 2.\r\n+     */\r\n+    public void setInterval(int interval) {\r\n+        _interval = interval;\r\n+    }\r\n+\r\n+    /**\r\n+     * Stop the associated thread if there and stop the current runnable.\r\n+     */\r\n+    public synchronized void stop() {\r\n+        _stop = true;\r\n+    }\r\n+\r\n+    private boolean isStopped() {\r\n+        return _stop;\r\n+    }\r\n+\r\n+    /**\r\n+     * Schedule the given cache for eviction. Starts the scheduling thread\r\n+     * if not started.\r\n+     */\r\n+    public synchronized void scheduleEviction(DataCache cache, String times) {\r\n+        if (times == null)\r\n+            return;\r\n+\r\n+        Schedule schedule = new Schedule(times);\r\n+        _caches.put(cache, schedule);\r\n+        _stop = false;\r\n+        if (_thread == null) {\r\n+            _thread = (Thread) AccessController.doPrivileged(J2DoPrivHelper\r\n+                .newDaemonThreadAction(this, _loc.get(\"scheduler-name\")\r\n+                    .getMessage()));\r\n+            _thread.start();\r\n+            if (_log.isTraceEnabled())\r\n+                _log.trace(_loc.get(\"scheduler-start\", _thread.getName()));\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove the given cache from scheduling.\r\n+     */\r\n+    public synchronized void removeFromSchedule(DataCache cache) {\r\n+        _caches.remove(cache);\r\n+        if (_caches.size() == 0)\r\n+            stop();\r\n+    }\r\n+\r\n+    public void run() {\r\n+        if (_log.isTraceEnabled())\r\n+            _log.trace(_loc.get(\"scheduler-interval\", _interval + \"\"));\r\n+\r\n+        Date lastRun = new Date();\r\n+        DateFormat fom = new SimpleDateFormat(\"E HH:mm:ss\");\r\n+        while (!isStopped()) {\r\n+            try {\r\n+                Thread.sleep(_interval * 60 * 1000);\r\n+\r\n+                Date now = new Date();\r\n+                DataCache cache;\r\n+                Schedule schedule;\r\n+                Map.Entry entry;\r\n+                for (Iterator i = _caches.entrySet().iterator(); i.hasNext();) {\r\n+                    entry = (Map.Entry) i.next();\r\n+                    cache = (DataCache) entry.getKey();\r\n+                    schedule = (Schedule) entry.getValue();\r\n+                    if (schedule.matches(lastRun, now)) {\r\n+                        if (_log.isTraceEnabled())\r\n+                            _log.trace(_loc.get(\"scheduler-clear\",\r\n+                                cache.getName(), fom.format(now)));\r\n+                        evict(cache);\r\n+                    }\r\n+                }\r\n+                lastRun = now;\r\n+            } catch (Exception e) {\r\n+                throw new InvalidStateException(_loc.get(\"scheduler-fail\"), e).\r\n+                    setFatal(true);\r\n+            }\r\n+        }\r\n+\r\n+        _log.info(_loc.get(\"scheduler-stop\"));\r\n+        synchronized (this) {\r\n+            if (isStopped())\r\n+                _thread = null; // be sure to deref the thread so it can restart\r\n+        }\r\n+    }\r\n+\r\n+    protected void evict(DataCache cache) {\r\n+        cache.clear();\r\n+    }\r\n+\r\n+    /**\r\n+     * Simple class which represents the given time schedule.\r\n+     */\r\n+    private static class Schedule {\r\n+\r\n+        static final int[] WILDCARD = new int[0];\r\n+        static final int[] UNITS = {\r\n+            Calendar.MONTH,\r\n+            Calendar.DAY_OF_MONTH,\r\n+            Calendar.DAY_OF_WEEK,\r\n+            Calendar.HOUR_OF_DAY,\r\n+            Calendar.MINUTE\r\n+        };\r\n+        final int[] month;\r\n+        final int[] dayOfMonth;\r\n+        final int[] dayOfWeek;\r\n+        final int[] hour;\r\n+        final int[] min;\r\n+\r\n+        public Schedule(String date) {\r\n+            StringTokenizer token = new StringTokenizer(date, \" \\t\");\r\n+            if (token.countTokens() != 5)\r\n+                throw new UserException(_loc.get(\"bad-count\", date)).\r\n+                    setFatal(true);\r\n+            try {\r\n+                min = parse(token.nextToken(), 0, 60);\r\n+                hour = parse(token.nextToken(), 0, 24);\r\n+                dayOfMonth = parse(token.nextToken(), 1, 31);\r\n+                month = parse(token.nextToken(), 1, 13);\r\n+                dayOfWeek = parse(token.nextToken(), 1, 8);\r\n+            } catch (Throwable t) {\r\n+                throw new UserException(_loc.get(\"bad-schedule\", date), t).\r\n+                    setFatal(true);\r\n+            }\r\n+        }\r\n+\r\n+        private int[] parse(String token, int min, int max) {\r\n+            if (\"*\".equals(token.trim()))\r\n+                return WILDCARD;\r\n+            String[] tokens = Strings.split(token, \",\", 0);\r\n+            int [] times = new int[tokens.length];\r\n+            for (int i = 0; i < tokens.length; i++) {\r\n+                try {\r\n+                    times[i] = Integer.parseInt(tokens[i]);\r\n+                } catch (Throwable t) {\r\n+                    throw new UserException(_loc.get(\"not-number\", token)).\r\n+                        setFatal(true);\r\n+                }\r\n+                if (times[i] < min || times[i] >= max)\r\n+                    throw new UserException(_loc.get(\"not-range\", token,\r\n+                        String.valueOf(min), String.valueOf(max))).\r\n+                        setFatal(true);\r\n+            }\r\n+            return times;\r\n+        }\r\n+\r\n+        boolean matches(Date last, Date now) {\r\n+            Calendar time = Calendar.getInstance();\r\n+            time.setTime(now);\r\n+            time.set(Calendar.SECOND, 0);\r\n+            time.set(Calendar.MILLISECOND, 0);\r\n+\r\n+            int[][] all =\r\n+                new int[][]{ month, dayOfMonth, dayOfWeek, hour, min };\r\n+            return matches(last, now, time, all, 0);\r\n+        }\r\n+\r\n+        private boolean matches(Date last, Date now, Calendar time,\r\n+            int[][] times, int depth) {\r\n+            if (depth == UNITS.length) {\r\n+                Date compare = time.getTime();\r\n+                return compare.compareTo(last) >= 0 &&\r\n+                    compare.compareTo(now) < 0;\r\n+            }\r\n+\r\n+            if (times[depth] != WILDCARD) {\r\n+                for (int i = 0; i < times[depth].length; i++) {\r\n+                    time.set(UNITS[depth], times[depth][i]);\r\n+                    if (matches(last, now, time, times, depth + 1))\r\n+                        return true;\r\n+                }\r\n+            }\r\n+            return matches(last, now, time, times, depth + 1);\r\n+\t\t}\r\n+\t}\r\n+}\r"},{"sha":"fa76f87bea5bec925be8ae667cfe484d765fb8f1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","previous_filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java"},{"sha":"505b5ff25e5777465e8ebc1530798393c94295d2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/InstrumentationFactory.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/InstrumentationFactory.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/InstrumentationFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/InstrumentationFactory.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","previous_filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/InstrumentationFactory.java"},{"sha":"e9aebb1bec88afddb415ad826185fbd91fd6d0d0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","status":"renamed","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -118,7 +118,8 @@\n         Set<Class> unspecified = null;\r\n         for (Iterator iter = classes.iterator(); iter.hasNext(); ) {\r\n             final Class cls = (Class) iter.next();\r\n-            final PCEnhancer enhancer = new PCEnhancer(conf, cls);\r\n+            final PCEnhancer enhancer =\r\n+                    new PCEnhancer((OpenJPAConfiguration) conf.clone(), cls);\r\n \r\n             enhancer.setBytecodeWriter(new BytecodeWriter() {\r\n                 public void write(BCClass bc) throws IOException {\r","previous_filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java"},{"sha":"b3a06960dab257da7a872ae8ef0ec35ad9e2451e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","previous_filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java"},{"sha":"8c189ee45efc67b140616a8e02a0d777eb65bb5f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","status":"modified","additions":1077,"deletions":1077,"changes":2154,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,1077 +1,1077 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.enhance;\n-\n-import java.util.BitSet;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.Map;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\n-import org.apache.openjpa.kernel.AbstractPCData;\n-import org.apache.openjpa.kernel.FetchConfiguration;\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\n-import org.apache.openjpa.kernel.PCData;\n-import org.apache.openjpa.kernel.StoreContext;\n-import org.apache.openjpa.lib.log.Log;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.meta.FieldMetaData;\n-import org.apache.openjpa.meta.JavaTypes;\n-import org.apache.openjpa.util.InternalException;\n-import serp.bytecode.BCClass;\n-import serp.bytecode.BCField;\n-import serp.bytecode.BCMethod;\n-import serp.bytecode.Code;\n-import serp.bytecode.Constants;\n-import serp.bytecode.ExceptionHandler;\n-import serp.bytecode.Instruction;\n-import serp.bytecode.JumpInstruction;\n-import serp.bytecode.LookupSwitchInstruction;\n-\n-/**\n- * Generates {@link PCData} instances which avoid primitve wrappers\n- * to optimize memory use and performance at the cost of slightly higher\n- * startup time.\n- *\n- * @author Steve Kim\n- * @nojavadoc\n- * @since 0.3.2\n- */\n-public class PCDataGenerator\n-    extends DynamicStorageGenerator {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (PCDataGenerator.class);\n-\n-    protected static final String POSTFIX = \"$openjpapcdata\";\n-\n-    private final Map _generated = new ConcurrentHashMap();\n-    private final OpenJPAConfiguration _conf;\n-    private final Log _log;\n-\n-    public PCDataGenerator(OpenJPAConfiguration conf) {\n-        _conf = conf;\n-        _log = _conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_ENHANCE);\n-    }\n-\n-    /**\n-     * Return the configuration.\n-     */\n-    public OpenJPAConfiguration getConfiguration() {\n-        return _conf;\n-    }\n-\n-    /**\n-     * Return a {@link PCData} instance for the given oid and metadata.\n-     */\n-    public PCData generatePCData(Object oid, ClassMetaData meta) {\n-        if (meta == null)\n-            return null;\n-        Class type = meta.getDescribedType();\n-        DynamicStorage storage = (DynamicStorage) _generated.get(type);\n-        if (storage == null) {\n-            storage = generateStorage(meta);\n-            _generated.put(type, storage);\n-            if (_log.isTraceEnabled())\n-                _log.trace(_loc.get(\"pcdata-created\", type.getName(), meta));\n-        }\n-        DynamicPCData data = (DynamicPCData) storage.newInstance();\n-        data.setId(oid);\n-        data.setStorageGenerator(this);\n-        finish(data, meta);\n-        return data;\n-    }\n-\n-    /**\n-     * Actually generate the factory instance.\n-     */\n-    private DynamicStorage generateStorage(ClassMetaData meta) {\n-        if (_log.isTraceEnabled())\n-            _log.trace(_loc.get(\"pcdata-generate\", meta));\n-\n-        FieldMetaData[] fields = meta.getFields();\n-        int[] types = new int[fields.length];\n-        for (int i = 0; i < types.length; i++)\n-            types[i] = replaceType(fields[i]);\n-        return generateStorage(types, meta);\n-    }\n-\n-    /**\n-     * Perform any final actions before the pcdata is returned to client code.\n-     */\n-    protected void finish(DynamicPCData data, ClassMetaData meta) {\n-    }\n-\n-    protected int getCreateFieldMethods(int typeCode) {\n-        if (typeCode >= JavaTypes.OBJECT)\n-            return POLICY_SILENT;\n-        // don't bother creating set/get<Primitive> methods\n-        return POLICY_EMPTY;\n-    }\n-\n-    protected void declareClasses(BCClass bc) {\n-        super.declareClasses(bc);\n-        bc.declareInterface(DynamicPCData.class);\n-        bc.setSuperclass(AbstractPCData.class);\n-    }\n-\n-    protected final String getClassName(Object obj) {\n-        return getUniqueName(((ClassMetaData) obj).getDescribedType());\n-    }\n-\n-    /**\n-     * Creates a unique name for the given type's pcdata implementation.\n-     */\n-    protected String getUniqueName(Class type) {\n-        return type.getName() + \"$\" + System.identityHashCode(type) + POSTFIX;\n-    }\n-\n-    protected final void decorate(Object obj, BCClass bc, int[] types) {\n-        super.decorate(obj, bc, types);\n-        ClassMetaData meta = (ClassMetaData) obj;\n-\n-        enhanceConstructor(bc);\n-        addBaseFields(bc);\n-        addImplDataMethods(bc, meta);\n-        addFieldImplDataMethods(bc, meta);\n-        addVersionMethods(bc);\n-        addGetType(bc, meta);\n-        addLoadMethod(bc, meta);\n-        addLoadWithFieldsMethod(bc, meta);\n-        addStoreMethods(bc, meta);\n-        addNewEmbedded(bc);\n-        addGetData(bc);\n-        decorate(bc, meta);\n-    }\n-\n-    /**\n-     * Apply additional decoration to generated class.\n-     */\n-    protected void decorate(BCClass bc, ClassMetaData meta) {\n-    }\n-\n-    /**\n-     * Enhance constructor to initialize fields\n-     */\n-    private void enhanceConstructor(BCClass bc) {\n-        BCMethod cons = bc.getDeclaredMethod(\"<init>\", (String[]) null);\n-        Code code = cons.getCode(false);\n-        code.afterLast();\n-        code.previous();\n-\n-        // private BitSet loaded = new BitSet();\n-        BCField loaded = addBeanField(bc, \"loaded\", BitSet.class);\n-        loaded.setFinal(true);\n-        code.aload().setThis();\n-        code.anew().setType(BitSet.class);\n-        code.dup();\n-        code.constant().setValue(bc.getFields().length);\n-        code.invokespecial().setMethod(BitSet.class, \"<init>\", void.class,\n-            new Class[]{ int.class });\n-        code.putfield().setField(loaded);\n-\n-        code.calculateMaxStack();\n-        code.calculateMaxLocals();\n-    }\n-\n-    /**\n-     * Have to load the type since it may not be available to the\n-     * same classloader (i.e. rar vs. ear). The context classloader\n-     * (i.e. the user app classloader) should be fine.\n-     */\n-    private void addGetType(BCClass bc, ClassMetaData meta) {\n-        BCField type = bc.declareField(\"type\", Class.class);\n-        type.setStatic(true);\n-        type.makePrivate();\n-        // public Class getType() {\n-        BCMethod getter = bc.declareMethod(\"getType\", Class.class, null);\n-        getter.makePublic();\n-        Code code = getter.getCode(true);\n-        // if (type == null) {\n-        // \t\ttry {\n-        // \t\t\ttype = Class.forName\n-        // \t\t\t\t(meta.getDescribedType().getName(), true,\n-        // \t\t\t\tThread.currentThread().getContextClassLoader());\n-        // \t\t} catch (ClassNotFoundException cnfe) {\n-        // \t\t\tthrow new InternalException();\n-        // \t\t}\n-        // }\n-        code.getstatic().setField(type);\n-\n-        Collection jumps = new LinkedList();\n-        jumps.add(code.ifnonnull());\n-        ExceptionHandler handler = code.addExceptionHandler();\n-\n-        handler.setTryStart(code.constant().setValue\n-            (meta.getDescribedType().getName()));\n-        code.constant().setValue(true);\n-        code.invokestatic().setMethod(Thread.class, \"currentThread\",\n-            Thread.class, null);\n-        code.invokevirtual().setMethod(Thread.class, \"getContextClassLoader\",\n-            ClassLoader.class, null);\n-        code.invokestatic().setMethod(Class.class, \"forName\", Class.class,\n-            new Class[]{ String.class, boolean.class, ClassLoader.class });\n-        code.putstatic().setField(type);\n-        Instruction go2 = code.go2();\n-        jumps.add(go2);\n-        handler.setTryEnd(go2);\n-        handler.setCatch(ClassNotFoundException.class);\n-        handler.setHandlerStart(throwException\n-            (code, InternalException.class));\n-        setTarget(code.getstatic().setField(type), jumps);\n-        code.areturn();\n-\n-        code.calculateMaxStack();\n-        code.calculateMaxLocals();\n-    }\n-\n-    /**\n-     * Declare standard dynamic pcdata fields.\n-     */\n-    private void addBaseFields(BCClass bc) {\n-        addBeanField(bc, \"id\", Object.class);\n-        BCField field = addBeanField(bc, \"storageGenerator\",\n-            PCDataGenerator.class);\n-        field.setAccessFlags(field.getAccessFlags()\n-            | Constants.ACCESS_TRANSIENT);\n-    }\n-\n-    /**\n-     * Add methods for loading and storing class-level impl data.\n-     */\n-    private void addImplDataMethods(BCClass bc, ClassMetaData meta) {\n-        // void storeImplData(OpenJPAStateManager);\n-        BCMethod meth = bc.declareMethod(\"storeImplData\", void.class,\n-            new Class[]{ OpenJPAStateManager.class });\n-        Code code = meth.getCode(true);\n-\n-        BCField impl = null;\n-        if (!usesImplData(meta))\n-            code.vreturn();\n-        else {\n-            // if (sm.isImplDataCacheable())\n-            // \t\tsetImplData(sm.getImplData());\n-            impl = addBeanField(bc, \"implData\", Object.class);\n-            code.aload().setParam(0);\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-                \"isImplDataCacheable\", boolean.class, null);\n-            JumpInstruction ifins = code.ifeq();\n-            code.aload().setThis();\n-            code.aload().setParam(0);\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-                \"getImplData\", Object.class, null);\n-            code.invokevirtual().setMethod(\"setImplData\", void.class,\n-                new Class[]{ Object.class });\n-            ifins.setTarget(code.vreturn());\n-        }\n-        code.calculateMaxStack();\n-        code.calculateMaxLocals();\n-\n-        // void loadImplData(OpenJPAStateManager);\n-        meth = bc.declareMethod(\"loadImplData\", void.class,\n-            new Class[]{ OpenJPAStateManager.class });\n-        code = meth.getCode(true);\n-        if (!usesImplData(meta))\n-            code.vreturn();\n-        else {\n-            // if (sm.getImplData() == null && implData != null)\n-            // \t\tsm.setImplData(impl, true);\n-            code.aload().setParam(0);\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-                \"getImplData\", Object.class, null);\n-            JumpInstruction ifins = code.ifnonnull();\n-            code.aload().setThis();\n-            code.getfield().setField(impl);\n-            JumpInstruction ifins2 = code.ifnull();\n-            code.aload().setParam(0);\n-            code.aload().setThis();\n-            code.getfield().setField(impl);\n-            code.constant().setValue(true);\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-                \"setImplData\", void.class,\n-                new Class[]{ Object.class, boolean.class });\n-            Instruction ins = code.vreturn();\n-            ifins.setTarget(ins);\n-            ifins2.setTarget(ins);\n-        }\n-        code.calculateMaxStack();\n-        code.calculateMaxLocals();\n-    }\n-\n-    /**\n-     * Add methods for loading and storing class-level impl data.\n-     */\n-    private void addFieldImplDataMethods(BCClass bc, ClassMetaData meta) {\n-        // public void loadImplData(OpenJPAStateManager sm, int i)\n-        BCMethod meth = bc.declareMethod(\"loadImplData\", void.class,\n-            new Class[]{ OpenJPAStateManager.class, int.class });\n-        meth.makePrivate();\n-        Code code = meth.getCode(true);\n-\n-        int count = countImplDataFields(meta);\n-        BCField impl = null;\n-        if (count == 0)\n-            code.vreturn();\n-        else {\n-            // Object[] fieldImpl\n-            impl = bc.declareField(\"fieldImpl\", Object[].class);\n-            impl.makePrivate();\n-\n-            // if (fieldImpl != null)\n-            code.aload().setThis();\n-            code.getfield().setField(impl);\n-            JumpInstruction ifins = code.ifnonnull();\n-            code.vreturn();\n-\n-            // Object obj = null;\n-            int obj = code.getNextLocalsIndex();\n-            ifins.setTarget(code.constant().setNull());\n-            code.astore().setLocal(obj);\n-\n-            // establish switch target, then move before it\n-            Instruction target = code.aload().setLocal(obj);\n-            code.previous();\n-\n-            // switch(i)\n-            code.iload().setParam(1);\n-            LookupSwitchInstruction lswitch = code.lookupswitch();\n-            FieldMetaData[] fields = meta.getFields();\n-            int cacheable = 0;\n-            for (int i = 0; i < fields.length; i++) {\n-                if (!usesImplData(fields[i]))\n-                    continue;\n-                // case x: obj = fieldImpl[y]; break;\n-                lswitch.addCase(i, code.aload().setThis());\n-                code.getfield().setField(impl);\n-                code.constant().setValue(cacheable++);\n-                code.aaload();\n-                code.astore().setLocal(obj);\n-                code.go2().setTarget(target);\n-            }\n-            lswitch.setDefaultTarget(target);\n-\n-            // if (obj != null)\n-            code.next();    // jump back over target\n-            ifins = code.ifnonnull();\n-            code.vreturn();\n-\n-            // sm.setImplData(index, impl);\n-            ifins.setTarget(code.aload().setParam(0));\n-            code.iload().setParam(1);\n-            code.aload().setLocal(obj);\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-                \"setImplData\", void.class,\n-                new Class[]{ int.class, Object.class });\n-            code.vreturn();\n-        }\n-        code.calculateMaxLocals();\n-        code.calculateMaxStack();\n-\n-        // void storeImplData(OpenJPAStateManager sm, int index, boolean loaded)\n-        meth = bc.declareMethod(\"storeImplData\", void.class,\n-            new Class[]{ OpenJPAStateManager.class, int.class, boolean.class });\n-        code = meth.getCode(true);\n-        if (count == 0)\n-            code.vreturn();\n-        else {\n-            // int arrIdx = -1;\n-            // switch(index)\n-            int arrIdx = code.getNextLocalsIndex();\n-            code.constant().setValue(-1);\n-            code.istore().setLocal(arrIdx);\n-            code.iload().setParam(1);\n-            LookupSwitchInstruction lswitch = code.lookupswitch();\n-\n-            // establish switch target, then move before it\n-            Instruction switchTarget = code.iload().setLocal(arrIdx);\n-            code.previous();\n-\n-            FieldMetaData[] fields = meta.getFields();\n-            int cacheable = 0;\n-            for (int i = 0; i < fields.length; i++) {\n-                if (!usesImplData(fields[i]))\n-                    continue;\n-                // case x: arrIdx = y; break;\n-                lswitch.addCase(i, code.constant().setValue(cacheable++));\n-                code.istore().setLocal(arrIdx);\n-                code.go2().setTarget(switchTarget);\n-            }\n-            lswitch.setDefaultTarget(switchTarget);\n-            code.next();    // step over switch target\n-\n-            // if (arrIdx != -1)\n-            code.constant().setValue(-1);\n-            JumpInstruction ifins = code.ificmpne();\n-            code.vreturn();\n-\n-            // create null target, then move before it\n-            Instruction nullTarget = code.aload().setThis();\n-            code.previous();\n-\n-            // if (loaded)\n-            ifins.setTarget(code.iload().setParam(2));\n-            code.ifeq().setTarget(nullTarget);\n-\n-            // Object obj = sm.getImplData(index)\n-            int obj = code.getNextLocalsIndex();\n-            code.aload().setParam(0);\n-            code.iload().setParam(1);\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-                \"getImplData\", Object.class, new Class[]{ int.class });\n-            code.astore().setLocal(obj);\n-\n-            // if (obj != null)\n-            code.aload().setLocal(obj);\n-            code.ifnull().setTarget(nullTarget);\n-\n-            // if (fieldImpl == null)\n-            // \t\tfieldImpl = new Object[fields];\n-            code.aload().setThis();\n-            code.getfield().setField(impl);\n-            ifins = code.ifnonnull();\n-            code.aload().setThis();\n-            code.constant().setValue(count);\n-            code.anewarray().setType(Object.class);\n-            code.putfield().setField(impl);\n-\n-            // fieldImpl[arrIdx] = obj;\n-            // return;\n-            ifins.setTarget(code.aload().setThis());\n-            code.getfield().setField(impl);\n-            code.iload().setLocal(arrIdx);\n-            code.aload().setLocal(obj);\n-            code.aastore();\n-            code.vreturn();\n-\n-            // if (fieldImpl != null)\n-            // \t\tfieldImpl[index] = null;\n-            code.next(); // step over nullTarget\n-            code.getfield().setField(impl);\n-            ifins = code.ifnonnull();\n-            code.vreturn();\n-            ifins.setTarget(code.aload().setThis());\n-            code.getfield().setField(impl);\n-            code.iload().setLocal(arrIdx);\n-            code.constant().setNull();\n-            code.aastore();\n-            code.vreturn();\n-        }\n-        code.calculateMaxStack();\n-        code.calculateMaxLocals();\n-    }\n-\n-    /**\n-     * Add methods for loading and storing version data.\n-     */\n-    protected void addVersionMethods(BCClass bc) {\n-        // void storeVersion(OpenJPAStateManager sm);\n-        addBeanField(bc, \"version\", Object.class);\n-        BCMethod meth = bc.declareMethod(\"storeVersion\", void.class,\n-            new Class[]{ OpenJPAStateManager.class });\n-        Code code = meth.getCode(true);\n-\n-        // version = sm.getVersion();\n-        code.aload().setThis();\n-        code.aload().setParam(0);\n-        code.invokeinterface()\n-            .setMethod(OpenJPAStateManager.class, \"getVersion\",\n-                Object.class, null);\n-        code.putfield().setField(\"version\", Object.class);\n-        code.vreturn();\n-        code.calculateMaxStack();\n-        code.calculateMaxLocals();\n-\n-        // void loadVersion(OpenJPAStateManager sm)\n-        meth = bc.declareMethod(\"loadVersion\", void.class,\n-            new Class[]{ OpenJPAStateManager.class });\n-        code = meth.getCode(true);\n-\n-        // if (sm.getVersion() == null)\n-        // \t\tsm.setVersion(version);\n-        code.aload().setParam(0);\n-        code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-            \"getVersion\", Object.class, null);\n-        JumpInstruction ifins = code.ifnonnull();\n-        code.aload().setParam(0);\n-        code.aload().setThis();\n-        code.getfield().setField(\"version\", Object.class);\n-        code.invokeinterface()\n-            .setMethod(OpenJPAStateManager.class, \"setVersion\",\n-                void.class, new Class[]{ Object.class });\n-        ifins.setTarget(code.vreturn());\n-        code.calculateMaxStack();\n-        code.calculateMaxLocals();\n-    }\n-\n-    private void addLoadMethod(BCClass bc, ClassMetaData meta) {\n-        // public void load(OpenJPAStateManager sm, FetchConfiguration fetch,\n-        // \t\tObject context)\n-        Code code = addLoadMethod(bc, false);\n-        FieldMetaData[] fmds = meta.getFields();\n-        Collection jumps = new LinkedList();\n-        Collection jumps2;\n-\t\t\n-        int local = code.getNextLocalsIndex();\n-        code.constant().setNull();\n-        code.astore().setLocal(local);\n-        int inter = code.getNextLocalsIndex();\n-        code.constant().setNull();\n-        code.astore().setLocal(inter);\n-\n-        int objectCount = 0;\n-        boolean intermediate;\n-        for (int i = 0; i < fmds.length; i++) {\n-            jumps2 = new LinkedList();\n-            intermediate = usesIntermediate(fmds[i]);\n-            setTarget(code.aload().setThis(), jumps);\n-            // if (loaded.get(i)) or (!loaded.get(i)) depending on inter resp\n-            code.getfield().setField(\"loaded\", BitSet.class);\n-            code.constant().setValue(i);\n-            code.invokevirtual().setMethod(BitSet.class, \"get\",\n-                boolean.class, new Class[]{ int.class });\n-            jumps.add(code.ifne());\n-\n-            if (intermediate)\n-                addLoadIntermediate(code, i, objectCount, jumps2, inter);\n-            jumps2.add(code.go2());\n-\n-            // if (fetch.requiresFetch(fmds[i])!=FetchConfiguration.FETCH_NONE)\n-            setTarget(code.aload().setParam(1), jumps);\n-            code.aload().setParam(0);\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-                \"getMetaData\", ClassMetaData.class, null);\n-            code.constant().setValue(fmds[i].getIndex());\n-            code.invokevirtual().setMethod(ClassMetaData.class,\n-                \"getField\", FieldMetaData.class, new Class[]{int.class});\n-            code.invokeinterface().setMethod (FetchConfiguration.class, \n-                \"requiresFetch\", int.class, new Class[]{FieldMetaData.class});\n-            code.constant().setValue(FetchConfiguration.FETCH_NONE);\n-            jumps2.add(code.ificmpeq());\n-            addLoad(bc, code, fmds[i], objectCount, local, false);\n-\n-            jumps = jumps2;\n-            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\n-                objectCount++;\n-        }\n-        setTarget(code.vreturn(), jumps);\n-        code.calculateMaxStack();\n-        code.calculateMaxLocals();\n-    }\n-\n-    private void addLoadWithFieldsMethod(BCClass bc, ClassMetaData meta) {\n-        Code code = addLoadMethod(bc, true);\n-        // public void load(OpenJPAStateManager sm, BitSet fields,\n-        // \t\tFetchConfiguration fetch, Object conn)\n-        FieldMetaData[] fmds = meta.getFields();\n-        Collection jumps = new LinkedList();\n-        Collection jumps2;\n-        int objectCount = 0;\n-        boolean intermediate;\n-        int local = code.getNextLocalsIndex();\n-        code.constant().setNull();\n-        code.astore().setLocal(local);\n-        int inter = code.getNextLocalsIndex();\n-        code.constant().setNull();\n-        code.astore().setLocal(inter);\n-\n-        for (int i = 0; i < fmds.length; i++) {\n-            jumps2 = new LinkedList();\n-            intermediate = usesIntermediate(fmds[i]);\n-            // if (fields.get(i))\n-            // {\n-            // \t\tif (loaded.get(i))\n-            setTarget(code.aload().setParam(1), jumps);\n-            code.constant().setValue(i);\n-            code.invokevirtual().setMethod(BitSet.class, \"get\",\n-                boolean.class, new Class[]{ int.class });\n-            jumps2.add(code.ifeq());\n-            code.aload().setThis();\n-            code.getfield().setField(\"loaded\", BitSet.class);\n-            code.constant().setValue(i);\n-            code.invokevirtual().setMethod(BitSet.class, \"get\",\n-                boolean.class, new Class[]{ int.class });\n-            if (intermediate)\n-                jumps.add(code.ifeq());\n-            else\n-                jumps2.add(code.ifeq());\n-\n-            addLoad(bc, code, fmds[i], objectCount, local, true);\n-            if (usesImplData(fmds[i])) {\n-                // loadImplData(sm, i);\n-                code.aload().setThis();\n-                code.aload().setParam(0);\n-                code.constant().setValue(i);\n-                code.invokevirtual().setMethod(\"loadImplData\", void.class,\n-                    new Class[]{ OpenJPAStateManager.class, int.class });\n-            }\n-\n-            // fields.clear(i);\n-            code.aload().setParam(1);\n-            code.constant().setValue(i);\n-            code.invokevirtual().setMethod(BitSet.class, \"clear\", void.class,\n-                new Class[] { int.class });\n-\n-            jumps2.add(code.go2());\n-\n-            if (intermediate)\n-                setTarget(addLoadIntermediate\n-                    (code, i, objectCount, jumps2, inter), jumps);\n-\n-            jumps = jumps2;\n-            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\n-                objectCount++;\n-        }\n-        setTarget(code.vreturn(), jumps);\n-        code.calculateMaxStack();\n-        code.calculateMaxLocals();\n-    }\n-\n-    /**\n-     * Declare and start the base load method.\n-     */\n-    private Code addLoadMethod(BCClass bc, boolean fields) {\n-        Class[] args = null;\n-        if (fields)\n-            args = new Class[]{ OpenJPAStateManager.class, BitSet.class,\n-                FetchConfiguration.class, Object.class };\n-        else\n-            args = new Class[]{ OpenJPAStateManager.class,\n-                FetchConfiguration.class, Object.class };\n-        BCMethod load = bc.declareMethod(\"load\", void.class, args);\n-        Code code = load.getCode(true);\n-\n-        //loadVersion(sm);\n-        code.aload().setThis();\n-        code.aload().setParam(0);\n-        code.invokevirtual().setMethod(\"loadVersion\", void.class,\n-            new Class[]{ OpenJPAStateManager.class });\n-\n-        //loadImplData(sm);\n-        code.aload().setThis();\n-        code.aload().setParam(0);\n-        code.invokevirtual().setMethod(\"loadImplData\", void.class,\n-            new Class[]{ OpenJPAStateManager.class });\n-        return code;\n-    }\n-\n-    /**\n-     * Add the field load.\n-     */\n-    private Instruction addLoad(BCClass bc, Code code, FieldMetaData fmd,\n-        int objectCount, int local, boolean fields) {\n-        int index = fmd.getIndex();\n-        int typeCode = replaceType(fmd);\n-        Instruction first;\n-        if (typeCode < JavaTypes.OBJECT) {\n-            // sm.store<type>(i, field<i>)\n-            Class type = forType(fmd.getTypeCode());\n-            first = code.aload().setParam(0);\n-            code.constant().setValue(index);\n-            code.aload().setThis();\n-            code.getfield().setField(getFieldName(index), type);\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-                \"store\" + StringUtils.capitalize(type.getName()),\n-                void.class, new Class[]{ int.class, type });\n-        } else {\n-            // fmd = sm.getMetaData().getField(i);\n-            int offset = fields ? 1 : 0;\n-            first = code.aload().setParam(0);\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-                \"getMetaData\", ClassMetaData.class, null);\n-            code.constant().setValue(fmd.getIndex());\n-            code.invokevirtual().setMethod(ClassMetaData.class, \"getField\",\n-                FieldMetaData.class, new Class[]{ int.class });\n-            code.astore().setLocal(local);\n-            // sm.storeField(i, toField(sm, fmd, objects[objectCount],\n-            // \t\tfetch, context);\n-            code.aload().setParam(0);\n-            code.constant().setValue(index);\n-            code.aload().setThis();\n-            code.aload().setParam(0);\n-            code.aload().setLocal(local);\n-            code.aload().setThis();\n-            code.getfield().setField(\"objects\", Object[].class);\n-            code.constant().setValue(objectCount);\n-            code.aaload();\n-            code.aload().setParam(1 + offset);\n-            code.aload().setParam(2 + offset);\n-            code.invokevirtual().setMethod(bc.getName(), \"toField\",\n-                Object.class.getName(), toStrings(new Class[]{ \n-                OpenJPAStateManager.class, FieldMetaData.class,\n-                Object.class, FetchConfiguration.class, Object.class }));\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-                \"storeField\", void.class,\n-                new Class[]{ int.class, Object.class });\n-        }\n-        return first;\n-    }\n-\n-    /**\n-     * Load intermediate data if possible.\n-     */\n-    private Instruction addLoadIntermediate(Code code, int index,\n-        int objectCount, Collection jumps2, int inter) {\n-        // {\n-        // \t\tObject inter = objects[objectCount];\n-        Instruction first = code.aload().setThis();\n-        code.getfield().setField(\"objects\", Object[].class);\n-        code.constant().setValue(objectCount);\n-        code.aaload();\n-        code.astore().setLocal(inter);\n-        // \t\tif (inter != null && !sm.getLoaded().get(index))\n-        code.aload().setLocal(inter);\n-        jumps2.add(code.ifnull());\n-        code.aload().setParam(0);\n-        code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-            \"getLoaded\", BitSet.class, null);\n-        code.constant().setValue(index);\n-        code.invokevirtual().setMethod(BitSet.class, \"get\",\n-            boolean.class, new Class[]{ int.class });\n-        jumps2.add(code.ifne());\n-        //\t\t\tsm.setIntermediate(index, inter);\n-        //\t}  // end else\n-        code.aload().setParam(0);\n-        code.constant().setValue(index);\n-        code.aload().setLocal(inter);\n-        code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-            \"setIntermediate\", void.class,\n-            new Class[]{ int.class, Object.class });\n-        return first;\n-    }\n-\n-    private void addStoreMethods(BCClass bc, ClassMetaData meta) {\n-        // i.e. void store(OpenJPAStateManager sm, BitSet fields);\n-        addStoreMethod(bc, meta, true);\n-        // i.e. void store(OpenJPAStateManager sm);\n-        addStoreMethod(bc, meta, false);\n-    }\n-\n-    private void addStoreMethod(BCClass bc, ClassMetaData meta,\n-        boolean fields) {\n-        BCMethod store;\n-        if (fields)\n-            store = bc.declareMethod(\"store\", void.class,\n-                new Class[]{ OpenJPAStateManager.class, BitSet.class });\n-        else\n-            store = bc.declareMethod(\"store\", void.class,\n-                new Class[]{ OpenJPAStateManager.class });\n-        Code code = store.getCode(true);\n-\n-        // initialize();\n-        code.aload().setThis();\n-        code.invokevirtual().setMethod(\"initialize\", void.class, null);\n-\n-        // storeVersion(sm);\n-        code.aload().setThis();\n-        code.aload().setParam(0);\n-        code.invokevirtual().setMethod(\"storeVersion\", void.class,\n-            new Class[]{ OpenJPAStateManager.class });\n-\n-        // storeImplData(sm);\n-        code.aload().setThis();\n-        code.aload().setParam(0);\n-        code.invokevirtual().setMethod(\"storeImplData\", void.class,\n-            new Class[]{ OpenJPAStateManager.class });\n-\n-        FieldMetaData[] fmds = meta.getFields();\n-        Collection jumps = new LinkedList();\n-        int objectCount = 0;\n-        for (int i = 0; i < fmds.length; i++) {\n-            if (fields) {\n-                //  if (fields != null && fields.get(index))\n-                setTarget(code.aload().setParam(1), jumps);\n-                jumps.add(code.ifnull());\n-                code.aload().setParam(1);\n-                code.constant().setValue(i);\n-                code.invokevirtual().setMethod(BitSet.class, \"get\",\n-                    boolean.class, new Class[]{ int.class });\n-                jumps.add(code.ifeq());\n-            } else {\n-                // if (sm.getLoaded().get(index)))\n-                setTarget(code.aload().setParam(0), jumps);\n-                code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-                    \"getLoaded\", BitSet.class, null);\n-                code.constant().setValue(i);\n-                code.invokevirtual().setMethod(BitSet.class, \"get\",\n-                    boolean.class, new Class[]{ int.class });\n-                jumps.add(code.ifeq());\n-            }\n-            addStore(bc, code, fmds[i], objectCount);\n-            if (usesIntermediate(fmds[i])) {\n-                JumpInstruction elseIns = code.go2();\n-                // else if (!loaded.get(index))\n-                setTarget(code.aload().setThis(), jumps);\n-                jumps.add(elseIns);\n-                code.getfield().setField(\"loaded\", BitSet.class);\n-                code.constant().setValue(i);\n-                code.invokevirtual().setMethod(BitSet.class, \"get\",\n-                    boolean.class, new Class[]{ int.class });\n-                jumps.add(code.ifne());\n-                // Object val = sm.getIntermediate(index);\n-                // if (val != null)\n-                // \t\tobjects[objectCount] = val;\n-                code.aload().setParam(0);\n-                code.constant().setValue(i);\n-                code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-                    \"getIntermediate\", Object.class, new Class[]{ int.class });\n-                int local = code.getNextLocalsIndex();\n-                code.astore().setLocal(local);\n-                code.aload().setLocal(local);\n-                jumps.add(code.ifnull());\n-                code.aload().setThis();\n-                code.getfield().setField(\"objects\", Object[].class);\n-                code.constant().setValue(objectCount);\n-                code.aload().setLocal(local);\n-                code.aastore();\n-            }\n-            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\n-                objectCount++;\n-        }\n-        setTarget(code.vreturn(), jumps);\n-        code.calculateMaxLocals();\n-        code.calculateMaxStack();\n-    }\n-\n-    private void addStore(BCClass bc, Code code, FieldMetaData fmd,\n-        int objectCount) {\n-        int typeCode = replaceType(fmd);\n-        int index = fmd.getIndex();\n-        if (typeCode < JavaTypes.OBJECT) {\n-            Class type = forType(typeCode);\n-            // field<i> = sm.fetch<Type>(index)\n-            code.aload().setThis();\n-            code.aload().setParam(0);\n-            code.constant().setValue(index);\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-                \"fetch\" + StringUtils.capitalize(type.getName()), type,\n-                new Class[]{ int.class });\n-            code.putfield().setField(getFieldName(index), type);\n-            code.aload().setThis();\n-            code.getfield().setField(\"loaded\", BitSet.class);\n-            code.constant().setValue(index);\n-            code.invokevirtual().setMethod(BitSet.class, \"set\", void.class,\n-                new Class[]{ int.class });\n-        } else {\n-            // Object val = toData(sm.getMetaData().getField(index),\n-            // \t\tsm.fetchField(index, false), sm.getContext());\n-            int local = code.getNextLocalsIndex();\n-            code.aload().setThis();\n-            code.aload().setParam(0);\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-                \"getMetaData\", ClassMetaData.class, null);\n-            code.constant().setValue(fmd.getIndex());\n-            code.invokevirtual().setMethod(ClassMetaData.class,\n-                \"getField\", FieldMetaData.class, new Class[]{ int.class });\n-            code.aload().setParam(0);\n-            code.constant().setValue(fmd.getIndex());\n-            code.constant().setValue(false);\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-                \"fetchField\", Object.class, new Class[]\n-                { int.class, boolean.class });\n-            code.aload().setParam(0);\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-                \"getContext\", StoreContext.class, null);\n-            code.invokevirtual().setMethod(bc.getName(), \"toData\",\n-                Object.class.getName(), toStrings(new Class []{\n-                FieldMetaData.class, Object.class, StoreContext.class }));\n-            code.astore().setLocal(local);\n-\n-            // if (val == NULL) {\n-            // \t\tval = null;\n-            // \t\tloaded.clear(index);\n-            // \t} else\n-            // \t\tloaded.set(index);\n-            // \tobjects[objectCount] = val;\n-            code.aload().setLocal(local);\n-            code.getstatic().setField(AbstractPCData.class, \"NULL\",\n-                Object.class);\n-            JumpInstruction ifins = code.ifacmpne();\n-            code.constant().setNull();\n-            code.astore().setLocal(local);\n-            code.aload().setThis();\n-            code.getfield().setField(\"loaded\", BitSet.class);\n-            code.constant().setValue(index);\n-            code.invokevirtual().setMethod(BitSet.class, \"clear\", void.class,\n-                new Class[]{ int.class });\n-            JumpInstruction go2 = code.go2();\n-            ifins.setTarget(code.aload().setThis());\n-            code.getfield().setField(\"loaded\", BitSet.class);\n-            code.constant().setValue(index);\n-            code.invokevirtual().setMethod(BitSet.class, \"set\", void.class,\n-                new Class[]{ int.class });\n-            go2.setTarget(code.aload().setThis());\n-            code.getfield().setField(\"objects\", Object[].class);\n-            code.constant().setValue(objectCount);\n-            code.aload().setLocal(local);\n-            code.aastore();\n-        }\n-        if (!usesImplData(fmd))\n-            return;\n-\n-        // storeImplData(sm, i, loaded.get(i);\n-        code.aload().setThis();\n-        code.aload().setParam(0);\n-        code.constant().setValue(index);\n-        code.aload().setThis();\n-        code.getfield().setField(\"loaded\", BitSet.class);\n-        code.constant().setValue(index);\n-        code.invokevirtual().setMethod(BitSet.class, \"get\", boolean.class,\n-            new Class[]{ int.class });\n-        code.invokevirtual().setMethod(\"storeImplData\", void.class,\n-            new Class[]{ OpenJPAStateManager.class, int.class, boolean.class });\n-    }\n-\n-    private void addNewEmbedded(BCClass bc) {\n-        // void newEmbeddedPCData(OpenJPAStateManager embedded)\n-        BCMethod meth = bc.declareMethod(\"newEmbeddedPCData\", PCData.class,\n-            new Class[]{ OpenJPAStateManager.class });\n-        Code code = meth.getCode(true);\n-        // return getStorageGenerator().generatePCData\n-        // \t\t(sm.getId(), sm.getMetaData());\n-        code.aload().setThis();\n-        code.getfield().setField(\"storageGenerator\", PCDataGenerator.class);\n-        code.aload().setParam(0);\n-        code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-            \"getId\", Object.class, null);\n-        code.aload().setParam(0);\n-        code.invokeinterface().setMethod(OpenJPAStateManager.class,\n-            \"getMetaData\", ClassMetaData.class, null);\n-        code.invokevirtual().setMethod(PCDataGenerator.class,\n-            \"generatePCData\", PCData.class, new Class[]\n-            { Object.class, ClassMetaData.class });\n-        code.areturn();\n-        code.calculateMaxLocals();\n-        code.calculateMaxStack();\n-    }\n-\n-    private void addGetData(BCClass bc) {\n-        // return getObjectField(i);\n-        BCMethod method = bc.declareMethod(\"getData\", Object.class,\n-            new Class[]{ int.class });\n-        Code code = method.getCode(true);\n-        code.aload().setThis();\n-        code.iload().setParam(0);\n-        code.invokevirtual().setMethod(\"getObject\", Object.class,\n-            new Class[]{ int.class });\n-        code.areturn();\n-        code.calculateMaxLocals();\n-        code.calculateMaxStack();\n-    }\n-\n-    /////////////\n-    // Utilities\n-    /////////////\n-\n-    /**\n-     * Return a valid {@link JavaTypes} constant for the given field\n-     */\n-    protected int replaceType(FieldMetaData fmd) {\n-        if (usesIntermediate(fmd))\n-            return JavaTypes.OBJECT;\n-        return fmd.getTypeCode();\n-    }\n-\n-    /**\n-     * Whether the given field uses a cacheable intermediate value.\n-     */\n-    protected boolean usesIntermediate(FieldMetaData fmd) {\n-        return fmd.usesIntermediate();\n-    }\n-\n-    /**\n-     * Whether the given type might have cacheable class-level impl data.\n-     */\n-    protected boolean usesImplData(ClassMetaData meta) {\n-        return true;\n-    }\n-\n-    /**\n-     * Whether the given field might have cacheable impl data.\n-     */\n-    protected boolean usesImplData(FieldMetaData fmd) {\n-        return fmd.usesImplData() == null;\n-    }\n-\n-    /**\n-     * The number of fields with cacheable impl data.\n-     */\n-    private int countImplDataFields(ClassMetaData meta) {\n-        FieldMetaData[] fmds = meta.getFields();\n-        int count = 0;\n-        for (int i = 0; i < fmds.length; i++)\n-            if (usesImplData(fmds[i]))\n-                count++;\n-        return count;\n-    }\n-\n-    /**\n-     * Add method which defers to AbstractPCData.\n-     */\n-    protected void callAbstractPCData(BCClass bc, String name, Class retType,\n-        Class[] args) {\n-        BCMethod meth = bc.declareMethod(name, retType, args);\n-        Code code = meth.getCode(true);\n-        code.aload().setThis();\n-        for (int i = 0; i < args.length; i++)\n-            code.xload().setParam(i).setType(args[i]);\n-        code.invokevirtual().setMethod(AbstractPCData.class, name, retType,\n-            args);\n-        if (!void.class.equals(retType))\n-            code.xreturn().setType(retType);\n-        code.calculateMaxLocals();\n-        code.calculateMaxStack();\n-    }\n-\n-    /**\n-     * Set the collection of {@link JumpInstruction}s to the given instruction,\n-     * clearing the collection in the process.\n-     */\n-    protected void setTarget(Instruction ins, Collection jumps) {\n-        for (Iterator it = jumps.iterator(); it.hasNext();)\n-            ((JumpInstruction) it.next()).setTarget(ins);\n-        jumps.clear();\n-    }\n-\n-    /**\n-     * Transform the given array of classes to strings.\n-     */\n-    private static String[] toStrings(Class[] cls) {\n-        String[] strings = new String[cls.length];\n-        for (int i = 0; i < strings.length; i++)\n-            strings[i] = cls[i].getName();\n-        return strings;\n-    }\n-\n-    /**\n-     * Dynamic {@link PCData}s generated will implement this interface\n-     * to simplify initialization.\n-     */\n-    public static interface DynamicPCData extends PCData {\n-\n-        public void setId(Object oid);\n-\n-        public PCDataGenerator getStorageGenerator();\n-\n-        public void setStorageGenerator (PCDataGenerator generator);\n-\t}\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import java.util.BitSet;\r\n+import java.util.Collection;\r\n+import java.util.Iterator;\r\n+import java.util.LinkedList;\r\n+import java.util.Map;\r\n+\r\n+import org.apache.commons.lang.StringUtils;\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.kernel.AbstractPCData;\r\n+import org.apache.openjpa.kernel.FetchConfiguration;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.kernel.PCData;\r\n+import org.apache.openjpa.kernel.StoreContext;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.util.InternalException;\r\n+import serp.bytecode.BCClass;\r\n+import serp.bytecode.BCField;\r\n+import serp.bytecode.BCMethod;\r\n+import serp.bytecode.Code;\r\n+import serp.bytecode.Constants;\r\n+import serp.bytecode.ExceptionHandler;\r\n+import serp.bytecode.Instruction;\r\n+import serp.bytecode.JumpInstruction;\r\n+import serp.bytecode.LookupSwitchInstruction;\r\n+\r\n+/**\r\n+ * Generates {@link PCData} instances which avoid primitve wrappers\r\n+ * to optimize memory use and performance at the cost of slightly higher\r\n+ * startup time.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @nojavadoc\r\n+ * @since 0.3.2\r\n+ */\r\n+public class PCDataGenerator\r\n+    extends DynamicStorageGenerator {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (PCDataGenerator.class);\r\n+\r\n+    protected static final String POSTFIX = \"$openjpapcdata\";\r\n+\r\n+    private final Map _generated = new ConcurrentHashMap();\r\n+    private final OpenJPAConfiguration _conf;\r\n+    private final Log _log;\r\n+\r\n+    public PCDataGenerator(OpenJPAConfiguration conf) {\r\n+        _conf = conf;\r\n+        _log = _conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the configuration.\r\n+     */\r\n+    public OpenJPAConfiguration getConfiguration() {\r\n+        return _conf;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a {@link PCData} instance for the given oid and metadata.\r\n+     */\r\n+    public PCData generatePCData(Object oid, ClassMetaData meta) {\r\n+        if (meta == null)\r\n+            return null;\r\n+        Class type = meta.getDescribedType();\r\n+        DynamicStorage storage = (DynamicStorage) _generated.get(type);\r\n+        if (storage == null) {\r\n+            storage = generateStorage(meta);\r\n+            _generated.put(type, storage);\r\n+            if (_log.isTraceEnabled())\r\n+                _log.trace(_loc.get(\"pcdata-created\", type.getName(), meta));\r\n+        }\r\n+        DynamicPCData data = (DynamicPCData) storage.newInstance();\r\n+        data.setId(oid);\r\n+        data.setStorageGenerator(this);\r\n+        finish(data, meta);\r\n+        return data;\r\n+    }\r\n+\r\n+    /**\r\n+     * Actually generate the factory instance.\r\n+     */\r\n+    private DynamicStorage generateStorage(ClassMetaData meta) {\r\n+        if (_log.isTraceEnabled())\r\n+            _log.trace(_loc.get(\"pcdata-generate\", meta));\r\n+\r\n+        FieldMetaData[] fields = meta.getFields();\r\n+        int[] types = new int[fields.length];\r\n+        for (int i = 0; i < types.length; i++)\r\n+            types[i] = replaceType(fields[i]);\r\n+        return generateStorage(types, meta);\r\n+    }\r\n+\r\n+    /**\r\n+     * Perform any final actions before the pcdata is returned to client code.\r\n+     */\r\n+    protected void finish(DynamicPCData data, ClassMetaData meta) {\r\n+    }\r\n+\r\n+    protected int getCreateFieldMethods(int typeCode) {\r\n+        if (typeCode >= JavaTypes.OBJECT)\r\n+            return POLICY_SILENT;\r\n+        // don't bother creating set/get<Primitive> methods\r\n+        return POLICY_EMPTY;\r\n+    }\r\n+\r\n+    protected void declareClasses(BCClass bc) {\r\n+        super.declareClasses(bc);\r\n+        bc.declareInterface(DynamicPCData.class);\r\n+        bc.setSuperclass(AbstractPCData.class);\r\n+    }\r\n+\r\n+    protected final String getClassName(Object obj) {\r\n+        return getUniqueName(((ClassMetaData) obj).getDescribedType());\r\n+    }\r\n+\r\n+    /**\r\n+     * Creates a unique name for the given type's pcdata implementation.\r\n+     */\r\n+    protected String getUniqueName(Class type) {\r\n+        return type.getName() + \"$\" + System.identityHashCode(type) + POSTFIX;\r\n+    }\r\n+\r\n+    protected final void decorate(Object obj, BCClass bc, int[] types) {\r\n+        super.decorate(obj, bc, types);\r\n+        ClassMetaData meta = (ClassMetaData) obj;\r\n+\r\n+        enhanceConstructor(bc);\r\n+        addBaseFields(bc);\r\n+        addImplDataMethods(bc, meta);\r\n+        addFieldImplDataMethods(bc, meta);\r\n+        addVersionMethods(bc);\r\n+        addGetType(bc, meta);\r\n+        addLoadMethod(bc, meta);\r\n+        addLoadWithFieldsMethod(bc, meta);\r\n+        addStoreMethods(bc, meta);\r\n+        addNewEmbedded(bc);\r\n+        addGetData(bc);\r\n+        decorate(bc, meta);\r\n+    }\r\n+\r\n+    /**\r\n+     * Apply additional decoration to generated class.\r\n+     */\r\n+    protected void decorate(BCClass bc, ClassMetaData meta) {\r\n+    }\r\n+\r\n+    /**\r\n+     * Enhance constructor to initialize fields\r\n+     */\r\n+    private void enhanceConstructor(BCClass bc) {\r\n+        BCMethod cons = bc.getDeclaredMethod(\"<init>\", (String[]) null);\r\n+        Code code = cons.getCode(false);\r\n+        code.afterLast();\r\n+        code.previous();\r\n+\r\n+        // private BitSet loaded = new BitSet();\r\n+        BCField loaded = addBeanField(bc, \"loaded\", BitSet.class);\r\n+        loaded.setFinal(true);\r\n+        code.aload().setThis();\r\n+        code.anew().setType(BitSet.class);\r\n+        code.dup();\r\n+        code.constant().setValue(bc.getFields().length);\r\n+        code.invokespecial().setMethod(BitSet.class, \"<init>\", void.class,\r\n+            new Class[]{ int.class });\r\n+        code.putfield().setField(loaded);\r\n+\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+    }\r\n+\r\n+    /**\r\n+     * Have to load the type since it may not be available to the\r\n+     * same classloader (i.e. rar vs. ear). The context classloader\r\n+     * (i.e. the user app classloader) should be fine.\r\n+     */\r\n+    private void addGetType(BCClass bc, ClassMetaData meta) {\r\n+        BCField type = bc.declareField(\"type\", Class.class);\r\n+        type.setStatic(true);\r\n+        type.makePrivate();\r\n+        // public Class getType() {\r\n+        BCMethod getter = bc.declareMethod(\"getType\", Class.class, null);\r\n+        getter.makePublic();\r\n+        Code code = getter.getCode(true);\r\n+        // if (type == null) {\r\n+        // \t\ttry {\r\n+        // \t\t\ttype = Class.forName\r\n+        // \t\t\t\t(meta.getDescribedType().getName(), true,\r\n+        // \t\t\t\tThread.currentThread().getContextClassLoader());\r\n+        // \t\t} catch (ClassNotFoundException cnfe) {\r\n+        // \t\t\tthrow new InternalException();\r\n+        // \t\t}\r\n+        // }\r\n+        code.getstatic().setField(type);\r\n+\r\n+        Collection jumps = new LinkedList();\r\n+        jumps.add(code.ifnonnull());\r\n+        ExceptionHandler handler = code.addExceptionHandler();\r\n+\r\n+        handler.setTryStart(code.constant().setValue\r\n+            (meta.getDescribedType().getName()));\r\n+        code.constant().setValue(true);\r\n+        code.invokestatic().setMethod(Thread.class, \"currentThread\",\r\n+            Thread.class, null);\r\n+        code.invokevirtual().setMethod(Thread.class, \"getContextClassLoader\",\r\n+            ClassLoader.class, null);\r\n+        code.invokestatic().setMethod(Class.class, \"forName\", Class.class,\r\n+            new Class[]{ String.class, boolean.class, ClassLoader.class });\r\n+        code.putstatic().setField(type);\r\n+        Instruction go2 = code.go2();\r\n+        jumps.add(go2);\r\n+        handler.setTryEnd(go2);\r\n+        handler.setCatch(ClassNotFoundException.class);\r\n+        handler.setHandlerStart(throwException\r\n+            (code, InternalException.class));\r\n+        setTarget(code.getstatic().setField(type), jumps);\r\n+        code.areturn();\r\n+\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+    }\r\n+\r\n+    /**\r\n+     * Declare standard dynamic pcdata fields.\r\n+     */\r\n+    private void addBaseFields(BCClass bc) {\r\n+        addBeanField(bc, \"id\", Object.class);\r\n+        BCField field = addBeanField(bc, \"storageGenerator\",\r\n+            PCDataGenerator.class);\r\n+        field.setAccessFlags(field.getAccessFlags()\r\n+            | Constants.ACCESS_TRANSIENT);\r\n+    }\r\n+\r\n+    /**\r\n+     * Add methods for loading and storing class-level impl data.\r\n+     */\r\n+    private void addImplDataMethods(BCClass bc, ClassMetaData meta) {\r\n+        // void storeImplData(OpenJPAStateManager);\r\n+        BCMethod meth = bc.declareMethod(\"storeImplData\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+        Code code = meth.getCode(true);\r\n+\r\n+        BCField impl = null;\r\n+        if (!usesImplData(meta))\r\n+            code.vreturn();\r\n+        else {\r\n+            // if (sm.isImplDataCacheable())\r\n+            // \t\tsetImplData(sm.getImplData());\r\n+            impl = addBeanField(bc, \"implData\", Object.class);\r\n+            code.aload().setParam(0);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"isImplDataCacheable\", boolean.class, null);\r\n+            JumpInstruction ifins = code.ifeq();\r\n+            code.aload().setThis();\r\n+            code.aload().setParam(0);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"getImplData\", Object.class, null);\r\n+            code.invokevirtual().setMethod(\"setImplData\", void.class,\r\n+                new Class[]{ Object.class });\r\n+            ifins.setTarget(code.vreturn());\r\n+        }\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+\r\n+        // void loadImplData(OpenJPAStateManager);\r\n+        meth = bc.declareMethod(\"loadImplData\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+        code = meth.getCode(true);\r\n+        if (!usesImplData(meta))\r\n+            code.vreturn();\r\n+        else {\r\n+            // if (sm.getImplData() == null && implData != null)\r\n+            // \t\tsm.setImplData(impl, true);\r\n+            code.aload().setParam(0);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"getImplData\", Object.class, null);\r\n+            JumpInstruction ifins = code.ifnonnull();\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(impl);\r\n+            JumpInstruction ifins2 = code.ifnull();\r\n+            code.aload().setParam(0);\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(impl);\r\n+            code.constant().setValue(true);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"setImplData\", void.class,\r\n+                new Class[]{ Object.class, boolean.class });\r\n+            Instruction ins = code.vreturn();\r\n+            ifins.setTarget(ins);\r\n+            ifins2.setTarget(ins);\r\n+        }\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+    }\r\n+\r\n+    /**\r\n+     * Add methods for loading and storing class-level impl data.\r\n+     */\r\n+    private void addFieldImplDataMethods(BCClass bc, ClassMetaData meta) {\r\n+        // public void loadImplData(OpenJPAStateManager sm, int i)\r\n+        BCMethod meth = bc.declareMethod(\"loadImplData\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class, int.class });\r\n+        meth.makePrivate();\r\n+        Code code = meth.getCode(true);\r\n+\r\n+        int count = countImplDataFields(meta);\r\n+        BCField impl = null;\r\n+        if (count == 0)\r\n+            code.vreturn();\r\n+        else {\r\n+            // Object[] fieldImpl\r\n+            impl = bc.declareField(\"fieldImpl\", Object[].class);\r\n+            impl.makePrivate();\r\n+\r\n+            // if (fieldImpl != null)\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(impl);\r\n+            JumpInstruction ifins = code.ifnonnull();\r\n+            code.vreturn();\r\n+\r\n+            // Object obj = null;\r\n+            int obj = code.getNextLocalsIndex();\r\n+            ifins.setTarget(code.constant().setNull());\r\n+            code.astore().setLocal(obj);\r\n+\r\n+            // establish switch target, then move before it\r\n+            Instruction target = code.aload().setLocal(obj);\r\n+            code.previous();\r\n+\r\n+            // switch(i)\r\n+            code.iload().setParam(1);\r\n+            LookupSwitchInstruction lswitch = code.lookupswitch();\r\n+            FieldMetaData[] fields = meta.getFields();\r\n+            int cacheable = 0;\r\n+            for (int i = 0; i < fields.length; i++) {\r\n+                if (!usesImplData(fields[i]))\r\n+                    continue;\r\n+                // case x: obj = fieldImpl[y]; break;\r\n+                lswitch.addCase(i, code.aload().setThis());\r\n+                code.getfield().setField(impl);\r\n+                code.constant().setValue(cacheable++);\r\n+                code.aaload();\r\n+                code.astore().setLocal(obj);\r\n+                code.go2().setTarget(target);\r\n+            }\r\n+            lswitch.setDefaultTarget(target);\r\n+\r\n+            // if (obj != null)\r\n+            code.next();    // jump back over target\r\n+            ifins = code.ifnonnull();\r\n+            code.vreturn();\r\n+\r\n+            // sm.setImplData(index, impl);\r\n+            ifins.setTarget(code.aload().setParam(0));\r\n+            code.iload().setParam(1);\r\n+            code.aload().setLocal(obj);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"setImplData\", void.class,\r\n+                new Class[]{ int.class, Object.class });\r\n+            code.vreturn();\r\n+        }\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+\r\n+        // void storeImplData(OpenJPAStateManager sm, int index, boolean loaded)\r\n+        meth = bc.declareMethod(\"storeImplData\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class, int.class, boolean.class });\r\n+        code = meth.getCode(true);\r\n+        if (count == 0)\r\n+            code.vreturn();\r\n+        else {\r\n+            // int arrIdx = -1;\r\n+            // switch(index)\r\n+            int arrIdx = code.getNextLocalsIndex();\r\n+            code.constant().setValue(-1);\r\n+            code.istore().setLocal(arrIdx);\r\n+            code.iload().setParam(1);\r\n+            LookupSwitchInstruction lswitch = code.lookupswitch();\r\n+\r\n+            // establish switch target, then move before it\r\n+            Instruction switchTarget = code.iload().setLocal(arrIdx);\r\n+            code.previous();\r\n+\r\n+            FieldMetaData[] fields = meta.getFields();\r\n+            int cacheable = 0;\r\n+            for (int i = 0; i < fields.length; i++) {\r\n+                if (!usesImplData(fields[i]))\r\n+                    continue;\r\n+                // case x: arrIdx = y; break;\r\n+                lswitch.addCase(i, code.constant().setValue(cacheable++));\r\n+                code.istore().setLocal(arrIdx);\r\n+                code.go2().setTarget(switchTarget);\r\n+            }\r\n+            lswitch.setDefaultTarget(switchTarget);\r\n+            code.next();    // step over switch target\r\n+\r\n+            // if (arrIdx != -1)\r\n+            code.constant().setValue(-1);\r\n+            JumpInstruction ifins = code.ificmpne();\r\n+            code.vreturn();\r\n+\r\n+            // create null target, then move before it\r\n+            Instruction nullTarget = code.aload().setThis();\r\n+            code.previous();\r\n+\r\n+            // if (loaded)\r\n+            ifins.setTarget(code.iload().setParam(2));\r\n+            code.ifeq().setTarget(nullTarget);\r\n+\r\n+            // Object obj = sm.getImplData(index)\r\n+            int obj = code.getNextLocalsIndex();\r\n+            code.aload().setParam(0);\r\n+            code.iload().setParam(1);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"getImplData\", Object.class, new Class[]{ int.class });\r\n+            code.astore().setLocal(obj);\r\n+\r\n+            // if (obj != null)\r\n+            code.aload().setLocal(obj);\r\n+            code.ifnull().setTarget(nullTarget);\r\n+\r\n+            // if (fieldImpl == null)\r\n+            // \t\tfieldImpl = new Object[fields];\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(impl);\r\n+            ifins = code.ifnonnull();\r\n+            code.aload().setThis();\r\n+            code.constant().setValue(count);\r\n+            code.anewarray().setType(Object.class);\r\n+            code.putfield().setField(impl);\r\n+\r\n+            // fieldImpl[arrIdx] = obj;\r\n+            // return;\r\n+            ifins.setTarget(code.aload().setThis());\r\n+            code.getfield().setField(impl);\r\n+            code.iload().setLocal(arrIdx);\r\n+            code.aload().setLocal(obj);\r\n+            code.aastore();\r\n+            code.vreturn();\r\n+\r\n+            // if (fieldImpl != null)\r\n+            // \t\tfieldImpl[index] = null;\r\n+            code.next(); // step over nullTarget\r\n+            code.getfield().setField(impl);\r\n+            ifins = code.ifnonnull();\r\n+            code.vreturn();\r\n+            ifins.setTarget(code.aload().setThis());\r\n+            code.getfield().setField(impl);\r\n+            code.iload().setLocal(arrIdx);\r\n+            code.constant().setNull();\r\n+            code.aastore();\r\n+            code.vreturn();\r\n+        }\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+    }\r\n+\r\n+    /**\r\n+     * Add methods for loading and storing version data.\r\n+     */\r\n+    protected void addVersionMethods(BCClass bc) {\r\n+        // void storeVersion(OpenJPAStateManager sm);\r\n+        addBeanField(bc, \"version\", Object.class);\r\n+        BCMethod meth = bc.declareMethod(\"storeVersion\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+        Code code = meth.getCode(true);\r\n+\r\n+        // version = sm.getVersion();\r\n+        code.aload().setThis();\r\n+        code.aload().setParam(0);\r\n+        code.invokeinterface()\r\n+            .setMethod(OpenJPAStateManager.class, \"getVersion\",\r\n+                Object.class, null);\r\n+        code.putfield().setField(\"version\", Object.class);\r\n+        code.vreturn();\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+\r\n+        // void loadVersion(OpenJPAStateManager sm)\r\n+        meth = bc.declareMethod(\"loadVersion\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+        code = meth.getCode(true);\r\n+\r\n+        // if (sm.getVersion() == null)\r\n+        // \t\tsm.setVersion(version);\r\n+        code.aload().setParam(0);\r\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+            \"getVersion\", Object.class, null);\r\n+        JumpInstruction ifins = code.ifnonnull();\r\n+        code.aload().setParam(0);\r\n+        code.aload().setThis();\r\n+        code.getfield().setField(\"version\", Object.class);\r\n+        code.invokeinterface()\r\n+            .setMethod(OpenJPAStateManager.class, \"setVersion\",\r\n+                void.class, new Class[]{ Object.class });\r\n+        ifins.setTarget(code.vreturn());\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+    }\r\n+\r\n+    private void addLoadMethod(BCClass bc, ClassMetaData meta) {\r\n+        // public void load(OpenJPAStateManager sm, FetchConfiguration fetch,\r\n+        // \t\tObject context)\r\n+        Code code = addLoadMethod(bc, false);\r\n+        FieldMetaData[] fmds = meta.getFields();\r\n+        Collection jumps = new LinkedList();\r\n+        Collection jumps2;\r\n+\t\t\r\n+        int local = code.getNextLocalsIndex();\r\n+        code.constant().setNull();\r\n+        code.astore().setLocal(local);\r\n+        int inter = code.getNextLocalsIndex();\r\n+        code.constant().setNull();\r\n+        code.astore().setLocal(inter);\r\n+\r\n+        int objectCount = 0;\r\n+        boolean intermediate;\r\n+        for (int i = 0; i < fmds.length; i++) {\r\n+            jumps2 = new LinkedList();\r\n+            intermediate = usesIntermediate(fmds[i]);\r\n+            setTarget(code.aload().setThis(), jumps);\r\n+            // if (loaded.get(i)) or (!loaded.get(i)) depending on inter resp\r\n+            code.getfield().setField(\"loaded\", BitSet.class);\r\n+            code.constant().setValue(i);\r\n+            code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n+                boolean.class, new Class[]{ int.class });\r\n+            jumps.add(code.ifne());\r\n+\r\n+            if (intermediate)\r\n+                addLoadIntermediate(code, i, objectCount, jumps2, inter);\r\n+            jumps2.add(code.go2());\r\n+\r\n+            // if (fetch.requiresFetch(fmds[i])!=FetchConfiguration.FETCH_NONE)\r\n+            setTarget(code.aload().setParam(1), jumps);\r\n+            code.aload().setParam(0);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"getMetaData\", ClassMetaData.class, null);\r\n+            code.constant().setValue(fmds[i].getIndex());\r\n+            code.invokevirtual().setMethod(ClassMetaData.class,\r\n+                \"getField\", FieldMetaData.class, new Class[]{int.class});\r\n+            code.invokeinterface().setMethod (FetchConfiguration.class, \r\n+                \"requiresFetch\", int.class, new Class[]{FieldMetaData.class});\r\n+            code.constant().setValue(FetchConfiguration.FETCH_NONE);\r\n+            jumps2.add(code.ificmpeq());\r\n+            addLoad(bc, code, fmds[i], objectCount, local, false);\r\n+\r\n+            jumps = jumps2;\r\n+            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\r\n+                objectCount++;\r\n+        }\r\n+        setTarget(code.vreturn(), jumps);\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+    }\r\n+\r\n+    private void addLoadWithFieldsMethod(BCClass bc, ClassMetaData meta) {\r\n+        Code code = addLoadMethod(bc, true);\r\n+        // public void load(OpenJPAStateManager sm, BitSet fields,\r\n+        // \t\tFetchConfiguration fetch, Object conn)\r\n+        FieldMetaData[] fmds = meta.getFields();\r\n+        Collection jumps = new LinkedList();\r\n+        Collection jumps2;\r\n+        int objectCount = 0;\r\n+        boolean intermediate;\r\n+        int local = code.getNextLocalsIndex();\r\n+        code.constant().setNull();\r\n+        code.astore().setLocal(local);\r\n+        int inter = code.getNextLocalsIndex();\r\n+        code.constant().setNull();\r\n+        code.astore().setLocal(inter);\r\n+\r\n+        for (int i = 0; i < fmds.length; i++) {\r\n+            jumps2 = new LinkedList();\r\n+            intermediate = usesIntermediate(fmds[i]);\r\n+            // if (fields.get(i))\r\n+            // {\r\n+            // \t\tif (loaded.get(i))\r\n+            setTarget(code.aload().setParam(1), jumps);\r\n+            code.constant().setValue(i);\r\n+            code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n+                boolean.class, new Class[]{ int.class });\r\n+            jumps2.add(code.ifeq());\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(\"loaded\", BitSet.class);\r\n+            code.constant().setValue(i);\r\n+            code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n+                boolean.class, new Class[]{ int.class });\r\n+            if (intermediate)\r\n+                jumps.add(code.ifeq());\r\n+            else\r\n+                jumps2.add(code.ifeq());\r\n+\r\n+            addLoad(bc, code, fmds[i], objectCount, local, true);\r\n+            if (usesImplData(fmds[i])) {\r\n+                // loadImplData(sm, i);\r\n+                code.aload().setThis();\r\n+                code.aload().setParam(0);\r\n+                code.constant().setValue(i);\r\n+                code.invokevirtual().setMethod(\"loadImplData\", void.class,\r\n+                    new Class[]{ OpenJPAStateManager.class, int.class });\r\n+            }\r\n+\r\n+            // fields.clear(i);\r\n+            code.aload().setParam(1);\r\n+            code.constant().setValue(i);\r\n+            code.invokevirtual().setMethod(BitSet.class, \"clear\", void.class,\r\n+                new Class[] { int.class });\r\n+\r\n+            jumps2.add(code.go2());\r\n+\r\n+            if (intermediate)\r\n+                setTarget(addLoadIntermediate\r\n+                    (code, i, objectCount, jumps2, inter), jumps);\r\n+\r\n+            jumps = jumps2;\r\n+            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\r\n+                objectCount++;\r\n+        }\r\n+        setTarget(code.vreturn(), jumps);\r\n+        code.calculateMaxStack();\r\n+        code.calculateMaxLocals();\r\n+    }\r\n+\r\n+    /**\r\n+     * Declare and start the base load method.\r\n+     */\r\n+    private Code addLoadMethod(BCClass bc, boolean fields) {\r\n+        Class[] args = null;\r\n+        if (fields)\r\n+            args = new Class[]{ OpenJPAStateManager.class, BitSet.class,\r\n+                FetchConfiguration.class, Object.class };\r\n+        else\r\n+            args = new Class[]{ OpenJPAStateManager.class,\r\n+                FetchConfiguration.class, Object.class };\r\n+        BCMethod load = bc.declareMethod(\"load\", void.class, args);\r\n+        Code code = load.getCode(true);\r\n+\r\n+        //loadVersion(sm);\r\n+        code.aload().setThis();\r\n+        code.aload().setParam(0);\r\n+        code.invokevirtual().setMethod(\"loadVersion\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+\r\n+        //loadImplData(sm);\r\n+        code.aload().setThis();\r\n+        code.aload().setParam(0);\r\n+        code.invokevirtual().setMethod(\"loadImplData\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+        return code;\r\n+    }\r\n+\r\n+    /**\r\n+     * Add the field load.\r\n+     */\r\n+    private Instruction addLoad(BCClass bc, Code code, FieldMetaData fmd,\r\n+        int objectCount, int local, boolean fields) {\r\n+        int index = fmd.getIndex();\r\n+        int typeCode = replaceType(fmd);\r\n+        Instruction first;\r\n+        if (typeCode < JavaTypes.OBJECT) {\r\n+            // sm.store<type>(i, field<i>)\r\n+            Class type = forType(fmd.getTypeCode());\r\n+            first = code.aload().setParam(0);\r\n+            code.constant().setValue(index);\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(getFieldName(index), type);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"store\" + StringUtils.capitalize(type.getName()),\r\n+                void.class, new Class[]{ int.class, type });\r\n+        } else {\r\n+            // fmd = sm.getMetaData().getField(i);\r\n+            int offset = fields ? 1 : 0;\r\n+            first = code.aload().setParam(0);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"getMetaData\", ClassMetaData.class, null);\r\n+            code.constant().setValue(fmd.getIndex());\r\n+            code.invokevirtual().setMethod(ClassMetaData.class, \"getField\",\r\n+                FieldMetaData.class, new Class[]{ int.class });\r\n+            code.astore().setLocal(local);\r\n+            // sm.storeField(i, toField(sm, fmd, objects[objectCount],\r\n+            // \t\tfetch, context);\r\n+            code.aload().setParam(0);\r\n+            code.constant().setValue(index);\r\n+            code.aload().setThis();\r\n+            code.aload().setParam(0);\r\n+            code.aload().setLocal(local);\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(\"objects\", Object[].class);\r\n+            code.constant().setValue(objectCount);\r\n+            code.aaload();\r\n+            code.aload().setParam(1 + offset);\r\n+            code.aload().setParam(2 + offset);\r\n+            code.invokevirtual().setMethod(bc.getName(), \"toField\",\r\n+                Object.class.getName(), toStrings(new Class[]{ \r\n+                OpenJPAStateManager.class, FieldMetaData.class,\r\n+                Object.class, FetchConfiguration.class, Object.class }));\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"storeField\", void.class,\r\n+                new Class[]{ int.class, Object.class });\r\n+        }\r\n+        return first;\r\n+    }\r\n+\r\n+    /**\r\n+     * Load intermediate data if possible.\r\n+     */\r\n+    private Instruction addLoadIntermediate(Code code, int index,\r\n+        int objectCount, Collection jumps2, int inter) {\r\n+        // {\r\n+        // \t\tObject inter = objects[objectCount];\r\n+        Instruction first = code.aload().setThis();\r\n+        code.getfield().setField(\"objects\", Object[].class);\r\n+        code.constant().setValue(objectCount);\r\n+        code.aaload();\r\n+        code.astore().setLocal(inter);\r\n+        // \t\tif (inter != null && !sm.getLoaded().get(index))\r\n+        code.aload().setLocal(inter);\r\n+        jumps2.add(code.ifnull());\r\n+        code.aload().setParam(0);\r\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+            \"getLoaded\", BitSet.class, null);\r\n+        code.constant().setValue(index);\r\n+        code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n+            boolean.class, new Class[]{ int.class });\r\n+        jumps2.add(code.ifne());\r\n+        //\t\t\tsm.setIntermediate(index, inter);\r\n+        //\t}  // end else\r\n+        code.aload().setParam(0);\r\n+        code.constant().setValue(index);\r\n+        code.aload().setLocal(inter);\r\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+            \"setIntermediate\", void.class,\r\n+            new Class[]{ int.class, Object.class });\r\n+        return first;\r\n+    }\r\n+\r\n+    private void addStoreMethods(BCClass bc, ClassMetaData meta) {\r\n+        // i.e. void store(OpenJPAStateManager sm, BitSet fields);\r\n+        addStoreMethod(bc, meta, true);\r\n+        // i.e. void store(OpenJPAStateManager sm);\r\n+        addStoreMethod(bc, meta, false);\r\n+    }\r\n+\r\n+    private void addStoreMethod(BCClass bc, ClassMetaData meta,\r\n+        boolean fields) {\r\n+        BCMethod store;\r\n+        if (fields)\r\n+            store = bc.declareMethod(\"store\", void.class,\r\n+                new Class[]{ OpenJPAStateManager.class, BitSet.class });\r\n+        else\r\n+            store = bc.declareMethod(\"store\", void.class,\r\n+                new Class[]{ OpenJPAStateManager.class });\r\n+        Code code = store.getCode(true);\r\n+\r\n+        // initialize();\r\n+        code.aload().setThis();\r\n+        code.invokevirtual().setMethod(\"initialize\", void.class, null);\r\n+\r\n+        // storeVersion(sm);\r\n+        code.aload().setThis();\r\n+        code.aload().setParam(0);\r\n+        code.invokevirtual().setMethod(\"storeVersion\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+\r\n+        // storeImplData(sm);\r\n+        code.aload().setThis();\r\n+        code.aload().setParam(0);\r\n+        code.invokevirtual().setMethod(\"storeImplData\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+\r\n+        FieldMetaData[] fmds = meta.getFields();\r\n+        Collection jumps = new LinkedList();\r\n+        int objectCount = 0;\r\n+        for (int i = 0; i < fmds.length; i++) {\r\n+            if (fields) {\r\n+                //  if (fields != null && fields.get(index))\r\n+                setTarget(code.aload().setParam(1), jumps);\r\n+                jumps.add(code.ifnull());\r\n+                code.aload().setParam(1);\r\n+                code.constant().setValue(i);\r\n+                code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n+                    boolean.class, new Class[]{ int.class });\r\n+                jumps.add(code.ifeq());\r\n+            } else {\r\n+                // if (sm.getLoaded().get(index)))\r\n+                setTarget(code.aload().setParam(0), jumps);\r\n+                code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                    \"getLoaded\", BitSet.class, null);\r\n+                code.constant().setValue(i);\r\n+                code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n+                    boolean.class, new Class[]{ int.class });\r\n+                jumps.add(code.ifeq());\r\n+            }\r\n+            addStore(bc, code, fmds[i], objectCount);\r\n+            if (usesIntermediate(fmds[i])) {\r\n+                JumpInstruction elseIns = code.go2();\r\n+                // else if (!loaded.get(index))\r\n+                setTarget(code.aload().setThis(), jumps);\r\n+                jumps.add(elseIns);\r\n+                code.getfield().setField(\"loaded\", BitSet.class);\r\n+                code.constant().setValue(i);\r\n+                code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n+                    boolean.class, new Class[]{ int.class });\r\n+                jumps.add(code.ifne());\r\n+                // Object val = sm.getIntermediate(index);\r\n+                // if (val != null)\r\n+                // \t\tobjects[objectCount] = val;\r\n+                code.aload().setParam(0);\r\n+                code.constant().setValue(i);\r\n+                code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                    \"getIntermediate\", Object.class, new Class[]{ int.class });\r\n+                int local = code.getNextLocalsIndex();\r\n+                code.astore().setLocal(local);\r\n+                code.aload().setLocal(local);\r\n+                jumps.add(code.ifnull());\r\n+                code.aload().setThis();\r\n+                code.getfield().setField(\"objects\", Object[].class);\r\n+                code.constant().setValue(objectCount);\r\n+                code.aload().setLocal(local);\r\n+                code.aastore();\r\n+            }\r\n+            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\r\n+                objectCount++;\r\n+        }\r\n+        setTarget(code.vreturn(), jumps);\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+    }\r\n+\r\n+    private void addStore(BCClass bc, Code code, FieldMetaData fmd,\r\n+        int objectCount) {\r\n+        int typeCode = replaceType(fmd);\r\n+        int index = fmd.getIndex();\r\n+        if (typeCode < JavaTypes.OBJECT) {\r\n+            Class type = forType(typeCode);\r\n+            // field<i> = sm.fetch<Type>(index)\r\n+            code.aload().setThis();\r\n+            code.aload().setParam(0);\r\n+            code.constant().setValue(index);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"fetch\" + StringUtils.capitalize(type.getName()), type,\r\n+                new Class[]{ int.class });\r\n+            code.putfield().setField(getFieldName(index), type);\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(\"loaded\", BitSet.class);\r\n+            code.constant().setValue(index);\r\n+            code.invokevirtual().setMethod(BitSet.class, \"set\", void.class,\r\n+                new Class[]{ int.class });\r\n+        } else {\r\n+            // Object val = toData(sm.getMetaData().getField(index),\r\n+            // \t\tsm.fetchField(index, false), sm.getContext());\r\n+            int local = code.getNextLocalsIndex();\r\n+            code.aload().setThis();\r\n+            code.aload().setParam(0);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"getMetaData\", ClassMetaData.class, null);\r\n+            code.constant().setValue(fmd.getIndex());\r\n+            code.invokevirtual().setMethod(ClassMetaData.class,\r\n+                \"getField\", FieldMetaData.class, new Class[]{ int.class });\r\n+            code.aload().setParam(0);\r\n+            code.constant().setValue(fmd.getIndex());\r\n+            code.constant().setValue(false);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"fetchField\", Object.class, new Class[]\r\n+                { int.class, boolean.class });\r\n+            code.aload().setParam(0);\r\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+                \"getContext\", StoreContext.class, null);\r\n+            code.invokevirtual().setMethod(bc.getName(), \"toData\",\r\n+                Object.class.getName(), toStrings(new Class []{\r\n+                FieldMetaData.class, Object.class, StoreContext.class }));\r\n+            code.astore().setLocal(local);\r\n+\r\n+            // if (val == NULL) {\r\n+            // \t\tval = null;\r\n+            // \t\tloaded.clear(index);\r\n+            // \t} else\r\n+            // \t\tloaded.set(index);\r\n+            // \tobjects[objectCount] = val;\r\n+            code.aload().setLocal(local);\r\n+            code.getstatic().setField(AbstractPCData.class, \"NULL\",\r\n+                Object.class);\r\n+            JumpInstruction ifins = code.ifacmpne();\r\n+            code.constant().setNull();\r\n+            code.astore().setLocal(local);\r\n+            code.aload().setThis();\r\n+            code.getfield().setField(\"loaded\", BitSet.class);\r\n+            code.constant().setValue(index);\r\n+            code.invokevirtual().setMethod(BitSet.class, \"clear\", void.class,\r\n+                new Class[]{ int.class });\r\n+            JumpInstruction go2 = code.go2();\r\n+            ifins.setTarget(code.aload().setThis());\r\n+            code.getfield().setField(\"loaded\", BitSet.class);\r\n+            code.constant().setValue(index);\r\n+            code.invokevirtual().setMethod(BitSet.class, \"set\", void.class,\r\n+                new Class[]{ int.class });\r\n+            go2.setTarget(code.aload().setThis());\r\n+            code.getfield().setField(\"objects\", Object[].class);\r\n+            code.constant().setValue(objectCount);\r\n+            code.aload().setLocal(local);\r\n+            code.aastore();\r\n+        }\r\n+        if (!usesImplData(fmd))\r\n+            return;\r\n+\r\n+        // storeImplData(sm, i, loaded.get(i);\r\n+        code.aload().setThis();\r\n+        code.aload().setParam(0);\r\n+        code.constant().setValue(index);\r\n+        code.aload().setThis();\r\n+        code.getfield().setField(\"loaded\", BitSet.class);\r\n+        code.constant().setValue(index);\r\n+        code.invokevirtual().setMethod(BitSet.class, \"get\", boolean.class,\r\n+            new Class[]{ int.class });\r\n+        code.invokevirtual().setMethod(\"storeImplData\", void.class,\r\n+            new Class[]{ OpenJPAStateManager.class, int.class, boolean.class });\r\n+    }\r\n+\r\n+    private void addNewEmbedded(BCClass bc) {\r\n+        // void newEmbeddedPCData(OpenJPAStateManager embedded)\r\n+        BCMethod meth = bc.declareMethod(\"newEmbeddedPCData\", PCData.class,\r\n+            new Class[]{ OpenJPAStateManager.class });\r\n+        Code code = meth.getCode(true);\r\n+        // return getStorageGenerator().generatePCData\r\n+        // \t\t(sm.getId(), sm.getMetaData());\r\n+        code.aload().setThis();\r\n+        code.getfield().setField(\"storageGenerator\", PCDataGenerator.class);\r\n+        code.aload().setParam(0);\r\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+            \"getId\", Object.class, null);\r\n+        code.aload().setParam(0);\r\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n+            \"getMetaData\", ClassMetaData.class, null);\r\n+        code.invokevirtual().setMethod(PCDataGenerator.class,\r\n+            \"generatePCData\", PCData.class, new Class[]\r\n+            { Object.class, ClassMetaData.class });\r\n+        code.areturn();\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+    }\r\n+\r\n+    private void addGetData(BCClass bc) {\r\n+        // return getObjectField(i);\r\n+        BCMethod method = bc.declareMethod(\"getData\", Object.class,\r\n+            new Class[]{ int.class });\r\n+        Code code = method.getCode(true);\r\n+        code.aload().setThis();\r\n+        code.iload().setParam(0);\r\n+        code.invokevirtual().setMethod(\"getObject\", Object.class,\r\n+            new Class[]{ int.class });\r\n+        code.areturn();\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+    }\r\n+\r\n+    /////////////\r\n+    // Utilities\r\n+    /////////////\r\n+\r\n+    /**\r\n+     * Return a valid {@link JavaTypes} constant for the given field\r\n+     */\r\n+    protected int replaceType(FieldMetaData fmd) {\r\n+        if (usesIntermediate(fmd))\r\n+            return JavaTypes.OBJECT;\r\n+        return fmd.getTypeCode();\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the given field uses a cacheable intermediate value.\r\n+     */\r\n+    protected boolean usesIntermediate(FieldMetaData fmd) {\r\n+        return fmd.usesIntermediate();\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the given type might have cacheable class-level impl data.\r\n+     */\r\n+    protected boolean usesImplData(ClassMetaData meta) {\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the given field might have cacheable impl data.\r\n+     */\r\n+    protected boolean usesImplData(FieldMetaData fmd) {\r\n+        return fmd.usesImplData() == null;\r\n+    }\r\n+\r\n+    /**\r\n+     * The number of fields with cacheable impl data.\r\n+     */\r\n+    private int countImplDataFields(ClassMetaData meta) {\r\n+        FieldMetaData[] fmds = meta.getFields();\r\n+        int count = 0;\r\n+        for (int i = 0; i < fmds.length; i++)\r\n+            if (usesImplData(fmds[i]))\r\n+                count++;\r\n+        return count;\r\n+    }\r\n+\r\n+    /**\r\n+     * Add method which defers to AbstractPCData.\r\n+     */\r\n+    protected void callAbstractPCData(BCClass bc, String name, Class retType,\r\n+        Class[] args) {\r\n+        BCMethod meth = bc.declareMethod(name, retType, args);\r\n+        Code code = meth.getCode(true);\r\n+        code.aload().setThis();\r\n+        for (int i = 0; i < args.length; i++)\r\n+            code.xload().setParam(i).setType(args[i]);\r\n+        code.invokevirtual().setMethod(AbstractPCData.class, name, retType,\r\n+            args);\r\n+        if (!void.class.equals(retType))\r\n+            code.xreturn().setType(retType);\r\n+        code.calculateMaxLocals();\r\n+        code.calculateMaxStack();\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the collection of {@link JumpInstruction}s to the given instruction,\r\n+     * clearing the collection in the process.\r\n+     */\r\n+    protected void setTarget(Instruction ins, Collection jumps) {\r\n+        for (Iterator it = jumps.iterator(); it.hasNext();)\r\n+            ((JumpInstruction) it.next()).setTarget(ins);\r\n+        jumps.clear();\r\n+    }\r\n+\r\n+    /**\r\n+     * Transform the given array of classes to strings.\r\n+     */\r\n+    private static String[] toStrings(Class[] cls) {\r\n+        String[] strings = new String[cls.length];\r\n+        for (int i = 0; i < strings.length; i++)\r\n+            strings[i] = cls[i].getName();\r\n+        return strings;\r\n+    }\r\n+\r\n+    /**\r\n+     * Dynamic {@link PCData}s generated will implement this interface\r\n+     * to simplify initialization.\r\n+     */\r\n+    public static interface DynamicPCData extends PCData {\r\n+\r\n+        public void setId(Object oid);\r\n+\r\n+        public PCDataGenerator getStorageGenerator();\r\n+\r\n+        public void setStorageGenerator (PCDataGenerator generator);\r\n+\t}\r\n+}\r"},{"sha":"71e1978320c4773b242aa8a120af1182bf4bbd09","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","previous_filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java"},{"sha":"9d5b213ff7f59726016d7f2ae7b07449b5b9958a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","status":"modified","additions":288,"deletions":288,"changes":576,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,288 +1,288 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.enhance;\n-\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.Map;\n-\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.util.ReferenceMap;\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n-import org.apache.openjpa.util.UserException;\n-import org.apache.openjpa.util.InvalidStateException;\n-\n-/**\n- * Tracks registered persistence-capable classes.\n- *\n- * @since 0.4.0\n- * @author Abe White\n- */\n-public class PCRegistry {\n-    // DO NOT ADD ADDITIONAL DEPENDENCIES TO THIS CLASS\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (PCRegistry.class);\n-\n-    // map of pc classes to meta structs; weak so the VM can GC classes\n-    private static final Map _metas = new ConcurrentReferenceHashMap\n-        (ReferenceMap.WEAK, ReferenceMap.HARD);\n-\n-    // register class listeners\n-    private static final Collection _listeners = new LinkedList();\n-\n-    /**\n-     * Register a {@link RegisterClassListener}.\n-     */\n-    public static void addRegisterClassListener(RegisterClassListener rcl) {\n-        if (rcl == null)\n-            return;\n-\n-        // we have to be positive that every listener gets notified for\n-        // every class, so lots of locking\n-        synchronized (_listeners) {\n-            _listeners.add(rcl);\n-        }\n-        synchronized (_metas) {\n-            for (Iterator itr = _metas.keySet().iterator(); itr.hasNext();)\n-                rcl.register((Class) itr.next());\n-        }\n-    }\n-\n-    /**\n-     * Removes a {@link RegisterClassListener}.\n-     */\n-    public static void removeRegisterClassListener(RegisterClassListener rcl) {\n-        synchronized (_listeners) {\n-            _listeners.remove(rcl);\n-        }\n-    }\n-\n-    /**\n-     * Get the field names for a <code>PersistenceCapable</code> class.\n-     */\n-    public static String[] getFieldNames(Class pcClass) {\n-        Meta meta = getMeta(pcClass);\n-        return meta.fieldNames;\n-    }\n-\n-    /**\n-     * Get the field types for a <code>PersistenceCapable</code> class.\n-     */\n-    public static Class[] getFieldTypes(Class pcClass) {\n-        Meta meta = getMeta(pcClass);\n-        return meta.fieldTypes;\n-    }\n-\n-    /**\n-     * Return the persistent superclass for a <code>PersistenceCapable</code>\n-     * class, or null if none. The superclass may or may not implement\n-     * {@link PersistenceCapable}, depending on the access type of the class.\n-     */\n-    public static Class getPersistentSuperclass(Class pcClass) {\n-        Meta meta = getMeta(pcClass);\n-        return meta.pcSuper;\n-    }\n-\n-    /**\n-     * Create a new instance of the class and assign its state manager.\n-     * The new instance has its flags set to <code>LOAD_REQUIRED</code>.\n-     */\n-    public static PersistenceCapable newInstance(Class pcClass,\n-        StateManager sm, boolean clear) {\n-        Meta meta = getMeta(pcClass);\n-        return (meta.pc == null) ? null : meta.pc.pcNewInstance(sm, clear);\n-    }\n-\n-    /**\n-     * Create a new instance of the class and assign its state manager and oid.\n-     * The new instance has its flags set to <code>LOAD_REQUIRED</code>.\n-     */\n-    public static PersistenceCapable newInstance(Class pcClass,\n-        StateManager sm, Object oid, boolean clear) {\n-        Meta meta = getMeta(pcClass);\n-        return (meta.pc == null) ? null : meta.pc.pcNewInstance(sm, oid, clear);\n-    }\n-\n-    /**\n-     * Return the persistence-capable type for <code>type</code>. This might\n-     * be a generated subclass of <code>type</code>.\n-     *\n-     * @since 1.1.0\n-     */\n-    public static Class getPCType(Class type) {\n-        Meta meta = getMeta(type);\n-        return (meta.pc == null) ? null : meta.pc.getClass();\n-    }\n-\n-    /**\n-     * Create a new identity object for the given\n-     * <code>PersistenceCapable</code> class.\n-     */\n-    public static Object newObjectId(Class pcClass) {\n-        Meta meta = getMeta(pcClass);\n-        return (meta.pc == null) ? null : meta.pc.pcNewObjectIdInstance();\n-    }\n-\n-    /**\n-     * Create a new identity object for the given\n-     * <code>PersistenceCapable</code> class, using the <code>String</code>\n-     * form of the constructor.\n-     */\n-    public static Object newObjectId(Class pcClass, String str) {\n-        Meta meta = getMeta(pcClass);\n-        return (meta.pc == null) ? null : meta.pc.pcNewObjectIdInstance(str);\n-    }\n-\n-    /**\n-     * Return the alias for the given type.\n-     */\n-    public static String getTypeAlias(Class pcClass) {\n-        return getMeta(pcClass).alias;\n-    }\n-\n-    /**\n-     * Copy fields from an outside source to the key fields in the identity\n-     * object.\n-     */\n-    public static void copyKeyFieldsToObjectId(Class pcClass, FieldSupplier fm,\n-        Object oid) {\n-        Meta meta = getMeta(pcClass);\n-        if (meta.pc == null)\n-            throw new UserException(_loc.get(\"copy-no-id\", pcClass));\n-\n-        meta.pc.pcCopyKeyFieldsToObjectId(fm, oid);\n-    }\n-\n-    /**\n-     * Copy fields to an outside source from the key fields in the identity\n-     * object.\n-     */\n-    public static void copyKeyFieldsFromObjectId(Class pcClass,\n-        FieldConsumer fm, Object oid) {\n-        Meta meta = getMeta(pcClass);\n-        if (meta.pc == null)\n-            throw new UserException(_loc.get(\"copy-no-id\", pcClass));\n-\n-        meta.pc.pcCopyKeyFieldsFromObjectId(fm, oid);\n-    }\n-\n-    /**\n-     * Register metadata by class.\n-     *\n-     * @param fieldTypes managed field types\n-     * @param fieldFlags managed field flags\n-     * @param sup the most immediate persistent superclass\n-     * @param pcClass the <code>PersistenceCapable</code> class\n-     * @param fieldNames managed field names\n-     * @param alias the class alias\n-     * @param pc an instance of the class, if not abstract\n-     */\n-    public static void register(Class pcClass, String[] fieldNames,\n-        Class[] fieldTypes, byte[] fieldFlags, Class sup, String alias,\n-        PersistenceCapable pc) {\n-        if (pcClass == null)\n-            throw new NullPointerException();\n-\n-        // we have to be positive that every listener gets notified for\n-        // every class, so lots of locking\n-        Meta meta = new Meta(pc, fieldNames, fieldTypes, sup, alias);\n-        synchronized (_metas) {\n-            _metas.put(pcClass, meta);\n-        }\n-        synchronized (_listeners) {\n-            for (Iterator i = _listeners.iterator(); i.hasNext();)\n-                ((RegisterClassListener) i.next()).register(pcClass);\n-        }\n-    }\n-\n-    /**\n-     * De-Register all metadata associated with the given ClassLoader. \n-     * Allows ClassLoaders to be garbage collected.\n-     *\n-     * @param cl the ClassLoader\n-     */\n-    public static void deRegister(ClassLoader cl) {\n-        synchronized (_metas) {\n-            for (Iterator i = _metas.keySet().iterator(); i.hasNext();) {\n-                Class pcClass = (Class) i.next();\n-                if (pcClass.getClassLoader() == cl) {\n-                    _metas.remove(pcClass);\n-                }\n-            }\n-        }\n-    }\n-    \n-    /**\n-     * Returns a collection of class objects of the registered\n-     * persistence-capable classes.\n-     */\n-    public static Collection getRegisteredTypes() {\n-        return Collections.unmodifiableCollection(_metas.keySet());\n-    }\n-\n-    /**\n-     * Returns <code>true</code> if <code>cls</code> is already registered.\n-     */\n-    public static boolean isRegistered(Class cls) {\n-        return _metas.containsKey(cls);\n-    }\n-\n-    /**\n-     * Look up the metadata for a <code>PersistenceCapable</code> class.\n-     */\n-    private static Meta getMeta(Class pcClass) {\n-        Meta ret = (Meta) _metas.get(pcClass);\n-        if (ret == null)\n-            throw new IllegalStateException(_loc.get(\"no-meta\", pcClass).\n-                getMessage());\n-        return ret;\n-    }\n-\n-    /**\n-     * Listener for persistent class registration events.\n-     */\n-    public static interface RegisterClassListener {\n-\n-        public void register(Class cls);\n-    }\n-\n-    /**\n-     * This is a helper class to manage metadata per persistence-capable class.\n-     */\n-    private static class Meta {\n-\n-        public final PersistenceCapable pc;\n-        public final String[] fieldNames;\n-        public final Class[] fieldTypes;\n-        public final Class pcSuper;\n-        public final String alias;\n-\n-        public Meta(PersistenceCapable pc, String[] fieldNames,\n-            Class[] fieldTypes, Class pcSuper, String alias) {\n-            this.pc = pc;\n-            this.fieldNames = fieldNames;\n-            this.fieldTypes = fieldTypes;\n-            this.pcSuper = pcSuper;\n-\t\t\tthis.alias = alias;\n-\t\t}\n-\t}\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.enhance;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Iterator;\r\n+import java.util.LinkedList;\r\n+import java.util.Map;\r\n+\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.ReferenceMap;\r\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\r\n+import org.apache.openjpa.util.UserException;\r\n+import org.apache.openjpa.util.InvalidStateException;\r\n+\r\n+/**\r\n+ * Tracks registered persistence-capable classes.\r\n+ *\r\n+ * @since 0.4.0\r\n+ * @author Abe White\r\n+ */\r\n+public class PCRegistry {\r\n+    // DO NOT ADD ADDITIONAL DEPENDENCIES TO THIS CLASS\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (PCRegistry.class);\r\n+\r\n+    // map of pc classes to meta structs; weak so the VM can GC classes\r\n+    private static final Map _metas = new ConcurrentReferenceHashMap\r\n+        (ReferenceMap.WEAK, ReferenceMap.HARD);\r\n+\r\n+    // register class listeners\r\n+    private static final Collection _listeners = new LinkedList();\r\n+\r\n+    /**\r\n+     * Register a {@link RegisterClassListener}.\r\n+     */\r\n+    public static void addRegisterClassListener(RegisterClassListener rcl) {\r\n+        if (rcl == null)\r\n+            return;\r\n+\r\n+        // we have to be positive that every listener gets notified for\r\n+        // every class, so lots of locking\r\n+        synchronized (_listeners) {\r\n+            _listeners.add(rcl);\r\n+        }\r\n+        synchronized (_metas) {\r\n+            for (Iterator itr = _metas.keySet().iterator(); itr.hasNext();)\r\n+                rcl.register((Class) itr.next());\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Removes a {@link RegisterClassListener}.\r\n+     */\r\n+    public static void removeRegisterClassListener(RegisterClassListener rcl) {\r\n+        synchronized (_listeners) {\r\n+            _listeners.remove(rcl);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the field names for a <code>PersistenceCapable</code> class.\r\n+     */\r\n+    public static String[] getFieldNames(Class pcClass) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        return meta.fieldNames;\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the field types for a <code>PersistenceCapable</code> class.\r\n+     */\r\n+    public static Class[] getFieldTypes(Class pcClass) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        return meta.fieldTypes;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the persistent superclass for a <code>PersistenceCapable</code>\r\n+     * class, or null if none. The superclass may or may not implement\r\n+     * {@link PersistenceCapable}, depending on the access type of the class.\r\n+     */\r\n+    public static Class getPersistentSuperclass(Class pcClass) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        return meta.pcSuper;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a new instance of the class and assign its state manager.\r\n+     * The new instance has its flags set to <code>LOAD_REQUIRED</code>.\r\n+     */\r\n+    public static PersistenceCapable newInstance(Class pcClass,\r\n+        StateManager sm, boolean clear) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        return (meta.pc == null) ? null : meta.pc.pcNewInstance(sm, clear);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a new instance of the class and assign its state manager and oid.\r\n+     * The new instance has its flags set to <code>LOAD_REQUIRED</code>.\r\n+     */\r\n+    public static PersistenceCapable newInstance(Class pcClass,\r\n+        StateManager sm, Object oid, boolean clear) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        return (meta.pc == null) ? null : meta.pc.pcNewInstance(sm, oid, clear);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the persistence-capable type for <code>type</code>. This might\r\n+     * be a generated subclass of <code>type</code>.\r\n+     *\r\n+     * @since 1.1.0\r\n+     */\r\n+    public static Class getPCType(Class type) {\r\n+        Meta meta = getMeta(type);\r\n+        return (meta.pc == null) ? null : meta.pc.getClass();\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a new identity object for the given\r\n+     * <code>PersistenceCapable</code> class.\r\n+     */\r\n+    public static Object newObjectId(Class pcClass) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        return (meta.pc == null) ? null : meta.pc.pcNewObjectIdInstance();\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a new identity object for the given\r\n+     * <code>PersistenceCapable</code> class, using the <code>String</code>\r\n+     * form of the constructor.\r\n+     */\r\n+    public static Object newObjectId(Class pcClass, String str) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        return (meta.pc == null) ? null : meta.pc.pcNewObjectIdInstance(str);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the alias for the given type.\r\n+     */\r\n+    public static String getTypeAlias(Class pcClass) {\r\n+        return getMeta(pcClass).alias;\r\n+    }\r\n+\r\n+    /**\r\n+     * Copy fields from an outside source to the key fields in the identity\r\n+     * object.\r\n+     */\r\n+    public static void copyKeyFieldsToObjectId(Class pcClass, FieldSupplier fm,\r\n+        Object oid) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        if (meta.pc == null)\r\n+            throw new UserException(_loc.get(\"copy-no-id\", pcClass));\r\n+\r\n+        meta.pc.pcCopyKeyFieldsToObjectId(fm, oid);\r\n+    }\r\n+\r\n+    /**\r\n+     * Copy fields to an outside source from the key fields in the identity\r\n+     * object.\r\n+     */\r\n+    public static void copyKeyFieldsFromObjectId(Class pcClass,\r\n+        FieldConsumer fm, Object oid) {\r\n+        Meta meta = getMeta(pcClass);\r\n+        if (meta.pc == null)\r\n+            throw new UserException(_loc.get(\"copy-no-id\", pcClass));\r\n+\r\n+        meta.pc.pcCopyKeyFieldsFromObjectId(fm, oid);\r\n+    }\r\n+\r\n+    /**\r\n+     * Register metadata by class.\r\n+     *\r\n+     * @param fieldTypes managed field types\r\n+     * @param fieldFlags managed field flags\r\n+     * @param sup the most immediate persistent superclass\r\n+     * @param pcClass the <code>PersistenceCapable</code> class\r\n+     * @param fieldNames managed field names\r\n+     * @param alias the class alias\r\n+     * @param pc an instance of the class, if not abstract\r\n+     */\r\n+    public static void register(Class pcClass, String[] fieldNames,\r\n+        Class[] fieldTypes, byte[] fieldFlags, Class sup, String alias,\r\n+        PersistenceCapable pc) {\r\n+        if (pcClass == null)\r\n+            throw new NullPointerException();\r\n+\r\n+        // we have to be positive that every listener gets notified for\r\n+        // every class, so lots of locking\r\n+        Meta meta = new Meta(pc, fieldNames, fieldTypes, sup, alias);\r\n+        synchronized (_metas) {\r\n+            _metas.put(pcClass, meta);\r\n+        }\r\n+        synchronized (_listeners) {\r\n+            for (Iterator i = _listeners.iterator(); i.hasNext();)\r\n+                ((RegisterClassListener) i.next()).register(pcClass);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * De-Register all metadata associated with the given ClassLoader. \r\n+     * Allows ClassLoaders to be garbage collected.\r\n+     *\r\n+     * @param cl the ClassLoader\r\n+     */\r\n+    public static void deRegister(ClassLoader cl) {\r\n+        synchronized (_metas) {\r\n+            for (Iterator i = _metas.keySet().iterator(); i.hasNext();) {\r\n+                Class pcClass = (Class) i.next();\r\n+                if (pcClass.getClassLoader() == cl) {\r\n+                    _metas.remove(pcClass);\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Returns a collection of class objects of the registered\r\n+     * persistence-capable classes.\r\n+     */\r\n+    public static Collection getRegisteredTypes() {\r\n+        return Collections.unmodifiableCollection(_metas.keySet());\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns <code>true</code> if <code>cls</code> is already registered.\r\n+     */\r\n+    public static boolean isRegistered(Class cls) {\r\n+        return _metas.containsKey(cls);\r\n+    }\r\n+\r\n+    /**\r\n+     * Look up the metadata for a <code>PersistenceCapable</code> class.\r\n+     */\r\n+    private static Meta getMeta(Class pcClass) {\r\n+        Meta ret = (Meta) _metas.get(pcClass);\r\n+        if (ret == null)\r\n+            throw new IllegalStateException(_loc.get(\"no-meta\", pcClass).\r\n+                getMessage());\r\n+        return ret;\r\n+    }\r\n+\r\n+    /**\r\n+     * Listener for persistent class registration events.\r\n+     */\r\n+    public static interface RegisterClassListener {\r\n+\r\n+        public void register(Class cls);\r\n+    }\r\n+\r\n+    /**\r\n+     * This is a helper class to manage metadata per persistence-capable class.\r\n+     */\r\n+    private static class Meta {\r\n+\r\n+        public final PersistenceCapable pc;\r\n+        public final String[] fieldNames;\r\n+        public final Class[] fieldTypes;\r\n+        public final Class pcSuper;\r\n+        public final String alias;\r\n+\r\n+        public Meta(PersistenceCapable pc, String[] fieldNames,\r\n+            Class[] fieldTypes, Class pcSuper, String alias) {\r\n+            this.pc = pc;\r\n+            this.fieldNames = fieldNames;\r\n+            this.fieldTypes = fieldTypes;\r\n+            this.pcSuper = pcSuper;\r\n+\t\t\tthis.alias = alias;\r\n+\t\t}\r\n+\t}\r\n+}\r"},{"sha":"4f87e14426c0a35b9258e6ac0543b7faf898195d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","status":"modified","additions":253,"deletions":253,"changes":506,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,253 +1,253 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.event;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Collections;\n-\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\n-import org.apache.openjpa.kernel.Broker;\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\n-import org.apache.openjpa.lib.util.Closeable;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\n-import org.apache.openjpa.util.UserException;\n-\n-/**\n- * Manager that can be used to track and notify\n- * {@link RemoteCommitListener}s on remote commit events. If remote events\n- * are enabled, this manager should be installed as a transaction listener on\n- * all brokers so that it knows when commits are made.\n- *\n- * @author Patrick Linskey\n- * @author Abe White\n- * @since 0.3.0\n- */\n-public class RemoteCommitEventManager\n-    extends AbstractConcurrentEventManager\n-    implements EndTransactionListener, Closeable {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (RemoteCommitEventManager.class);\n-\n-    private final RemoteCommitProvider _provider;\n-    private boolean _transmitPersIds = false;\n-\n-    /**\n-     * Constructor. Supply configuration.\n-     */\n-    public RemoteCommitEventManager(OpenJPAConfiguration conf) {\n-        _provider = conf.newRemoteCommitProviderInstance();\n-        if (_provider != null) {\n-            _provider.setRemoteCommitEventManager(this);\n-        }\n-    }\n-\n-    /**\n-     * Return true if remote events are enabled.\n-     */\n-    public boolean areRemoteEventsEnabled() {\n-        return _provider != null;\n-    }\n-\n-    /**\n-     * Return the {@link RemoteCommitProvider} that this manager uses.\n-     *\n-     * @since 0.3.1\n-     */\n-    public RemoteCommitProvider getRemoteCommitProvider() {\n-        return _provider;\n-    }\n-\n-    /**\n-     * Whether the oids of added instances will be transmitted.\n-     */\n-    public boolean getTransmitPersistedObjectIds() {\n-        return _transmitPersIds;\n-    }\n-\n-    /**\n-     * Whether the oids of added instances will be transmitted.\n-     */\n-    public void setTransmitPersistedObjectIds(boolean transmit) {\n-        _transmitPersIds = transmit;\n-    }\n-\n-    /**\n-     * Adds an OpenJPA-internal listener to this RemoteCommitEventManager.\n-     * Listeners so registered will be fired before any that are registered\n-     * via {@link #addListener}. This means that the external listeners can\n-     * rely on internal caches and data structures being up-to-date by the\n-     * time that they are invoked.\n-     *\n-     * @since 1.0.0\n-     */\n-    public void addInternalListener(RemoteCommitListener listen) {\n-        if (_provider == null)\n-            throw new UserException(_loc.get(\"no-provider\"));\n-        ((List) _listeners).add(0, listen);\n-    }\n-\n-    public void addListener(RemoteCommitListener listen) {\n-        if (_provider == null)\n-            throw new UserException(_loc.get(\"no-provider\"));\n-        super.addListener(listen);\n-    }\n-\n-    /**\n-     * Close this manager and all registered listeners.\n-     */\n-    public void close() {\n-        if (_provider != null) {\n-            _provider.close();\n-            Collection listeners = getListeners();\n-            for (Iterator itr = listeners.iterator(); itr.hasNext();)\n-                ((RemoteCommitListener) itr.next()).close();\n-        }\n-    }\n-\n-    protected void fireEvent(Object event, Object listener) {\n-        RemoteCommitListener listen = (RemoteCommitListener) listener;\n-        RemoteCommitEvent ev = (RemoteCommitEvent) event;\n-        listen.afterCommit(ev);\n-    }\n-\n-    /**\n-     * Fire an event to local listeners only notifying them of a detected\n-     * stale record.\n-     *\n-     * @since 1.0.0\n-     */\n-    public void fireLocalStaleNotification(Object oid) {\n-        RemoteCommitEvent ev = new RemoteCommitEvent(\n-            RemoteCommitEvent.PAYLOAD_LOCAL_STALE_DETECTION,\n-            null, null, Collections.singleton(oid), null);\n-        fireEvent(ev);\n-    }\n-\n-    //////////////////////////////////////\n-    // TransactionListener implementation\n-    //////////////////////////////////////\n-\n-    public void afterCommit(TransactionEvent event) {\n-        if (_provider != null) {\n-            RemoteCommitEvent rce = createRemoteCommitEvent(event);\n-            if (rce != null)\n-                _provider.broadcast(rce);\n-        }\n-    }\n-\n-    /**\n-     * Create a remote commit event from the given transaction event.\n-     */\n-    private RemoteCommitEvent createRemoteCommitEvent(TransactionEvent event) {\n-        Broker broker = (Broker) event.getSource();\n-        int payload;\n-        Collection persIds = null;\n-        Collection addClassNames = null;\n-        Collection updates = null;\n-        Collection deletes = null;\n-\n-        if (broker.isTrackChangesByType()) {\n-            payload = RemoteCommitEvent.PAYLOAD_EXTENTS;\n-            addClassNames = toClassNames(event.getPersistedTypes());\n-            updates = toClassNames(event.getUpdatedTypes());\n-            deletes = toClassNames(event.getDeletedTypes());\n-            if (addClassNames == null && updates == null && deletes == null)\n-                return null;\n-        } else {\n-            Collection trans = event.getTransactionalObjects();\n-            if (trans.isEmpty())\n-                return null;\n-\n-            payload = (_transmitPersIds)\n-                ? RemoteCommitEvent.PAYLOAD_OIDS_WITH_ADDS\n-                : RemoteCommitEvent.PAYLOAD_OIDS;\n-            Object oid;\n-            Object obj;\n-            OpenJPAStateManager sm;\n-            for (Iterator itr = trans.iterator(); itr.hasNext();) {\n-                obj = itr.next();\n-                sm = broker.getStateManager(obj);\n-\n-                if (sm == null || !sm.isPersistent() || !sm.isDirty())\n-                    continue;\n-                if (sm.isNew() && sm.isDeleted())\n-                    continue;\n-\n-                oid = sm.fetchObjectId();\n-                if (sm.isNew()) {\n-                    if (_transmitPersIds) {\n-                        if (persIds == null)\n-                            persIds = new ArrayList();\n-                        persIds.add(oid);\n-                    }\n-                    if (addClassNames == null)\n-                        addClassNames = new HashSet();\n-                    addClassNames.add(obj.getClass().getName());\n-                } else if (sm.isDeleted()) {\n-                    if (deletes == null)\n-                        deletes = new ArrayList();\n-                    deletes.add(oid);\n-                } else {\n-                    if (updates == null)\n-                        updates = new ArrayList();\n-                    updates.add(oid);\n-                }\n-            }\n-            if (addClassNames == null && updates == null && deletes == null)\n-                return null;\n-        }\n-        return new RemoteCommitEvent(payload, persIds, addClassNames, updates,\n-            deletes);\n-    }\n-\n-    /**\n-     * Transform a collection of classes to class names.\n-     */\n-    private static Collection toClassNames(Collection clss) {\n-        if (clss.isEmpty())\n-            return null;\n-\n-        List names = new ArrayList(clss);\n-        for (int i = 0; i < names.size(); i++)\n-            names.set(i, ((Class) names.get(i)).getName());\n-        return names;\n-    }\n-\n-    public void beforeCommit(TransactionEvent event) {\n-    }\n-\n-    public void afterRollback(TransactionEvent event) {\n-    }\n-\n-    public void afterCommitComplete(TransactionEvent event) {\n-    }\n-\n-    public void afterRollbackComplete(TransactionEvent event) {\n-    }\n-\n-    public void afterStateTransitions(TransactionEvent event)\n-\t{\n-\t}\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.HashSet;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Collections;\r\n+\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.kernel.Broker;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.lib.util.Closeable;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Manager that can be used to track and notify\r\n+ * {@link RemoteCommitListener}s on remote commit events. If remote events\r\n+ * are enabled, this manager should be installed as a transaction listener on\r\n+ * all brokers so that it knows when commits are made.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ * @since 0.3.0\r\n+ */\r\n+public class RemoteCommitEventManager\r\n+    extends AbstractConcurrentEventManager\r\n+    implements EndTransactionListener, Closeable {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (RemoteCommitEventManager.class);\r\n+\r\n+    private final RemoteCommitProvider _provider;\r\n+    private boolean _transmitPersIds = false;\r\n+\r\n+    /**\r\n+     * Constructor. Supply configuration.\r\n+     */\r\n+    public RemoteCommitEventManager(OpenJPAConfiguration conf) {\r\n+        _provider = conf.newRemoteCommitProviderInstance();\r\n+        if (_provider != null) {\r\n+            _provider.setRemoteCommitEventManager(this);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return true if remote events are enabled.\r\n+     */\r\n+    public boolean areRemoteEventsEnabled() {\r\n+        return _provider != null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the {@link RemoteCommitProvider} that this manager uses.\r\n+     *\r\n+     * @since 0.3.1\r\n+     */\r\n+    public RemoteCommitProvider getRemoteCommitProvider() {\r\n+        return _provider;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the oids of added instances will be transmitted.\r\n+     */\r\n+    public boolean getTransmitPersistedObjectIds() {\r\n+        return _transmitPersIds;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether the oids of added instances will be transmitted.\r\n+     */\r\n+    public void setTransmitPersistedObjectIds(boolean transmit) {\r\n+        _transmitPersIds = transmit;\r\n+    }\r\n+\r\n+    /**\r\n+     * Adds an OpenJPA-internal listener to this RemoteCommitEventManager.\r\n+     * Listeners so registered will be fired before any that are registered\r\n+     * via {@link #addListener}. This means that the external listeners can\r\n+     * rely on internal caches and data structures being up-to-date by the\r\n+     * time that they are invoked.\r\n+     *\r\n+     * @since 1.0.0\r\n+     */\r\n+    public void addInternalListener(RemoteCommitListener listen) {\r\n+        if (_provider == null)\r\n+            throw new UserException(_loc.get(\"no-provider\"));\r\n+        ((List) _listeners).add(0, listen);\r\n+    }\r\n+\r\n+    public void addListener(RemoteCommitListener listen) {\r\n+        if (_provider == null)\r\n+            throw new UserException(_loc.get(\"no-provider\"));\r\n+        super.addListener(listen);\r\n+    }\r\n+\r\n+    /**\r\n+     * Close this manager and all registered listeners.\r\n+     */\r\n+    public void close() {\r\n+        if (_provider != null) {\r\n+            _provider.close();\r\n+            Collection listeners = getListeners();\r\n+            for (Iterator itr = listeners.iterator(); itr.hasNext();)\r\n+                ((RemoteCommitListener) itr.next()).close();\r\n+        }\r\n+    }\r\n+\r\n+    protected void fireEvent(Object event, Object listener) {\r\n+        RemoteCommitListener listen = (RemoteCommitListener) listener;\r\n+        RemoteCommitEvent ev = (RemoteCommitEvent) event;\r\n+        listen.afterCommit(ev);\r\n+    }\r\n+\r\n+    /**\r\n+     * Fire an event to local listeners only notifying them of a detected\r\n+     * stale record.\r\n+     *\r\n+     * @since 1.0.0\r\n+     */\r\n+    public void fireLocalStaleNotification(Object oid) {\r\n+        RemoteCommitEvent ev = new RemoteCommitEvent(\r\n+            RemoteCommitEvent.PAYLOAD_LOCAL_STALE_DETECTION,\r\n+            null, null, Collections.singleton(oid), null);\r\n+        fireEvent(ev);\r\n+    }\r\n+\r\n+    //////////////////////////////////////\r\n+    // TransactionListener implementation\r\n+    //////////////////////////////////////\r\n+\r\n+    public void afterCommit(TransactionEvent event) {\r\n+        if (_provider != null) {\r\n+            RemoteCommitEvent rce = createRemoteCommitEvent(event);\r\n+            if (rce != null)\r\n+                _provider.broadcast(rce);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a remote commit event from the given transaction event.\r\n+     */\r\n+    private RemoteCommitEvent createRemoteCommitEvent(TransactionEvent event) {\r\n+        Broker broker = (Broker) event.getSource();\r\n+        int payload;\r\n+        Collection persIds = null;\r\n+        Collection addClassNames = null;\r\n+        Collection updates = null;\r\n+        Collection deletes = null;\r\n+\r\n+        if (broker.isTrackChangesByType()) {\r\n+            payload = RemoteCommitEvent.PAYLOAD_EXTENTS;\r\n+            addClassNames = toClassNames(event.getPersistedTypes());\r\n+            updates = toClassNames(event.getUpdatedTypes());\r\n+            deletes = toClassNames(event.getDeletedTypes());\r\n+            if (addClassNames == null && updates == null && deletes == null)\r\n+                return null;\r\n+        } else {\r\n+            Collection trans = event.getTransactionalObjects();\r\n+            if (trans.isEmpty())\r\n+                return null;\r\n+\r\n+            payload = (_transmitPersIds)\r\n+                ? RemoteCommitEvent.PAYLOAD_OIDS_WITH_ADDS\r\n+                : RemoteCommitEvent.PAYLOAD_OIDS;\r\n+            Object oid;\r\n+            Object obj;\r\n+            OpenJPAStateManager sm;\r\n+            for (Iterator itr = trans.iterator(); itr.hasNext();) {\r\n+                obj = itr.next();\r\n+                sm = broker.getStateManager(obj);\r\n+\r\n+                if (sm == null || !sm.isPersistent() || !sm.isDirty())\r\n+                    continue;\r\n+                if (sm.isNew() && sm.isDeleted())\r\n+                    continue;\r\n+\r\n+                oid = sm.fetchObjectId();\r\n+                if (sm.isNew()) {\r\n+                    if (_transmitPersIds) {\r\n+                        if (persIds == null)\r\n+                            persIds = new ArrayList();\r\n+                        persIds.add(oid);\r\n+                    }\r\n+                    if (addClassNames == null)\r\n+                        addClassNames = new HashSet();\r\n+                    addClassNames.add(obj.getClass().getName());\r\n+                } else if (sm.isDeleted()) {\r\n+                    if (deletes == null)\r\n+                        deletes = new ArrayList();\r\n+                    deletes.add(oid);\r\n+                } else {\r\n+                    if (updates == null)\r\n+                        updates = new ArrayList();\r\n+                    updates.add(oid);\r\n+                }\r\n+            }\r\n+            if (addClassNames == null && updates == null && deletes == null)\r\n+                return null;\r\n+        }\r\n+        return new RemoteCommitEvent(payload, persIds, addClassNames, updates,\r\n+            deletes);\r\n+    }\r\n+\r\n+    /**\r\n+     * Transform a collection of classes to class names.\r\n+     */\r\n+    private static Collection toClassNames(Collection clss) {\r\n+        if (clss.isEmpty())\r\n+            return null;\r\n+\r\n+        List names = new ArrayList(clss);\r\n+        for (int i = 0; i < names.size(); i++)\r\n+            names.set(i, ((Class) names.get(i)).getName());\r\n+        return names;\r\n+    }\r\n+\r\n+    public void beforeCommit(TransactionEvent event) {\r\n+    }\r\n+\r\n+    public void afterRollback(TransactionEvent event) {\r\n+    }\r\n+\r\n+    public void afterCommitComplete(TransactionEvent event) {\r\n+    }\r\n+\r\n+    public void afterRollbackComplete(TransactionEvent event) {\r\n+    }\r\n+\r\n+    public void afterStateTransitions(TransactionEvent event)\r\n+\t{\r\n+\t}\r\n+}\r"},{"sha":"c8a449a22371aa0c9f3b8a107b3f6258419317b9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","status":"modified","additions":65,"deletions":64,"changes":129,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,64 +1,65 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.event;\n-\n-import java.util.Iterator;\n-import java.util.Set;\n-\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashSet;\n-\n-/**\n- * Single-JVM-only implementation of {@link RemoteCommitProvider}\n- * that listens for object modifications and propagates those changes\n- * to other SingleJVMRemoteCommitProviders in the same JVM. This is\n- * only useful for linking together multiple factories in the same\n- * JVM that are all loaded in the same classloader, which is a rare\n- * circumstance.\n- *\n- * @author Patrick Linskey\n- * @since 0.2.5.0\n- */\n-public class SingleJVMRemoteCommitProvider\n-    extends AbstractRemoteCommitProvider {\n-\n-    private static Set s_providers = new ConcurrentHashSet();\n-\n-    public SingleJVMRemoteCommitProvider() {\n-        s_providers.add(this);\n-    }\n-\n-    public void broadcast(RemoteCommitEvent event) {\n-        SingleJVMRemoteCommitProvider provider;\n-        for (Iterator iter = s_providers.iterator(); iter.hasNext();) {\n-            provider = (SingleJVMRemoteCommitProvider) iter.next();\n-\n-            // don't notify this object -- this provider's factory\n-            // should not be notified of commits that originated\n-            // with one of its brokers\n-            if (provider == this)\n-                continue;\n-\n-            provider.fireEvent(event);\n-        }\n-    }\n-\n-    public void close() {\n-        s_providers.remove(this);\n-    }\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import java.util.Iterator;\r\n+import java.util.Set;\r\n+\r\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashSet;\r\n+\r\n+/**\r\n+ * Single-JVM-only implementation of {@link RemoteCommitProvider}\r\n+ * that listens for object modifications and propagates those changes\r\n+ * to other SingleJVMRemoteCommitProviders in the same JVM. This is\r\n+ * only useful for linking together multiple factories in the same\r\n+ * JVM that are all loaded in the same classloader, which is a rare\r\n+ * circumstance.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @since 0.2.5.0\r\n+ */\r\n+public class SingleJVMRemoteCommitProvider\r\n+    extends AbstractRemoteCommitProvider {\r\n+\r\n+    private static Set s_providers = new ConcurrentReferenceHashSet(\r\n+        ConcurrentReferenceHashSet.HARD);\r\n+\r\n+    public SingleJVMRemoteCommitProvider() {\r\n+        s_providers.add(this);\r\n+    }\r\n+\r\n+    public void broadcast(RemoteCommitEvent event) {\r\n+        SingleJVMRemoteCommitProvider provider;\r\n+        for (Iterator iter = s_providers.iterator(); iter.hasNext();) {\r\n+            provider = (SingleJVMRemoteCommitProvider) iter.next();\r\n+\r\n+            // don't notify this object -- this provider's factory\r\n+            // should not be notified of commits that originated\r\n+            // with one of its brokers\r\n+            if (provider == this)\r\n+                continue;\r\n+\r\n+            provider.fireEvent(event);\r\n+        }\r\n+    }\r\n+\r\n+    public void close() {\r\n+        s_providers.remove(this);\r\n+    }\r\n+}\r"},{"sha":"987cafaf0196195fa3805f52f169caac6ea61258","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","status":"modified","additions":948,"deletions":948,"changes":1896,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,948 +1,948 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.event;\n-\n-import java.io.BufferedInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.EOFException;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.OutputStream;\n-import java.net.InetAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.SocketException;\n-import java.net.UnknownHostException;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.List;\n-import java.util.Collections;\n-\n-import org.apache.commons.pool.PoolableObjectFactory;\n-import org.apache.commons.pool.impl.GenericObjectPool;\n-import org.apache.openjpa.lib.conf.Configurable;\n-import org.apache.openjpa.lib.log.Log;\n-import org.apache.openjpa.lib.util.J2DoPrivHelper;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.util.GeneralException;\n-import org.apache.openjpa.util.InternalException;\n-import org.apache.openjpa.util.Serialization;\n-import org.apache.openjpa.lib.util.concurrent.ReentrantLock;\n-\n-import serp.util.Strings;\n-\n-/**\n- * TCP-based implementation of {@link RemoteCommitProvider} that\n- * listens for object modifications and propagates those changes to\n- * other RemoteCommitProviders over TCP sockets.\n- *\n- * @author Brian Leair\n- * @author Patrick Linskey\n- * @since 0.2.5.0\n- */\n-public class TCPRemoteCommitProvider\n-    extends AbstractRemoteCommitProvider\n-    implements Configurable {\n-\n-    private static final int DEFAULT_PORT = 5636;\n-\n-    private static final Localizer s_loc = Localizer.forPackage\n-        (TCPRemoteCommitProvider.class);\n-    private static long s_idSequence = System.currentTimeMillis();\n-\n-    //\tA map of listen ports to listeners in this JVM. We might\n-    //\twant to look into allowing same port, different interface --\n-    //\tthat is not currently possible in a single JVM.\n-    private static final Map s_portListenerMap = new HashMap();\n-\n-    private long _id;\n-    private byte[] _localhost;\n-    private int _port = DEFAULT_PORT;\n-    private int _maxActive = 2;\n-    private int _maxIdle = 2;\n-    private int _recoveryTimeMillis = 15000;\n-    private TCPPortListener _listener;\n-    private BroadcastQueue _broadcastQueue = new BroadcastQueue();\n-    private final List _broadcastThreads = Collections.synchronizedList(\n-        new LinkedList());\n-\n-    private ArrayList _addresses = new ArrayList();\n-    private ReentrantLock _addressesLock;\n-\n-    public TCPRemoteCommitProvider()\n-        throws UnknownHostException {\n-        // obtain a unique ID.\n-        synchronized (TCPRemoteCommitProvider.class) {\n-            _id = s_idSequence++;\n-        }\n-\n-        // cache the local IP address.\n-        _localhost = InetAddress.getLocalHost().getAddress();\n-        _addressesLock = new ReentrantLock();\n-        setNumBroadcastThreads(2);\n-    }\n-\n-    /**\n-     * The port that this provider should listen on.\n-     */\n-    public int getPort() {\n-        return _port;\n-    }\n-\n-    /**\n-     * The port that this provider should listen on. Set once only.\n-     */\n-    public void setPort(int port) {\n-        _port = port;\n-    }\n-\n-    /**\n-     * The number of milliseconds to wait before retrying\n-     * to reconnect to a peer after it becomes unreachable.\n-     */\n-    public void setRecoveryTimeMillis(int recoverytime) {\n-        _recoveryTimeMillis = recoverytime;\n-    }\n-\n-    /**\n-     * The number of milliseconds to wait before retrying\n-     * to reconnect to a peer after it becomes unreachable.\n-     */\n-    public int getRecoveryTimeMillis() {\n-        return _recoveryTimeMillis;\n-    }\n-\n-    /**\n-     * The maximum number of sockets that this provider can\n-     * simetaneously open to each peer in the cluster.\n-     */\n-    public void setMaxActive(int maxActive) {\n-        _maxActive = maxActive;\n-    }\n-\n-    /**\n-     * The maximum number of sockets that this provider can\n-     * simetaneously open to each peer in the cluster.\n-     */\n-    public int getMaxActive() {\n-        return _maxActive;\n-    }\n-\n-    /**\n-     * The number of idle sockets that this provider can keep open\n-     * to each peer in the cluster.\n-     */\n-    public void setMaxIdle(int maxIdle) {\n-        _maxIdle = maxIdle;\n-    }\n-\n-    /**\n-     * The number of idle sockets that this provider can keep open\n-     * to each peer in the cluster.\n-     */\n-    public int getMaxIdle() {\n-        return _maxIdle;\n-    }\n-\n-    /**\n-     * The number of worker threads that are used for\n-     * transmitting packets to peers in the cluster.\n-     */\n-    public void setNumBroadcastThreads(int numBroadcastThreads) {\n-        synchronized (_broadcastThreads) {\n-            int cur = _broadcastThreads.size();\n-            if (cur > numBroadcastThreads) {\n-                // Notify the extra worker threads so they stop themselves\n-                // Threads will not end until they send another pk.\n-                for (int i = numBroadcastThreads; i < cur; i++) {\n-                    BroadcastWorkerThread worker = (BroadcastWorkerThread)\n-                        _broadcastThreads.remove(0);\n-                    worker.setRunning(false);\n-                }\n-            } else if (cur < numBroadcastThreads) {\n-                // Create additional worker threads\n-                for (int i = cur; i < numBroadcastThreads; i++) {\n-                    BroadcastWorkerThread wt = new BroadcastWorkerThread();\n-                    wt.setDaemon(true);\n-                    wt.start();\n-                    _broadcastThreads.add(wt);\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * The number of worker threads that are used for\n-     * transmitting packets to peers in the cluster.\n-     */\n-    public int getNumBroadcastThreads() {\n-        return _broadcastThreads.size();\n-    }\n-\n-    /**\n-     * Sets the list of addresses of peers to which this provider will\n-     * send events to. The peers are semicolon-separated <code>names</code>\n-     * list in the form of \"myhost1:portA;myhost2:portB\".\n-     */\n-    public void setAddresses(String names)\n-        throws UnknownHostException {\n-        // NYI. Could look for equivalence of addresses and avoid\n-        // changing those that didn't change.\n-\n-        _addressesLock.lock();\n-        try {\n-            for (Iterator iter = _addresses.iterator(); iter.hasNext();) {\n-                ((HostAddress) iter.next()).close();\n-            }\n-            String[] toks = Strings.split(names, \";\", 0);\n-            _addresses = new ArrayList(toks.length);\n-\n-            InetAddress localhost = InetAddress.getLocalHost();\n-            String localhostName = localhost.getHostName();\n-\n-            for (int i = 0; i < toks.length; i++) {\n-                String host = toks[i];\n-                String hostname;\n-                int tmpPort;\n-                int colon = host.indexOf(':');\n-                if (colon != -1) {\n-                    hostname = host.substring(0, colon);\n-                    tmpPort = Integer.parseInt(host.substring(colon + 1));\n-                } else {\n-                    hostname = host;\n-                    tmpPort = DEFAULT_PORT;\n-                }\n-                InetAddress tmpAddress = (InetAddress) AccessController\n-                    .doPrivileged(J2DoPrivHelper.getByNameAction(hostname)); \n-\n-                // bleair: For each address we would rather make use of\n-                // the jdk1.4 isLinkLocalAddress () || isLoopbackAddress ().\n-                // (Though in practice on win32 they don't work anyways!)\n-                // Instead we will check hostname. Not perfect, but\n-                // it will match often enough (people will typically\n-                // use the DNS machine names and be cutting/pasting.)\n-                if (localhostName.equals(hostname)) {\n-                    // This string matches the hostname for for ourselves, we\n-                    // don't actually need to send ourselves messages.\n-                    if (log.isTraceEnabled()) {\n-                        log.trace(s_loc.get(\"tcp-address-asself\",\n-                            tmpAddress.getHostName() + \":\" + tmpPort));\n-                    }\n-                } else {\n-                    HostAddress newAddress = new HostAddress(host);\n-                    _addresses.add(newAddress);\n-                    if (log.isTraceEnabled()) {\n-                        log.trace(s_loc.get(\"tcp-address-set\",\n-                            newAddress._address.getHostName() + \":\"\n-                                + newAddress._port));\n-                    }\n-                }\n-            }\n-        } catch (PrivilegedActionException pae) {\n-            throw (UnknownHostException) pae.getException();\n-        } finally {\n-            _addressesLock.unlock();\n-        }\n-    }\n-\n-    // ---------- Configurable implementation ----------\n-\n-    /**\n-     * Subclasses that need to perform actions in\n-     * {@link Configurable#endConfiguration} must invoke this method.\n-     */\n-    public void endConfiguration() {\n-        super.endConfiguration();\n-        synchronized (s_portListenerMap) {\n-            // see if a listener exists for this port.\n-            _listener = (TCPPortListener) s_portListenerMap.get\n-                (String.valueOf(_port));\n-\n-            if (_listener == null ||\n-                (!_listener.isRunning() && _listener._port == _port)) {\n-                try {\n-                    _listener = new TCPPortListener(_port, log);\n-                    _listener.listen();\n-                    s_portListenerMap.put(String.valueOf(_port), _listener);\n-                } catch (Exception e) {\n-                    throw new GeneralException(s_loc.get(\"tcp-init-exception\",\n-                        String.valueOf(_port)), e).setFatal(true);\n-                }\n-            } else if (_listener.isRunning()) {\n-                if (_listener._port != _port) {\n-                    // this really shouldn't be able to happen.\n-                    throw new GeneralException(s_loc.get\n-                        (\"tcp-not-equal\", String.valueOf(_port))).\n-                        setFatal(true);\n-                }\n-            } else\n-                throw new InternalException(s_loc.get(\"tcp-listener-broken\"));\n-            _listener.addProvider(this);\n-        }\n-\n-        _addressesLock.lock();\n-        try {\n-            HostAddress curAddress;\n-            for (Iterator iter = _addresses.iterator();\n-                iter.hasNext();) {\n-                curAddress = (HostAddress) iter.next();\n-                curAddress.setMaxActive(_maxActive);\n-                curAddress.setMaxIdle(_maxIdle);\n-            }\n-        }\n-        finally {\n-            _addressesLock.unlock();\n-        }\n-    }\n-\n-    // ---------- RemoteCommitProvider implementation ----------\n-\n-    // pre 3.3.4\t= <no version number transmitted>\n-    // 3.3 Preview \t= 0x1428acfd;\n-    // 3.4 \t\t\t= 0x1428acff;\n-    private static final long PROTOCOL_VERSION = 0x1428acff;\n-\n-    public void broadcast(RemoteCommitEvent event) {\n-        try {\n-            // build a packet notifying other JVMs of object changes.\n-            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-            ObjectOutputStream oos = new ObjectOutputStream(baos);\n-\n-            oos.writeLong(PROTOCOL_VERSION);\n-            oos.writeLong(_id);\n-            oos.writeInt(_port);\n-            oos.writeObject(_localhost);\n-            oos.writeObject(event);\n-            oos.flush();\n-\n-            byte[] bytes = baos.toByteArray();\n-            baos.close();\n-            if (_broadcastThreads.isEmpty())\n-                sendUpdatePacket(bytes);\n-            else\n-                _broadcastQueue.addPacket(bytes);\n-        } catch (IOException ioe) {\n-            if (log.isWarnEnabled())\n-                log.warn(s_loc.get(\"tcp-payload-create-error\"), ioe);\n-        }\n-    }\n-\n-    /**\n-     * Sends a change notification packet to other machines in this\n-     * provider cluster.\n-     */\n-    private void sendUpdatePacket(byte[] bytes) {\n-        _addressesLock.lock();\n-        try {\n-            for (Iterator iter = _addresses.iterator(); iter.hasNext();)\n-                ((HostAddress) iter.next()).sendUpdatePacket(bytes);\n-        } finally {\n-            _addressesLock.unlock();\n-        }\n-    }\n-\n-    public void close() {\n-        if (_listener != null)\n-            _listener.removeProvider(this);\n-\n-        // Remove Broadcast Threads then close sockets.\n-        _broadcastQueue.close();\n-\n-        // Wait for _broadcastThreads to get cleaned up.\n-        while(!_broadcastThreads.isEmpty()) {\n-            try {\n-                Thread.sleep(500);\n-            } catch (InterruptedException ie) {\n-                // Ignore.\n-            }\n-        }\n-        \n-        _addressesLock.lock();\n-        try {\n-            for (Iterator iter = _addresses.iterator(); iter.hasNext();)\n-                ((HostAddress) iter.next()).close();\n-        } finally {\n-            _addressesLock.unlock();\n-        }\n-    }\n-\n-    /**\n-     * Utility class to hold messages to be sent. This\n-     * allows calls to broadcast () to return without\n-     * waiting for the send to complete.\n-     */\n-    private static class BroadcastQueue {\n-\n-        private LinkedList _packetQueue = new LinkedList();\n-        private boolean _closed = false;\n-\n-        public synchronized void close() {\n-            _closed = true;\n-            notifyAll();\n-        }\n-\n-        public synchronized boolean isClosed() {\n-            return _closed;\n-        }\n-\n-        public synchronized void addPacket(byte[] bytes) {\n-            _packetQueue.addLast(bytes);\n-            notify();\n-        }\n-\n-        /**\n-         * @return the bytes defining the packet to process, or\n-         * <code>null</code> if the queue is empty.\n-         */\n-        public synchronized byte[] removePacket()\n-            throws InterruptedException {\n-            // only wait if the queue is still open. This allows processing\n-            // of events in the queue to continue, while avoiding sleeping\n-            // during shutdown.\n-            while (!_closed && _packetQueue.isEmpty())\n-                wait();\n-            if (_packetQueue.isEmpty())\n-                return null;\n-            else\n-                return (byte[]) _packetQueue.removeFirst();\n-        }\n-    }\n-\n-    /**\n-     * Threads to broadcast packets placed in the {@link BroadcastQueue}.\n-     */\n-    private class BroadcastWorkerThread\n-        extends Thread {\n-\n-        private boolean _keepRunning = true;\n-\n-        public void run() {\n-            while (_keepRunning) {\n-                try {\n-                    // This will block until there is a packet to send, or\n-                    // until the queue is closed.\n-                    byte[] bytes = _broadcastQueue.removePacket();\n-                    if (bytes != null)\n-                        sendUpdatePacket(bytes);\n-                    else if (_broadcastQueue.isClosed())\n-                        _keepRunning = false;\n-                } catch (InterruptedException e) {\n-                    // End the thread.\n-                    break;\n-                }\n-            }\n-            remove();\n-        }\n-\n-        public void setRunning(boolean keepRunning) {\n-            _keepRunning = keepRunning;\n-        }\n-        \n-        private void remove() {\n-            _broadcastThreads.remove(this);\n-        }\n-    }\n-\n-    /**\n-     * Responsible for listening for incoming packets and processing them.\n-     */\n-    private static class TCPPortListener\n-        implements Runnable {\n-\n-        private final Log _log;\n-        private ServerSocket _receiveSocket;\n-        private Thread _acceptThread;\n-        private Set _receiverThreads = new HashSet();\n-        private final Set _providers = new HashSet();\n-\n-        /**\n-         * Cache the local IP address\n-         */\n-        private byte[] _localhost;\n-\n-        /**\n-         * The port that this listener should listen on. Configured\n-         * by TCPRemoteCommitProvider.\n-         */\n-        private int _port;\n-\n-        /**\n-         * Should be set to <code>true</code> once the listener is listening.\n-         */\n-        private boolean _isRunning = false;\n-\n-        /**\n-         * Construct a new TCPPortListener configured to use the specified port.\n-         */\n-        private TCPPortListener(int port, Log log)\n-            throws IOException {\n-            _port = port;\n-            _log = log;\n-            try {\n-                _receiveSocket = (ServerSocket) AccessController\n-                    .doPrivileged(J2DoPrivHelper.newServerSocketAction(_port));\n-            } catch (PrivilegedActionException pae) {\n-                throw (IOException) pae.getException();\n-            }\n-            _localhost = InetAddress.getLocalHost().getAddress();\n-\n-            if (_log.isTraceEnabled())\n-                _log.info(s_loc.get(\"tcp-start-listener\",\n-                    String.valueOf(_port)));\n-        }\n-\n-        private void listen() {\n-            _acceptThread = new Thread(this);\n-            _acceptThread.setDaemon(true);\n-            _acceptThread.start();\n-        }\n-\n-        /**\n-         * All providers added here will be notified of any incoming\n-         * provider messages. There will be one of these per\n-         * BrokerFactory in a given JVM.\n-         * {@link TCPRemoteCommitProvider#endConfiguration} invokes\n-         * <code>addProvider</code> with <code>this</code> upon\n-         * completion of configuration.\n-         */\n-        private void addProvider(TCPRemoteCommitProvider provider) {\n-            synchronized (_providers) {\n-                _providers.add(provider);\n-            }\n-        }\n-\n-        /**\n-         * Remove a provider from the list of providers to notify of\n-         * commit events.\n-         */\n-        private synchronized void removeProvider\n-            (TCPRemoteCommitProvider provider) {\n-            synchronized (_providers) {\n-                _providers.remove(provider);\n-\n-                // if the provider list is empty, shut down the thread.\n-                if (_providers.size() == 0) {\n-                    _isRunning = false;\n-                    try {\n-                        _receiveSocket.close();\n-                    } catch (IOException ioe) {\n-                        if (_log.isWarnEnabled())\n-                            _log.warn(s_loc.get(\"tcp-close-error\"), ioe);\n-                    }\n-                    _acceptThread.interrupt();\n-                }\n-            }\n-        }\n-\n-        private boolean isRunning() {\n-            synchronized (_providers) {\n-                return _isRunning;\n-            }\n-        }\n-\n-        public void run() {\n-            synchronized (_providers) {\n-                _isRunning = true;\n-            }\n-\n-            Socket s = null;\n-            while (_isRunning) {\n-                try {\n-                    s = null;\n-                    // Block, waiting to accept new connection from a peer\n-                    s = (Socket) AccessController.doPrivileged(J2DoPrivHelper\n-                        .acceptAction(_receiveSocket));\n-                    if (_log.isTraceEnabled()) {\n-                        _log.trace(s_loc.get(\"tcp-received-connection\",\n-                            s.getInetAddress().getHostAddress()\n-                                + \":\" + s.getPort()));\n-                    }\n-                    ReceiveSocketHandler sh = new ReceiveSocketHandler(s);\n-                    Thread receiverThread = new Thread(sh);\n-                    receiverThread.setDaemon(true);\n-                    receiverThread.start();\n-                    _receiverThreads.add(receiverThread);\n-                } catch (Exception e) {\n-                    if (e instanceof PrivilegedActionException)\n-                        e = ((PrivilegedActionException) e).getException();\n-                    if (!(e instanceof SocketException) || _isRunning)\n-                        if (_log.isWarnEnabled())\n-                            _log.warn(s_loc.get(\"tcp-accept-error\"), e);\n-\n-                    // Nominal case (InterruptedException) because close ()\n-                    // calls _acceptThread.interrupt ();\n-                    try {\n-                        if (s != null)\n-                            s.close();\n-                    } catch (Exception ee) {\n-                        if (_log.isWarnEnabled())\n-                            _log.warn(s_loc.get(\"tcp-close-error\"), e);\n-                    }\n-                }\n-            }\n-\n-            // We are done listening. Interrupt any worker threads.\n-            Thread worker;\n-            for (Iterator iter = _receiverThreads.iterator();\n-                iter.hasNext();) {\n-                worker = (Thread) iter.next();\n-                // FYI, the worker threads are blocked\n-                // reading from the socket's InputStream. InputStreams\n-                // aren't interruptable, so this interrupt isn't\n-                // really going to be delivered until something breaks\n-                // the InputStream.\n-                worker.interrupt();\n-            }\n-            synchronized (_providers) {\n-                try {\n-                    if (_isRunning)\n-                        _receiveSocket.close();\n-                } catch (Exception e) {\n-                    if (_log.isWarnEnabled())\n-                        _log.warn(s_loc.get(\"tcp-close-error\"), e);\n-                }\n-                _isRunning = false;\n-                if (_log.isTraceEnabled())\n-                    _log.trace(s_loc.get(\"tcp-close-listener\",\n-                        _port + \"\"));\n-            }\n-        }\n-\n-        /**\n-         * Utility class that acts as a worker thread to receive Events\n-         * from broadcasters.\n-         */\n-        private class ReceiveSocketHandler\n-            implements Runnable {\n-\n-            private InputStream _in;\n-            private Socket _s;\n-\n-            private ReceiveSocketHandler(Socket s) {\n-                // We are the receiving end and we don't send any messages\n-                // back to the broadcaster. Turn off Nagle's so that\n-                // we will send ack packets without waiting.\n-                _s = s;\n-                try {\n-                    _s.setTcpNoDelay(true);\n-                    _in = new BufferedInputStream(s.getInputStream());\n-                } catch (IOException ioe) {\n-                    if (_log.isInfoEnabled())\n-                        _log.info(s_loc.get(\"tcp-socket-option-error\"), ioe);\n-                    _s = null;\n-                } catch (Exception e) {\n-                    if (_log.isWarnEnabled())\n-                        _log.warn(s_loc.get(\"tcp-receive-error\"), e);\n-                    _s = null;\n-                }\n-            }\n-\n-            public void run() {\n-                if (_s == null)\n-                    return;\n-                while (_isRunning && _s != null) {\n-                    try {\n-                        // This will block our thread, waiting to read\n-                        // the next Event-object-message.\n-                        handle(_in);\n-                    } catch (EOFException eof) {\n-                        // EOFException raised when peer is properly\n-                        // closing its end.\n-                        if (_log.isTraceEnabled()) {\n-                            _log.trace(s_loc.get(\"tcp-close-socket\",\n-                                _s.getInetAddress().getHostAddress()\n-                                    + \":\" + _s.getPort()));\n-                        }\n-                        break;\n-                    } catch (Throwable e) {\n-                        if (_log.isWarnEnabled())\n-                            _log.warn(s_loc.get(\"tcp-receive-error\"), e);\n-                        break;\n-                    }\n-                }\n-                // We are done receiving on this socket and this worker\n-                // thread is terminating.\n-                try {\n-                    _in.close();\n-                    if (_s != null)\n-                        _s.close();\n-                } catch (IOException e) {\n-                    _log.warn(s_loc.get(\"tcp-close-socket-error\",\n-                        _s.getInetAddress().getHostAddress() + \":\"\n-                            + _s.getPort()), e);\n-                }\n-            }\n-\n-            /**\n-             * Process an {@link InputStream} containing objects written\n-             * by {@link TCPRemoteCommitProvider#broadcast(RemoteCommitEvent)}.\n-             */\n-            private void handle(InputStream in)\n-                throws IOException, ClassNotFoundException {\n-                // This will block waiting for the next\n-                ObjectInputStream ois = \n-                    new Serialization.ClassResolvingObjectInputStream(in);\n-\n-                long protocolVersion = ois.readLong();\n-                if (protocolVersion != PROTOCOL_VERSION) {\n-                    if (_log.isWarnEnabled()) {\n-                        _log.warn(s_loc.get(\"tcp-wrong-version-error\",\n-                            _s.getInetAddress().getHostAddress() + \":\"\n-                                + _s.getPort()));\n-                        return;\n-                    }\n-                }\n-\n-                long senderId = ois.readLong();\n-                int senderPort = ois.readInt();\n-                byte[] senderAddress = (byte[]) ois.readObject();\n-                RemoteCommitEvent rce = (RemoteCommitEvent) ois.readObject();\n-                if (_log.isTraceEnabled()) {\n-                    _log.trace(s_loc.get(\"tcp-received-event\",\n-                        _s.getInetAddress().getHostAddress() + \":\"\n-                            + _s.getPort()));\n-                }\n-\n-                boolean fromSelf = senderPort == _port &&\n-                    Arrays.equals(senderAddress, _localhost);\n-                TCPRemoteCommitProvider provider;\n-                synchronized (_providers) {\n-                    // bleair: We're iterating, but currenlty there can really\n-                    // only be a single provider.\n-                    for (Iterator iter = _providers.iterator();\n-                        iter.hasNext();) {\n-                        provider = (TCPRemoteCommitProvider) iter.next();\n-                        if (senderId != provider._id || !fromSelf)\n-                            provider.eventManager.fireEvent(rce);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Utility class to store an InetAddress and an int. Not using\n-     * InetSocketAddress because it's a JDK1.4 API. This also\n-     * provides a wrapper around the socket(s) associated with this address.\n-     */\n-    private class HostAddress {\n-\n-        private InetAddress _address;\n-        private int _port;\n-        private long _timeLastError; // millis\n-        private boolean _isAvailable; // is peer thought to be up\n-        private int _infosIssued = 0; // limit log entries\n-\n-        private GenericObjectPool _socketPool; // reusable open sockets\n-\n-        /**\n-         * Construct a new host address from a string of the form\n-         * \"host:port\" or of the form \"host\".\n-         */\n-        private HostAddress(String host)\n-            throws UnknownHostException {\n-            int colon = host.indexOf(':');\n-            try {\n-                if (colon != -1) {\n-                    _address = (InetAddress) AccessController\n-                        .doPrivileged(J2DoPrivHelper.getByNameAction(host\n-                            .substring(0, colon)));\n-                    _port = Integer.parseInt(host.substring(colon + 1));\n-                } else {\n-                    _address = (InetAddress) AccessController\n-                        .doPrivileged(J2DoPrivHelper.getByNameAction(host));\n-                    _port = DEFAULT_PORT;\n-                }\n-            } catch (PrivilegedActionException pae) {\n-                throw (UnknownHostException) pae.getException();\n-            }\n-            // -1 max wait == as long as it takes\n-            _socketPool = new GenericObjectPool\n-                (new SocketPoolableObjectFactory(), _maxActive,\n-                    GenericObjectPool.WHEN_EXHAUSTED_BLOCK, -1);\n-            _isAvailable = true;\n-        }\n-\n-        private void setMaxActive(int maxActive) {\n-            _socketPool.setMaxActive(maxActive);\n-        }\n-\n-        private void setMaxIdle(int maxIdle) {\n-            _socketPool.setMaxIdle(maxIdle);\n-        }\n-\n-        public void close() {\n-            // Close the pool of sockets to this peer. This\n-            // will close all sockets in the pool.\n-            try {\n-                _socketPool.close();\n-            } catch (Exception e) {\n-                if (log.isWarnEnabled()) {\n-                    log.warn(s_loc.get(\"tcp-close-pool-error\"), e);\n-                }\n-            }\n-        }\n-\n-        private void sendUpdatePacket(byte[] bytes) {\n-            if (!_isAvailable) {\n-                long now = System.currentTimeMillis();\n-                if (now - _timeLastError < _recoveryTimeMillis)\n-                    // Not enough time has passed since the last error\n-                    return;\n-            }\n-            Socket s = null;\n-            try {\n-                s = getSocket();\n-                OutputStream os = s.getOutputStream();\n-                os.write(bytes);\n-                os.flush();\n-\n-                if (log.isTraceEnabled()) {\n-                    log.trace(s_loc.get(\"tcp-sent-update\",\n-                        _address.getHostAddress() + \":\" + _port,\n-                        String.valueOf(s.getLocalPort())));\n-                }\n-                _isAvailable = true;\n-                _infosIssued = 0;\n-                // Return the socket to the pool; the socket is\n-                // still good.\n-                returnSocket(s);\n-            } catch (Exception e) {\n-                // There has been a problem sending to the peer.\n-                // The OS socket that was being used is can no longer\n-                // be used.\n-                if (s != null)\n-                    this.closeSocket(s);\n-                this.clearAllSockets();\n-\n-                if (_isAvailable) {\n-                    // Log a warning, the peer was up and has now gone down\n-                    if (log.isWarnEnabled()) {\n-                        log.warn(s_loc.get(\"tcp-send-error\",\n-                            _address.getHostAddress() + \":\" + _port), e);\n-                    }\n-                    _isAvailable = false;\n-                    // Once enough time has passed we will log another warning\n-                    _timeLastError = System.currentTimeMillis();\n-                } else {\n-                    long now = System.currentTimeMillis();\n-                    if (now - _timeLastError > _recoveryTimeMillis) {\n-                        if (_infosIssued < 5) {\n-                            // Enough time has passed, and peer is still down\n-                            _timeLastError = System.currentTimeMillis();\n-                            // We were trying to reestablish the connection,\n-                            // but we failed again. Log a message, but\n-                            // lower severity. This log will occur periodically\n-                            // for 5 times until the peer comes back.\n-                            if (log.isInfoEnabled()) {\n-                                log.info(s_loc.get(\"tcp-send-still-error\",\n-                                    _address.getHostAddress() + \":\"\n-                                        + _port), e);\n-                            }\n-                            _infosIssued++;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        private Socket getSocket()\n-            throws Exception {\n-            return (Socket) _socketPool.borrowObject();\n-        }\n-\n-        private void returnSocket(Socket s)\n-            throws Exception {\n-            _socketPool.returnObject(s);\n-        }\n-\n-        private void clearAllSockets() {\n-            _socketPool.clear();\n-        }\n-\n-        private void closeSocket(Socket s) {\n-            // All sockets come from the pool.\n-            // This socket is no longer usable, so delete it from the\n-            // pool.\n-            try {\n-                _socketPool.invalidateObject(s);\n-            } catch (Exception e) {\n-            }\n-        }\n-\n-        /**\n-         * Factory for pooled sockets.\n-         */\n-        private class SocketPoolableObjectFactory\n-            implements PoolableObjectFactory {\n-\n-            public Object makeObject()\n-                throws IOException {\n-                try {\n-                    Socket s = (Socket) AccessController\n-                        .doPrivileged(J2DoPrivHelper.newSocketAction(_address,\n-                            _port));\n-                    if (log.isTraceEnabled()) {\n-                        log.trace(s_loc.get(\"tcp-open-connection\", _address\n-                            + \":\" + _port, \"\" + s.getLocalPort()));\n-                    }\n-                    return s;\n-                } catch (PrivilegedActionException pae) {\n-                    throw (IOException) pae.getException();\n-                }\n-            }\n-\n-            public void destroyObject(Object obj) {\n-                // silentClose ().\n-                try {\n-                    Socket s = (Socket) obj;\n-                    if (log.isTraceEnabled())\n-                        log.trace(s_loc.get(\"tcp-close-sending-socket\",\n-                            _address + \":\" + _port, \"\" + s.getLocalPort()));\n-                    s.close();\n-                } catch (Exception e) {\n-                    log.warn(s_loc.get(\"tcp-close-socket-error\",\n-                        _address.getHostAddress() + \":\" + _port), e);\n-                }\n-            }\n-\n-            public boolean validateObject(Object obj) {\n-                return true;\n-            }\n-\n-            public void activateObject (Object value)\n-\t\t\t{\n-\t\t\t}\n-\n-\t\t\tpublic void passivateObject (Object value)\n-\t\t\t{\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import java.io.BufferedInputStream;\r\n+import java.io.ByteArrayOutputStream;\r\n+import java.io.EOFException;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.ObjectOutputStream;\r\n+import java.io.OutputStream;\r\n+import java.net.InetAddress;\r\n+import java.net.ServerSocket;\r\n+import java.net.Socket;\r\n+import java.net.SocketException;\r\n+import java.net.UnknownHostException;\r\n+import java.security.AccessController;\r\n+import java.security.PrivilegedActionException;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.Iterator;\r\n+import java.util.LinkedList;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+import java.util.List;\r\n+import java.util.Collections;\r\n+\r\n+import org.apache.commons.pool.PoolableObjectFactory;\r\n+import org.apache.commons.pool.impl.GenericObjectPool;\r\n+import org.apache.openjpa.lib.conf.Configurable;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.util.GeneralException;\r\n+import org.apache.openjpa.util.InternalException;\r\n+import org.apache.openjpa.util.Serialization;\r\n+import java.util.concurrent.locks.ReentrantLock;\r\n+\r\n+import serp.util.Strings;\r\n+\r\n+/**\r\n+ * TCP-based implementation of {@link RemoteCommitProvider} that\r\n+ * listens for object modifications and propagates those changes to\r\n+ * other RemoteCommitProviders over TCP sockets.\r\n+ *\r\n+ * @author Brian Leair\r\n+ * @author Patrick Linskey\r\n+ * @since 0.2.5.0\r\n+ */\r\n+public class TCPRemoteCommitProvider\r\n+    extends AbstractRemoteCommitProvider\r\n+    implements Configurable {\r\n+\r\n+    private static final int DEFAULT_PORT = 5636;\r\n+\r\n+    private static final Localizer s_loc = Localizer.forPackage\r\n+        (TCPRemoteCommitProvider.class);\r\n+    private static long s_idSequence = System.currentTimeMillis();\r\n+\r\n+    //\tA map of listen ports to listeners in this JVM. We might\r\n+    //\twant to look into allowing same port, different interface --\r\n+    //\tthat is not currently possible in a single JVM.\r\n+    private static final Map s_portListenerMap = new HashMap();\r\n+\r\n+    private long _id;\r\n+    private byte[] _localhost;\r\n+    private int _port = DEFAULT_PORT;\r\n+    private int _maxActive = 2;\r\n+    private int _maxIdle = 2;\r\n+    private int _recoveryTimeMillis = 15000;\r\n+    private TCPPortListener _listener;\r\n+    private BroadcastQueue _broadcastQueue = new BroadcastQueue();\r\n+    private final List _broadcastThreads = Collections.synchronizedList(\r\n+        new LinkedList());\r\n+\r\n+    private ArrayList _addresses = new ArrayList();\r\n+    private ReentrantLock _addressesLock;\r\n+\r\n+    public TCPRemoteCommitProvider()\r\n+        throws UnknownHostException {\r\n+        // obtain a unique ID.\r\n+        synchronized (TCPRemoteCommitProvider.class) {\r\n+            _id = s_idSequence++;\r\n+        }\r\n+\r\n+        // cache the local IP address.\r\n+        _localhost = InetAddress.getLocalHost().getAddress();\r\n+        _addressesLock = new ReentrantLock();\r\n+        setNumBroadcastThreads(2);\r\n+    }\r\n+\r\n+    /**\r\n+     * The port that this provider should listen on.\r\n+     */\r\n+    public int getPort() {\r\n+        return _port;\r\n+    }\r\n+\r\n+    /**\r\n+     * The port that this provider should listen on. Set once only.\r\n+     */\r\n+    public void setPort(int port) {\r\n+        _port = port;\r\n+    }\r\n+\r\n+    /**\r\n+     * The number of milliseconds to wait before retrying\r\n+     * to reconnect to a peer after it becomes unreachable.\r\n+     */\r\n+    public void setRecoveryTimeMillis(int recoverytime) {\r\n+        _recoveryTimeMillis = recoverytime;\r\n+    }\r\n+\r\n+    /**\r\n+     * The number of milliseconds to wait before retrying\r\n+     * to reconnect to a peer after it becomes unreachable.\r\n+     */\r\n+    public int getRecoveryTimeMillis() {\r\n+        return _recoveryTimeMillis;\r\n+    }\r\n+\r\n+    /**\r\n+     * The maximum number of sockets that this provider can\r\n+     * simetaneously open to each peer in the cluster.\r\n+     */\r\n+    public void setMaxActive(int maxActive) {\r\n+        _maxActive = maxActive;\r\n+    }\r\n+\r\n+    /**\r\n+     * The maximum number of sockets that this provider can\r\n+     * simetaneously open to each peer in the cluster.\r\n+     */\r\n+    public int getMaxActive() {\r\n+        return _maxActive;\r\n+    }\r\n+\r\n+    /**\r\n+     * The number of idle sockets that this provider can keep open\r\n+     * to each peer in the cluster.\r\n+     */\r\n+    public void setMaxIdle(int maxIdle) {\r\n+        _maxIdle = maxIdle;\r\n+    }\r\n+\r\n+    /**\r\n+     * The number of idle sockets that this provider can keep open\r\n+     * to each peer in the cluster.\r\n+     */\r\n+    public int getMaxIdle() {\r\n+        return _maxIdle;\r\n+    }\r\n+\r\n+    /**\r\n+     * The number of worker threads that are used for\r\n+     * transmitting packets to peers in the cluster.\r\n+     */\r\n+    public void setNumBroadcastThreads(int numBroadcastThreads) {\r\n+        synchronized (_broadcastThreads) {\r\n+            int cur = _broadcastThreads.size();\r\n+            if (cur > numBroadcastThreads) {\r\n+                // Notify the extra worker threads so they stop themselves\r\n+                // Threads will not end until they send another pk.\r\n+                for (int i = numBroadcastThreads; i < cur; i++) {\r\n+                    BroadcastWorkerThread worker = (BroadcastWorkerThread)\r\n+                        _broadcastThreads.remove(0);\r\n+                    worker.setRunning(false);\r\n+                }\r\n+            } else if (cur < numBroadcastThreads) {\r\n+                // Create additional worker threads\r\n+                for (int i = cur; i < numBroadcastThreads; i++) {\r\n+                    BroadcastWorkerThread wt = new BroadcastWorkerThread();\r\n+                    wt.setDaemon(true);\r\n+                    wt.start();\r\n+                    _broadcastThreads.add(wt);\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * The number of worker threads that are used for\r\n+     * transmitting packets to peers in the cluster.\r\n+     */\r\n+    public int getNumBroadcastThreads() {\r\n+        return _broadcastThreads.size();\r\n+    }\r\n+\r\n+    /**\r\n+     * Sets the list of addresses of peers to which this provider will\r\n+     * send events to. The peers are semicolon-separated <code>names</code>\r\n+     * list in the form of \"myhost1:portA;myhost2:portB\".\r\n+     */\r\n+    public void setAddresses(String names)\r\n+        throws UnknownHostException {\r\n+        // NYI. Could look for equivalence of addresses and avoid\r\n+        // changing those that didn't change.\r\n+\r\n+        _addressesLock.lock();\r\n+        try {\r\n+            for (Iterator iter = _addresses.iterator(); iter.hasNext();) {\r\n+                ((HostAddress) iter.next()).close();\r\n+            }\r\n+            String[] toks = Strings.split(names, \";\", 0);\r\n+            _addresses = new ArrayList(toks.length);\r\n+\r\n+            InetAddress localhost = InetAddress.getLocalHost();\r\n+            String localhostName = localhost.getHostName();\r\n+\r\n+            for (int i = 0; i < toks.length; i++) {\r\n+                String host = toks[i];\r\n+                String hostname;\r\n+                int tmpPort;\r\n+                int colon = host.indexOf(':');\r\n+                if (colon != -1) {\r\n+                    hostname = host.substring(0, colon);\r\n+                    tmpPort = Integer.parseInt(host.substring(colon + 1));\r\n+                } else {\r\n+                    hostname = host;\r\n+                    tmpPort = DEFAULT_PORT;\r\n+                }\r\n+                InetAddress tmpAddress = (InetAddress) AccessController\r\n+                    .doPrivileged(J2DoPrivHelper.getByNameAction(hostname)); \r\n+\r\n+                // bleair: For each address we would rather make use of\r\n+                // the jdk1.4 isLinkLocalAddress () || isLoopbackAddress ().\r\n+                // (Though in practice on win32 they don't work anyways!)\r\n+                // Instead we will check hostname. Not perfect, but\r\n+                // it will match often enough (people will typically\r\n+                // use the DNS machine names and be cutting/pasting.)\r\n+                if (localhostName.equals(hostname)) {\r\n+                    // This string matches the hostname for for ourselves, we\r\n+                    // don't actually need to send ourselves messages.\r\n+                    if (log.isTraceEnabled()) {\r\n+                        log.trace(s_loc.get(\"tcp-address-asself\",\r\n+                            tmpAddress.getHostName() + \":\" + tmpPort));\r\n+                    }\r\n+                } else {\r\n+                    HostAddress newAddress = new HostAddress(host);\r\n+                    _addresses.add(newAddress);\r\n+                    if (log.isTraceEnabled()) {\r\n+                        log.trace(s_loc.get(\"tcp-address-set\",\r\n+                            newAddress._address.getHostName() + \":\"\r\n+                                + newAddress._port));\r\n+                    }\r\n+                }\r\n+            }\r\n+        } catch (PrivilegedActionException pae) {\r\n+            throw (UnknownHostException) pae.getException();\r\n+        } finally {\r\n+            _addressesLock.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    // ---------- Configurable implementation ----------\r\n+\r\n+    /**\r\n+     * Subclasses that need to perform actions in\r\n+     * {@link Configurable#endConfiguration} must invoke this method.\r\n+     */\r\n+    public void endConfiguration() {\r\n+        super.endConfiguration();\r\n+        synchronized (s_portListenerMap) {\r\n+            // see if a listener exists for this port.\r\n+            _listener = (TCPPortListener) s_portListenerMap.get\r\n+                (String.valueOf(_port));\r\n+\r\n+            if (_listener == null ||\r\n+                (!_listener.isRunning() && _listener._port == _port)) {\r\n+                try {\r\n+                    _listener = new TCPPortListener(_port, log);\r\n+                    _listener.listen();\r\n+                    s_portListenerMap.put(String.valueOf(_port), _listener);\r\n+                } catch (Exception e) {\r\n+                    throw new GeneralException(s_loc.get(\"tcp-init-exception\",\r\n+                        String.valueOf(_port)), e).setFatal(true);\r\n+                }\r\n+            } else if (_listener.isRunning()) {\r\n+                if (_listener._port != _port) {\r\n+                    // this really shouldn't be able to happen.\r\n+                    throw new GeneralException(s_loc.get\r\n+                        (\"tcp-not-equal\", String.valueOf(_port))).\r\n+                        setFatal(true);\r\n+                }\r\n+            } else\r\n+                throw new InternalException(s_loc.get(\"tcp-listener-broken\"));\r\n+            _listener.addProvider(this);\r\n+        }\r\n+\r\n+        _addressesLock.lock();\r\n+        try {\r\n+            HostAddress curAddress;\r\n+            for (Iterator iter = _addresses.iterator();\r\n+                iter.hasNext();) {\r\n+                curAddress = (HostAddress) iter.next();\r\n+                curAddress.setMaxActive(_maxActive);\r\n+                curAddress.setMaxIdle(_maxIdle);\r\n+            }\r\n+        }\r\n+        finally {\r\n+            _addressesLock.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    // ---------- RemoteCommitProvider implementation ----------\r\n+\r\n+    // pre 3.3.4\t= <no version number transmitted>\r\n+    // 3.3 Preview \t= 0x1428acfd;\r\n+    // 3.4 \t\t\t= 0x1428acff;\r\n+    private static final long PROTOCOL_VERSION = 0x1428acff;\r\n+\r\n+    public void broadcast(RemoteCommitEvent event) {\r\n+        try {\r\n+            // build a packet notifying other JVMs of object changes.\r\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n+            ObjectOutputStream oos = new ObjectOutputStream(baos);\r\n+\r\n+            oos.writeLong(PROTOCOL_VERSION);\r\n+            oos.writeLong(_id);\r\n+            oos.writeInt(_port);\r\n+            oos.writeObject(_localhost);\r\n+            oos.writeObject(event);\r\n+            oos.flush();\r\n+\r\n+            byte[] bytes = baos.toByteArray();\r\n+            baos.close();\r\n+            if (_broadcastThreads.isEmpty())\r\n+                sendUpdatePacket(bytes);\r\n+            else\r\n+                _broadcastQueue.addPacket(bytes);\r\n+        } catch (IOException ioe) {\r\n+            if (log.isWarnEnabled())\r\n+                log.warn(s_loc.get(\"tcp-payload-create-error\"), ioe);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Sends a change notification packet to other machines in this\r\n+     * provider cluster.\r\n+     */\r\n+    private void sendUpdatePacket(byte[] bytes) {\r\n+        _addressesLock.lock();\r\n+        try {\r\n+            for (Iterator iter = _addresses.iterator(); iter.hasNext();)\r\n+                ((HostAddress) iter.next()).sendUpdatePacket(bytes);\r\n+        } finally {\r\n+            _addressesLock.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void close() {\r\n+        if (_listener != null)\r\n+            _listener.removeProvider(this);\r\n+\r\n+        // Remove Broadcast Threads then close sockets.\r\n+        _broadcastQueue.close();\r\n+\r\n+        // Wait for _broadcastThreads to get cleaned up.\r\n+        while(!_broadcastThreads.isEmpty()) {\r\n+            try {\r\n+                Thread.sleep(500);\r\n+            } catch (InterruptedException ie) {\r\n+                // Ignore.\r\n+            }\r\n+        }\r\n+        \r\n+        _addressesLock.lock();\r\n+        try {\r\n+            for (Iterator iter = _addresses.iterator(); iter.hasNext();)\r\n+                ((HostAddress) iter.next()).close();\r\n+        } finally {\r\n+            _addressesLock.unlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Utility class to hold messages to be sent. This\r\n+     * allows calls to broadcast () to return without\r\n+     * waiting for the send to complete.\r\n+     */\r\n+    private static class BroadcastQueue {\r\n+\r\n+        private LinkedList _packetQueue = new LinkedList();\r\n+        private boolean _closed = false;\r\n+\r\n+        public synchronized void close() {\r\n+            _closed = true;\r\n+            notifyAll();\r\n+        }\r\n+\r\n+        public synchronized boolean isClosed() {\r\n+            return _closed;\r\n+        }\r\n+\r\n+        public synchronized void addPacket(byte[] bytes) {\r\n+            _packetQueue.addLast(bytes);\r\n+            notify();\r\n+        }\r\n+\r\n+        /**\r\n+         * @return the bytes defining the packet to process, or\r\n+         * <code>null</code> if the queue is empty.\r\n+         */\r\n+        public synchronized byte[] removePacket()\r\n+            throws InterruptedException {\r\n+            // only wait if the queue is still open. This allows processing\r\n+            // of events in the queue to continue, while avoiding sleeping\r\n+            // during shutdown.\r\n+            while (!_closed && _packetQueue.isEmpty())\r\n+                wait();\r\n+            if (_packetQueue.isEmpty())\r\n+                return null;\r\n+            else\r\n+                return (byte[]) _packetQueue.removeFirst();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Threads to broadcast packets placed in the {@link BroadcastQueue}.\r\n+     */\r\n+    private class BroadcastWorkerThread\r\n+        extends Thread {\r\n+\r\n+        private boolean _keepRunning = true;\r\n+\r\n+        public void run() {\r\n+            while (_keepRunning) {\r\n+                try {\r\n+                    // This will block until there is a packet to send, or\r\n+                    // until the queue is closed.\r\n+                    byte[] bytes = _broadcastQueue.removePacket();\r\n+                    if (bytes != null)\r\n+                        sendUpdatePacket(bytes);\r\n+                    else if (_broadcastQueue.isClosed())\r\n+                        _keepRunning = false;\r\n+                } catch (InterruptedException e) {\r\n+                    // End the thread.\r\n+                    break;\r\n+                }\r\n+            }\r\n+            remove();\r\n+        }\r\n+\r\n+        public void setRunning(boolean keepRunning) {\r\n+            _keepRunning = keepRunning;\r\n+        }\r\n+        \r\n+        private void remove() {\r\n+            _broadcastThreads.remove(this);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Responsible for listening for incoming packets and processing them.\r\n+     */\r\n+    private static class TCPPortListener\r\n+        implements Runnable {\r\n+\r\n+        private final Log _log;\r\n+        private ServerSocket _receiveSocket;\r\n+        private Thread _acceptThread;\r\n+        private Set _receiverThreads = new HashSet();\r\n+        private final Set _providers = new HashSet();\r\n+\r\n+        /**\r\n+         * Cache the local IP address\r\n+         */\r\n+        private byte[] _localhost;\r\n+\r\n+        /**\r\n+         * The port that this listener should listen on. Configured\r\n+         * by TCPRemoteCommitProvider.\r\n+         */\r\n+        private int _port;\r\n+\r\n+        /**\r\n+         * Should be set to <code>true</code> once the listener is listening.\r\n+         */\r\n+        private boolean _isRunning = false;\r\n+\r\n+        /**\r\n+         * Construct a new TCPPortListener configured to use the specified port.\r\n+         */\r\n+        private TCPPortListener(int port, Log log)\r\n+            throws IOException {\r\n+            _port = port;\r\n+            _log = log;\r\n+            try {\r\n+                _receiveSocket = (ServerSocket) AccessController\r\n+                    .doPrivileged(J2DoPrivHelper.newServerSocketAction(_port));\r\n+            } catch (PrivilegedActionException pae) {\r\n+                throw (IOException) pae.getException();\r\n+            }\r\n+            _localhost = InetAddress.getLocalHost().getAddress();\r\n+\r\n+            if (_log.isTraceEnabled())\r\n+                _log.info(s_loc.get(\"tcp-start-listener\",\r\n+                    String.valueOf(_port)));\r\n+        }\r\n+\r\n+        private void listen() {\r\n+            _acceptThread = new Thread(this);\r\n+            _acceptThread.setDaemon(true);\r\n+            _acceptThread.start();\r\n+        }\r\n+\r\n+        /**\r\n+         * All providers added here will be notified of any incoming\r\n+         * provider messages. There will be one of these per\r\n+         * BrokerFactory in a given JVM.\r\n+         * {@link TCPRemoteCommitProvider#endConfiguration} invokes\r\n+         * <code>addProvider</code> with <code>this</code> upon\r\n+         * completion of configuration.\r\n+         */\r\n+        private void addProvider(TCPRemoteCommitProvider provider) {\r\n+            synchronized (_providers) {\r\n+                _providers.add(provider);\r\n+            }\r\n+        }\r\n+\r\n+        /**\r\n+         * Remove a provider from the list of providers to notify of\r\n+         * commit events.\r\n+         */\r\n+        private synchronized void removeProvider\r\n+            (TCPRemoteCommitProvider provider) {\r\n+            synchronized (_providers) {\r\n+                _providers.remove(provider);\r\n+\r\n+                // if the provider list is empty, shut down the thread.\r\n+                if (_providers.size() == 0) {\r\n+                    _isRunning = false;\r\n+                    try {\r\n+                        _receiveSocket.close();\r\n+                    } catch (IOException ioe) {\r\n+                        if (_log.isWarnEnabled())\r\n+                            _log.warn(s_loc.get(\"tcp-close-error\"), ioe);\r\n+                    }\r\n+                    _acceptThread.interrupt();\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        private boolean isRunning() {\r\n+            synchronized (_providers) {\r\n+                return _isRunning;\r\n+            }\r\n+        }\r\n+\r\n+        public void run() {\r\n+            synchronized (_providers) {\r\n+                _isRunning = true;\r\n+            }\r\n+\r\n+            Socket s = null;\r\n+            while (_isRunning) {\r\n+                try {\r\n+                    s = null;\r\n+                    // Block, waiting to accept new connection from a peer\r\n+                    s = (Socket) AccessController.doPrivileged(J2DoPrivHelper\r\n+                        .acceptAction(_receiveSocket));\r\n+                    if (_log.isTraceEnabled()) {\r\n+                        _log.trace(s_loc.get(\"tcp-received-connection\",\r\n+                            s.getInetAddress().getHostAddress()\r\n+                                + \":\" + s.getPort()));\r\n+                    }\r\n+                    ReceiveSocketHandler sh = new ReceiveSocketHandler(s);\r\n+                    Thread receiverThread = new Thread(sh);\r\n+                    receiverThread.setDaemon(true);\r\n+                    receiverThread.start();\r\n+                    _receiverThreads.add(receiverThread);\r\n+                } catch (Exception e) {\r\n+                    if (e instanceof PrivilegedActionException)\r\n+                        e = ((PrivilegedActionException) e).getException();\r\n+                    if (!(e instanceof SocketException) || _isRunning)\r\n+                        if (_log.isWarnEnabled())\r\n+                            _log.warn(s_loc.get(\"tcp-accept-error\"), e);\r\n+\r\n+                    // Nominal case (InterruptedException) because close ()\r\n+                    // calls _acceptThread.interrupt ();\r\n+                    try {\r\n+                        if (s != null)\r\n+                            s.close();\r\n+                    } catch (Exception ee) {\r\n+                        if (_log.isWarnEnabled())\r\n+                            _log.warn(s_loc.get(\"tcp-close-error\"), e);\r\n+                    }\r\n+                }\r\n+            }\r\n+\r\n+            // We are done listening. Interrupt any worker threads.\r\n+            Thread worker;\r\n+            for (Iterator iter = _receiverThreads.iterator();\r\n+                iter.hasNext();) {\r\n+                worker = (Thread) iter.next();\r\n+                // FYI, the worker threads are blocked\r\n+                // reading from the socket's InputStream. InputStreams\r\n+                // aren't interruptable, so this interrupt isn't\r\n+                // really going to be delivered until something breaks\r\n+                // the InputStream.\r\n+                worker.interrupt();\r\n+            }\r\n+            synchronized (_providers) {\r\n+                try {\r\n+                    if (_isRunning)\r\n+                        _receiveSocket.close();\r\n+                } catch (Exception e) {\r\n+                    if (_log.isWarnEnabled())\r\n+                        _log.warn(s_loc.get(\"tcp-close-error\"), e);\r\n+                }\r\n+                _isRunning = false;\r\n+                if (_log.isTraceEnabled())\r\n+                    _log.trace(s_loc.get(\"tcp-close-listener\",\r\n+                        _port + \"\"));\r\n+            }\r\n+        }\r\n+\r\n+        /**\r\n+         * Utility class that acts as a worker thread to receive Events\r\n+         * from broadcasters.\r\n+         */\r\n+        private class ReceiveSocketHandler\r\n+            implements Runnable {\r\n+\r\n+            private InputStream _in;\r\n+            private Socket _s;\r\n+\r\n+            private ReceiveSocketHandler(Socket s) {\r\n+                // We are the receiving end and we don't send any messages\r\n+                // back to the broadcaster. Turn off Nagle's so that\r\n+                // we will send ack packets without waiting.\r\n+                _s = s;\r\n+                try {\r\n+                    _s.setTcpNoDelay(true);\r\n+                    _in = new BufferedInputStream(s.getInputStream());\r\n+                } catch (IOException ioe) {\r\n+                    if (_log.isInfoEnabled())\r\n+                        _log.info(s_loc.get(\"tcp-socket-option-error\"), ioe);\r\n+                    _s = null;\r\n+                } catch (Exception e) {\r\n+                    if (_log.isWarnEnabled())\r\n+                        _log.warn(s_loc.get(\"tcp-receive-error\"), e);\r\n+                    _s = null;\r\n+                }\r\n+            }\r\n+\r\n+            public void run() {\r\n+                if (_s == null)\r\n+                    return;\r\n+                while (_isRunning && _s != null) {\r\n+                    try {\r\n+                        // This will block our thread, waiting to read\r\n+                        // the next Event-object-message.\r\n+                        handle(_in);\r\n+                    } catch (EOFException eof) {\r\n+                        // EOFException raised when peer is properly\r\n+                        // closing its end.\r\n+                        if (_log.isTraceEnabled()) {\r\n+                            _log.trace(s_loc.get(\"tcp-close-socket\",\r\n+                                _s.getInetAddress().getHostAddress()\r\n+                                    + \":\" + _s.getPort()));\r\n+                        }\r\n+                        break;\r\n+                    } catch (Throwable e) {\r\n+                        if (_log.isWarnEnabled())\r\n+                            _log.warn(s_loc.get(\"tcp-receive-error\"), e);\r\n+                        break;\r\n+                    }\r\n+                }\r\n+                // We are done receiving on this socket and this worker\r\n+                // thread is terminating.\r\n+                try {\r\n+                    _in.close();\r\n+                    if (_s != null)\r\n+                        _s.close();\r\n+                } catch (IOException e) {\r\n+                    _log.warn(s_loc.get(\"tcp-close-socket-error\",\r\n+                        _s.getInetAddress().getHostAddress() + \":\"\r\n+                            + _s.getPort()), e);\r\n+                }\r\n+            }\r\n+\r\n+            /**\r\n+             * Process an {@link InputStream} containing objects written\r\n+             * by {@link TCPRemoteCommitProvider#broadcast(RemoteCommitEvent)}.\r\n+             */\r\n+            private void handle(InputStream in)\r\n+                throws IOException, ClassNotFoundException {\r\n+                // This will block waiting for the next\r\n+                ObjectInputStream ois = \r\n+                    new Serialization.ClassResolvingObjectInputStream(in);\r\n+\r\n+                long protocolVersion = ois.readLong();\r\n+                if (protocolVersion != PROTOCOL_VERSION) {\r\n+                    if (_log.isWarnEnabled()) {\r\n+                        _log.warn(s_loc.get(\"tcp-wrong-version-error\",\r\n+                            _s.getInetAddress().getHostAddress() + \":\"\r\n+                                + _s.getPort()));\r\n+                        return;\r\n+                    }\r\n+                }\r\n+\r\n+                long senderId = ois.readLong();\r\n+                int senderPort = ois.readInt();\r\n+                byte[] senderAddress = (byte[]) ois.readObject();\r\n+                RemoteCommitEvent rce = (RemoteCommitEvent) ois.readObject();\r\n+                if (_log.isTraceEnabled()) {\r\n+                    _log.trace(s_loc.get(\"tcp-received-event\",\r\n+                        _s.getInetAddress().getHostAddress() + \":\"\r\n+                            + _s.getPort()));\r\n+                }\r\n+\r\n+                boolean fromSelf = senderPort == _port &&\r\n+                    Arrays.equals(senderAddress, _localhost);\r\n+                TCPRemoteCommitProvider provider;\r\n+                synchronized (_providers) {\r\n+                    // bleair: We're iterating, but currenlty there can really\r\n+                    // only be a single provider.\r\n+                    for (Iterator iter = _providers.iterator();\r\n+                        iter.hasNext();) {\r\n+                        provider = (TCPRemoteCommitProvider) iter.next();\r\n+                        if (senderId != provider._id || !fromSelf)\r\n+                            provider.eventManager.fireEvent(rce);\r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Utility class to store an InetAddress and an int. Not using\r\n+     * InetSocketAddress because it's a JDK1.4 API. This also\r\n+     * provides a wrapper around the socket(s) associated with this address.\r\n+     */\r\n+    private class HostAddress {\r\n+\r\n+        private InetAddress _address;\r\n+        private int _port;\r\n+        private long _timeLastError; // millis\r\n+        private boolean _isAvailable; // is peer thought to be up\r\n+        private int _infosIssued = 0; // limit log entries\r\n+\r\n+        private GenericObjectPool _socketPool; // reusable open sockets\r\n+\r\n+        /**\r\n+         * Construct a new host address from a string of the form\r\n+         * \"host:port\" or of the form \"host\".\r\n+         */\r\n+        private HostAddress(String host)\r\n+            throws UnknownHostException {\r\n+            int colon = host.indexOf(':');\r\n+            try {\r\n+                if (colon != -1) {\r\n+                    _address = (InetAddress) AccessController\r\n+                        .doPrivileged(J2DoPrivHelper.getByNameAction(host\r\n+                            .substring(0, colon)));\r\n+                    _port = Integer.parseInt(host.substring(colon + 1));\r\n+                } else {\r\n+                    _address = (InetAddress) AccessController\r\n+                        .doPrivileged(J2DoPrivHelper.getByNameAction(host));\r\n+                    _port = DEFAULT_PORT;\r\n+                }\r\n+            } catch (PrivilegedActionException pae) {\r\n+                throw (UnknownHostException) pae.getException();\r\n+            }\r\n+            // -1 max wait == as long as it takes\r\n+            _socketPool = new GenericObjectPool\r\n+                (new SocketPoolableObjectFactory(), _maxActive,\r\n+                    GenericObjectPool.WHEN_EXHAUSTED_BLOCK, -1);\r\n+            _isAvailable = true;\r\n+        }\r\n+\r\n+        private void setMaxActive(int maxActive) {\r\n+            _socketPool.setMaxActive(maxActive);\r\n+        }\r\n+\r\n+        private void setMaxIdle(int maxIdle) {\r\n+            _socketPool.setMaxIdle(maxIdle);\r\n+        }\r\n+\r\n+        public void close() {\r\n+            // Close the pool of sockets to this peer. This\r\n+            // will close all sockets in the pool.\r\n+            try {\r\n+                _socketPool.close();\r\n+            } catch (Exception e) {\r\n+                if (log.isWarnEnabled()) {\r\n+                    log.warn(s_loc.get(\"tcp-close-pool-error\"), e);\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        private void sendUpdatePacket(byte[] bytes) {\r\n+            if (!_isAvailable) {\r\n+                long now = System.currentTimeMillis();\r\n+                if (now - _timeLastError < _recoveryTimeMillis)\r\n+                    // Not enough time has passed since the last error\r\n+                    return;\r\n+            }\r\n+            Socket s = null;\r\n+            try {\r\n+                s = getSocket();\r\n+                OutputStream os = s.getOutputStream();\r\n+                os.write(bytes);\r\n+                os.flush();\r\n+\r\n+                if (log.isTraceEnabled()) {\r\n+                    log.trace(s_loc.get(\"tcp-sent-update\",\r\n+                        _address.getHostAddress() + \":\" + _port,\r\n+                        String.valueOf(s.getLocalPort())));\r\n+                }\r\n+                _isAvailable = true;\r\n+                _infosIssued = 0;\r\n+                // Return the socket to the pool; the socket is\r\n+                // still good.\r\n+                returnSocket(s);\r\n+            } catch (Exception e) {\r\n+                // There has been a problem sending to the peer.\r\n+                // The OS socket that was being used is can no longer\r\n+                // be used.\r\n+                if (s != null)\r\n+                    this.closeSocket(s);\r\n+                this.clearAllSockets();\r\n+\r\n+                if (_isAvailable) {\r\n+                    // Log a warning, the peer was up and has now gone down\r\n+                    if (log.isWarnEnabled()) {\r\n+                        log.warn(s_loc.get(\"tcp-send-error\",\r\n+                            _address.getHostAddress() + \":\" + _port), e);\r\n+                    }\r\n+                    _isAvailable = false;\r\n+                    // Once enough time has passed we will log another warning\r\n+                    _timeLastError = System.currentTimeMillis();\r\n+                } else {\r\n+                    long now = System.currentTimeMillis();\r\n+                    if (now - _timeLastError > _recoveryTimeMillis) {\r\n+                        if (_infosIssued < 5) {\r\n+                            // Enough time has passed, and peer is still down\r\n+                            _timeLastError = System.currentTimeMillis();\r\n+                            // We were trying to reestablish the connection,\r\n+                            // but we failed again. Log a message, but\r\n+                            // lower severity. This log will occur periodically\r\n+                            // for 5 times until the peer comes back.\r\n+                            if (log.isInfoEnabled()) {\r\n+                                log.info(s_loc.get(\"tcp-send-still-error\",\r\n+                                    _address.getHostAddress() + \":\"\r\n+                                        + _port), e);\r\n+                            }\r\n+                            _infosIssued++;\r\n+                        }\r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        private Socket getSocket()\r\n+            throws Exception {\r\n+            return (Socket) _socketPool.borrowObject();\r\n+        }\r\n+\r\n+        private void returnSocket(Socket s)\r\n+            throws Exception {\r\n+            _socketPool.returnObject(s);\r\n+        }\r\n+\r\n+        private void clearAllSockets() {\r\n+            _socketPool.clear();\r\n+        }\r\n+\r\n+        private void closeSocket(Socket s) {\r\n+            // All sockets come from the pool.\r\n+            // This socket is no longer usable, so delete it from the\r\n+            // pool.\r\n+            try {\r\n+                _socketPool.invalidateObject(s);\r\n+            } catch (Exception e) {\r\n+            }\r\n+        }\r\n+\r\n+        /**\r\n+         * Factory for pooled sockets.\r\n+         */\r\n+        private class SocketPoolableObjectFactory\r\n+            implements PoolableObjectFactory {\r\n+\r\n+            public Object makeObject()\r\n+                throws IOException {\r\n+                try {\r\n+                    Socket s = (Socket) AccessController\r\n+                        .doPrivileged(J2DoPrivHelper.newSocketAction(_address,\r\n+                            _port));\r\n+                    if (log.isTraceEnabled()) {\r\n+                        log.trace(s_loc.get(\"tcp-open-connection\", _address\r\n+                            + \":\" + _port, \"\" + s.getLocalPort()));\r\n+                    }\r\n+                    return s;\r\n+                } catch (PrivilegedActionException pae) {\r\n+                    throw (IOException) pae.getException();\r\n+                }\r\n+            }\r\n+\r\n+            public void destroyObject(Object obj) {\r\n+                // silentClose ().\r\n+                try {\r\n+                    Socket s = (Socket) obj;\r\n+                    if (log.isTraceEnabled())\r\n+                        log.trace(s_loc.get(\"tcp-close-sending-socket\",\r\n+                            _address + \":\" + _port, \"\" + s.getLocalPort()));\r\n+                    s.close();\r\n+                } catch (Exception e) {\r\n+                    log.warn(s_loc.get(\"tcp-close-socket-error\",\r\n+                        _address.getHostAddress() + \":\" + _port), e);\r\n+                }\r\n+            }\r\n+\r\n+            public boolean validateObject(Object obj) {\r\n+                return true;\r\n+            }\r\n+\r\n+            public void activateObject (Object value)\r\n+\t\t\t{\r\n+\t\t\t}\r\n+\r\n+\t\t\tpublic void passivateObject (Object value)\r\n+\t\t\t{\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+}\r"},{"sha":"adcd0dd1b3672c26af8f24df965e11e7881590b0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","status":"modified","additions":129,"deletions":129,"changes":258,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,129 +1,129 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.event;\n-\n-import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\n-\n-/**\n- * Manager that can be used to track and notify transaction listeners\n- * of transaction-related events.\n- *\n- * @author Patrick Linskey\n- * @author Abe White\n- * @since 0.3.0\n- * @nojavadoc\n- */\n-public class TransactionEventManager\n-    extends AbstractConcurrentEventManager {\n-\n-    private int _begin = 0;\n-    private int _flush = 0;\n-    private int _end = 0;\n-\n-    public void addListener(Object listener) {\n-        super.addListener(listener);\n-        if (listener instanceof BeginTransactionListener)\n-            _begin++;\n-        if (listener instanceof FlushTransactionListener)\n-            _flush++;\n-        if (listener instanceof EndTransactionListener)\n-            _end++;\n-    }\n-\n-    public boolean removeListener(Object listener) {\n-        if (!super.removeListener(listener))\n-            return false;\n-\n-        if (listener instanceof BeginTransactionListener)\n-            _begin--;\n-        if (listener instanceof FlushTransactionListener)\n-            _flush--;\n-        if (listener instanceof EndTransactionListener)\n-            _end--;\n-        return true;\n-    }\n-\n-    /**\n-     * Whether there are any begin transaction listeners.\n-     */\n-    public boolean hasBeginListeners() {\n-        return _begin > 0;\n-    }\n-\n-    /**\n-     * Whether there are any flush transaction listeners.\n-     */\n-    public boolean hasFlushListeners() {\n-        return _flush > 0;\n-    }\n-\n-    /**\n-     * Whether there are any end transaction listeners.\n-     */\n-    public boolean hasEndListeners() {\n-        return _end > 0;\n-    }\n-\n-    /**\n-     * Fire the given event to all registered listeners.\n-     */\n-    protected void fireEvent(Object event, Object listener) {\n-        TransactionEvent ev = (TransactionEvent) event;\n-        switch (ev.getType()) {\n-            case TransactionEvent.AFTER_BEGIN:\n-                if (listener instanceof BeginTransactionListener)\n-                    ((BeginTransactionListener) listener).afterBegin(ev);\n-                break;\n-            case TransactionEvent.BEFORE_FLUSH:\n-                if (listener instanceof FlushTransactionListener)\n-                    ((FlushTransactionListener) listener).beforeFlush(ev);\n-                break;\n-            case TransactionEvent.AFTER_FLUSH:\n-                if (listener instanceof FlushTransactionListener)\n-                    ((FlushTransactionListener) listener).afterFlush(ev);\n-                break;\n-            case TransactionEvent.BEFORE_COMMIT:\n-                if (listener instanceof EndTransactionListener)\n-                    ((EndTransactionListener) listener).beforeCommit(ev);\n-                break;\n-            case TransactionEvent.AFTER_COMMIT:\n-                if (listener instanceof EndTransactionListener)\n-                    ((EndTransactionListener) listener).afterCommit(ev);\n-                break;\n-            case TransactionEvent.AFTER_ROLLBACK:\n-                if (listener instanceof EndTransactionListener)\n-                    ((EndTransactionListener) listener).afterRollback(ev);\n-                break;\n-            case TransactionEvent.AFTER_STATE_TRANSITIONS:\n-                if (listener instanceof EndTransactionListener)\n-                    ((EndTransactionListener) listener)\n-                        .afterStateTransitions(ev);\n-                break;\n-            case TransactionEvent.AFTER_COMMIT_COMPLETE:\n-                if (listener instanceof EndTransactionListener)\n-                    ((EndTransactionListener) listener).afterCommitComplete(ev);\n-                break;\n-            case TransactionEvent.AFTER_ROLLBACK_COMPLETE:\n-                if (listener instanceof EndTransactionListener)\n-                    ((EndTransactionListener) listener)\n-                        .afterRollbackComplete(ev);\n-                break;\n-        }\n-\t}\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.event;\r\n+\r\n+import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\r\n+\r\n+/**\r\n+ * Manager that can be used to track and notify transaction listeners\r\n+ * of transaction-related events.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ * @since 0.3.0\r\n+ * @nojavadoc\r\n+ */\r\n+public class TransactionEventManager\r\n+    extends AbstractConcurrentEventManager {\r\n+\r\n+    private int _begin = 0;\r\n+    private int _flush = 0;\r\n+    private int _end = 0;\r\n+\r\n+    public void addListener(Object listener) {\r\n+        super.addListener(listener);\r\n+        if (listener instanceof BeginTransactionListener)\r\n+            _begin++;\r\n+        if (listener instanceof FlushTransactionListener)\r\n+            _flush++;\r\n+        if (listener instanceof EndTransactionListener)\r\n+            _end++;\r\n+    }\r\n+\r\n+    public boolean removeListener(Object listener) {\r\n+        if (!super.removeListener(listener))\r\n+            return false;\r\n+\r\n+        if (listener instanceof BeginTransactionListener)\r\n+            _begin--;\r\n+        if (listener instanceof FlushTransactionListener)\r\n+            _flush--;\r\n+        if (listener instanceof EndTransactionListener)\r\n+            _end--;\r\n+        return true;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether there are any begin transaction listeners.\r\n+     */\r\n+    public boolean hasBeginListeners() {\r\n+        return _begin > 0;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether there are any flush transaction listeners.\r\n+     */\r\n+    public boolean hasFlushListeners() {\r\n+        return _flush > 0;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether there are any end transaction listeners.\r\n+     */\r\n+    public boolean hasEndListeners() {\r\n+        return _end > 0;\r\n+    }\r\n+\r\n+    /**\r\n+     * Fire the given event to all registered listeners.\r\n+     */\r\n+    protected void fireEvent(Object event, Object listener) {\r\n+        TransactionEvent ev = (TransactionEvent) event;\r\n+        switch (ev.getType()) {\r\n+            case TransactionEvent.AFTER_BEGIN:\r\n+                if (listener instanceof BeginTransactionListener)\r\n+                    ((BeginTransactionListener) listener).afterBegin(ev);\r\n+                break;\r\n+            case TransactionEvent.BEFORE_FLUSH:\r\n+                if (listener instanceof FlushTransactionListener)\r\n+                    ((FlushTransactionListener) listener).beforeFlush(ev);\r\n+                break;\r\n+            case TransactionEvent.AFTER_FLUSH:\r\n+                if (listener instanceof FlushTransactionListener)\r\n+                    ((FlushTransactionListener) listener).afterFlush(ev);\r\n+                break;\r\n+            case TransactionEvent.BEFORE_COMMIT:\r\n+                if (listener instanceof EndTransactionListener)\r\n+                    ((EndTransactionListener) listener).beforeCommit(ev);\r\n+                break;\r\n+            case TransactionEvent.AFTER_COMMIT:\r\n+                if (listener instanceof EndTransactionListener)\r\n+                    ((EndTransactionListener) listener).afterCommit(ev);\r\n+                break;\r\n+            case TransactionEvent.AFTER_ROLLBACK:\r\n+                if (listener instanceof EndTransactionListener)\r\n+                    ((EndTransactionListener) listener).afterRollback(ev);\r\n+                break;\r\n+            case TransactionEvent.AFTER_STATE_TRANSITIONS:\r\n+                if (listener instanceof EndTransactionListener)\r\n+                    ((EndTransactionListener) listener)\r\n+                        .afterStateTransitions(ev);\r\n+                break;\r\n+            case TransactionEvent.AFTER_COMMIT_COMPLETE:\r\n+                if (listener instanceof EndTransactionListener)\r\n+                    ((EndTransactionListener) listener).afterCommitComplete(ev);\r\n+                break;\r\n+            case TransactionEvent.AFTER_ROLLBACK_COMPLETE:\r\n+                if (listener instanceof EndTransactionListener)\r\n+                    ((EndTransactionListener) listener)\r\n+                        .afterRollbackComplete(ev);\r\n+                break;\r\n+        }\r\n+\t}\r\n+}\r"},{"sha":"c2141233580e47c2701f1bd43be9366459f03a87","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","status":"modified","additions":800,"deletions":828,"changes":1628,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,828 +1,800 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.kernel;\n-\n-import java.io.ObjectStreamException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Properties;\n-import javax.transaction.Status;\n-import javax.transaction.Synchronization;\n-import javax.transaction.Transaction;\n-import javax.transaction.TransactionManager;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\n-import org.apache.openjpa.conf.OpenJPAVersion;\n-import org.apache.openjpa.datacache.DataCacheStoreManager;\n-import org.apache.openjpa.ee.ManagedRuntime;\n-import org.apache.openjpa.enhance.PCRegistry;\n-import org.apache.openjpa.enhance.PersistenceCapable;\n-import org.apache.openjpa.event.BrokerFactoryEvent;\n-import org.apache.openjpa.event.RemoteCommitEventManager;\n-import org.apache.openjpa.lib.conf.Configuration;\n-import org.apache.openjpa.lib.conf.Configurations;\n-import org.apache.openjpa.lib.log.Log;\n-import org.apache.openjpa.lib.util.J2DoPrivHelper;\n-import org.apache.openjpa.lib.util.JavaVersions;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashSet;\n-import org.apache.openjpa.lib.util.concurrent.ReentrantLock;\n-import org.apache.openjpa.meta.MetaDataRepository;\n-import org.apache.openjpa.util.GeneralException;\n-import org.apache.openjpa.util.InternalException;\n-import org.apache.openjpa.util.InvalidStateException;\n-import org.apache.openjpa.util.OpenJPAException;\n-import org.apache.openjpa.util.UserException;\n-\n-/**\n- * Abstract implementation of the {@link BrokerFactory}\n- * that must be subclassed for a specific runtime.\n- *\n- * @author Abe White\n- */\n-public abstract class AbstractBrokerFactory\n-    implements BrokerFactory {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (AbstractBrokerFactory.class);\n-\n-    // static mapping of configurations to pooled broker factories\n-    private static final Map _pool = Collections.synchronizedMap(new HashMap());\n-\n-    // configuration\n-    private final OpenJPAConfiguration _conf;\n-    private transient boolean _readOnly = false;\n-    private transient boolean _closed = false;\n-    private transient RuntimeException _closedException = null;\n-    private Map _userObjects = null;\n-\n-    // internal lock: spec forbids synchronization on this object\n-    private final ReentrantLock _lock = new ReentrantLock();\n-\n-    // maps global transactions to associated brokers\n-    private transient ConcurrentHashMap _transactional\n-        = new ConcurrentHashMap();\n-\n-    // weak-ref tracking of open brokers\n-    private transient Collection _brokers = new ConcurrentReferenceHashSet\n-        (ConcurrentReferenceHashSet.WEAK);\n-\n-    // cache the class names loaded from the persistent classes property so\n-    // that we can re-load them for each new broker\n-    private transient Collection _pcClassNames = null;\n-    private transient Collection _pcClassLoaders = null;\n-    private transient boolean _persistentTypesLoaded = false;\n-\n-    // lifecycle listeners to pass to each broker\n-    private transient Map _lifecycleListeners = null;\n-\n-    // transaction listeners to pass to each broker\n-    private transient List _transactionListeners = null;\n-\n-    // key under which this instance can be stored in the broker pool\n-    // and later identified\n-    private Object _poolKey;\n-\n-    /**\n-     * Return an internal factory pool key for the given configuration.\n-     *\n-     * @since 1.1.0\n-     */\n-    protected static Object toPoolKey(Map map) {\n-        Object key = Configurations.getProperty(\"Id\", map);\n-        return ( key != null) ? key : map;\n-    }\n-\n-    /**\n-     * Register <code>factory</code> in the pool under <code>key</code>.\n-     *\n-     * @since 1.1.0\n-     */\n-    protected static void pool(Object key, AbstractBrokerFactory factory) {\n-        synchronized(_pool) {\n-            _pool.put(key, factory);\n-            factory.setPoolKey(key);\n-            factory.makeReadOnly();\n-        }\n-    }\n-\n-    /**\n-     * Return the pooled factory matching the given key, or null\n-     * if none. The key must be of the form created by {@link #getPoolKey}.\n-     */\n-    public static AbstractBrokerFactory getPooledFactoryForKey(Object key) {\n-        return (AbstractBrokerFactory) _pool.get(key);\n-    }\n-\n-    /**\n-     * Constructor. Configuration must be provided on construction.\n-     */\n-    protected AbstractBrokerFactory(OpenJPAConfiguration config) {\n-        _conf = config;\n-        getPcClassLoaders();\n-    }\n-\n-    /**\n-     * Return the configuration for this factory.\n-     */\n-    public OpenJPAConfiguration getConfiguration() {\n-        return _conf;\n-    }\n-\n-    public Broker newBroker() {\n-        return newBroker(_conf.getConnectionUserName(),\n-            _conf.getConnectionPassword());\n-    }\n-\n-    public Broker newBroker(String user, String pass) {\n-        return newBroker(user, pass, _conf.isTransactionModeManaged(),\n-            _conf.getConnectionRetainModeConstant());\n-    }\n-\n-    public Broker newBroker(boolean managed, int connRetainMode) {\n-        return newBroker(_conf.getConnectionUserName(),\n-            _conf.getConnectionPassword(), managed, connRetainMode);\n-    }\n-\n-    public Broker newBroker(String user, String pass, boolean managed,\n-        int connRetainMode) {\n-        return newBroker(user, pass, managed, connRetainMode, true);\n-    }\n-\n-    public Broker newBroker(String user, String pass, boolean managed,\n-        int connRetainMode, boolean findExisting) {\n-        try {\n-            assertOpen();\n-            makeReadOnly();\n-\n-            BrokerImpl broker = null;\n-            if (findExisting)\n-                broker = findBroker(user, pass, managed);\n-            if (broker == null) {\n-                broker = newBrokerImpl(user, pass);\n-                initializeBroker(managed, connRetainMode, broker, false);\n-            }\n-            return broker;\n-        } catch (OpenJPAException ke) {\n-            throw ke;\n-        } catch (RuntimeException re) {\n-            throw new GeneralException(re);\n-        }\n-    }\n-\n-    void initializeBroker(boolean managed, int connRetainMode,\n-        BrokerImpl broker, boolean fromDeserialization) {\n-        assertOpen();\n-        makeReadOnly();\n-\n-        // decorate the store manager for data caching and custom\n-        // result object providers; always make sure it's a delegating\n-        // store manager, because it's easier for users to deal with\n-        // that way\n-        StoreManager sm = newStoreManager();\n-        DelegatingStoreManager dsm = null;\n-        if (_conf.getDataCacheManagerInstance().getSystemDataCache()\n-            != null)\n-            dsm = new DataCacheStoreManager(sm);\n-        dsm = new ROPStoreManager((dsm == null) ? sm : dsm);\n-\n-        broker.initialize(this, dsm, managed, connRetainMode,\n-            fromDeserialization);\n-        if (!fromDeserialization)\n-            addListeners(broker);\n-\n-        // if we're using remote events, register the event manager so\n-        // that it can broadcast commit notifications from the broker\n-        RemoteCommitEventManager remote = _conf.\n-            getRemoteCommitEventManager();\n-        if (remote.areRemoteEventsEnabled())\n-            broker.addTransactionListener(remote);\n-\n-        loadPersistentTypes(broker.getClassLoader());\n-        _brokers.add(broker);\n-        _conf.setReadOnly(Configuration.INIT_STATE_FROZEN);\n-    }\n-\n-    /**\n-     * Add factory-registered lifecycle listeners to the broker.\n-     */\n-    protected void addListeners(BrokerImpl broker) {\n-        if (_lifecycleListeners != null && !_lifecycleListeners.isEmpty()) {\n-            Map.Entry entry;\n-            for (Iterator itr = _lifecycleListeners.entrySet().iterator();\n-                itr.hasNext();) {\n-                entry = (Map.Entry) itr.next();\n-                broker.addLifecycleListener(entry.getKey(), (Class[])\n-                    entry.getValue());\n-            }\n-        }\n-\n-        if (_transactionListeners != null && !_transactionListeners.isEmpty()) {\n-            for (Iterator itr = _transactionListeners.iterator();\n-                itr.hasNext(); ) {\n-                broker.addTransactionListener(itr.next());\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Load the configured persistent classes list. Performed automatically\n-     * whenever a broker is created.\n-     */\n-    private void loadPersistentTypes(ClassLoader envLoader) {\n-        // if we've loaded the persistent types and the class name list\n-        // is empty, then we can simply return. Note that there is a\n-        // potential threading scenario in which _persistentTypesLoaded is\n-        // false when read, but the work to populate _pcClassNames has\n-        // already been done. This is ok; _pcClassNames can tolerate\n-        // concurrent access, so the worst case is that the list is\n-        // persistent type data is processed multiple times, which this\n-        // algorithm takes into account.\n-        if (_persistentTypesLoaded && _pcClassNames.isEmpty())\n-            return;\n-\n-        // cache persistent type names if not already\n-        ClassLoader loader = _conf.getClassResolverInstance().\n-            getClassLoader(getClass(), envLoader);\n-        Collection toRedefine = new ArrayList();\n-        if (!_persistentTypesLoaded) {\n-            Collection clss = _conf.getMetaDataRepositoryInstance().\n-                loadPersistentTypes(false, loader);\n-            if (clss.isEmpty())\n-                _pcClassNames = Collections.EMPTY_SET;\n-            else {\n-                Collection c = new ArrayList(clss.size());\n-                for (Iterator itr = clss.iterator(); itr.hasNext();) {\n-                    Class cls = (Class) itr.next();\n-                    c.add(cls.getName());\n-                    if (needsSub(cls))\n-                        toRedefine.add(cls);\n-                }\n-                getPcClassLoaders().add(loader);\n-                _pcClassNames = c;\n-            }\n-            _persistentTypesLoaded = true;\n-        } else {\n-            // reload with this loader\n-            if (getPcClassLoaders().add(loader)) {\n-                for (Iterator itr = _pcClassNames.iterator(); itr.hasNext();) {\n-                    try {\n-                        Class cls =\n-                            Class.forName((String) itr.next(), true, loader);\n-                        if (needsSub(cls))\n-                            toRedefine.add(cls);\n-                    } catch (Throwable t) {\n-                        _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME)\n-                            .warn(null, t);\n-                    }\n-                }\n-            }\n-        }\n-\n-        if (JavaVersions.VERSION >= 5) {\n-            try {\n-                // This is Java 5 / 6 code. There might be a more elegant\n-                // way to bootstrap this into the system, but reflection\n-                // will get things working for now. We could potentially\n-                // do this by creating a new BrokerFactoryEvent type for\n-                // Broker creation, at which point we have an appropriate\n-                // classloader to use.\n-                Class cls = Class.forName(\n-                    \"org.apache.openjpa.enhance.ManagedClassSubclasser\");\n-                cls.getMethod(\"prepareUnenhancedClasses\", new Class[] {\n-                        OpenJPAConfiguration.class, Collection.class,\n-                        ClassLoader.class\n-                    })\n-                    .invoke(null, new Object[]{ _conf, toRedefine, envLoader });\n-            } catch (NoSuchMethodException e) {\n-                // should never happen in a properly-built installation\n-                throw new InternalException(e);\n-            } catch (IllegalAccessException e) {\n-                // should never happen in a properly-built installation\n-                throw new InternalException(e);\n-            } catch (InvocationTargetException e) {\n-                Throwable cause = e.getCause();\n-                if (cause instanceof OpenJPAException)\n-                    throw (OpenJPAException) cause;\n-                else\n-                    throw new InternalException(cause);\n-            } catch (ClassNotFoundException e) {\n-                // should never happen in a properly-built installation\n-                throw new InternalException(e);\n-            }\n-        }\n-    }\n-\n-    private boolean needsSub(Class cls) {\n-        return !cls.isInterface()\n-            && !PersistenceCapable.class.isAssignableFrom(cls);\n-    }\n-\n-    public void addLifecycleListener(Object listener, Class[] classes) {\n-        lock();\n-        try {\n-            assertOpen();\n-            if (_lifecycleListeners == null)\n-                _lifecycleListeners = new HashMap(7);\n-            _lifecycleListeners.put(listener, classes);\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    public void removeLifecycleListener(Object listener) {\n-        lock();\n-        try {\n-            assertOpen();\n-            if (_lifecycleListeners != null)\n-                _lifecycleListeners.remove(listener);\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    public void addTransactionListener(Object listener) {\n-        lock();\n-        try {\n-            assertOpen();\n-            if (_transactionListeners == null)\n-                _transactionListeners = new LinkedList();\n-            _transactionListeners.add(listener);\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    public void removeTransactionListener(Object listener) {\n-        lock();\n-        try {\n-            assertOpen();\n-            if (_transactionListeners != null)\n-                _transactionListeners.remove(listener);\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    /**\n-     * Returns true if this broker factory is closed.\n-     */\n-    public boolean isClosed() {\n-        return _closed;\n-    }\n-\n-    public void close() {\n-        lock();\n-        try {\n-            assertOpen();\n-            assertNoActiveTransaction();\n-\n-            // remove from factory pool\n-            synchronized (_pool) {\n-                if (_pool.get(_poolKey) == this)\n-                    _pool.remove(_poolKey);\n-            }\n-\n-            // close all brokers\n-            Broker broker;\n-            for (Iterator itr = _brokers.iterator(); itr.hasNext();) {\n-                broker = (Broker) itr.next();\n-                // Check for null because _brokers contains weak references\n-                if ((broker != null) && (!broker.isClosed()))\n-                    broker.close();\n-            }\n-\n-            if(_conf.metaDataRepositoryAvailable()) {\n-                // remove metadata repository from listener list\n-                PCRegistry.removeRegisterClassListener\n-                    (_conf.getMetaDataRepositoryInstance());\n-            }\n-\n-            _conf.close();\n-            _closed = true;\n-            Log log = _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\n-            if (log.isTraceEnabled())\n-                _closedException = new IllegalStateException();\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    /**\n-     * Subclasses should override this method to add a <code>Platform</code>\n-     * property listing the runtime platform, such as:\n-     * <code>OpenJPA JDBC Edition: Oracle Database</code>\n-     */\n-    public Properties getProperties() {\n-        // required props are VendorName and VersionNumber\n-        Properties props = new Properties();\n-        props.setProperty(\"VendorName\", OpenJPAVersion.VENDOR_NAME);\n-        props.setProperty(\"VersionNumber\", OpenJPAVersion.VERSION_NUMBER);\n-        props.setProperty(\"VersionId\", OpenJPAVersion.VERSION_ID);\n-        return props;\n-    }\n-\n-    public Object getUserObject(Object key) {\n-        lock();\n-        try {\n-            assertOpen();\n-            return (_userObjects == null) ? null : _userObjects.get(key);\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    public Object putUserObject(Object key, Object val) {\n-        lock();\n-        try {\n-            assertOpen();\n-            if (val == null)\n-                return (_userObjects == null) ? null : _userObjects.remove(key);\n-\n-            if (_userObjects == null)\n-                _userObjects = new HashMap();\n-            return _userObjects.put(key, val);\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    public void lock() {\n-        _lock.lock();\n-    }\n-\n-    public void unlock() {\n-        _lock.unlock();\n-    }\n-\n-    /**\n-     * Replaces the factory with this JVMs pooled version if it exists. Also\n-     * freezes the factory.\n-     */\n-    protected Object readResolve()\n-        throws ObjectStreamException {\n-        AbstractBrokerFactory factory = getPooledFactoryForKey(_poolKey);\n-        if (factory != null)\n-            return factory;\n-\n-        // reset these transient fields to empty values\n-        _transactional = new ConcurrentHashMap();\n-        _brokers = new ConcurrentReferenceHashSet(\n-                ConcurrentReferenceHashSet.WEAK);\n-\n-        makeReadOnly();\n-        return this;\n-    }\n-\n-    ////////////////////////\n-    // Methods for Override\n-    ////////////////////////\n-\n-    /**\n-     * Return a new StoreManager for this runtime. Note that the instance\n-     * returned here may be wrapped before being passed to the\n-     * {@link #newBroker} method.\n-     */\n-    protected abstract StoreManager newStoreManager();\n-\n-    /**\n-     * Find a pooled broker, or return null if none. If using\n-     * managed transactions, looks for a transactional broker;\n-     * otherwise returns null by default. This method will be called before\n-     * {@link #newStoreManager} so that factory subclasses implementing\n-     * pooling can return a matching manager before a new {@link StoreManager}\n-     * is created.\n-     */\n-    protected BrokerImpl findBroker(String user, String pass, boolean managed) {\n-        if (managed)\n-            return findTransactionalBroker(user, pass);\n-        return null;\n-    }\n-\n-    /**\n-     * Return a broker configured with the proper settings.\n-     * By default, this method constructs a new\n-     * BrokerImpl of the class set for this factory.\n-     */\n-    protected BrokerImpl newBrokerImpl(String user, String pass) {\n-        BrokerImpl broker = _conf.newBrokerInstance(user, pass);\n-        if (broker == null)\n-            throw new UserException(_loc.get(\"no-broker-class\",\n-                _conf.getBrokerImpl()));\n-\n-        return broker;\n-    }\n-\n-    /**\n-     * Setup transient state used by this factory based on the\n-     * current configuration, which will subsequently be locked down. This\n-     * method will be called before the first broker is requested,\n-     * and will be re-called each time the factory is deserialized into a JVM\n-     * that has no configuration for this data store.\n-     */\n-    protected void setup() {\n-    }\n-\n-    /////////////\n-    // Utilities\n-    /////////////\n-\n-    /**\n-     * Find a managed runtime broker associated with the\n-     * current transaction, or returns null if none.\n-     */\n-    protected BrokerImpl findTransactionalBroker(String user, String pass) {\n-        Transaction trans;\n-        ManagedRuntime mr = _conf.getManagedRuntimeInstance();\n-        Object txKey;\n-        try {\n-            trans = mr.getTransactionManager().\n-                getTransaction();\n-            txKey = mr.getTransactionKey();\n-\n-            if (trans == null\n-                || trans.getStatus() == Status.STATUS_NO_TRANSACTION\n-                || trans.getStatus() == Status.STATUS_UNKNOWN)\n-                return null;\n-        } catch (OpenJPAException ke) {\n-            throw ke;\n-        } catch (Exception e) {\n-            throw new GeneralException(e);\n-        }\n-\n-        Collection brokers = (Collection) _transactional.get(txKey);\n-        if (brokers != null) {\n-            // we don't need to synchronize on brokers since one JTA transaction\n-            // can never be active on multiple concurrent threads.\n-            BrokerImpl broker;\n-            for (Iterator itr = brokers.iterator(); itr.hasNext();) {\n-                broker = (BrokerImpl) itr.next();\n-                if (StringUtils.equals(broker.getConnectionUserName(),\n-                    user) && StringUtils.equals\n-                    (broker.getConnectionPassword(), pass))\n-                    return broker;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Configures the given broker with the current factory option settings.\n-     */\n-    protected void configureBroker(BrokerImpl broker) {\n-        broker.setOptimistic(_conf.getOptimistic());\n-        broker.setNontransactionalRead(_conf.getNontransactionalRead());\n-        broker.setNontransactionalWrite(_conf.getNontransactionalWrite());\n-        broker.setRetainState(_conf.getRetainState());\n-        broker.setRestoreState(_conf.getRestoreStateConstant());\n-        broker.setAutoClear(_conf.getAutoClearConstant());\n-        broker.setIgnoreChanges(_conf.getIgnoreChanges());\n-        broker.setMultithreaded(_conf.getMultithreaded());\n-        broker.setAutoDetach(_conf.getAutoDetachConstant());\n-        broker.setDetachState(_conf.getDetachStateInstance().\n-            getDetachState());\n-    }\n-\n-    /**\n-     * Freezes the configuration of this factory.\n-     */\n-    public void makeReadOnly() {\n-        if (_readOnly)\n-            return;\n-\n-        lock();\n-        try {\n-            // check again\n-            if (_readOnly)\n-                return;\n-            _readOnly = true;\n-\n-            Log log = _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\n-            if (log.isInfoEnabled())\n-                log.info(getFactoryInitializationBanner());\n-            if (log.isTraceEnabled()) {\n-                Map props = _conf.toProperties(true);\n-                String lineSep = J2DoPrivHelper.getLineSeparator();\n-                StringBuffer buf = new StringBuffer();\n-                Map.Entry entry;\n-                for (Iterator itr = props.entrySet().iterator();\n-                    itr.hasNext();) {\n-                    entry = (Map.Entry) itr.next();\n-                    buf.append(entry.getKey()).append(\": \").\n-                        append(entry.getValue());\n-                    if (itr.hasNext())\n-                        buf.append(lineSep);\n-                }\n-                log.trace(_loc.get(\"factory-properties\", buf.toString()));\n-            }\n-\n-            // setup transient state\n-            setup();\n-\n-            // register the metdata repository to auto-load persistent types\n-            // and make sure types are enhanced\n-            MetaDataRepository repos = _conf.getMetaDataRepositoryInstance();\n-            repos.setValidate(repos.VALIDATE_RUNTIME, true);\n-            repos.setResolve(repos.MODE_MAPPING_INIT, true);\n-            PCRegistry.addRegisterClassListener(repos);\n-\n-            // freeze underlying configuration and eagerly initialize to\n-            // avoid synchronization\n-            _conf.setReadOnly(Configuration.INIT_STATE_FREEZING);\n-            _conf.instantiateAll();\n-\n-            // fire an event for all the broker factory listeners\n-            // registered on the configuration.\n-            _conf.getBrokerFactoryEventManager().fireEvent(\n-                new BrokerFactoryEvent(this,\n-                    BrokerFactoryEvent.BROKER_FACTORY_CREATED));\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    /**\n-     * Return an object to be written to the log when this broker factory\n-     * initializes. This happens after the configuration is fully loaded.\n-     */\n-    protected Object getFactoryInitializationBanner() {\n-        return _loc.get(\"factory-init\", OpenJPAVersion.VERSION_NUMBER);\n-    }\n-\n-    /**\n-     * Throw an exception if the factory is closed.  The exact message and\n-     * content of the exception varies whether TRACE is enabled or not.\n-     */\n-    private void assertOpen() {\n-        if (_closed) {\n-            if (_closedException == null)  // TRACE not enabled\n-                throw new InvalidStateException(_loc\n-                        .get(\"closed-factory-notrace\"));\n-            else\n-                throw new InvalidStateException(_loc.get(\"closed-factory\"))\n-                        .setCause(_closedException);\n-        }\n-    }\n-\n-    ////////////////////\n-    // Broker utilities\n-    ////////////////////\n-\n-    /**\n-     * Throws a {@link UserException} if a transaction is active. The thrown\n-     * exception will contain all the Brokers with active transactions as\n-     * failed objects in the nested exceptions.\n-     */\n-    private void assertNoActiveTransaction() {\n-        Collection excs;\n-        if (_transactional.isEmpty())\n-            return;\n-\n-        excs = new ArrayList(_transactional.size());\n-        for (Iterator trans = _transactional.values().iterator();\n-            trans.hasNext();) {\n-            Collection brokers = (Collection) trans.next();\n-            for (Iterator itr = brokers.iterator(); itr.hasNext();) {\n-                excs.add(new InvalidStateException(_loc.get(\"active\")).\n-                    setFailedObject(itr.next()));\n-            }\n-        }\n-\n-        if (!excs.isEmpty())\n-            throw new InvalidStateException(_loc.get(\"nested-exceps\")).\n-                setNestedThrowables((Throwable[]) excs.toArray\n-                    (new Throwable[excs.size()]));\n-    }\n-\n-    /**\n-     * Synchronize the given broker with a managed transaction,\n-     * optionally starting one if none is in progress.\n-     *\n-     * @return true if synched with transaction, false otherwise\n-     */\n-    boolean syncWithManagedTransaction(BrokerImpl broker, boolean begin) {\n-        Transaction trans;\n-        try {\n-            ManagedRuntime mr = broker.getManagedRuntime();\n-            TransactionManager tm = mr.getTransactionManager();\n-            trans = tm.getTransaction();\n-            if (trans != null\n-                && (trans.getStatus() == Status.STATUS_NO_TRANSACTION\n-                || trans.getStatus() == Status.STATUS_UNKNOWN))\n-                trans = null;\n-\n-            if (trans == null && begin) {\n-                tm.begin();\n-                trans = tm.getTransaction();\n-            } else if (trans == null)\n-                return false;\n-\n-            // synch broker and trans\n-            trans.registerSynchronization(broker);\n-\n-            // we don't need to synchronize on brokers or guard against multiple\n-            // threads using the same trans since one JTA transaction can never\n-            // be active on multiple concurrent threads.\n-            Object txKey = mr.getTransactionKey();\n-            Collection brokers = (Collection) _transactional.get(txKey);\n-            \n-            if (brokers == null) {\n-                brokers = new ArrayList(2);\n-                _transactional.put(txKey, brokers);\n-                trans.registerSynchronization(new RemoveTransactionSync(txKey));\n-            }\n-            brokers.add(broker);\n-            \n-            return true;\n-        } catch (OpenJPAException ke) {\n-            throw ke;\n-        } catch (Exception e) {\n-            throw new GeneralException(e);\n-        }\n-    }\n-\n-    /**\n-     * Returns a set of all the open brokers associated with this factory. The\n-     * returned set is unmodifiable, and may contain null references.\n-     */\n-    public Collection getOpenBrokers() {\n-        return Collections.unmodifiableCollection(_brokers);\n-    }\n-\n-    /**\n-     * @return a key that can be used to obtain this broker factory from the\n-     * pool at a later time.\n-     *\n-     * @since 1.1.0\n-     */\n-    public Object getPoolKey() {\n-        return _poolKey;\n-    }\n-\n-    /**\n-     * Set a key that can be used to obtain this broker factory from the\n-     * pool at a later time.\n-     *\n-     * @since 1.1.0\n-     */\n-    void setPoolKey(Object key) {\n-        _poolKey = key;\n-    }\n-\n-    /**\n-     * Simple synchronization listener to remove completed transactions\n-     * from our cache.\n-     */\n-    private class RemoveTransactionSync\n-        implements Synchronization {\n-\n-        private final Object _trans;\n-\n-        public RemoveTransactionSync(Object trans) {\n-            _trans = trans;\n-        }\n-\n-        public void beforeCompletion() {\n-        }\n-\n-        public void afterCompletion(int status) {\n-            _transactional.remove (_trans);\n-\t\t}\n-\t}\n-    \n-    /**\n-     * Method insures that deserialized EMF has this reference re-instantiated\n-     */\n-    private Collection getPcClassLoaders() {\n-       if (_pcClassLoaders == null)\n-         _pcClassLoaders = new ConcurrentReferenceHashSet(\n-             ConcurrentReferenceHashSet.WEAK);\n-          \n-       return _pcClassLoaders;\n-    }\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import java.io.ObjectStreamException;\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.LinkedList;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Properties;\r\n+import javax.transaction.Status;\r\n+import javax.transaction.Synchronization;\r\n+import javax.transaction.Transaction;\r\n+import javax.transaction.TransactionManager;\r\n+\r\n+import org.apache.commons.lang.StringUtils;\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+import org.apache.openjpa.conf.OpenJPAVersion;\r\n+import org.apache.openjpa.datacache.DataCacheStoreManager;\r\n+import org.apache.openjpa.ee.ManagedRuntime;\r\n+import org.apache.openjpa.enhance.PCRegistry;\r\n+import org.apache.openjpa.enhance.PersistenceCapable;\r\n+import org.apache.openjpa.enhance.ManagedClassSubclasser;\r\n+import org.apache.openjpa.event.BrokerFactoryEvent;\r\n+import org.apache.openjpa.event.RemoteCommitEventManager;\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.lib.conf.Configurations;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\r\n+import org.apache.openjpa.lib.util.JavaVersions;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashSet;\r\n+import java.util.concurrent.locks.ReentrantLock;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+import org.apache.openjpa.util.GeneralException;\r\n+import org.apache.openjpa.util.InternalException;\r\n+import org.apache.openjpa.util.InvalidStateException;\r\n+import org.apache.openjpa.util.OpenJPAException;\r\n+import org.apache.openjpa.util.UserException;\r\n+\r\n+/**\r\n+ * Abstract implementation of the {@link BrokerFactory}\r\n+ * that must be subclassed for a specific runtime.\r\n+ *\r\n+ * @author Abe White\r\n+ */\r\n+public abstract class AbstractBrokerFactory\r\n+    implements BrokerFactory {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (AbstractBrokerFactory.class);\r\n+\r\n+    // static mapping of configurations to pooled broker factories\r\n+    private static final Map _pool = Collections.synchronizedMap(new HashMap());\r\n+\r\n+    // configuration\r\n+    private final OpenJPAConfiguration _conf;\r\n+    private transient boolean _readOnly = false;\r\n+    private transient boolean _closed = false;\r\n+    private transient RuntimeException _closedException = null;\r\n+    private Map _userObjects = null;\r\n+\r\n+    // internal lock: spec forbids synchronization on this object\r\n+    private final ReentrantLock _lock = new ReentrantLock();\r\n+\r\n+    // maps global transactions to associated brokers\r\n+    private transient ConcurrentHashMap _transactional\r\n+        = new ConcurrentHashMap();\r\n+\r\n+    // weak-ref tracking of open brokers\r\n+    private transient Collection _brokers = new ConcurrentReferenceHashSet\r\n+        (ConcurrentReferenceHashSet.WEAK);\r\n+\r\n+    // cache the class names loaded from the persistent classes property so\r\n+    // that we can re-load them for each new broker\r\n+    private transient Collection _pcClassNames = null;\r\n+    private transient Collection _pcClassLoaders = null;\r\n+    private transient boolean _persistentTypesLoaded = false;\r\n+\r\n+    // lifecycle listeners to pass to each broker\r\n+    private transient Map _lifecycleListeners = null;\r\n+\r\n+    // transaction listeners to pass to each broker\r\n+    private transient List _transactionListeners = null;\r\n+\r\n+    // key under which this instance can be stored in the broker pool\r\n+    // and later identified\r\n+    private Object _poolKey;\r\n+\r\n+    /**\r\n+     * Return an internal factory pool key for the given configuration.\r\n+     *\r\n+     * @since 1.1.0\r\n+     */\r\n+    protected static Object toPoolKey(Map map) {\r\n+        Object key = Configurations.getProperty(\"Id\", map);\r\n+        return ( key != null) ? key : map;\r\n+    }\r\n+\r\n+    /**\r\n+     * Register <code>factory</code> in the pool under <code>key</code>.\r\n+     *\r\n+     * @since 1.1.0\r\n+     */\r\n+    protected static void pool(Object key, AbstractBrokerFactory factory) {\r\n+        synchronized(_pool) {\r\n+            _pool.put(key, factory);\r\n+            factory.setPoolKey(key);\r\n+            factory.makeReadOnly();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the pooled factory matching the given key, or null\r\n+     * if none. The key must be of the form created by {@link #getPoolKey}.\r\n+     */\r\n+    public static AbstractBrokerFactory getPooledFactoryForKey(Object key) {\r\n+        return (AbstractBrokerFactory) _pool.get(key);\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor. Configuration must be provided on construction.\r\n+     */\r\n+    protected AbstractBrokerFactory(OpenJPAConfiguration config) {\r\n+        _conf = config;\r\n+        getPcClassLoaders();\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the configuration for this factory.\r\n+     */\r\n+    public OpenJPAConfiguration getConfiguration() {\r\n+        return _conf;\r\n+    }\r\n+\r\n+    public Broker newBroker() {\r\n+        return newBroker(_conf.getConnectionUserName(),\r\n+            _conf.getConnectionPassword());\r\n+    }\r\n+\r\n+    public Broker newBroker(String user, String pass) {\r\n+        return newBroker(user, pass, _conf.isTransactionModeManaged(),\r\n+            _conf.getConnectionRetainModeConstant());\r\n+    }\r\n+\r\n+    public Broker newBroker(boolean managed, int connRetainMode) {\r\n+        return newBroker(_conf.getConnectionUserName(),\r\n+            _conf.getConnectionPassword(), managed, connRetainMode);\r\n+    }\r\n+\r\n+    public Broker newBroker(String user, String pass, boolean managed,\r\n+        int connRetainMode) {\r\n+        return newBroker(user, pass, managed, connRetainMode, true);\r\n+    }\r\n+\r\n+    public Broker newBroker(String user, String pass, boolean managed,\r\n+        int connRetainMode, boolean findExisting) {\r\n+        try {\r\n+            assertOpen();\r\n+            makeReadOnly();\r\n+\r\n+            BrokerImpl broker = null;\r\n+            if (findExisting)\r\n+                broker = findBroker(user, pass, managed);\r\n+            if (broker == null) {\r\n+                broker = newBrokerImpl(user, pass);\r\n+                initializeBroker(managed, connRetainMode, broker, false);\r\n+            }\r\n+            return broker;\r\n+        } catch (OpenJPAException ke) {\r\n+            throw ke;\r\n+        } catch (RuntimeException re) {\r\n+            throw new GeneralException(re);\r\n+        }\r\n+    }\r\n+\r\n+    void initializeBroker(boolean managed, int connRetainMode,\r\n+        BrokerImpl broker, boolean fromDeserialization) {\r\n+        assertOpen();\r\n+        makeReadOnly();\r\n+\r\n+        // decorate the store manager for data caching and custom\r\n+        // result object providers; always make sure it's a delegating\r\n+        // store manager, because it's easier for users to deal with\r\n+        // that way\r\n+        StoreManager sm = newStoreManager();\r\n+        DelegatingStoreManager dsm = null;\r\n+        if (_conf.getDataCacheManagerInstance().getSystemDataCache()\r\n+            != null)\r\n+            dsm = new DataCacheStoreManager(sm);\r\n+        dsm = new ROPStoreManager((dsm == null) ? sm : dsm);\r\n+\r\n+        broker.initialize(this, dsm, managed, connRetainMode,\r\n+            fromDeserialization);\r\n+        if (!fromDeserialization)\r\n+            addListeners(broker);\r\n+\r\n+        // if we're using remote events, register the event manager so\r\n+        // that it can broadcast commit notifications from the broker\r\n+        RemoteCommitEventManager remote = _conf.\r\n+            getRemoteCommitEventManager();\r\n+        if (remote.areRemoteEventsEnabled())\r\n+            broker.addTransactionListener(remote);\r\n+\r\n+        loadPersistentTypes(broker.getClassLoader());\r\n+        _brokers.add(broker);\r\n+        _conf.setReadOnly(Configuration.INIT_STATE_FROZEN);\r\n+    }\r\n+\r\n+    /**\r\n+     * Add factory-registered lifecycle listeners to the broker.\r\n+     */\r\n+    protected void addListeners(BrokerImpl broker) {\r\n+        if (_lifecycleListeners != null && !_lifecycleListeners.isEmpty()) {\r\n+            Map.Entry entry;\r\n+            for (Iterator itr = _lifecycleListeners.entrySet().iterator();\r\n+                itr.hasNext();) {\r\n+                entry = (Map.Entry) itr.next();\r\n+                broker.addLifecycleListener(entry.getKey(), (Class[])\r\n+                    entry.getValue());\r\n+            }\r\n+        }\r\n+\r\n+        if (_transactionListeners != null && !_transactionListeners.isEmpty()) {\r\n+            for (Iterator itr = _transactionListeners.iterator();\r\n+                itr.hasNext(); ) {\r\n+                broker.addTransactionListener(itr.next());\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Load the configured persistent classes list. Performed automatically\r\n+     * whenever a broker is created.\r\n+     */\r\n+    private void loadPersistentTypes(ClassLoader envLoader) {\r\n+        // if we've loaded the persistent types and the class name list\r\n+        // is empty, then we can simply return. Note that there is a\r\n+        // potential threading scenario in which _persistentTypesLoaded is\r\n+        // false when read, but the work to populate _pcClassNames has\r\n+        // already been done. This is ok; _pcClassNames can tolerate\r\n+        // concurrent access, so the worst case is that the list is\r\n+        // persistent type data is processed multiple times, which this\r\n+        // algorithm takes into account.\r\n+        if (_persistentTypesLoaded && _pcClassNames.isEmpty())\r\n+            return;\r\n+\r\n+        // cache persistent type names if not already\r\n+        ClassLoader loader = _conf.getClassResolverInstance().\r\n+            getClassLoader(getClass(), envLoader);\r\n+        Collection toRedefine = new ArrayList();\r\n+        if (!_persistentTypesLoaded) {\r\n+            Collection clss = _conf.getMetaDataRepositoryInstance().\r\n+                loadPersistentTypes(false, loader);\r\n+            if (clss.isEmpty())\r\n+                _pcClassNames = Collections.EMPTY_SET;\r\n+            else {\r\n+                Collection c = new ArrayList(clss.size());\r\n+                for (Iterator itr = clss.iterator(); itr.hasNext();) {\r\n+                    Class cls = (Class) itr.next();\r\n+                    c.add(cls.getName());\r\n+                    if (needsSub(cls))\r\n+                        toRedefine.add(cls);\r\n+                }\r\n+                getPcClassLoaders().add(loader);\r\n+                _pcClassNames = c;\r\n+            }\r\n+            _persistentTypesLoaded = true;\r\n+        } else {\r\n+            // reload with this loader\r\n+            if (getPcClassLoaders().add(loader)) {\r\n+                for (Iterator itr = _pcClassNames.iterator(); itr.hasNext();) {\r\n+                    try {\r\n+                        Class cls =\r\n+                            Class.forName((String) itr.next(), true, loader);\r\n+                        if (needsSub(cls))\r\n+                            toRedefine.add(cls);\r\n+                    } catch (Throwable t) {\r\n+                        _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME)\r\n+                            .warn(null, t);\r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        // get the ManagedClassSubclasser into the loop\r\n+        ManagedClassSubclasser.prepareUnenhancedClasses(\r\n+            _conf, toRedefine, envLoader);\r\n+    }\r\n+\r\n+    private boolean needsSub(Class cls) {\r\n+        return !cls.isInterface()\r\n+            && !PersistenceCapable.class.isAssignableFrom(cls);\r\n+    }\r\n+\r\n+    public void addLifecycleListener(Object listener, Class[] classes) {\r\n+        lock();\r\n+        try {\r\n+            assertOpen();\r\n+            if (_lifecycleListeners == null)\r\n+                _lifecycleListeners = new HashMap(7);\r\n+            _lifecycleListeners.put(listener, classes);\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void removeLifecycleListener(Object listener) {\r\n+        lock();\r\n+        try {\r\n+            assertOpen();\r\n+            if (_lifecycleListeners != null)\r\n+                _lifecycleListeners.remove(listener);\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void addTransactionListener(Object listener) {\r\n+        lock();\r\n+        try {\r\n+            assertOpen();\r\n+            if (_transactionListeners == null)\r\n+                _transactionListeners = new LinkedList();\r\n+            _transactionListeners.add(listener);\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void removeTransactionListener(Object listener) {\r\n+        lock();\r\n+        try {\r\n+            assertOpen();\r\n+            if (_transactionListeners != null)\r\n+                _transactionListeners.remove(listener);\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns true if this broker factory is closed.\r\n+     */\r\n+    public boolean isClosed() {\r\n+        return _closed;\r\n+    }\r\n+\r\n+    public void close() {\r\n+        lock();\r\n+        try {\r\n+            assertOpen();\r\n+            assertNoActiveTransaction();\r\n+\r\n+            // remove from factory pool\r\n+            synchronized (_pool) {\r\n+                if (_pool.get(_poolKey) == this)\r\n+                    _pool.remove(_poolKey);\r\n+            }\r\n+\r\n+            // close all brokers\r\n+            Broker broker;\r\n+            for (Iterator itr = _brokers.iterator(); itr.hasNext();) {\r\n+                broker = (Broker) itr.next();\r\n+                // Check for null because _brokers contains weak references\r\n+                if ((broker != null) && (!broker.isClosed()))\r\n+                    broker.close();\r\n+            }\r\n+\r\n+            if(_conf.metaDataRepositoryAvailable()) {\r\n+                // remove metadata repository from listener list\r\n+                PCRegistry.removeRegisterClassListener\r\n+                    (_conf.getMetaDataRepositoryInstance());\r\n+            }\r\n+\r\n+            _conf.close();\r\n+            _closed = true;\r\n+            Log log = _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\r\n+            if (log.isTraceEnabled())\r\n+                _closedException = new IllegalStateException();\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Subclasses should override this method to add a <code>Platform</code>\r\n+     * property listing the runtime platform, such as:\r\n+     * <code>OpenJPA JDBC Edition: Oracle Database</code>\r\n+     */\r\n+    public Properties getProperties() {\r\n+        // required props are VendorName and VersionNumber\r\n+        Properties props = new Properties();\r\n+        props.setProperty(\"VendorName\", OpenJPAVersion.VENDOR_NAME);\r\n+        props.setProperty(\"VersionNumber\", OpenJPAVersion.VERSION_NUMBER);\r\n+        props.setProperty(\"VersionId\", OpenJPAVersion.VERSION_ID);\r\n+        return props;\r\n+    }\r\n+\r\n+    public Object getUserObject(Object key) {\r\n+        lock();\r\n+        try {\r\n+            assertOpen();\r\n+            return (_userObjects == null) ? null : _userObjects.get(key);\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public Object putUserObject(Object key, Object val) {\r\n+        lock();\r\n+        try {\r\n+            assertOpen();\r\n+            if (val == null)\r\n+                return (_userObjects == null) ? null : _userObjects.remove(key);\r\n+\r\n+            if (_userObjects == null)\r\n+                _userObjects = new HashMap();\r\n+            return _userObjects.put(key, val);\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void lock() {\r\n+        _lock.lock();\r\n+    }\r\n+\r\n+    public void unlock() {\r\n+        _lock.unlock();\r\n+    }\r\n+\r\n+    /**\r\n+     * Replaces the factory with this JVMs pooled version if it exists. Also\r\n+     * freezes the factory.\r\n+     */\r\n+    protected Object readResolve()\r\n+        throws ObjectStreamException {\r\n+        AbstractBrokerFactory factory = getPooledFactoryForKey(_poolKey);\r\n+        if (factory != null)\r\n+            return factory;\r\n+\r\n+        // reset these transient fields to empty values\r\n+        _transactional = new ConcurrentHashMap();\r\n+        _brokers = new ConcurrentReferenceHashSet(\r\n+                ConcurrentReferenceHashSet.WEAK);\r\n+\r\n+        makeReadOnly();\r\n+        return this;\r\n+    }\r\n+\r\n+    ////////////////////////\r\n+    // Methods for Override\r\n+    ////////////////////////\r\n+\r\n+    /**\r\n+     * Return a new StoreManager for this runtime. Note that the instance\r\n+     * returned here may be wrapped before being passed to the\r\n+     * {@link #newBroker} method.\r\n+     */\r\n+    protected abstract StoreManager newStoreManager();\r\n+\r\n+    /**\r\n+     * Find a pooled broker, or return null if none. If using\r\n+     * managed transactions, looks for a transactional broker;\r\n+     * otherwise returns null by default. This method will be called before\r\n+     * {@link #newStoreManager} so that factory subclasses implementing\r\n+     * pooling can return a matching manager before a new {@link StoreManager}\r\n+     * is created.\r\n+     */\r\n+    protected BrokerImpl findBroker(String user, String pass, boolean managed) {\r\n+        if (managed)\r\n+            return findTransactionalBroker(user, pass);\r\n+        return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a broker configured with the proper settings.\r\n+     * By default, this method constructs a new\r\n+     * BrokerImpl of the class set for this factory.\r\n+     */\r\n+    protected BrokerImpl newBrokerImpl(String user, String pass) {\r\n+        BrokerImpl broker = _conf.newBrokerInstance(user, pass);\r\n+        if (broker == null)\r\n+            throw new UserException(_loc.get(\"no-broker-class\",\r\n+                _conf.getBrokerImpl()));\r\n+\r\n+        return broker;\r\n+    }\r\n+\r\n+    /**\r\n+     * Setup transient state used by this factory based on the\r\n+     * current configuration, which will subsequently be locked down. This\r\n+     * method will be called before the first broker is requested,\r\n+     * and will be re-called each time the factory is deserialized into a JVM\r\n+     * that has no configuration for this data store.\r\n+     */\r\n+    protected void setup() {\r\n+    }\r\n+\r\n+    /////////////\r\n+    // Utilities\r\n+    /////////////\r\n+\r\n+    /**\r\n+     * Find a managed runtime broker associated with the\r\n+     * current transaction, or returns null if none.\r\n+     */\r\n+    protected BrokerImpl findTransactionalBroker(String user, String pass) {\r\n+        Transaction trans;\r\n+        ManagedRuntime mr = _conf.getManagedRuntimeInstance();\r\n+        Object txKey;\r\n+        try {\r\n+            trans = mr.getTransactionManager().\r\n+                getTransaction();\r\n+            txKey = mr.getTransactionKey();\r\n+\r\n+            if (trans == null\r\n+                || trans.getStatus() == Status.STATUS_NO_TRANSACTION\r\n+                || trans.getStatus() == Status.STATUS_UNKNOWN)\r\n+                return null;\r\n+        } catch (OpenJPAException ke) {\r\n+            throw ke;\r\n+        } catch (Exception e) {\r\n+            throw new GeneralException(e);\r\n+        }\r\n+\r\n+        Collection brokers = (Collection) _transactional.get(txKey);\r\n+        if (brokers != null) {\r\n+            // we don't need to synchronize on brokers since one JTA transaction\r\n+            // can never be active on multiple concurrent threads.\r\n+            BrokerImpl broker;\r\n+            for (Iterator itr = brokers.iterator(); itr.hasNext();) {\r\n+                broker = (BrokerImpl) itr.next();\r\n+                if (StringUtils.equals(broker.getConnectionUserName(),\r\n+                    user) && StringUtils.equals\r\n+                    (broker.getConnectionPassword(), pass))\r\n+                    return broker;\r\n+            }\r\n+        }\r\n+        return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Configures the given broker with the current factory option settings.\r\n+     */\r\n+    protected void configureBroker(BrokerImpl broker) {\r\n+        broker.setOptimistic(_conf.getOptimistic());\r\n+        broker.setNontransactionalRead(_conf.getNontransactionalRead());\r\n+        broker.setNontransactionalWrite(_conf.getNontransactionalWrite());\r\n+        broker.setRetainState(_conf.getRetainState());\r\n+        broker.setRestoreState(_conf.getRestoreStateConstant());\r\n+        broker.setAutoClear(_conf.getAutoClearConstant());\r\n+        broker.setIgnoreChanges(_conf.getIgnoreChanges());\r\n+        broker.setMultithreaded(_conf.getMultithreaded());\r\n+        broker.setAutoDetach(_conf.getAutoDetachConstant());\r\n+        broker.setDetachState(_conf.getDetachStateInstance().\r\n+            getDetachState());\r\n+    }\r\n+\r\n+    /**\r\n+     * Freezes the configuration of this factory.\r\n+     */\r\n+    public void makeReadOnly() {\r\n+        if (_readOnly)\r\n+            return;\r\n+\r\n+        lock();\r\n+        try {\r\n+            // check again\r\n+            if (_readOnly)\r\n+                return;\r\n+            _readOnly = true;\r\n+\r\n+            Log log = _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\r\n+            if (log.isInfoEnabled())\r\n+                log.info(getFactoryInitializationBanner());\r\n+            if (log.isTraceEnabled()) {\r\n+                Map props = _conf.toProperties(true);\r\n+                String lineSep = J2DoPrivHelper.getLineSeparator();\r\n+                StringBuffer buf = new StringBuffer();\r\n+                Map.Entry entry;\r\n+                for (Iterator itr = props.entrySet().iterator();\r\n+                    itr.hasNext();) {\r\n+                    entry = (Map.Entry) itr.next();\r\n+                    buf.append(entry.getKey()).append(\": \").\r\n+                        append(entry.getValue());\r\n+                    if (itr.hasNext())\r\n+                        buf.append(lineSep);\r\n+                }\r\n+                log.trace(_loc.get(\"factory-properties\", buf.toString()));\r\n+            }\r\n+\r\n+            // setup transient state\r\n+            setup();\r\n+\r\n+            // register the metdata repository to auto-load persistent types\r\n+            // and make sure types are enhanced\r\n+            MetaDataRepository repos = _conf.getMetaDataRepositoryInstance();\r\n+            repos.setValidate(repos.VALIDATE_RUNTIME, true);\r\n+            repos.setResolve(repos.MODE_MAPPING_INIT, true);\r\n+            PCRegistry.addRegisterClassListener(repos);\r\n+\r\n+            // freeze underlying configuration and eagerly initialize to\r\n+            // avoid synchronization\r\n+            _conf.setReadOnly(Configuration.INIT_STATE_FREEZING);\r\n+            _conf.instantiateAll();\r\n+\r\n+            // fire an event for all the broker factory listeners\r\n+            // registered on the configuration.\r\n+            _conf.getBrokerFactoryEventManager().fireEvent(\r\n+                new BrokerFactoryEvent(this,\r\n+                    BrokerFactoryEvent.BROKER_FACTORY_CREATED));\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return an object to be written to the log when this broker factory\r\n+     * initializes. This happens after the configuration is fully loaded.\r\n+     */\r\n+    protected Object getFactoryInitializationBanner() {\r\n+        return _loc.get(\"factory-init\", OpenJPAVersion.VERSION_NUMBER);\r\n+    }\r\n+\r\n+    /**\r\n+     * Throw an exception if the factory is closed.  The exact message and\r\n+     * content of the exception varies whether TRACE is enabled or not.\r\n+     */\r\n+    private void assertOpen() {\r\n+        if (_closed) {\r\n+            if (_closedException == null)  // TRACE not enabled\r\n+                throw new InvalidStateException(_loc\r\n+                        .get(\"closed-factory-notrace\"));\r\n+            else\r\n+                throw new InvalidStateException(_loc.get(\"closed-factory\"))\r\n+                        .setCause(_closedException);\r\n+        }\r\n+    }\r\n+\r\n+    ////////////////////\r\n+    // Broker utilities\r\n+    ////////////////////\r\n+\r\n+    /**\r\n+     * Throws a {@link UserException} if a transaction is active. The thrown\r\n+     * exception will contain all the Brokers with active transactions as\r\n+     * failed objects in the nested exceptions.\r\n+     */\r\n+    private void assertNoActiveTransaction() {\r\n+        Collection excs;\r\n+        if (_transactional.isEmpty())\r\n+            return;\r\n+\r\n+        excs = new ArrayList(_transactional.size());\r\n+        for (Iterator trans = _transactional.values().iterator();\r\n+            trans.hasNext();) {\r\n+            Collection brokers = (Collection) trans.next();\r\n+            for (Iterator itr = brokers.iterator(); itr.hasNext();) {\r\n+                excs.add(new InvalidStateException(_loc.get(\"active\")).\r\n+                    setFailedObject(itr.next()));\r\n+            }\r\n+        }\r\n+\r\n+        if (!excs.isEmpty())\r\n+            throw new InvalidStateException(_loc.get(\"nested-exceps\")).\r\n+                setNestedThrowables((Throwable[]) excs.toArray\r\n+                    (new Throwable[excs.size()]));\r\n+    }\r\n+\r\n+    /**\r\n+     * Synchronize the given broker with a managed transaction,\r\n+     * optionally starting one if none is in progress.\r\n+     *\r\n+     * @return true if synched with transaction, false otherwise\r\n+     */\r\n+    boolean syncWithManagedTransaction(BrokerImpl broker, boolean begin) {\r\n+        Transaction trans;\r\n+        try {\r\n+            ManagedRuntime mr = broker.getManagedRuntime();\r\n+            TransactionManager tm = mr.getTransactionManager();\r\n+            trans = tm.getTransaction();\r\n+            if (trans != null\r\n+                && (trans.getStatus() == Status.STATUS_NO_TRANSACTION\r\n+                || trans.getStatus() == Status.STATUS_UNKNOWN))\r\n+                trans = null;\r\n+\r\n+            if (trans == null && begin) {\r\n+                tm.begin();\r\n+                trans = tm.getTransaction();\r\n+            } else if (trans == null)\r\n+                return false;\r\n+\r\n+            // synch broker and trans\r\n+            trans.registerSynchronization(broker);\r\n+\r\n+            // we don't need to synchronize on brokers or guard against multiple\r\n+            // threads using the same trans since one JTA transaction can never\r\n+            // be active on multiple concurrent threads.\r\n+            Object txKey = mr.getTransactionKey();\r\n+            Collection brokers = (Collection) _transactional.get(txKey);\r\n+            \r\n+            if (brokers == null) {\r\n+                brokers = new ArrayList(2);\r\n+                _transactional.put(txKey, brokers);\r\n+                trans.registerSynchronization(new RemoveTransactionSync(txKey));\r\n+            }\r\n+            brokers.add(broker);\r\n+            \r\n+            return true;\r\n+        } catch (OpenJPAException ke) {\r\n+            throw ke;\r\n+        } catch (Exception e) {\r\n+            throw new GeneralException(e);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a set of all the open brokers associated with this factory. The\r\n+     * returned set is unmodifiable, and may contain null references.\r\n+     */\r\n+    public Collection getOpenBrokers() {\r\n+        return Collections.unmodifiableCollection(_brokers);\r\n+    }\r\n+\r\n+    /**\r\n+     * @return a key that can be used to obtain this broker factory from the\r\n+     * pool at a later time.\r\n+     *\r\n+     * @since 1.1.0\r\n+     */\r\n+    public Object getPoolKey() {\r\n+        return _poolKey;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set a key that can be used to obtain this broker factory from the\r\n+     * pool at a later time.\r\n+     *\r\n+     * @since 1.1.0\r\n+     */\r\n+    void setPoolKey(Object key) {\r\n+        _poolKey = key;\r\n+    }\r\n+\r\n+    /**\r\n+     * Simple synchronization listener to remove completed transactions\r\n+     * from our cache.\r\n+     */\r\n+    private class RemoveTransactionSync\r\n+        implements Synchronization {\r\n+\r\n+        private final Object _trans;\r\n+\r\n+        public RemoveTransactionSync(Object trans) {\r\n+            _trans = trans;\r\n+        }\r\n+\r\n+        public void beforeCompletion() {\r\n+        }\r\n+\r\n+        public void afterCompletion(int status) {\r\n+            _transactional.remove (_trans);\r\n+\t\t}\r\n+\t}\r\n+    \r\n+    /**\r\n+     * Method insures that deserialized EMF has this reference re-instantiated\r\n+     */\r\n+    private Collection getPcClassLoaders() {\r\n+       if (_pcClassLoaders == null)\r\n+         _pcClassLoaders = new ConcurrentReferenceHashSet(\r\n+             ConcurrentReferenceHashSet.WEAK);\r\n+          \r\n+       return _pcClassLoaders;\r\n+    }\r\n+}\r"},{"sha":"2119b47f94cf2f46dd16eb27229581cd6f067f67","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":4728,"deletions":4728,"changes":9456,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"7fc43ebd288e1e4712af79390927d4daf182d17c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","status":"modified","additions":947,"deletions":947,"changes":1894,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,947 +1,947 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.kernel;\n-\n-import java.io.IOException;\n-import java.io.ObjectOutput;\n-import java.io.Serializable;\n-import java.util.BitSet;\n-import java.util.Collection;\n-import java.util.Map;\n-\n-import org.apache.openjpa.enhance.PersistenceCapable;\n-import org.apache.openjpa.enhance.StateManager;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.util.concurrent.ReentrantLock;\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.meta.FieldMetaData;\n-import org.apache.openjpa.meta.JavaTypes;\n-import org.apache.openjpa.meta.ValueMetaData;\n-import org.apache.openjpa.util.Exceptions;\n-import org.apache.openjpa.util.Proxy;\n-import org.apache.openjpa.util.UnsupportedException;\n-import org.apache.openjpa.util.ImplHelper;\n-\n-/**\n- * Internal state manager for detached instances. Does not fully\n- * implement {@link OpenJPAStateManager} contract to allow for serialization.\n- *\n- * @author Steve Kim\n- * @nojavadoc\n- */\n-public class DetachedStateManager\n-    extends AttachStrategy\n-    implements OpenJPAStateManager, Serializable {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (DetachedStateManager.class);\n-\n-    private final PersistenceCapable _pc;\n-    private final boolean _embedded;\n-    private final boolean _access;\n-    private final BitSet _loaded;\n-    private final BitSet _dirty;\n-    private final Object _oid;\n-    private final Object _version;\n-    private final ReentrantLock _lock;\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param pc the managed instance\n-     * @param sm the instance's state manager\n-     * @param load the set of detached field indexes\n-     * @param access whether to allow access to unloaded fields\n-     * @param multithreaded whether the instance will be used concurrently\n-     * by multiple threads\n-     */\n-    public DetachedStateManager(PersistenceCapable pc, OpenJPAStateManager sm,\n-        BitSet load, boolean access, boolean multithreaded) {\n-        _pc = pc;\n-        _embedded = sm.isEmbedded();\n-        _loaded = load;\n-        _access = access;\n-        _dirty = new BitSet(_loaded.length());\n-        _oid = sm.fetchObjectId();\n-        _version = sm.getVersion();\n-        if (multithreaded)\n-            _lock = new ReentrantLock();\n-        else\n-            _lock = null;\n-    }\n-\n-    /////////////////////////////////\n-    // AttachStrategy implementation\n-    /////////////////////////////////\n-\n-    public Object attach(AttachManager manager, Object toAttach,\n-        ClassMetaData meta, PersistenceCapable into, OpenJPAStateManager owner,\n-        ValueMetaData ownerMeta, boolean explicit) {\n-        BrokerImpl broker = manager.getBroker();\n-        StateManagerImpl sm;\n-        if (_embedded) {\n-            if (_dirty.length () > 0)\n-                owner.dirty(ownerMeta.getFieldMetaData().getIndex());\n-            sm = (StateManagerImpl) broker.embed(_pc, _oid, owner, ownerMeta);\n-            ImplHelper.toPersistenceCapable(toAttach, broker.getConfiguration())\n-                .pcReplaceStateManager(this);\n-        } else {\n-            PCState state = (_dirty.length() > 0) ? PCState.PDIRTY\n-                : PCState.PCLEAN;\n-            sm = (StateManagerImpl) broker.copy(this, state);\n-        }\n-        PersistenceCapable pc = sm.getPersistenceCapable();\n-        manager.setAttachedCopy(toAttach, pc);\n-\n-        manager.fireBeforeAttach(toAttach, meta);\n-\n-        // pre-load for efficiency: current field values for restore, dependent\n-        // for delete\n-        FieldMetaData[] fields = meta.getFields();\n-        int restore = broker.getRestoreState();\n-        if (_dirty.length() > 0) {\n-            BitSet load = new BitSet(fields.length);\n-            for (int i = 0; i < fields.length; i++) {\n-                if (!_dirty.get(i))\n-                    continue;\n-\n-                switch (fields[i].getDeclaredTypeCode()) {\n-                    case JavaTypes.ARRAY:\n-                    case JavaTypes.COLLECTION:\n-                        if (restore == RestoreState.RESTORE_ALL\n-                            || fields[i].getElement().getCascadeDelete()\n-                            == ValueMetaData.CASCADE_AUTO)\n-                            load.set(i);\n-                        break;\n-                    case JavaTypes.MAP:\n-                        if (restore == RestoreState.RESTORE_ALL\n-                            || fields[i].getElement().getCascadeDelete()\n-                            == ValueMetaData.CASCADE_AUTO\n-                            || fields[i].getKey().getCascadeDelete()\n-                            == ValueMetaData.CASCADE_AUTO)\n-                            load.set(i);\n-                        break;\n-                    default:\n-                        if (restore != RestoreState.RESTORE_NONE\n-                            || fields[i].getCascadeDelete()\n-                            == ValueMetaData.CASCADE_AUTO)\n-                            load.set(i);\n-                }\n-            }\n-            FetchConfiguration fc = broker.getFetchConfiguration();\n-            sm.loadFields(load, fc, fc.getWriteLockLevel(), null);\n-        }        \n-        Object origVersion = sm.getVersion();\n-        sm.setVersion(_version);\n-\n-        BitSet loaded = sm.getLoaded();\n-        int set = StateManager.SET_ATTACH;\n-        for (int i = 0; i < fields.length; i++) {\n-            if (!_loaded.get(i))\n-                continue;\n-            // don't reload already loaded non-mutable objects\n-            if (!_dirty.get(i) && loaded.get(i) && ignoreLoaded(fields[i]))\n-                continue;\n-\n-            provideField(i);\n-            switch (fields[i].getDeclaredTypeCode()) {\n-                case JavaTypes.BOOLEAN:\n-                    if (_dirty.get(i))\n-                        sm.settingBooleanField(pc, i,\n-                            (loaded.get(i)) && sm.fetchBooleanField(i),\n-                            longval == 1, set);\n-                    else\n-                        sm.storeBooleanField(i, longval == 1);\n-                    break;\n-                case JavaTypes.BYTE:\n-                    if (_dirty.get(i))\n-                        sm.settingByteField(pc, i, (!loaded.get(i)) ? (byte) 0\n-                            : sm.fetchByteField(i), (byte) longval, set);\n-                    else\n-                        sm.storeByteField(i, (byte) longval);\n-                    break;\n-                case JavaTypes.CHAR:\n-                    if (_dirty.get(i))\n-                        sm.settingCharField(pc, i, (!loaded.get(i)) ? (char) 0\n-                            : sm.fetchCharField(i), (char) longval, set);\n-                    else\n-                        sm.storeCharField(i, (char) longval);\n-                    break;\n-                case JavaTypes.INT:\n-                    if (_dirty.get(i))\n-                        sm.settingIntField(pc, i, (!loaded.get(i)) ? 0\n-                            : sm.fetchIntField(i), (int) longval, set);\n-                    else\n-                        sm.storeIntField(i, (int) longval);\n-                    break;\n-                case JavaTypes.LONG:\n-                    if (_dirty.get(i))\n-                        sm.settingLongField(pc, i, (!loaded.get(i)) ? 0L\n-                            : sm.fetchLongField(i), longval, set);\n-                    else\n-                        sm.storeLongField(i, longval);\n-                    break;\n-                case JavaTypes.SHORT:\n-                    if (_dirty.get(i))\n-                        sm.settingShortField(pc, i, (!loaded.get(i)) ? (short) 0\n-                            : sm.fetchShortField(i), (short) longval, set);\n-                    else\n-                        sm.storeShortField(i, (short) longval);\n-                    break;\n-                case JavaTypes.FLOAT:\n-                    if (_dirty.get(i))\n-                        sm.settingFloatField(pc, i, (!loaded.get(i)) ? 0F\n-                            : sm.fetchFloatField(i), (float) dblval, set);\n-                    else\n-                        sm.storeFloatField(i, (float) dblval);\n-                    break;\n-                case JavaTypes.DOUBLE:\n-                    if (_dirty.get(i))\n-                        sm.settingDoubleField(pc, i, (!loaded.get(i)) ? 0D\n-                            : sm.fetchDoubleField(i), dblval, set);\n-                    else\n-                        sm.storeDoubleField(i, dblval);\n-                    break;\n-                case JavaTypes.STRING:\n-                    if (_dirty.get(i))\n-                        sm.settingStringField(pc, i, (!loaded.get(i)) ? null\n-                            : sm.fetchStringField(i), (String) objval, set);\n-                    else\n-                        sm.storeStringField(i, (String) objval);\n-                    objval = null;\n-                    break;\n-                case JavaTypes.PC:\n-                case JavaTypes.PC_UNTYPED:\n-                    if (fields[i].getCascadeAttach() == ValueMetaData\n-                        .CASCADE_NONE)\n-                        objval = getReference(manager, objval, sm, fields[i]);\n-                    else {\n-                        PersistenceCapable toPC = null;\n-                        if (objval != null && fields[i].isEmbeddedPC())\n-                            toPC = ImplHelper.toPersistenceCapable(objval,\n-                                broker.getConfiguration());\n-                        objval = manager.attach(objval, toPC, sm, fields[i],\n-                            false);\n-                    }\n-                    if (_dirty.get(i))\n-                        sm.settingObjectField(pc, i, (!loaded.get(i)) ? null\n-                            : sm.fetchObjectField(i), objval, set);\n-                    else\n-                        sm.storeObjectField(i, objval);\n-                    objval = null;\n-                    break;\n-                case JavaTypes.COLLECTION:\n-                    Collection coll = (Collection) objval;\n-                    objval = null;\n-                    if (coll != null)\n-                        coll = attachCollection(manager, coll, sm, fields[i]);\n-                    if (_dirty.get(i))\n-                        sm.settingObjectField(pc, i, (!loaded.get(i)) ? null\n-                            : sm.fetchObjectField(i), coll, set);\n-                    else\n-                        sm.storeObjectField(i, coll);\n-                    break;\n-                case JavaTypes.MAP:\n-                    Map map = (Map) objval;\n-                    objval = null;\n-                    if (map != null)\n-                        map = attachMap(manager, map, sm, fields[i]);\n-                    if (_dirty.get(i))\n-                        sm.settingObjectField(pc, i, (!loaded.get(i)) ? null\n-                            : sm.fetchObjectField(i), map, set);\n-                    else\n-                        sm.storeObjectField(i, map);\n-                    break;\n-                default:\n-                    if (_dirty.get(i))\n-                        sm.settingObjectField(pc, i, (!loaded.get(i)) ? null\n-                            : sm.fetchObjectField(i), objval, set);\n-                    else\n-                        sm.storeObjectField(i, objval);\n-                    objval = null;\n-            }\n-        }\n-        pc.pcReplaceStateManager(sm);\n-\n-        // if we were clean at least make sure a version check is done to\n-        // prevent using old state\n-        if (!sm.isVersionCheckRequired() && broker.isActive()\n-            && _version != origVersion && (origVersion == null \n-            || broker.getStoreManager().compareVersion(sm, _version, \n-            origVersion) != StoreManager.VERSION_SAME)) {\n-            broker.transactional(sm.getManagedInstance(), false, \n-                manager.getBehavior());\n-        }\n-\n-        return sm.getManagedInstance();\n-    }\n-\n-    protected Object getDetachedObjectId(AttachManager manager,\n-        Object toAttach) {\n-        return _oid;\n-    }\n-\n-    void provideField(int field) {\n-        _pc.pcProvideField(field);\n-    }\n-\n-    protected void provideField(Object toAttach, StateManagerImpl sm,\n-        int field) {\n-        provideField(field);\n-    }\n-\n-    /**\n-     * Ignore if the field is not dirty but loaded\n-     */\n-    protected static boolean ignoreLoaded(FieldMetaData fmd) {\n-        switch (fmd.getTypeCode()) {\n-            case JavaTypes.BOOLEAN:\n-            case JavaTypes.BOOLEAN_OBJ:\n-            case JavaTypes.BYTE:\n-            case JavaTypes.BYTE_OBJ:\n-            case JavaTypes.INT:\n-            case JavaTypes.INT_OBJ:\n-            case JavaTypes.LONG:\n-            case JavaTypes.LONG_OBJ:\n-            case JavaTypes.SHORT:\n-            case JavaTypes.SHORT_OBJ:\n-            case JavaTypes.DOUBLE:\n-            case JavaTypes.DOUBLE_OBJ:\n-            case JavaTypes.FLOAT:\n-            case JavaTypes.FLOAT_OBJ:\n-            case JavaTypes.CHAR:\n-            case JavaTypes.CHAR_OBJ:\n-            case JavaTypes.STRING:\n-                return true;\n-        }\n-        return false;\n-    }\n-\n-    ///////////////////////////////\n-    // StateManager implementation\n-    ///////////////////////////////\n-\n-    public Object getGenericContext() {\n-        return null;\n-    }\n-\n-    public Object getPCPrimaryKey(Object oid, int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public StateManager replaceStateManager(StateManager sm) {\n-        return sm;\n-    }\n-\n-    public Object getVersion() {\n-        return _version;\n-    }\n-\n-    public void setVersion(Object version) {\n-        throw new UnsupportedException();\n-    }\n-\n-    public boolean isDirty() {\n-        return _dirty.length() != 0;\n-    }\n-\n-    public boolean isTransactional() {\n-        return false;\n-    }\n-\n-    public boolean isPersistent() {\n-        return false;\n-    }\n-\n-    public boolean isNew() {\n-        return false;\n-    }\n-\n-    public boolean isDeleted() {\n-        return false;\n-    }\n-\n-    public boolean isDetached() {\n-        return true;\n-    }\n-\n-    public boolean isVersionUpdateRequired() {\n-        return false;\n-    }\n-\n-    public boolean isVersionCheckRequired() {\n-        return false;\n-    }\n-\n-    public void dirty(String field) {\n-        // should we store ClassMetaData?\n-        throw new UnsupportedException();\n-    }\n-\n-    public Object fetchObjectId() {\n-        return _oid;\n-    }\n-\n-    public void accessingField(int idx) {\n-        if (!_access && !_loaded.get(idx))\n-        \t// do not access the pc fields by implictly invoking _pc.toString()\n-        \t// may cause infinite loop if again tries to access unloaded field \n-            throw new IllegalStateException(_loc.get(\"unloaded-detached\",\n-               Exceptions.toString(_pc)).getMessage());\n-    }\n-\n-    public boolean serializing() {\n-        return false;\n-    }\n-\n-    public boolean writeDetached(ObjectOutput out)\n-        throws IOException {\n-        out.writeObject(_pc.pcGetDetachedState());\n-        out.writeObject(this);\n-        return false;\n-    }\n-\n-    public void proxyDetachedDeserialized(int idx) {\n-        lock();\n-        try {\n-            _pc.pcProvideField(idx);\n-            if (objval instanceof Proxy)\n-                ((Proxy) objval).setOwner(this, idx);\n-            objval = null;\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    public void settingBooleanField(PersistenceCapable pc, int idx,\n-        boolean cur, boolean next, int set) {\n-        accessingField(idx);\n-        if (cur == next || !_loaded.get(idx))\n-            return;\n-        lock();\n-        try {\n-            _dirty.set(idx);\n-            longval = next ? 1 : 0;\n-            pc.pcReplaceField(idx);\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    public void settingCharField(PersistenceCapable pc, int idx, char cur,\n-        char next, int set) {\n-        accessingField(idx);\n-        if (cur == next || !_loaded.get(idx))\n-            return;\n-        lock();\n-        try {\n-            _dirty.set(idx);\n-            longval = next;\n-            pc.pcReplaceField(idx);\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    public void settingByteField(PersistenceCapable pc, int idx, byte cur,\n-        byte next, int set) {\n-        accessingField(idx);\n-        if (cur == next || !_loaded.get(idx))\n-            return;\n-        lock();\n-        try {\n-            _dirty.set(idx);\n-            longval = next;\n-            pc.pcReplaceField(idx);\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    public void settingShortField(PersistenceCapable pc, int idx, short cur,\n-        short next, int set) {\n-        accessingField(idx);\n-        if (cur == next || !_loaded.get(idx))\n-            return;\n-        lock();\n-        try {\n-            _dirty.set(idx);\n-            longval = next;\n-            pc.pcReplaceField(idx);\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    public void settingIntField(PersistenceCapable pc, int idx, int cur,\n-        int next, int set) {\n-        accessingField(idx);\n-        if (cur == next || !_loaded.get(idx))\n-            return;\n-        lock();\n-        try {\n-            _dirty.set(idx);\n-            longval = next;\n-            pc.pcReplaceField(idx);\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    public void settingLongField(PersistenceCapable pc, int idx, long cur,\n-        long next, int set) {\n-        accessingField(idx);\n-        if (cur == next || !_loaded.get(idx))\n-            return;\n-        lock();\n-        try {\n-            _dirty.set(idx);\n-            longval = next;\n-            pc.pcReplaceField(idx);\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    public void settingFloatField(PersistenceCapable pc, int idx, float cur,\n-        float next, int set) {\n-        accessingField(idx);\n-        if (cur == next || !_loaded.get(idx))\n-            return;\n-        lock();\n-        try {\n-            _dirty.set(idx);\n-            dblval = next;\n-            pc.pcReplaceField(idx);\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    public void settingDoubleField(PersistenceCapable pc, int idx, double cur,\n-        double next, int set) {\n-        accessingField(idx);\n-        if (cur == next || !_loaded.get(idx))\n-            return;\n-        lock();\n-        try {\n-            _dirty.set(idx);\n-            dblval = next;\n-            pc.pcReplaceField(idx);\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    public void settingStringField(PersistenceCapable pc, int idx, String cur,\n-        String next, int set) {\n-        accessingField(idx);\n-        if (cur == next || (cur != null && cur.equals(next))\n-                || !_loaded.get(idx))\n-            return;\n-        lock();\n-        try {\n-            _dirty.set(idx);\n-            objval = next;\n-            pc.pcReplaceField(idx);\n-        } finally {\n-            unlock();\n-            objval = null;\n-        }\n-    }\n-\n-    public void settingObjectField(PersistenceCapable pc, int idx, Object cur,\n-        Object next, int set) {\n-        accessingField(idx);\n-        if (cur == next || !_loaded.get(idx))\n-            return;\n-        lock();\n-        try {\n-            _dirty.set(idx);\n-            objval = next;\n-            pc.pcReplaceField(idx);\n-        } finally {\n-            unlock();\n-            objval = null;\n-        }\n-    }\n-\n-    public void providedBooleanField(PersistenceCapable pc, int idx,\n-        boolean cur) {\n-        longval = cur ? 1 : 0;\n-    }\n-\n-    public void providedCharField(PersistenceCapable pc, int idx, char cur) {\n-        longval = cur;\n-    }\n-\n-    public void providedByteField(PersistenceCapable pc, int idx, byte cur) {\n-        longval = cur;\n-    }\n-\n-    public void providedShortField(PersistenceCapable pc, int idx, short cur) {\n-        longval = cur;\n-    }\n-\n-    public void providedIntField(PersistenceCapable pc, int idx, int cur) {\n-        longval = cur;\n-    }\n-\n-    public void providedLongField(PersistenceCapable pc, int idx, long cur) {\n-        longval = cur;\n-    }\n-\n-    public void providedFloatField(PersistenceCapable pc, int idx, float cur) {\n-        dblval = cur;\n-    }\n-\n-    public void providedDoubleField(PersistenceCapable pc, int idx,\n-        double cur) {\n-        dblval = cur;\n-    }\n-\n-    public void providedStringField(PersistenceCapable pc, int idx,\n-        String cur) {\n-        objval = cur;\n-    }\n-\n-    public void providedObjectField(PersistenceCapable pc, int idx,\n-        Object cur) {\n-        objval = cur;\n-    }\n-\n-    public boolean replaceBooleanField(PersistenceCapable pc, int idx) {\n-        return longval == 1;\n-    }\n-\n-    public char replaceCharField(PersistenceCapable pc, int idx) {\n-        return (char) longval;\n-    }\n-\n-    public byte replaceByteField(PersistenceCapable pc, int idx) {\n-        return (byte) longval;\n-    }\n-\n-    public short replaceShortField(PersistenceCapable pc, int idx) {\n-        return (short) longval;\n-    }\n-\n-    public int replaceIntField(PersistenceCapable pc, int idx) {\n-        return (int) longval;\n-    }\n-\n-    public long replaceLongField(PersistenceCapable pc, int idx) {\n-        return longval;\n-    }\n-\n-    public float replaceFloatField(PersistenceCapable pc, int idx) {\n-        return (float) dblval;\n-    }\n-\n-    public double replaceDoubleField(PersistenceCapable pc, int idx) {\n-        return dblval;\n-    }\n-\n-    public String replaceStringField(PersistenceCapable pc, int idx) {\n-        String str = (String) objval;\n-        objval = null;\n-        return str;\n-    }\n-\n-    public Object replaceObjectField(PersistenceCapable pc, int idx) {\n-        Object ret = objval;\n-        objval = null;\n-        return ret;\n-    }\n-\n-    //////////////////////////////////////\n-    // OpenJPAStateManager implementation\n-    //////////////////////////////////////\n-\n-    public void initialize(Class forType, PCState state) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void load(FetchConfiguration fetch) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public Object getManagedInstance() {\n-        return _pc;\n-    }\n-\n-    public PersistenceCapable getPersistenceCapable() {\n-        return _pc;\n-    }\n-\n-    public ClassMetaData getMetaData() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public OpenJPAStateManager getOwner() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public int getOwnerIndex() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public boolean isEmbedded() {\n-        return _embedded;\n-    }\n-\n-    public boolean isFlushed() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public boolean isFlushedDirty() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public boolean isProvisional() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public BitSet getLoaded() {\n-        return _loaded;\n-    }\n-\n-    public BitSet getDirty() {\n-        return _dirty;\n-    }\n-\n-    public BitSet getFlushed() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public BitSet getUnloaded(FetchConfiguration fetch) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public Object newProxy(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public Object newFieldProxy(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public boolean isDefaultValue(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public StoreContext getContext() {\n-        return null;\n-    }\n-\n-    public PCState getPCState() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public Object getObjectId() {\n-        return _oid;\n-    }\n-\n-    public void setObjectId(Object oid) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public boolean assignObjectId(boolean flush) {\n-        return true;\n-    }\n-\n-    public Object getId() {\n-        return getObjectId();\n-    }\n-\n-    public Object getLock() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void setLock(Object lock) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void setNextVersion(Object version) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public Object getImplData() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public Object setImplData(Object data, boolean cacheable) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public boolean isImplDataCacheable() {\n-        return false;\n-    }\n-\n-    public Object getImplData(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public Object setImplData(int field, Object data) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public boolean isImplDataCacheable(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public Object getIntermediate(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void setIntermediate(int field, Object data) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void removed(int field, Object removed, boolean key) {\n-        dirty(field);\n-    }\n-\n-    public boolean beforeRefresh(boolean all) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void dirty(int field) {\n-        lock();\n-        try {\n-            _dirty.set(field);\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    public void storeBoolean(int field, boolean extVal) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void storeByte(int field, byte extVal) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void storeChar(int field, char extVal) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void storeInt(int field, int extVal) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void storeShort(int field, short extVal) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void storeLong(int field, long extVal) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void storeFloat(int field, float extVal) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void storeDouble(int field, double extVal) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void storeString(int field, String extVal) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void storeObject(int field, Object extVal) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void store(int field, Object extVal) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void storeField(int field, Object value) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public boolean fetchBoolean(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public byte fetchByte(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public char fetchChar(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public short fetchShort(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public int fetchInt(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public long fetchLong(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public float fetchFloat(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public double fetchDouble(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public String fetchString(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public Object fetchObject(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public Object fetch(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public Object fetchField(int field, boolean transitions) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public Object fetchInitialField(int field) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void setRemote(int field, Object value) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void lock() {\n-        if (_lock != null)\n-            _lock.lock();\n-    }\n-\n-    public void unlock() {\n-        if (_lock != null)\n-            _lock.unlock();\n-    }\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.ObjectOutput;\r\n+import java.io.Serializable;\r\n+import java.util.BitSet;\r\n+import java.util.Collection;\r\n+import java.util.Map;\r\n+\r\n+import org.apache.openjpa.enhance.PersistenceCapable;\r\n+import org.apache.openjpa.enhance.StateManager;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import java.util.concurrent.locks.ReentrantLock;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.meta.ValueMetaData;\r\n+import org.apache.openjpa.util.Exceptions;\r\n+import org.apache.openjpa.util.Proxy;\r\n+import org.apache.openjpa.util.UnsupportedException;\r\n+import org.apache.openjpa.util.ImplHelper;\r\n+\r\n+/**\r\n+ * Internal state manager for detached instances. Does not fully\r\n+ * implement {@link OpenJPAStateManager} contract to allow for serialization.\r\n+ *\r\n+ * @author Steve Kim\r\n+ * @nojavadoc\r\n+ */\r\n+public class DetachedStateManager\r\n+    extends AttachStrategy\r\n+    implements OpenJPAStateManager, Serializable {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (DetachedStateManager.class);\r\n+\r\n+    private final PersistenceCapable _pc;\r\n+    private final boolean _embedded;\r\n+    private final boolean _access;\r\n+    private final BitSet _loaded;\r\n+    private final BitSet _dirty;\r\n+    private final Object _oid;\r\n+    private final Object _version;\r\n+    private final ReentrantLock _lock;\r\n+\r\n+    /**\r\n+     * Constructor.\r\n+     *\r\n+     * @param pc the managed instance\r\n+     * @param sm the instance's state manager\r\n+     * @param load the set of detached field indexes\r\n+     * @param access whether to allow access to unloaded fields\r\n+     * @param multithreaded whether the instance will be used concurrently\r\n+     * by multiple threads\r\n+     */\r\n+    public DetachedStateManager(PersistenceCapable pc, OpenJPAStateManager sm,\r\n+        BitSet load, boolean access, boolean multithreaded) {\r\n+        _pc = pc;\r\n+        _embedded = sm.isEmbedded();\r\n+        _loaded = load;\r\n+        _access = access;\r\n+        _dirty = new BitSet(_loaded.length());\r\n+        _oid = sm.fetchObjectId();\r\n+        _version = sm.getVersion();\r\n+        if (multithreaded)\r\n+            _lock = new ReentrantLock();\r\n+        else\r\n+            _lock = null;\r\n+    }\r\n+\r\n+    /////////////////////////////////\r\n+    // AttachStrategy implementation\r\n+    /////////////////////////////////\r\n+\r\n+    public Object attach(AttachManager manager, Object toAttach,\r\n+        ClassMetaData meta, PersistenceCapable into, OpenJPAStateManager owner,\r\n+        ValueMetaData ownerMeta, boolean explicit) {\r\n+        BrokerImpl broker = manager.getBroker();\r\n+        StateManagerImpl sm;\r\n+        if (_embedded) {\r\n+            if (_dirty.length () > 0)\r\n+                owner.dirty(ownerMeta.getFieldMetaData().getIndex());\r\n+            sm = (StateManagerImpl) broker.embed(_pc, _oid, owner, ownerMeta);\r\n+            ImplHelper.toPersistenceCapable(toAttach, broker.getConfiguration())\r\n+                .pcReplaceStateManager(this);\r\n+        } else {\r\n+            PCState state = (_dirty.length() > 0) ? PCState.PDIRTY\r\n+                : PCState.PCLEAN;\r\n+            sm = (StateManagerImpl) broker.copy(this, state);\r\n+        }\r\n+        PersistenceCapable pc = sm.getPersistenceCapable();\r\n+        manager.setAttachedCopy(toAttach, pc);\r\n+\r\n+        manager.fireBeforeAttach(toAttach, meta);\r\n+\r\n+        // pre-load for efficiency: current field values for restore, dependent\r\n+        // for delete\r\n+        FieldMetaData[] fields = meta.getFields();\r\n+        int restore = broker.getRestoreState();\r\n+        if (_dirty.length() > 0) {\r\n+            BitSet load = new BitSet(fields.length);\r\n+            for (int i = 0; i < fields.length; i++) {\r\n+                if (!_dirty.get(i))\r\n+                    continue;\r\n+\r\n+                switch (fields[i].getDeclaredTypeCode()) {\r\n+                    case JavaTypes.ARRAY:\r\n+                    case JavaTypes.COLLECTION:\r\n+                        if (restore == RestoreState.RESTORE_ALL\r\n+                            || fields[i].getElement().getCascadeDelete()\r\n+                            == ValueMetaData.CASCADE_AUTO)\r\n+                            load.set(i);\r\n+                        break;\r\n+                    case JavaTypes.MAP:\r\n+                        if (restore == RestoreState.RESTORE_ALL\r\n+                            || fields[i].getElement().getCascadeDelete()\r\n+                            == ValueMetaData.CASCADE_AUTO\r\n+                            || fields[i].getKey().getCascadeDelete()\r\n+                            == ValueMetaData.CASCADE_AUTO)\r\n+                            load.set(i);\r\n+                        break;\r\n+                    default:\r\n+                        if (restore != RestoreState.RESTORE_NONE\r\n+                            || fields[i].getCascadeDelete()\r\n+                            == ValueMetaData.CASCADE_AUTO)\r\n+                            load.set(i);\r\n+                }\r\n+            }\r\n+            FetchConfiguration fc = broker.getFetchConfiguration();\r\n+            sm.loadFields(load, fc, fc.getWriteLockLevel(), null);\r\n+        }        \r\n+        Object origVersion = sm.getVersion();\r\n+        sm.setVersion(_version);\r\n+\r\n+        BitSet loaded = sm.getLoaded();\r\n+        int set = StateManager.SET_ATTACH;\r\n+        for (int i = 0; i < fields.length; i++) {\r\n+            if (!_loaded.get(i))\r\n+                continue;\r\n+            // don't reload already loaded non-mutable objects\r\n+            if (!_dirty.get(i) && loaded.get(i) && ignoreLoaded(fields[i]))\r\n+                continue;\r\n+\r\n+            provideField(i);\r\n+            switch (fields[i].getDeclaredTypeCode()) {\r\n+                case JavaTypes.BOOLEAN:\r\n+                    if (_dirty.get(i))\r\n+                        sm.settingBooleanField(pc, i,\r\n+                            (loaded.get(i)) && sm.fetchBooleanField(i),\r\n+                            longval == 1, set);\r\n+                    else\r\n+                        sm.storeBooleanField(i, longval == 1);\r\n+                    break;\r\n+                case JavaTypes.BYTE:\r\n+                    if (_dirty.get(i))\r\n+                        sm.settingByteField(pc, i, (!loaded.get(i)) ? (byte) 0\r\n+                            : sm.fetchByteField(i), (byte) longval, set);\r\n+                    else\r\n+                        sm.storeByteField(i, (byte) longval);\r\n+                    break;\r\n+                case JavaTypes.CHAR:\r\n+                    if (_dirty.get(i))\r\n+                        sm.settingCharField(pc, i, (!loaded.get(i)) ? (char) 0\r\n+                            : sm.fetchCharField(i), (char) longval, set);\r\n+                    else\r\n+                        sm.storeCharField(i, (char) longval);\r\n+                    break;\r\n+                case JavaTypes.INT:\r\n+                    if (_dirty.get(i))\r\n+                        sm.settingIntField(pc, i, (!loaded.get(i)) ? 0\r\n+                            : sm.fetchIntField(i), (int) longval, set);\r\n+                    else\r\n+                        sm.storeIntField(i, (int) longval);\r\n+                    break;\r\n+                case JavaTypes.LONG:\r\n+                    if (_dirty.get(i))\r\n+                        sm.settingLongField(pc, i, (!loaded.get(i)) ? 0L\r\n+                            : sm.fetchLongField(i), longval, set);\r\n+                    else\r\n+                        sm.storeLongField(i, longval);\r\n+                    break;\r\n+                case JavaTypes.SHORT:\r\n+                    if (_dirty.get(i))\r\n+                        sm.settingShortField(pc, i, (!loaded.get(i)) ? (short) 0\r\n+                            : sm.fetchShortField(i), (short) longval, set);\r\n+                    else\r\n+                        sm.storeShortField(i, (short) longval);\r\n+                    break;\r\n+                case JavaTypes.FLOAT:\r\n+                    if (_dirty.get(i))\r\n+                        sm.settingFloatField(pc, i, (!loaded.get(i)) ? 0F\r\n+                            : sm.fetchFloatField(i), (float) dblval, set);\r\n+                    else\r\n+                        sm.storeFloatField(i, (float) dblval);\r\n+                    break;\r\n+                case JavaTypes.DOUBLE:\r\n+                    if (_dirty.get(i))\r\n+                        sm.settingDoubleField(pc, i, (!loaded.get(i)) ? 0D\r\n+                            : sm.fetchDoubleField(i), dblval, set);\r\n+                    else\r\n+                        sm.storeDoubleField(i, dblval);\r\n+                    break;\r\n+                case JavaTypes.STRING:\r\n+                    if (_dirty.get(i))\r\n+                        sm.settingStringField(pc, i, (!loaded.get(i)) ? null\r\n+                            : sm.fetchStringField(i), (String) objval, set);\r\n+                    else\r\n+                        sm.storeStringField(i, (String) objval);\r\n+                    objval = null;\r\n+                    break;\r\n+                case JavaTypes.PC:\r\n+                case JavaTypes.PC_UNTYPED:\r\n+                    if (fields[i].getCascadeAttach() == ValueMetaData\r\n+                        .CASCADE_NONE)\r\n+                        objval = getReference(manager, objval, sm, fields[i]);\r\n+                    else {\r\n+                        PersistenceCapable toPC = null;\r\n+                        if (objval != null && fields[i].isEmbeddedPC())\r\n+                            toPC = ImplHelper.toPersistenceCapable(objval,\r\n+                                broker.getConfiguration());\r\n+                        objval = manager.attach(objval, toPC, sm, fields[i],\r\n+                            false);\r\n+                    }\r\n+                    if (_dirty.get(i))\r\n+                        sm.settingObjectField(pc, i, (!loaded.get(i)) ? null\r\n+                            : sm.fetchObjectField(i), objval, set);\r\n+                    else\r\n+                        sm.storeObjectField(i, objval);\r\n+                    objval = null;\r\n+                    break;\r\n+                case JavaTypes.COLLECTION:\r\n+                    Collection coll = (Collection) objval;\r\n+                    objval = null;\r\n+                    if (coll != null)\r\n+                        coll = attachCollection(manager, coll, sm, fields[i]);\r\n+                    if (_dirty.get(i))\r\n+                        sm.settingObjectField(pc, i, (!loaded.get(i)) ? null\r\n+                            : sm.fetchObjectField(i), coll, set);\r\n+                    else\r\n+                        sm.storeObjectField(i, coll);\r\n+                    break;\r\n+                case JavaTypes.MAP:\r\n+                    Map map = (Map) objval;\r\n+                    objval = null;\r\n+                    if (map != null)\r\n+                        map = attachMap(manager, map, sm, fields[i]);\r\n+                    if (_dirty.get(i))\r\n+                        sm.settingObjectField(pc, i, (!loaded.get(i)) ? null\r\n+                            : sm.fetchObjectField(i), map, set);\r\n+                    else\r\n+                        sm.storeObjectField(i, map);\r\n+                    break;\r\n+                default:\r\n+                    if (_dirty.get(i))\r\n+                        sm.settingObjectField(pc, i, (!loaded.get(i)) ? null\r\n+                            : sm.fetchObjectField(i), objval, set);\r\n+                    else\r\n+                        sm.storeObjectField(i, objval);\r\n+                    objval = null;\r\n+            }\r\n+        }\r\n+        pc.pcReplaceStateManager(sm);\r\n+\r\n+        // if we were clean at least make sure a version check is done to\r\n+        // prevent using old state\r\n+        if (!sm.isVersionCheckRequired() && broker.isActive()\r\n+            && _version != origVersion && (origVersion == null \r\n+            || broker.getStoreManager().compareVersion(sm, _version, \r\n+            origVersion) != StoreManager.VERSION_SAME)) {\r\n+            broker.transactional(sm.getManagedInstance(), false, \r\n+                manager.getBehavior());\r\n+        }\r\n+\r\n+        return sm.getManagedInstance();\r\n+    }\r\n+\r\n+    protected Object getDetachedObjectId(AttachManager manager,\r\n+        Object toAttach) {\r\n+        return _oid;\r\n+    }\r\n+\r\n+    void provideField(int field) {\r\n+        _pc.pcProvideField(field);\r\n+    }\r\n+\r\n+    protected void provideField(Object toAttach, StateManagerImpl sm,\r\n+        int field) {\r\n+        provideField(field);\r\n+    }\r\n+\r\n+    /**\r\n+     * Ignore if the field is not dirty but loaded\r\n+     */\r\n+    protected static boolean ignoreLoaded(FieldMetaData fmd) {\r\n+        switch (fmd.getTypeCode()) {\r\n+            case JavaTypes.BOOLEAN:\r\n+            case JavaTypes.BOOLEAN_OBJ:\r\n+            case JavaTypes.BYTE:\r\n+            case JavaTypes.BYTE_OBJ:\r\n+            case JavaTypes.INT:\r\n+            case JavaTypes.INT_OBJ:\r\n+            case JavaTypes.LONG:\r\n+            case JavaTypes.LONG_OBJ:\r\n+            case JavaTypes.SHORT:\r\n+            case JavaTypes.SHORT_OBJ:\r\n+            case JavaTypes.DOUBLE:\r\n+            case JavaTypes.DOUBLE_OBJ:\r\n+            case JavaTypes.FLOAT:\r\n+            case JavaTypes.FLOAT_OBJ:\r\n+            case JavaTypes.CHAR:\r\n+            case JavaTypes.CHAR_OBJ:\r\n+            case JavaTypes.STRING:\r\n+                return true;\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    ///////////////////////////////\r\n+    // StateManager implementation\r\n+    ///////////////////////////////\r\n+\r\n+    public Object getGenericContext() {\r\n+        return null;\r\n+    }\r\n+\r\n+    public Object getPCPrimaryKey(Object oid, int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public StateManager replaceStateManager(StateManager sm) {\r\n+        return sm;\r\n+    }\r\n+\r\n+    public Object getVersion() {\r\n+        return _version;\r\n+    }\r\n+\r\n+    public void setVersion(Object version) {\r\n+        throw new UnsupportedException();\r\n+    }\r\n+\r\n+    public boolean isDirty() {\r\n+        return _dirty.length() != 0;\r\n+    }\r\n+\r\n+    public boolean isTransactional() {\r\n+        return false;\r\n+    }\r\n+\r\n+    public boolean isPersistent() {\r\n+        return false;\r\n+    }\r\n+\r\n+    public boolean isNew() {\r\n+        return false;\r\n+    }\r\n+\r\n+    public boolean isDeleted() {\r\n+        return false;\r\n+    }\r\n+\r\n+    public boolean isDetached() {\r\n+        return true;\r\n+    }\r\n+\r\n+    public boolean isVersionUpdateRequired() {\r\n+        return false;\r\n+    }\r\n+\r\n+    public boolean isVersionCheckRequired() {\r\n+        return false;\r\n+    }\r\n+\r\n+    public void dirty(String field) {\r\n+        // should we store ClassMetaData?\r\n+        throw new UnsupportedException();\r\n+    }\r\n+\r\n+    public Object fetchObjectId() {\r\n+        return _oid;\r\n+    }\r\n+\r\n+    public void accessingField(int idx) {\r\n+        if (!_access && !_loaded.get(idx))\r\n+        \t// do not access the pc fields by implictly invoking _pc.toString()\r\n+        \t// may cause infinite loop if again tries to access unloaded field \r\n+            throw new IllegalStateException(_loc.get(\"unloaded-detached\",\r\n+               Exceptions.toString(_pc)).getMessage());\r\n+    }\r\n+\r\n+    public boolean serializing() {\r\n+        return false;\r\n+    }\r\n+\r\n+    public boolean writeDetached(ObjectOutput out)\r\n+        throws IOException {\r\n+        out.writeObject(_pc.pcGetDetachedState());\r\n+        out.writeObject(this);\r\n+        return false;\r\n+    }\r\n+\r\n+    public void proxyDetachedDeserialized(int idx) {\r\n+        lock();\r\n+        try {\r\n+            _pc.pcProvideField(idx);\r\n+            if (objval instanceof Proxy)\r\n+                ((Proxy) objval).setOwner(this, idx);\r\n+            objval = null;\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void settingBooleanField(PersistenceCapable pc, int idx,\r\n+        boolean cur, boolean next, int set) {\r\n+        accessingField(idx);\r\n+        if (cur == next || !_loaded.get(idx))\r\n+            return;\r\n+        lock();\r\n+        try {\r\n+            _dirty.set(idx);\r\n+            longval = next ? 1 : 0;\r\n+            pc.pcReplaceField(idx);\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void settingCharField(PersistenceCapable pc, int idx, char cur,\r\n+        char next, int set) {\r\n+        accessingField(idx);\r\n+        if (cur == next || !_loaded.get(idx))\r\n+            return;\r\n+        lock();\r\n+        try {\r\n+            _dirty.set(idx);\r\n+            longval = next;\r\n+            pc.pcReplaceField(idx);\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void settingByteField(PersistenceCapable pc, int idx, byte cur,\r\n+        byte next, int set) {\r\n+        accessingField(idx);\r\n+        if (cur == next || !_loaded.get(idx))\r\n+            return;\r\n+        lock();\r\n+        try {\r\n+            _dirty.set(idx);\r\n+            longval = next;\r\n+            pc.pcReplaceField(idx);\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void settingShortField(PersistenceCapable pc, int idx, short cur,\r\n+        short next, int set) {\r\n+        accessingField(idx);\r\n+        if (cur == next || !_loaded.get(idx))\r\n+            return;\r\n+        lock();\r\n+        try {\r\n+            _dirty.set(idx);\r\n+            longval = next;\r\n+            pc.pcReplaceField(idx);\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void settingIntField(PersistenceCapable pc, int idx, int cur,\r\n+        int next, int set) {\r\n+        accessingField(idx);\r\n+        if (cur == next || !_loaded.get(idx))\r\n+            return;\r\n+        lock();\r\n+        try {\r\n+            _dirty.set(idx);\r\n+            longval = next;\r\n+            pc.pcReplaceField(idx);\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void settingLongField(PersistenceCapable pc, int idx, long cur,\r\n+        long next, int set) {\r\n+        accessingField(idx);\r\n+        if (cur == next || !_loaded.get(idx))\r\n+            return;\r\n+        lock();\r\n+        try {\r\n+            _dirty.set(idx);\r\n+            longval = next;\r\n+            pc.pcReplaceField(idx);\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void settingFloatField(PersistenceCapable pc, int idx, float cur,\r\n+        float next, int set) {\r\n+        accessingField(idx);\r\n+        if (cur == next || !_loaded.get(idx))\r\n+            return;\r\n+        lock();\r\n+        try {\r\n+            _dirty.set(idx);\r\n+            dblval = next;\r\n+            pc.pcReplaceField(idx);\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void settingDoubleField(PersistenceCapable pc, int idx, double cur,\r\n+        double next, int set) {\r\n+        accessingField(idx);\r\n+        if (cur == next || !_loaded.get(idx))\r\n+            return;\r\n+        lock();\r\n+        try {\r\n+            _dirty.set(idx);\r\n+            dblval = next;\r\n+            pc.pcReplaceField(idx);\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void settingStringField(PersistenceCapable pc, int idx, String cur,\r\n+        String next, int set) {\r\n+        accessingField(idx);\r\n+        if (cur == next || (cur != null && cur.equals(next))\r\n+                || !_loaded.get(idx))\r\n+            return;\r\n+        lock();\r\n+        try {\r\n+            _dirty.set(idx);\r\n+            objval = next;\r\n+            pc.pcReplaceField(idx);\r\n+        } finally {\r\n+            unlock();\r\n+            objval = null;\r\n+        }\r\n+    }\r\n+\r\n+    public void settingObjectField(PersistenceCapable pc, int idx, Object cur,\r\n+        Object next, int set) {\r\n+        accessingField(idx);\r\n+        if (cur == next || !_loaded.get(idx))\r\n+            return;\r\n+        lock();\r\n+        try {\r\n+            _dirty.set(idx);\r\n+            objval = next;\r\n+            pc.pcReplaceField(idx);\r\n+        } finally {\r\n+            unlock();\r\n+            objval = null;\r\n+        }\r\n+    }\r\n+\r\n+    public void providedBooleanField(PersistenceCapable pc, int idx,\r\n+        boolean cur) {\r\n+        longval = cur ? 1 : 0;\r\n+    }\r\n+\r\n+    public void providedCharField(PersistenceCapable pc, int idx, char cur) {\r\n+        longval = cur;\r\n+    }\r\n+\r\n+    public void providedByteField(PersistenceCapable pc, int idx, byte cur) {\r\n+        longval = cur;\r\n+    }\r\n+\r\n+    public void providedShortField(PersistenceCapable pc, int idx, short cur) {\r\n+        longval = cur;\r\n+    }\r\n+\r\n+    public void providedIntField(PersistenceCapable pc, int idx, int cur) {\r\n+        longval = cur;\r\n+    }\r\n+\r\n+    public void providedLongField(PersistenceCapable pc, int idx, long cur) {\r\n+        longval = cur;\r\n+    }\r\n+\r\n+    public void providedFloatField(PersistenceCapable pc, int idx, float cur) {\r\n+        dblval = cur;\r\n+    }\r\n+\r\n+    public void providedDoubleField(PersistenceCapable pc, int idx,\r\n+        double cur) {\r\n+        dblval = cur;\r\n+    }\r\n+\r\n+    public void providedStringField(PersistenceCapable pc, int idx,\r\n+        String cur) {\r\n+        objval = cur;\r\n+    }\r\n+\r\n+    public void providedObjectField(PersistenceCapable pc, int idx,\r\n+        Object cur) {\r\n+        objval = cur;\r\n+    }\r\n+\r\n+    public boolean replaceBooleanField(PersistenceCapable pc, int idx) {\r\n+        return longval == 1;\r\n+    }\r\n+\r\n+    public char replaceCharField(PersistenceCapable pc, int idx) {\r\n+        return (char) longval;\r\n+    }\r\n+\r\n+    public byte replaceByteField(PersistenceCapable pc, int idx) {\r\n+        return (byte) longval;\r\n+    }\r\n+\r\n+    public short replaceShortField(PersistenceCapable pc, int idx) {\r\n+        return (short) longval;\r\n+    }\r\n+\r\n+    public int replaceIntField(PersistenceCapable pc, int idx) {\r\n+        return (int) longval;\r\n+    }\r\n+\r\n+    public long replaceLongField(PersistenceCapable pc, int idx) {\r\n+        return longval;\r\n+    }\r\n+\r\n+    public float replaceFloatField(PersistenceCapable pc, int idx) {\r\n+        return (float) dblval;\r\n+    }\r\n+\r\n+    public double replaceDoubleField(PersistenceCapable pc, int idx) {\r\n+        return dblval;\r\n+    }\r\n+\r\n+    public String replaceStringField(PersistenceCapable pc, int idx) {\r\n+        String str = (String) objval;\r\n+        objval = null;\r\n+        return str;\r\n+    }\r\n+\r\n+    public Object replaceObjectField(PersistenceCapable pc, int idx) {\r\n+        Object ret = objval;\r\n+        objval = null;\r\n+        return ret;\r\n+    }\r\n+\r\n+    //////////////////////////////////////\r\n+    // OpenJPAStateManager implementation\r\n+    //////////////////////////////////////\r\n+\r\n+    public void initialize(Class forType, PCState state) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void load(FetchConfiguration fetch) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public Object getManagedInstance() {\r\n+        return _pc;\r\n+    }\r\n+\r\n+    public PersistenceCapable getPersistenceCapable() {\r\n+        return _pc;\r\n+    }\r\n+\r\n+    public ClassMetaData getMetaData() {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public OpenJPAStateManager getOwner() {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public int getOwnerIndex() {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public boolean isEmbedded() {\r\n+        return _embedded;\r\n+    }\r\n+\r\n+    public boolean isFlushed() {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public boolean isFlushedDirty() {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public boolean isProvisional() {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public BitSet getLoaded() {\r\n+        return _loaded;\r\n+    }\r\n+\r\n+    public BitSet getDirty() {\r\n+        return _dirty;\r\n+    }\r\n+\r\n+    public BitSet getFlushed() {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public BitSet getUnloaded(FetchConfiguration fetch) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public Object newProxy(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public Object newFieldProxy(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public boolean isDefaultValue(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public StoreContext getContext() {\r\n+        return null;\r\n+    }\r\n+\r\n+    public PCState getPCState() {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public Object getObjectId() {\r\n+        return _oid;\r\n+    }\r\n+\r\n+    public void setObjectId(Object oid) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public boolean assignObjectId(boolean flush) {\r\n+        return true;\r\n+    }\r\n+\r\n+    public Object getId() {\r\n+        return getObjectId();\r\n+    }\r\n+\r\n+    public Object getLock() {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void setLock(Object lock) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void setNextVersion(Object version) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public Object getImplData() {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public Object setImplData(Object data, boolean cacheable) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public boolean isImplDataCacheable() {\r\n+        return false;\r\n+    }\r\n+\r\n+    public Object getImplData(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public Object setImplData(int field, Object data) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public boolean isImplDataCacheable(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public Object getIntermediate(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void setIntermediate(int field, Object data) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void removed(int field, Object removed, boolean key) {\r\n+        dirty(field);\r\n+    }\r\n+\r\n+    public boolean beforeRefresh(boolean all) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void dirty(int field) {\r\n+        lock();\r\n+        try {\r\n+            _dirty.set(field);\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void storeBoolean(int field, boolean extVal) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void storeByte(int field, byte extVal) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void storeChar(int field, char extVal) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void storeInt(int field, int extVal) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void storeShort(int field, short extVal) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void storeLong(int field, long extVal) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void storeFloat(int field, float extVal) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void storeDouble(int field, double extVal) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void storeString(int field, String extVal) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void storeObject(int field, Object extVal) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void store(int field, Object extVal) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void storeField(int field, Object value) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public boolean fetchBoolean(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public byte fetchByte(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public char fetchChar(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public short fetchShort(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public int fetchInt(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public long fetchLong(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public float fetchFloat(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public double fetchDouble(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public String fetchString(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public Object fetchObject(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public Object fetch(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public Object fetchField(int field, boolean transitions) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public Object fetchInitialField(int field) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void setRemote(int field, Object value) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    public void lock() {\r\n+        if (_lock != null)\r\n+            _lock.lock();\r\n+    }\r\n+\r\n+    public void unlock() {\r\n+        if (_lock != null)\r\n+            _lock.unlock();\r\n+    }\r\n+}\r"},{"sha":"dd7a8a759847ad0cc42c218b96d791ef01cfcd3f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","status":"modified","additions":353,"deletions":353,"changes":706,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,353 +1,353 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.kernel;\n-\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.NoSuchElementException;\n-\n-import org.apache.commons.collections.Predicate;\n-import org.apache.commons.collections.iterators.FilterIterator;\n-import org.apache.commons.collections.iterators.IteratorChain;\n-import org.apache.openjpa.lib.rop.ResultObjectProvider;\n-import org.apache.openjpa.lib.rop.ResultObjectProviderIterator;\n-import org.apache.openjpa.lib.util.Closeable;\n-import org.apache.openjpa.lib.util.ReferenceHashSet;\n-import org.apache.openjpa.lib.util.concurrent.ReentrantLock;\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.meta.MetaDataRepository;\n-import org.apache.openjpa.util.GeneralException;\n-import org.apache.openjpa.util.ImplHelper;\n-import org.apache.openjpa.util.OpenJPAException;\n-\n-/**\n- * Representation of all members of a persistent class.\n- *\n- * @author Abe White\n- * @author Patrick Linskey\n- * @nojavadoc\n- */\n-public class ExtentImpl\n-    implements Extent {\n-\n-    private static final ClassMetaData[] EMPTY_METAS = new ClassMetaData[0];\n-\n-    private final Broker _broker;\n-    private final Class _type;\n-    private final boolean _subs;\n-    private final FetchConfiguration _fc;\n-    private final ReentrantLock _lock;\n-    private boolean _ignore = false;\n-\n-    // set of open iterators\n-    private ReferenceHashSet _openItrs = null;\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param broker the owning broker\n-     * @param type the candidate class\n-     * @param subs whether subclasses are included in the extent\n-     */\n-    ExtentImpl(Broker broker, Class type, boolean subs,\n-        FetchConfiguration fetch) {\n-        _broker = broker;\n-        _type = type;\n-        _subs = subs;\n-        if (fetch != null)\n-            _fc = fetch;\n-        else\n-            _fc = (FetchConfiguration) broker.getFetchConfiguration().clone();\n-        _ignore = broker.getIgnoreChanges();\n-        if (broker.getMultithreaded())\n-            _lock = new ReentrantLock();\n-        else\n-            _lock = null;\n-    }\n-\n-    public FetchConfiguration getFetchConfiguration() {\n-        return _fc;\n-    }\n-\n-    public boolean getIgnoreChanges() {\n-        return _ignore;\n-    }\n-\n-    public void setIgnoreChanges(boolean ignoreChanges) {\n-        _broker.assertOpen();\n-        _ignore = ignoreChanges;\n-    }\n-\n-    public List list() {\n-        List list = new ArrayList();\n-        Iterator itr = iterator();\n-        try {\n-            while (itr.hasNext())\n-                list.add(itr.next());\n-            return list;\n-        } finally {\n-            ImplHelper.close(itr);\n-        }\n-    }\n-\n-    public Iterator iterator() {\n-        _broker.assertNontransactionalRead();\n-        CloseableIterator citr = null;\n-        try {\n-            // create an iterator chain; add pnew objects if transactional\n-            CloseableIteratorChain chain = new CloseableIteratorChain();\n-            boolean trans = !_ignore && _broker.isActive();\n-            if (trans)\n-                chain.addIterator(new FilterNewIterator());\n-\n-            // add database iterators for each implementing class\n-            MetaDataRepository repos = _broker.getConfiguration().\n-                getMetaDataRepositoryInstance();\n-            ClassMetaData meta = repos.getMetaData(_type,\n-                _broker.getClassLoader(), false);\n-\n-            ClassMetaData[] metas;\n-            if (meta != null && (!_subs || !meta.isManagedInterface())\n-                && (meta.isMapped() || (_subs\n-                && meta.getMappedPCSubclassMetaDatas().length > 0)))\n-                metas = new ClassMetaData[]{ meta };\n-            else if (_subs && (meta == null || meta.isManagedInterface()))\n-                metas = repos.getImplementorMetaDatas(_type,\n-                    _broker.getClassLoader(), false);\n-            else\n-                metas = EMPTY_METAS;\n-\n-            ResultObjectProvider rop;\n-            for (int i = 0; i < metas.length; i++) {\n-                rop = _broker.getStoreManager().executeExtent(metas[i],\n-                    _subs, _fc);\n-                if (rop != null)\n-                    chain.addIterator(new ResultObjectProviderIterator(rop));\n-            }\n-\n-            // filter deleted objects if transactional\n-            if (trans)\n-                citr = new FilterDeletedIterator(chain);\n-            else\n-                citr = chain;\n-            citr.setRemoveOnClose(this);\n-        } catch (OpenJPAException ke) {\n-            throw ke;\n-        } catch (RuntimeException re) {\n-            throw new GeneralException(re);\n-        }\n-\n-        lock();\n-        try {\n-            if (_openItrs == null)\n-                _openItrs = new ReferenceHashSet(ReferenceHashSet.WEAK);\n-            _openItrs.add(citr);\n-        } finally {\n-            unlock();\n-        }\n-        return citr;\n-    }\n-\n-    public Broker getBroker() {\n-        return _broker;\n-    }\n-\n-    public Class getElementType() {\n-        return _type;\n-    }\n-\n-    public boolean hasSubclasses() {\n-        return _subs;\n-    }\n-\n-    public void closeAll() {\n-        if (_openItrs == null)\n-            return;\n-\n-        lock();\n-        try {\n-            CloseableIterator citr;\n-            for (Iterator itr = _openItrs.iterator(); itr.hasNext();) {\n-                citr = (CloseableIterator) itr.next();\n-                citr.setRemoveOnClose(null);\n-                try {\n-                    citr.close();\n-                } catch (Exception e) {\n-                }\n-            }\n-            _openItrs.clear();\n-        } catch (OpenJPAException ke) {\n-            throw ke;\n-        } catch (RuntimeException re) {\n-            throw new GeneralException(re);\n-        } finally {\n-            unlock();\n-        }\n-    }\n-\n-    public void lock() {\n-        if (_lock != null)\n-            _lock.lock();\n-    }\n-\n-    public void unlock() {\n-        if (_lock != null)\n-            _lock.unlock();\n-    }\n-\n-    /**\n-     * Closeable iterator.\n-     */\n-    private static interface CloseableIterator\n-        extends Closeable, Iterator {\n-\n-        /**\n-         * Set the extent to remove self from on close.\n-         */\n-        public void setRemoveOnClose(ExtentImpl extent);\n-    }\n-\n-    /**\n-     * Closeable {@link IteratorChain}.\n-     */\n-    private static class CloseableIteratorChain\n-        extends IteratorChain\n-        implements CloseableIterator {\n-\n-        private ExtentImpl _extent = null;\n-        private boolean _closed = false;\n-\n-        public boolean hasNext() {\n-            return (_closed) ? false : super.hasNext();\n-        }\n-\n-        public Object next() {\n-            if (_closed)\n-                throw new NoSuchElementException();\n-            return super.next();\n-        }\n-\n-        public void remove() {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public void setRemoveOnClose(ExtentImpl extent) {\n-            _extent = extent;\n-        }\n-\n-        public void close()\n-            throws Exception {\n-            if (_extent != null && _extent._openItrs != null) {\n-                _extent.lock();\n-                try {\n-                    _extent._openItrs.remove(this);\n-                } finally {\n-                    _extent.unlock();\n-                }\n-            }\n-\n-            _closed = true;\n-            for (Iterator itr = getIterators().iterator(); itr.hasNext();)\n-                ((Closeable) itr.next()).close();\n-        }\n-    }\n-\n-    /**\n-     * {@link FilterIterator} that skips deleted objects.\n-     */\n-    private static class FilterDeletedIterator\n-        extends FilterIterator\n-        implements CloseableIterator, Predicate {\n-\n-        private ExtentImpl _extent = null;\n-        private boolean _closed = false;\n-\n-        public FilterDeletedIterator(Iterator itr) {\n-            super(itr);\n-            setPredicate(this);\n-        }\n-\n-        public boolean hasNext() {\n-            return (_closed) ? false : super.hasNext();\n-        }\n-\n-        public Object next() {\n-            if (_closed)\n-                throw new NoSuchElementException();\n-            return super.next();\n-        }\n-\n-        public void remove() {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public void setRemoveOnClose(ExtentImpl extent) {\n-            _extent = extent;\n-        }\n-\n-        public void close()\n-            throws Exception {\n-            if (_extent != null && _extent._openItrs != null) {\n-                _extent.lock();\n-                try {\n-                    _extent._openItrs.remove(this);\n-                } finally {\n-                    _extent.unlock();\n-                }\n-            }\n-\n-            _closed = true;\n-            ((Closeable) getIterator()).close();\n-        }\n-\n-        public boolean evaluate(Object o) {\n-            return !_extent._broker.isDeleted(o);\n-        }\n-    }\n-\n-    /**\n-     * Iterator over all new objects in this extent. This iterator is always\n-     * wrapped, so it doesn't need to keep track of whether it's closed.\n-     */\n-    private class FilterNewIterator\n-        extends FilterIterator\n-        implements Closeable, Predicate {\n-\n-        public FilterNewIterator() {\n-            super(_broker.getTransactionalObjects().iterator());\n-            setPredicate(this);\n-        }\n-\n-        public void close() {\n-        }\n-\n-        public boolean evaluate(Object o) {\n-            if (!_broker.isNew(o))\n-                return false;\n-\n-            Class type = o.getClass();\n-            if (!_subs && type != _type)\n-                return false;\n-            if (_subs && !_type.isAssignableFrom(type))\n-                return false;\n-            return true;\n-\t\t}\n-\t}\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.NoSuchElementException;\r\n+\r\n+import org.apache.commons.collections.Predicate;\r\n+import org.apache.commons.collections.iterators.FilterIterator;\r\n+import org.apache.commons.collections.iterators.IteratorChain;\r\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n+import org.apache.openjpa.lib.rop.ResultObjectProviderIterator;\r\n+import org.apache.openjpa.lib.util.Closeable;\r\n+import org.apache.openjpa.lib.util.ReferenceHashSet;\r\n+import java.util.concurrent.locks.ReentrantLock;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+import org.apache.openjpa.util.GeneralException;\r\n+import org.apache.openjpa.util.ImplHelper;\r\n+import org.apache.openjpa.util.OpenJPAException;\r\n+\r\n+/**\r\n+ * Representation of all members of a persistent class.\r\n+ *\r\n+ * @author Abe White\r\n+ * @author Patrick Linskey\r\n+ * @nojavadoc\r\n+ */\r\n+public class ExtentImpl\r\n+    implements Extent {\r\n+\r\n+    private static final ClassMetaData[] EMPTY_METAS = new ClassMetaData[0];\r\n+\r\n+    private final Broker _broker;\r\n+    private final Class _type;\r\n+    private final boolean _subs;\r\n+    private final FetchConfiguration _fc;\r\n+    private final ReentrantLock _lock;\r\n+    private boolean _ignore = false;\r\n+\r\n+    // set of open iterators\r\n+    private ReferenceHashSet _openItrs = null;\r\n+\r\n+    /**\r\n+     * Constructor.\r\n+     *\r\n+     * @param broker the owning broker\r\n+     * @param type the candidate class\r\n+     * @param subs whether subclasses are included in the extent\r\n+     */\r\n+    ExtentImpl(Broker broker, Class type, boolean subs,\r\n+        FetchConfiguration fetch) {\r\n+        _broker = broker;\r\n+        _type = type;\r\n+        _subs = subs;\r\n+        if (fetch != null)\r\n+            _fc = fetch;\r\n+        else\r\n+            _fc = (FetchConfiguration) broker.getFetchConfiguration().clone();\r\n+        _ignore = broker.getIgnoreChanges();\r\n+        if (broker.getMultithreaded())\r\n+            _lock = new ReentrantLock();\r\n+        else\r\n+            _lock = null;\r\n+    }\r\n+\r\n+    public FetchConfiguration getFetchConfiguration() {\r\n+        return _fc;\r\n+    }\r\n+\r\n+    public boolean getIgnoreChanges() {\r\n+        return _ignore;\r\n+    }\r\n+\r\n+    public void setIgnoreChanges(boolean ignoreChanges) {\r\n+        _broker.assertOpen();\r\n+        _ignore = ignoreChanges;\r\n+    }\r\n+\r\n+    public List list() {\r\n+        List list = new ArrayList();\r\n+        Iterator itr = iterator();\r\n+        try {\r\n+            while (itr.hasNext())\r\n+                list.add(itr.next());\r\n+            return list;\r\n+        } finally {\r\n+            ImplHelper.close(itr);\r\n+        }\r\n+    }\r\n+\r\n+    public Iterator iterator() {\r\n+        _broker.assertNontransactionalRead();\r\n+        CloseableIterator citr = null;\r\n+        try {\r\n+            // create an iterator chain; add pnew objects if transactional\r\n+            CloseableIteratorChain chain = new CloseableIteratorChain();\r\n+            boolean trans = !_ignore && _broker.isActive();\r\n+            if (trans)\r\n+                chain.addIterator(new FilterNewIterator());\r\n+\r\n+            // add database iterators for each implementing class\r\n+            MetaDataRepository repos = _broker.getConfiguration().\r\n+                getMetaDataRepositoryInstance();\r\n+            ClassMetaData meta = repos.getMetaData(_type,\r\n+                _broker.getClassLoader(), false);\r\n+\r\n+            ClassMetaData[] metas;\r\n+            if (meta != null && (!_subs || !meta.isManagedInterface())\r\n+                && (meta.isMapped() || (_subs\r\n+                && meta.getMappedPCSubclassMetaDatas().length > 0)))\r\n+                metas = new ClassMetaData[]{ meta };\r\n+            else if (_subs && (meta == null || meta.isManagedInterface()))\r\n+                metas = repos.getImplementorMetaDatas(_type,\r\n+                    _broker.getClassLoader(), false);\r\n+            else\r\n+                metas = EMPTY_METAS;\r\n+\r\n+            ResultObjectProvider rop;\r\n+            for (int i = 0; i < metas.length; i++) {\r\n+                rop = _broker.getStoreManager().executeExtent(metas[i],\r\n+                    _subs, _fc);\r\n+                if (rop != null)\r\n+                    chain.addIterator(new ResultObjectProviderIterator(rop));\r\n+            }\r\n+\r\n+            // filter deleted objects if transactional\r\n+            if (trans)\r\n+                citr = new FilterDeletedIterator(chain);\r\n+            else\r\n+                citr = chain;\r\n+            citr.setRemoveOnClose(this);\r\n+        } catch (OpenJPAException ke) {\r\n+            throw ke;\r\n+        } catch (RuntimeException re) {\r\n+            throw new GeneralException(re);\r\n+        }\r\n+\r\n+        lock();\r\n+        try {\r\n+            if (_openItrs == null)\r\n+                _openItrs = new ReferenceHashSet(ReferenceHashSet.WEAK);\r\n+            _openItrs.add(citr);\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+        return citr;\r\n+    }\r\n+\r\n+    public Broker getBroker() {\r\n+        return _broker;\r\n+    }\r\n+\r\n+    public Class getElementType() {\r\n+        return _type;\r\n+    }\r\n+\r\n+    public boolean hasSubclasses() {\r\n+        return _subs;\r\n+    }\r\n+\r\n+    public void closeAll() {\r\n+        if (_openItrs == null)\r\n+            return;\r\n+\r\n+        lock();\r\n+        try {\r\n+            CloseableIterator citr;\r\n+            for (Iterator itr = _openItrs.iterator(); itr.hasNext();) {\r\n+                citr = (CloseableIterator) itr.next();\r\n+                citr.setRemoveOnClose(null);\r\n+                try {\r\n+                    citr.close();\r\n+                } catch (Exception e) {\r\n+                }\r\n+            }\r\n+            _openItrs.clear();\r\n+        } catch (OpenJPAException ke) {\r\n+            throw ke;\r\n+        } catch (RuntimeException re) {\r\n+            throw new GeneralException(re);\r\n+        } finally {\r\n+            unlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void lock() {\r\n+        if (_lock != null)\r\n+            _lock.lock();\r\n+    }\r\n+\r\n+    public void unlock() {\r\n+        if (_lock != null)\r\n+            _lock.unlock();\r\n+    }\r\n+\r\n+    /**\r\n+     * Closeable iterator.\r\n+     */\r\n+    private static interface CloseableIterator\r\n+        extends Closeable, Iterator {\r\n+\r\n+        /**\r\n+         * Set the extent to remove self from on close.\r\n+         */\r\n+        public void setRemoveOnClose(ExtentImpl extent);\r\n+    }\r\n+\r\n+    /**\r\n+     * Closeable {@link IteratorChain}.\r\n+     */\r\n+    private static class CloseableIteratorChain\r\n+        extends IteratorChain\r\n+        implements CloseableIterator {\r\n+\r\n+        private ExtentImpl _extent = null;\r\n+        private boolean _closed = false;\r\n+\r\n+        public boolean hasNext() {\r\n+            return (_closed) ? false : super.hasNext();\r\n+        }\r\n+\r\n+        public Object next() {\r\n+            if (_closed)\r\n+                throw new NoSuchElementException();\r\n+            return super.next();\r\n+        }\r\n+\r\n+        public void remove() {\r\n+            throw new UnsupportedOperationException();\r\n+        }\r\n+\r\n+        public void setRemoveOnClose(ExtentImpl extent) {\r\n+            _extent = extent;\r\n+        }\r\n+\r\n+        public void close()\r\n+            throws Exception {\r\n+            if (_extent != null && _extent._openItrs != null) {\r\n+                _extent.lock();\r\n+                try {\r\n+                    _extent._openItrs.remove(this);\r\n+                } finally {\r\n+                    _extent.unlock();\r\n+                }\r\n+            }\r\n+\r\n+            _closed = true;\r\n+            for (Iterator itr = getIterators().iterator(); itr.hasNext();)\r\n+                ((Closeable) itr.next()).close();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * {@link FilterIterator} that skips deleted objects.\r\n+     */\r\n+    private static class FilterDeletedIterator\r\n+        extends FilterIterator\r\n+        implements CloseableIterator, Predicate {\r\n+\r\n+        private ExtentImpl _extent = null;\r\n+        private boolean _closed = false;\r\n+\r\n+        public FilterDeletedIterator(Iterator itr) {\r\n+            super(itr);\r\n+            setPredicate(this);\r\n+        }\r\n+\r\n+        public boolean hasNext() {\r\n+            return (_closed) ? false : super.hasNext();\r\n+        }\r\n+\r\n+        public Object next() {\r\n+            if (_closed)\r\n+                throw new NoSuchElementException();\r\n+            return super.next();\r\n+        }\r\n+\r\n+        public void remove() {\r\n+            throw new UnsupportedOperationException();\r\n+        }\r\n+\r\n+        public void setRemoveOnClose(ExtentImpl extent) {\r\n+            _extent = extent;\r\n+        }\r\n+\r\n+        public void close()\r\n+            throws Exception {\r\n+            if (_extent != null && _extent._openItrs != null) {\r\n+                _extent.lock();\r\n+                try {\r\n+                    _extent._openItrs.remove(this);\r\n+                } finally {\r\n+                    _extent.unlock();\r\n+                }\r\n+            }\r\n+\r\n+            _closed = true;\r\n+            ((Closeable) getIterator()).close();\r\n+        }\r\n+\r\n+        public boolean evaluate(Object o) {\r\n+            return !_extent._broker.isDeleted(o);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Iterator over all new objects in this extent. This iterator is always\r\n+     * wrapped, so it doesn't need to keep track of whether it's closed.\r\n+     */\r\n+    private class FilterNewIterator\r\n+        extends FilterIterator\r\n+        implements Closeable, Predicate {\r\n+\r\n+        public FilterNewIterator() {\r\n+            super(_broker.getTransactionalObjects().iterator());\r\n+            setPredicate(this);\r\n+        }\r\n+\r\n+        public void close() {\r\n+        }\r\n+\r\n+        public boolean evaluate(Object o) {\r\n+            if (!_broker.isNew(o))\r\n+                return false;\r\n+\r\n+            Class type = o.getClass();\r\n+            if (!_subs && type != _type)\r\n+                return false;\r\n+            if (_subs && !_type.isAssignableFrom(type))\r\n+                return false;\r\n+            return true;\r\n+\t\t}\r\n+\t}\r\n+}\r"},{"sha":"f05d69804b540049111549a4ce571f25095c1838","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","status":"modified","additions":2156,"deletions":2156,"changes":4312,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"10b6da126547d2356135f1ef99e6e377f795c6e3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","status":"modified","additions":645,"deletions":639,"changes":1284,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,639 +1,645 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.util;\n-\n-import java.util.AbstractCollection;\n-import java.util.AbstractSet;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import org.apache.commons.collections.Predicate;\n-import org.apache.commons.collections.iterators.FilterIterator;\n-import org.apache.commons.collections.iterators.IteratorChain;\n-import org.apache.openjpa.lib.util.LRUMap;\n-import org.apache.openjpa.lib.util.ReferenceHashMap;\n-import org.apache.openjpa.lib.util.ReferenceMap;\n-import org.apache.openjpa.lib.util.SizedMap;\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n-import org.apache.openjpa.lib.util.concurrent.ReentrantLock;\n-\n-/**\n- * Fixed-size map that has ability to pin/unpin entries and move overflow to\n- * a backing soft map.\n- *\n- * @author Patrick Linskey\n- * @author Abe White\n- */\n-public class CacheMap\n-    implements Map {\n-\n-    /**\n-     * The map for non-expired and non-pinned references.\n-     */\n-    protected final SizedMap cacheMap;\n-\n-    /**\n-     * The map for expired references.\n-     */\n-    protected final SizedMap softMap;\n-\n-    /**\n-     * The set of objects pinned into the cache.\n-     */\n-    protected final Map pinnedMap;\n-\n-    // number of pinned values (not including keys not mapped to values)\n-    private int _pinnedSize = 0;\n-\n-    private final ReentrantLock _writeLock = new ReentrantLock();\n-    private final ReentrantLock _readLock;\n-\n-    /**\n-     * Create a non-LRU (and therefore highly concurrent) cache map with a\n-     * size of 1000.\n-     */\n-    public CacheMap() {\n-        this(false, 1000);\n-    }\n-\n-    /**\n-     * Create a cache map with the given properties.\n-     */\n-    public CacheMap(boolean lru, int max) {\n-        this(lru, max, max / 2, .75F);\n-    }\n-\n-    /**\n-     * Create a cache map with the given properties.\n-     */\n-    public CacheMap(boolean lru, int max, int size, float load) {\n-        if (size < 0)\n-            size = 500;\n-        if (!lru) {\n-            cacheMap = new ConcurrentHashMap(size, load) {\n-                public void overflowRemoved(Object key, Object value) {\n-                    cacheMapOverflowRemoved(key, value);\n-                }\n-            };\n-            softMap = new ConcurrentReferenceHashMap(ReferenceMap.HARD,\n-                ReferenceMap.SOFT, size, load) {\n-                public void overflowRemoved(Object key, Object value) {\n-                    softMapOverflowRemoved(key, value);\n-                }\n-\n-                public void valueExpired(Object key) {\n-                    softMapValueExpired(key);\n-                }\n-            };\n-            pinnedMap = new ConcurrentHashMap();\n-            _readLock = null;\n-        } else {\n-            cacheMap = new LRUMap(size, load) {\n-                public void overflowRemoved(Object key, Object value) {\n-                    cacheMapOverflowRemoved(key, value);\n-                }\n-            };\n-            softMap = new ReferenceHashMap(ReferenceMap.HARD,\n-                ReferenceMap.SOFT, size, load) {\n-                public void overflowRemoved(Object key, Object value) {\n-                    softMapOverflowRemoved(key, value);\n-                }\n-\n-                public void valueExpired(Object key) {\n-                    softMapValueExpired(key);\n-                }\n-            };\n-            pinnedMap = new HashMap();\n-            _readLock = _writeLock;\n-        }\n-        cacheMap.setMaxSize((max < 0) ? Integer.MAX_VALUE : max);\n-    }\n-\n-    /**\n-     * Called from {@link SizedMap#overflowRemoved} in the cache map.\n-     */\n-    protected void cacheMapOverflowRemoved(Object key, Object value) {\n-        if (softMap.size() < softMap.getMaxSize())\n-            put(softMap, key, value);\n-        else\n-            entryRemoved(key, value, true);\n-    }\n-\n-    /**\n-     * Called from {@link SizedMap#overflowRemoved} in the soft map.\n-     */\n-    protected void softMapOverflowRemoved(Object key, Object value) {\n-        entryRemoved(key, value, true);\n-    }\n-\n-    /**\n-     * Called when a value expires from the soft map.\n-     */\n-    protected void softMapValueExpired(Object key) {\n-        entryRemoved(key, null, true);\n-    }\n-\n-    /**\n-     * Put the given entry into the given map. Allows subclasses to\n-     * take additional actions.\n-     */\n-    protected Object put(Map map, Object key, Object value) {\n-        return map.put(key, value);\n-    }\n-\n-    /**\n-     * Remove the given key from the given map. Allows subclasses to\n-     * take additional actions.\n-     */\n-    protected Object remove(Map map, Object key) {\n-        return map.remove(key);\n-    }\n-\n-    /**\n-     * Acquire read lock.\n-     */\n-    public void readLock() {\n-        if (_readLock != null)\n-            _readLock.lock();\n-    }\n-\n-    /**\n-     * Release read lock.\n-     */\n-    public void readUnlock() {\n-        if (_readLock != null)\n-            _readLock.unlock();\n-    }\n-\n-    /**\n-     * Acquire write lock.\n-     */\n-    public void writeLock() {\n-        _writeLock.lock();\n-    }\n-\n-    /**\n-     * Release write lock.\n-     */\n-    public void writeUnlock() {\n-        _writeLock.unlock();\n-    }\n-\n-    /**\n-     * Whether this cache map uses LRU eviction.\n-     */\n-    public boolean isLRU() {\n-        return _readLock != null;\n-    }\n-\n-    /**\n-     * The maximum number of hard references to maintain, or -1 for no limit.\n-     */\n-    public void setCacheSize(int size) {\n-        writeLock();\n-        try {\n-            cacheMap.setMaxSize((size < 0) ? Integer.MAX_VALUE : size);\n-        } finally {\n-            writeUnlock();\n-        }\n-    }\n-\n-    /**\n-     * The maximum number of hard references to maintain, or -1 for no limit.\n-     */\n-    public int getCacheSize() {\n-        int max = cacheMap.getMaxSize();\n-        return (max == Integer.MAX_VALUE) ? -1 : max;\n-    }\n-\n-    /**\n-     * The maximum number of soft references to maintain, or -1 for no limit.\n-     */\n-    public void setSoftReferenceSize(int size) {\n-        writeLock();\n-        try {\n-            softMap.setMaxSize((size < 0) ? Integer.MAX_VALUE : size);\n-        } finally {\n-            writeUnlock();\n-        }\n-    }\n-\n-    /**\n-     * The maximum number of soft references to maintain, or -1 for no limit.\n-     */\n-    public int getSoftReferenceSize() {\n-        int max = softMap.getMaxSize();\n-        return (max == Integer.MAX_VALUE) ? -1 : max;\n-    }\n-\n-    /**\n-     * The keys pinned into the map.\n-     */\n-    public Set getPinnedKeys() {\n-        readLock();\n-        try {\n-            return Collections.unmodifiableSet(pinnedMap.keySet());\n-        } finally {\n-            readUnlock();\n-        }\n-    }\n-\n-    /**\n-     * Locks the given key and its value into the map. Objects pinned into\n-     * the map are not counted towards the maximum cache size, and are never\n-     * evicted implicitly. You may pin keys for which no value is in the map.\n-     *\n-     * @return true if the givne key's value was pinned; false if no value\n-     * for the given key is cached\n-     */\n-    public boolean pin(Object key) {\n-        writeLock();\n-        try {\n-            // if we don't have a pinned map we need to create one; else if the\n-            // pinned map already contains the key, nothing to do\n-            if (pinnedMap.containsKey(key))\n-                return pinnedMap.get(key) != null;\n-\n-            // check other maps for key\n-            Object val = remove(cacheMap, key);\n-            if (val == null)\n-                val = remove(softMap, key);\n-\n-            // pin key\n-            put(pinnedMap, key, val);\n-            if (val != null) {\n-                _pinnedSize++;\n-                return true;\n-            }\n-            return false;\n-        } finally {\n-            writeUnlock();\n-        }\n-    }\n-\n-    /**\n-     * Undo a pinning.\n-     */\n-    public boolean unpin(Object key) {\n-        writeLock();\n-        try {\n-            Object val = remove(pinnedMap, key);\n-            if (val != null) {\n-                // put back into unpinned cache\n-                put(key, val);\n-                _pinnedSize--;\n-                return true;\n-            }\n-            return false;\n-        } finally {\n-            writeUnlock();\n-        }\n-    }\n-\n-    /**\n-     * Invoked when a key-value pair is evicted from this data\n-     * structure. This is invoked with <code>expired</code> set to\n-     * <code>true</code> when an object is dropped because of space\n-     * requirements or through garbage collection of soft references.\n-     * It is invoked with <code>expired</code> set to <code>false</code>\n-     * when an object is explicitly removed via the {@link #remove} or\n-     * {@link #clear} methods. This may be invoked more than once for a\n-     * given entry.\n-     *\n-     * @param value may be null if the value was a soft reference that has\n-     * been GCd\n-     * @since 0.2.5.0\n-     */\n-    protected void entryRemoved(Object key, Object value, boolean expired) {\n-    }\n-\n-    /**\n-     * Invoked when an entry is added to the cache. This may be invoked\n-     * more than once for an entry.\n-     */\n-    protected void entryAdded(Object key, Object value) {\n-    }\n-\n-    public Object get(Object key) {\n-        readLock();\n-        try {\n-            Object val = pinnedMap.get(key);\n-            if (val != null)\n-                return val;\n-\n-            val = cacheMap.get(key);\n-            if (val == null) {\n-                // if we find the key in the soft map, move it back into\n-                // the primary map\n-                val = softMap.get(key);\n-                if (val != null)\n-                    put(key, val);\n-            }\n-            return val;\n-        } finally {\n-            readUnlock();\n-        }\n-    }\n-\n-    public Object put(Object key, Object value) {\n-        writeLock();\n-        try {\n-            // if the key is pinned, just interact directly with the pinned map\n-            Object val;\n-            if (pinnedMap.containsKey(key)) {\n-                val = put(pinnedMap, key, value);\n-                if (val == null) {\n-                    _pinnedSize++;\n-                    entryAdded(key, value);\n-                } else {\n-                    entryRemoved(key, val, false);\n-                    entryAdded(key, value);\n-                }\n-                return val;\n-            }\n-\n-            // if no hard refs, don't put anything\n-            if (cacheMap.getMaxSize() == 0)\n-                return null;\n-\n-            // otherwise, put the value into the map and clear it from the\n-            // soft map\n-            val = put(cacheMap, key, value);\n-            if (val == null) {\n-                val = remove(softMap, key);\n-                if (val == null)\n-                    entryAdded(key, value);\n-                else {\n-                    entryRemoved(key, val, false);\n-                    entryAdded(key, value);\n-                }\n-            } else {\n-                entryRemoved(key, val, false);\n-                entryAdded(key, value);\n-            }\n-            return val;\n-        } finally {\n-            writeUnlock();\n-        }\n-    }\n-\n-    public void putAll(Map map) {\n-        Map.Entry entry;\n-        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n-            entry = (Map.Entry) itr.next();\n-            put(entry.getKey(), entry.getValue());\n-        }\n-    }\n-\n-    /**\n-     * If <code>key</code> is pinned into the cache, the pin is\n-     * cleared and the object is removed.\n-     */\n-    public Object remove(Object key) {\n-        writeLock();\n-        try {\n-            // if the key is pinned, just interact directly with the\n-            // pinned map\n-            Object val;\n-            if (pinnedMap.containsKey(key)) {\n-                // re-put with null value; we still want key pinned\n-                val = put(pinnedMap, key, null);\n-                if (val != null) {\n-                    _pinnedSize--;\n-                    entryRemoved(key, val, false);\n-                }\n-                return val;\n-            }\n-\n-            val = remove(cacheMap, key);\n-            if (val == null)\n-                val = softMap.remove(key);\n-            if (val != null)\n-                entryRemoved(key, val, false);\n-\n-            return val;\n-        } finally {\n-            writeUnlock();\n-        }\n-    }\n-\n-    /**\n-     * Removes pinned objects as well as unpinned ones.\n-     */\n-    public void clear() {\n-        writeLock();\n-        try {\n-            notifyEntryRemovals(pinnedMap.entrySet());\n-            pinnedMap.clear();\n-            _pinnedSize = 0;\n-\n-            notifyEntryRemovals(cacheMap.entrySet());\n-            cacheMap.clear();\n-\n-            notifyEntryRemovals(softMap.entrySet());\n-            softMap.clear();\n-        } finally {\n-            writeUnlock();\n-        }\n-    }\n-\n-    private void notifyEntryRemovals(Set set) {\n-        Map.Entry entry;\n-        for (Iterator itr = set.iterator(); itr.hasNext();) {\n-            entry = (Map.Entry) itr.next();\n-            if (entry.getValue() != null)\n-                entryRemoved(entry.getKey(), entry.getValue(), false);\n-        }\n-    }\n-\n-    public int size() {\n-        readLock();\n-        try {\n-            return _pinnedSize + cacheMap.size() + softMap.size();\n-        } finally {\n-            readUnlock();\n-        }\n-    }\n-\n-    public boolean isEmpty() {\n-        return size() == 0;\n-    }\n-\n-    public boolean containsKey(Object key) {\n-        readLock();\n-        try {\n-            return pinnedMap.get(key) != null\n-                || cacheMap.containsKey(key)\n-                || softMap.containsKey(key);\n-        } finally {\n-            readUnlock();\n-        }\n-    }\n-\n-    public boolean containsValue(Object val) {\n-        readLock();\n-        try {\n-            return pinnedMap.containsValue(val)\n-                || cacheMap.containsValue(val)\n-                || softMap.containsValue(val);\n-        } finally {\n-            readUnlock();\n-        }\n-    }\n-\n-    public Set keySet() {\n-        return new KeySet();\n-    }\n-\n-    public Collection values() {\n-        return new ValueCollection();\n-    }\n-\n-    public Set entrySet() {\n-        return new EntrySet();\n-    }\n-\n-    public String toString() {\n-        readLock();\n-        try {\n-            return \"CacheMap:\" + cacheMap.toString() + \"::\"\n-                + softMap.toString();\n-        } finally {\n-            readUnlock();\n-        }\n-    }\n-\n-    /**\n-     * View of the entry set.\n-     */\n-    private class EntrySet\n-        extends AbstractSet {\n-\n-        public int size() {\n-            return CacheMap.this.size();\n-        }\n-\n-        public boolean add(Object o) {\n-            Map.Entry entry = (Map.Entry) o;\n-            put(entry.getKey(), entry.getValue());\n-            return true;\n-        }\n-\n-        public Iterator iterator() {\n-            return new EntryIterator(EntryIterator.ENTRY);\n-        }\n-    }\n-\n-    /**\n-     * View of the key set.\n-     */\n-    private class KeySet\n-        extends AbstractSet {\n-\n-        public int size() {\n-            return CacheMap.this.size();\n-        }\n-\n-        public Iterator iterator() {\n-            return new EntryIterator(EntryIterator.KEY);\n-        }\n-    }\n-\n-    /**\n-     * View of the value collection.\n-     */\n-    private class ValueCollection\n-        extends AbstractCollection {\n-\n-        public int size() {\n-            return CacheMap.this.size();\n-        }\n-\n-        public Iterator iterator() {\n-            return new EntryIterator(EntryIterator.VALUE);\n-        }\n-    }\n-\n-    /**\n-     * Iterator over all entries.\n-     */\n-    private class EntryIterator\n-        implements Iterator, Predicate {\n-\n-        public static final int ENTRY = 0;\n-        public static final int KEY = 1;\n-        public static final int VALUE = 2;\n-\n-        private final IteratorChain _itr = new IteratorChain();\n-        private final int _type;\n-\n-        public EntryIterator(int type) {\n-            _type = type;\n-            _itr.addIterator(new FilterIterator(getView(pinnedMap), this));\n-            _itr.addIterator(getView(cacheMap));\n-            _itr.addIterator(getView(softMap));\n-        }\n-\n-        /**\n-         * Return an iterator over the appropriate view of the given map.\n-         */\n-        private Iterator getView(Map m) {\n-            if (m == null)\n-                return null;\n-\n-            switch (_type) {\n-                case KEY:\n-                    return m.keySet().iterator();\n-                case VALUE:\n-                    return m.values().iterator();\n-                default:\n-                    return m.entrySet().iterator();\n-            }\n-        }\n-\n-        public boolean hasNext() {\n-            return _itr.hasNext();\n-        }\n-\n-        public Object next() {\n-            return _itr.next();\n-        }\n-\n-        public void remove() {\n-            _itr.remove();\n-        }\n-\n-        public boolean evaluate(Object obj) {\n-            switch (_type) {\n-                case ENTRY:\n-                    return ((Map.Entry) obj).getValue() != null;\n-\t\t\tcase VALUE:\n-\t\t\t\treturn obj != null;\n-\t\t\tdefault:\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.util;\r\n+\r\n+import java.util.AbstractCollection;\r\n+import java.util.AbstractSet;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+\r\n+import org.apache.commons.collections.Predicate;\r\n+import org.apache.commons.collections.iterators.FilterIterator;\r\n+import org.apache.commons.collections.iterators.IteratorChain;\r\n+import org.apache.openjpa.lib.util.LRUMap;\r\n+import org.apache.openjpa.lib.util.ReferenceHashMap;\r\n+import org.apache.openjpa.lib.util.ReferenceMap;\r\n+import org.apache.openjpa.lib.util.SizedMap;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\r\n+import org.apache.openjpa.lib.util.concurrent.SizedConcurrentHashMap;\r\n+\r\n+import java.util.concurrent.locks.ReentrantLock;\r\n+\r\n+/**\r\n+ * Fixed-size map that has ability to pin/unpin entries and move overflow to\r\n+ * a backing soft map.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @author Abe White\r\n+ */\r\n+public class CacheMap\r\n+    implements Map {\r\n+\r\n+    /**\r\n+     * The map for non-expired and non-pinned references.\r\n+     */\r\n+    protected final SizedMap cacheMap;\r\n+\r\n+    /**\r\n+     * The map for expired references.\r\n+     */\r\n+    protected final SizedMap softMap;\r\n+\r\n+    /**\r\n+     * The set of objects pinned into the cache.\r\n+     */\r\n+    protected final Map pinnedMap;\r\n+\r\n+    // number of pinned values (not including keys not mapped to values)\r\n+    private int _pinnedSize = 0;\r\n+\r\n+    private final ReentrantLock _writeLock = new ReentrantLock();\r\n+    private final ReentrantLock _readLock;\r\n+\r\n+    /**\r\n+     * Create a non-LRU (and therefore highly concurrent) cache map with a\r\n+     * size of 1000.\r\n+     */\r\n+    public CacheMap() {\r\n+        this(false, 1000);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a cache map with the given properties.\r\n+     */\r\n+    public CacheMap(boolean lru, int max) {\r\n+        this(lru, max, max / 2, .75F);\r\n+    }\r\n+\r\n+    /**\r\n+     * @deprecated use {@link CacheMap#CacheMap(boolean, int, int, float, int)}\r\n+     * instead.\r\n+     */\r\n+    public CacheMap(boolean lru, int max, int size, float load) {\r\n+        this(lru, max, size, load, 16);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a cache map with the given properties.\r\n+     *\r\n+     * @since 1.1.0\r\n+     */\r\n+    public CacheMap(boolean lru, int max, int size, float load,\r\n+        int concurrencyLevel) {\r\n+        if (size < 0)\r\n+            size = 500;\r\n+\r\n+        softMap = new ConcurrentReferenceHashMap(ReferenceMap.HARD,\r\n+            ReferenceMap.SOFT, size, load) {\r\n+            public void overflowRemoved(Object key, Object value) {\r\n+                softMapOverflowRemoved(key, value);\r\n+            }\r\n+\r\n+            public void valueExpired(Object key) {\r\n+                softMapValueExpired(key);\r\n+            }\r\n+        };\r\n+        pinnedMap = new ConcurrentHashMap();\r\n+\r\n+        if (!lru) {\r\n+            cacheMap = new SizedConcurrentHashMap(size, load, concurrencyLevel){\r\n+                public void overflowRemoved(Object key, Object value) {\r\n+                    cacheMapOverflowRemoved(key, value);\r\n+                }\r\n+            };\r\n+            _readLock = null;\r\n+        } else {\r\n+            cacheMap = new LRUMap(size, load) {\r\n+                public void overflowRemoved(Object key, Object value) {\r\n+                    cacheMapOverflowRemoved(key, value);\r\n+                }\r\n+            };\r\n+            _readLock = _writeLock;\r\n+        }\r\n+        if (max < 0)\r\n+            max = Integer.MAX_VALUE;\r\n+        cacheMap.setMaxSize(max);\r\n+    }\r\n+\r\n+    /**\r\n+     * Called from {@link SizedMap#overflowRemoved} in the cache map.\r\n+     */\r\n+    protected void cacheMapOverflowRemoved(Object key, Object value) {\r\n+        if (softMap.size() < softMap.getMaxSize())\r\n+            put(softMap, key, value);\r\n+        else\r\n+            entryRemoved(key, value, true);\r\n+    }\r\n+\r\n+    /**\r\n+     * Called from {@link SizedMap#overflowRemoved} in the soft map.\r\n+     */\r\n+    protected void softMapOverflowRemoved(Object key, Object value) {\r\n+        entryRemoved(key, value, true);\r\n+    }\r\n+\r\n+    /**\r\n+     * Called when a value expires from the soft map.\r\n+     */\r\n+    protected void softMapValueExpired(Object key) {\r\n+        entryRemoved(key, null, true);\r\n+    }\r\n+\r\n+    /**\r\n+     * Put the given entry into the given map. Allows subclasses to\r\n+     * take additional actions.\r\n+     */\r\n+    protected Object put(Map map, Object key, Object value) {\r\n+        return map.put(key, value);\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove the given key from the given map. Allows subclasses to\r\n+     * take additional actions.\r\n+     */\r\n+    protected Object remove(Map map, Object key) {\r\n+        return map.remove(key);\r\n+    }\r\n+\r\n+    /**\r\n+     * Acquire read lock.\r\n+     */\r\n+    public void readLock() {\r\n+        if (_readLock != null)\r\n+            _readLock.lock();\r\n+    }\r\n+\r\n+    /**\r\n+     * Release read lock.\r\n+     */\r\n+    public void readUnlock() {\r\n+        if (_readLock != null)\r\n+            _readLock.unlock();\r\n+    }\r\n+\r\n+    /**\r\n+     * Acquire write lock.\r\n+     */\r\n+    public void writeLock() {\r\n+        _writeLock.lock();\r\n+    }\r\n+\r\n+    /**\r\n+     * Release write lock.\r\n+     */\r\n+    public void writeUnlock() {\r\n+        _writeLock.unlock();\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether this cache map uses LRU eviction.\r\n+     */\r\n+    public boolean isLRU() {\r\n+        return _readLock != null;\r\n+    }\r\n+\r\n+    /**\r\n+     * The maximum number of hard references to maintain, or -1 for no limit.\r\n+     */\r\n+    public void setCacheSize(int size) {\r\n+        writeLock();\r\n+        try {\r\n+            cacheMap.setMaxSize((size < 0) ? Integer.MAX_VALUE : size);\r\n+        } finally {\r\n+            writeUnlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * The maximum number of hard references to maintain, or -1 for no limit.\r\n+     */\r\n+    public int getCacheSize() {\r\n+        int max = cacheMap.getMaxSize();\r\n+        return (max == Integer.MAX_VALUE) ? -1 : max;\r\n+    }\r\n+\r\n+    /**\r\n+     * The maximum number of soft references to maintain, or -1 for no limit.\r\n+     */\r\n+    public void setSoftReferenceSize(int size) {\r\n+        writeLock();\r\n+        try {\r\n+            softMap.setMaxSize((size < 0) ? Integer.MAX_VALUE : size);\r\n+        } finally {\r\n+            writeUnlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * The maximum number of soft references to maintain, or -1 for no limit.\r\n+     */\r\n+    public int getSoftReferenceSize() {\r\n+        int max = softMap.getMaxSize();\r\n+        return (max == Integer.MAX_VALUE) ? -1 : max;\r\n+    }\r\n+\r\n+    /**\r\n+     * The keys pinned into the map.\r\n+     */\r\n+    public Set getPinnedKeys() {\r\n+        readLock();\r\n+        try {\r\n+            return Collections.unmodifiableSet(pinnedMap.keySet());\r\n+        } finally {\r\n+            readUnlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Locks the given key and its value into the map. Objects pinned into\r\n+     * the map are not counted towards the maximum cache size, and are never\r\n+     * evicted implicitly. You may pin keys for which no value is in the map.\r\n+     *\r\n+     * @return true if the givne key's value was pinned; false if no value\r\n+     * for the given key is cached\r\n+     */\r\n+    public boolean pin(Object key) {\r\n+        writeLock();\r\n+        try {\r\n+            // if we don't have a pinned map we need to create one; else if the\r\n+            // pinned map already contains the key, nothing to do\r\n+            if (pinnedMap.containsKey(key))\r\n+                return pinnedMap.get(key) != null;\r\n+\r\n+            // check other maps for key\r\n+            Object val = remove(cacheMap, key);\r\n+            if (val == null)\r\n+                val = remove(softMap, key);\r\n+\r\n+            // pin key\r\n+            put(pinnedMap, key, val);\r\n+            if (val != null) {\r\n+                _pinnedSize++;\r\n+                return true;\r\n+            }\r\n+            return false;\r\n+        } finally {\r\n+            writeUnlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Undo a pinning.\r\n+     */\r\n+    public boolean unpin(Object key) {\r\n+        writeLock();\r\n+        try {\r\n+            Object val = remove(pinnedMap, key);\r\n+            if (val != null) {\r\n+                // put back into unpinned cache\r\n+                put(key, val);\r\n+                _pinnedSize--;\r\n+                return true;\r\n+            }\r\n+            return false;\r\n+        } finally {\r\n+            writeUnlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Invoked when a key-value pair is evicted from this data\r\n+     * structure. This is invoked with <code>expired</code> set to\r\n+     * <code>true</code> when an object is dropped because of space\r\n+     * requirements or through garbage collection of soft references.\r\n+     * It is invoked with <code>expired</code> set to <code>false</code>\r\n+     * when an object is explicitly removed via the {@link #remove} or\r\n+     * {@link #clear} methods. This may be invoked more than once for a\r\n+     * given entry.\r\n+     *\r\n+     * @param value may be null if the value was a soft reference that has\r\n+     * been GCd\r\n+     * @since 0.2.5.0\r\n+     */\r\n+    protected void entryRemoved(Object key, Object value, boolean expired) {\r\n+    }\r\n+\r\n+    /**\r\n+     * Invoked when an entry is added to the cache. This may be invoked\r\n+     * more than once for an entry.\r\n+     */\r\n+    protected void entryAdded(Object key, Object value) {\r\n+    }\r\n+\r\n+    public Object get(Object key) {\r\n+        readLock();\r\n+        try {\r\n+            Object val = pinnedMap.get(key);\r\n+            if (val != null)\r\n+                return val;\r\n+\r\n+            val = cacheMap.get(key);\r\n+            if (val == null) {\r\n+                // if we find the key in the soft map, move it back into\r\n+                // the primary map\r\n+                val = softMap.get(key);\r\n+                if (val != null)\r\n+                    put(key, val);\r\n+            }\r\n+            return val;\r\n+        } finally {\r\n+            readUnlock();\r\n+        }\r\n+    }\r\n+\r\n+    public Object put(Object key, Object value) {\r\n+        writeLock();\r\n+        try {\r\n+            // if the key is pinned, just interact directly with the pinned map\r\n+            Object val;\r\n+            if (pinnedMap.containsKey(key)) {\r\n+                val = put(pinnedMap, key, value);\r\n+                if (val == null) {\r\n+                    _pinnedSize++;\r\n+                    entryAdded(key, value);\r\n+                } else {\r\n+                    entryRemoved(key, val, false);\r\n+                    entryAdded(key, value);\r\n+                }\r\n+                return val;\r\n+            }\r\n+\r\n+            // if no hard refs, don't put anything\r\n+            if (cacheMap.getMaxSize() == 0)\r\n+                return null;\r\n+\r\n+            // otherwise, put the value into the map and clear it from the\r\n+            // soft map\r\n+            val = put(cacheMap, key, value);\r\n+            if (val == null) {\r\n+                val = remove(softMap, key);\r\n+                if (val == null)\r\n+                    entryAdded(key, value);\r\n+                else {\r\n+                    entryRemoved(key, val, false);\r\n+                    entryAdded(key, value);\r\n+                }\r\n+            } else {\r\n+                entryRemoved(key, val, false);\r\n+                entryAdded(key, value);\r\n+            }\r\n+            return val;\r\n+        } finally {\r\n+            writeUnlock();\r\n+        }\r\n+    }\r\n+\r\n+    public void putAll(Map map) {\r\n+        Map.Entry entry;\r\n+        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\r\n+            entry = (Map.Entry) itr.next();\r\n+            put(entry.getKey(), entry.getValue());\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * If <code>key</code> is pinned into the cache, the pin is\r\n+     * cleared and the object is removed.\r\n+     */\r\n+    public Object remove(Object key) {\r\n+        writeLock();\r\n+        try {\r\n+            // if the key is pinned, just interact directly with the\r\n+            // pinned map\r\n+            Object val;\r\n+            if (pinnedMap.containsKey(key)) {\r\n+                // re-put with null value; we still want key pinned\r\n+                val = put(pinnedMap, key, null);\r\n+                if (val != null) {\r\n+                    _pinnedSize--;\r\n+                    entryRemoved(key, val, false);\r\n+                }\r\n+                return val;\r\n+            }\r\n+\r\n+            val = remove(cacheMap, key);\r\n+            if (val == null)\r\n+                val = softMap.remove(key);\r\n+            if (val != null)\r\n+                entryRemoved(key, val, false);\r\n+\r\n+            return val;\r\n+        } finally {\r\n+            writeUnlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Removes pinned objects as well as unpinned ones.\r\n+     */\r\n+    public void clear() {\r\n+        writeLock();\r\n+        try {\r\n+            notifyEntryRemovals(pinnedMap.entrySet());\r\n+            pinnedMap.clear();\r\n+            _pinnedSize = 0;\r\n+\r\n+            notifyEntryRemovals(cacheMap.entrySet());\r\n+            cacheMap.clear();\r\n+\r\n+            notifyEntryRemovals(softMap.entrySet());\r\n+            softMap.clear();\r\n+        } finally {\r\n+            writeUnlock();\r\n+        }\r\n+    }\r\n+\r\n+    private void notifyEntryRemovals(Set set) {\r\n+        Map.Entry entry;\r\n+        for (Iterator itr = set.iterator(); itr.hasNext();) {\r\n+            entry = (Map.Entry) itr.next();\r\n+            if (entry.getValue() != null)\r\n+                entryRemoved(entry.getKey(), entry.getValue(), false);\r\n+        }\r\n+    }\r\n+\r\n+    public int size() {\r\n+        readLock();\r\n+        try {\r\n+            return _pinnedSize + cacheMap.size() + softMap.size();\r\n+        } finally {\r\n+            readUnlock();\r\n+        }\r\n+    }\r\n+\r\n+    public boolean isEmpty() {\r\n+        return size() == 0;\r\n+    }\r\n+\r\n+    public boolean containsKey(Object key) {\r\n+        readLock();\r\n+        try {\r\n+            return pinnedMap.get(key) != null\r\n+                || cacheMap.containsKey(key)\r\n+                || softMap.containsKey(key);\r\n+        } finally {\r\n+            readUnlock();\r\n+        }\r\n+    }\r\n+\r\n+    public boolean containsValue(Object val) {\r\n+        readLock();\r\n+        try {\r\n+            return pinnedMap.containsValue(val)\r\n+                || cacheMap.containsValue(val)\r\n+                || softMap.containsValue(val);\r\n+        } finally {\r\n+            readUnlock();\r\n+        }\r\n+    }\r\n+\r\n+    public Set keySet() {\r\n+        return new KeySet();\r\n+    }\r\n+\r\n+    public Collection values() {\r\n+        return new ValueCollection();\r\n+    }\r\n+\r\n+    public Set entrySet() {\r\n+        return new EntrySet();\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        readLock();\r\n+        try {\r\n+            return \"CacheMap:\" + cacheMap.toString() + \"::\"\r\n+                + softMap.toString();\r\n+        } finally {\r\n+            readUnlock();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * View of the entry set.\r\n+     */\r\n+    private class EntrySet\r\n+        extends AbstractSet {\r\n+\r\n+        public int size() {\r\n+            return CacheMap.this.size();\r\n+        }\r\n+\r\n+        public boolean add(Object o) {\r\n+            Map.Entry entry = (Map.Entry) o;\r\n+            put(entry.getKey(), entry.getValue());\r\n+            return true;\r\n+        }\r\n+\r\n+        public Iterator iterator() {\r\n+            return new EntryIterator(EntryIterator.ENTRY);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * View of the key set.\r\n+     */\r\n+    private class KeySet\r\n+        extends AbstractSet {\r\n+\r\n+        public int size() {\r\n+            return CacheMap.this.size();\r\n+        }\r\n+\r\n+        public Iterator iterator() {\r\n+            return new EntryIterator(EntryIterator.KEY);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * View of the value collection.\r\n+     */\r\n+    private class ValueCollection\r\n+        extends AbstractCollection {\r\n+\r\n+        public int size() {\r\n+            return CacheMap.this.size();\r\n+        }\r\n+\r\n+        public Iterator iterator() {\r\n+            return new EntryIterator(EntryIterator.VALUE);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Iterator over all entries.\r\n+     */\r\n+    private class EntryIterator\r\n+        implements Iterator, Predicate {\r\n+\r\n+        public static final int ENTRY = 0;\r\n+        public static final int KEY = 1;\r\n+        public static final int VALUE = 2;\r\n+\r\n+        private final IteratorChain _itr = new IteratorChain();\r\n+        private final int _type;\r\n+\r\n+        public EntryIterator(int type) {\r\n+            _type = type;\r\n+            _itr.addIterator(new FilterIterator(getView(pinnedMap), this));\r\n+            _itr.addIterator(getView(cacheMap));\r\n+            _itr.addIterator(getView(softMap));\r\n+        }\r\n+\r\n+        /**\r\n+         * Return an iterator over the appropriate view of the given map.\r\n+         */\r\n+        private Iterator getView(Map m) {\r\n+            if (m == null)\r\n+                return null;\r\n+\r\n+            switch (_type) {\r\n+                case KEY:\r\n+                    return m.keySet().iterator();\r\n+                case VALUE:\r\n+                    return m.values().iterator();\r\n+                default:\r\n+                    return m.entrySet().iterator();\r\n+            }\r\n+        }\r\n+\r\n+        public boolean hasNext() {\r\n+            return _itr.hasNext();\r\n+        }\r\n+\r\n+        public Object next() {\r\n+            return _itr.next();\r\n+        }\r\n+\r\n+        public void remove() {\r\n+            _itr.remove();\r\n+        }\r\n+\r\n+        public boolean evaluate(Object obj) {\r\n+            switch (_type) {\r\n+                case ENTRY:\r\n+                    return ((Map.Entry) obj).getValue() != null;\r\n+\t\t\tcase VALUE:\r\n+\t\t\t\treturn obj != null;\r\n+\t\t\tdefault:\r\n+\t\t\t\treturn true;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+}\r\n+\r"},{"sha":"f25dfb4f02bf34134c2b36f47e3f4a32468f6fb9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","status":"modified","additions":322,"deletions":322,"changes":644,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,322 +1,322 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.util;\n-\n-import java.util.ArrayList;\n-import java.util.BitSet;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.Map;\n-\n-import org.apache.openjpa.enhance.PersistenceCapable;\n-import org.apache.openjpa.enhance.PCRegistry;\n-import org.apache.openjpa.enhance.StateManager;\n-import org.apache.openjpa.enhance.ManagedInstanceProvider;\n-import org.apache.openjpa.enhance.ReflectingPersistenceCapable;\n-import org.apache.openjpa.enhance.RuntimeUnenhancedClasssesModes;\n-import org.apache.openjpa.kernel.FetchConfiguration;\n-import org.apache.openjpa.kernel.LockManager;\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\n-import org.apache.openjpa.kernel.PCState;\n-import org.apache.openjpa.kernel.StoreContext;\n-import org.apache.openjpa.kernel.StoreManager;\n-import org.apache.openjpa.lib.util.Closeable;\n-import org.apache.openjpa.lib.util.ReferenceMap;\n-import org.apache.openjpa.lib.util.UUIDGenerator;\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.meta.FieldMetaData;\n-import org.apache.openjpa.meta.JavaTypes;\n-import org.apache.openjpa.meta.SequenceMetaData;\n-import org.apache.openjpa.meta.ValueStrategies;\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\n-\n-/**\n- * Helper for OpenJPA back-ends.\n- *\n- * @since 0.3.0\n- * @author Abe White\n- * @nojavadoc\n- */\n-public class ImplHelper {\n-\n-    // Cache for from/to type assignments\n-    private static final Map _assignableTypes =\n-        new ConcurrentReferenceHashMap(ReferenceMap.WEAK, ReferenceMap.HARD);\n-\n-    // map of all new unenhanced instances active in this classloader\n-    public static final Map _unenhancedInstanceMap =\n-        new ConcurrentReferenceHashMap(ReferenceMap.WEAK, ReferenceMap.HARD) {\n-\n-            protected boolean eq(Object x, Object y) {\n-                // the Entries in ConcurrentReferenceHashMap delegate back to\n-                // eq() in their equals() impls\n-                if (x instanceof Map.Entry)\n-                    return super.eq(x, y);\n-                else\n-                    return x == y;\n-            }\n-\n-            protected int hc(Object o) {\n-                // the Entries in ConcurrentReferenceHashMap delegate back to\n-                // hc() in their hashCode() impls\n-                if (o instanceof Map.Entry)\n-                    return super.hc(o);\n-                else\n-                    return System.identityHashCode(o);\n-            }\n-        };\n-\n-    /**\n-     * Helper for store manager implementations. This method simply delegates\n-     * to the proper singular method for each state manager.\n-     *\n-     * @see StoreManager#loadAll\n-     * @since 0.4.0\n-     */\n-    public static Collection loadAll(Collection sms, StoreManager store,\n-        PCState state, int load, FetchConfiguration fetch, Object context) {\n-        Collection failed = null;\n-        OpenJPAStateManager sm;\n-        LockManager lm;\n-        for (Iterator itr = sms.iterator(); itr.hasNext();) {\n-            sm = (OpenJPAStateManager) itr.next();\n-            if (sm.getManagedInstance() == null) {\n-                if (!store.initialize(sm, state, fetch, context))\n-                    failed = addFailedId(sm, failed);\n-            } else if (load != StoreManager.FORCE_LOAD_NONE\n-                || sm.getPCState() == PCState.HOLLOW) {\n-                lm = sm.getContext().getLockManager();\n-                if (!store.load(sm, sm.getUnloaded(fetch), fetch, \n-                    lm.getLockLevel(sm), context))\n-                    failed = addFailedId(sm, failed);\n-            } else if (!store.exists(sm, context))\n-                failed = addFailedId(sm, failed);\n-        }\n-        return (failed == null) ? Collections.EMPTY_LIST : failed;\n-    }\n-\n-    /**\n-     * Add identity of given instance to collection.\n-     */\n-    private static Collection addFailedId(OpenJPAStateManager sm,\n-        Collection failed) {\n-        if (failed == null)\n-            failed = new ArrayList();\n-        failed.add(sm.getId());\n-        return failed;\n-    }\n-\n-    /**\n-     * Generate a value for the given metadata, or return null. Generates\n-     * values for hte following strategies: {@link ValueStrategies#SEQUENCE},\n-     * {@link ValueStrategies#UUID_STRING}, {@link ValueStrategies#UUID_HEX}\n-     */\n-    public static Object generateIdentityValue(StoreContext ctx,\n-        ClassMetaData meta, int typeCode) {\n-        return generateValue(ctx, meta, null, typeCode);\n-    }\n-\n-    /**\n-     * Generate a value for the given metadata, or return null. Generates\n-     * values for hte following strategies: {@link ValueStrategies#SEQUENCE},\n-     * {@link ValueStrategies#UUID_STRING}, {@link ValueStrategies#UUID_HEX}\n-     */\n-    public static Object generateFieldValue(StoreContext ctx,\n-        FieldMetaData fmd) {\n-        return generateValue(ctx, fmd.getDefiningMetaData(), fmd, \n-            fmd.getDeclaredTypeCode());\n-    }\n-\n-    /**\n-     * Generate a value for the given metadaa.\n-     */\n-    private static Object generateValue(StoreContext ctx,\n-        ClassMetaData meta, FieldMetaData fmd, int typeCode) {\n-        int strategy = (fmd == null) ? meta.getIdentityStrategy()\n-            : fmd.getValueStrategy();\n-        switch (strategy) {\n-            case ValueStrategies.SEQUENCE:\n-                SequenceMetaData smd = (fmd == null)\n-                    ? meta.getIdentitySequenceMetaData()\n-                    : fmd.getValueSequenceMetaData();\n-                return JavaTypes.convert(smd.getInstance(ctx.getClassLoader()).\n-                    next(ctx, meta), typeCode);\n-            case ValueStrategies.UUID_STRING:\n-                return UUIDGenerator.nextString();\n-            case ValueStrategies.UUID_HEX:\n-                return UUIDGenerator.nextHex();\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    /**\n-     * Returns the fields of the state that require an update.\n-     *\n-     * @param  sm  the state to check\n-     * @return the BitSet of fields that need update, or null if none\n-     */\n-    public static BitSet getUpdateFields(OpenJPAStateManager sm) {\n-        if ((sm.getPCState() == PCState.PDIRTY\n-            && (!sm.isFlushed() || sm.isFlushedDirty()))\n-            || (sm.getPCState() == PCState.PNEW && sm.isFlushedDirty())) {\n-            BitSet dirty = sm.getDirty();\n-            if (sm.isFlushed()) {\n-                dirty = (BitSet) dirty.clone();\n-                dirty.andNot(sm.getFlushed());\n-            }\n-            if (dirty.length() > 0)\n-                return dirty;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Close the given resource. The resource can be an extent iterator,\n-     * query result, large result set relation, or any closeable OpenJPA\n-     * component.\n-     */\n-    public static void close(Object o) {\n-        try {\n-            if (o instanceof Closeable)\n-                ((Closeable) o).close();\n-        } catch (RuntimeException re) {\n-            throw re;\n-        } catch (Exception e) {\n-            throw new GeneralException(e);\n-        }\n-    }\n-\n-    /**\n-     * Returns true if the specified class is a type that can be managed by\n-     * OpenJPA.\n-     *\n-     * @param type the class to test\n-     * @return true if the class is manageable.\n-     *\n-     * @since 1.0.0\n-     */\n-    public static boolean isManagedType(OpenJPAConfiguration conf, Class type) {\n-        return (PersistenceCapable.class.isAssignableFrom(type)\n-            || (type != null\n-                && (conf == null || conf.getRuntimeUnenhancedClassesConstant()\n-                    == RuntimeUnenhancedClasssesModes.SUPPORTED)\n-                && PCRegistry.isRegistered(type)));\n-    }\n-\n-    /**\n-     * Returns true if the specified instance is manageable.\n-     *\n-     * @param instance the object to check\n-     * @return true if the instance is a persistent type, false otherwise\n-     */\n-    public static boolean isManageable(Object instance) {\n-        return instance instanceof PersistenceCapable\n-            || instance != null && PCRegistry.isRegistered(instance.getClass());\n-    }\n-\n-    /**\n-     * Returns true if the referenced \"to\" class is assignable to the \"from\"\n-     * class.  This helper method utilizes a cache to help avoid the overhead\n-     * of the Class.isAssignableFrom() method.\n-     *\n-     * @param from target class instance to be checked for assignability\n-     * @param to second class instance to be checked for assignability\n-     * @return true if the \"to\" class is assignable to the \"from\" class\n-     */\n-    public static boolean isAssignable(Class from, Class to) {\n-        if (from == null || to == null)\n-            return false;\n-\n-        Boolean isAssignable = null;\n-        Map assignableTo = (Map) _assignableTypes.get(from);\n-        if (assignableTo == null) { // \"to\" cache doesn't exist, so create it...\n-            assignableTo = new ConcurrentReferenceHashMap(ReferenceMap.WEAK,\n-                    ReferenceMap.HARD);\n-            _assignableTypes.put(from, assignableTo);\n-        } else { // \"to\" cache exists...\n-            isAssignable = (Boolean) assignableTo.get(to);\n-        }\n-\n-        if (isAssignable == null) {// we don't have a record of this pair...\n-            isAssignable = Boolean.valueOf(from.isAssignableFrom(to));\n-            assignableTo.put(to, isAssignable);\n-        }\n-\n-        return isAssignable.booleanValue();\n-    }\n-\n-    /**\n-     * @return the persistence-capable instance responsible for managing\n-     * <code>o</code>, or <code>null</code> if <code>o</code> is not manageable.\n-     * @since 1.0.0\n-     */\n-    public static PersistenceCapable toPersistenceCapable(Object o, Object ctx){\n-        if (o instanceof PersistenceCapable)\n-            return (PersistenceCapable) o;\n-\n-        OpenJPAConfiguration conf = null;\n-        if (ctx instanceof OpenJPAConfiguration)\n-            conf = (OpenJPAConfiguration) ctx;\n-        else if (ctx instanceof StateManager\n-            && ((StateManager) ctx).getGenericContext() instanceof StoreContext)\n-            conf = ((StoreContext) ((StateManager) ctx).getGenericContext())\n-                .getConfiguration();\n-\n-        if (!isManageable(o))\n-            return null;\n-\n-        // if we had a putIfAbsent() method, we wouldn't need to sync here\n-        synchronized (o) {\n-            PersistenceCapable pc = (PersistenceCapable)\n-                _unenhancedInstanceMap.get(o);\n-\n-            if (pc != null)\n-                return pc;\n-\n-            // if we don't have a conf passed in, then we can't create a new\n-            // ReflectingPC; this will only be the case when invoked from a\n-            // context outside of OpenJPA.\n-            if (conf == null)\n-                return null;\n-\n-            pc = new ReflectingPersistenceCapable(o, conf);\n-            _unenhancedInstanceMap.put(o, pc);\n-            return pc;\n-        }\n-    }\n-\n-    public static void registerPersistenceCapable(\n-        ReflectingPersistenceCapable pc) {\n-        _unenhancedInstanceMap.put(pc.getManagedInstance(), pc);\n-    }\n-\n-    /**\n-     * @return the user-visible representation of <code>o</code>.\n-     * @since 1.0.0\n-     */\n-    public static Object getManagedInstance(Object o) {\n-        if (o instanceof ManagedInstanceProvider)\n-            return ((ManagedInstanceProvider) o).getManagedInstance();\n-        else\n-            return o;\n-    }\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.util;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.BitSet;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Iterator;\r\n+import java.util.Map;\r\n+\r\n+import org.apache.openjpa.enhance.PersistenceCapable;\r\n+import org.apache.openjpa.enhance.PCRegistry;\r\n+import org.apache.openjpa.enhance.StateManager;\r\n+import org.apache.openjpa.enhance.ManagedInstanceProvider;\r\n+import org.apache.openjpa.enhance.ReflectingPersistenceCapable;\r\n+import org.apache.openjpa.enhance.RuntimeUnenhancedClasssesModes;\r\n+import org.apache.openjpa.kernel.FetchConfiguration;\r\n+import org.apache.openjpa.kernel.LockManager;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.kernel.PCState;\r\n+import org.apache.openjpa.kernel.StoreContext;\r\n+import org.apache.openjpa.kernel.StoreManager;\r\n+import org.apache.openjpa.lib.util.Closeable;\r\n+import org.apache.openjpa.lib.util.ReferenceMap;\r\n+import org.apache.openjpa.lib.util.UUIDGenerator;\r\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.meta.SequenceMetaData;\r\n+import org.apache.openjpa.meta.ValueStrategies;\r\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n+\r\n+/**\r\n+ * Helper for OpenJPA back-ends.\r\n+ *\r\n+ * @since 0.3.0\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ */\r\n+public class ImplHelper {\r\n+\r\n+    // Cache for from/to type assignments\r\n+    private static final Map _assignableTypes =\r\n+        new ConcurrentReferenceHashMap(ReferenceMap.WEAK, ReferenceMap.HARD);\r\n+\r\n+    // map of all new unenhanced instances active in this classloader\r\n+    public static final Map _unenhancedInstanceMap =\r\n+        new ConcurrentReferenceHashMap(ReferenceMap.WEAK, ReferenceMap.HARD) {\r\n+\r\n+            protected boolean eq(Object x, Object y) {\r\n+                // the Entries in ConcurrentReferenceHashMap delegate back to\r\n+                // eq() in their equals() impls\r\n+                if (x instanceof Map.Entry)\r\n+                    return super.eq(x, y);\r\n+                else\r\n+                    return x == y;\r\n+            }\r\n+\r\n+            protected int hc(Object o) {\r\n+                // the Entries in ConcurrentReferenceHashMap delegate back to\r\n+                // hc() in their hashCode() impls\r\n+                if (o instanceof Map.Entry)\r\n+                    return super.hc(o);\r\n+                else\r\n+                    return System.identityHashCode(o);\r\n+            }\r\n+        };\r\n+\r\n+    /**\r\n+     * Helper for store manager implementations. This method simply delegates\r\n+     * to the proper singular method for each state manager.\r\n+     *\r\n+     * @see StoreManager#loadAll\r\n+     * @since 0.4.0\r\n+     */\r\n+    public static Collection loadAll(Collection sms, StoreManager store,\r\n+        PCState state, int load, FetchConfiguration fetch, Object context) {\r\n+        Collection failed = null;\r\n+        OpenJPAStateManager sm;\r\n+        LockManager lm;\r\n+        for (Iterator itr = sms.iterator(); itr.hasNext();) {\r\n+            sm = (OpenJPAStateManager) itr.next();\r\n+            if (sm.getManagedInstance() == null) {\r\n+                if (!store.initialize(sm, state, fetch, context))\r\n+                    failed = addFailedId(sm, failed);\r\n+            } else if (load != StoreManager.FORCE_LOAD_NONE\r\n+                || sm.getPCState() == PCState.HOLLOW) {\r\n+                lm = sm.getContext().getLockManager();\r\n+                if (!store.load(sm, sm.getUnloaded(fetch), fetch, \r\n+                    lm.getLockLevel(sm), context))\r\n+                    failed = addFailedId(sm, failed);\r\n+            } else if (!store.exists(sm, context))\r\n+                failed = addFailedId(sm, failed);\r\n+        }\r\n+        return (failed == null) ? Collections.EMPTY_LIST : failed;\r\n+    }\r\n+\r\n+    /**\r\n+     * Add identity of given instance to collection.\r\n+     */\r\n+    private static Collection addFailedId(OpenJPAStateManager sm,\r\n+        Collection failed) {\r\n+        if (failed == null)\r\n+            failed = new ArrayList();\r\n+        failed.add(sm.getId());\r\n+        return failed;\r\n+    }\r\n+\r\n+    /**\r\n+     * Generate a value for the given metadata, or return null. Generates\r\n+     * values for hte following strategies: {@link ValueStrategies#SEQUENCE},\r\n+     * {@link ValueStrategies#UUID_STRING}, {@link ValueStrategies#UUID_HEX}\r\n+     */\r\n+    public static Object generateIdentityValue(StoreContext ctx,\r\n+        ClassMetaData meta, int typeCode) {\r\n+        return generateValue(ctx, meta, null, typeCode);\r\n+    }\r\n+\r\n+    /**\r\n+     * Generate a value for the given metadata, or return null. Generates\r\n+     * values for hte following strategies: {@link ValueStrategies#SEQUENCE},\r\n+     * {@link ValueStrategies#UUID_STRING}, {@link ValueStrategies#UUID_HEX}\r\n+     */\r\n+    public static Object generateFieldValue(StoreContext ctx,\r\n+        FieldMetaData fmd) {\r\n+        return generateValue(ctx, fmd.getDefiningMetaData(), fmd, \r\n+            fmd.getDeclaredTypeCode());\r\n+    }\r\n+\r\n+    /**\r\n+     * Generate a value for the given metadaa.\r\n+     */\r\n+    private static Object generateValue(StoreContext ctx,\r\n+        ClassMetaData meta, FieldMetaData fmd, int typeCode) {\r\n+        int strategy = (fmd == null) ? meta.getIdentityStrategy()\r\n+            : fmd.getValueStrategy();\r\n+        switch (strategy) {\r\n+            case ValueStrategies.SEQUENCE:\r\n+                SequenceMetaData smd = (fmd == null)\r\n+                    ? meta.getIdentitySequenceMetaData()\r\n+                    : fmd.getValueSequenceMetaData();\r\n+                return JavaTypes.convert(smd.getInstance(ctx.getClassLoader()).\r\n+                    next(ctx, meta), typeCode);\r\n+            case ValueStrategies.UUID_STRING:\r\n+                return UUIDGenerator.nextString();\r\n+            case ValueStrategies.UUID_HEX:\r\n+                return UUIDGenerator.nextHex();\r\n+            default:\r\n+                return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the fields of the state that require an update.\r\n+     *\r\n+     * @param  sm  the state to check\r\n+     * @return the BitSet of fields that need update, or null if none\r\n+     */\r\n+    public static BitSet getUpdateFields(OpenJPAStateManager sm) {\r\n+        if ((sm.getPCState() == PCState.PDIRTY\r\n+            && (!sm.isFlushed() || sm.isFlushedDirty()))\r\n+            || (sm.getPCState() == PCState.PNEW && sm.isFlushedDirty())) {\r\n+            BitSet dirty = sm.getDirty();\r\n+            if (sm.isFlushed()) {\r\n+                dirty = (BitSet) dirty.clone();\r\n+                dirty.andNot(sm.getFlushed());\r\n+            }\r\n+            if (dirty.length() > 0)\r\n+                return dirty;\r\n+        }\r\n+        return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Close the given resource. The resource can be an extent iterator,\r\n+     * query result, large result set relation, or any closeable OpenJPA\r\n+     * component.\r\n+     */\r\n+    public static void close(Object o) {\r\n+        try {\r\n+            if (o instanceof Closeable)\r\n+                ((Closeable) o).close();\r\n+        } catch (RuntimeException re) {\r\n+            throw re;\r\n+        } catch (Exception e) {\r\n+            throw new GeneralException(e);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns true if the specified class is a type that can be managed by\r\n+     * OpenJPA.\r\n+     *\r\n+     * @param type the class to test\r\n+     * @return true if the class is manageable.\r\n+     *\r\n+     * @since 1.0.0\r\n+     */\r\n+    public static boolean isManagedType(OpenJPAConfiguration conf, Class type) {\r\n+        return (PersistenceCapable.class.isAssignableFrom(type)\r\n+            || (type != null\r\n+                && (conf == null || conf.getRuntimeUnenhancedClassesConstant()\r\n+                    == RuntimeUnenhancedClasssesModes.SUPPORTED)\r\n+                && PCRegistry.isRegistered(type)));\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns true if the specified instance is manageable.\r\n+     *\r\n+     * @param instance the object to check\r\n+     * @return true if the instance is a persistent type, false otherwise\r\n+     */\r\n+    public static boolean isManageable(Object instance) {\r\n+        return instance instanceof PersistenceCapable\r\n+            || instance != null && PCRegistry.isRegistered(instance.getClass());\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns true if the referenced \"to\" class is assignable to the \"from\"\r\n+     * class.  This helper method utilizes a cache to help avoid the overhead\r\n+     * of the Class.isAssignableFrom() method.\r\n+     *\r\n+     * @param from target class instance to be checked for assignability\r\n+     * @param to second class instance to be checked for assignability\r\n+     * @return true if the \"to\" class is assignable to the \"from\" class\r\n+     */\r\n+    public static boolean isAssignable(Class from, Class to) {\r\n+        if (from == null || to == null)\r\n+            return false;\r\n+\r\n+        Boolean isAssignable = null;\r\n+        Map assignableTo = (Map) _assignableTypes.get(from);\r\n+        if (assignableTo == null) { // \"to\" cache doesn't exist, so create it...\r\n+            assignableTo = new ConcurrentReferenceHashMap(ReferenceMap.WEAK,\r\n+                    ReferenceMap.HARD);\r\n+            _assignableTypes.put(from, assignableTo);\r\n+        } else { // \"to\" cache exists...\r\n+            isAssignable = (Boolean) assignableTo.get(to);\r\n+        }\r\n+\r\n+        if (isAssignable == null) {// we don't have a record of this pair...\r\n+            isAssignable = Boolean.valueOf(from.isAssignableFrom(to));\r\n+            assignableTo.put(to, isAssignable);\r\n+        }\r\n+\r\n+        return isAssignable.booleanValue();\r\n+    }\r\n+\r\n+    /**\r\n+     * @return the persistence-capable instance responsible for managing\r\n+     * <code>o</code>, or <code>null</code> if <code>o</code> is not manageable.\r\n+     * @since 1.0.0\r\n+     */\r\n+    public static PersistenceCapable toPersistenceCapable(Object o, Object ctx){\r\n+        if (o instanceof PersistenceCapable)\r\n+            return (PersistenceCapable) o;\r\n+\r\n+        OpenJPAConfiguration conf = null;\r\n+        if (ctx instanceof OpenJPAConfiguration)\r\n+            conf = (OpenJPAConfiguration) ctx;\r\n+        else if (ctx instanceof StateManager\r\n+            && ((StateManager) ctx).getGenericContext() instanceof StoreContext)\r\n+            conf = ((StoreContext) ((StateManager) ctx).getGenericContext())\r\n+                .getConfiguration();\r\n+\r\n+        if (!isManageable(o))\r\n+            return null;\r\n+\r\n+        // if we had a putIfAbsent() method, we wouldn't need to sync here\r\n+        synchronized (o) {\r\n+            PersistenceCapable pc = (PersistenceCapable)\r\n+                _unenhancedInstanceMap.get(o);\r\n+\r\n+            if (pc != null)\r\n+                return pc;\r\n+\r\n+            // if we don't have a conf passed in, then we can't create a new\r\n+            // ReflectingPC; this will only be the case when invoked from a\r\n+            // context outside of OpenJPA.\r\n+            if (conf == null)\r\n+                return null;\r\n+\r\n+            pc = new ReflectingPersistenceCapable(o, conf);\r\n+            _unenhancedInstanceMap.put(o, pc);\r\n+            return pc;\r\n+        }\r\n+    }\r\n+\r\n+    public static void registerPersistenceCapable(\r\n+        ReflectingPersistenceCapable pc) {\r\n+        _unenhancedInstanceMap.put(pc.getManagedInstance(), pc);\r\n+    }\r\n+\r\n+    /**\r\n+     * @return the user-visible representation of <code>o</code>.\r\n+     * @since 1.0.0\r\n+     */\r\n+    public static Object getManagedInstance(Object o) {\r\n+        if (o instanceof ManagedInstanceProvider)\r\n+            return ((ManagedInstanceProvider) o).getManagedInstance();\r\n+        else\r\n+            return o;\r\n+    }\r\n+}\r"},{"sha":"37ad42064d2d4035ae6702092b28eee10961dc52","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","status":"modified","additions":149,"deletions":149,"changes":298,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,149 +1,149 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.util;\n-\n-import java.io.Serializable;\n-\n-import org.apache.openjpa.lib.util.ReferenceMap;\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n-\n-/**\n- * Identity class extended by builtin OpenJPA identity objects.\n- *\n- * @author Steve Kim\n- */\n-public abstract class OpenJPAId\n-    implements Comparable, Serializable {\n-\n-    // cache the types' generated hashcodes\n-    private static ConcurrentReferenceHashMap _typeCache =\n-        new ConcurrentReferenceHashMap(ReferenceMap.WEAK, ReferenceMap.HARD);\n-\n-    protected Class type;\n-    protected boolean subs = true;\n-\n-    // type has his based on the least-derived non-object class so that\n-    // user-given ids with non-exact types match ids with exact types\n-    private transient int _typeHash = 0;\n-\n-    protected OpenJPAId() {\n-    }\n-\n-    protected OpenJPAId(Class type) {\n-        this.type = type;\n-    }\n-\n-    protected OpenJPAId(Class type, boolean subs) {\n-        this.type = type;\n-        this.subs = subs;\n-    }\n-\n-    /**\n-     * Return the persitent class which this id instance represents.\n-     */\n-    public Class getType() {\n-        return type;\n-    }\n-\n-    /**\n-     * Whether this oid might be for a subclass of the given type.\n-     * Defaults to true.\n-     */\n-    public boolean hasSubclasses() {\n-        return subs;\n-    }\n-\n-    /**\n-     * Set the exact type of the described instance once it is known.\n-     */\n-    public void setManagedInstanceType(Class type) {\n-        this.type = type;\n-        this.subs = false;\n-    }\n-\n-    /**\n-     * Set the exact type of the described instance once it is known.\n-     */\n-    public void setManagedInstanceType(Class type, boolean subs) {\n-        this.type = type;\n-        this.subs = subs;\n-    }\n-\n-    /**\n-     * Return the identity value as an object.\n-     */\n-    public abstract Object getIdObject();\n-\n-    /**\n-     * Return the id's hash code.\n-     */\n-    protected abstract int idHash();\n-\n-    /**\n-     * Compare the id to the id of the given instance.\n-     */\n-    protected abstract boolean idEquals(OpenJPAId other);\n-\n-    /**\n-     * Generate the hashcode for this Id.  Cache the type's generated hashcode\n-     * so that it doesn't have to be generated each time.\n-     */\n-    public int hashCode() {\n-        if (_typeHash == 0) {\n-            Integer typeHashInt = (Integer) _typeCache.get(type);\n-            if (typeHashInt == null) {\n-                Class base = type;\n-                Class superclass = base.getSuperclass();\n-                while (superclass != null && superclass != Object.class) {\n-                    base = base.getSuperclass();\n-                    superclass = base.getSuperclass();\n-                }\n-                _typeHash = base.hashCode();\n-                _typeCache.put(type, new Integer(_typeHash));\n-            } else {\n-                _typeHash = typeHashInt.intValue();\n-            }\n-        }\n-        return _typeHash ^ idHash();\n-    }\n-\n-    public boolean equals(Object o) {\n-        if (o == this)\n-            return true;\n-        if (o == null || getClass() != o.getClass())\n-            return false;\n-\n-        OpenJPAId id = (OpenJPAId) o;\n-        return idEquals(id) && (id.type.isAssignableFrom(type)\n-            || (subs && type.isAssignableFrom(id.type)));\n-    }\n-\n-    public String toString() {\n-        return type.getName() + \"-\" + getIdObject();\n-    }\n-\n-    public int compareTo(Object other) {\n-        if (other == this)\n-            return 0;\n-        if (other == null)\n-            return 1;\n-        return ((Comparable) getIdObject()).compareTo(((OpenJPAId) other).\n-            getIdObject ());\n-\t}\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.util;\r\n+\r\n+import java.io.Serializable;\r\n+\r\n+import org.apache.openjpa.lib.util.ReferenceMap;\r\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\r\n+\r\n+/**\r\n+ * Identity class extended by builtin OpenJPA identity objects.\r\n+ *\r\n+ * @author Steve Kim\r\n+ */\r\n+public abstract class OpenJPAId\r\n+    implements Comparable, Serializable {\r\n+\r\n+    // cache the types' generated hashcodes\r\n+    private static ConcurrentReferenceHashMap _typeCache =\r\n+        new ConcurrentReferenceHashMap(ReferenceMap.WEAK, ReferenceMap.HARD);\r\n+\r\n+    protected Class type;\r\n+    protected boolean subs = true;\r\n+\r\n+    // type has his based on the least-derived non-object class so that\r\n+    // user-given ids with non-exact types match ids with exact types\r\n+    private transient int _typeHash = 0;\r\n+\r\n+    protected OpenJPAId() {\r\n+    }\r\n+\r\n+    protected OpenJPAId(Class type) {\r\n+        this.type = type;\r\n+    }\r\n+\r\n+    protected OpenJPAId(Class type, boolean subs) {\r\n+        this.type = type;\r\n+        this.subs = subs;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the persitent class which this id instance represents.\r\n+     */\r\n+    public Class getType() {\r\n+        return type;\r\n+    }\r\n+\r\n+    /**\r\n+     * Whether this oid might be for a subclass of the given type.\r\n+     * Defaults to true.\r\n+     */\r\n+    public boolean hasSubclasses() {\r\n+        return subs;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the exact type of the described instance once it is known.\r\n+     */\r\n+    public void setManagedInstanceType(Class type) {\r\n+        this.type = type;\r\n+        this.subs = false;\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the exact type of the described instance once it is known.\r\n+     */\r\n+    public void setManagedInstanceType(Class type, boolean subs) {\r\n+        this.type = type;\r\n+        this.subs = subs;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the identity value as an object.\r\n+     */\r\n+    public abstract Object getIdObject();\r\n+\r\n+    /**\r\n+     * Return the id's hash code.\r\n+     */\r\n+    protected abstract int idHash();\r\n+\r\n+    /**\r\n+     * Compare the id to the id of the given instance.\r\n+     */\r\n+    protected abstract boolean idEquals(OpenJPAId other);\r\n+\r\n+    /**\r\n+     * Generate the hashcode for this Id.  Cache the type's generated hashcode\r\n+     * so that it doesn't have to be generated each time.\r\n+     */\r\n+    public int hashCode() {\r\n+        if (_typeHash == 0) {\r\n+            Integer typeHashInt = (Integer) _typeCache.get(type);\r\n+            if (typeHashInt == null) {\r\n+                Class base = type;\r\n+                Class superclass = base.getSuperclass();\r\n+                while (superclass != null && superclass != Object.class) {\r\n+                    base = base.getSuperclass();\r\n+                    superclass = base.getSuperclass();\r\n+                }\r\n+                _typeHash = base.hashCode();\r\n+                _typeCache.put(type, new Integer(_typeHash));\r\n+            } else {\r\n+                _typeHash = typeHashInt.intValue();\r\n+            }\r\n+        }\r\n+        return _typeHash ^ idHash();\r\n+    }\r\n+\r\n+    public boolean equals(Object o) {\r\n+        if (o == this)\r\n+            return true;\r\n+        if (o == null || getClass() != o.getClass())\r\n+            return false;\r\n+\r\n+        OpenJPAId id = (OpenJPAId) o;\r\n+        return idEquals(id) && (id.type.isAssignableFrom(type)\r\n+            || (subs && type.isAssignableFrom(id.type)));\r\n+    }\r\n+\r\n+    public String toString() {\r\n+        return type.getName() + \"-\" + getIdObject();\r\n+    }\r\n+\r\n+    public int compareTo(Object other) {\r\n+        if (other == this)\r\n+            return 0;\r\n+        if (other == null)\r\n+            return 1;\r\n+        return ((Comparable) getIdObject()).compareTo(((OpenJPAId) other).\r\n+            getIdObject ());\r\n+\t}\r\n+}\r"},{"sha":"9048d2151ebf0cfc2639f2ffc499c727a2b48d17","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","status":"modified","additions":1662,"deletions":1672,"changes":3334,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"8d4bcd457b196418511b2f143a509ba15e8fa72a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -21,7 +21,7 @@\n import java.util.Map;\r\n \r\n import org.apache.openjpa.kernel.StoreManager;\r\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n \r\n /**\r\n  * Repository of store-specific facade classes. This is used by facade \r"},{"sha":"1254cd79c1104191ef829d37bf290d375182b8eb","filename":"openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","previous_filename":"openjpa-kernel-5/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java"},{"sha":"36480b01642a644cb7c15c98540f1aed34dbe485","filename":"openjpa-lib-5/pom.xml","status":"removed","additions":0,"deletions":55,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib-5/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib-5/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib-5/pom.xml?ref=6af619cd891e793efe4c239f4e4815b89d119d49","patch":"@@ -1,55 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n-<!--\r\n- Licensed to the Apache Software Foundation (ASF) under one\r\n- or more contributor license agreements.  See the NOTICE file\r\n- distributed with this work for additional information\r\n- regarding copyright ownership.  The ASF licenses this file\r\n- to you under the Apache License, Version 2.0 (the\r\n- \"License\"); you may not use this file except in compliance\r\n- with the License.  You may obtain a copy of the License at\r\n-\r\n- http://www.apache.org/licenses/LICENSE-2.0\r\n-\r\n- Unless required by applicable law or agreed to in writing,\r\n- software distributed under the License is distributed on an\r\n- \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- KIND, either express or implied.  See the License for the\r\n- specific language governing permissions and limitations\r\n- under the License.\r\n--->\r\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n-         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n-         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\r\n-    <modelVersion>4.0.0</modelVersion>\r\n-    <groupId>org.apache.openjpa</groupId>\r\n-    <artifactId>openjpa-lib-5</artifactId>\r\n-    <packaging>jar</packaging>\r\n-    <name>OpenJPA Utilities 1.5</name>\r\n-    <description>OpenJPA Utilities 1.5</description>\r\n-    <url>http://openjpa.apache.org</url>\r\n-    <parent>\r\n-        <groupId>org.apache.openjpa</groupId>\r\n-        <artifactId>openjpa-parent</artifactId>\r\n-        <version>1.1.0-SNAPSHOT</version>\r\n-    </parent>\r\n-    <dependencies>\r\n-        <dependency>\r\n-            <groupId>org.apache.openjpa</groupId>\r\n-            <artifactId>openjpa-lib</artifactId>\r\n-            <version>${pom.version}</version>\r\n-            <scope>compile</scope>\r\n-        </dependency>\r\n-    </dependencies>\r\n-    <build>\r\n-        <plugins>\r\n-            <plugin>\r\n-                <groupId>org.apache.maven.plugins</groupId>\r\n-                <artifactId>maven-compiler-plugin</artifactId>\r\n-                <configuration>\r\n-                    <source>1.5</source>\r\n-                    <target>1.5</target>\r\n-                </configuration>\r\n-            </plugin>\r\n-        </plugins>\r\n-    </build>\r\n-</project>\r"},{"sha":"0479b2474e0049e00ff1c5e196df59c5dd82f97a","filename":"openjpa-lib-5/src/main/java/org/apache/openjpa/lib/util/Timestamp5Helper.java","status":"removed","additions":0,"deletions":56,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib-5/src/main/java/org/apache/openjpa/lib/util/Timestamp5Helper.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib-5/src/main/java/org/apache/openjpa/lib/util/Timestamp5Helper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib-5/src/main/java/org/apache/openjpa/lib/util/Timestamp5Helper.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49","patch":"@@ -1,56 +0,0 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.lib.util;\r\n-\r\n-import java.sql.Timestamp;\r\n-\r\n-/**\r\n- * Helper class to create java.sql.Timestamp object with nanosecond precision.\r\n- * This is only available since JDB 5.\r\n- * \r\n- * @author Albert Lee\r\n- */\r\n-public final class Timestamp5Helper extends TimestampHelper{\r\n-\r\n-    // number of seconds passed 1970/1/1 00:00:00 GMT.\r\n-    private static long sec0;\r\n-    // fraction of seconds passed 1970/1/1 00:00:00 GMT, offset by\r\n-    // the base System.nanoTime (nano0), in nanosecond unit.\r\n-    private static long nano0;\r\n-\r\n-    static {\r\n-        // initialize base time in second and fraction of second (ns).\r\n-        long curTime = System.currentTimeMillis();\r\n-        sec0 = curTime / MilliMuliplier;\r\n-        nano0 = (curTime % MilliMuliplier) * MicroMuliplier - System.nanoTime();\r\n-    }\r\n-\r\n-    /*\r\n-     * This class implements a nanosecond precision Timestamp.\r\n-     */\r\n-    protected Timestamp getTimestamp() {\r\n-        long nano_delta = nano0 + System.nanoTime();\r\n-        long sec1 = sec0 + (nano_delta / NanoMuliplier);\r\n-        long nano1 = nano_delta % NanoMuliplier;\r\n-\r\n-        Timestamp rtnTs = new Timestamp(sec1 * MilliMuliplier);\r\n-        rtnTs.setNanos((int) nano1);\r\n-        return rtnTs;\r\n-    }\r\n-}\r"},{"sha":"6cef49c16143baa5a26a9d52942945e4b2265899","filename":"openjpa-lib/pom.xml","status":"modified","additions":2,"deletions":22,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/pom.xml?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -32,26 +32,6 @@\n         <artifactId>openjpa-parent</artifactId>\n         <version>1.1.0-SNAPSHOT</version>\n     </parent>\n-    <profiles>\n-        <profile>\n-            <id>java14-validate</id>\n-            <activation><property><name>java14.jar</name></property></activation>\n-            <build>\n-                <pluginManagement>\n-                    <plugins>\n-                        <plugin>\n-                            <artifactId>maven-compiler-plugin</artifactId>\n-                            <configuration>\n-                                <compilerArguments>\n-                                    <bootclasspath>${java14.jar}</bootclasspath>\n-                                </compilerArguments>\n-                            </configuration>\n-                        </plugin>\n-                    </plugins>\n-                </pluginManagement>\n-            </build>\n-        </profile>\n-    </profiles>\n     <dependencies>\n         <dependency>\n             <groupId>jakarta-regexp</groupId>\n@@ -94,8 +74,8 @@\n             <plugin>\n                 <artifactId>maven-compiler-plugin</artifactId>\n                 <configuration>\n-                    <source>1.4</source>\n-                    <target>1.4</target>\n+                    <source>1.5</source>\n+                    <target>1.5</target>\n                 </configuration>\n             </plugin>\n             <!--"},{"sha":"c2854589cf34de03cecab8471aee1a3f363e5709","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","status":"modified","additions":718,"deletions":718,"changes":1436,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,718 +1,718 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.lib.conf;\n-\n-import java.io.File;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.MissingResourceException;\n-import java.util.Properties;\n-import java.util.TreeSet;\n-import javax.naming.Context;\n-import javax.naming.InitialContext;\n-import javax.naming.NamingException;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.apache.commons.lang.exception.NestableRuntimeException;\n-import org.apache.openjpa.lib.log.Log;\n-import org.apache.openjpa.lib.util.J2DoPrivHelper;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.util.Options;\n-import org.apache.openjpa.lib.util.ParseException;\n-import org.apache.openjpa.lib.util.StringDistance;\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n-import serp.util.Strings;\n-\n-/**\n- * Utility methods dealing with configuration.\n- *\n- * @author Abe White\n- * @nojavadoc\n- */\n-public class Configurations {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (Configurations.class);\n-    \n-    private static final ConcurrentReferenceHashMap _loaders = new\n-        ConcurrentReferenceHashMap(ConcurrentReferenceHashMap.WEAK, \n-                ConcurrentReferenceHashMap.HARD);\n-\n-    private static final Object NULL_LOADER = \"null-loader\";\n-\n-    /**\n-     * Return the class name from the given plugin string, or null if none.\n-     */\n-    public static String getClassName(String plugin) {\n-        return getPluginComponent(plugin, true);\n-    }\n-\n-    /**\n-     * Return the properties part of the given plugin string, or null if none.\n-     */\n-    public static String getProperties(String plugin) {\n-        return getPluginComponent(plugin, false);\n-    }\n-\n-    /**\n-     * Return either the class name or properties string from a plugin string.\n-     */\n-    private static String getPluginComponent(String plugin, boolean clsName) {\n-        if (plugin != null)\n-            plugin = plugin.trim();\n-        if (StringUtils.isEmpty(plugin))\n-            return null;\n-\n-        int openParen = -1;\n-        if (plugin.charAt(plugin.length() - 1) == ')')\n-            openParen = plugin.indexOf('(');\n-        if (openParen == -1) {\n-            int eq = plugin.indexOf('=');\n-            if (eq == -1)\n-                return (clsName) ? plugin : null;\n-            return (clsName) ? null : plugin;\n-        }\n-\n-        // clsName(props) form\n-        if (clsName)\n-            return plugin.substring(0, openParen).trim();\n-        String prop = plugin.substring(openParen + 1,\n-            plugin.length() - 1).trim();\n-        return (prop.length() == 0) ? null : prop;\n-    }\n-\n-    /**\n-     * Combine the given class name and properties into a plugin string.\n-     */\n-    public static String getPlugin(String clsName, String props) {\n-        if (StringUtils.isEmpty(clsName))\n-            return props;\n-        if (StringUtils.isEmpty(props))\n-            return clsName;\n-        return clsName + \"(\" + props + \")\";\n-    }\n-\n-    /**\n-     * Return a plugin string that combines the properties of the given plugin\n-     * strings, where properties of <code>override</code> will override the\n-     * same properties of <code>orig</code>.\n-     */\n-    public static String combinePlugins(String orig, String override) {\n-        if (StringUtils.isEmpty(orig))\n-            return override;\n-        if (StringUtils.isEmpty(override))\n-            return orig;\n-\n-        String origCls = getClassName(orig);\n-        String overrideCls = getClassName(override);\n-        String cls;\n-        if (StringUtils.isEmpty(origCls))\n-            cls = overrideCls;\n-        else if (StringUtils.isEmpty(overrideCls))\n-            cls = origCls;\n-        else if (!origCls.equals(overrideCls))\n-            return override; // completely different plugin\n-        else\n-            cls = origCls;\n-\n-        String origProps = getProperties(orig);\n-        String overrideProps = getProperties(override);\n-        if (StringUtils.isEmpty(origProps))\n-            return getPlugin(cls, overrideProps);\n-        if (StringUtils.isEmpty(overrideProps))\n-            return getPlugin(cls, origProps);\n-\n-        Properties props = parseProperties(origProps);\n-        props.putAll(parseProperties(overrideProps));\n-        return getPlugin(cls, serializeProperties(props)); \n-    }\n-\n-    /**\n-     * Create the instance with the given class name, using the given\n-     * class loader. No configuration of the instance is performed by\n-     * this method.\n-     */\n-    public static Object newInstance(String clsName, ClassLoader loader) {\n-        return newInstance(clsName, null, null, loader, true);\n-    }\n-\n-    /**\n-     * Create and configure an instance with the given class name and\n-     * properties.\n-     */\n-    public static Object newInstance(String clsName, Configuration conf,\n-        String props, ClassLoader loader) {\n-        Object obj = newInstance(clsName, null, conf, loader, true);\n-        configureInstance(obj, conf, props);\n-        return obj;\n-    }\n-\n-    /**\n-     * Helper method used by members of this package to instantiate plugin\n-     * values.\n-     */\n-    static Object newInstance(String clsName, Value val, Configuration conf,\n-        ClassLoader loader, boolean fatal) {\n-        if (StringUtils.isEmpty(clsName))\n-            return null;\n-\n-        Class cls = null; \n-\n-        while (cls == null) {\n-            // can't have a null reference in the map, so use symbolic\n-            // constant as key\n-            Object key = loader == null ? NULL_LOADER : loader;\n-            Map loaderCache = (Map) _loaders.get(key);\n-            if (loaderCache == null) { // We don't have a cache for this loader.\n-                loaderCache = new ConcurrentHashMap();\n-                _loaders.put(key, loaderCache);\n-            } else {  // We have a cache for this loader.\n-                cls = (Class) loaderCache.get(clsName);\n-            }\n-\n-            if (cls == null) {\n-                try {\n-                    cls = Strings.toClass(clsName, findDerivedLoader(conf,\n-                            loader));\n-                    loaderCache.put(clsName, cls);\n-                } catch (RuntimeException re) {\n-                    if (loader != null)  // Try one more time with loader=null\n-                        loader = null;\n-                    else {\n-                        if (val != null)\n-                            re = getCreateException(clsName, val, re);\n-                        if (fatal)\n-                            throw re;\n-                        Log log = (conf == null) ? null : conf\n-                                .getConfigurationLog();\n-                        if (log != null && log.isErrorEnabled())\n-                            log.error(_loc\n-                                    .get(\"plugin-creation-exception\", val), re);\n-                        return null;\n-                    }\n-                }\n-            }\n-        }\n-\n-        try {\n-            return AccessController.doPrivileged(\n-                J2DoPrivHelper.newInstanceAction(cls));\n-        } catch (Exception e) {\n-            if (e instanceof PrivilegedActionException) {\n-                e = ((PrivilegedActionException) e).getException();   \n-            }\n-            RuntimeException re = new NestableRuntimeException(_loc.get\n-                (\"obj-create\", cls).getMessage(), e);\n-            if (fatal)\n-                throw re;\n-            Log log = (conf == null) ? null : conf.getConfigurationLog();\n-            if (log != null && log.isErrorEnabled())\n-                log.error(_loc.get(\"plugin-creation-exception\", val), re);\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Attempt to find a derived loader that delegates to our target loader.\n-     * This allows application loaders that delegate appropriately for known\n-     * classes first crack at class names.\n-     */\n-    private static ClassLoader findDerivedLoader(Configuration conf,\n-        ClassLoader loader) {\n-        // we always prefer the thread loader, because it's the only thing we\n-        // can access that isn't bound to the OpenJPA classloader, unless\n-        // the conf object is of a custom class\n-        ClassLoader ctxLoader = (ClassLoader) AccessController.doPrivileged(\n-            J2DoPrivHelper.getContextClassLoaderAction());\n-        if (loader == null) {\n-            if (ctxLoader != null)\n-                return ctxLoader;\n-            if (conf != null)\n-                return (ClassLoader) AccessController.doPrivileged(\n-                    J2DoPrivHelper.getClassLoaderAction(conf.getClass())); \n-            return Configurations.class.getClassLoader();\n-        }\n-\n-        for (ClassLoader parent = ctxLoader; parent != null; \n-            parent = (ClassLoader) AccessController.doPrivileged(\n-                J2DoPrivHelper.getParentAction(parent))) {\n-            if (parent == loader)\n-                return ctxLoader;\n-        }\n-        if (conf != null) {\n-            for (ClassLoader parent = (ClassLoader)\n-                AccessController.doPrivileged(\n-                    J2DoPrivHelper.getClassLoaderAction(conf.getClass())); \n-                parent != null; \n-                parent = (ClassLoader) AccessController.doPrivileged(\n-                    J2DoPrivHelper.getParentAction(parent))) {\n-                if (parent == loader)\n-                    return (ClassLoader) AccessController.doPrivileged(\n-                        J2DoPrivHelper.getClassLoaderAction(conf.getClass())); \n-            }\n-        }\n-        return loader;\n-    }\n-\n-    /**\n-     * Return a List<String> of all the fully-qualified anchors specified in the\n-     * properties location listed in <code>opts</code>. If no properties\n-     * location is listed in <code>opts</code>, this returns whatever the\n-     * product derivations can find in their default configurations.\n-     * If the properties location specified in <code>opts</code> already\n-     * contains an anchor spec, this returns that anchor. Note that in this\n-     * fully-qualified-input case, the logic involving product derivations\n-     * and resource parsing is short-circuited, so this method\n-     * should not be used as a means to test that a particular anchor is\n-     * defined in a given location by invoking with a fully-qualified anchor.\n-     *\n-     * This does not mutate <code>opts</code>.\n-     *\n-     * @since 1.1.0\n-     */\n-    public static List getFullyQualifiedAnchorsInPropertiesLocation(\n-        Options opts) {\n-        String props = opts.getProperty(\"properties\", \"p\", null);\n-        if (props != null) {\n-            int anchorPosition = props.indexOf(\"#\");\n-            if (anchorPosition > -1)\n-                return Arrays.asList(new String[] { props });\n-        }\n-\n-        return ProductDerivations.getFullyQualifiedAnchorsInPropertiesLocation(\n-            props);\n-    }\n-\n-    /**\n-     * Set the given {@link Configuration} instance from the command line\n-     * options provided. All property names of the given configuration are\n-     * recognized; additionally, if a <code>properties</code> or\n-     * <code>p</code> argument exists, the resource it\n-     * points to will be loaded and set into the given configuration instance.\n-     * It can point to either a file or a resource name.\n-     */\n-    public static void populateConfiguration(Configuration conf, Options opts) {\n-        String props = opts.removeProperty(\"properties\", \"p\", null);\n-        ConfigurationProvider provider;\n-        if (!StringUtils.isEmpty(props)) {\n-            String path = props;\n-            String anchor = null;\n-            int idx = path.lastIndexOf('#');\n-            if (idx != -1) {\n-                if (idx < path.length() - 1)\n-                    anchor = path.substring(idx + 1);\n-                path = path.substring(0, idx);\n-                if (path.length() == 0)\n-                    throw new MissingResourceException(_loc.get(\"anchor-only\",\n-                        props).getMessage(), Configurations.class.getName(), \n-                        props);\n-            }\n-\n-            File file = new File(path);\n-            if (((Boolean) AccessController.doPrivileged(J2DoPrivHelper\n-                .isFileAction(file))).booleanValue())\n-                provider = ProductDerivations.load(file, anchor, null);\n-            else {\n-                file = new File(\"META-INF\" + File.separatorChar + path);\n-                if (((Boolean) AccessController.doPrivileged(J2DoPrivHelper\n-                    .isFileAction(file))).booleanValue())\n-                    provider = ProductDerivations.load(file, anchor, null);\n-                else\n-                    provider = ProductDerivations.load(path, anchor, null);\n-            }\n-            if (provider != null)\n-                provider.setInto(conf);\n-            else\n-                throw new MissingResourceException(_loc.get(\"no-provider\",\n-                    props).getMessage(), Configurations.class.getName(), \n-                    props);\n-        } else {\n-            provider = ProductDerivations.loadDefaults(null);\n-            if (provider != null)\n-                provider.setInto(conf);\n-        }\n-        opts.setInto(conf);\n-    }\n-\n-    /**\n-     * Helper method to throw an informative description on instantiation error.\n-     */\n-    private static RuntimeException getCreateException(String clsName,\n-        Value val, Exception e) {\n-        // re-throw the exception with some better information\n-        final String msg;\n-        final Object[] params;\n-\n-        String alias = val.alias(clsName);\n-        String[] aliases = val.getAliases();\n-        String[] keys;\n-        if (aliases.length == 0)\n-            keys = aliases;\n-        else {\n-            keys = new String[aliases.length / 2];\n-            for (int i = 0; i < aliases.length; i += 2)\n-                keys[i / 2] = aliases[i];\n-        }\n-\n-        String closest;\n-        if (keys.length == 0) {\n-            msg = \"invalid-plugin\";\n-            params = new Object[]{ val.getProperty(), alias, e.toString(), };\n-        } else if ((closest = StringDistance.getClosestLevenshteinDistance\n-            (alias, keys, 0.5f)) == null) {\n-            msg = \"invalid-plugin-aliases\";\n-            params = new Object[]{\n-                val.getProperty(), alias, e.toString(),\n-                new TreeSet(Arrays.asList(keys)), };\n-        } else {\n-            msg = \"invalid-plugin-aliases-hint\";\n-            params = new Object[]{\n-                val.getProperty(), alias, e.toString(),\n-                new TreeSet(Arrays.asList(keys)), closest, };\n-        }\n-        return new ParseException(_loc.get(msg, params), e);\n-    }\n-\n-    /**\n-     * Configures the given object with the given properties by\n-     * matching the properties string to the object's setter\n-     * methods. The properties string should be in the form\n-     * \"prop1=val1, prop2=val2 ...\". Does not validate that setter\n-     * methods exist for the properties.\n-     *\n-     * @throws RuntimeException on configuration error\n-     */\n-    public static void configureInstance(Object obj, Configuration conf,\n-        String properties) {\n-        configureInstance(obj, conf, properties, null);\n-    }\n-\n-    /**\n-     * Configures the given object with the given properties by\n-     * matching the properties string to the object's setter\n-     * methods. The properties string should be in the form\n-     * \"prop1=val1, prop2=val2 ...\". Validates that setter methods\n-     * exist for the properties.\n-     *\n-     * @throws RuntimeException on configuration error\n-     */\n-    public static void configureInstance(Object obj, Configuration conf,\n-        String properties, String configurationName) {\n-        if (obj == null)\n-            return;\n-\n-        Properties props = null;\n-        if (!StringUtils.isEmpty(properties))\n-            props = parseProperties(properties);\n-        configureInstance(obj, conf, props, configurationName);\n-    }\n-\n-    /**\n-     * Configures the given object with the given properties by\n-     * matching the properties string to the object's setter\n-     * methods. Does not validate that setter methods exist for the properties.\n-     *\n-     * @throws RuntimeException on configuration error\n-     */\n-    public static void configureInstance(Object obj, Configuration conf,\n-        Properties properties) {\n-        configureInstance(obj, conf, properties, null);\n-    }\n-\n-    /**\n-     * Configures the given object with the given properties by\n-     * matching the properties string to the object's setter\n-     * methods. If <code>configurationName</code> is\n-     * non-<code>null</code>, validates that setter methods exist for\n-     * the properties.\n-     *\n-     * @throws RuntimeException on configuration error\n-     */\n-    public static void configureInstance(Object obj, Configuration conf,\n-        Properties properties, String configurationName) {\n-        if (obj == null)\n-            return;\n-\n-        Options opts;\n-        if (properties instanceof Options)\n-            opts = (Options) properties;\n-        else { \n-            opts = new Options();\n-            if (properties != null)\n-                opts.putAll(properties);\n-        }\n-\n-        Configurable configurable = null;\n-        if (conf != null && obj instanceof Configurable)\n-            configurable = (Configurable) obj;\n-\n-        if (configurable != null) {\n-            configurable.setConfiguration(conf);\n-            configurable.startConfiguration();\n-        }\n-        Options invalidEntries = opts.setInto(obj);\n-        if (obj instanceof GenericConfigurable)\n-            ((GenericConfigurable) obj).setInto(invalidEntries);\n-\n-\t\tif (!invalidEntries.isEmpty() && configurationName != null) {\n-\t\t\tLocalizer.Message msg = null;\n-\t\t\tString first = (String) invalidEntries.keySet().iterator().next();\n-\t\t\tif (invalidEntries.keySet().size() == 1 &&\n-\t\t\t\tfirst.indexOf('.') == -1) {\n-\t\t\t\t// if there's just one misspelling and this is not a\n-\t\t\t\t// path traversal, check for near misses.\n-\t\t\t\tCollection options = findOptionsFor(obj.getClass());\n-\t\t\t\tString close = StringDistance.getClosestLevenshteinDistance\n-\t\t\t\t\t(first, options, 0.75f);\n-\t\t\t\tif (close != null)\n-\t\t\t\t\tmsg = _loc.get(\"invalid-config-param-hint\", new Object[]{\n-\t\t\t\t\t\tconfigurationName, obj.getClass(), first, close,\n-\t\t\t\t\t\toptions, });\n-\t\t\t}\n-\n-            if (msg == null) {\n-                msg = _loc.get(\"invalid-config-params\", new String[]{\n-                    configurationName, obj.getClass().getName(),\n-                    invalidEntries.keySet().toString(),\n-                    findOptionsFor(obj.getClass()).toString(), });\n-            }\n-            throw new ParseException(msg);\n-        }\n-        if (configurable != null)\n-            configurable.endConfiguration();\n-    }\n-\n-    private static Collection findOptionsFor(Class cls) {\n-        Collection c = Options.findOptionsFor(cls);\n-        \n-        // remove Configurable.setConfiguration() and \n-        // GenericConfigurable.setInto() from the set, if applicable.\n-        if (Configurable.class.isAssignableFrom(cls))\n-            c.remove(\"Configuration\");\n-        if (GenericConfigurable.class.isAssignableFrom(cls))\n-            c.remove(\"Into\");\n-        \n-        return c;\n-    }\n-\n-    /**\n-     * Turn a set of properties into a comma-separated string.\n-     */\n-    public static String serializeProperties(Map map) {\n-        if (map == null || map.isEmpty())\n-            return null;\n-\n-        StringBuffer buf = new StringBuffer();\n-        Map.Entry entry;\n-        String val;\n-        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n-            entry = (Map.Entry) itr.next();\n-            if (buf.length() > 0)\n-                buf.append(\", \");\n-            buf.append(entry.getKey()).append('=');\n-            val = String.valueOf(entry.getValue());\n-            if (val.indexOf(',') != -1)\n-                buf.append('\"').append(val).append('\"');\n-            else\n-                buf.append(val);\n-        }\n-        return buf.toString();\n-    }\n-\n-    /**\n-     * Parse a set of properties from a comma-separated string.\n-     */\n-    public static Options parseProperties(String properties) {\n-        Options opts = new Options();\n-        properties = StringUtils.trimToNull(properties);\n-        if (properties == null)\n-            return opts;\n-\n-        try {\n-            String[] props = Strings.split(properties, \",\", 0);\n-            int idx;\n-            char quote;\n-            String prop;\n-            String val;\n-            for (int i = 0; i < props.length; i++) {\n-                idx = props[i].indexOf('=');\n-                if (idx == -1) {\n-                    // if the key is not assigned to any value, set the\n-                    // value to the same thing as the key, and continue.\n-                    // This permits GenericConfigurable instances to\n-                    // behave meaningfully. We might consider setting the\n-                    // value to some well-known \"value was not set, but\n-                    // key is present\" string so that instances getting\n-                    // values injected can differentiate between a mentioned\n-                    // property and one set to a particular value.\n-                    prop = props[i];\n-                    val = prop;\n-                } else {\n-                    prop = props[i].substring(0, idx).trim();\n-                    val = props[i].substring(idx + 1).trim();\n-                }\n-\n-                // if the value is quoted, read until the end quote\n-                if (((val.startsWith(\"\\\"\") && val.endsWith(\"\\\"\"))\n-                    || (val.startsWith(\"'\") && val.endsWith(\"'\")))\n-                    && val.length() > 1)\n-                    val = val.substring(1, val.length() - 1);\n-                else if (val.startsWith(\"\\\"\") || val.startsWith(\"'\")) {\n-                    quote = val.charAt(0);\n-                    StringBuffer buf = new StringBuffer(val.substring(1));\n-                    int quotIdx;\n-                    while (++i < props.length) {\n-                        buf.append(\",\");\n-\n-                        quotIdx = props[i].indexOf(quote);\n-                        if (quotIdx != -1) {\n-                            buf.append(props[i].substring(0, quotIdx));\n-                            if (quotIdx + 1 < props[i].length())\n-                                buf.append(props[i].substring(quotIdx + 1));\n-                            break;\n-                        } else\n-                            buf.append(props[i]);\n-                    }\n-                    val = buf.toString();\n-                }\n-                opts.put(prop, val);\n-            }\n-            return opts;\n-        } catch (RuntimeException re) {\n-            throw new ParseException(_loc.get(\"prop-parse\", properties), re);\n-        }\n-    }\n-\n-    /**\n-     * Looks up the given name in JNDI. If the name is null, null is returned.\n-     */\n-    public static Object lookup(String name) {\n-        if (StringUtils.isEmpty(name))\n-            return null;\n-\n-        Context ctx = null;\n-        try {\n-            ctx = new InitialContext();\n-            return ctx.lookup(name);\n-        } catch (NamingException ne) {\n-            throw new NestableRuntimeException(\n-                _loc.get(\"naming-err\", name).getMessage(), ne);\n-        } finally {\n-            if (ctx != null)\n-                try { ctx.close(); } catch (Exception e) {}\n-        }\n-    }\n-\n-    /**\n-     * Test whether the map contains the given partial key, prefixed with any\n-     * possible configuration prefix.\n-     */\n-    public static boolean containsProperty(String partialKey, Map props) {\n-        if (partialKey == null || props == null || props.isEmpty())\n-            return false;\n-        else\n-            return props.containsKey(\n-                ProductDerivations.getConfigurationKey(partialKey, props));\n-    }\n-\n-    /**\n-     * Get the property under the given partial key, prefixed with any possible\n-     * configuration prefix.\n-     */\n-    public static Object getProperty(String partialKey, Map m) {\n-        if (partialKey == null || m == null || m.isEmpty())\n-            return null;\n-        else \n-            return m.get(ProductDerivations.getConfigurationKey(partialKey, m));\n-    }\n-\n-    /**\n-     * Remove the property under the given partial key, prefixed with any\n-     * possible configuration prefix.\n-     */\n-    public static Object removeProperty(String partialKey, Map props) {\n-        if (partialKey == null || props == null || props.isEmpty())\n-            return null;\n-        if (containsProperty(partialKey, props))\n-            return props.remove(ProductDerivations.getConfigurationKey(\n-                partialKey, props));\n-        else\n-            return null;\n-    }\n-\n-    /**\n-     * Runs <code>runnable</code> against all the anchors in the configuration\n-     * pointed to by <code>opts</code>. Each invocation gets a fresh clone of \n-     * <code>opts</code> with the <code>properties</code> option set\n-     * appropriately.\n-     *\n-     * @since 1.1.0\n-     */\n-    public static boolean runAgainstAllAnchors(Options opts,\n-        Configurations.Runnable runnable) {\n-        if (opts.containsKey(\"help\") || opts.containsKey(\"-help\")) {\n-            return false;\n-        }\n-        List anchors =\n-            Configurations.getFullyQualifiedAnchorsInPropertiesLocation(opts);\n-\n-        // We use 'properties' below; get rid of 'p' to avoid conflicts. This\n-        // relies on knowing what getFullyQualifiedAnchorsInPropertiesLocation\n-        // looks for.\n-        if (opts.containsKey(\"p\"))\n-            opts.remove(\"p\");\n-\n-        boolean ret = true;\n-        if (anchors.size() == 0) {\n-            ret = launchRunnable(opts, runnable);\n-        } else {\n-            for (Iterator iter = anchors.iterator(); iter.hasNext(); ) { \n-                Options clonedOptions = (Options) opts.clone();\n-                clonedOptions.setProperty(\"properties\", iter.next().toString());\n-                ret &= launchRunnable(clonedOptions, runnable);\n-            }\n-        }\n-        return ret;\n-    }\n-\n-    private static boolean launchRunnable(Options opts,\n-        Configurations.Runnable runnable) {\n-        boolean ret = true;\n-        try {\n-            ret = runnable.run(opts);\n-        } catch (Exception e) {\n-            if (!(e instanceof RuntimeException))\n-                throw new RuntimeException(e);\n-            else\n-                throw (RuntimeException) e;\n-        }\n-        return ret;\n-    }\n-\n-    public interface Runnable {\n-        public boolean run(Options opts) throws Exception;\n-    }\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.lib.conf;\r\n+\r\n+import java.io.File;\r\n+import java.security.AccessController;\r\n+import java.security.PrivilegedActionException;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.MissingResourceException;\r\n+import java.util.Properties;\r\n+import java.util.TreeSet;\r\n+import javax.naming.Context;\r\n+import javax.naming.InitialContext;\r\n+import javax.naming.NamingException;\r\n+\r\n+import org.apache.commons.lang.StringUtils;\r\n+import org.apache.commons.lang.exception.NestableRuntimeException;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.Options;\r\n+import org.apache.openjpa.lib.util.ParseException;\r\n+import org.apache.openjpa.lib.util.StringDistance;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\r\n+import serp.util.Strings;\r\n+\r\n+/**\r\n+ * Utility methods dealing with configuration.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ */\r\n+public class Configurations {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (Configurations.class);\r\n+    \r\n+    private static final ConcurrentReferenceHashMap _loaders = new\r\n+        ConcurrentReferenceHashMap(ConcurrentReferenceHashMap.WEAK, \r\n+                ConcurrentReferenceHashMap.HARD);\r\n+\r\n+    private static final Object NULL_LOADER = \"null-loader\";\r\n+\r\n+    /**\r\n+     * Return the class name from the given plugin string, or null if none.\r\n+     */\r\n+    public static String getClassName(String plugin) {\r\n+        return getPluginComponent(plugin, true);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the properties part of the given plugin string, or null if none.\r\n+     */\r\n+    public static String getProperties(String plugin) {\r\n+        return getPluginComponent(plugin, false);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return either the class name or properties string from a plugin string.\r\n+     */\r\n+    private static String getPluginComponent(String plugin, boolean clsName) {\r\n+        if (plugin != null)\r\n+            plugin = plugin.trim();\r\n+        if (StringUtils.isEmpty(plugin))\r\n+            return null;\r\n+\r\n+        int openParen = -1;\r\n+        if (plugin.charAt(plugin.length() - 1) == ')')\r\n+            openParen = plugin.indexOf('(');\r\n+        if (openParen == -1) {\r\n+            int eq = plugin.indexOf('=');\r\n+            if (eq == -1)\r\n+                return (clsName) ? plugin : null;\r\n+            return (clsName) ? null : plugin;\r\n+        }\r\n+\r\n+        // clsName(props) form\r\n+        if (clsName)\r\n+            return plugin.substring(0, openParen).trim();\r\n+        String prop = plugin.substring(openParen + 1,\r\n+            plugin.length() - 1).trim();\r\n+        return (prop.length() == 0) ? null : prop;\r\n+    }\r\n+\r\n+    /**\r\n+     * Combine the given class name and properties into a plugin string.\r\n+     */\r\n+    public static String getPlugin(String clsName, String props) {\r\n+        if (StringUtils.isEmpty(clsName))\r\n+            return props;\r\n+        if (StringUtils.isEmpty(props))\r\n+            return clsName;\r\n+        return clsName + \"(\" + props + \")\";\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a plugin string that combines the properties of the given plugin\r\n+     * strings, where properties of <code>override</code> will override the\r\n+     * same properties of <code>orig</code>.\r\n+     */\r\n+    public static String combinePlugins(String orig, String override) {\r\n+        if (StringUtils.isEmpty(orig))\r\n+            return override;\r\n+        if (StringUtils.isEmpty(override))\r\n+            return orig;\r\n+\r\n+        String origCls = getClassName(orig);\r\n+        String overrideCls = getClassName(override);\r\n+        String cls;\r\n+        if (StringUtils.isEmpty(origCls))\r\n+            cls = overrideCls;\r\n+        else if (StringUtils.isEmpty(overrideCls))\r\n+            cls = origCls;\r\n+        else if (!origCls.equals(overrideCls))\r\n+            return override; // completely different plugin\r\n+        else\r\n+            cls = origCls;\r\n+\r\n+        String origProps = getProperties(orig);\r\n+        String overrideProps = getProperties(override);\r\n+        if (StringUtils.isEmpty(origProps))\r\n+            return getPlugin(cls, overrideProps);\r\n+        if (StringUtils.isEmpty(overrideProps))\r\n+            return getPlugin(cls, origProps);\r\n+\r\n+        Properties props = parseProperties(origProps);\r\n+        props.putAll(parseProperties(overrideProps));\r\n+        return getPlugin(cls, serializeProperties(props)); \r\n+    }\r\n+\r\n+    /**\r\n+     * Create the instance with the given class name, using the given\r\n+     * class loader. No configuration of the instance is performed by\r\n+     * this method.\r\n+     */\r\n+    public static Object newInstance(String clsName, ClassLoader loader) {\r\n+        return newInstance(clsName, null, null, loader, true);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create and configure an instance with the given class name and\r\n+     * properties.\r\n+     */\r\n+    public static Object newInstance(String clsName, Configuration conf,\r\n+        String props, ClassLoader loader) {\r\n+        Object obj = newInstance(clsName, null, conf, loader, true);\r\n+        configureInstance(obj, conf, props);\r\n+        return obj;\r\n+    }\r\n+\r\n+    /**\r\n+     * Helper method used by members of this package to instantiate plugin\r\n+     * values.\r\n+     */\r\n+    static Object newInstance(String clsName, Value val, Configuration conf,\r\n+        ClassLoader loader, boolean fatal) {\r\n+        if (StringUtils.isEmpty(clsName))\r\n+            return null;\r\n+\r\n+        Class cls = null; \r\n+\r\n+        while (cls == null) {\r\n+            // can't have a null reference in the map, so use symbolic\r\n+            // constant as key\r\n+            Object key = loader == null ? NULL_LOADER : loader;\r\n+            Map loaderCache = (Map) _loaders.get(key);\r\n+            if (loaderCache == null) { // We don't have a cache for this loader.\r\n+                loaderCache = new ConcurrentHashMap();\r\n+                _loaders.put(key, loaderCache);\r\n+            } else {  // We have a cache for this loader.\r\n+                cls = (Class) loaderCache.get(clsName);\r\n+            }\r\n+\r\n+            if (cls == null) {\r\n+                try {\r\n+                    cls = Strings.toClass(clsName, findDerivedLoader(conf,\r\n+                            loader));\r\n+                    loaderCache.put(clsName, cls);\r\n+                } catch (RuntimeException re) {\r\n+                    if (loader != null)  // Try one more time with loader=null\r\n+                        loader = null;\r\n+                    else {\r\n+                        if (val != null)\r\n+                            re = getCreateException(clsName, val, re);\r\n+                        if (fatal)\r\n+                            throw re;\r\n+                        Log log = (conf == null) ? null : conf\r\n+                                .getConfigurationLog();\r\n+                        if (log != null && log.isErrorEnabled())\r\n+                            log.error(_loc\r\n+                                    .get(\"plugin-creation-exception\", val), re);\r\n+                        return null;\r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        try {\r\n+            return AccessController.doPrivileged(\r\n+                J2DoPrivHelper.newInstanceAction(cls));\r\n+        } catch (Exception e) {\r\n+            if (e instanceof PrivilegedActionException) {\r\n+                e = ((PrivilegedActionException) e).getException();   \r\n+            }\r\n+            RuntimeException re = new NestableRuntimeException(_loc.get\r\n+                (\"obj-create\", cls).getMessage(), e);\r\n+            if (fatal)\r\n+                throw re;\r\n+            Log log = (conf == null) ? null : conf.getConfigurationLog();\r\n+            if (log != null && log.isErrorEnabled())\r\n+                log.error(_loc.get(\"plugin-creation-exception\", val), re);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Attempt to find a derived loader that delegates to our target loader.\r\n+     * This allows application loaders that delegate appropriately for known\r\n+     * classes first crack at class names.\r\n+     */\r\n+    private static ClassLoader findDerivedLoader(Configuration conf,\r\n+        ClassLoader loader) {\r\n+        // we always prefer the thread loader, because it's the only thing we\r\n+        // can access that isn't bound to the OpenJPA classloader, unless\r\n+        // the conf object is of a custom class\r\n+        ClassLoader ctxLoader = (ClassLoader) AccessController.doPrivileged(\r\n+            J2DoPrivHelper.getContextClassLoaderAction());\r\n+        if (loader == null) {\r\n+            if (ctxLoader != null)\r\n+                return ctxLoader;\r\n+            if (conf != null)\r\n+                return (ClassLoader) AccessController.doPrivileged(\r\n+                    J2DoPrivHelper.getClassLoaderAction(conf.getClass())); \r\n+            return Configurations.class.getClassLoader();\r\n+        }\r\n+\r\n+        for (ClassLoader parent = ctxLoader; parent != null; \r\n+            parent = (ClassLoader) AccessController.doPrivileged(\r\n+                J2DoPrivHelper.getParentAction(parent))) {\r\n+            if (parent == loader)\r\n+                return ctxLoader;\r\n+        }\r\n+        if (conf != null) {\r\n+            for (ClassLoader parent = (ClassLoader)\r\n+                AccessController.doPrivileged(\r\n+                    J2DoPrivHelper.getClassLoaderAction(conf.getClass())); \r\n+                parent != null; \r\n+                parent = (ClassLoader) AccessController.doPrivileged(\r\n+                    J2DoPrivHelper.getParentAction(parent))) {\r\n+                if (parent == loader)\r\n+                    return (ClassLoader) AccessController.doPrivileged(\r\n+                        J2DoPrivHelper.getClassLoaderAction(conf.getClass())); \r\n+            }\r\n+        }\r\n+        return loader;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a List<String> of all the fully-qualified anchors specified in the\r\n+     * properties location listed in <code>opts</code>. If no properties\r\n+     * location is listed in <code>opts</code>, this returns whatever the\r\n+     * product derivations can find in their default configurations.\r\n+     * If the properties location specified in <code>opts</code> already\r\n+     * contains an anchor spec, this returns that anchor. Note that in this\r\n+     * fully-qualified-input case, the logic involving product derivations\r\n+     * and resource parsing is short-circuited, so this method\r\n+     * should not be used as a means to test that a particular anchor is\r\n+     * defined in a given location by invoking with a fully-qualified anchor.\r\n+     *\r\n+     * This does not mutate <code>opts</code>.\r\n+     *\r\n+     * @since 1.1.0\r\n+     */\r\n+    public static List getFullyQualifiedAnchorsInPropertiesLocation(\r\n+        Options opts) {\r\n+        String props = opts.getProperty(\"properties\", \"p\", null);\r\n+        if (props != null) {\r\n+            int anchorPosition = props.indexOf(\"#\");\r\n+            if (anchorPosition > -1)\r\n+                return Arrays.asList(new String[] { props });\r\n+        }\r\n+\r\n+        return ProductDerivations.getFullyQualifiedAnchorsInPropertiesLocation(\r\n+            props);\r\n+    }\r\n+\r\n+    /**\r\n+     * Set the given {@link Configuration} instance from the command line\r\n+     * options provided. All property names of the given configuration are\r\n+     * recognized; additionally, if a <code>properties</code> or\r\n+     * <code>p</code> argument exists, the resource it\r\n+     * points to will be loaded and set into the given configuration instance.\r\n+     * It can point to either a file or a resource name.\r\n+     */\r\n+    public static void populateConfiguration(Configuration conf, Options opts) {\r\n+        String props = opts.removeProperty(\"properties\", \"p\", null);\r\n+        ConfigurationProvider provider;\r\n+        if (!StringUtils.isEmpty(props)) {\r\n+            String path = props;\r\n+            String anchor = null;\r\n+            int idx = path.lastIndexOf('#');\r\n+            if (idx != -1) {\r\n+                if (idx < path.length() - 1)\r\n+                    anchor = path.substring(idx + 1);\r\n+                path = path.substring(0, idx);\r\n+                if (path.length() == 0)\r\n+                    throw new MissingResourceException(_loc.get(\"anchor-only\",\r\n+                        props).getMessage(), Configurations.class.getName(), \r\n+                        props);\r\n+            }\r\n+\r\n+            File file = new File(path);\r\n+            if (((Boolean) AccessController.doPrivileged(J2DoPrivHelper\r\n+                .isFileAction(file))).booleanValue())\r\n+                provider = ProductDerivations.load(file, anchor, null);\r\n+            else {\r\n+                file = new File(\"META-INF\" + File.separatorChar + path);\r\n+                if (((Boolean) AccessController.doPrivileged(J2DoPrivHelper\r\n+                    .isFileAction(file))).booleanValue())\r\n+                    provider = ProductDerivations.load(file, anchor, null);\r\n+                else\r\n+                    provider = ProductDerivations.load(path, anchor, null);\r\n+            }\r\n+            if (provider != null)\r\n+                provider.setInto(conf);\r\n+            else\r\n+                throw new MissingResourceException(_loc.get(\"no-provider\",\r\n+                    props).getMessage(), Configurations.class.getName(), \r\n+                    props);\r\n+        } else {\r\n+            provider = ProductDerivations.loadDefaults(null);\r\n+            if (provider != null)\r\n+                provider.setInto(conf);\r\n+        }\r\n+        opts.setInto(conf);\r\n+    }\r\n+\r\n+    /**\r\n+     * Helper method to throw an informative description on instantiation error.\r\n+     */\r\n+    private static RuntimeException getCreateException(String clsName,\r\n+        Value val, Exception e) {\r\n+        // re-throw the exception with some better information\r\n+        final String msg;\r\n+        final Object[] params;\r\n+\r\n+        String alias = val.alias(clsName);\r\n+        String[] aliases = val.getAliases();\r\n+        String[] keys;\r\n+        if (aliases.length == 0)\r\n+            keys = aliases;\r\n+        else {\r\n+            keys = new String[aliases.length / 2];\r\n+            for (int i = 0; i < aliases.length; i += 2)\r\n+                keys[i / 2] = aliases[i];\r\n+        }\r\n+\r\n+        String closest;\r\n+        if (keys.length == 0) {\r\n+            msg = \"invalid-plugin\";\r\n+            params = new Object[]{ val.getProperty(), alias, e.toString(), };\r\n+        } else if ((closest = StringDistance.getClosestLevenshteinDistance\r\n+            (alias, keys, 0.5f)) == null) {\r\n+            msg = \"invalid-plugin-aliases\";\r\n+            params = new Object[]{\r\n+                val.getProperty(), alias, e.toString(),\r\n+                new TreeSet(Arrays.asList(keys)), };\r\n+        } else {\r\n+            msg = \"invalid-plugin-aliases-hint\";\r\n+            params = new Object[]{\r\n+                val.getProperty(), alias, e.toString(),\r\n+                new TreeSet(Arrays.asList(keys)), closest, };\r\n+        }\r\n+        return new ParseException(_loc.get(msg, params), e);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configures the given object with the given properties by\r\n+     * matching the properties string to the object's setter\r\n+     * methods. The properties string should be in the form\r\n+     * \"prop1=val1, prop2=val2 ...\". Does not validate that setter\r\n+     * methods exist for the properties.\r\n+     *\r\n+     * @throws RuntimeException on configuration error\r\n+     */\r\n+    public static void configureInstance(Object obj, Configuration conf,\r\n+        String properties) {\r\n+        configureInstance(obj, conf, properties, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configures the given object with the given properties by\r\n+     * matching the properties string to the object's setter\r\n+     * methods. The properties string should be in the form\r\n+     * \"prop1=val1, prop2=val2 ...\". Validates that setter methods\r\n+     * exist for the properties.\r\n+     *\r\n+     * @throws RuntimeException on configuration error\r\n+     */\r\n+    public static void configureInstance(Object obj, Configuration conf,\r\n+        String properties, String configurationName) {\r\n+        if (obj == null)\r\n+            return;\r\n+\r\n+        Properties props = null;\r\n+        if (!StringUtils.isEmpty(properties))\r\n+            props = parseProperties(properties);\r\n+        configureInstance(obj, conf, props, configurationName);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configures the given object with the given properties by\r\n+     * matching the properties string to the object's setter\r\n+     * methods. Does not validate that setter methods exist for the properties.\r\n+     *\r\n+     * @throws RuntimeException on configuration error\r\n+     */\r\n+    public static void configureInstance(Object obj, Configuration conf,\r\n+        Properties properties) {\r\n+        configureInstance(obj, conf, properties, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Configures the given object with the given properties by\r\n+     * matching the properties string to the object's setter\r\n+     * methods. If <code>configurationName</code> is\r\n+     * non-<code>null</code>, validates that setter methods exist for\r\n+     * the properties.\r\n+     *\r\n+     * @throws RuntimeException on configuration error\r\n+     */\r\n+    public static void configureInstance(Object obj, Configuration conf,\r\n+        Properties properties, String configurationName) {\r\n+        if (obj == null)\r\n+            return;\r\n+\r\n+        Options opts;\r\n+        if (properties instanceof Options)\r\n+            opts = (Options) properties;\r\n+        else { \r\n+            opts = new Options();\r\n+            if (properties != null)\r\n+                opts.putAll(properties);\r\n+        }\r\n+\r\n+        Configurable configurable = null;\r\n+        if (conf != null && obj instanceof Configurable)\r\n+            configurable = (Configurable) obj;\r\n+\r\n+        if (configurable != null) {\r\n+            configurable.setConfiguration(conf);\r\n+            configurable.startConfiguration();\r\n+        }\r\n+        Options invalidEntries = opts.setInto(obj);\r\n+        if (obj instanceof GenericConfigurable)\r\n+            ((GenericConfigurable) obj).setInto(invalidEntries);\r\n+\r\n+\t\tif (!invalidEntries.isEmpty() && configurationName != null) {\r\n+\t\t\tLocalizer.Message msg = null;\r\n+\t\t\tString first = (String) invalidEntries.keySet().iterator().next();\r\n+\t\t\tif (invalidEntries.keySet().size() == 1 &&\r\n+\t\t\t\tfirst.indexOf('.') == -1) {\r\n+\t\t\t\t// if there's just one misspelling and this is not a\r\n+\t\t\t\t// path traversal, check for near misses.\r\n+\t\t\t\tCollection options = findOptionsFor(obj.getClass());\r\n+\t\t\t\tString close = StringDistance.getClosestLevenshteinDistance\r\n+\t\t\t\t\t(first, options, 0.75f);\r\n+\t\t\t\tif (close != null)\r\n+\t\t\t\t\tmsg = _loc.get(\"invalid-config-param-hint\", new Object[]{\r\n+\t\t\t\t\t\tconfigurationName, obj.getClass(), first, close,\r\n+\t\t\t\t\t\toptions, });\r\n+\t\t\t}\r\n+\r\n+            if (msg == null) {\r\n+                msg = _loc.get(\"invalid-config-params\", new String[]{\r\n+                    configurationName, obj.getClass().getName(),\r\n+                    invalidEntries.keySet().toString(),\r\n+                    findOptionsFor(obj.getClass()).toString(), });\r\n+            }\r\n+            throw new ParseException(msg);\r\n+        }\r\n+        if (configurable != null)\r\n+            configurable.endConfiguration();\r\n+    }\r\n+\r\n+    private static Collection findOptionsFor(Class cls) {\r\n+        Collection c = Options.findOptionsFor(cls);\r\n+        \r\n+        // remove Configurable.setConfiguration() and \r\n+        // GenericConfigurable.setInto() from the set, if applicable.\r\n+        if (Configurable.class.isAssignableFrom(cls))\r\n+            c.remove(\"Configuration\");\r\n+        if (GenericConfigurable.class.isAssignableFrom(cls))\r\n+            c.remove(\"Into\");\r\n+        \r\n+        return c;\r\n+    }\r\n+\r\n+    /**\r\n+     * Turn a set of properties into a comma-separated string.\r\n+     */\r\n+    public static String serializeProperties(Map map) {\r\n+        if (map == null || map.isEmpty())\r\n+            return null;\r\n+\r\n+        StringBuffer buf = new StringBuffer();\r\n+        Map.Entry entry;\r\n+        String val;\r\n+        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\r\n+            entry = (Map.Entry) itr.next();\r\n+            if (buf.length() > 0)\r\n+                buf.append(\", \");\r\n+            buf.append(entry.getKey()).append('=');\r\n+            val = String.valueOf(entry.getValue());\r\n+            if (val.indexOf(',') != -1)\r\n+                buf.append('\"').append(val).append('\"');\r\n+            else\r\n+                buf.append(val);\r\n+        }\r\n+        return buf.toString();\r\n+    }\r\n+\r\n+    /**\r\n+     * Parse a set of properties from a comma-separated string.\r\n+     */\r\n+    public static Options parseProperties(String properties) {\r\n+        Options opts = new Options();\r\n+        properties = StringUtils.trimToNull(properties);\r\n+        if (properties == null)\r\n+            return opts;\r\n+\r\n+        try {\r\n+            String[] props = Strings.split(properties, \",\", 0);\r\n+            int idx;\r\n+            char quote;\r\n+            String prop;\r\n+            String val;\r\n+            for (int i = 0; i < props.length; i++) {\r\n+                idx = props[i].indexOf('=');\r\n+                if (idx == -1) {\r\n+                    // if the key is not assigned to any value, set the\r\n+                    // value to the same thing as the key, and continue.\r\n+                    // This permits GenericConfigurable instances to\r\n+                    // behave meaningfully. We might consider setting the\r\n+                    // value to some well-known \"value was not set, but\r\n+                    // key is present\" string so that instances getting\r\n+                    // values injected can differentiate between a mentioned\r\n+                    // property and one set to a particular value.\r\n+                    prop = props[i];\r\n+                    val = prop;\r\n+                } else {\r\n+                    prop = props[i].substring(0, idx).trim();\r\n+                    val = props[i].substring(idx + 1).trim();\r\n+                }\r\n+\r\n+                // if the value is quoted, read until the end quote\r\n+                if (((val.startsWith(\"\\\"\") && val.endsWith(\"\\\"\"))\r\n+                    || (val.startsWith(\"'\") && val.endsWith(\"'\")))\r\n+                    && val.length() > 1)\r\n+                    val = val.substring(1, val.length() - 1);\r\n+                else if (val.startsWith(\"\\\"\") || val.startsWith(\"'\")) {\r\n+                    quote = val.charAt(0);\r\n+                    StringBuffer buf = new StringBuffer(val.substring(1));\r\n+                    int quotIdx;\r\n+                    while (++i < props.length) {\r\n+                        buf.append(\",\");\r\n+\r\n+                        quotIdx = props[i].indexOf(quote);\r\n+                        if (quotIdx != -1) {\r\n+                            buf.append(props[i].substring(0, quotIdx));\r\n+                            if (quotIdx + 1 < props[i].length())\r\n+                                buf.append(props[i].substring(quotIdx + 1));\r\n+                            break;\r\n+                        } else\r\n+                            buf.append(props[i]);\r\n+                    }\r\n+                    val = buf.toString();\r\n+                }\r\n+                opts.put(prop, val);\r\n+            }\r\n+            return opts;\r\n+        } catch (RuntimeException re) {\r\n+            throw new ParseException(_loc.get(\"prop-parse\", properties), re);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Looks up the given name in JNDI. If the name is null, null is returned.\r\n+     */\r\n+    public static Object lookup(String name) {\r\n+        if (StringUtils.isEmpty(name))\r\n+            return null;\r\n+\r\n+        Context ctx = null;\r\n+        try {\r\n+            ctx = new InitialContext();\r\n+            return ctx.lookup(name);\r\n+        } catch (NamingException ne) {\r\n+            throw new NestableRuntimeException(\r\n+                _loc.get(\"naming-err\", name).getMessage(), ne);\r\n+        } finally {\r\n+            if (ctx != null)\r\n+                try { ctx.close(); } catch (Exception e) {}\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Test whether the map contains the given partial key, prefixed with any\r\n+     * possible configuration prefix.\r\n+     */\r\n+    public static boolean containsProperty(String partialKey, Map props) {\r\n+        if (partialKey == null || props == null || props.isEmpty())\r\n+            return false;\r\n+        else\r\n+            return props.containsKey(\r\n+                ProductDerivations.getConfigurationKey(partialKey, props));\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the property under the given partial key, prefixed with any possible\r\n+     * configuration prefix.\r\n+     */\r\n+    public static Object getProperty(String partialKey, Map m) {\r\n+        if (partialKey == null || m == null || m.isEmpty())\r\n+            return null;\r\n+        else \r\n+            return m.get(ProductDerivations.getConfigurationKey(partialKey, m));\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove the property under the given partial key, prefixed with any\r\n+     * possible configuration prefix.\r\n+     */\r\n+    public static Object removeProperty(String partialKey, Map props) {\r\n+        if (partialKey == null || props == null || props.isEmpty())\r\n+            return null;\r\n+        if (containsProperty(partialKey, props))\r\n+            return props.remove(ProductDerivations.getConfigurationKey(\r\n+                partialKey, props));\r\n+        else\r\n+            return null;\r\n+    }\r\n+\r\n+    /**\r\n+     * Runs <code>runnable</code> against all the anchors in the configuration\r\n+     * pointed to by <code>opts</code>. Each invocation gets a fresh clone of \r\n+     * <code>opts</code> with the <code>properties</code> option set\r\n+     * appropriately.\r\n+     *\r\n+     * @since 1.1.0\r\n+     */\r\n+    public static boolean runAgainstAllAnchors(Options opts,\r\n+        Configurations.Runnable runnable) {\r\n+        if (opts.containsKey(\"help\") || opts.containsKey(\"-help\")) {\r\n+            return false;\r\n+        }\r\n+        List anchors =\r\n+            Configurations.getFullyQualifiedAnchorsInPropertiesLocation(opts);\r\n+\r\n+        // We use 'properties' below; get rid of 'p' to avoid conflicts. This\r\n+        // relies on knowing what getFullyQualifiedAnchorsInPropertiesLocation\r\n+        // looks for.\r\n+        if (opts.containsKey(\"p\"))\r\n+            opts.remove(\"p\");\r\n+\r\n+        boolean ret = true;\r\n+        if (anchors.size() == 0) {\r\n+            ret = launchRunnable(opts, runnable);\r\n+        } else {\r\n+            for (Iterator iter = anchors.iterator(); iter.hasNext(); ) { \r\n+                Options clonedOptions = (Options) opts.clone();\r\n+                clonedOptions.setProperty(\"properties\", iter.next().toString());\r\n+                ret &= launchRunnable(clonedOptions, runnable);\r\n+            }\r\n+        }\r\n+        return ret;\r\n+    }\r\n+\r\n+    private static boolean launchRunnable(Options opts,\r\n+        Configurations.Runnable runnable) {\r\n+        boolean ret = true;\r\n+        try {\r\n+            ret = runnable.run(opts);\r\n+        } catch (Exception e) {\r\n+            if (!(e instanceof RuntimeException))\r\n+                throw new RuntimeException(e);\r\n+            else\r\n+                throw (RuntimeException) e;\r\n+        }\r\n+        return ret;\r\n+    }\r\n+\r\n+    public interface Runnable {\r\n+        public boolean run(Options opts) throws Exception;\r\n+    }\r\n+}\r"},{"sha":"93578493fa4416cca12e981b14b9ba4bd713f4c2","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","status":"modified","additions":138,"deletions":138,"changes":276,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,138 +1,138 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.lib.conf;\n-\n-import java.security.AccessController;\n-\n-import org.apache.commons.lang.ObjectUtils;\n-import org.apache.openjpa.lib.util.J2DoPrivHelper;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.util.ReferenceMap;\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n-\n-/**\n- * An object {@link Value}.\n- *\n- * @author Abe White\n- */\n-public class ObjectValue extends Value {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (ObjectValue.class);\n-\n-    // cache the types' classloader\n-    private static ConcurrentReferenceHashMap _classloaderCache =\n-        new ConcurrentReferenceHashMap(ReferenceMap.HARD, ReferenceMap.WEAK);\n-\n-    private Object _value = null;\n-\n-    public ObjectValue(String prop) {\n-        super(prop);\n-    }\n-\n-    /**\n-     * The internal value.\n-     */\n-    public Object get() {\n-        return _value;\n-    }\n-\n-    /**\n-     * The internal value.\n-     */\n-    public void set(Object obj) {\n-        set(obj, false);\n-    }\n-\n-    /**\n-     * The internal value.\n-     *\n-     * @param derived if true, this value was derived from other properties\n-     */\n-    public void set(Object obj, boolean derived) {\n-        if (!derived) assertChangeable();\n-        Object oldValue = _value;\n-        _value = obj;\n-        if (!derived && !ObjectUtils.equals(obj, oldValue)) {\n-            objectChanged();\n-            valueChanged();\n-        }\n-    }\n-\n-    /**\n-     * Instantiate the object as an instance of the given class. Equivalent\n-     * to <code>instantiate(type, conf, true)</code>.\n-     */\n-    public Object instantiate(Class type, Configuration conf) {\n-        return instantiate(type, conf, true);\n-    }\n-\n-    /**\n-     * Instantiate the object as an instance of the given class.\n-     */\n-    public Object instantiate(Class type, Configuration conf, boolean fatal) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Allow subclasses to instantiate additional plugins. This method does\n-     * not perform configuration.\n-     */\n-    public Object newInstance(String clsName, Class type, Configuration conf,\n-            boolean fatal) {\n-        ClassLoader cl = (ClassLoader) _classloaderCache.get(type);\n-        if (cl == null) {\n-            cl = (ClassLoader) AccessController.doPrivileged(\n-                J2DoPrivHelper.getClassLoaderAction(type));\n-            if (cl == null) {  // System classloader is returned as null\n-                cl = (ClassLoader) AccessController.doPrivileged(\n-                    J2DoPrivHelper.getSystemClassLoaderAction()); \n-            }\n-            _classloaderCache.put(type, cl);\n-        }\n-        return Configurations.newInstance(clsName, this, conf, cl, fatal);\n-    }\n-\n-    public Class getValueType() {\n-        return Object.class;\n-    }\n-\n-    /**\n-     * Implement this method to synchronize internal data with the new\n-     * object value.\n-     */\n-    protected void objectChanged() {\n-    }\n-\n-    protected String getInternalString() {\n-        return null;\n-    }\n-\n-    protected void setInternalString(String str) {\n-        if (str == null)\n-            set(null);\n-        else\n-            throw new IllegalArgumentException(_loc.get(\"cant-set-string\",\n-                getProperty()).getMessage());\n-    }\n-\n-    protected void setInternalObject(Object obj) {\n-        set(obj);\n-    }\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.lib.conf;\r\n+\r\n+import java.security.AccessController;\r\n+\r\n+import org.apache.commons.lang.ObjectUtils;\r\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.ReferenceMap;\r\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\r\n+\r\n+/**\r\n+ * An object {@link Value}.\r\n+ *\r\n+ * @author Abe White\r\n+ */\r\n+public class ObjectValue extends Value {\r\n+\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (ObjectValue.class);\r\n+\r\n+    // cache the types' classloader\r\n+    private static ConcurrentReferenceHashMap _classloaderCache =\r\n+        new ConcurrentReferenceHashMap(ReferenceMap.HARD, ReferenceMap.WEAK);\r\n+\r\n+    private Object _value = null;\r\n+\r\n+    public ObjectValue(String prop) {\r\n+        super(prop);\r\n+    }\r\n+\r\n+    /**\r\n+     * The internal value.\r\n+     */\r\n+    public Object get() {\r\n+        return _value;\r\n+    }\r\n+\r\n+    /**\r\n+     * The internal value.\r\n+     */\r\n+    public void set(Object obj) {\r\n+        set(obj, false);\r\n+    }\r\n+\r\n+    /**\r\n+     * The internal value.\r\n+     *\r\n+     * @param derived if true, this value was derived from other properties\r\n+     */\r\n+    public void set(Object obj, boolean derived) {\r\n+        if (!derived) assertChangeable();\r\n+        Object oldValue = _value;\r\n+        _value = obj;\r\n+        if (!derived && !ObjectUtils.equals(obj, oldValue)) {\r\n+            objectChanged();\r\n+            valueChanged();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Instantiate the object as an instance of the given class. Equivalent\r\n+     * to <code>instantiate(type, conf, true)</code>.\r\n+     */\r\n+    public Object instantiate(Class type, Configuration conf) {\r\n+        return instantiate(type, conf, true);\r\n+    }\r\n+\r\n+    /**\r\n+     * Instantiate the object as an instance of the given class.\r\n+     */\r\n+    public Object instantiate(Class type, Configuration conf, boolean fatal) {\r\n+        throw new UnsupportedOperationException();\r\n+    }\r\n+\r\n+    /**\r\n+     * Allow subclasses to instantiate additional plugins. This method does\r\n+     * not perform configuration.\r\n+     */\r\n+    public Object newInstance(String clsName, Class type, Configuration conf,\r\n+            boolean fatal) {\r\n+        ClassLoader cl = (ClassLoader) _classloaderCache.get(type);\r\n+        if (cl == null) {\r\n+            cl = (ClassLoader) AccessController.doPrivileged(\r\n+                J2DoPrivHelper.getClassLoaderAction(type));\r\n+            if (cl == null) {  // System classloader is returned as null\r\n+                cl = (ClassLoader) AccessController.doPrivileged(\r\n+                    J2DoPrivHelper.getSystemClassLoaderAction()); \r\n+            }\r\n+            _classloaderCache.put(type, cl);\r\n+        }\r\n+        return Configurations.newInstance(clsName, this, conf, cl, fatal);\r\n+    }\r\n+\r\n+    public Class getValueType() {\r\n+        return Object.class;\r\n+    }\r\n+\r\n+    /**\r\n+     * Implement this method to synchronize internal data with the new\r\n+     * object value.\r\n+     */\r\n+    protected void objectChanged() {\r\n+    }\r\n+\r\n+    protected String getInternalString() {\r\n+        return null;\r\n+    }\r\n+\r\n+    protected void setInternalString(String str) {\r\n+        if (str == null)\r\n+            set(null);\r\n+        else\r\n+            throw new IllegalArgumentException(_loc.get(\"cant-set-string\",\r\n+                getProperty()).getMessage());\r\n+    }\r\n+\r\n+    protected void setInternalObject(Object obj) {\r\n+        set(obj);\r\n+    }\r\n+}\r"},{"sha":"81269c9047c961ef47e24c487190bb1f0c52604a","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","status":"modified","additions":103,"deletions":103,"changes":206,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,103 +1,103 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.lib.jdbc;\n-\n-import java.sql.Connection;\n-import java.sql.SQLException;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n-import javax.sql.DataSource;\n-\n-import org.apache.openjpa.lib.util.concurrent.CopyOnWriteArrayList;\n-\n-/**\n- * Delegating data source that maintains a list of {@link ConnectionDecorator}s.\n- *\n- * @author Abe White\n- * @nojavadoc\n- */\n-public class DecoratingDataSource extends DelegatingDataSource {\n-\n-    private List _decorators = new CopyOnWriteArrayList();\n-\n-    /**\n-     * Constructor. Supply wrapped data source.\n-     */\n-    public DecoratingDataSource(DataSource ds) {\n-        super(ds);\n-    }\n-\n-    /**\n-     * Return a read-only list of connection decorators in the order they were\n-     * added.\n-     */\n-    public Collection getDecorators() {\n-        return Collections.unmodifiableCollection(_decorators);\n-    }\n-\n-    /**\n-     * Add a connection decorator.\n-     */\n-    public void addDecorator(ConnectionDecorator decorator) {\n-        if (decorator != null)\n-            _decorators.add(decorator);\n-    }\n-\n-    /**\n-     * Add multiple connection decorators efficiently.\n-     */\n-    public void addDecorators(Collection decorators) {\n-        if (decorators != null)\n-            _decorators.addAll(decorators);\n-    }\n-\n-    /**\n-     * Remove a connection decorator.\n-     */\n-    public boolean removeDecorator(ConnectionDecorator decorator) {\n-        return _decorators.remove(decorator);\n-    }\n-\n-    /**\n-     * Clear all decorators.\n-     */\n-    public void clearDecorators() {\n-        _decorators.clear();\n-    }\n-\n-    public Connection getConnection() throws SQLException {\n-        Connection conn = super.getConnection();\n-        return decorate(conn);\n-    }\n-\n-    public Connection getConnection(String user, String pass)\n-        throws SQLException {\n-        Connection conn = super.getConnection(user, pass);\n-        return decorate(conn);\n-    }\n-\n-    private Connection decorate(Connection conn) throws SQLException {\n-        if (!_decorators.isEmpty())\n-            for (Iterator itr = _decorators.iterator(); itr.hasNext();)\n-                conn = ((ConnectionDecorator) itr.next()).decorate(conn);\n-        return conn;\n-    }\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.lib.jdbc;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.SQLException;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+import javax.sql.DataSource;\r\n+\r\n+import java.util.concurrent.CopyOnWriteArrayList;\r\n+\r\n+/**\r\n+ * Delegating data source that maintains a list of {@link ConnectionDecorator}s.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ */\r\n+public class DecoratingDataSource extends DelegatingDataSource {\r\n+\r\n+    private List _decorators = new CopyOnWriteArrayList();\r\n+\r\n+    /**\r\n+     * Constructor. Supply wrapped data source.\r\n+     */\r\n+    public DecoratingDataSource(DataSource ds) {\r\n+        super(ds);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a read-only list of connection decorators in the order they were\r\n+     * added.\r\n+     */\r\n+    public Collection getDecorators() {\r\n+        return Collections.unmodifiableCollection(_decorators);\r\n+    }\r\n+\r\n+    /**\r\n+     * Add a connection decorator.\r\n+     */\r\n+    public void addDecorator(ConnectionDecorator decorator) {\r\n+        if (decorator != null)\r\n+            _decorators.add(decorator);\r\n+    }\r\n+\r\n+    /**\r\n+     * Add multiple connection decorators efficiently.\r\n+     */\r\n+    public void addDecorators(Collection decorators) {\r\n+        if (decorators != null)\r\n+            _decorators.addAll(decorators);\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove a connection decorator.\r\n+     */\r\n+    public boolean removeDecorator(ConnectionDecorator decorator) {\r\n+        return _decorators.remove(decorator);\r\n+    }\r\n+\r\n+    /**\r\n+     * Clear all decorators.\r\n+     */\r\n+    public void clearDecorators() {\r\n+        _decorators.clear();\r\n+    }\r\n+\r\n+    public Connection getConnection() throws SQLException {\r\n+        Connection conn = super.getConnection();\r\n+        return decorate(conn);\r\n+    }\r\n+\r\n+    public Connection getConnection(String user, String pass)\r\n+        throws SQLException {\r\n+        Connection conn = super.getConnection(user, pass);\r\n+        return decorate(conn);\r\n+    }\r\n+\r\n+    private Connection decorate(Connection conn) throws SQLException {\r\n+        if (!_decorators.isEmpty())\r\n+            for (Iterator itr = _decorators.iterator(); itr.hasNext();)\r\n+                conn = ((ConnectionDecorator) itr.next()).decorate(conn);\r\n+        return conn;\r\n+    }\r\n+}\r"},{"sha":"52ed8f2208b08bb0c90667fdc1059f469e6cecab","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","status":"modified","additions":295,"deletions":295,"changes":590,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,295 +1,295 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.lib.jdbc;\n-\n-import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.sql.Statement;\n-\n-import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\n-\n-/**\n- * Manages the firing of {@link JDBCEvent}s.\n- *\n- * @author Abe White\n- * @nojavadoc\n- */\n-public class JDBCEventConnectionDecorator extends AbstractConcurrentEventManager\n-    implements ConnectionDecorator {\n-\n-    public Connection decorate(Connection conn) {\n-        if (!hasListeners())\n-            return conn;\n-        return new EventConnection(conn);\n-    }\n-\n-    /**\n-     * Fire the given event to all listeners. Prevents creation of an\n-     * event object when there are no listeners.\n-     */\n-    private JDBCEvent fireEvent(Connection source, short type,\n-        JDBCEvent associatedEvent, Statement stmnt, String sql) {\n-        if (!hasListeners())\n-            return null;\n-\n-        JDBCEvent event = new JDBCEvent(source, type, associatedEvent,\n-            stmnt, sql);\n-        fireEvent(event);\n-        return event;\n-    }\n-\n-    /**\n-     * Fire the given event to all listeners.\n-     */\n-    protected void fireEvent(Object event, Object listener) {\n-        JDBCListener listen = (JDBCListener) listener;\n-        JDBCEvent ev = (JDBCEvent) event;\n-        switch (ev.getType()) {\n-            case JDBCEvent.BEFORE_PREPARE_STATEMENT:\n-                listen.beforePrepareStatement(ev);\n-                break;\n-            case JDBCEvent.AFTER_PREPARE_STATEMENT:\n-                listen.afterPrepareStatement(ev);\n-                break;\n-            case JDBCEvent.BEFORE_CREATE_STATEMENT:\n-                listen.beforeCreateStatement(ev);\n-                break;\n-            case JDBCEvent.AFTER_CREATE_STATEMENT:\n-                listen.afterCreateStatement(ev);\n-                break;\n-            case JDBCEvent.BEFORE_EXECUTE_STATEMENT:\n-                listen.beforeExecuteStatement(ev);\n-                break;\n-            case JDBCEvent.AFTER_EXECUTE_STATEMENT:\n-                listen.afterExecuteStatement(ev);\n-                break;\n-            case JDBCEvent.BEFORE_COMMIT:\n-                listen.beforeCommit(ev);\n-                break;\n-            case JDBCEvent.AFTER_COMMIT:\n-                listen.afterCommit(ev);\n-                break;\n-            case JDBCEvent.BEFORE_ROLLBACK:\n-                listen.beforeRollback(ev);\n-                break;\n-            case JDBCEvent.AFTER_ROLLBACK:\n-                listen.afterRollback(ev);\n-                break;\n-            case JDBCEvent.AFTER_CONNECT:\n-                listen.afterConnect(ev);\n-                break;\n-            case JDBCEvent.BEFORE_CLOSE:\n-                listen.beforeClose(ev);\n-                break;\n-        }\n-    }\n-\n-    /**\n-     * Fires events as appropriate.\n-     */\n-    private class EventConnection extends DelegatingConnection {\n-\n-        public EventConnection(Connection conn) {\n-            super(conn);\n-            fireEvent(getDelegate(), JDBCEvent.AFTER_CONNECT, null, null, null);\n-        }\n-\n-        public void commit() throws SQLException {\n-            JDBCEvent before = fireEvent(getDelegate(),\n-                JDBCEvent.BEFORE_COMMIT, null, null, null);\n-            try {\n-                super.commit();\n-            } finally {\n-                fireEvent(getDelegate(), JDBCEvent.AFTER_COMMIT, before,\n-                    null, null);\n-            }\n-        }\n-\n-        public void rollback() throws SQLException {\n-            JDBCEvent before = fireEvent(getDelegate(),\n-                JDBCEvent.BEFORE_ROLLBACK, null, null, null);\n-            try {\n-                super.rollback();\n-            } finally {\n-                fireEvent(getDelegate(), JDBCEvent.AFTER_ROLLBACK, before,\n-                    null, null);\n-            }\n-        }\n-\n-        protected Statement createStatement(boolean wrap) throws SQLException {\n-            JDBCEvent before = fireEvent(getDelegate(),\n-                JDBCEvent.BEFORE_CREATE_STATEMENT, null, null, null);\n-            Statement stmnt = null;\n-            try {\n-                stmnt = new EventStatement(super.createStatement(false),\n-                    EventConnection.this);\n-            } finally {\n-                fireEvent(getDelegate(), JDBCEvent.AFTER_CREATE_STATEMENT,\n-                    before, stmnt, null);\n-            }\n-            return stmnt;\n-        }\n-\n-        protected Statement createStatement(int rsType, int rsConcur,\n-            boolean wrap) throws SQLException {\n-            JDBCEvent before = fireEvent(getDelegate(),\n-                JDBCEvent.BEFORE_CREATE_STATEMENT, null, null, null);\n-            Statement stmnt = null;\n-            try {\n-                stmnt = new EventStatement(super.createStatement\n-                    (rsType, rsConcur, false), EventConnection.this);\n-            } finally {\n-                fireEvent(getDelegate(), JDBCEvent.AFTER_CREATE_STATEMENT,\n-                    before, stmnt, null);\n-            }\n-            return stmnt;\n-        }\n-\n-        protected PreparedStatement prepareStatement(String sql, boolean wrap)\n-            throws SQLException {\n-            JDBCEvent before = fireEvent(getDelegate(),\n-                JDBCEvent.BEFORE_PREPARE_STATEMENT, null, null, sql);\n-            PreparedStatement stmnt = null;\n-            try {\n-                stmnt = new EventPreparedStatement(super.prepareStatement\n-                    (sql, false), EventConnection.this, sql);\n-            } finally {\n-                fireEvent(getDelegate(), JDBCEvent.AFTER_PREPARE_STATEMENT,\n-                    before, stmnt, sql);\n-            }\n-            return stmnt;\n-        }\n-\n-        protected PreparedStatement prepareStatement(String sql, int rsType,\n-            int rsConcur, boolean wrap) throws SQLException {\n-            JDBCEvent before = fireEvent(getDelegate(),\n-                JDBCEvent.BEFORE_PREPARE_STATEMENT, null, null, sql);\n-            PreparedStatement stmnt = null;\n-            try {\n-                stmnt = new EventPreparedStatement(super.prepareStatement\n-                    (sql, rsType, rsConcur, false), EventConnection.this, sql);\n-            } finally {\n-                fireEvent(getDelegate(), JDBCEvent.AFTER_PREPARE_STATEMENT,\n-                    before, stmnt, sql);\n-            }\n-            return stmnt;\n-        }\n-\n-        public void close() throws SQLException {\n-            try {\n-                fireEvent(getDelegate(), JDBCEvent.BEFORE_CLOSE,\n-                    null, null, null);\n-            } finally {\n-                super.close();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Fires events as appropriate.\n-     */\n-    private class EventPreparedStatement extends DelegatingPreparedStatement {\n-\n-        private final EventConnection _conn;\n-        private final String _sql;\n-\n-        public EventPreparedStatement(PreparedStatement ps,\n-            EventConnection conn, String sql) {\n-            super(ps, conn);\n-            _conn = conn;\n-            _sql = sql;\n-        }\n-\n-        public int executeUpdate() throws SQLException {\n-            JDBCEvent before = fireEvent(_conn.getDelegate(),\n-                JDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate(), _sql);\n-            try {\n-                return super.executeUpdate();\n-            } finally {\n-                fireEvent(_conn.getDelegate(),\n-                    JDBCEvent.AFTER_EXECUTE_STATEMENT, before,\n-                    getDelegate(), _sql);\n-            }\n-        }\n-\n-        protected ResultSet executeQuery(boolean wrap) throws SQLException {\n-            JDBCEvent before = fireEvent(_conn.getDelegate(),\n-                JDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate(), _sql);\n-            try {\n-                return super.executeQuery(wrap);\n-            } finally {\n-                fireEvent(_conn.getDelegate(),\n-                    JDBCEvent.AFTER_EXECUTE_STATEMENT, before,\n-                    getDelegate(), _sql);\n-            }\n-        }\n-\n-        public int[] executeBatch() throws SQLException {\n-            JDBCEvent before = fireEvent(_conn.getDelegate(),\n-                JDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate(), _sql);\n-            try {\n-                return super.executeBatch();\n-            } finally {\n-                fireEvent(_conn.getDelegate(),\n-                    JDBCEvent.AFTER_EXECUTE_STATEMENT, before,\n-                    getDelegate(), _sql);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Fires events as appropriate.\n-     */\n-    private class EventStatement extends DelegatingStatement {\n-\n-        private final EventConnection _conn;\n-\n-        public EventStatement(Statement stmnt, EventConnection conn) {\n-            super(stmnt, conn);\n-            _conn = conn;\n-        }\n-\n-        public int executeUpdate(String sql) throws SQLException {\n-            JDBCEvent before = fireEvent(_conn.getDelegate(),\n-                JDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate(), sql);\n-            try {\n-                return super.executeUpdate(sql);\n-            } finally {\n-                fireEvent(_conn.getDelegate(),\n-                    JDBCEvent.AFTER_EXECUTE_STATEMENT, before,\n-                    getDelegate(), sql);\n-            }\n-        }\n-\n-        protected ResultSet executeQuery(String sql, boolean wrap)\n-            throws SQLException {\n-            JDBCEvent before = fireEvent(_conn.getDelegate(),\n-                JDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate(), sql);\n-            try {\n-                return super.executeQuery(sql, wrap);\n-            } finally {\n-                fireEvent(_conn.getDelegate(),\n-                    JDBCEvent.AFTER_EXECUTE_STATEMENT, before,\n-                    getDelegate(), sql);\n-            }\n-        }\n-    }\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.lib.jdbc;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.PreparedStatement;\r\n+import java.sql.ResultSet;\r\n+import java.sql.SQLException;\r\n+import java.sql.Statement;\r\n+\r\n+import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\r\n+\r\n+/**\r\n+ * Manages the firing of {@link JDBCEvent}s.\r\n+ *\r\n+ * @author Abe White\r\n+ * @nojavadoc\r\n+ */\r\n+public class JDBCEventConnectionDecorator extends AbstractConcurrentEventManager\r\n+    implements ConnectionDecorator {\r\n+\r\n+    public Connection decorate(Connection conn) {\r\n+        if (!hasListeners())\r\n+            return conn;\r\n+        return new EventConnection(conn);\r\n+    }\r\n+\r\n+    /**\r\n+     * Fire the given event to all listeners. Prevents creation of an\r\n+     * event object when there are no listeners.\r\n+     */\r\n+    private JDBCEvent fireEvent(Connection source, short type,\r\n+        JDBCEvent associatedEvent, Statement stmnt, String sql) {\r\n+        if (!hasListeners())\r\n+            return null;\r\n+\r\n+        JDBCEvent event = new JDBCEvent(source, type, associatedEvent,\r\n+            stmnt, sql);\r\n+        fireEvent(event);\r\n+        return event;\r\n+    }\r\n+\r\n+    /**\r\n+     * Fire the given event to all listeners.\r\n+     */\r\n+    protected void fireEvent(Object event, Object listener) {\r\n+        JDBCListener listen = (JDBCListener) listener;\r\n+        JDBCEvent ev = (JDBCEvent) event;\r\n+        switch (ev.getType()) {\r\n+            case JDBCEvent.BEFORE_PREPARE_STATEMENT:\r\n+                listen.beforePrepareStatement(ev);\r\n+                break;\r\n+            case JDBCEvent.AFTER_PREPARE_STATEMENT:\r\n+                listen.afterPrepareStatement(ev);\r\n+                break;\r\n+            case JDBCEvent.BEFORE_CREATE_STATEMENT:\r\n+                listen.beforeCreateStatement(ev);\r\n+                break;\r\n+            case JDBCEvent.AFTER_CREATE_STATEMENT:\r\n+                listen.afterCreateStatement(ev);\r\n+                break;\r\n+            case JDBCEvent.BEFORE_EXECUTE_STATEMENT:\r\n+                listen.beforeExecuteStatement(ev);\r\n+                break;\r\n+            case JDBCEvent.AFTER_EXECUTE_STATEMENT:\r\n+                listen.afterExecuteStatement(ev);\r\n+                break;\r\n+            case JDBCEvent.BEFORE_COMMIT:\r\n+                listen.beforeCommit(ev);\r\n+                break;\r\n+            case JDBCEvent.AFTER_COMMIT:\r\n+                listen.afterCommit(ev);\r\n+                break;\r\n+            case JDBCEvent.BEFORE_ROLLBACK:\r\n+                listen.beforeRollback(ev);\r\n+                break;\r\n+            case JDBCEvent.AFTER_ROLLBACK:\r\n+                listen.afterRollback(ev);\r\n+                break;\r\n+            case JDBCEvent.AFTER_CONNECT:\r\n+                listen.afterConnect(ev);\r\n+                break;\r\n+            case JDBCEvent.BEFORE_CLOSE:\r\n+                listen.beforeClose(ev);\r\n+                break;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Fires events as appropriate.\r\n+     */\r\n+    private class EventConnection extends DelegatingConnection {\r\n+\r\n+        public EventConnection(Connection conn) {\r\n+            super(conn);\r\n+            fireEvent(getDelegate(), JDBCEvent.AFTER_CONNECT, null, null, null);\r\n+        }\r\n+\r\n+        public void commit() throws SQLException {\r\n+            JDBCEvent before = fireEvent(getDelegate(),\r\n+                JDBCEvent.BEFORE_COMMIT, null, null, null);\r\n+            try {\r\n+                super.commit();\r\n+            } finally {\r\n+                fireEvent(getDelegate(), JDBCEvent.AFTER_COMMIT, before,\r\n+                    null, null);\r\n+            }\r\n+        }\r\n+\r\n+        public void rollback() throws SQLException {\r\n+            JDBCEvent before = fireEvent(getDelegate(),\r\n+                JDBCEvent.BEFORE_ROLLBACK, null, null, null);\r\n+            try {\r\n+                super.rollback();\r\n+            } finally {\r\n+                fireEvent(getDelegate(), JDBCEvent.AFTER_ROLLBACK, before,\r\n+                    null, null);\r\n+            }\r\n+        }\r\n+\r\n+        protected Statement createStatement(boolean wrap) throws SQLException {\r\n+            JDBCEvent before = fireEvent(getDelegate(),\r\n+                JDBCEvent.BEFORE_CREATE_STATEMENT, null, null, null);\r\n+            Statement stmnt = null;\r\n+            try {\r\n+                stmnt = new EventStatement(super.createStatement(false),\r\n+                    EventConnection.this);\r\n+            } finally {\r\n+                fireEvent(getDelegate(), JDBCEvent.AFTER_CREATE_STATEMENT,\r\n+                    before, stmnt, null);\r\n+            }\r\n+            return stmnt;\r\n+        }\r\n+\r\n+        protected Statement createStatement(int rsType, int rsConcur,\r\n+            boolean wrap) throws SQLException {\r\n+            JDBCEvent before = fireEvent(getDelegate(),\r\n+                JDBCEvent.BEFORE_CREATE_STATEMENT, null, null, null);\r\n+            Statement stmnt = null;\r\n+            try {\r\n+                stmnt = new EventStatement(super.createStatement\r\n+                    (rsType, rsConcur, false), EventConnection.this);\r\n+            } finally {\r\n+                fireEvent(getDelegate(), JDBCEvent.AFTER_CREATE_STATEMENT,\r\n+                    before, stmnt, null);\r\n+            }\r\n+            return stmnt;\r\n+        }\r\n+\r\n+        protected PreparedStatement prepareStatement(String sql, boolean wrap)\r\n+            throws SQLException {\r\n+            JDBCEvent before = fireEvent(getDelegate(),\r\n+                JDBCEvent.BEFORE_PREPARE_STATEMENT, null, null, sql);\r\n+            PreparedStatement stmnt = null;\r\n+            try {\r\n+                stmnt = new EventPreparedStatement(super.prepareStatement\r\n+                    (sql, false), EventConnection.this, sql);\r\n+            } finally {\r\n+                fireEvent(getDelegate(), JDBCEvent.AFTER_PREPARE_STATEMENT,\r\n+                    before, stmnt, sql);\r\n+            }\r\n+            return stmnt;\r\n+        }\r\n+\r\n+        protected PreparedStatement prepareStatement(String sql, int rsType,\r\n+            int rsConcur, boolean wrap) throws SQLException {\r\n+            JDBCEvent before = fireEvent(getDelegate(),\r\n+                JDBCEvent.BEFORE_PREPARE_STATEMENT, null, null, sql);\r\n+            PreparedStatement stmnt = null;\r\n+            try {\r\n+                stmnt = new EventPreparedStatement(super.prepareStatement\r\n+                    (sql, rsType, rsConcur, false), EventConnection.this, sql);\r\n+            } finally {\r\n+                fireEvent(getDelegate(), JDBCEvent.AFTER_PREPARE_STATEMENT,\r\n+                    before, stmnt, sql);\r\n+            }\r\n+            return stmnt;\r\n+        }\r\n+\r\n+        public void close() throws SQLException {\r\n+            try {\r\n+                fireEvent(getDelegate(), JDBCEvent.BEFORE_CLOSE,\r\n+                    null, null, null);\r\n+            } finally {\r\n+                super.close();\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Fires events as appropriate.\r\n+     */\r\n+    private class EventPreparedStatement extends DelegatingPreparedStatement {\r\n+\r\n+        private final EventConnection _conn;\r\n+        private final String _sql;\r\n+\r\n+        public EventPreparedStatement(PreparedStatement ps,\r\n+            EventConnection conn, String sql) {\r\n+            super(ps, conn);\r\n+            _conn = conn;\r\n+            _sql = sql;\r\n+        }\r\n+\r\n+        public int executeUpdate() throws SQLException {\r\n+            JDBCEvent before = fireEvent(_conn.getDelegate(),\r\n+                JDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate(), _sql);\r\n+            try {\r\n+                return super.executeUpdate();\r\n+            } finally {\r\n+                fireEvent(_conn.getDelegate(),\r\n+                    JDBCEvent.AFTER_EXECUTE_STATEMENT, before,\r\n+                    getDelegate(), _sql);\r\n+            }\r\n+        }\r\n+\r\n+        protected ResultSet executeQuery(boolean wrap) throws SQLException {\r\n+            JDBCEvent before = fireEvent(_conn.getDelegate(),\r\n+                JDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate(), _sql);\r\n+            try {\r\n+                return super.executeQuery(wrap);\r\n+            } finally {\r\n+                fireEvent(_conn.getDelegate(),\r\n+                    JDBCEvent.AFTER_EXECUTE_STATEMENT, before,\r\n+                    getDelegate(), _sql);\r\n+            }\r\n+        }\r\n+\r\n+        public int[] executeBatch() throws SQLException {\r\n+            JDBCEvent before = fireEvent(_conn.getDelegate(),\r\n+                JDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate(), _sql);\r\n+            try {\r\n+                return super.executeBatch();\r\n+            } finally {\r\n+                fireEvent(_conn.getDelegate(),\r\n+                    JDBCEvent.AFTER_EXECUTE_STATEMENT, before,\r\n+                    getDelegate(), _sql);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Fires events as appropriate.\r\n+     */\r\n+    private class EventStatement extends DelegatingStatement {\r\n+\r\n+        private final EventConnection _conn;\r\n+\r\n+        public EventStatement(Statement stmnt, EventConnection conn) {\r\n+            super(stmnt, conn);\r\n+            _conn = conn;\r\n+        }\r\n+\r\n+        public int executeUpdate(String sql) throws SQLException {\r\n+            JDBCEvent before = fireEvent(_conn.getDelegate(),\r\n+                JDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate(), sql);\r\n+            try {\r\n+                return super.executeUpdate(sql);\r\n+            } finally {\r\n+                fireEvent(_conn.getDelegate(),\r\n+                    JDBCEvent.AFTER_EXECUTE_STATEMENT, before,\r\n+                    getDelegate(), sql);\r\n+            }\r\n+        }\r\n+\r\n+        protected ResultSet executeQuery(String sql, boolean wrap)\r\n+            throws SQLException {\r\n+            JDBCEvent before = fireEvent(_conn.getDelegate(),\r\n+                JDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate(), sql);\r\n+            try {\r\n+                return super.executeQuery(sql, wrap);\r\n+            } finally {\r\n+                fireEvent(_conn.getDelegate(),\r\n+                    JDBCEvent.AFTER_EXECUTE_STATEMENT, before,\r\n+                    getDelegate(), sql);\r\n+            }\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"0bc0d85cbdbc3f81b7fe169a6b035cb382c95b42","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","status":"modified","additions":51,"deletions":51,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,51 +1,51 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.lib.log;\n-\n-import java.util.Map;\n-\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n-\n-/**\n- * Base type that aids in adapting an external log framework to the\n- * {@link LogFactory}.\n- *\n- * @author Abe White\n- */\n-public abstract class LogFactoryAdapter implements LogFactory {\n-\n-    // cache category to log adapters\n-    private Map _logs = new ConcurrentHashMap();\n-\n-    public Log getLog(String channel) {\n-        // no locking; OK if same adapter created multiple times\n-        Log log = (Log) _logs.get(channel);\n-        if (log == null) {\n-            log = newLogAdapter(channel);\n-            _logs.put(channel, log);\n-        }\n-        return log;\n-    }\n-\n-    /**\n-     * Return a log adapter for the given channel. This method may be called\n-     * multiple times for the same channel in concurrent situations.\n-     */\n-    protected abstract Log newLogAdapter(String channel);\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.lib.log;\r\n+\r\n+import java.util.Map;\r\n+\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+\r\n+/**\r\n+ * Base type that aids in adapting an external log framework to the\r\n+ * {@link LogFactory}.\r\n+ *\r\n+ * @author Abe White\r\n+ */\r\n+public abstract class LogFactoryAdapter implements LogFactory {\r\n+\r\n+    // cache category to log adapters\r\n+    private Map _logs = new ConcurrentHashMap();\r\n+\r\n+    public Log getLog(String channel) {\r\n+        // no locking; OK if same adapter created multiple times\r\n+        Log log = (Log) _logs.get(channel);\r\n+        if (log == null) {\r\n+            log = newLogAdapter(channel);\r\n+            _logs.put(channel, log);\r\n+        }\r\n+        return log;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a log adapter for the given channel. This method may be called\r\n+     * multiple times for the same channel in concurrent situations.\r\n+     */\r\n+    protected abstract Log newLogAdapter(String channel);\r\n+}\r"},{"sha":"8cf5412976275f30c2c40a5c894f10d3ee02385e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","status":"modified","additions":365,"deletions":365,"changes":730,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,365 +1,365 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.lib.log;\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.PrintStream;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.Map;\n-\n-import org.apache.openjpa.lib.conf.Configurable;\n-import org.apache.openjpa.lib.conf.Configuration;\n-import org.apache.openjpa.lib.conf.GenericConfigurable;\n-import org.apache.openjpa.lib.util.Files;\n-import org.apache.openjpa.lib.util.J2DoPrivHelper;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.util.Options;\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n-\n-/**\n- * Default {@link LogFactory} implementation. For ease of automatic\n- * configuration, this implementation keys on only the last dot-separated\n- * token of the log channel name.\n- *\n- * @author Patrick Linskey\n- */\n-public class LogFactoryImpl \n-    implements LogFactory, GenericConfigurable, Configurable {\n-\n-    private static Localizer _loc = Localizer.forPackage(LogFactoryImpl.class);\n-\n-    public static final String TRACE_STR = _loc.get(\"log-trace\").getMessage();\n-    public static final String INFO_STR = _loc.get(\"log-info\").getMessage();\n-    public static final String WARN_STR = _loc.get(\"log-warn\").getMessage();\n-    public static final String ERROR_STR = _loc.get(\"log-error\").getMessage();\n-    public static final String FATAL_STR = _loc.get(\"log-fatal\").getMessage();\n-\n-    public static final String STDOUT = \"stdout\";\n-    public static final String STDERR = \"stderr\";\n-\n-    private static final String NEWLINE = J2DoPrivHelper.getLineSeparator();\n-\n-    /**\n-     * The time at which this factory was initialized.\n-     */\n-    protected final long initializationMillis;\n-\n-    /**\n-     * The {@link Log}s that this factory manages, keyed by log channel name.\n-     */\n-    private Map _logs = new ConcurrentHashMap(); // <String,Log>\n-\n-    /**\n-     * The default logging level.\n-     */\n-    private short _defaultLogLevel = Log.INFO;\n-\n-    /**\n-     * Storage for logging level configuration specified at configuration time.\n-     */\n-    private Map _configuredLevels = new HashMap(); // <String,Integer>\n-\n-    /**\n-     * The stream to write to. Defaults to System.err.\n-     */\n-    private PrintStream _out = System.err;\n-\n-    /**\n-     * A token to add to all log messages. If <code>null</code>, the \n-     * configuration's id will be used.\n-     */\n-    private String _diagContext = null;\n-    private boolean _diagContextComputed = false;\n-    \n-    private Configuration _conf;\n-\n-\n-    public LogFactoryImpl() {\n-        initializationMillis = System.currentTimeMillis();\n-    }\n-\n-    public Log getLog(String channel) {\n-        // no locking; ok if same log created multiple times\n-        LogImpl l = (LogImpl) _logs.get(channel);\n-        if (l == null) {\n-            l = newLogImpl();\n-            l.setChannel(channel);\n-            Short lvl = (Short) _configuredLevels.get(shorten(channel));\n-            l.setLevel(lvl == null ? _defaultLogLevel : lvl.shortValue());\n-            _logs.put(channel, l);\n-        }\n-        return l;\n-    }\n-\n-    /**\n-     * Create a new log. The log will be cached.\n-     */\n-    protected LogImpl newLogImpl() {\n-        return new LogImpl();\n-    }\n-\n-    /**\n-     * The string name of the default level for unconfigured log channels;\n-     * used for automatic configuration.\n-     */\n-    public void setDefaultLevel(String level) {\n-        _defaultLogLevel = getLevel(level);\n-    }\n-\n-    /**\n-     * The default level for unconfigured log channels.\n-     */\n-    public short getDefaultLevel() {\n-        return _defaultLogLevel;\n-    }\n-\n-    /**\n-     * The default level for unconfigured log channels.\n-     */\n-    public void setDefaultLevel(short level) {\n-        _defaultLogLevel = level;\n-    }\n-\n-    /**\n-     * A string to prefix all log messages with. Set to\n-     * <code>null</code> to use the configuration's Id property setting.\n-     */\n-    public void setDiagnosticContext(String val) {\n-        _diagContext = val;\n-    }\n-\n-    /**\n-     * A string to prefix all log messages with. Set to\n-     * <code>null</code> to use the configuration's Id property setting.\n-     */\n-    public String getDiagnosticContext() {\n-        if (!_diagContextComputed) {\n-            // this initialization has to happen lazily because there is no\n-            // guarantee that conf.getId() will be populated by the time that\n-            // endConfiguration() is called.\n-            if (_diagContext == null && _conf != null) {\n-                _diagContext = _conf.getId();\n-            }\n-            if (\"\".equals(_diagContext))\n-                _diagContext = null;\n-            _diagContextComputed = true;\n-        }\n-        return _diagContext;\n-    }\n-\n-    /**\n-     * The stream to write to. Recognized values are: <code>stdout</code>\n-     * and <code>stderr</code>. Any other value will be considered a file name.\n-     */\n-    public void setFile(String file) {\n-        if (STDOUT.equals(file))\n-            _out = System.out;\n-        else if (STDERR.equals(file))\n-            _out = System.err;\n-        else {\n-            File f = Files.getFile(file, null);\n-            try {\n-                _out = new PrintStream((FileOutputStream)\n-                    AccessController.doPrivileged(\n-                        J2DoPrivHelper.newFileOutputStreamAction(\n-                            (String) AccessController.doPrivileged(\n-                                J2DoPrivHelper.getCanonicalPathAction(f)),\n-                            true)));\n-            } catch (PrivilegedActionException pae) {\n-                throw new IllegalArgumentException(_loc.get(\"log-bad-file\",\n-                        file) + \" \" + pae.getException());\n-            } catch (IOException ioe) {\n-                throw new IllegalArgumentException(_loc.get(\"log-bad-file\",\n-                    file) + \" \" + ioe.toString());\n-            }\n-        }\n-    }\n-\n-    /**\n-     * The stream to write to.\n-     */\n-    public PrintStream getStream() {\n-        return _out;\n-    }\n-\n-    /**\n-     * The stream to write to.\n-     */\n-    public void setStream(PrintStream stream) {\n-        if (stream == null)\n-            throw new NullPointerException(\"stream == null\");\n-        _out = stream;\n-    }\n-\n-    /**\n-     * Returns a string representation of the specified log level constant.\n-     */\n-    public static String getLevelName(short level) {\n-        switch (level) {\n-            case Log.TRACE:\n-                return TRACE_STR;\n-            case Log.INFO:\n-                return INFO_STR;\n-            case Log.WARN:\n-                return WARN_STR;\n-            case Log.ERROR:\n-                return ERROR_STR;\n-            case Log.FATAL:\n-                return FATAL_STR;\n-            default:\n-                return _loc.get(\"log-unknown\").getMessage();\n-        }\n-    }\n-\n-    /**\n-     * Returns a symbolic constant for the specified string level.\n-     */\n-    public static short getLevel(String str) {\n-        str = str.toUpperCase().trim();\n-        short val = TRACE_STR.equals(str) ? Log.TRACE :\n-            INFO_STR.equals(str) ? Log.INFO :\n-                WARN_STR.equals(str) ? Log.WARN :\n-                    ERROR_STR.equals(str) ? Log.ERROR :\n-                        FATAL_STR.equals(str) ? Log.FATAL : -1;\n-\n-        if (val == -1)\n-            throw new IllegalArgumentException\n-                (_loc.get(\"log-bad-constant\", str).getMessage());\n-\n-        return val;\n-    }\n-\n-    // ---------- Configurable implementation ----------\n-    \n-    public void setConfiguration(Configuration conf) {\n-        _conf = conf;\n-    }\n-    \n-    public void startConfiguration() {\n-    }\n-\n-    public void endConfiguration() {\n-    }\n-\n-    // ---------- GenericConfigurable implementation ----------\n-\n-    public void setInto(Options opts) {\n-        if (!opts.isEmpty()) {\n-            Map.Entry e;\n-            for (Iterator iter = opts.entrySet().iterator(); iter.hasNext();) {\n-                e = (Map.Entry) iter.next();\n-                _configuredLevels.put(shorten((String) e.getKey()),\n-                    new Short(getLevel((String) e.getValue())));\n-            }\n-            opts.clear();\n-        }\n-    }\n-\n-    private static String shorten(String channel) {\n-        return channel.substring(channel.lastIndexOf('.') + 1);\n-    }\n-\n-    /**\n-     * A simple implementation of the {@link Log} interface. Writes\n-     * output to stderr.\n-     */\n-    public class LogImpl extends AbstractLog {\n-\n-        private short _level = INFO;\n-        private String _channel;\n-\n-        protected boolean isEnabled(short level) {\n-            return level >= _level;\n-        }\n-\n-        protected void log(short level, String message, Throwable t) {\n-            String msg = formatMessage(level, message, t);\n-            synchronized (_out) {\n-                _out.print(msg);\n-            }\n-        }\n-\n-        /**\n-         * Convert <code>message</code> into a string ready to be written to\n-         * the log. The string should include the terminating newline.\n-         *\n-         * @param t may be null\n-         */\n-        protected String formatMessage(short level, String message,\n-            Throwable t) {\n-            // we write to a StringBuffer and then flush it all at\n-            // once as a single line, since some environments(e.g., JBoss)\n-            // override the System output stream to flush any calls\n-            // to write without regard to line breaks, making the\n-            // output incomprehensibe.\n-            StringBuffer buf = new StringBuffer();\n-\n-            buf.append(getOffset());\n-            buf.append(\"  \");\n-            if (getDiagnosticContext() != null)\n-                buf.append(getDiagnosticContext()).append(\"  \");\n-            buf.append(getLevelName(level));\n-            if (level == INFO || level == WARN)\n-                buf.append(\" \");\n-            buf.append(\"  [\");\n-            buf.append(Thread.currentThread().getName());\n-            buf.append(\"] \");\n-            buf.append(_channel);\n-            buf.append(\" - \");\n-            buf.append(message);\n-            buf.append(NEWLINE);\n-\n-            if (t != null) {\n-                StringWriter swriter = new StringWriter();\n-                PrintWriter pwriter = new PrintWriter(swriter);\n-                t.printStackTrace(pwriter);\n-                pwriter.flush();\n-                buf.append(swriter.toString());\n-            }\n-            return buf.toString();\n-        }\n-\n-        private long getOffset() {\n-            return System.currentTimeMillis() - initializationMillis;\n-        }\n-\n-        public void setChannel(String val) {\n-            _channel = val;\n-        }\n-\n-        public String getChannel() {\n-            return _channel;\n-        }\n-\n-        public void setLevel(short val) {\n-            _level = val;\n-        }\n-\n-        public short getLevel() {\n-            return _level;\n-        }\n-    }\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.lib.log;\r\n+\r\n+import java.io.File;\r\n+import java.io.FileOutputStream;\r\n+import java.io.IOException;\r\n+import java.io.PrintStream;\r\n+import java.io.PrintWriter;\r\n+import java.io.StringWriter;\r\n+import java.security.AccessController;\r\n+import java.security.PrivilegedActionException;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.Map;\r\n+\r\n+import org.apache.openjpa.lib.conf.Configurable;\r\n+import org.apache.openjpa.lib.conf.Configuration;\r\n+import org.apache.openjpa.lib.conf.GenericConfigurable;\r\n+import org.apache.openjpa.lib.util.Files;\r\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.util.Options;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+\r\n+/**\r\n+ * Default {@link LogFactory} implementation. For ease of automatic\r\n+ * configuration, this implementation keys on only the last dot-separated\r\n+ * token of the log channel name.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ */\r\n+public class LogFactoryImpl \r\n+    implements LogFactory, GenericConfigurable, Configurable {\r\n+\r\n+    private static Localizer _loc = Localizer.forPackage(LogFactoryImpl.class);\r\n+\r\n+    public static final String TRACE_STR = _loc.get(\"log-trace\").getMessage();\r\n+    public static final String INFO_STR = _loc.get(\"log-info\").getMessage();\r\n+    public static final String WARN_STR = _loc.get(\"log-warn\").getMessage();\r\n+    public static final String ERROR_STR = _loc.get(\"log-error\").getMessage();\r\n+    public static final String FATAL_STR = _loc.get(\"log-fatal\").getMessage();\r\n+\r\n+    public static final String STDOUT = \"stdout\";\r\n+    public static final String STDERR = \"stderr\";\r\n+\r\n+    private static final String NEWLINE = J2DoPrivHelper.getLineSeparator();\r\n+\r\n+    /**\r\n+     * The time at which this factory was initialized.\r\n+     */\r\n+    protected final long initializationMillis;\r\n+\r\n+    /**\r\n+     * The {@link Log}s that this factory manages, keyed by log channel name.\r\n+     */\r\n+    private Map _logs = new ConcurrentHashMap(); // <String,Log>\r\n+\r\n+    /**\r\n+     * The default logging level.\r\n+     */\r\n+    private short _defaultLogLevel = Log.INFO;\r\n+\r\n+    /**\r\n+     * Storage for logging level configuration specified at configuration time.\r\n+     */\r\n+    private Map _configuredLevels = new HashMap(); // <String,Integer>\r\n+\r\n+    /**\r\n+     * The stream to write to. Defaults to System.err.\r\n+     */\r\n+    private PrintStream _out = System.err;\r\n+\r\n+    /**\r\n+     * A token to add to all log messages. If <code>null</code>, the \r\n+     * configuration's id will be used.\r\n+     */\r\n+    private String _diagContext = null;\r\n+    private boolean _diagContextComputed = false;\r\n+    \r\n+    private Configuration _conf;\r\n+\r\n+\r\n+    public LogFactoryImpl() {\r\n+        initializationMillis = System.currentTimeMillis();\r\n+    }\r\n+\r\n+    public Log getLog(String channel) {\r\n+        // no locking; ok if same log created multiple times\r\n+        LogImpl l = (LogImpl) _logs.get(channel);\r\n+        if (l == null) {\r\n+            l = newLogImpl();\r\n+            l.setChannel(channel);\r\n+            Short lvl = (Short) _configuredLevels.get(shorten(channel));\r\n+            l.setLevel(lvl == null ? _defaultLogLevel : lvl.shortValue());\r\n+            _logs.put(channel, l);\r\n+        }\r\n+        return l;\r\n+    }\r\n+\r\n+    /**\r\n+     * Create a new log. The log will be cached.\r\n+     */\r\n+    protected LogImpl newLogImpl() {\r\n+        return new LogImpl();\r\n+    }\r\n+\r\n+    /**\r\n+     * The string name of the default level for unconfigured log channels;\r\n+     * used for automatic configuration.\r\n+     */\r\n+    public void setDefaultLevel(String level) {\r\n+        _defaultLogLevel = getLevel(level);\r\n+    }\r\n+\r\n+    /**\r\n+     * The default level for unconfigured log channels.\r\n+     */\r\n+    public short getDefaultLevel() {\r\n+        return _defaultLogLevel;\r\n+    }\r\n+\r\n+    /**\r\n+     * The default level for unconfigured log channels.\r\n+     */\r\n+    public void setDefaultLevel(short level) {\r\n+        _defaultLogLevel = level;\r\n+    }\r\n+\r\n+    /**\r\n+     * A string to prefix all log messages with. Set to\r\n+     * <code>null</code> to use the configuration's Id property setting.\r\n+     */\r\n+    public void setDiagnosticContext(String val) {\r\n+        _diagContext = val;\r\n+    }\r\n+\r\n+    /**\r\n+     * A string to prefix all log messages with. Set to\r\n+     * <code>null</code> to use the configuration's Id property setting.\r\n+     */\r\n+    public String getDiagnosticContext() {\r\n+        if (!_diagContextComputed) {\r\n+            // this initialization has to happen lazily because there is no\r\n+            // guarantee that conf.getId() will be populated by the time that\r\n+            // endConfiguration() is called.\r\n+            if (_diagContext == null && _conf != null) {\r\n+                _diagContext = _conf.getId();\r\n+            }\r\n+            if (\"\".equals(_diagContext))\r\n+                _diagContext = null;\r\n+            _diagContextComputed = true;\r\n+        }\r\n+        return _diagContext;\r\n+    }\r\n+\r\n+    /**\r\n+     * The stream to write to. Recognized values are: <code>stdout</code>\r\n+     * and <code>stderr</code>. Any other value will be considered a file name.\r\n+     */\r\n+    public void setFile(String file) {\r\n+        if (STDOUT.equals(file))\r\n+            _out = System.out;\r\n+        else if (STDERR.equals(file))\r\n+            _out = System.err;\r\n+        else {\r\n+            File f = Files.getFile(file, null);\r\n+            try {\r\n+                _out = new PrintStream((FileOutputStream)\r\n+                    AccessController.doPrivileged(\r\n+                        J2DoPrivHelper.newFileOutputStreamAction(\r\n+                            (String) AccessController.doPrivileged(\r\n+                                J2DoPrivHelper.getCanonicalPathAction(f)),\r\n+                            true)));\r\n+            } catch (PrivilegedActionException pae) {\r\n+                throw new IllegalArgumentException(_loc.get(\"log-bad-file\",\r\n+                        file) + \" \" + pae.getException());\r\n+            } catch (IOException ioe) {\r\n+                throw new IllegalArgumentException(_loc.get(\"log-bad-file\",\r\n+                    file) + \" \" + ioe.toString());\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * The stream to write to.\r\n+     */\r\n+    public PrintStream getStream() {\r\n+        return _out;\r\n+    }\r\n+\r\n+    /**\r\n+     * The stream to write to.\r\n+     */\r\n+    public void setStream(PrintStream stream) {\r\n+        if (stream == null)\r\n+            throw new NullPointerException(\"stream == null\");\r\n+        _out = stream;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a string representation of the specified log level constant.\r\n+     */\r\n+    public static String getLevelName(short level) {\r\n+        switch (level) {\r\n+            case Log.TRACE:\r\n+                return TRACE_STR;\r\n+            case Log.INFO:\r\n+                return INFO_STR;\r\n+            case Log.WARN:\r\n+                return WARN_STR;\r\n+            case Log.ERROR:\r\n+                return ERROR_STR;\r\n+            case Log.FATAL:\r\n+                return FATAL_STR;\r\n+            default:\r\n+                return _loc.get(\"log-unknown\").getMessage();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a symbolic constant for the specified string level.\r\n+     */\r\n+    public static short getLevel(String str) {\r\n+        str = str.toUpperCase().trim();\r\n+        short val = TRACE_STR.equals(str) ? Log.TRACE :\r\n+            INFO_STR.equals(str) ? Log.INFO :\r\n+                WARN_STR.equals(str) ? Log.WARN :\r\n+                    ERROR_STR.equals(str) ? Log.ERROR :\r\n+                        FATAL_STR.equals(str) ? Log.FATAL : -1;\r\n+\r\n+        if (val == -1)\r\n+            throw new IllegalArgumentException\r\n+                (_loc.get(\"log-bad-constant\", str).getMessage());\r\n+\r\n+        return val;\r\n+    }\r\n+\r\n+    // ---------- Configurable implementation ----------\r\n+    \r\n+    public void setConfiguration(Configuration conf) {\r\n+        _conf = conf;\r\n+    }\r\n+    \r\n+    public void startConfiguration() {\r\n+    }\r\n+\r\n+    public void endConfiguration() {\r\n+    }\r\n+\r\n+    // ---------- GenericConfigurable implementation ----------\r\n+\r\n+    public void setInto(Options opts) {\r\n+        if (!opts.isEmpty()) {\r\n+            Map.Entry e;\r\n+            for (Iterator iter = opts.entrySet().iterator(); iter.hasNext();) {\r\n+                e = (Map.Entry) iter.next();\r\n+                _configuredLevels.put(shorten((String) e.getKey()),\r\n+                    new Short(getLevel((String) e.getValue())));\r\n+            }\r\n+            opts.clear();\r\n+        }\r\n+    }\r\n+\r\n+    private static String shorten(String channel) {\r\n+        return channel.substring(channel.lastIndexOf('.') + 1);\r\n+    }\r\n+\r\n+    /**\r\n+     * A simple implementation of the {@link Log} interface. Writes\r\n+     * output to stderr.\r\n+     */\r\n+    public class LogImpl extends AbstractLog {\r\n+\r\n+        private short _level = INFO;\r\n+        private String _channel;\r\n+\r\n+        protected boolean isEnabled(short level) {\r\n+            return level >= _level;\r\n+        }\r\n+\r\n+        protected void log(short level, String message, Throwable t) {\r\n+            String msg = formatMessage(level, message, t);\r\n+            synchronized (_out) {\r\n+                _out.print(msg);\r\n+            }\r\n+        }\r\n+\r\n+        /**\r\n+         * Convert <code>message</code> into a string ready to be written to\r\n+         * the log. The string should include the terminating newline.\r\n+         *\r\n+         * @param t may be null\r\n+         */\r\n+        protected String formatMessage(short level, String message,\r\n+            Throwable t) {\r\n+            // we write to a StringBuffer and then flush it all at\r\n+            // once as a single line, since some environments(e.g., JBoss)\r\n+            // override the System output stream to flush any calls\r\n+            // to write without regard to line breaks, making the\r\n+            // output incomprehensibe.\r\n+            StringBuffer buf = new StringBuffer();\r\n+\r\n+            buf.append(getOffset());\r\n+            buf.append(\"  \");\r\n+            if (getDiagnosticContext() != null)\r\n+                buf.append(getDiagnosticContext()).append(\"  \");\r\n+            buf.append(getLevelName(level));\r\n+            if (level == INFO || level == WARN)\r\n+                buf.append(\" \");\r\n+            buf.append(\"  [\");\r\n+            buf.append(Thread.currentThread().getName());\r\n+            buf.append(\"] \");\r\n+            buf.append(_channel);\r\n+            buf.append(\" - \");\r\n+            buf.append(message);\r\n+            buf.append(NEWLINE);\r\n+\r\n+            if (t != null) {\r\n+                StringWriter swriter = new StringWriter();\r\n+                PrintWriter pwriter = new PrintWriter(swriter);\r\n+                t.printStackTrace(pwriter);\r\n+                pwriter.flush();\r\n+                buf.append(swriter.toString());\r\n+            }\r\n+            return buf.toString();\r\n+        }\r\n+\r\n+        private long getOffset() {\r\n+            return System.currentTimeMillis() - initializationMillis;\r\n+        }\r\n+\r\n+        public void setChannel(String val) {\r\n+            _channel = val;\r\n+        }\r\n+\r\n+        public String getChannel() {\r\n+            return _channel;\r\n+        }\r\n+\r\n+        public void setLevel(short val) {\r\n+            _level = val;\r\n+        }\r\n+\r\n+        public short getLevel() {\r\n+            return _level;\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"13fb9fced33084c1bf27189faddd87de8b8f1458","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","status":"modified","additions":193,"deletions":193,"changes":386,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,193 +1,193 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.lib.log;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import org.apache.openjpa.lib.util.concurrent.CopyOnWriteArrayList;\n-\n-/**\n- * A LogFactory implementation to pass events through multiple\n- * LogFactory implementations(such as log4j and LogPanelFactory).\n- *\n- * @author Steve Kim\n- */\n-public class MultiLogFactory implements LogFactory {\n-\n-    private List _delegates;\n-\n-    /**\n-     * Create an instance with the given delegates.\n-     */\n-    public MultiLogFactory(LogFactory d1, LogFactory d2) {\n-        this(new LogFactory[]{ d1, d2 });\n-    }\n-\n-    /**\n-     * Create an instance with the given delegates.\n-     */\n-    public MultiLogFactory(LogFactory d1, LogFactory d2, LogFactory d3) {\n-        this(new LogFactory[]{ d1, d2, d3 });\n-    }\n-\n-    /**\n-     * Create an instance with the given delegates.\n-     */\n-    public MultiLogFactory(LogFactory[] delegates) {\n-        _delegates = new CopyOnWriteArrayList(Arrays.asList(delegates));\n-    }\n-\n-    public void addLogFactory(LogFactory factory) {\n-        _delegates.add(factory);\n-    }\n-\n-    public void removeLogFactory(LogFactory factory) {\n-        _delegates.remove(factory);\n-    }\n-\n-    /**\n-     * Returns the delegates that this MultiLogFactory delegates messages to.\n-     */\n-    public LogFactory[] getDelegates() {\n-        return (LogFactory[]) _delegates.toArray(new LogFactory[0]);\n-    }\n-\n-    /**\n-     * Returns a Log impl that combines all logs.\n-     */\n-    public synchronized Log getLog(String channel) {\n-        List logs = new ArrayList(_delegates.size());\n-        for (Iterator i = _delegates.iterator(); i.hasNext();) {\n-            LogFactory f = (LogFactory) i.next();\n-            if (f != null) {\n-                Log l = f.getLog(channel);\n-                if (l != null)\n-                    logs.add(l);\n-            }\n-        }\n-        return new MultiLog((Log[]) logs.toArray(new Log[logs.size()]));\n-    }\n-\n-    /**\n-     * Combinatory Log impl.\n-     */\n-    private static class MultiLog implements Log {\n-\n-        private Log[] _logs;\n-\n-        public MultiLog(Log[] logs) {\n-            _logs = logs;\n-        }\n-\n-        /**\n-         * Return the logs that this log delegates to.\n-         */\n-        public Log[] getDelegates() {\n-            return _logs;\n-        }\n-\n-        public void trace(Object msg) {\n-            for (int i = 0; i < _logs.length; i++)\n-                _logs[i].trace(msg);\n-        }\n-\n-        public void trace(Object msg, Throwable t) {\n-            for (int i = 0; i < _logs.length; i++)\n-                _logs[i].trace(msg, t);\n-        }\n-\n-        public void info(Object msg) {\n-            for (int i = 0; i < _logs.length; i++)\n-                _logs[i].info(msg);\n-        }\n-\n-        public void info(Object msg, Throwable t) {\n-            for (int i = 0; i < _logs.length; i++)\n-                _logs[i].info(msg, t);\n-        }\n-\n-        public void warn(Object msg) {\n-            for (int i = 0; i < _logs.length; i++)\n-                _logs[i].warn(msg);\n-        }\n-\n-        public void warn(Object msg, Throwable t) {\n-            for (int i = 0; i < _logs.length; i++)\n-                _logs[i].warn(msg, t);\n-        }\n-\n-        public void error(Object msg) {\n-            for (int i = 0; i < _logs.length; i++)\n-                _logs[i].error(msg);\n-        }\n-\n-        public void error(Object msg, Throwable t) {\n-            for (int i = 0; i < _logs.length; i++)\n-                _logs[i].error(msg, t);\n-        }\n-\n-        public void fatal(Object msg) {\n-            for (int i = 0; i < _logs.length; i++)\n-                _logs[i].fatal(msg);\n-        }\n-\n-        public void fatal(Object msg, Throwable t) {\n-            for (int i = 0; i < _logs.length; i++)\n-                _logs[i].fatal(msg, t);\n-        }\n-\n-        public boolean isTraceEnabled() {\n-            for (int i = 0; i < _logs.length; i++)\n-                if (_logs[i].isTraceEnabled())\n-                    return true;\n-            return false;\n-        }\n-\n-        public boolean isInfoEnabled() {\n-            for (int i = 0; i < _logs.length; i++)\n-                if (_logs[i].isInfoEnabled())\n-                    return true;\n-            return false;\n-        }\n-\n-        public boolean isWarnEnabled() {\n-            for (int i = 0; i < _logs.length; i++)\n-                if (_logs[i].isWarnEnabled())\n-                    return true;\n-            return false;\n-        }\n-\n-        public boolean isErrorEnabled() {\n-            for (int i = 0; i < _logs.length; i++)\n-                if (_logs[i].isErrorEnabled())\n-                    return true;\n-            return false;\n-        }\n-\n-        public boolean isFatalEnabled() {\n-            for (int i = 0; i < _logs.length; i++)\n-                if (_logs[i].isFatalEnabled())\n-                    return true;\n-            return false;\n-        }\n-    }\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.lib.log;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.Iterator;\r\n+import java.util.List;\r\n+\r\n+import java.util.concurrent.CopyOnWriteArrayList;\r\n+\r\n+/**\r\n+ * A LogFactory implementation to pass events through multiple\r\n+ * LogFactory implementations(such as log4j and LogPanelFactory).\r\n+ *\r\n+ * @author Steve Kim\r\n+ */\r\n+public class MultiLogFactory implements LogFactory {\r\n+\r\n+    private List _delegates;\r\n+\r\n+    /**\r\n+     * Create an instance with the given delegates.\r\n+     */\r\n+    public MultiLogFactory(LogFactory d1, LogFactory d2) {\r\n+        this(new LogFactory[]{ d1, d2 });\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance with the given delegates.\r\n+     */\r\n+    public MultiLogFactory(LogFactory d1, LogFactory d2, LogFactory d3) {\r\n+        this(new LogFactory[]{ d1, d2, d3 });\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an instance with the given delegates.\r\n+     */\r\n+    public MultiLogFactory(LogFactory[] delegates) {\r\n+        _delegates = new CopyOnWriteArrayList(Arrays.asList(delegates));\r\n+    }\r\n+\r\n+    public void addLogFactory(LogFactory factory) {\r\n+        _delegates.add(factory);\r\n+    }\r\n+\r\n+    public void removeLogFactory(LogFactory factory) {\r\n+        _delegates.remove(factory);\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the delegates that this MultiLogFactory delegates messages to.\r\n+     */\r\n+    public LogFactory[] getDelegates() {\r\n+        return (LogFactory[]) _delegates.toArray(new LogFactory[0]);\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a Log impl that combines all logs.\r\n+     */\r\n+    public synchronized Log getLog(String channel) {\r\n+        List logs = new ArrayList(_delegates.size());\r\n+        for (Iterator i = _delegates.iterator(); i.hasNext();) {\r\n+            LogFactory f = (LogFactory) i.next();\r\n+            if (f != null) {\r\n+                Log l = f.getLog(channel);\r\n+                if (l != null)\r\n+                    logs.add(l);\r\n+            }\r\n+        }\r\n+        return new MultiLog((Log[]) logs.toArray(new Log[logs.size()]));\r\n+    }\r\n+\r\n+    /**\r\n+     * Combinatory Log impl.\r\n+     */\r\n+    private static class MultiLog implements Log {\r\n+\r\n+        private Log[] _logs;\r\n+\r\n+        public MultiLog(Log[] logs) {\r\n+            _logs = logs;\r\n+        }\r\n+\r\n+        /**\r\n+         * Return the logs that this log delegates to.\r\n+         */\r\n+        public Log[] getDelegates() {\r\n+            return _logs;\r\n+        }\r\n+\r\n+        public void trace(Object msg) {\r\n+            for (int i = 0; i < _logs.length; i++)\r\n+                _logs[i].trace(msg);\r\n+        }\r\n+\r\n+        public void trace(Object msg, Throwable t) {\r\n+            for (int i = 0; i < _logs.length; i++)\r\n+                _logs[i].trace(msg, t);\r\n+        }\r\n+\r\n+        public void info(Object msg) {\r\n+            for (int i = 0; i < _logs.length; i++)\r\n+                _logs[i].info(msg);\r\n+        }\r\n+\r\n+        public void info(Object msg, Throwable t) {\r\n+            for (int i = 0; i < _logs.length; i++)\r\n+                _logs[i].info(msg, t);\r\n+        }\r\n+\r\n+        public void warn(Object msg) {\r\n+            for (int i = 0; i < _logs.length; i++)\r\n+                _logs[i].warn(msg);\r\n+        }\r\n+\r\n+        public void warn(Object msg, Throwable t) {\r\n+            for (int i = 0; i < _logs.length; i++)\r\n+                _logs[i].warn(msg, t);\r\n+        }\r\n+\r\n+        public void error(Object msg) {\r\n+            for (int i = 0; i < _logs.length; i++)\r\n+                _logs[i].error(msg);\r\n+        }\r\n+\r\n+        public void error(Object msg, Throwable t) {\r\n+            for (int i = 0; i < _logs.length; i++)\r\n+                _logs[i].error(msg, t);\r\n+        }\r\n+\r\n+        public void fatal(Object msg) {\r\n+            for (int i = 0; i < _logs.length; i++)\r\n+                _logs[i].fatal(msg);\r\n+        }\r\n+\r\n+        public void fatal(Object msg, Throwable t) {\r\n+            for (int i = 0; i < _logs.length; i++)\r\n+                _logs[i].fatal(msg, t);\r\n+        }\r\n+\r\n+        public boolean isTraceEnabled() {\r\n+            for (int i = 0; i < _logs.length; i++)\r\n+                if (_logs[i].isTraceEnabled())\r\n+                    return true;\r\n+            return false;\r\n+        }\r\n+\r\n+        public boolean isInfoEnabled() {\r\n+            for (int i = 0; i < _logs.length; i++)\r\n+                if (_logs[i].isInfoEnabled())\r\n+                    return true;\r\n+            return false;\r\n+        }\r\n+\r\n+        public boolean isWarnEnabled() {\r\n+            for (int i = 0; i < _logs.length; i++)\r\n+                if (_logs[i].isWarnEnabled())\r\n+                    return true;\r\n+            return false;\r\n+        }\r\n+\r\n+        public boolean isErrorEnabled() {\r\n+            for (int i = 0; i < _logs.length; i++)\r\n+                if (_logs[i].isErrorEnabled())\r\n+                    return true;\r\n+            return false;\r\n+        }\r\n+\r\n+        public boolean isFatalEnabled() {\r\n+            for (int i = 0; i < _logs.length; i++)\r\n+                if (_logs[i].isFatalEnabled())\r\n+                    return true;\r\n+            return false;\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"cf42913f326e999026c7fabdd31bedc25b4bf8ba","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java","status":"renamed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","previous_filename":"openjpa-lib-5/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java"},{"sha":"33d4e438912953708cb08b0847853d17cf0b0e04","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/LRUMap.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/LRUMap.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/LRUMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/LRUMap.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -38,12 +38,12 @@\n     public LRUMap() {\n     }\n \n-    public LRUMap(int maxSize) {\n-        super(maxSize);\n+    public LRUMap(int initCapacity) {\n+        super(initCapacity);\n     }\n \n-    public LRUMap(int maxSize, float loadFactor) {\n-        super(maxSize, loadFactor);\n+    public LRUMap(int initCapacity, float loadFactor) {\n+        super(initCapacity, loadFactor);\n     }\n \n     public LRUMap(Map map) {"},{"sha":"a82b2f7f45bc93eef6995b41e6c6befc2b190c88","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","status":"modified","additions":302,"deletions":302,"changes":604,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -1,302 +1,302 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.lib.util;\n-\n-import java.security.AccessController;\n-import java.text.MessageFormat;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.MissingResourceException;\n-import java.util.Properties;\n-import java.util.ResourceBundle;\n-\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n-import org.apache.openjpa.lib.util.concurrent.CopyOnWriteArraySet;\n-\n-/**\n- * The Localizer provides convenient access to localized\n- * strings. It includes built-in support for parameter substitution through\n- * the use of the {@link MessageFormat} utility.\n- * Strings are stored in per-package {@link Properties} files.\n- * The property file for the default locale must be named\n- * <code>localizer.properties</code>. Additional locales can be supported\n- * through additional property files using the naming conventions specified\n- * in the {@link ResourceBundle} class. For example, the German locale\n- * could be supported through a <code>localizer_de_DE.properties</code> file.\n- *\n- * @author Abe White\n- */\n-public class Localizer {\n-\n-    // static cache of package+loc name to localizer mappings\n-    private static final Map _localizers = new ConcurrentHashMap();\n-\n-    // list of resource providers to delegate to when locating resources\n-    private static final Collection _providers = new CopyOnWriteArraySet\n-        (Arrays.asList(new Object[]{\n-            new SimpleResourceBundleProvider(),\n-            new StreamResourceBundleProvider(),\n-            new ZipResourceBundleProvider(), }));\n-\n-    /**\n-     * Return a Localizer instance that will access the properties file\n-     * in the package of the given class using the system default locale.\n-     *\n-     * @see #forPackage(Class,Locale)\n-     */\n-    public static Localizer forPackage(Class cls) {\n-        return forPackage(cls, null);\n-    }\n-\n-    /**\n-     * Return a Localizer instance that will access the properties file\n-     * in the package of the given class using the given locale.\n-     *\n-     * @param cls the class whose package to check for the localized\n-     * properties file; if null, the system will check for\n-     * a top-level properties file\n-     * @param locale the locale to which strings should be localized; if\n-     * null, the system default will be assumed\n-     */\n-    public static Localizer forPackage(Class cls, Locale locale) {\n-        if (locale == null)\n-            locale = Locale.getDefault();\n-\n-        int dot = (cls == null) ? -1 : cls.getName().lastIndexOf('.');\n-        String pkg;\n-        String file;\n-        if (dot == -1) {\n-            pkg = \"\";\n-            file = \"localizer\";\n-        } else {\n-            pkg = cls.getName().substring(0, dot);\n-            file = pkg + \".localizer\";\n-        }\n-        String key = file + locale.toString();\n-\n-        // no locking; ok if bundle created multiple times\n-        // check for cached version\n-        Localizer loc = (Localizer) _localizers.get(key);\n-        if (loc != null)\n-            return loc;\n-        else {\n-            loc = new Localizer(pkg, file, locale, \n-                cls == null ? null:(ClassLoader) AccessController.doPrivileged(\n-                    J2DoPrivHelper.getClassLoaderAction(cls))); \n-            _localizers.put(key, loc);\n-            return loc;\n-        }\n-    }\n-\n-    /**\n-     * Register a resource provider.\n-     */\n-    public static void addProvider(ResourceBundleProvider provider) {\n-        _providers.add(provider);\n-    }\n-\n-    /**\n-     * Remove a resource provider.\n-     */\n-    public static boolean removeProvider(ResourceBundleProvider provider) {\n-        return _providers.remove(provider);\n-    }\n-\n-    private String _file;\n-    private String _pkg;\n-    private ResourceBundle _bundle = null;\n-    private Locale _locale;\n-    private ClassLoader _loader;\n-\n-    private Localizer(String pkg, String f, Locale locale, ClassLoader loader) {\n-        _pkg = pkg;\n-        _file = f;\n-        _locale = locale;\n-        _loader = loader;\n-    }\n-    \n-    private ResourceBundle getBundle() {\n-        // no locking; it's ok to create multiple bundles\n-        if (_bundle == null) {\n-            // find resource bundle\n-            for (Iterator itr = _providers.iterator();\n-                itr.hasNext() && _bundle == null; ) {\n-                _bundle = ((ResourceBundleProvider) itr.next())\n-                    .findResource(_file, _locale, _loader);\n-            }\n-        }\n-        return _bundle;\n-    }\n-\n-    /**\n-     * Return the localized string matching the given key.\n-     */\n-    public Message get(String key) {\n-        return get(key, null);\n-    }\n-\n-    /**\n-     * Return the localized string matching the given key.\n-     */\n-    public Message getFatal(String key) {\n-        return getFatal(key, null);\n-    }\n-\n-    /**\n-     * Return the localized string matching the given key. The given\n-     * <code>sub</code> object will be packed into an array and substituted\n-     * into the found string according to the rules of the\n-     * {@link MessageFormat} class.\n-     *\n-     * @see #get(String)\n-     */\n-    public Message get(String key, Object sub) {\n-        return get(key, new Object[]{ sub });\n-    }\n-\n-    /**\n-     * Return the localized string matching the given key. The given\n-     * <code>sub</code> object will be packed into an array and substituted\n-     * into the found string according to the rules of the\n-     * {@link MessageFormat} class.\n-     *\n-     * @see #getFatal(String)\n-     */\n-    public Message getFatal(String key, Object sub) {\n-        return getFatal(key, new Object[]{ sub });\n-    }\n-\n-    /**\n-     * Return the localized string for the given key.\n-     *\n-     * @see #get(String,Object)\n-     */\n-    public Message get(String key, Object sub1, Object sub2) {\n-        return get(key, new Object[]{ sub1, sub2 });\n-    }\n-\n-    /**\n-     * Return the localized string for the given key.\n-     *\n-     * @see #getFatal(String,Object)\n-     */\n-    public Message getFatal(String key, Object sub1, Object sub2) {\n-        return getFatal(key, new Object[]{ sub1, sub2 });\n-    }\n-\n-    /**\n-     * Return the localized string for the given key.\n-     *\n-     * @see #get(String,Object)\n-     */\n-    public Message get(String key, Object sub1, Object sub2, Object sub3) {\n-        return get(key, new Object[]{ sub1, sub2, sub3 });\n-    }\n-\n-    /**\n-     * Return the localized string matching the given key. The given\n-     * <code>subs</code> objects will be substituted\n-     * into the found string according to the rules of the\n-     * {@link MessageFormat} class.\n-     *\n-     * @see #get(String)\n-     */\n-    public Message get(String key, Object[] subs) {\n-        return new Message(_pkg, getBundle(), key, subs, false);\n-    }\n-\n-    /**\n-     * Return the localized string matching the given key. The given\n-     * <code>subs</code> objects will be substituted\n-     * into the found string according to the rules of the\n-     * {@link MessageFormat} class.\n-     *\n-     * @see #getFatal(String)\n-     */\n-    public Message getFatal(String key, Object[] subs) {\n-        return new Message(_pkg, getBundle(), key, subs, true);\n-    }\n-\n-    /**\n-     * A <code>Message</code> can provide a localized message via the \n-     * {@link #getMessage} method call, and can also provide the original key,\n-     * package, and substitution array that were used to assemble the message.\n-     */\n-    public static class Message {\n-\n-        private final String _pkg;\n-        private final String _key;\n-        private final Object[] _subs;\n-        private final String _localizedMessage;\n-\n-        private Message(String packageName, ResourceBundle bundle, String key, \n-            Object[] subs, boolean fatal) {\n-            if (bundle == null && fatal)\n-                throw new MissingResourceException(key, key, key);\n-\n-            _pkg = packageName;\n-            _key = key;\n-            _subs = subs;\n-            if (bundle == null) {\n-                _localizedMessage = key;\n-            } else {\n-                String localized = null;\n-                try {\n-                    localized = bundle.getString(key);\n-                } catch (MissingResourceException mre) {\n-                    if (fatal)\n-                        throw mre;\n-                }\n-                _localizedMessage = (localized == null) ? key : localized;\n-            }\n-        }\n-\n-        /**\n-         * The localized message.\n-         */\n-        public String getMessage() {\n-            return MessageFormat.format(_localizedMessage, _subs);\n-        }\n-\n-        /**\n-         * The unique key for the localized message.\n-         */\n-        public String getKey() {\n-            return _key;\n-        }\n-\n-        /**\n-         * Substitutions inserted into the message.\n-         */\n-        public Object[] getSubstitutions() {\n-            return _subs;\n-        }\n-\n-        public String getPackageName() {\n-            return _pkg;\n-        }\n-\n-        public String toString() {\n-            return getMessage();\n-        }\n-    }\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.lib.util;\r\n+\r\n+import java.security.AccessController;\r\n+import java.text.MessageFormat;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import java.util.Iterator;\r\n+import java.util.Locale;\r\n+import java.util.Map;\r\n+import java.util.MissingResourceException;\r\n+import java.util.Properties;\r\n+import java.util.ResourceBundle;\r\n+\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.CopyOnWriteArraySet;\r\n+\r\n+/**\r\n+ * The Localizer provides convenient access to localized\r\n+ * strings. It inlcudes built-in support for parameter substitution through\r\n+ * the use of the {@link MessageFormat} utility.\r\n+ * Strings are stored in per-package {@link Properties} files.\r\n+ * The property file for the default locale must be named\r\n+ * <code>localizer.properties</code>. Additional locales can be supported\r\n+ * through additional property files using the naming conventions specified\r\n+ * in the {@link ResourceBundle} class. For example, the german locale\r\n+ * could be supported through a <code>localizer_de_DE.properties</code> file.\r\n+ *\r\n+ * @author Abe White\r\n+ */\r\n+public class Localizer {\r\n+\r\n+    // static cache of package+loc name to localizer mappings\r\n+    private static final Map _localizers = new ConcurrentHashMap();\r\n+\r\n+    // list of resource providers to delegate to when locating resources\r\n+    private static final Collection _providers = new CopyOnWriteArraySet\r\n+        (Arrays.asList(new Object[]{\r\n+            new SimpleResourceBundleProvider(),\r\n+            new StreamResourceBundleProvider(),\r\n+            new ZipResourceBundleProvider(), }));\r\n+\r\n+    /**\r\n+     * Return a Localizer instance that will access the properties file\r\n+     * in the package of the given class using the system default locale.\r\n+     *\r\n+     * @see #forPackage(Class,Locale)\r\n+     */\r\n+    public static Localizer forPackage(Class cls) {\r\n+        return forPackage(cls, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return a Localizer instance that will access the properties file\r\n+     * in the package of the given class using the given locale.\r\n+     *\r\n+     * @param cls the class whose package to check for the localized\r\n+     * properties file; if null, the system will check for\r\n+     * a top-level properties file\r\n+     * @param locale the locale to which strings should be localized; if\r\n+     * null, the system default will be assumed\r\n+     */\r\n+    public static Localizer forPackage(Class cls, Locale locale) {\r\n+        if (locale == null)\r\n+            locale = Locale.getDefault();\r\n+\r\n+        int dot = (cls == null) ? -1 : cls.getName().lastIndexOf('.');\r\n+        String pkg;\r\n+        String file;\r\n+        if (dot == -1) {\r\n+            pkg = \"\";\r\n+            file = \"localizer\";\r\n+        } else {\r\n+            pkg = cls.getName().substring(0, dot);\r\n+            file = pkg + \".localizer\";\r\n+        }\r\n+        String key = file + locale.toString();\r\n+\r\n+        // no locking; ok if bundle created multiple times\r\n+        // check for cached version\r\n+        Localizer loc = (Localizer) _localizers.get(key);\r\n+        if (loc != null)\r\n+            return loc;\r\n+        else {\r\n+            loc = new Localizer(pkg, file, locale,\r\n+                cls == null ? null:(ClassLoader) AccessController.doPrivileged(\r\n+                    J2DoPrivHelper.getClassLoaderAction(cls)));\r\n+            _localizers.put(key, loc);\r\n+            return loc;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Register a resource provider.\r\n+     */\r\n+    public static void addProvider(ResourceBundleProvider provider) {\r\n+        _providers.add(provider);\r\n+    }\r\n+\r\n+    /**\r\n+     * Remove a resource provider.\r\n+     */\r\n+    public static boolean removeProvider(ResourceBundleProvider provider) {\r\n+        return _providers.remove(provider);\r\n+    }\r\n+\r\n+    private String _file;\r\n+    private String _pkg;\r\n+    private ResourceBundle _bundle = null;\r\n+    private Locale _locale;\r\n+    private ClassLoader _loader;\r\n+\r\n+    private Localizer(String pkg, String f, Locale locale, ClassLoader loader) {\r\n+        _pkg = pkg;\r\n+        _file = f;\r\n+        _locale = locale;\r\n+        _loader = loader;\r\n+    }\r\n+\r\n+    private ResourceBundle getBundle() {\r\n+        // no locking; it's ok to create multiple bundles\r\n+        if (_bundle == null) {\r\n+            // find resource bundle\r\n+            for (Iterator itr = _providers.iterator();\r\n+                itr.hasNext() && _bundle == null; ) {\r\n+                _bundle = ((ResourceBundleProvider) itr.next())\r\n+                    .findResource(_file, _locale, _loader);\r\n+            }\r\n+        }\r\n+        return _bundle;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the localized string matching the given key.\r\n+     */\r\n+    public Message get(String key) {\r\n+        return get(key, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the localized string matching the given key.\r\n+     */\r\n+    public Message getFatal(String key) {\r\n+        return getFatal(key, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the localized string matching the given key. The given\r\n+     * <code>sub</code> object will be packed into an array and substituted\r\n+     * into the found string according to the rules of the\r\n+     * {@link MessageFormat} class.\r\n+     *\r\n+     * @see #get(String)\r\n+     */\r\n+    public Message get(String key, Object sub) {\r\n+        return get(key, new Object[]{ sub });\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the localized string matching the given key. The given\r\n+     * <code>sub</code> object will be packed into an array and substituted\r\n+     * into the found string according to the rules of the\r\n+     * {@link MessageFormat} class.\r\n+     *\r\n+     * @see #getFatal(String)\r\n+     */\r\n+    public Message getFatal(String key, Object sub) {\r\n+        return getFatal(key, new Object[]{ sub });\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the localized string for the given key.\r\n+     *\r\n+     * @see #get(String,Object)\r\n+     */\r\n+    public Message get(String key, Object sub1, Object sub2) {\r\n+        return get(key, new Object[]{ sub1, sub2 });\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the localized string for the given key.\r\n+     *\r\n+     * @see #getFatal(String,Object)\r\n+     */\r\n+    public Message getFatal(String key, Object sub1, Object sub2) {\r\n+        return getFatal(key, new Object[]{ sub1, sub2 });\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the localized string for the given key.\r\n+     *\r\n+     * @see #get(String,Object)\r\n+     */\r\n+    public Message get(String key, Object sub1, Object sub2, Object sub3) {\r\n+        return get(key, new Object[]{ sub1, sub2, sub3 });\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the localized string matching the given key. The given\r\n+     * <code>subs</code> objects will be substituted\r\n+     * into the found string according to the rules of the\r\n+     * {@link MessageFormat} class.\r\n+     *\r\n+     * @see #get(String)\r\n+     */\r\n+    public Message get(String key, Object[] subs) {\r\n+        return new Message(_pkg, getBundle(), key, subs, false);\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the localized string matching the given key. The given\r\n+     * <code>subs</code> objects will be substituted\r\n+     * into the found string according to the rules of the\r\n+     * {@link MessageFormat} class.\r\n+     *\r\n+     * @see #getFatal(String)\r\n+     */\r\n+    public Message getFatal(String key, Object[] subs) {\r\n+        return new Message(_pkg, getBundle(), key, subs, true);\r\n+    }\r\n+\r\n+    /**\r\n+     * A <code>Message</code> can provide a localized message via the\r\n+     * {@link #getMessage} method call, and can also provide the original key,\r\n+     * package, and substitution array that were used to assemble the message.\r\n+     */\r\n+    public static class Message {\r\n+\r\n+        private final String _pkg;\r\n+        private final String _key;\r\n+        private final Object[] _subs;\r\n+        private final String _localizedMessage;\r\n+\r\n+        private Message(String packageName, ResourceBundle bundle, String key,\r\n+            Object[] subs, boolean fatal) {\r\n+            if (bundle == null && fatal)\r\n+                throw new MissingResourceException(key, key, key);\r\n+\r\n+            _pkg = packageName;\r\n+            _key = key;\r\n+            _subs = subs;\r\n+            if (bundle == null) {\r\n+                _localizedMessage = key;\r\n+            } else {\r\n+                String localized = null;\r\n+                try {\r\n+                    localized = bundle.getString(key);\r\n+                } catch (MissingResourceException mre) {\r\n+                    if (fatal)\r\n+                        throw mre;\r\n+                }\r\n+                _localizedMessage = (localized == null) ? key : localized;\r\n+            }\r\n+        }\r\n+\r\n+        /**\r\n+         * The localized message.\r\n+         */\r\n+        public String getMessage() {\r\n+            return MessageFormat.format(_localizedMessage, _subs);\r\n+        }\r\n+\r\n+        /**\r\n+         * The unique key for the localized message.\r\n+         */\r\n+        public String getKey() {\r\n+            return _key;\r\n+        }\r\n+\r\n+        /**\r\n+         * Substitutions inserted into the message.\r\n+         */\r\n+        public Object[] getSubstitutions() {\r\n+            return _subs;\r\n+        }\r\n+\r\n+        public String getPackageName() {\r\n+            return _pkg;\r\n+        }\r\n+\r\n+        public String toString() {\r\n+            return getMessage();\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"ddff2af56ab8f9a4e443d3ee300faffaa55f5dde","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TimestampHelper.java","status":"modified","additions":18,"deletions":24,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TimestampHelper.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TimestampHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TimestampHelper.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -22,8 +22,7 @@\n \r\n /**\r\n  * Helper base class attempts to return java.sql.Timestamp object with\r\n- * nanosecond precision. This base class is created to allow JDK 1.4 maven build\r\n- * and only implements millisecond precision.\r\n+ * nanosecond precision. \r\n  * \r\n  * @author Albert Lee\r\n  */\r\n@@ -34,34 +33,29 @@\n     protected static final long MicroMuliplier = MilliMuliplier * 1000L;\r\n     protected static final long NanoMuliplier = MicroMuliplier * 1000L;\r\n \r\n-    private static TimestampHelper instance = null;\r\n-    \r\n+    // number of seconds passed 1970/1/1 00:00:00 GMT.\r\n+    private static long sec0;\r\n+    // fraction of seconds passed 1970/1/1 00:00:00 GMT, offset by\r\n+    // the base System.nanoTime (nano0), in nanosecond unit.\r\n+    private static long nano0;\r\n+\r\n     static {\r\n-        if (JavaVersions.VERSION >= 5) {\r\n-            try {\r\n-                Class timestamp5HelperClass = Class\r\n-                    .forName(\"org.apache.openjpa.lib.util.Timestamp5Helper\");\r\n-                instance = (TimestampHelper) timestamp5HelperClass\r\n-                    .newInstance();\r\n-            } catch (Throwable e) {\r\n-                instance = new TimestampHelper();\r\n-            }\r\n-        } else {\r\n-            instance = new TimestampHelper();\r\n-        }\r\n+        // initialize base time in second and fraction of second (ns).\r\n+        long curTime = System.currentTimeMillis();\r\n+        sec0 = curTime / MilliMuliplier;\r\n+        nano0 = (curTime % MilliMuliplier) * MicroMuliplier - System.nanoTime();\r\n     }\r\n \r\n     /*\r\n      * Return a java.sql.Timestamp object of current time.\r\n      */\r\n     public static Timestamp getNanoPrecisionTimestamp() {\r\n-        return instance.getTimestamp();\r\n-    }\r\n-    \r\n-    /*\r\n-     * This class implements a millisecond precision Timestamp.\r\n-     */\r\n-    protected Timestamp getTimestamp() { \r\n-        return new Timestamp(System.currentTimeMillis());\r\n+        long nano_delta = nano0 + System.nanoTime();\r\n+        long sec1 = sec0 + (nano_delta / NanoMuliplier);\r\n+        long nano1 = nano_delta % NanoMuliplier;\r\n+\r\n+        Timestamp rtnTs = new Timestamp(sec1 * MilliMuliplier);\r\n+        rtnTs.setNanos((int) nano1);\r\n+        return rtnTs;\r\n     }\r\n }\r"},{"sha":"012f867e2b2baccffd2545acac4d88405d62e7df","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractCollection.java","status":"removed","additions":0,"deletions":50,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractCollection.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractCollection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractCollection.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49","patch":"@@ -1,50 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-/*\n- * Written by Dawid Kurzyniec, based on public domain code written by Doug Lea\n- * and publictly available documentation, and released to the public domain, as\n- * explained at http://creativecommons.org/licenses/publicdomain\n- */\n-package org.apache.openjpa.lib.util.concurrent;\n-\n-/**\n- * Overrides toArray() and toArray(Object[]) in AbstractCollection to provide\n- * implementations valid for concurrent collections.\n- *\n- * @author Doug Lea\n- * @author Dawid Kurzyniec\n- */\n-abstract class AbstractCollection extends java.util.AbstractCollection {\n-\n-    /**\n-     * Sole constructor. (For invocation by subclass constructors, typically\n-     * implicit.)\n-     */\n-    protected AbstractCollection() {\n-        super();\n-    }\n-\n-    public Object[] toArray() {\n-        return Utils.collectionToArray(this);\n-    }\n-\n-    public Object[] toArray(Object[] a) {\n-        return Utils.collectionToArray(this, a);\n-    }\n-}"},{"sha":"b28b1763d6e01bb2721483a25a474926ba15954f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractConcurrentEventManager.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractConcurrentEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractConcurrentEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractConcurrentEventManager.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3","patch":"@@ -24,6 +24,7 @@\n import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n \n import org.apache.openjpa.lib.util.EventManager;\n \n@@ -39,7 +40,7 @@\n public abstract class AbstractConcurrentEventManager\n     implements EventManager, Serializable {\n \n-    private static Exception[] EMPTY_EXCEPTIONS = new Exception[0];\n+    private static final Exception[] EMPTY_EXCEPTIONS = new Exception[0];\n \n     protected final Collection _listeners;\n     private boolean _failFast = false;"},{"sha":"8aaa77939194d5c16cba4027fee8ebc34e59ab81","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractQueue.java","status":"removed","additions":0,"deletions":173,"changes":173,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractQueue.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractQueue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractQueue.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49","patch":"@@ -1,173 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-/*\n- * Written by Doug Lea with assistance from members of JCP JSR-166\n- * Expert Group and released to the public domain, as explained at\n- * http://creativecommons.org/licenses/publicdomain\n- */\n-package org.apache.openjpa.lib.util.concurrent;\n-\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.NoSuchElementException;\n-\n-/**\n- * This class provides skeletal implementations of some {@link Queue}\n- * operations. The implementations in this class are appropriate when\n- * the base implementation does <em>not</em> allow <tt>null</tt>\n- * elements. Methods {@link #add add}, {@link #remove remove}, and\n- * {@link #element element} are based on {@link #offer offer}, {@link\n- * #poll poll}, and {@link #peek peek}, respectively but throw\n- * exceptions instead of indicating failure via <tt>false</tt> or\n- * <tt>null</tt> returns.\n- * A <tt>Queue</tt> implementation that extends this class must\n- * minimally define a method {@link Queue#offer} which does not permit\n- * insertion of <tt>null</tt> elements, along with methods {@link\n- * Queue#peek}, {@link Queue#poll}, {@link Collection#size}, and a\n- * {@link Collection#iterator} supporting {@link\n- * Iterator#remove}. Typically, additional methods will be overridden\n- * as well. If these requirements cannot be met, consider instead\n- * subclassing {@link AbstractCollection}. This class is a member of the\n- * <a href=\"{@docRoot}/../guide/collections/index.html\">\n- * Java Collections Framework</a>.\n- *\n- * @author Doug Lea\n- * @since 1.5\n- */\n-abstract class AbstractQueue extends AbstractCollection implements Queue {\n-\n-    /**\n-     * Constructor for use by subclasses.\n-     */\n-    protected AbstractQueue() {\n-    }\n-\n-    /**\n-     * Inserts the specified element into this queue if it is possible to do so\n-     * immediately without violating capacity restrictions, returning\n-     * <tt>true</tt> upon success and throwing an <tt>IllegalStateException</tt>\n-     * if no space is currently available.\n-     * This implementation returns <tt>true</tt> if <tt>offer</tt> succeeds,\n-     * else throws an <tt>IllegalStateException</tt>.\n-     *\n-     * @param e the element to add\n-     * @return <tt>true</tt> (as specified by {@link Collection#add})\n-     * @throws IllegalStateException if the element cannot be added at this\n-     * time due to capacity restrictions\n-     * @throws ClassCastException if the class of the specified element\n-     * prevents it from being added to this queue\n-     * @throws NullPointerException if the specified element is null and\n-     * this queue not permit null elements\n-     * @throws IllegalArgumentException if some property of this element\n-     * prevents it from being added to this queue\n-     */\n-    public boolean add(Object e) {\n-        if (offer(e))\n-            return true;\n-        else\n-            throw new IllegalStateException(\"Queue full\");\n-    }\n-\n-    /**\n-     * Retrieves and removes the head of this queue. This method differs\n-     * from {@link #poll poll} only in that it throws an exception if this\n-     * queue is empty. This implementation returns the result of <tt>poll</tt>\n-     * unless the queue is empty.\n-     *\n-     * @return the head of this queue\n-     * @throws NoSuchElementException if this queue is empty\n-     */\n-    public Object remove() {\n-        Object x = poll();\n-        if (x != null)\n-            return x;\n-        else\n-            throw new NoSuchElementException();\n-    }\n-\n-    /**\n-     * Retrieves, but does not remove, the head of this queue. This method\n-     * differs from {@link #peek peek} only in that it throws an exception if\n-     * this queue is empty.\n-     * This implementation returns the result of <tt>peek</tt>\n-     * unless the queue is empty.\n-     *\n-     * @return the head of this queue\n-     * @throws NoSuchElementException if this queue is empty\n-     */\n-    public Object element() {\n-        Object x = peek();\n-        if (x != null)\n-            return x;\n-        else\n-            throw new NoSuchElementException();\n-    }\n-\n-    /**\n-     * Removes all of the elements from this queue.\n-     * The queue will be empty after this call returns.\n-     * This implementation repeatedly invokes {@link #poll poll} until it\n-     * returns <tt>null</tt>.\n-     */\n-    public void clear() {\n-        while (poll() != null)\n-            ;\n-    }\n-\n-    /**\n-     * Adds all of the elements in the specified collection to this\n-     * queue. Attempts to addAll of a queue to itself result in\n-     * <tt>IllegalArgumentException</tt>. Further, the behavior of\n-     * this operation is undefined if the specified collection is\n-     * modified while the operation is in progress.\n-     * This implementation iterates over the specified collection,\n-     * and adds each element returned by the iterator to this\n-     * queue, in turn. A runtime exception encountered while\n-     * trying to add an element(including, in particular, a\n-     * <tt>null</tt> element) may result in only some of the elements\n-     * having been successfully added when the associated exception is thrown.\n-     *\n-     * @param c collection containing elements to be added to this queue\n-     * @return <tt>true</tt> if this queue changed as a result of the call\n-     * @throws ClassCastException if the class of an element of the specified\n-     * collection prevents it from being added to this queue\n-     * @throws NullPointerException if the specified collection contains a\n-     * null element and this queue does not permit null elements,\n-     * or if the specified collection is null\n-     * @throws IllegalArgumentException if some property of an element of the\n-     * specified collection prevents it from being added to this\n-     * queue, or if the specified collection is this queue\n-     * @throws IllegalStateException if not all the elements can be added at\n-     * this time due to insertion restrictions\n-     * @see #add(Object)\n-     */\n-    public boolean addAll(Collection c) {\n-        if (c == null)\n-            throw new NullPointerException();\n-        if (c == this)\n-            throw new IllegalArgumentException();\n-        boolean modified = false;\n-        Iterator e = c.iterator();\n-        while (e.hasNext()) {\n-            if (add(e.next()))\n-                modified = true;\n-        }\n-        return modified;\n-    }\n-}"},{"sha":"cc7fc73a054349e1d0f84d0b4a3b2b2ad3ecc32a","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractSet.java","status":"removed","additions":0,"deletions":50,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractSet.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/AbstractSet.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49","patch":"@@ -1,50 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-/*\n- * Written by Dawid Kurzyniec, based on public domain code written by Doug Lea\n- * and publictly available documentation, and released to the public domain, as\n- * explained at http://creativecommons.org/licenses/publicdomain\n- */\n-package org.apache.openjpa.lib.util.concurrent;\n-\n-/**\n- * Overrides toArray() and toArray(Object[]) in AbstractCollection to provide\n- * implementations valid for concurrent sets.\n- *\n- * @author Doug Lea\n- * @author Dawid Kurzyniec\n- */\n-abstract class AbstractSet extends java.util.AbstractSet {\n-\n-    /**\n-     * Sole constructor. (For invocation by subclass constructors, typically\n-     * implicit.)\n-     */\n-    protected AbstractSet() {\n-        super();\n-    }\n-\n-    public Object[] toArray() {\n-        return Utils.collectionToArray(this);\n-    }\n-\n-    public Object[] toArray(Object[] a) {\n-        return Utils.collectionToArray(this, a);\n-    }\n-}"},{"sha":"1c6e5a74283943b9a3640c77ab00215d4b2e88ce","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Arrays.java","status":"removed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Arrays.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Arrays.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Arrays.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49"},{"sha":"e66adfbbca65e8f034a49e9d2e732f09d89ee13e","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashMap.java","status":"removed","additions":0,"deletions":941,"changes":941,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashMap.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49"},{"sha":"7220ea975f0860f14ed742e3c78b59388ea0acba","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashSet.java","status":"removed","additions":0,"deletions":110,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashSet.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentHashSet.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49"},{"sha":"5000350403403dfd13f264bb03af6a4e3528595d","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentLinkedQueue.java","status":"removed","additions":0,"deletions":503,"changes":503,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentLinkedQueue.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentLinkedQueue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentLinkedQueue.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49"},{"sha":"27185d88af14adf57eb27596c0bb63df24a77040","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashSet.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashSet.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ConcurrentReferenceHashSet.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"de3be63a8f06333f5f61cc5cd529f8d05a88ce07","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CondVar.java","status":"removed","additions":0,"deletions":203,"changes":203,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CondVar.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CondVar.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CondVar.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49"},{"sha":"a3694af9d92f3f3b65ca7c25238fe94330b9a0e7","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Condition.java","status":"removed","additions":0,"deletions":385,"changes":385,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Condition.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Condition.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Condition.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49"},{"sha":"63895233253016aff4ec63b3b39f99b9ef407c81","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArrayList.java","status":"removed","additions":0,"deletions":951,"changes":951,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArrayList.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArrayList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArrayList.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49"},{"sha":"d96d15aa8ba4f1791fdc45a348430407a0cd577b","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArraySet.java","status":"removed","additions":0,"deletions":360,"changes":360,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArraySet.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArraySet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/CopyOnWriteArraySet.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49"},{"sha":"bf4089c269edfdc8474ef9705fd85c1b7c4216c0","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOCondVar.java","status":"removed","additions":0,"deletions":159,"changes":159,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOCondVar.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOCondVar.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOCondVar.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49"},{"sha":"062fde7349b5236f00be8b55d7386a698d7d0200","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOWaitQueue.java","status":"removed","additions":0,"deletions":97,"changes":97,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOWaitQueue.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOWaitQueue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/FIFOWaitQueue.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49"},{"sha":"5b431aeffcc78a376e7a4d7cd60378c40afddfca","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Lock.java","status":"removed","additions":0,"deletions":282,"changes":282,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Lock.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Lock.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Lock.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49"},{"sha":"5a781e4d53f44628ab6f9c4265bba5cc745d2085","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NanoTimer.java","status":"removed","additions":0,"deletions":48,"changes":48,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NanoTimer.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NanoTimer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NanoTimer.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49"},{"sha":"cdde04d5b5f3c53d7015cd0eb6087b9ac0578e52","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","status":"added","additions":241,"deletions":0,"changes":241,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"5275783c8e6234850a1255a2c1fe24ec3bd6b139","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Queue.java","status":"removed","additions":0,"deletions":201,"changes":201,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Queue.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Queue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Queue.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49"},{"sha":"bd4b3ce34f77b89a21295d9cfeca0c7305be8223","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ReentrantLock.java","status":"removed","additions":0,"deletions":856,"changes":856,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ReentrantLock.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ReentrantLock.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/ReentrantLock.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49"},{"sha":"6428c1cb7d52833f6d766acc46f165019865c690","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","status":"added","additions":152,"deletions":0,"changes":152,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"2dc17fc64a9c236bdc5a31239bf3b23e1a8b3317","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/TimeUnit.java","status":"removed","additions":0,"deletions":558,"changes":558,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/TimeUnit.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/TimeUnit.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/TimeUnit.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49"},{"sha":"06bf5f3f95105b174a94279cf1f1824603c43826","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Utils.java","status":"removed","additions":0,"deletions":345,"changes":345,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Utils.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Utils.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/Utils.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49"},{"sha":"68df261741b50344de2ef897647e55cd0419f27d","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/WaitQueue.java","status":"removed","additions":0,"deletions":152,"changes":152,"blob_url":"https://github.com/apache/openjpa/blob/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/WaitQueue.java","raw_url":"https://github.com/apache/openjpa/raw/6af619cd891e793efe4c239f4e4815b89d119d49/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/WaitQueue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/WaitQueue.java?ref=6af619cd891e793efe4c239f4e4815b89d119d49"},{"sha":"0495c18519e646680e3da1c89f47cfebb33eadc0","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"d976d2c7d8e7d9b3ea77dff84e4ae31ac56d538e","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java","status":"modified","additions":100,"deletions":100,"changes":200,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"8145713e4738288a53aa5ee517cd806da9325d8b","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestConcurrentMap.java","status":"modified","additions":9,"deletions":7,"changes":16,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestConcurrentMap.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestConcurrentMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestConcurrentMap.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"2f5b8e508ef0c2f2f21b29fdd5efdeab96028077","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java","status":"added","additions":126,"deletions":0,"changes":126,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"7035f7ed2a48158ac7b471dfa0a6f9a4054a1561","filename":"openjpa-persistence-jdbc/pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-persistence-jdbc/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-persistence-jdbc/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/pom.xml?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"e4645c73a700acfbf66c15cd10a56795b06ee270","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestExceptionsFromCallbacks.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestExceptionsFromCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestExceptionsFromCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestExceptionsFromCallbacks.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"dfbf272a6cf5c342fd9a785787da79c0b7980503","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/utils/AbstractTestCase.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/utils/AbstractTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/utils/AbstractTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/utils/AbstractTestCase.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"e2fbb6c9bc03761dd7dc9b4dc5e7c42092be7856","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/discriminator/TestDiscriminatorTypes.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/discriminator/TestDiscriminatorTypes.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/discriminator/TestDiscriminatorTypes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/discriminator/TestDiscriminatorTypes.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"ab7dcc2f3f0bcdf045975a283463078b32e2cc71","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/TestPessimisticLocking.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/TestPessimisticLocking.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/TestPessimisticLocking.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/TestPessimisticLocking.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"0b11839a75522843e8196aa9c91210974b09ca6d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/TestRetainValuesInOptimistic.java","status":"modified","additions":0,"deletions":6,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/TestRetainValuesInOptimistic.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/TestRetainValuesInOptimistic.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/kernel/TestRetainValuesInOptimistic.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"9798089b94388bca3ff96b2fb5ac1979d8bdeaf0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/TestHandlerToRelationMaps.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/TestHandlerToRelationMaps.java","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/TestHandlerToRelationMaps.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/relations/TestHandlerToRelationMaps.java?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"aad904998dcb6cc8265fdd0eecf11aac182e6b4a","filename":"openjpa-persistence/pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-persistence/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-persistence/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/pom.xml?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"acb4618cda73c2271c5512c5d22b030f9b644564","filename":"openjpa-xmlstore/pom.xml","status":"modified","additions":2,"deletions":22,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-xmlstore/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/openjpa-xmlstore/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-xmlstore/pom.xml?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"},{"sha":"e2fc392d277f625f02e7dc8a610795a2863d7ab0","filename":"pom.xml","status":"modified","additions":3,"deletions":16,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/b2c1e8f16ffb4fa129249ba88deba4d762adc6c3/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/pom.xml?ref=b2c1e8f16ffb4fa129249ba88deba4d762adc6c3"}]}

