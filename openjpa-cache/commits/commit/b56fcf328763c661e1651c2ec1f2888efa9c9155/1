{"sha":"b56fcf328763c661e1651c2ec1f2888efa9c9155","node_id":"MDY6Q29tbWl0MjA2MzY0OmI1NmZjZjMyODc2M2M2NjFlMTY1MWMyZWMxZjI4ODhlZmE5YzkxNTU=","commit":{"author":{"name":"Jeremy Bauer","email":"jrbauer@apache.org","date":"2010-12-06T16:09:08Z"},"committer":{"name":"Jeremy Bauer","email":"jrbauer@apache.org","date":"2010-12-06T16:09:08Z"},"message":"OPENJPA-1884 Updated entity manager impl to process cache store mode property provided on refresh method and updated data cache manager to refresh the L2 properly when a store mode is provided.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@1042698 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"895dbeae489cf44f7ec0890cac6662dd7c10065b","url":"https://api.github.com/repos/apache/openjpa/git/trees/895dbeae489cf44f7ec0890cac6662dd7c10065b"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/b56fcf328763c661e1651c2ec1f2888efa9c9155","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/b56fcf328763c661e1651c2ec1f2888efa9c9155","html_url":"https://github.com/apache/openjpa/commit/b56fcf328763c661e1651c2ec1f2888efa9c9155","comments_url":"https://api.github.com/repos/apache/openjpa/commits/b56fcf328763c661e1651c2ec1f2888efa9c9155/comments","author":null,"committer":null,"parents":[{"sha":"502a5996b7b9a3ad611db0a3e70ff3805acc37e9","url":"https://api.github.com/repos/apache/openjpa/commits/502a5996b7b9a3ad611db0a3e70ff3805acc37e9","html_url":"https://github.com/apache/openjpa/commit/502a5996b7b9a3ad611db0a3e70ff3805acc37e9"}],"stats":{"total":293,"additions":280,"deletions":13},"files":[{"sha":"4980e629ef8ae3b6f38e4c29f6d924021c1b3602","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","status":"modified","additions":55,"deletions":12,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/b56fcf328763c661e1651c2ec1f2888efa9c9155/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/b56fcf328763c661e1651c2ec1f2888efa9c9155/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java?ref=b56fcf328763c661e1651c2ec1f2888efa9c9155","patch":"@@ -24,7 +24,6 @@\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n@@ -437,8 +436,13 @@ private void cacheStateManager(DataCache cache, OpenJPAStateManager sm, DataCach\n     public boolean load(OpenJPAStateManager sm, BitSet fields,\n         FetchConfiguration fetch, int lockLevel, Object edata) {\n         DataCache cache = _mgr.selectCache(sm);\n-        if (cache == null || sm.isEmbedded() || bypass(fetch, StoreManager.FORCE_LOAD_NONE))\n-            return super.load(sm, fields, fetch, lockLevel, edata);\n+\n+        boolean found = false;\n+        if (cache == null || sm.isEmbedded() || bypass(fetch, StoreManager.FORCE_LOAD_NONE)) {\n+            found = super.load(sm, fields, fetch, lockLevel, edata);\n+            updateDataCache(found, sm, fetch);\n+            return found;\n+        }\n \n         CacheStatistics stats = cache.getStatistics();\n         DataCachePCData data = cache.get(sm.getObjectId());\n@@ -454,20 +458,59 @@ public boolean load(OpenJPAStateManager sm, BitSet fields,\n \n         // load from store manager; clone the set of still-unloaded fields\n         // so that if the store manager decides to modify it it won't affect us\n-        if (!super.load(sm, (BitSet) fields.clone(), fetch, lockLevel, edata))\n-            return false;\n-        if (_ctx.getPopulateDataCache()) {\n-            cacheStateManager(cache, sm, data);\n+        found = super.load(sm, (BitSet) fields.clone(), fetch, lockLevel, edata);\n+\n+        // Get new instance of cache after DB load since it may have changed\n+        updateDataCache(found, sm, fetch);\n+\n+        return found;\n+    }\n+\n+    /**\n+     * Updates or inserts and item into the data cache.  If storeMode=USE and not in the cache,\n+     * the item is inserted.  If storeMode=REFRESH the item is inserted, updated, or if found=false, \n+     * removed from the cache.\n+     * @param found whether the entity was found by the store manager\n+     * @param sm the state manager\n+     * @param fetch fetch configuration\n+     */\n+    private void updateDataCache(boolean found, OpenJPAStateManager sm, FetchConfiguration fetch) {\n+\n+        if (!_ctx.getPopulateDataCache() || sm == null || fetch.getCacheStoreMode() == DataCacheStoreMode.BYPASS) {\n+            return;\n+        }\n+\n+        DataCache cache = _mgr.selectCache(sm);\n+        if (cache == null) {\n+            return;\n         }\n-        return true;\n \n+        DataCachePCData data = cache.get(sm.getObjectId());\n+        boolean alreadyCached = data != null;\n+\n+        if ((fetch.getCacheStoreMode() == DataCacheStoreMode.USE && !alreadyCached) ||\n+             fetch.getCacheStoreMode() == DataCacheStoreMode.REFRESH) {\n+            // If not found in the DB and the item is in the cache, and not locking remove the item\n+            if (!found && data != null && !isLocking(fetch)) {\n+                cache.remove(sm.getObjectId());\n+                return;\n+            }\n+            // Update or insert the item into the cache\n+            if (found) {\n+                cacheStateManager(cache, sm, data);\n+                CacheStatistics stats = cache.getStatistics();\n+                if (stats.isEnabled()) {\n+                    ((CacheStatisticsSPI) stats).newPut(sm.getMetaData().getDescribedType());\n+                }\n+            }\n+        }\n     }\n \n     public Collection<Object> loadAll(Collection<OpenJPAStateManager> sms, PCState state, int load,\n-    \t\tFetchConfiguration fetch, Object edata) {\n-    \tif (bypass(fetch, load)) {\n-    \t    return super.loadAll(sms, state, load, fetch, edata);\n-    \t}\n+        FetchConfiguration fetch, Object edata) {\n+        if (bypass(fetch, load)) {\n+            return super.loadAll(sms, state, load, fetch, edata);\n+        }\n \n         Map<OpenJPAStateManager, BitSet> unloaded = null;\n         List<OpenJPAStateManager> smList = null;"},{"sha":"b0acea7aafcd3c166e7668b1b85c85cea0d2f8ce","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestMultiEMFCacheModes.java","status":"added","additions":223,"deletions":0,"changes":223,"blob_url":"https://github.com/apache/openjpa/blob/b56fcf328763c661e1651c2ec1f2888efa9c9155/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestMultiEMFCacheModes.java","raw_url":"https://github.com/apache/openjpa/raw/b56fcf328763c661e1651c2ec1f2888efa9c9155/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestMultiEMFCacheModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/cache/jpa/TestMultiEMFCacheModes.java?ref=b56fcf328763c661e1651c2ec1f2888efa9c9155","patch":"@@ -0,0 +1,223 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence.cache.jpa;\r\n+\r\n+import java.util.Random;\r\n+\r\n+import javax.persistence.Cache;\r\n+import javax.persistence.CacheStoreMode;\r\n+import javax.persistence.EntityManager;\r\n+import javax.persistence.EntityManagerFactory;\r\n+import javax.persistence.EntityNotFoundException;\r\n+import javax.persistence.LockModeType;\r\n+\r\n+\r\n+import org.apache.openjpa.persistence.cache.jpa.featureSelection.CacheableEntity;\r\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n+\r\n+/**\r\n+ * Verifies L2 operations using multiple entity manager factories. The EMF which\r\n+ * does updates does not have the data cache enabled thus, it does not send\r\n+ * sjvm updates upon commit.\r\n+ */\r\n+public class TestMultiEMFCacheModes extends SingleEMFTestCase {\r\n+\r\n+    public void setUp() {\r\n+        setUp( CLEAR_TABLES, CacheableEntity.class,\r\n+               \"openjpa.ConnectionFactoryProperties\", \"PrintParameters=true\",\r\n+               \"openjpa.DataCache\", \"true\");\r\n+    }\r\n+\r\n+    /**\r\n+     * Verifies that the data cache us updated via a em.refresh operation when \r\n+     * javax.persistence.cache.storeMode = CacheStoreMode.REFRESH and the\r\n+     * entity is updated in the database.\r\n+     */\r\n+    public void testCacheRefreshModeRefresh() {\r\n+\r\n+        EntityManager em = emf.createEntityManager();\r\n+        \r\n+        // Create a new cacheable entity\r\n+        CacheableEntity ce = createEntity(em);\r\n+        int ceid = ce.getId();\r\n+\r\n+        // Clear the L1\r\n+        em.clear();\r\n+        \r\n+        // Clear the L2 cache\r\n+        Cache cache = emf.getCache();\r\n+        cache.evictAll();\r\n+        assertFalse(cache.contains(CacheableEntity.class, ceid));\r\n+\r\n+        // Find the entity, reloading it into the L2 \r\n+        em.getTransaction().begin();\r\n+        ce = em.find(CacheableEntity.class, ceid);\r\n+        assertTrue(em.contains(ce));\r\n+        assertTrue(cache.contains(CacheableEntity.class, ceid));\r\n+        assertTrue(em.getLockMode(ce) == LockModeType.NONE);\r\n+        assertEquals(ce.getName(), \"Cached Entity\");\r\n+        assertEquals(ce.getVersion(), 1);\r\n+        em.getTransaction().commit();\r\n+\r\n+        // Create a new EMF -WITHOUT- the L2 enabled.  If the L2 was enabled, the\r\n+        // sjvm remote commit provider would evict the entity upon update, throwing\r\n+        // off the intent of this variation.\r\n+        EntityManagerFactory emf2 = this.createEMF(CacheableEntity.class,\r\n+            \"openjpa.LockManager\", \"mixed\",\r\n+            \"openjpa.ConnectionFactoryProperties\", \"PrintParameters=true\");\r\n+        EntityManager em2 = emf2.createEntityManager();\r\n+        \r\n+        // Find + lock, then update the entity and commit\r\n+        em2.getTransaction().begin();\r\n+        CacheableEntity ce2 = em2.find(CacheableEntity.class, ceid, LockModeType.PESSIMISTIC_FORCE_INCREMENT);\r\n+        ce2.setName(\"Updated Cached Entity\");\r\n+        em2.getTransaction().commit();\r\n+        em2.close();\r\n+        emf2.close();\r\n+\r\n+        // Refresh the entity - this will load the entity into the L1 and with storeMode=REFRESH, \r\n+        // should also refresh it in the L2\r\n+        java.util.Map<String, Object> cacheStoreModeMap = new java.util.HashMap<String, Object>();\r\n+        cacheStoreModeMap.put(\"javax.persistence.cache.storeMode\", CacheStoreMode.REFRESH);\r\n+        em.refresh(ce, cacheStoreModeMap);\r\n+\r\n+        // Verify the entity was updated\r\n+        verifyUpdatedEntity(ce, ceid);\r\n+\r\n+        // Verify loading from the L1\r\n+        ce = em.find(CacheableEntity.class, ceid);\r\n+        \r\n+        // Verify the entity was updated\r\n+        verifyUpdatedEntity(ce, ceid);\r\n+\r\n+        // Clear the L1\r\n+        em.clear();\r\n+\r\n+        // Assert the L2 contains the entity\r\n+        assertTrue(cache.contains(CacheableEntity.class, ceid));\r\n+\r\n+        // Reload the entity from the L2\r\n+        ce = em.find(CacheableEntity.class, ceid);\r\n+        \r\n+        // Verify the entity in the L2 was updated\r\n+        verifyUpdatedEntity(ce, ceid);\r\n+\r\n+        em.close();\r\n+    }\r\n+\r\n+    /**\r\n+     * Verifies that the data cache us updated via a em.refresh operation when \r\n+     * javax.persistence.cache.storeMode = CacheStoreMode.REFRESH and the \r\n+     * record is removed from the database.\r\n+     */\r\n+    public void testCacheRefreshModeRefreshDelete() {\r\n+\r\n+        EntityManager em = emf.createEntityManager();\r\n+\r\n+        // Create a new cachable entity\r\n+        CacheableEntity ce = createEntity(em);\r\n+        int ceid = ce.getId();\r\n+\r\n+        // Clear the L2 cache\r\n+        Cache cache = emf.getCache();\r\n+        cache.evictAll();\r\n+        assertFalse(cache.contains(CacheableEntity.class, ceid));\r\n+\r\n+        // Find the entity, reloading it into the L2 \r\n+        em.getTransaction().begin();\r\n+        ce = em.find(CacheableEntity.class, ceid);\r\n+        assertTrue(em.contains(ce));\r\n+        assertTrue(cache.contains(CacheableEntity.class, ceid));\r\n+        assertTrue(em.getLockMode(ce) == LockModeType.NONE);\r\n+        assertEquals(ce.getName(), \"Cached Entity\");\r\n+        assertEquals(ce.getVersion(), 1);\r\n+        em.getTransaction().commit();\r\n+\r\n+        // Create a new EMF -WITHOUT- the L2 enabled.  If the L2 was enabled, the\r\n+        // sjvm remote commit provider would evict the entity upon delete, throwing\r\n+        // off the intent of this variation.\r\n+        EntityManagerFactory emf2 = this.createEMF(CacheableEntity.class,\r\n+            \"openjpa.LockManager\", \"mixed\",\r\n+            \"openjpa.ConnectionFactoryProperties\", \"PrintParameters=true\");\r\n+        EntityManager em2 = emf2.createEntityManager();\r\n+\r\n+        // Find and delete the entity in a separate context with no L2 configured\r\n+        em2.getTransaction().begin();\r\n+        CacheableEntity ce2 = em2.find(CacheableEntity.class, ceid);\r\n+        assertNotNull(ce2);\r\n+        em2.remove(ce2);\r\n+        em2.getTransaction().commit();\r\n+        em2.close();\r\n+        emf2.close();\r\n+\r\n+        // Refresh the entity with storeMode=REFRESH.  The entity has been deleted so it will be\r\n+        // purged from the L2 cache when the DB load fails.\r\n+        java.util.Map<String, Object> cacheStoreModeMap = new java.util.HashMap<String, Object>();\r\n+        cacheStoreModeMap.put(\"javax.persistence.cache.storeMode\", CacheStoreMode.REFRESH);\r\n+        try {\r\n+            em.refresh(ce, cacheStoreModeMap);\r\n+            fail(\"Refresh operation should have thrown an exception\");\r\n+        } catch (EntityNotFoundException e) {\r\n+            // expected exception\r\n+        }\r\n+\r\n+        // Try loading from the L1 - OpenJPA will detect the entity was\r\n+        // removed in another transaction.\r\n+        try {\r\n+            ce = em.find(CacheableEntity.class, ceid);\r\n+            fail(\"OpenJPA should have detected the removed entity\");\r\n+        } catch (EntityNotFoundException e) {\r\n+            // expected exception\r\n+        }\r\n+\r\n+        // Clear the L1\r\n+        em.clear();\r\n+\r\n+        // Assert the L2 no longer contains the entity\r\n+        assertFalse(cache.contains(CacheableEntity.class, ceid));\r\n+\r\n+        // Attempt to reload entity from the L2 or database\r\n+        ce = em.find(CacheableEntity.class, ceid);\r\n+\r\n+        // Verify the entity was removed from L2 and DB\r\n+        assertNull(ce);\r\n+\r\n+        em.close();\r\n+\t}\r\n+\r\n+\tprivate CacheableEntity createEntity(EntityManager em) {\r\n+        CacheableEntity ce = new CacheableEntity();\r\n+        int ceid = new Random().nextInt();\r\n+        ce.setId(ceid);\r\n+        ce.setName(\"Cached Entity\");\r\n+\r\n+        // Persist the new cachable entity\r\n+        em.getTransaction().begin();\r\n+        em.persist(ce);\r\n+        em.getTransaction().commit();\r\n+        em.clear();\r\n+        return ce;\r\n+    }\r\n+\r\n+    private void verifyUpdatedEntity(CacheableEntity ce, int id) {\r\n+        assertEquals(id, ce.getId());\r\n+        assertEquals(\"Updated Cached Entity\", ce.getName());\r\n+        assertEquals(2, ce.getVersion());\r\n+    }\r\n+}\r"},{"sha":"18e39c9304e2598b5ab165c08efd9750cea3c06f","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/b56fcf328763c661e1651c2ec1f2888efa9c9155/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/b56fcf328763c661e1651c2ec1f2888efa9c9155/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java?ref=b56fcf328763c661e1651c2ec1f2888efa9c9155","patch":"@@ -761,7 +761,8 @@ public void refresh(Object entity, LockModeType mode, Map<String, Object> proper\n         assertValidAttchedEntity(REFRESH, entity);\n \n         _broker.assertWriteOperation();\n-        configureCurrentFetchPlan(pushFetchPlan(), properties, mode, true);\n+        configureCurrentCacheModes(pushFetchPlan(), properties);\n+        configureCurrentFetchPlan(getFetchPlan(), properties, mode, true);\n         DataCacheRetrieveMode rmode = getFetchPlan().getCacheRetrieveMode();\n         if (DataCacheRetrieveMode.USE.equals(rmode) || rmode == null) {\n             getFetchPlan().setCacheRetrieveMode(DataCacheRetrieveMode.BYPASS);"}]}

