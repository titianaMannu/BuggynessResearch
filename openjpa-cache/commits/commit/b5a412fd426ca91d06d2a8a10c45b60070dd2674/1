{"sha":"b5a412fd426ca91d06d2a8a10c45b60070dd2674","node_id":"MDY6Q29tbWl0MjA2MzY0OmI1YTQxMmZkNDI2Y2E5MWQwNmQyYThhMTBjNDViNjAwNzBkZDI2NzQ=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2010-01-15T05:23:15Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2010-01-15T05:23:15Z"},"message":"OPENJPA-900: Reduce reflection in hint processing. Redesign with explicit hint keys.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@899529 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"928bd48b408f26e258151d5b912a71e8500ade83","url":"https://api.github.com/repos/apache/openjpa/git/trees/928bd48b408f26e258151d5b912a71e8500ade83"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/b5a412fd426ca91d06d2a8a10c45b60070dd2674","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/b5a412fd426ca91d06d2a8a10c45b60070dd2674","html_url":"https://github.com/apache/openjpa/commit/b5a412fd426ca91d06d2a8a10c45b60070dd2674","comments_url":"https://api.github.com/repos/apache/openjpa/commits/b5a412fd426ca91d06d2a8a10c45b60070dd2674/comments","author":null,"committer":null,"parents":[{"sha":"dad4ad195225eaa68e6e3bed942822f0ea86d434","url":"https://api.github.com/repos/apache/openjpa/commits/dad4ad195225eaa68e6e3bed942822f0ea86d434","html_url":"https://github.com/apache/openjpa/commit/dad4ad195225eaa68e6e3bed942822f0ea86d434"}],"stats":{"total":1150,"additions":675,"deletions":475},"files":[{"sha":"b854e6b0d717ba355a57152982fcc7bbd96c16f6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCProductDerivation.java","status":"modified","additions":27,"deletions":9,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCProductDerivation.java?ref=b5a412fd426ca91d06d2a8a10c45b60070dd2674","patch":"@@ -18,14 +18,18 @@\n  */\n package org.apache.openjpa.jdbc.conf;\n \n+import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import org.apache.openjpa.conf.BrokerFactoryValue;\n import org.apache.openjpa.conf.OpenJPAProductDerivation;\n import org.apache.openjpa.jdbc.kernel.JDBCBrokerFactory;\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.sql.MySQLDictionary;\n import org.apache.openjpa.jdbc.sql.OracleDictionary;\n import org.apache.openjpa.lib.conf.AbstractProductDerivation;\n@@ -37,14 +41,8 @@\n public class JDBCProductDerivation extends AbstractProductDerivation\n     implements OpenJPAProductDerivation {\n \n-    private static Set<String> supportedQueryHints = new HashSet<String>(2);\n-\n-    static {\n-        supportedQueryHints.add(MySQLDictionary.SELECT_HINT);\n-        supportedQueryHints.add(OracleDictionary.SELECT_HINT);\n-        supportedQueryHints = Collections.unmodifiableSet(supportedQueryHints);\n-    }\n-\n+    public static final String PREFIX = \"openjpa.jdbc\"; \n+    \n     public void putBrokerFactoryAliases(Map m) {\n         m.put(\"jdbc\", JDBCBrokerFactory.class.getName());\n     }\n@@ -62,8 +60,28 @@ public boolean beforeConfigurationConstruct(ConfigurationProvider cp) {\n         return false;\n     }\n     \n+    /**\n+     * Hint keys correspond to some (not all) bean-style mutable property name in JDBCFetchConfiguration.\n+     * The fully qualified key is prefixed with <code>openjpa.jdbc</code>.\n+     */\n+    private static Set<String> _hints = new HashSet<String>();\n+    static {\n+        _hints.add(PREFIX + \".EagerFetchMode\");\n+        _hints.add(PREFIX + \".FetchDirection\");\n+        _hints.add(PREFIX + \".TransactionIsolation\");\n+        _hints.add(PREFIX + \".JoinSyntax\");\n+        _hints.add(PREFIX + \".LRSSize\");\n+        _hints.add(PREFIX + \".ResultSetType\");\n+        _hints.add(PREFIX + \".SubclassFetchMode\");\n+        \n+        _hints.add(MySQLDictionary.SELECT_HINT);\n+        _hints.add(OracleDictionary.SELECT_HINT);\n+        \n+        _hints = Collections.unmodifiableSet(_hints);\n+    }\n+\n     @Override\n     public Set<String> getSupportedQueryHints() {\n-        return supportedQueryHints;\n+        return _hints;\n     }\n }"},{"sha":"13dfc4fd82252f609ef81d87278fe0c07f200063","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java?ref=b5a412fd426ca91d06d2a8a10c45b60070dd2674","patch":"@@ -484,25 +484,25 @@ public void setHint(String name, Object value) {\n         }\n     }\n     \n-    public void setHint(String name, Object value, boolean validate) {\n+    public void setHint(String name, Object value, Object original) {\n         try {\n-            _fetch.setHint(name, value, validate);\n+            _fetch.setHint(name, value, original);\n         } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n \n-    public Object getHint(String name) {\n+    public boolean isHintSet(String key) {\n         try {\n-            return _fetch.getHint(name);\n+            return _fetch.isHintSet(key);\n         } catch (RuntimeException re) {\n             throw translate(re);\n         }\n     }\n     \n-    public void addHint(String name, Object value) {\n+    public Object getHint(String name) {\n         try {\n-            _fetch.addHint(name, value);\n+            return _fetch.getHint(name);\n         } catch (RuntimeException re) {\n             throw translate(re);\n         }\n@@ -515,7 +515,7 @@ public void addHint(String name, Object value) {\n             throw translate(re);\n         }\n     }\n-\n+    \n     public int requiresFetch(FieldMetaData fmd) {\n         try {\n             return _fetch.requiresFetch(fmd);"},{"sha":"819a91c3cb5d2f27f7f055182f10200ee6af125e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","status":"modified","additions":21,"deletions":20,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java?ref=b5a412fd426ca91d06d2a8a10c45b60070dd2674","patch":"@@ -126,7 +126,8 @@\n \n     // remember the list of all the results we have returned so we\n     // can free their resources when close or closeAll is called\n-    private transient final Collection<ResultList<?>> _resultLists = new ReferenceHashSet(ReferenceHashSet.WEAK);\n+    private transient final Collection<RemoveOnCloseResultList> _resultLists = \n+        new ReferenceHashSet(ReferenceHashSet.WEAK);\n \n     /**\n      * Construct a query managed by the given broker.\n@@ -1239,7 +1240,7 @@ protected Object toResult(StoreQuery q, StoreQuery.Executor ex,\n         boolean detach = (_broker.getAutoDetach() &\n             AutoDetach.DETACH_NONTXREAD) > 0 && !_broker.isActive();\n         boolean lrs = range.lrs && !ex.isAggregate(q) && !ex.hasGrouping(q);\n-        ResultList res = (!detach && lrs) ? _fc.newResultList(rop)\n+        ResultList<?> res = (!detach && lrs) ? _fc.newResultList(rop)\n             : new EagerResultList(rop);\n         res.setUserObject(new Object[]{rop,ex});\n         _resultLists.add(decorateResultList(res));\n@@ -1249,7 +1250,7 @@ protected Object toResult(StoreQuery q, StoreQuery.Executor ex,\n     /**\n      * Optionally decorate the native result.\n      */\n-    protected ResultList decorateResultList(ResultList res) {\n+    protected RemoveOnCloseResultList decorateResultList(ResultList<?> res) {\n         return new RemoveOnCloseResultList(res);\n     }\n \n@@ -1260,7 +1261,7 @@ private ResultPacker getResultPacker(StoreQuery q, StoreQuery.Executor ex) {\n         if (_packer != null)\n             return _packer;\n \n-        Class resultClass = (_resultClass != null) ? _resultClass\n+        Class<?> resultClass = (_resultClass != null) ? _resultClass\n             : ex.getResultClass(q);\n         if (resultClass == null)\n             return null;\n@@ -1279,7 +1280,7 @@ private ResultPacker getResultPacker(StoreQuery q, StoreQuery.Executor ex) {\n                 // into some result class\n                 _packer = new ResultPacker(_class, getAlias(), resultClass);\n             } else if (resultClass != null) { // projection\n-                Class[] types = ex.getProjectionTypes(q);\n+                Class<?>[] types = ex.getProjectionTypes(q);\n                 _packer = new ResultPacker(types, aliases, resultClass);\n             }\n         }\n@@ -1346,9 +1347,9 @@ private boolean isAccessPathDirty() {\n \n     public static boolean isAccessPathDirty(Broker broker,\n         ClassMetaData[] accessMetas) {\n-        Collection persisted = broker.getPersistedTypes();\n-        Collection updated = broker.getUpdatedTypes();\n-        Collection deleted = broker.getDeletedTypes();\n+        Collection<Class<?>> persisted = broker.getPersistedTypes();\n+        Collection<Class<?>> updated = broker.getUpdatedTypes();\n+        Collection<Class<?>> deleted = broker.getDeletedTypes();\n         if (persisted.isEmpty() && updated.isEmpty() && deleted.isEmpty())\n             return false;\n \n@@ -1358,7 +1359,7 @@ public static boolean isAccessPathDirty(Broker broker,\n             return true;\n \n         // compare dirty classes to the access path classes\n-        Class accClass;\n+        Class<?> accClass;\n         for (int i = 0; i < accessMetas.length; i++) {\n             if (accessMetas[i] == null)\n                 continue;\n@@ -1369,14 +1370,14 @@ public static boolean isAccessPathDirty(Broker broker,\n                 return true;\n \n             // check for dirty subclass\n-            for (Iterator dirty = persisted.iterator(); dirty.hasNext();)\n-                if (accClass.isAssignableFrom((Class) dirty.next()))\n+            for (Iterator<Class<?>> dirty = persisted.iterator(); dirty.hasNext();)\n+                if (accClass.isAssignableFrom(dirty.next()))\n                     return true;\n-            for (Iterator dirty = updated.iterator(); dirty.hasNext();)\n-                if (accClass.isAssignableFrom((Class) dirty.next()))\n+            for (Iterator<Class<?>> dirty = updated.iterator(); dirty.hasNext();)\n+                if (accClass.isAssignableFrom(dirty.next()))\n                     return true;\n-            for (Iterator dirty = deleted.iterator(); dirty.hasNext();)\n-                if (accClass.isAssignableFrom((Class) dirty.next()))\n+            for (Iterator<Class<?>> dirty = deleted.iterator(); dirty.hasNext();)\n+                if (accClass.isAssignableFrom(dirty.next()))\n                     return true;\n         }\n \n@@ -1401,8 +1402,8 @@ private void closeResults(boolean force) {\n             assertOpen();\n \n             RemoveOnCloseResultList res;\n-            for (Iterator itr = _resultLists.iterator(); itr.hasNext();) {\n-                res = (RemoveOnCloseResultList) itr.next();\n+            for (Iterator<RemoveOnCloseResultList> itr = _resultLists.iterator(); itr.hasNext();) {\n+                res = itr.next();\n                 if (force || res.isProviderOpen())\n                     res.close(false);\n             }\n@@ -1470,9 +1471,9 @@ public boolean setQuery(Object query) {\n             // don't share mutable objects\n             _fc.copy(q._fc);\n             if (q._filtListeners != null)\n-                _filtListeners = new HashMap(q._filtListeners);\n+                _filtListeners = new HashMap<String,FilterListener>(q._filtListeners);\n             if (q._aggListeners != null)\n-                _aggListeners = new HashMap(q._aggListeners);\n+                _aggListeners = new HashMap<String,AggregateListener>(q._aggListeners);\n             return true;\n         } finally {\n             unlock();\n@@ -1500,7 +1501,7 @@ public String getAlias() {\n         }\n     }\n \n-    public Class[] getProjectionTypes() {\n+    public Class<?>[] getProjectionTypes() {\n         lock();\n         try {\n             return compileForExecutor().getProjectionTypes(_storeQuery);"},{"sha":"bc2f27c179d2308b01117ac3bc48816a191b1771","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/FetchMode.java","status":"modified","additions":34,"deletions":7,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/FetchMode.java","raw_url":"https://github.com/apache/openjpa/raw/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/FetchMode.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/FetchMode.java?ref=b5a412fd426ca91d06d2a8a10c45b60070dd2674","patch":"@@ -19,6 +19,8 @@\n package org.apache.openjpa.persistence.jdbc;\n \n import org.apache.openjpa.jdbc.kernel.EagerFetchModes;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.persistence.OpenJPAEnum;\n \n /**\n  * Type of fetching to employ.\n@@ -27,18 +29,20 @@\n  * @since 0.4.0\n  * @published\n  */\n-public enum FetchMode {\n-    NONE(EagerFetchModes.EAGER_NONE),\n-    JOIN(EagerFetchModes.EAGER_JOIN),\n-    PARALLEL(EagerFetchModes.EAGER_PARALLEL);\n+public enum FetchMode implements OpenJPAEnum<FetchMode>{\n+    NONE(EagerFetchModes.EAGER_NONE, \"none\"),\n+    JOIN(EagerFetchModes.EAGER_JOIN, \"join\"),\n+    PARALLEL(EagerFetchModes.EAGER_PARALLEL, \"parallel\");\n \n     private final int eagerFetchConstant;\n-\n-    private FetchMode(int value) {\n+    private final String[] _names;\n+    \n+    private FetchMode(int value, String... names) {\n         eagerFetchConstant = value;\n+        _names = names;\n     }\n \n-    int toKernelConstant() {\n+    public int toKernelConstant() {\n         return eagerFetchConstant;\n     }\n \n@@ -57,4 +61,27 @@ static FetchMode fromKernelConstant(int kernelConstant) {\n                 throw new IllegalArgumentException(kernelConstant + \"\");\n         }\n     }\n+    \n+    public int convertToKernelConstant(String s) {\n+        return FetchMode.toKernelConstantFromString(s);\n+    }\n+    \n+    public int convertToKernelConstant(int i) {\n+        if (i == FetchConfiguration.DEFAULT)\n+            return i;\n+        for (FetchMode mode : FetchMode.values()) {\n+            if (mode.eagerFetchConstant == i)\n+                return i;\n+        }\n+        throw new IllegalArgumentException(i + \" is invalid value for FetchMode\");\n+    }\n+    \n+    public static int toKernelConstantFromString(String s) {\n+        for (FetchMode level : FetchMode.values()) {\n+            for (String name : level._names)\n+               if (name.equalsIgnoreCase(s) || String.valueOf(level.toKernelConstant()).equals(s))\n+                   return level.toKernelConstant();\n+        }\n+        throw new IllegalArgumentException(s + \" is not a valid name for \" + FetchMode.class.getName());\n+    }\n }"},{"sha":"bb9d23ccc75e5d3403d800b9fdcf3bb5c0f2a4fa","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCFetchPlanImpl.java","status":"modified","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCFetchPlanImpl.java","raw_url":"https://github.com/apache/openjpa/raw/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCFetchPlanImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCFetchPlanImpl.java?ref=b5a412fd426ca91d06d2a8a10c45b60070dd2674","patch":"@@ -18,14 +18,21 @@\n  */\n package org.apache.openjpa.persistence.jdbc;\n \n+import java.sql.ResultSet;\n import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n import javax.persistence.LockModeType;\n \n import org.apache.openjpa.jdbc.kernel.DelegatingJDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.EagerFetchModes;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.sql.JoinSyntaxes;\n import org.apache.openjpa.kernel.DelegatingFetchConfiguration;\n import org.apache.openjpa.kernel.FetchConfiguration;\n import org.apache.openjpa.persistence.FetchPlanImpl;\n+import org.apache.openjpa.persistence.HintValueConverter;\n import org.apache.openjpa.persistence.PersistenceExceptions;\n \n /**\n@@ -40,6 +47,49 @@\n     implements JDBCFetchPlan {\n \n     private DelegatingJDBCFetchConfiguration _fetch;\n+    static {\n+        registerHint(new String[]{\"openjpa.FetchPlan.EagerFetchMode\", \"openjpa.jdbc.EagerFetchMode\"},\n+            new HintValueConverter.StringToInteger(new String[]{\"none\", \"0\", \"join\", \"1\", \"parallel\", \"2\"}, \n+                new int[]{EagerFetchModes.EAGER_NONE, EagerFetchModes.EAGER_NONE, \n+                          EagerFetchModes.EAGER_JOIN, EagerFetchModes.EAGER_JOIN,\n+                          EagerFetchModes.EAGER_PARALLEL,EagerFetchModes.EAGER_PARALLEL}),\n+            new HintValueConverter.EnumToInteger(FetchMode.class, \n+                new int[]{EagerFetchModes.EAGER_NONE, EagerFetchModes.EAGER_JOIN, EagerFetchModes.EAGER_PARALLEL}));\n+        registerHint(new String[]{\"openjpa.JoinSyntax\", \"openjpa.jdbc.JoinSyntax\",\"openjpa.FetchPlan.JoinSyntax\"}, \n+            new HintValueConverter.EnumToInteger(JoinSyntax.class,\n+                new int[]{JoinSyntaxes.SYNTAX_SQL92, JoinSyntaxes.SYNTAX_TRADITIONAL, JoinSyntaxes.SYNTAX_DATABASE}),\n+            new HintValueConverter.StringToInteger(new String[]{\"sql92\", \"0\", \"traditional\", \"1\", \"database\", \"2\"}, \n+                new int[]{JoinSyntaxes.SYNTAX_SQL92, JoinSyntaxes.SYNTAX_SQL92, \n+                    JoinSyntaxes.SYNTAX_TRADITIONAL, JoinSyntaxes.SYNTAX_TRADITIONAL,\n+                    JoinSyntaxes.SYNTAX_DATABASE, JoinSyntaxes.SYNTAX_DATABASE}));\n+        registerHint(new String[]{\"openjpa.FetchDirection\", \"openjpa.jdbc.FetchDirection\",\n+                \"openjpa.FetchPlan.FetchDirection\"}, \n+                new HintValueConverter.EnumToInteger(FetchDirection.class,\n+                    new int[]{ResultSet.FETCH_FORWARD, ResultSet.FETCH_REVERSE, ResultSet.FETCH_UNKNOWN}),    \n+                new HintValueConverter.StringToInteger(new String[]{\"forward\", String.valueOf(ResultSet.FETCH_FORWARD), \n+                                                       \"reverse\", String.valueOf(ResultSet.FETCH_REVERSE), \n+                                                       \"unknown\", String.valueOf(ResultSet.FETCH_UNKNOWN)}, \n+                    new int[]{ResultSet.FETCH_FORWARD, ResultSet.FETCH_FORWARD, \n+                        ResultSet.FETCH_REVERSE, ResultSet.FETCH_REVERSE,\n+                        ResultSet.FETCH_UNKNOWN, ResultSet.FETCH_UNKNOWN}));\n+        registerHint(new String[]{\"openjpa.FetchPlan.Isolation\", \"openjpa.jdbc.TransactionIsolation\"}, \n+                new HintValueConverter.OpenJPAEnumToInteger(IsolationLevel.DEFAULT));    \n+        registerHint(new String[]{\"openjpa.FetchPlan.LRSSizeAlgorithm\", \"openjpa.FetchPlan.LRSSize\",\n+        \"openjpa.jdbc.LRSSize\"}, \n+        new HintValueConverter.OpenJPAEnumToInteger(LRSSizeAlgorithm.QUERY));\n+        registerHint(new String[]{\"openjpa.FetchPlan.ResultSetType\", \"openjpa.jdbc.ResultSetType\"}, \n+                new HintValueConverter.OpenJPAEnumToInteger(ResultSetType.FORWARD_ONLY));\n+        registerHint(new String[]{\"openjpa.FetchPlan.SubclassFetchMode\", \"openjpa.jdbc.SubclassFetchMode\"}, \n+                new HintValueConverter.OpenJPAEnumToInteger(FetchMode.NONE));\n+        \n+//        \"openjpa.FetchPlan.FetchDirection\"\n+//        _hints.add(\"openjpa.FetchPlan.LockScope\");\n+//        _hints.add(\"openjpa.FetchPlan.LockTimeout\");\n+//        _hints.add(\"openjpa.FetchPlan.MaxFetchDepth\");\n+//        _hints.add(\"openjpa.FetchPlan.QueryTimeout\");\n+//        _hints.add(\"openjpa.FetchPlan.ReadLockMode\");\n+//        _hints.add(\"openjpa.FetchPlan.WriteLockMode\");\n+    }\n \n     /**\n      * Constructor; supply delegate."},{"sha":"49193d8a59431244526c486d5fd3fd6204972fa2","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ResultSetType.java","status":"modified","additions":27,"deletions":2,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ResultSetType.java","raw_url":"https://github.com/apache/openjpa/raw/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ResultSetType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ResultSetType.java?ref=b5a412fd426ca91d06d2a8a10c45b60070dd2674","patch":"@@ -20,13 +20,16 @@\n \n import java.sql.ResultSet;\n \n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.persistence.OpenJPAEnum;\n+\n /**\n  * Type of result set to use.\n  *\n  * @since 1.0.0\n  * @published\n  */\n-public enum ResultSetType {\n+public enum ResultSetType implements OpenJPAEnum<ResultSetType>{\n     FORWARD_ONLY(ResultSet.TYPE_FORWARD_ONLY),\n     SCROLL_INSENSITIVE(ResultSet.TYPE_SCROLL_INSENSITIVE),\n     SCROLL_SENSITIVE(ResultSet.TYPE_SCROLL_SENSITIVE);\n@@ -37,7 +40,7 @@ private ResultSetType(int value) {\n         resultSetConstant = value;\n     }\n \n-    int toKernelConstant() {\n+    public int toKernelConstant() {\n         return resultSetConstant;\n     }\n \n@@ -56,4 +59,26 @@ static ResultSetType fromKernelConstant(int kernelConstant) {\n                 throw new IllegalArgumentException(kernelConstant + \"\");\n         }\n     }\n+    \n+    public int convertToKernelConstant(String s) {\n+        return ResultSetType.toKernelConstantFromString(s);\n+    }\n+    \n+    public int convertToKernelConstant(int i) {\n+        if (i == FetchConfiguration.DEFAULT)\n+            return i;\n+        for (ResultSetType level : ResultSetType.values()) {\n+            if (level.resultSetConstant == i)\n+                return i;\n+        }\n+        throw new IllegalArgumentException(i + \" is invalid value for ResultSetType\");\n+    }\n+    \n+    public static int toKernelConstantFromString(String s) {\n+        for (ResultSetType level : ResultSetType.values()) {\n+            if (level.name().equalsIgnoreCase(s) || String.valueOf(level.toKernelConstant()).equals(s))\n+                return level.toKernelConstant();\n+        }\n+        throw new IllegalArgumentException(s + \" is not a valid name for \" + ResultSetType.class.getName());\n+    }\n }"},{"sha":"ffa6d2cef4224cf7217c4bdc3baa14504de4ea3d","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestFetchHints.java","status":"modified","additions":214,"deletions":213,"changes":427,"blob_url":"https://github.com/apache/openjpa/blob/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestFetchHints.java","raw_url":"https://github.com/apache/openjpa/raw/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestFetchHints.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestFetchHints.java?ref=b5a412fd426ca91d06d2a8a10c45b60070dd2674","patch":"@@ -72,7 +72,6 @@\n  *   openjpa.FlushBeforeQueries\n  *   openjpa.LockTimeout\n  *   openjpa.MaxFetchDepth\n- *   openjpa.QueryCacheEnabled\n  *   openjpa.QueryTimeout\n  *   openjpa.ReadLockLevel\n  *   openjpa.WriteLockLevel\n@@ -110,16 +109,16 @@ public void testFetchBatchSizeHint() {\n         fetchBatchSizeHintTest(fPlan, fConfig, hintName, 100, 100);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"xxxxx\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"xxxxx\");\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n             fPlan.setFetchBatchSize(999);\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             assertEquals(fPlan.getFetchBatchSize(), -1);\n         } catch (Exception e) {\n             fail(\"Unexpected \" + e.getClass().getName());\n@@ -145,16 +144,16 @@ public void testFetchPlanFetchBatchSizeHint() {\n         fetchBatchSizeHintTest(fPlan, fConfig, hintName, 500, 500);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n             fPlan.setFetchBatchSize(999);\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             assertEquals(fPlan.getFetchBatchSize(), -1);\n         } catch (Exception e) {\n             fail(\"Unexpected \" + e.getClass().getName());\n@@ -166,7 +165,7 @@ private void fetchBatchSizeHintTest(JDBCFetchPlan fPlan,\n         JDBCFetchConfigurationImpl fConfig, String hint, Object value,\n         int expected) {\n         fConfig.setFetchBatchSize(999);\n-        fPlan.setHint(hint, value, false);\n+        fPlan.setHint(hint, value);\n         Object getValue = fPlan.getHint(hint);\n         assertEquals(value.getClass(), getValue.getClass());\n         assertEquals(value, getValue);\n@@ -208,24 +207,24 @@ public void testFetchPlanEagerFetchModeHint() {\n             FetchMode.JOIN, EagerFetchModes.EAGER_JOIN);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -2, false);\n-            fPlan.setHint(hintName, -3, true);\n+            fPlan.setHint(hintName, -2);\n+            fPlan.setHint(hintName, -3);\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n@@ -268,31 +267,31 @@ public void testJdbcEagerFetchModeHint() {\n             EagerFetchModes.EAGER_JOIN);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -2, true);\n+            fPlan.setHint(hintName, -1);\n+            fPlan.setHint(hintName, -2);\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             assertEquals(fPlan.getEagerFetchMode(), FetchMode.PARALLEL);\n         } catch (Exception e) {\n               fail(\"Unexpected \" + e.getClass().getName());\n@@ -347,24 +346,24 @@ public void testFetchPlanJoinSyntaxHint() {\n             JoinSyntax.DATABASE, JoinSyntaxes.SYNTAX_DATABASE);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -2, true);\n+            fPlan.setHint(hintName, -1);\n+            fPlan.setHint(hintName, -2);\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n@@ -406,31 +405,31 @@ public void testJdbcJoinSyntaxHint() {\n             JoinSyntaxes.SYNTAX_DATABASE);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -2, true);\n+            fPlan.setHint(hintName, -1);\n+            fPlan.setHint(hintName, -2);\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             assertEquals(fConfig.getJoinSyntax(),\n                 ((JDBCConfiguration) fConfig.getContext().getConfiguration())\n                     .getDBDictionaryInstance().joinSyntax);\n@@ -488,24 +487,24 @@ public void testFetchPlanFetchDirectionHint() {\n             ResultSet.FETCH_UNKNOWN);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -2, true);\n+            fPlan.setHint(hintName, -1);\n+            fPlan.setHint(hintName, -2);\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n@@ -548,31 +547,31 @@ public void testJdbcFetchDirectionHint() {\n             ResultSet.FETCH_UNKNOWN);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -2, true);\n+            fPlan.setHint(hintName, -1);\n+            fPlan.setHint(hintName, -2);\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             assertEquals(fConfig.getFetchDirection(), ResultSet.FETCH_FORWARD);\n         } catch (Exception e) {\n             fail(\"Unexpected \" + e.getClass().getName());\n@@ -665,29 +664,30 @@ public void testFetchPlanIsolationHint() {\n         }\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n-            fail(\"Expecting a a IllegalArgumentException.\");\n-        } catch (Exception e) {\n-            assertTrue(\"Caught expected exception\",\n-                IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n-        }\n-        try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -1, true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n+        // Is not -1 is valid value for transaction isolation level?\n+//        try {\n+//            fPlan.setHint(hintName, -1);\n+//            fPlan.setHint(hintName, -1);\n+//            fail(\"Expecting a a IllegalArgumentException.\");\n+//        } catch (Exception e) {\n+//            assertTrue(\"Caught expected exception\",\n+//                IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n+//        }\n         em.close();\n     }\n \n@@ -756,31 +756,31 @@ public void testJdbcTransactionIsolationHint() {\n                 Connection.TRANSACTION_SERIALIZABLE);\n         }\n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -2, false);\n-            fPlan.setHint(hintName, -3, true);\n+            fPlan.setHint(hintName, -2);\n+            fPlan.setHint(hintName, -3);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             assertEquals(IsolationLevel.DEFAULT, fPlan.getIsolation());\n             assertEquals(-1, fConfig.getIsolation());\n         } catch (Exception e) {\n@@ -835,27 +835,27 @@ public void testFetchPlanLRSSizeAlgorithmHint() {\n             LRSSizeAlgorithm.UNKNOWN, LRSSizes.SIZE_UNKNOWN);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -2, true);\n+            fPlan.setHint(hintName, -1);\n+            fPlan.setHint(hintName, -2);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n-            assertTrue(\"Caught expected exception\",\n+            assertTrue(\"Caught unexpected exception \" + e,\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         em.close();\n@@ -893,35 +893,36 @@ public void testFetchPlanLRSSizeHint() {\n             LRSSizeAlgorithm.UNKNOWN, LRSSizes.SIZE_UNKNOWN);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -2, true);\n+            fPlan.setHint(hintName, -1);\n+            fPlan.setHint(hintName, -2);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             assertEquals(LRSSizeAlgorithm.QUERY, fPlan.getLRSSizeAlgorithm());\n             assertEquals(LRSSizes.SIZE_QUERY, fPlan.getLRSSize());\n             assertEquals(LRSSizes.SIZE_QUERY, fConfig.getLRSSize());\n         } catch (Exception e) {\n+            e.printStackTrace();\n             fail(\"Unexpected \" + e.getClass().getName());\n         }\n         em.close();\n@@ -959,35 +960,36 @@ public void testJdbcLRSSizeHint() {\n             LRSSizeAlgorithm.UNKNOWN, LRSSizes.SIZE_UNKNOWN);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -2, true);\n+            fPlan.setHint(hintName, -1);\n+            fPlan.setHint(hintName, -2);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             assertEquals(LRSSizeAlgorithm.QUERY, fPlan.getLRSSizeAlgorithm());\n             assertEquals(LRSSizes.SIZE_QUERY, fPlan.getLRSSize());\n             assertEquals(LRSSizes.SIZE_QUERY, fConfig.getLRSSize());\n         } catch (Exception e) {\n+            e.printStackTrace();\n             fail(\"Unexpected \" + e.getClass().getName());\n         }\n         em.close();\n@@ -1024,15 +1026,15 @@ public void testFetchPlanMaxFetchDepthHint() {\n         maxFetchDepthHintTest(fPlan, fConfig, hintName, 500, 500);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             assertEquals(-1, fPlan.getMaxFetchDepth());\n             assertEquals(-1, fConfig.getMaxFetchDepth());\n         } catch (IllegalArgumentException e) {\n@@ -1059,15 +1061,15 @@ public void testMaxFetchDepthHint() {\n         maxFetchDepthHintTest(fPlan, fConfig, hintName, 100, 100);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             assertEquals(-1, fPlan.getMaxFetchDepth());\n             assertEquals(-1, fConfig.getMaxFetchDepth());\n         } catch (Exception e) {\n@@ -1107,23 +1109,23 @@ public void testLockTimeoutHint() {\n         lockTimeoutHintTest(fPlan, fConfig, hintName, 100, 100);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -2, false);\n-            fPlan.setHint(hintName, -3, true);\n+            fPlan.setHint(hintName, -2);\n+            fPlan.setHint(hintName, -3);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             int defTimeout = fConfig.getContext().getConfiguration()\n                 .getLockTimeout();\n             assertEquals(defTimeout, fPlan.getLockTimeout());\n@@ -1154,23 +1156,23 @@ public void testFetchPlanLockTimeoutHint() {\n         lockTimeoutHintTest(fPlan, fConfig, hintName, 1500, 1500);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -2, false);\n-            fPlan.setHint(hintName, -3, true);\n+            fPlan.setHint(hintName, -2);\n+            fPlan.setHint(hintName, -3);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             int defTimeout = fConfig.getContext().getConfiguration()\n                 .getLockTimeout();\n             assertEquals(defTimeout, fPlan.getLockTimeout());\n@@ -1201,23 +1203,23 @@ public void testJavaxLockTimeoutHint() {\n         lockTimeoutHintTest(fPlan, fConfig, hintName, 2000, 2000);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -2, false);\n-            fPlan.setHint(hintName, -3, true);\n+            fPlan.setHint(hintName, -2);\n+            fPlan.setHint(hintName, -3);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             int defTimeout = fConfig.getContext().getConfiguration()\n                 .getLockTimeout();\n             assertEquals(defTimeout, fPlan.getLockTimeout());\n@@ -1259,23 +1261,23 @@ public void testQueryTimeoutHint() {\n         queryTimeoutHintTest(fPlan, fConfig, hintName, 100, 100);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -2, false);\n-            fPlan.setHint(hintName, -3, true);\n+            fPlan.setHint(hintName, -2);\n+            fPlan.setHint(hintName, -3);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             int defTimeout = fConfig.getContext().getConfiguration()\n                 .getQueryTimeout();\n             assertEquals(defTimeout, fPlan.getQueryTimeout());\n@@ -1306,23 +1308,23 @@ public void testFetchPlanQueryTimeoutHint() {\n         queryTimeoutHintTest(fPlan, fConfig, hintName, 1500, 1500);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -2, false);\n-            fPlan.setHint(hintName, -3, true);\n+            fPlan.setHint(hintName, -2);\n+            fPlan.setHint(hintName, -3);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             int defTimeout = fConfig.getContext().getConfiguration()\n                 .getQueryTimeout();\n             assertEquals(defTimeout, fPlan.getQueryTimeout());\n@@ -1353,23 +1355,23 @@ public void testJavaxQueryTimeoutHint() {\n         queryTimeoutHintTest(fPlan, fConfig, hintName, 2000, 2000);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -2, false);\n-            fPlan.setHint(hintName, -3, true);\n+            fPlan.setHint(hintName, -2);\n+            fPlan.setHint(hintName, -3);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             int defTimeout = fConfig.getContext().getConfiguration()\n                 .getQueryTimeout();\n             assertEquals(defTimeout, fPlan.getQueryTimeout());\n@@ -1426,27 +1428,27 @@ public void testFetchPlanResultSetTypeHint() {\n             ResultSet.TYPE_SCROLL_INSENSITIVE);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -2, true);\n+            fPlan.setHint(hintName, -1);\n+            fPlan.setHint(hintName, -2);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n-            assertTrue(\"Caught expected exception\",\n+            assertTrue(\"Caught unexpected exception \" + e,\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         em.close();\n@@ -1487,31 +1489,31 @@ public void testJdbcResultSetTypeHint() {\n             ResultSet.TYPE_SCROLL_INSENSITIVE);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -2, true);\n+            fPlan.setHint(hintName, -1);\n+            fPlan.setHint(hintName, -2);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             assertEquals(ResultSet.TYPE_FORWARD_ONLY, fConfig\n                 .getResultSetType());\n         } catch (Exception e) {\n@@ -1565,24 +1567,24 @@ public void testFetchPlanSubclassFetchModeHint() {\n             FetchMode.JOIN, EagerFetchModes.EAGER_JOIN);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -2, true);\n+            fPlan.setHint(hintName, -1);\n+            fPlan.setHint(hintName, -2);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n@@ -1625,31 +1627,31 @@ public void testJdbcSubclassFetchModeHint() {\n             EagerFetchModes.EAGER_JOIN);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -2, true);\n+            fPlan.setHint(hintName, -1);\n+            fPlan.setHint(hintName, -2);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             assertEquals(EagerFetchModes.EAGER_JOIN, fConfig\n                 .getSubclassFetchMode());\n         } catch (Exception e) {\n@@ -1699,31 +1701,31 @@ public void testFlushBeforeQueriesHint() {\n             QueryFlushModes.FLUSH_WITH_CONNECTION);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -2, true);\n+            fPlan.setHint(hintName, -1);\n+            fPlan.setHint(hintName, -2);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             fConfig.getFlushBeforeQueries();\n             assertEquals(QueryFlushModes.FLUSH_TRUE, fConfig\n                 .getFlushBeforeQueries());\n@@ -1821,31 +1823,31 @@ public void testReadLockLevelHint() {\n             MixedLockLevels.LOCK_PESSIMISTIC_FORCE_INCREMENT);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -2, true);\n+            fPlan.setHint(hintName, -1);\n+            fPlan.setHint(hintName, -2);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             assertEquals(MixedLockLevels.LOCK_READ, fConfig.getReadLockLevel());\n         } catch (Exception e) {\n             fail(\"Unexpected \" + e.getClass().getName());\n@@ -1943,31 +1945,31 @@ public void testWriteLockLevelHint() {\n             MixedLockLevels.LOCK_PESSIMISTIC_FORCE_INCREMENT);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -2, true);\n+            fPlan.setHint(hintName, -1);\n+            fPlan.setHint(hintName, -2);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, FetchConfiguration.DEFAULT, true);\n+            fPlan.setHint(hintName, FetchConfiguration.DEFAULT);\n             assertEquals(MixedLockLevels.LOCK_WRITE, fConfig\n                 .getWriteLockLevel());\n         } catch (Exception e) {\n@@ -2089,24 +2091,24 @@ private void fetchPlanReadLockModeHint(boolean inTransaction) {\n             MixedLockLevels.LOCK_PESSIMISTIC_FORCE_INCREMENT);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -2, true);\n+            fPlan.setHint(hintName, -1);\n+            fPlan.setHint(hintName, -2);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n@@ -2229,24 +2231,24 @@ private void fetchPlanWriteLockModeHint(boolean inTransaction) {\n             MixedLockLevels.LOCK_PESSIMISTIC_FORCE_INCREMENT);\n \n         try {\n-            fPlan.setHint(hintName, \"xxxxx\", false);\n-            fPlan.setHint(hintName, \"yyyyy\", true);\n+            fPlan.setHint(hintName, \"xxxxx\");\n+            fPlan.setHint(hintName, \"yyyyy\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, \"12345\", false);\n-            fPlan.setHint(hintName, \"67890\", true);\n+            fPlan.setHint(hintName, \"12345\");\n+            fPlan.setHint(hintName, \"67890\");\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n                 IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n         }\n         try {\n-            fPlan.setHint(hintName, -1, false);\n-            fPlan.setHint(hintName, -2, true);\n+            fPlan.setHint(hintName, -1);\n+            fPlan.setHint(hintName, -2);\n             fail(\"Expecting a a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\",\n@@ -2279,36 +2281,36 @@ public void testSimiliarLockTimeoutHints() {\n         EntityManager em = emf.createEntityManager();\n         OpenJPAEntityManager oem = (OpenJPAEntityManager)em.getDelegate();\n \n-        similarLockTimeoutHintsTest(oem, 333,\n+        similarLockTimeoutHintsTest(oem, JavaxLockTimeout, 333,\n             JavaxLockTimeout, 333,\n             OpenJPALockTimeout, 111,\n             FetchPlanLockTimeout, 222);\n-        similarLockTimeoutHintsTest(oem, 333,\n+        similarLockTimeoutHintsTest(oem, JavaxLockTimeout, 333,\n             OpenJPALockTimeout, 111,\n             FetchPlanLockTimeout, 222,\n             JavaxLockTimeout, 333);\n-        similarLockTimeoutHintsTest(oem, 333,\n+        similarLockTimeoutHintsTest(oem, JavaxLockTimeout, 333,\n             JavaxLockTimeout, 333,\n             FetchPlanLockTimeout, 222,\n             OpenJPALockTimeout, 111);\n-        similarLockTimeoutHintsTest(oem, 222,\n+        similarLockTimeoutHintsTest(oem, FetchPlanLockTimeout, 222,\n             OpenJPALockTimeout, 111,\n             FetchPlanLockTimeout, 222);\n-        similarLockTimeoutHintsTest(oem, 222,\n+        similarLockTimeoutHintsTest(oem, FetchPlanLockTimeout, 222,\n             FetchPlanLockTimeout, 222,\n             OpenJPALockTimeout, 111);\n-        similarLockTimeoutHintsTest(oem, 111,\n+        similarLockTimeoutHintsTest(oem, OpenJPALockTimeout, 111,\n             OpenJPALockTimeout, 111);\n-        similarLockTimeoutHintsTest(oem, 222,\n+        similarLockTimeoutHintsTest(oem, FetchPlanLockTimeout, 222,\n             FetchPlanLockTimeout, 222);\n-        similarLockTimeoutHintsTest(oem, 333,\n+        similarLockTimeoutHintsTest(oem, JavaxLockTimeout, 333,\n             JavaxLockTimeout, 333);\n \n         em.close();\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private void similarLockTimeoutHintsTest(OpenJPAEntityManager oem,\n+    private void similarLockTimeoutHintsTest(OpenJPAEntityManager oem, String winner, \n         Object expected, Object... hintNvalues) {\n         JDBCFetchPlan fPlan = (JDBCFetchPlan) oem.pushFetchPlan();\n         JDBCFetchConfigurationImpl fConfig = (JDBCFetchConfigurationImpl) fPlan\n@@ -2321,8 +2323,10 @@ private void similarLockTimeoutHintsTest(OpenJPAEntityManager oem,\n             String hintName = (String)hintNvalues[i];\n             Object expectedValue = hintNvalues[i+1];\n             Object getValue = fPlan.getHint(hintName);\n-            assertEquals(expectedValue.getClass(), getValue.getClass());\n-            assertEquals(expectedValue, getValue);\n+            if (hintName.equals(winner)) {\n+                assertEquals(expectedValue.getClass(), getValue.getClass());\n+                assertEquals(expectedValue, getValue);\n+            } \n         }\n         assertEquals(expected, fPlan.getLockTimeout());\n         assertEquals(expected, fConfig.getLockTimeout());\n@@ -2341,36 +2345,36 @@ public void testSimiliarQueryTimeoutHints() {\n         EntityManager em = emf.createEntityManager();\n         OpenJPAEntityManager oem = (OpenJPAEntityManager)em.getDelegate();\n \n-        similarQueryTimeoutHintsTest(oem, 333,\n+        similarQueryTimeoutHintsTest(oem, JavaxQueryTimeout, 333, \n             JavaxQueryTimeout, 333,\n             OpenJPAQueryTimeout, 111,\n             FetchPlanQueryTimeout, 222);\n-        similarQueryTimeoutHintsTest(oem, 333,\n+        similarQueryTimeoutHintsTest(oem, JavaxQueryTimeout, 333, \n             OpenJPAQueryTimeout, 111,\n             FetchPlanQueryTimeout, 222,\n             JavaxQueryTimeout, 333);\n-        similarQueryTimeoutHintsTest(oem, 333,\n+        similarQueryTimeoutHintsTest(oem, JavaxQueryTimeout, 333, \n             JavaxQueryTimeout, 333,\n             FetchPlanQueryTimeout, 222,\n             OpenJPAQueryTimeout, 111);\n-        similarQueryTimeoutHintsTest(oem, 222,\n+        similarQueryTimeoutHintsTest(oem, FetchPlanQueryTimeout, 222, \n             OpenJPAQueryTimeout, 111,\n             FetchPlanQueryTimeout, 222);\n-        similarQueryTimeoutHintsTest(oem, 222,\n+        similarQueryTimeoutHintsTest(oem, FetchPlanQueryTimeout, 222, \n             FetchPlanQueryTimeout, 222,\n             OpenJPAQueryTimeout, 111);\n-        similarQueryTimeoutHintsTest(oem, 111,\n+        similarQueryTimeoutHintsTest(oem, OpenJPAQueryTimeout, 111, \n             OpenJPAQueryTimeout, 111);\n-        similarQueryTimeoutHintsTest(oem, 222,\n+        similarQueryTimeoutHintsTest(oem, FetchPlanQueryTimeout, 222, \n             FetchPlanQueryTimeout, 222);\n-        similarQueryTimeoutHintsTest(oem, 333,\n+        similarQueryTimeoutHintsTest(oem, JavaxQueryTimeout, 333, \n             JavaxQueryTimeout, 333);\n \n         em.close();\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private void similarQueryTimeoutHintsTest(OpenJPAEntityManager oem,\n+    private void similarQueryTimeoutHintsTest(OpenJPAEntityManager oem, String winner, \n         Object expected, Object... hintNvalues) {\n         JDBCFetchPlan fPlan = (JDBCFetchPlan) oem.pushFetchPlan();\n         JDBCFetchConfigurationImpl fConfig = (JDBCFetchConfigurationImpl) fPlan\n@@ -2383,8 +2387,10 @@ private void similarQueryTimeoutHintsTest(OpenJPAEntityManager oem,\n             String hintName = (String)hintNvalues[i];\n             Object expectedValue = hintNvalues[i+1];\n             Object getValue = fPlan.getHint(hintName);\n-            assertEquals(expectedValue.getClass(), getValue.getClass());\n-            assertEquals(expectedValue, getValue);\n+            if (hintName.equals(winner)) {\n+                assertEquals(expectedValue.getClass(), getValue.getClass());\n+                assertEquals(expectedValue, getValue);\n+            }\n         }\n         assertEquals(expected, fPlan.getQueryTimeout());\n         assertEquals(expected, fConfig.getQueryTimeout());\n@@ -2404,8 +2410,6 @@ public void testSetHintAddHintsArgument() {\n         fPlan.setHint(\"unrecognized.prop.name\", \"unrecognized.prop.value\");\n         assertEquals(null, fPlan.getHint(\"unrecognized.prop.name\"));\n \n-        fPlan.addHints(null);\n-        fPlan.addHints(new HashMap<String,Object>());\n \n         OpenJPAConfiguration conf = oem.getConfiguration();\n         if (conf instanceof JDBCConfiguration\n@@ -2416,16 +2420,13 @@ public void testSetHintAddHintsArgument() {\n                 fail(\"Expecting a a IllegalArgumentException.\");\n             } catch (Exception e) {\n                 assertTrue(\"Caught expected exception\",\n-                    IllegalArgumentException.class.isAssignableFrom(e\n-                        .getClass()));\n+                    IllegalArgumentException.class.isAssignableFrom(e.getClass()));\n             }\n         }\n \n         try {\n-            fPlan.setHint(\"openjpa.FetchPlan.Isolation\", new Integer(13),\n-                false);\n-            fPlan.setHint(\"openjpa.FetchPlan.Isolation\", new Integer(14),\n-                true);\n+            fPlan.setHint(\"openjpa.FetchPlan.Isolation\", new Integer(13));\n+            fPlan.setHint(\"openjpa.FetchPlan.Isolation\", new Integer(14));\n             fail(\"Expecting a IllegalArgumentException.\");\n         } catch (Exception e) {\n             assertTrue(\"Caught expected exception\","},{"sha":"56f531a8d5a42051aa489c8affe3cdcd90fd85a3","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/EntityManagerImpl.java?ref=b5a412fd426ca91d06d2a8a10c45b60070dd2674","patch":"@@ -1633,7 +1633,10 @@ private void configureCurrentFetchPlan(FetchPlan fetch, Map<String, Object> prop\n             LockModeType lock, boolean requiresTxn) {\n         // handle properties in map first\n         configureCurrentCacheModes(fetch, properties);\n-        fetch.addHints(properties);\n+        if (properties != null) {\n+            for (Map.Entry<String, Object> entry : properties.entrySet())\n+                fetch.setHint(entry.getKey(), entry.getValue());\n+        }\n         // override with the specific lockMode, if needed.\n         if (lock != null && lock != LockModeType.NONE) {\n             if (requiresTxn) {"},{"sha":"a7f50c316793a572cf282dab4702d97af04716a1","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanHintHandler.java","status":"removed","additions":0,"deletions":212,"changes":212,"blob_url":"https://github.com/apache/openjpa/blob/dad4ad195225eaa68e6e3bed942822f0ea86d434/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanHintHandler.java","raw_url":"https://github.com/apache/openjpa/raw/dad4ad195225eaa68e6e3bed942822f0ea86d434/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanHintHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanHintHandler.java?ref=dad4ad195225eaa68e6e3bed942822f0ea86d434","patch":"@@ -1,212 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.openjpa.persistence;\n-\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.persistence.LockModeType;\n-\n-import org.apache.openjpa.kernel.FetchConfigurationImpl;\n-import org.apache.openjpa.kernel.AbstractHintHandler;\n-import org.apache.openjpa.kernel.MixedLockLevels;\n-import org.apache.openjpa.lib.conf.ProductDerivations;\n-import org.apache.openjpa.lib.util.Localizer;\n-\n-/**\n- * Fetch plan hint handler. Handles openjpa.FetchPlan.*, \n- * javax.persistence.lock.* and javax.persistence.query.* hints.\n- *\n- * @since 2.0.0\n- * @nojavadoc\n- */\n-@SuppressWarnings(\"serial\")\n-public class FetchPlanHintHandler extends AbstractHintHandler {\n-\n-    private static final Localizer _loc = Localizer.forPackage(FetchPlanHintHandler.class);\n-\n-    protected static final String PREFIX_FETCHPLAN = PREFIX_OPENJPA + \"FetchPlan.\";\n-\n-    // Valid defined product derivation prefixes\n-    protected static final Set<String> validProductPrefixes =  new HashSet<String>();\n-    // JPA Specification 2.0 keys are mapped to equivalent FetchPlan keys\n-    protected static final Map<String, String> javaxHintsMap   = new HashMap<String, String>();\n-    // hints precedent definitions\n-    protected static final Map<String, String[]> precedenceMap = new HashMap<String, String[]>();\n-\n-    static {\n-        // Initialize valid product prefixes from available product derivations.\n-        for (String prefix : ProductDerivations.getConfigurationPrefixes()) {\n-            validProductPrefixes.add(prefix);\n-        }\n-        // Initialize javax.persistence to openjpa.FetchPlan hint mapping.\n-        javaxHintsMap.put(JPAProperties.LOCK_TIMEOUT,  PREFIX_FETCHPLAN + \"LockTimeout\");\n-        javaxHintsMap.put(JPAProperties.LOCK_SCOPE,    PREFIX_FETCHPLAN + \"LockScope\");\n-        javaxHintsMap.put(JPAProperties.QUERY_TIMEOUT, PREFIX_FETCHPLAN + \"QueryTimeout\");\n-        // Initialize hint precedence order mapping from list.\n-        String[][] precedenceMapList = {\n-            { JPAProperties.LOCK_TIMEOUT,\n-              PREFIX_FETCHPLAN  + \"LockTimeout\",\n-              PREFIX_OPENJPA    + \"LockTimeout\" },\n-\n-            { JPAProperties.LOCK_SCOPE,\n-              PREFIX_FETCHPLAN  + \"LockScope\",\n-              PREFIX_OPENJPA    + \"LockScope\" },\n-\n-            { JPAProperties.QUERY_TIMEOUT,\n-              PREFIX_FETCHPLAN  + \"QueryTimeout\",\n-              PREFIX_OPENJPA    + \"QueryTimeout\" },\n-\n-            { PREFIX_FETCHPLAN  + \"Isolation\",\n-              PREFIX_JDBC       + \"TransactionIsolation\" },\n-\n-            { PREFIX_FETCHPLAN  + \"EagerFetchMode\",\n-              PREFIX_JDBC       + \"EagerFetchMode\" },\n-\n-            { PREFIX_FETCHPLAN  + \"FetchDirection\",\n-              PREFIX_JDBC       + \"FetchDirection\" },\n-\n-            { PREFIX_FETCHPLAN  + \"JoinSyntax\",\n-              PREFIX_JDBC       + \"JoinSyntax\" },\n-\n-            { PREFIX_FETCHPLAN  + \"LRSSizeAlgorithm\",\n-              PREFIX_FETCHPLAN  + \"LRSSize\",\n-              PREFIX_JDBC       + \"LRSSize\" },\n-\n-            { PREFIX_FETCHPLAN  + \"ResultSetType\",\n-              PREFIX_JDBC       + \"ResultSetType\" },\n-\n-            { PREFIX_FETCHPLAN  + \"SubclassFetchMode\",\n-              PREFIX_JDBC       + \"SubclassFetchMode\" },\n-\n-            { PREFIX_FETCHPLAN  + \"ReadLockMode\",\n-              PREFIX_OPENJPA    + \"ReadLockLevel\" },\n-\n-            { PREFIX_FETCHPLAN  + \"WriteLockMode\",\n-              PREFIX_OPENJPA    + \"WriteLockLevel\" },\n-\n-            { PREFIX_FETCHPLAN  + \"FetchBatchSize\",\n-              PREFIX_OPENJPA    + \"FetchBatchSize\" },\n-\n-            { PREFIX_FETCHPLAN  + \"MaxFetchDepth\",\n-              PREFIX_OPENJPA    + \"MaxFetchDepth\" }\n-        };\n-        for (String[] list : precedenceMapList) {\n-            for (String hint : list)\n-                precedenceMap.put(hint, list);\n-        }\n-    }\n-\n-    protected FetchPlanImpl _fPlan;\n-\n-    /**\n-     * Constructor; supply delegate.\n-     */\n-    public FetchPlanHintHandler(FetchPlanImpl fetchPlan) {\n-        super((FetchConfigurationImpl) fetchPlan.getDelegate());\n-        _fPlan = fetchPlan;\n-    }\n-\n-    public boolean setHint(String hintName, Object value, boolean validateThrowException) {\n-        if (!JPAProperties.isValidKey(hintName)\n-            && !validProductPrefixes.contains(getPrefixOf(hintName)))\n-            return false;\n-        return super.setHint(hintName, value, validateThrowException);\n-    }\n-\n-    protected boolean setHintInternal(String hintName, Object value, boolean validateThrowException) {\n-        boolean valueSet = false;\n-        if (hintName.startsWith(PREFIX_FETCHPLAN)) {\n-            if (hintName.endsWith(\"LockMode\") && !_fConfig.getContext().isActive()) {\n-                _fConfig.setHint(hintName + \".Defer\", toLockLevel(value));\n-                valueSet = true;\n-            } else {\n-                valueSet = hintToSetter(_fPlan, hintName, value);\n-            }\n-        } else {\n-            _fConfig.setHint(hintName, value, validateThrowException);\n-        }\n-        return valueSet;\n-    }\n-\n-    protected String hintToKey(String key) {\n-        // transform product derived prefix to openjpa prefix\n-        if (!key.startsWith(PREFIX_OPENJPA)\n-            && validProductPrefixes.contains(getPrefixOf(key)))\n-            key = PREFIX_OPENJPA + key.substring(key.indexOf('.') + 1);\n-\n-        // transform javax.persistence.* hints to fetch plan hints.\n-        if (javaxHintsMap.containsKey(key))\n-            key = javaxHintsMap.get(key);\n-        return key;\n-    }\n-\n-    protected boolean hasPrecedent(String key) {\n-        boolean hasPrecedent = true;\n-        String[] list = precedenceMap.get(key);\n-        if (list != null) {\n-            for (String hint : list) {\n-                if (hint.equals(key))\n-                    break;\n-                // stop if a higher precedence hint has already defined \n-                if (_fConfig.getHint(hint) != null) {\n-                    hasPrecedent = false;\n-                    break;\n-                }\n-            }\n-        }\n-        return hasPrecedent;\n-    }\n-\n-    protected void handleException(RuntimeException e) {\n-        throw PersistenceExceptions.toPersistenceException(e);\n-    }\n-\n-    private Integer toLockLevel(Object value) {\n-        Object origValue = value;\n-        if (value instanceof String) {\n-            // to accomodate alias name input in relationship with enum values\n-            //  e.g. \"optimistic-force-increment\" == \n-            //          LockModeType.OPTIMISTIC_FORCE_INCREMENT\n-            String strValue = ((String) value).toUpperCase().replace('-', '_');\n-            value = Enum.valueOf(LockModeType.class, strValue);\n-        }\n-        if (value instanceof LockModeType)\n-            value = MixedLockLevelsHelper.toLockLevel((LockModeType) value);\n-\n-        Integer intValue = null;\n-        if (value instanceof Integer)\n-            intValue = (Integer) value;\n-        if (intValue == null\n-            || (intValue != MixedLockLevels.LOCK_NONE\n-                && intValue != MixedLockLevels.LOCK_READ\n-                && intValue != MixedLockLevels.LOCK_OPTIMISTIC\n-                && intValue != MixedLockLevels.LOCK_WRITE\n-                && intValue != MixedLockLevels.LOCK_OPTIMISTIC_FORCE_INCREMENT\n-                && intValue != MixedLockLevels.LOCK_PESSIMISTIC_READ\n-                && intValue != MixedLockLevels.LOCK_PESSIMISTIC_WRITE\n-                && intValue != MixedLockLevels.LOCK_PESSIMISTIC_FORCE_INCREMENT)\n-                )\n-            throw new IllegalArgumentException(_loc.get(\"bad-lock-level\",\n-                origValue).getMessage());\n-        return intValue;\n-    }\n-}"},{"sha":"847dd81cc2a0c165a0181dea5952ed3dccdb183d","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/HintValueConverter.java","status":"added","additions":189,"deletions":0,"changes":189,"blob_url":"https://github.com/apache/openjpa/blob/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/HintValueConverter.java","raw_url":"https://github.com/apache/openjpa/raw/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/HintValueConverter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/HintValueConverter.java?ref=b5a412fd426ca91d06d2a8a10c45b60070dd2674","patch":"@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence;\n+\n+import java.util.Arrays;\n+\n+\n+/**\n+ * Converts a given user-specified value to a target type consumable by the kernel.\n+ * Used by hint processing.\n+ * \n+ * @author Pinaki Poddar\n+ * @since 2.0.0\n+ * @unpublished\n+ */\n+public interface HintValueConverter {\n+    /**\n+     * Convert the user-specified value to a kernel consumable value.\n+     *  \n+     * @param original the user-specified value\n+     * @return an equivalent value consumable by a kernel construct.\n+     * \n+     * @exception IllegalArgumentException if the given value can not be converted.\n+     */\n+    Object convert(Object original);\n+    \n+    /**\n+     * Affirm if this receiver can convert the value of the given type.\n+     */\n+    boolean canConvert(Class<?> type);\n+    \n+    /**\n+     * Convert the enum value to an enumerated set of constants.\n+     * \n+     * @author Pinaki Poddar\n+     *\n+     */\n+    static class EnumToInteger implements HintValueConverter {\n+        private Class<? extends Enum<?>> _type;\n+        private Integer[] map;\n+        \n+        public EnumToInteger(Class<? extends Enum<?>> enumType, int[] numbers) {\n+            try {\n+                _type = enumType;\n+                Enum<?>[] values = (Enum<?>[])enumType.getMethod(\"values\", null).invoke(null, (Class<?>[])null);\n+                map = new Integer[values.length];\n+                int i = 0;\n+                for (Enum<?> v : values) {\n+                    map[v.ordinal()] = numbers[i++];\n+                }\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        \n+        public Object convert(Object e) {\n+            if (e.getClass() == _type)\n+                return map[((Enum<?>)e).ordinal()];\n+            return e;\n+        }\n+        \n+        public boolean canConvert(Class<?> type) {\n+            return Enum.class.isAssignableFrom(type);\n+        }\n+    }\n+    \n+    /**\n+     * Converts an OpenJPA specific enum to an equivalent kernel constant.\n+     * \n+     * @author Pinaki Poddar\n+     *\n+     */\n+    public static class OpenJPAEnumToInteger implements HintValueConverter {\n+        private OpenJPAEnum<?> _prototype;\n+        \n+        public OpenJPAEnumToInteger(OpenJPAEnum<?> prototype) {\n+            _prototype = prototype;\n+        }\n+            \n+        public Object convert(Object e) {\n+            if (e.getClass() == _prototype.getClass())\n+                return ((OpenJPAEnum<Enum<?>>)e).toKernelConstant();\n+            if (e instanceof String) {\n+                return _prototype.convertToKernelConstant(e.toString());\n+            }\n+            if (e instanceof Integer) {\n+                return _prototype.convertToKernelConstant((Integer)e);\n+            }\n+            return e;\n+        }\n+        \n+        public boolean canConvert(Class<?> type) {\n+            return OpenJPAEnum.class.isAssignableFrom(type) \n+                || type == String.class \n+                || type == Integer.class\n+                || type == int.class;\n+        }\n+    }\n+\n+    /**\n+     * Converts a String to an integer.\n+     * \n+     * @author Pinaki Poddar\n+     *\n+     */\n+    public static class StringToInteger implements HintValueConverter {\n+        private String[] strings;\n+        private Integer[] numbers;\n+        \n+        /**\n+         * Construct a converter that will simply translate a numeric string to a integer.\n+         */\n+        public StringToInteger() {\n+            \n+        }\n+        \n+        /**\n+         * Construct a converter that will translate any of the given strings to corresponding integer.\n+         * Both arrays must not be null, must not contain null elements and must have the same dimension.\n+         * \n+         * @param strings\n+         * @param numbers\n+         */\n+        public StringToInteger(String[] strings, int[] numbers) {\n+            if (strings == null || numbers == null || strings.length != numbers.length)\n+                throw new IllegalArgumentException();\n+            this.strings = new String[strings.length];\n+            this.numbers = new Integer[numbers.length];\n+            for (int i = 0; i < strings.length; i++) {\n+                this.strings[i] = strings[i];\n+                this.numbers[i] = numbers[i];\n+            }\n+        }\n+        \n+        public Object convert(Object s) {\n+            if (s instanceof String == false)\n+                return s;\n+            String str = s.toString();\n+            if (strings == null) {\n+                try {\n+                    return Integer.parseInt(str);\n+                } catch (NumberFormatException e) {\n+                    throw new IllegalArgumentException(\"Can not convert \" + str + \" . Expected a numeric string\");\n+                }\n+            }\n+            for (int i = 0; i < strings.length; i++)  {\n+                if (strings[i].equalsIgnoreCase(str))\n+                    return numbers[i];\n+            }\n+            throw new IllegalArgumentException(\"Can not convert \" + str + \" . Valid input is \" + \n+                    Arrays.toString(strings));\n+        }\n+        \n+        public boolean canConvert(Class<?> cls) {\n+            return String.class == cls;\n+        }\n+    }\n+    \n+    public static class StringToBoolean implements HintValueConverter {\n+        public Object convert(Object v) {\n+            if (v instanceof String)\n+                return Boolean.valueOf(v.toString());\n+            if (v instanceof Boolean)\n+                return v;\n+            return v;\n+        }\n+        \n+        public boolean canConvert(Class<?> cls) {\n+            return String.class == cls || Boolean.class == cls || boolean.class == cls;\n+        }\n+    }\n+\n+}"},{"sha":"b1a44a9d38eda38594432c27592a3ed2212dbcbb","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/MixedLockLevelsHelper.java","status":"modified","additions":46,"deletions":1,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/MixedLockLevelsHelper.java","raw_url":"https://github.com/apache/openjpa/raw/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/MixedLockLevelsHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/MixedLockLevelsHelper.java?ref=b5a412fd426ca91d06d2a8a10c45b60070dd2674","patch":"@@ -20,6 +20,7 @@\n \n import javax.persistence.LockModeType;\n \n+import org.apache.openjpa.kernel.FetchConfiguration;\n import org.apache.openjpa.kernel.MixedLockLevels;\n \n /**\n@@ -29,7 +30,7 @@\n  * @author Albert Lee\n  * @since 2.0.0\n  */\n-public class MixedLockLevelsHelper {\n+public class MixedLockLevelsHelper implements HintValueConverter {\n     /**\n      * Translates javax.persistence LockModeType to internal lock level.\n      */\n@@ -50,6 +51,24 @@ public static int toLockLevel(LockModeType mode) {\n             return MixedLockLevels.LOCK_PESSIMISTIC_WRITE;\n         return MixedLockLevels.LOCK_PESSIMISTIC_FORCE_INCREMENT;\n     }\n+    \n+    public static int toLockLevel(int mode) {\n+        switch (mode) {\n+        case MixedLockLevels.LOCK_OPTIMISTIC:\n+        case MixedLockLevels.LOCK_OPTIMISTIC_FORCE_INCREMENT:\n+        case MixedLockLevels.LOCK_PESSIMISTIC_FORCE_INCREMENT:\n+        case MixedLockLevels.LOCK_PESSIMISTIC_READ:\n+        case MixedLockLevels.LOCK_PESSIMISTIC_WRITE:\n+        case MixedLockLevels.LOCK_NONE:\n+        case MixedLockLevels.LOCK_READ:\n+        case MixedLockLevels.LOCK_WRITE:\n+        case FetchConfiguration.DEFAULT:\n+            return mode;\n+         default:\n+             throw new IllegalArgumentException(\"Unknown lock level \" + mode);\n+        }\n+    }\n+\n \n     /**\n      * Translates internal lock level to javax.persistence LockModeType.\n@@ -71,4 +90,30 @@ public static LockModeType fromLockLevel(int level) {\n             return LockModeType.PESSIMISTIC_WRITE;\n         return LockModeType.PESSIMISTIC_FORCE_INCREMENT;\n     }\n+\n+    public boolean canConvert(Class<?> type) {\n+        return type == LockModeType.class || type == String.class || type == Integer.class || type == int.class;\n+    }\n+\n+    public Object convert(Object original) {\n+        if (original instanceof LockModeType)\n+            return MixedLockLevelsHelper.toLockLevel((LockModeType)original);\n+        if (original instanceof String) {\n+            try {\n+                int value = Integer.parseInt(original.toString());\n+                return MixedLockLevelsHelper.toLockLevel(value);\n+            } catch (NumberFormatException nfe) {\n+                if (\"none\".equalsIgnoreCase(original.toString())) {\n+                    return MixedLockLevels.LOCK_NONE;\n+                }\n+                return MixedLockLevelsHelper.toLockLevel(\n+                        LockModeType.valueOf(original.toString().toUpperCase().replace('-', '_')));\n+            }\n+        }\n+        if (original instanceof Integer) {\n+            return MixedLockLevelsHelper.toLockLevel((Integer)original);\n+        }\n+        \n+        throw new IllegalArgumentException(\"can not convert \" + original + \" of \" + original.getClass());\n+    }\n }"},{"sha":"3c37a2caa1735002547399b70be03979e2286911","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProductDerivation.java","status":"modified","additions":56,"deletions":3,"changes":59,"blob_url":"https://github.com/apache/openjpa/blob/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProductDerivation.java?ref=b5a412fd426ca91d06d2a8a10c45b60070dd2674","patch":"@@ -29,16 +29,17 @@\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.MissingResourceException;\n import java.util.Set;\n \n-import javax.persistence.spi.PersistenceUnitInfo;\n-import javax.persistence.spi.PersistenceUnitTransactionType;\n import javax.persistence.SharedCacheMode;\n import javax.persistence.ValidationMode;\n+import javax.persistence.spi.PersistenceUnitInfo;\n+import javax.persistence.spi.PersistenceUnitTransactionType;\n \n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.conf.Compatibility;\n@@ -48,6 +49,7 @@\n import org.apache.openjpa.conf.Specification;\n import org.apache.openjpa.datacache.DataCacheMode;\n import org.apache.openjpa.kernel.MixedLockLevels;\n+import org.apache.openjpa.kernel.QueryHints;\n import org.apache.openjpa.lib.conf.AbstractProductDerivation;\n import org.apache.openjpa.lib.conf.Configuration;\n import org.apache.openjpa.lib.conf.ConfigurationProvider;\n@@ -94,9 +96,55 @@\n     private HashMap<String, PUNameCollision> _puNameCollisions\n         = new HashMap<String,PUNameCollision>();\n     \n+    public static final String PREFIX = \"javax.persistence\"; \n+    \n+    private static Set<String> _hints = new HashSet<String>();\n+    \n     // Provider name to filter out PUs that don't belong to this derivation.\n     protected String _providerImplName;\n \n+    static {\n+        _hints.add(\"javax.persistence.lock.timeout\");\n+        _hints.add(\"javax.persistence.query.timeout\");\n+        \n+        _hints.add(\"openjpa.FetchPlan.ExtendedPathLookup\");\n+        _hints.add(\"openjpa.FetchBatchSize\"); \n+        _hints.add(\"openjpa.FetchPlan.FetchBatchSize\");\n+        _hints.add(\"openjpa.MaxFetchDepth\"); \n+        _hints.add(\"openjpa.FetchPlan.MaxFetchDepth\");\n+        _hints.add(\"openjpa.LockTimeout\");\n+        _hints.add(\"openjpa.FetchPlan.LockTimeout\");\n+        _hints.add(\"openjpa.QueryTimeout\");\n+        _hints.add(\"openjpa.FetchPlan.QueryTimeout\");\n+        _hints.add(\"openjpa.FlushBeforeQueries\");\n+        _hints.add(\"openjpa.FetchPlan.FlushBeforeQueries\");\n+        _hints.add(\"openjpa.ReadLockLevel\");\n+        _hints.add(\"openjpa.FetchPlan.ReadLockLevel\");\n+        _hints.add(\"openjpa.WriteLockLevel\");\n+        _hints.add(\"openjpa.FetchPlan.WriteLockLevel\");\n+        _hints.add(\"openjpa.FetchPlan.FetchBatchSize\");\n+        _hints.add(\"openjpa.FetchPlan.LockScope\");\n+        _hints.add(\"openjpa.FetchPlan.LockTimeout\");\n+        _hints.add(\"openjpa.FetchPlan.MaxFetchDepth\");\n+        _hints.add(\"openjpa.FetchPlan.QueryTimeout\");\n+        _hints.add(\"openjpa.FetchPlan.ReadLockMode\");\n+        _hints.add(\"openjpa.FetchPlan.WriteLockMode\");\n+        _hints.add(QueryHints.HINT_AGGREGATE_LISTENER);\n+        _hints.add(QueryHints.HINT_AGGREGATE_LISTENERS);\n+        _hints.add(QueryHints.HINT_FILTER_LISTENER);\n+        _hints.add(QueryHints.HINT_FILTER_LISTENERS);\n+        _hints.add(QueryHints.HINT_IGNORE_FINDER);\n+        _hints.add(QueryHints.HINT_IGNORE_PREPARED_QUERY);\n+        _hints.add(QueryHints.HINT_INVALIDATE_FINDER);\n+        _hints.add(QueryHints.HINT_INVALIDATE_PREPARED_QUERY);\n+        _hints.add(QueryHints.HINT_PARAM_MARKER_IN_QUERY);\n+        _hints.add(QueryHints.HINT_RECACHE_FINDER);\n+        _hints.add(QueryHints.HINT_RESULT_COUNT);\n+        _hints.add(QueryHints.HINT_SUBCLASSES);\n+\n+        _hints = Collections.unmodifiableSet(_hints);\n+    }\n+    \n \tpublic PersistenceProductDerivation() {\n \t\t_providerImplName = PersistenceProviderImpl.class.getName();\n \t}\n@@ -110,7 +158,12 @@ public int getType() {\n     \n     @Override\n     public String getConfigurationPrefix() {\n-        return \"javax.persistence\";\n+        return PREFIX;\n+    }\n+    \n+    @Override\n+    public Set<String> getSupportedQueryHints() {\n+        return _hints;\n     }\n \n     @Override"}]}

