{"sha":"b8bb8404a9c1da1dd22ac8b414f7496ee033acbd","node_id":"MDY6Q29tbWl0MjA2MzY0OmI4YmI4NDA0YTljMWRhMWRkMjJhYzhiNDE0Zjc0OTZlZTAzM2FjYmQ=","commit":{"author":{"name":"Craig Russell","email":"clr@apache.org","date":"2007-07-17T23:56:45Z"},"committer":{"name":"Craig Russell","email":"clr@apache.org","date":"2007-07-17T23:56:45Z"},"message":"OPENJPA-235 break-nullable-patch contributed by Markus Fuchs\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@557089 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"daef4e142379608172e05ebbf208b3c0fe4bea7a","url":"https://api.github.com/repos/apache/openjpa/git/trees/daef4e142379608172e05ebbf208b3c0fe4bea7a"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd","html_url":"https://github.com/apache/openjpa/commit/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd","comments_url":"https://api.github.com/repos/apache/openjpa/commits/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/comments","author":{"login":"papajdo","id":2455884,"node_id":"MDQ6VXNlcjI0NTU4ODQ=","avatar_url":"https://avatars.githubusercontent.com/u/2455884?v=4","gravatar_id":"","url":"https://api.github.com/users/papajdo","html_url":"https://github.com/papajdo","followers_url":"https://api.github.com/users/papajdo/followers","following_url":"https://api.github.com/users/papajdo/following{/other_user}","gists_url":"https://api.github.com/users/papajdo/gists{/gist_id}","starred_url":"https://api.github.com/users/papajdo/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/papajdo/subscriptions","organizations_url":"https://api.github.com/users/papajdo/orgs","repos_url":"https://api.github.com/users/papajdo/repos","events_url":"https://api.github.com/users/papajdo/events{/privacy}","received_events_url":"https://api.github.com/users/papajdo/received_events","type":"User","site_admin":false},"committer":{"login":"papajdo","id":2455884,"node_id":"MDQ6VXNlcjI0NTU4ODQ=","avatar_url":"https://avatars.githubusercontent.com/u/2455884?v=4","gravatar_id":"","url":"https://api.github.com/users/papajdo","html_url":"https://github.com/papajdo","followers_url":"https://api.github.com/users/papajdo/followers","following_url":"https://api.github.com/users/papajdo/following{/other_user}","gists_url":"https://api.github.com/users/papajdo/gists{/gist_id}","starred_url":"https://api.github.com/users/papajdo/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/papajdo/subscriptions","organizations_url":"https://api.github.com/users/papajdo/orgs","repos_url":"https://api.github.com/users/papajdo/repos","events_url":"https://api.github.com/users/papajdo/events{/privacy}","received_events_url":"https://api.github.com/users/papajdo/received_events","type":"User","site_admin":false},"parents":[{"sha":"62ae83f3b5a0eca67b5a5c4ae6cd01c4f6b3ac23","url":"https://api.github.com/repos/apache/openjpa/commits/62ae83f3b5a0eca67b5a5c4ae6cd01c4f6b3ac23","html_url":"https://github.com/apache/openjpa/commit/62ae83f3b5a0eca67b5a5c4ae6cd01c4f6b3ac23"}],"stats":{"total":762,"additions":678,"deletions":84},"files":[{"sha":"8fed879bb415e2c1a1e5b4f59cdd983003550d12","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","status":"modified","additions":195,"deletions":68,"changes":263,"blob_url":"https://github.com/apache/openjpa/blob/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","raw_url":"https://github.com/apache/openjpa/raw/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java?ref=b8bb8404a9c1da1dd22ac8b414f7496ee033acbd","patch":"@@ -24,6 +24,7 @@\n import java.util.HashMap;\r\n import java.util.Iterator;\r\n import java.util.LinkedList;\r\n+import java.util.List;\r\n import java.util.Map;\r\n \r\n import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n@@ -43,6 +44,7 @@\n import org.apache.openjpa.lib.util.Localizer;\r\n import org.apache.openjpa.util.InternalException;\r\n import org.apache.openjpa.util.OpenJPAException;\r\n+import org.apache.openjpa.util.UserException;\r\n \r\n /**\r\n  * <p>Standard update manager, capable of foreign key constraint evaluation.</p>\r\n@@ -163,7 +165,7 @@ private void analyzeForeignKeys(Collection inserts, Collection updates,\n             row2 = getInsertRow(insertMap, rowMgr, row);\r\n             if (row2 != null) {\r\n                 ignoreUpdates = false;\r\n-                graphs[1] = addEdge(graphs[1], row, (PrimaryRow) row2, null);\r\n+                graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row, null);\r\n             }\r\n \r\n             // now check this row's fks against other deletes\r\n@@ -180,7 +182,7 @@ private void analyzeForeignKeys(Collection inserts, Collection updates,\n                 row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\r\n                     Row.ACTION_DELETE, fkVal, false);\r\n                 if (row2 != null && row2.isValid() && row2 != row)\r\n-                    graphs[1] = addEdge(graphs[1], row, (PrimaryRow) row2,\r\n+                    graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row,\r\n                         fks[j]);\r\n             }\r\n         }\r\n@@ -249,7 +251,7 @@ private Graph analyzeAgainstInserts(Collection rows, RowManagerImpl rowMgr,\n                     Row.ACTION_INSERT, row.getForeignKeySet(fks[j]), false);\r\n                 if (row2 != null && row2.isValid() && (row2 != row\r\n                     || fks[j].isDeferred() || fks[j].isLogical()))\r\n-                    graph = addEdge(graph, (PrimaryRow) row2, row, fks[j]);\r\n+                    graph = addEdge(graph, row, (PrimaryRow) row2, fks[j]);\r\n             }\r\n \r\n             // see if there are any relation id columns dependent on\r\n@@ -263,7 +265,7 @@ private Graph analyzeAgainstInserts(Collection rows, RowManagerImpl rowMgr,\n                 row2 = rowMgr.getRow(getBaseTable(sm), Row.ACTION_INSERT,\r\n                     sm, false);\r\n                 if (row2 != null && row2.isValid())\r\n-                    graph = addEdge(graph, (PrimaryRow) row2, row, cols[j]);\r\n+                    graph = addEdge(graph, row, (PrimaryRow) row2, cols[j]);\r\n             }\r\n         }\r\n         return graph;\r\n@@ -318,80 +320,205 @@ protected void flushGraph(Graph graph, PreparedStatementManager psMgr,\n             return;\r\n \r\n         DepthFirstAnalysis dfa = newDepthFirstAnalysis(graph, autoAssign);\r\n+        Collection insertUpdates = new LinkedList();\r\n+        Collection deleteUpdates = new LinkedList();\r\n+        boolean recalculate;\r\n+\r\n+        // Handle circular constraints:\r\n+        // - if deleted row A has a ciricular fk to deleted row B, \r\n+        //   then use an update statement to null A's fk to B before flushing, \r\n+        //   and then flush\r\n+        // - if inserted row A has a circular fk to updated/inserted row B,\r\n+        //   then null the fk in the B row object, then flush,\r\n+        //   and after flushing, use an update to set the fk back to A\r\n+        // Depending on where circular dependencies are broken, the  \r\n+        // topological order of the graph nodes has to be re-calculated.\r\n+        recalculate = resolveCycles(graph, dfa.getEdges(Edge.TYPE_BACK),\r\n+                deleteUpdates, insertUpdates);\r\n+        recalculate |= resolveCycles(graph, dfa.getEdges(Edge.TYPE_FORWARD),\r\n+                deleteUpdates, insertUpdates);\r\n+\r\n+        if (recalculate) {\r\n+            dfa = recalculateDepthFirstAnalysis(graph, autoAssign);\r\n+        }\r\n+\r\n+        // flush delete updates to null fks, then all rows in order, then\r\n+        // the insert updates to set circular fk values\r\n+        flush(deleteUpdates, psMgr);\r\n         Collection nodes = dfa.getSortedNodes();\r\n-        Collection backs = dfa.getEdges(Edge.TYPE_BACK);\r\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();)\r\n+            psMgr.flush((RowImpl) itr.next());\r\n+        flush(insertUpdates, psMgr);\r\n+    }\r\n \r\n-        // handle circular constraints:\r\n-        // - if deleted row A has a ciricular fk to deleted row B, then use an\r\n-        //   update statement to null A's fk to B\r\n-        // - if inserted row A has a circular fk to updated/inserted row B,\r\n-        //   then null the fk in the B row object, and after flushing, use\r\n-        //   an update to set the fk to back to A\r\n-        Collection insertUpdates = null;\r\n-        Collection deleteUpdates = null;\r\n+    /**\r\n+     * Break a circular dependency caused by delete operations.\r\n+     * If deleted row A has a ciricular fk to deleted row B, then use an update \r\n+     * statement to null A's fk to B before deleting B, then delete A.\r\n+     * @param edge Edge in the dependency graph corresponding to a foreign key\r\n+     * constraint. This dependency is broken by nullifying the foreign key.\r\n+     * @param deleteUpdates Collection of update statements that are executed\r\n+     * before the delete operations are flushed \r\n+     */\r\n+    private void addDeleteUpdate(Edge edge, Collection deleteUpdates)\r\n+        throws SQLException {\r\n         PrimaryRow row;\r\n         RowImpl update;\r\n-        Edge edge;\r\n+        ForeignKey fk;\r\n+\r\n+        // copy where conditions into new update that nulls the fk\r\n+        row = (PrimaryRow) edge.getTo();\r\n+        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\r\n+        row.copyInto(update, true);\r\n+        if (edge.getUserObject() instanceof ForeignKey) {\r\n+            fk = (ForeignKey) edge.getUserObject();\r\n+            update.setForeignKey(fk, row.getForeignKeyIO(fk), null);\r\n+        } else\r\n+            update.setNull((Column) edge.getUserObject());\r\n+\r\n+        deleteUpdates.add(update);\r\n+    }\r\n+\r\n+    /**\r\n+     * Break a circular dependency caused by insert operations.\r\n+     * If inserted row A has a circular fk to updated/inserted row B,\r\n+     * then null the fk in the B row object, then flush,\r\n+     * and after flushing, use an update to set the fk back to A.\r\n+     * @param row Row to be flushed\r\n+     * @param edge Edge in the dependency graph corresponding to a foreign key\r\n+     * constraint. This dependency is broken by nullifying the foreign key.\r\n+     * @param insertUpdates Collection of update statements that are executed\r\n+     * after the insert/update operations are flushed \r\n+     */\r\n+    private void addInsertUpdate(PrimaryRow row, Edge edge,\r\n+        Collection insertUpdates) throws SQLException {\r\n+        RowImpl update;\r\n         ForeignKey fk;\r\n         Column col;\r\n-        for (Iterator itr = backs.iterator(); itr.hasNext();) {\r\n-            edge = (Edge) itr.next();\r\n-            if (edge.getUserObject() == null)\r\n-                throw new InternalException(_loc.get(\"del-ins-cycle\"));\r\n-\r\n-            // use a primary row update to prevent setting pk and fk values\r\n-            // until after flush, to get latest auto-increment values\r\n-            row = (PrimaryRow) edge.getTo();\r\n-            if (row.getAction() == Row.ACTION_DELETE) {\r\n-                // copy where conditions into new update that nulls the fk\r\n-                row = (PrimaryRow) edge.getFrom();\r\n-                update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE,null);\r\n-                row.copyInto(update, true);\r\n-                if (edge.getUserObject() instanceof ForeignKey) {\r\n-                    fk = (ForeignKey) edge.getUserObject();\r\n-                    update.setForeignKey(fk, row.getForeignKeyIO(fk), null);\r\n-                } else\r\n-                    update.setNull((Column) edge.getUserObject());\r\n-\r\n-                if (deleteUpdates == null)\r\n-                    deleteUpdates = new LinkedList();\r\n-                deleteUpdates.add(update);\r\n-            } else {\r\n-                // copy where conditions into new update that sets the fk\r\n-                update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE,null);\r\n-                if (row.getAction() == Row.ACTION_INSERT) {\r\n-                    if (row.getPrimaryKey() == null)\r\n-                        throw new InternalException(_loc.get(\"ref-cycle\"));\r\n-                    update.wherePrimaryKey(row.getPrimaryKey());\r\n-                } else\r\n-                    row.copyInto(update, true);\r\n-                if (edge.getUserObject() instanceof ForeignKey) {\r\n-                    fk = (ForeignKey) edge.getUserObject();\r\n-                    update.setForeignKey(fk, row.getForeignKeyIO(fk),\r\n-                        row.getForeignKeySet(fk));\r\n-                    row.clearForeignKey(fk);\r\n-                } else {\r\n-                    col = (Column) edge.getUserObject();\r\n-                    update.setRelationId(col, row.getRelationIdSet(col),\r\n-                        row.getRelationIdCallback(col));\r\n-                    row.clearRelationId(col);\r\n-                }\r\n \r\n-                if (insertUpdates == null)\r\n-                    insertUpdates = new LinkedList();\r\n-                insertUpdates.add(update);\r\n+        // copy where conditions into new update that sets the fk\r\n+        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\r\n+        if (row.getAction() == Row.ACTION_INSERT) {\r\n+            if (row.getPrimaryKey() == null)\r\n+                throw new InternalException(_loc.get(\"ref-cycle\"));\r\n+            update.wherePrimaryKey(row.getPrimaryKey());\r\n+        } else {\r\n+            // Row.ACTION_UPDATE\r\n+            row.copyInto(update, true);\r\n+        }\r\n+        if (edge.getUserObject() instanceof ForeignKey) {\r\n+            fk = (ForeignKey) edge.getUserObject();\r\n+            update.setForeignKey(fk, row.getForeignKeyIO(fk),\r\n+                row.getForeignKeySet(fk));\r\n+            row.clearForeignKey(fk);\r\n+        } else {\r\n+            col = (Column) edge.getUserObject();\r\n+            update.setRelationId(col, row.getRelationIdSet(col),\r\n+                row.getRelationIdCallback(col));\r\n+            row.clearRelationId(col);\r\n+        }\r\n+\r\n+        insertUpdates.add(update);\r\n+    }\r\n+\r\n+    /**\r\n+     * Finds a nullable foreign key by walking the dependency cycle. \r\n+     * Circular dependencies can be broken at this point.\r\n+     * @param cycle Cycle in the dependency graph.\r\n+     * @return Edge corresponding to a nullable foreign key.\r\n+     */\r\n+    private Edge findBreakableLink(List cycle) {\r\n+        Edge breakableLink = null;\r\n+        for (Iterator iter = cycle.iterator(); iter.hasNext(); ) {\r\n+            Edge edge = (Edge) iter.next();\r\n+            Object userObject = edge.getUserObject();\r\n+            if (userObject instanceof ForeignKey) {\r\n+                 if (!((ForeignKey) userObject).hasNotNullColumns()) {\r\n+                     breakableLink = edge;\r\n+                     break;\r\n+                 }\r\n+            } else if (userObject instanceof Column) {\r\n+                if (!((Column) userObject).isNotNull()) {\r\n+                    breakableLink = edge;\r\n+                    break;\r\n+                }\r\n             }\r\n         }\r\n+        return breakableLink;\r\n+    }\r\n \r\n-        // flush delete updates to null fks, then all rows in order, then\r\n-        // the insert updates to set circular fk values\r\n-        if (deleteUpdates != null)\r\n-            flush(deleteUpdates, psMgr);\r\n-        for (Iterator itr = nodes.iterator(); itr.hasNext();)\r\n-            psMgr.flush((RowImpl) itr.next());\r\n-        if (insertUpdates != null)\r\n-            flush(insertUpdates, psMgr);\r\n-\t}\r\n+    /**\r\n+     * Re-calculates the DepthFirstSearch analysis of the graph \r\n+     * after some of the edges have been removed. Ensures\r\n+     * that the dependency graph is cycle free.\r\n+     * @param graph The graph of statements to be walked\r\n+     * @param autoAssign Whether any of the rows in the graph have any\r\n+     * auto-assign constraints\r\n+     */\r\n+    private DepthFirstAnalysis recalculateDepthFirstAnalysis(Graph graph,\r\n+        boolean autoAssign) {\r\n+        DepthFirstAnalysis dfa;\r\n+        // clear previous traversal data\r\n+        graph.clearTraversal();\r\n+        dfa = newDepthFirstAnalysis(graph, autoAssign);\r\n+        // make sure that the graph is non-cyclic now\r\n+        assert (dfa.hasNoCycles()): _loc.get(\"graph-not-cycle-free\");\r\n+        return dfa;\r\n+    }\r\n+\r\n+    /**\r\n+     * Resolve circular dependencies by identifying and breaking\r\n+     * a nullable foreign key.\r\n+     * @param graph Dependency graph.\r\n+     * @param edges Collection of edges. Each edge indicates a possible \r\n+     * circular dependency\r\n+     * @param deleteUpdates Collection of update operations (nullifying \r\n+     * foreign keys) to be filled. These updates will be executed before \r\n+     * the rows in the dependency graph are flushed\r\n+     * @param insertUpdates CCollection of update operations (nullifying \r\n+     * foreign keys) to be filled. These updates will be executed after \r\n+     * the rows in the dependency graph are flushed\r\n+     * @return Depending on where circular dependencies are broken, the  \r\n+     * topological order of the graph nodes has to be re-calculated.\r\n+     */\r\n+    private boolean resolveCycles(Graph graph, Collection edges,\r\n+        Collection deleteUpdates, Collection insertUpdates)\r\n+        throws SQLException {\r\n+        boolean recalculate = false;\r\n+        for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n+            Edge edge = (Edge) itr.next();\r\n+            List cycle = edge.getCycle();\r\n+\r\n+            if (cycle != null) {\r\n+                // find a nullable foreign key\r\n+                Edge breakableLink = findBreakableLink(cycle);\r\n+                if (breakableLink == null) {\r\n+                    throw new UserException(_loc.get(\"no-nullable-fk\"));\r\n+                }\r\n+\r\n+                // topologic node order must be re-calculated,  if the\r\n+                // breakable link is different from the edge where\r\n+                // the circular dependency was originally detected\r\n+                if (edge != breakableLink) {\r\n+                    recalculate = true;\r\n+                }\r\n+\r\n+                if (!breakableLink.isRemovedFromGraph()) {\r\n+\r\n+                    // use a primary row update to prevent setting pk and fk values\r\n+                    // until after flush, to get latest auto-increment values\r\n+                    PrimaryRow row = (PrimaryRow) breakableLink.getFrom();\r\n+                    if (row.getAction() == Row.ACTION_DELETE) {\r\n+                        addDeleteUpdate(breakableLink, deleteUpdates);\r\n+                    } else {\r\n+                        addInsertUpdate(row, breakableLink, insertUpdates);\r\n+                    }\r\n+                    graph.removeEdge(breakableLink);\r\n+                }\r\n+            }\r\n+        }\r\n+        return recalculate;\r\n+    }\r\n \r\n     /**\r\n      * Create a new {@link DepthFirstAnalysis} suitable for the given graph\r"},{"sha":"40df305eadc2f9951ba53d02b66afaed44acc9cc","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","status":"modified","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/apache/openjpa/blob/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","raw_url":"https://github.com/apache/openjpa/raw/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java?ref=b8bb8404a9c1da1dd22ac8b414f7496ee033acbd","patch":"@@ -701,6 +701,19 @@ public boolean columnsMatch(Column[] fkCols, Column[] fkPKCols) {\n             && match(getPrimaryKeyColumns(), fkPKCols);\n     }\n \n+    /**\n+     * Checks for non-nullable local columns.\n+     */\n+    public boolean hasNotNullColumns() {\n+      Column[] columns = getColumns();\n+      for (int j = 0; j < columns.length; j++) {\n+          if (columns[j].isNotNull()) {\n+              return true;\n+          }\n+      }\n+      return false;\n+    }\n+    \n     private static boolean match(Column[] cols, Column[] fkCols) {\n         if (cols.length != fkCols.length)\n             return false;"},{"sha":"dd0f87b759caf8845ad75942649c4d9bcab7f214","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","status":"modified","additions":9,"deletions":1,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties?ref=b8bb8404a9c1da1dd22ac8b414f7496ee033acbd","patch":"@@ -98,7 +98,15 @@ native-seq-usage: Usage: java org.apache.openjpa.jdbc.kernel.NativeJDBCSeq\\n\\\n \t\\t[-properties/-p <properties file or resource>]\\n\\\n \t\\t[-<property name> <property value>]*\n bad-level: Invalid isolation level. Valid levels are -1, \\\n-    Connection.TRANSACTION_NONE, Connection.TRANSACTION_READ_UNCOMMITTED, \\ \n+    Connection.TRANSACTION_NONE, Connection.TRANSACTION_READ_UNCOMMITTED, \\\n     Connection.TRANSACTION_READ_COMMITTED, \\\n     Connection.TRANSACTION_REPEATABLE_READ, or \\\n     Connection.TRANSACTION_SERIALIZABLE. Specified value: {0}.\n+no-nullable-fk: No nullable foreign key found to resolve circular flush\\n\\\n+\tdependency. During flush processing, changes to instances, new\\n\\\n+\tinstances, and deleted instances must be processed in a specific sequence\\n\\\n+\tto avoid foreign key constraint violations. The changes required in this\\n\\\n+\ttransaction cannot be reordered because none of the foreign key constraints\\n\\\n+\tis nullable (optional).\n+graph-not-cycle-free: A circular flush dependency has been found after all \\\n+    circular dependencies should have been resolved."},{"sha":"ae7647450d776a4f3c1d80b97406f808273cecf0","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","status":"modified","additions":149,"deletions":6,"changes":155,"blob_url":"https://github.com/apache/openjpa/blob/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","raw_url":"https://github.com/apache/openjpa/raw/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java?ref=b8bb8404a9c1da1dd22ac8b414f7496ee033acbd","patch":"@@ -18,6 +18,8 @@\n  */\r\n package org.apache.openjpa.lib.graph;\r\n \r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+\r\n import java.util.AbstractList;\r\n import java.util.ArrayList;\r\n import java.util.Arrays;\r\n@@ -26,6 +28,7 @@\n import java.util.Comparator;\r\n import java.util.HashMap;\r\n import java.util.Iterator;\r\n+import java.util.LinkedList;\r\n import java.util.List;\r\n import java.util.Map;\r\n \r\n@@ -42,6 +45,9 @@\n  */\r\n public class DepthFirstAnalysis {\r\n \r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (DepthFirstAnalysis.class);\r\n+\r\n     private final Graph _graph;\r\n     private final Map _nodeInfo = new HashMap();\r\n     private Comparator _comp;\r\n@@ -65,14 +71,15 @@ public DepthFirstAnalysis(Graph graph) {\n             node = itr.next();\r\n             info = (NodeInfo) _nodeInfo.get(node);\r\n             if (info.color == NodeInfo.COLOR_WHITE)\r\n-                visit(graph, node, info, 0);\r\n+                visit(graph, node, info, 0, new LinkedList());\r\n         }\r\n     }\r\n \r\n     /**\r\n      * Visit a node.  See Introduction to Algorithms book for details.\r\n      */\r\n-    private int visit(Graph graph, Object node, NodeInfo info, int time) {\r\n+    private int visit(Graph graph, Object node, NodeInfo info, int time, \r\n+        List path) {\r\n         // discover node\r\n         info.color = NodeInfo.COLOR_GRAY;\r\n \r\n@@ -89,14 +96,24 @@ private int visit(Graph graph, Object node, NodeInfo info, int time) {\n             otherInfo = (NodeInfo) _nodeInfo.get(other);\r\n             if (otherInfo.color == NodeInfo.COLOR_WHITE) {\r\n                 // undiscovered node; recurse into it\r\n-                childTime = visit(graph, other, otherInfo, time);\r\n+                path.add(edge);\r\n+                childTime = visit(graph, other, otherInfo, time, path);\r\n+                path.remove(edge);\r\n                 edge.setType(Edge.TYPE_TREE);\r\n             } else if (otherInfo.color == NodeInfo.COLOR_GRAY) {\r\n                 childTime = -1;\r\n                 edge.setType(Edge.TYPE_BACK);\r\n+                // calculate the cycle including this edge\r\n+                edge.setCycle(cycleForBackEdge(edge, path));\r\n             } else {\r\n                 childTime = otherInfo.finished;\r\n                 edge.setType(Edge.TYPE_FORWARD);\r\n+                // find the cycle including this edge\r\n+                List cycle = new LinkedList();\r\n+                cycle.add(edge);\r\n+                if (cycleForForwardEdge(graph, other, node, cycle)) {\r\n+                    edge.setCycle(cycle);\r\n+                }\r\n             }\r\n             maxChildTime = Math.max(maxChildTime, childTime);\r\n         }\r\n@@ -134,7 +151,7 @@ public List getSortedNodes() {\n     /**\r\n      * Return all edges of the given type.  This method can be used to\r\n      * discover all edges that cause cycles in the graph by passing it\r\n-     * the {@link #EDGE_BACK} edge type.\r\n+     * the {@link Edge#TYPE_BACK} or {@link Edge#TYPE_FORWARD} edge type.\r\n      */\r\n     public Collection getEdges(int type) {\r\n         Collection typed = null;\r\n@@ -166,6 +183,132 @@ public int getFinishedTime(Object node) {\n         return info.finished;\r\n     }\r\n \r\n+    /**\r\n+     * Returns a list of graph edges forming a cycle. The cycle begins \r\n+     * with a type {@link Edge#TYPE_BACK} edge.\r\n+     * @param backEdge \"Starting\" edge of the cycle\r\n+     * @param path Continuous list of graph edges, may be null\r\n+     * @param pos Index of the first edge in path continuing the cycle\r\n+     * @return Cycle starting with a type {@link Edge#TYPE_BACK} edge\r\n+     */\r\n+    private List buildCycle(Edge backEdge, List path, int pos) {\r\n+        int length = path != null ? path.size() - pos : 0;\r\n+        List cycle = new ArrayList(length + 1);\r\n+        cycle.add(0, backEdge);\r\n+        for (int i = 0; i < length; i++) {\r\n+            cycle.add(i + 1, path.get(pos + i));\r\n+        }\r\n+        return cycle;\r\n+    }\r\n+\r\n+    /**\r\n+     * Computes the list of edges forming a cycle. The cycle always exists for\r\n+     * a type {@link Edge#TYPE_BACK} edge. This method should only be called \r\n+     * for type {@link Edge#TYPE_BACK} edges. \r\n+     * @param edge Edge where the cycle was detected\r\n+     * @param path Path consisting of edges to the edge's starting node\r\n+     * @return Cycle starting with a type {@link Edge#TYPE_BACK} edge\r\n+     */\r\n+    private List cycleForBackEdge(Edge edge, List path) {\r\n+        if (edge.getType() != Edge.TYPE_BACK) {\r\n+            return null;\r\n+        }\r\n+        \r\n+        List cycle;\r\n+        int pos = 0;\r\n+        if (path != null && edge.getFrom() != edge.getTo()) {\r\n+            // Not a single edge loop\r\n+            pos = findNodeInPath(edge.getTo(), path);\r\n+            assert (pos >= 0): _loc.get(\"node-not-on-path\", edge, edge.getTo()); \r\n+        } else {\r\n+            assert (edge.getFrom() == edge.getTo()): \r\n+                    _loc.get(\"edge-no-loop\", edge).getMessage();\r\n+            path = null;\r\n+        }\r\n+        cycle = buildCycle(edge, path, pos); \r\n+        assert (cycle != null): _loc.get(\"cycle-null\", edge).getMessage();\r\n+        return cycle;\r\n+    }\r\n+\r\n+    /**\r\n+     * Computes the cycle of edges including node cycleTo. The cycle must not \r\n+     * necessarily exist. This method should only be called for type \r\n+     * {@link Edge#TYPE_FORWARD} edges.\r\n+     * @param graph Graph\r\n+     * @param node Current node\r\n+     * @param cycleTo End node for loop\r\n+     * @param path Path from loop end node to current node\r\n+     * @return True if a cycle has been found. The cycle will be contained in\r\n+     * the <code>path</code> parameter.\r\n+     */\r\n+    private boolean cycleForForwardEdge(Graph graph, Object node,\r\n+        Object cycleTo, List path) {                   \r\n+        boolean found = false;\r\n+        Collection edges = graph.getEdgesFrom(node);\r\n+        for (Iterator itr = edges.iterator(); !found && itr.hasNext();) {\r\n+            Edge edge = (Edge) itr.next();\r\n+            Object other = edge.getOther(node);\r\n+            // Single edge loops are ignored\r\n+            if (node != other) {\r\n+                if (other == cycleTo) {\r\n+                    // Cycle complete\r\n+                    path.add(edge);\r\n+                    found = true;\r\n+                } else if (!path.contains(edge)){\r\n+                    // Walk this edge\r\n+                    path.add(edge);\r\n+                    found = cycleForForwardEdge(graph, other, cycleTo, path);\r\n+                    if (!found) {\r\n+                        // Remove edge again\r\n+                        path.remove(edge);                    \r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n+        return found;\r\n+    }\r\n+    \r\n+    /**\r\n+     * Finds the position of the edge starting from a particular node in the \r\n+     * continuous list of edges.\r\n+     * @param node Node on the cycle.\r\n+     * @param path Continuous list of graph edges.\r\n+     * @return Edge index if found, -1 otherwise.\r\n+     */\r\n+    private int findNodeInPath(Object node, List path) {\r\n+        int pos = -1;\r\n+        if (path != null) {\r\n+            for (int i = 0; i < path.size(); i++) {\r\n+                if (((Edge)path.get(i)).getFrom() == node) {\r\n+                    pos = i;\r\n+                }\r\n+            }\r\n+        }\r\n+        return pos;\r\n+    }\r\n+\r\n+    /**\r\n+     * Test, if the analysis didn't find cycles.\r\n+     */\r\n+    public boolean hasNoCycles() {\r\n+        // a) there must not be any back edges\r\n+        if (!getEdges(Edge.TYPE_BACK).isEmpty()) {\r\n+            return false;\r\n+        }\r\n+        // b) there might be forward edges\r\n+        // make sure these don't indicate cycles\r\n+        Collection edges = getEdges(Edge.TYPE_FORWARD);\r\n+        if (!edges.isEmpty()) {\r\n+            for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n+                Edge edge = (Edge) itr.next();\r\n+                if (edge.getCycle() != null)  {\r\n+                    return false;\r\n+                }\r\n+            }\r\n+        }\r\n+        return true;\r\n+    }\r\n+    \r\n     /**\r\n      * Comparator for toplogically sorting entries in the node info map.\r\n      */\r\n@@ -184,8 +327,8 @@ public int compare(Object o1, Object o2) {\n             NodeInfo n1 = (NodeInfo) e1.getValue();\r\n             NodeInfo n2 = (NodeInfo) e2.getValue();\r\n \r\n-            // reverse finished order\r\n-            int ret = n2.finished - n1.finished;\r\n+            // sort by finished order\r\n+            int ret = n1.finished - n2.finished;\r\n             if (ret == 0 && _subComp != null)\r\n                 ret = _subComp.compare(e1.getKey(), e2.getKey());\r\n             return ret;\r"},{"sha":"5d5b1a7fe208f4b394ec2e7dc51e8ded4bab6c57","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","status":"modified","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","raw_url":"https://github.com/apache/openjpa/raw/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java?ref=b8bb8404a9c1da1dd22ac8b414f7496ee033acbd","patch":"@@ -18,6 +18,8 @@\n  */\r\n package org.apache.openjpa.lib.graph;\r\n \r\n+import java.util.List;\r\n+\r\n /**\r\n  * <p>A graph edge.  Includes the from and to nodes, an arbitrary user object,\r\n  * and a weight.  Edges can be either directed or undirected.</p>\r\n@@ -52,6 +54,8 @@\n     private int _type = 0;\r\n     private double _weight = 0;\r\n     private Object _userObj = null;\r\n+    private List _cycle = null;\r\n+    private boolean _removedFromGraph = false;\r\n \r\n     /**\r\n      * Constructor.\r\n@@ -175,11 +179,40 @@ public void setType(int type) {\n         _type = type;\r\n     }\r\n \r\n+    /**\r\n+     * List of edges forming a cycle. Only set for TYPE_BACK and TYPE_FORWARD edges.\r\n+     */\r\n+    public List getCycle() {\r\n+        return _cycle;\r\n+    }\r\n+    \r\n+    /**\r\n+     * List of edges forming a cycle. Only set for TYPE_BACK and TYPE_FORWARD edges.\r\n+     */\r\n+    public void setCycle(List cycle) {\r\n+        _cycle = cycle;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns if this edge is (still) part of the graph.\r\n+     */\r\n+    public boolean isRemovedFromGraph() {\r\n+        return _removedFromGraph;\r\n+    }\r\n+\r\n+    /**\r\n+     * Mark this edge as removed from the graph.\r\n+     */\r\n+    public void setRemovedFromGraph() {\r\n+        this._removedFromGraph = true;\r\n+    }\r\n+\r\n     /**\r\n      * Clear traversal info.\r\n      */\r\n     public void clearTraversal() {\r\n         _type = 0;\r\n+        _cycle = null;\r\n     }\r\n \r\n     public String toString() {\r"},{"sha":"ed10c2082d841ab91a64409464a70c8b50fdf57a","filename":"openjpa-lib/src/main/resources/org/apache/openjpa/lib/graph/localizer.properties","status":"added","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/apache/openjpa/blob/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-lib/src/main/resources/org/apache/openjpa/lib/graph/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-lib/src/main/resources/org/apache/openjpa/lib/graph/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/resources/org/apache/openjpa/lib/graph/localizer.properties?ref=b8bb8404a9c1da1dd22ac8b414f7496ee033acbd","patch":"@@ -0,0 +1,22 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+# http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.  \n+\n+cycle-null: The cycle must not be null for edge {0}!\n+edge-no-loop: Edge {0} must be a single node loop, if the depth first search \\\n+    path is null!\n+node-not-on-path: Could not find node {1} in the depth first search path \\\n+    leading to edge {0}!"},{"sha":"d16170b5ae4387170b8dd55263741e6d66c3c93f","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","status":"modified","additions":74,"deletions":2,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","raw_url":"https://github.com/apache/openjpa/raw/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java?ref=b8bb8404a9c1da1dd22ac8b414f7496ee033acbd","patch":"@@ -20,6 +20,7 @@\n \r\n import java.util.Collection;\r\n import java.util.Iterator;\r\n+import java.util.List;\r\n \r\n import org.apache.openjpa.lib.test.AbstractTestCase;\r\n \r\n@@ -34,6 +35,10 @@\n     private DepthFirstAnalysis _dfa = null;\r\n \r\n     public void setUp() {\r\n+        setUpGraph1();   \r\n+    }\r\n+    \r\n+    public void setUpGraph1() {\r\n         Graph graph = new Graph();\r\n         Object node1 = new Object();\r\n         Object node2 = new Object();\r\n@@ -51,15 +56,37 @@ public void setUp() {\n         _dfa = new DepthFirstAnalysis(graph);\r\n     }\r\n \r\n+    public void setUpGraph2() {\r\n+        Graph graph = new Graph();\r\n+        Integer node1 = new Integer(5);\r\n+        Integer node2 = new Integer(4);\r\n+        Integer node3 = new Integer(3);\r\n+        Integer node4 = new Integer(2);\r\n+        Integer node5 = new Integer(1);\r\n+        graph.addNode(node1);\r\n+        graph.addNode(node2);\r\n+        graph.addNode(node3);\r\n+        graph.addNode(node4);\r\n+        graph.addNode(node5);\r\n+        graph.addEdge(new Edge(node1, node2, true));\r\n+        graph.addEdge(new Edge(node2, node3, true));\r\n+        graph.addEdge(new Edge(node3, node3, true));\r\n+        graph.addEdge(new Edge(node3, node4, true));\r\n+        graph.addEdge(new Edge(node4, node1, true));\r\n+        graph.addEdge(new Edge(node4, node2, true));\r\n+        graph.addEdge(new Edge(node5, node2, true));\r\n+        _dfa = new DepthFirstAnalysis(graph);\r\n+    }\r\n+\r\n     public void testNodeSorting() {\r\n         Collection nodes = _dfa.getSortedNodes();\r\n         assertEquals(4, nodes.size());\r\n \r\n-        int time = Integer.MAX_VALUE;\r\n+        int time = 0;\r\n         Object node;\r\n         for (Iterator itr = nodes.iterator(); itr.hasNext();) {\r\n             node = itr.next();\r\n-            assertTrue(time >= _dfa.getFinishedTime(node));\r\n+            assertTrue(time <= _dfa.getFinishedTime(node));\r\n             time = _dfa.getFinishedTime(node);\r\n         }\r\n     }\r\n@@ -74,6 +101,51 @@ public void testEdgeTyping() {\n             || edge1.getTo() == edge1.getFrom());\r\n     }\r\n \r\n+    public void testBackEdges() {\r\n+        setUpGraph2();\r\n+        Collection edges = _dfa.getEdges(Edge.TYPE_BACK);\r\n+        assertEquals(2, edges.size());\r\n+        Iterator itr = edges.iterator();\r\n+        Edge edge0 = (Edge) itr.next();\r\n+        Edge edge1 = (Edge) itr.next();\r\n+        if (edge0.getTo() == edge0.getFrom()) {\r\n+            assertTrue(edge0.getCycle() != null && edge0.getCycle().size() == 1);\r\n+            List cycle = edge1.getCycle();\r\n+            assertTrue(cycle != null && cycle.size() == 4);\r\n+            assertTrue(((Edge)cycle.get(0)).getFrom() == ((Edge)cycle.get(3)).getTo());\r\n+        } else if (edge1.getTo() == edge1.getFrom()) {\r\n+            assertTrue(edge1.getCycle() != null && edge1.getCycle().size() == 1);            \r\n+            assertTrue(edge1 == edge1.getCycle());\r\n+            List cycle = edge0.getCycle();\r\n+            assertTrue(cycle != null && cycle.size() == 4);\r\n+            assertTrue(((Edge)cycle.get(0)).getFrom() == ((Edge)cycle.get(3)).getTo());\r\n+        } else {\r\n+            // should not happen\r\n+            assertFalse(true);\r\n+        }\r\n+    }\r\n+    \r\n+    public void testForwardEdges() {\r\n+        setUpGraph2();\r\n+        Collection edges = _dfa.getEdges(Edge.TYPE_FORWARD);\r\n+        assertEquals(2, edges.size());\r\n+        Iterator itr = edges.iterator();\r\n+        Edge edge0 = (Edge) itr.next();\r\n+        Edge edge1 = (Edge) itr.next();\r\n+        if (edge0.getCycle() == null) {\r\n+            List cycle = edge1.getCycle();\r\n+            assertTrue(cycle != null && cycle.size() == 3);\r\n+            assertTrue(((Edge)cycle.get(0)).getFrom() == ((Edge)cycle.get(2)).getTo());\r\n+        } else if (edge1.getCycle() == null) {\r\n+            List cycle = edge0.getCycle();\r\n+            assertTrue(cycle != null && cycle.size() == 3);\r\n+            assertTrue(((Edge)cycle.get(0)).getFrom() == ((Edge)cycle.get(2)).getTo());\r\n+        } else {\r\n+            // should not happen\r\n+            assertFalse(true);\r\n+        }\r\n+    }\r\n+    \r\n     public static void main(String[] args) {\r\n         main(TestDepthFirstAnalysis.class);\r\n     }\r"},{"sha":"a4087f2b039f6c90f3a516a79d4c2c1df799e4e6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","raw_url":"https://github.com/apache/openjpa/raw/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java?ref=b8bb8404a9c1da1dd22ac8b414f7496ee033acbd","patch":"@@ -40,7 +40,7 @@\n \r\n     private String name;\r\n \r\n-    @OneToOne(cascade = CascadeType.ALL)\r\n+    @OneToOne(cascade = CascadeType.ALL, optional = false)\r\n     @JoinColumn(name = \"entityc_id\", referencedColumnName = \"entityc_id\",\r\n         nullable = false)\r\n     @ForeignKey\r"},{"sha":"03c85b4f31f07e6cb5392e1890a098eaf51ea522","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","raw_url":"https://github.com/apache/openjpa/raw/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java?ref=b8bb8404a9c1da1dd22ac8b414f7496ee033acbd","patch":"@@ -41,7 +41,7 @@\n \r\n     private String name;\r\n \r\n-    @OneToOne(cascade = CascadeType.ALL)\r\n+    @OneToOne(cascade = CascadeType.ALL, optional = false)\r\n     @JoinColumn(name = \"entityd_id\", referencedColumnName = \"entityd_id\",\r\n         nullable = false)\r\n     @ForeignKey\r"},{"sha":"d321dd2e0ff539e30a9ba739ca8373cfde66dc74","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","status":"modified","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","raw_url":"https://github.com/apache/openjpa/raw/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java?ref=b8bb8404a9c1da1dd22ac8b414f7496ee033acbd","patch":"@@ -18,12 +18,16 @@\n  */\r\n package org.apache.openjpa.jdbc.kernel;\r\n \r\n+import org.apache.openjpa.persistence.jdbc.ForeignKey;\r\n+\r\n import javax.persistence.Column;\r\n import javax.persistence.Entity;\r\n import javax.persistence.GeneratedValue;\r\n import javax.persistence.GenerationType;\r\n import javax.persistence.Id;\r\n import javax.persistence.Version;\r\n+import javax.persistence.OneToOne;\r\n+import javax.persistence.JoinColumn;\r\n \r\n @Entity\r\n public class EntityD {\r\n@@ -35,6 +39,16 @@\n \r\n     private String name;\r\n \r\n+    @OneToOne\r\n+    @JoinColumn(name = \"entitya_id\", referencedColumnName = \"entitya_id\")\r\n+    @ForeignKey\r\n+    private EntityA entityA;\r\n+    \r\n+    @OneToOne\r\n+    @JoinColumn(name = \"entityb_id\", referencedColumnName = \"entityb_id\")\r\n+    @ForeignKey\r\n+    private EntityB entityB;\r\n+    \r\n     @Version\r\n     private Integer optLock;\r\n \r\n@@ -49,6 +63,22 @@ public Integer getId() {\n         return id;\r\n     }\r\n \r\n+    public EntityA getEntityA() {\r\n+        return this.entityA;\r\n+    }\r\n+\r\n+    public void setEntityA(EntityA entityA) {\r\n+        this.entityA = entityA;\r\n+    }\r\n+\r\n+    public EntityB getEntityB() {\r\n+        return entityB;\r\n+    }\r\n+\r\n+    public void setEntityB(EntityB entityB) {\r\n+        this.entityB = entityB;\r\n+    }\r\n+    \r\n     public String getName() {\r\n         return this.name;\r\n     }\r"},{"sha":"df5b8302651859d14ad5bebf6a28bd63a1de9de1","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityE.java","status":"added","additions":76,"deletions":0,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityE.java","raw_url":"https://github.com/apache/openjpa/raw/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityE.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityE.java?ref=b8bb8404a9c1da1dd22ac8b414f7496ee033acbd","patch":"@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.OneToOne;\n+import javax.persistence.Version;\n+\n+import org.apache.openjpa.persistence.jdbc.ForeignKey;\n+\n+@Entity\n+public class EntityE {\n+\n+    @Id\n+    @Column(name = \"entitye_id\", nullable = false)\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Integer id;\n+\n+    private String name;\n+\n+    @OneToOne\n+    @JoinColumn(name = \"entityb_id\", referencedColumnName = \"entityb_id\")\n+    @ForeignKey\n+    private EntityB entityB;\n+\n+    @Version\n+    private Integer optLock;\n+\n+    public EntityE() {\n+    }\n+\n+    public void setId(Integer id) {\n+        this.id = id;\n+    }\n+\n+    public Integer getId() {\n+        return id;\n+    }\n+\n+    public EntityB getEntityB() {\n+        return this.entityB;\n+    }\n+\n+    public void setEntityB(EntityB entityB) {\n+        this.entityB = entityB;\n+    }\n+\n+    public String getName() {\n+        return this.name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+}"},{"sha":"956e569e5621be26ddf69b674c2bb8acaabfc26c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","status":"modified","additions":75,"deletions":5,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","raw_url":"https://github.com/apache/openjpa/raw/b8bb8404a9c1da1dd22ac8b414f7496ee033acbd/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java?ref=b8bb8404a9c1da1dd22ac8b414f7496ee033acbd","patch":"@@ -34,15 +34,20 @@\n     private EntityA entityA;\r\n     private EntityB entityB;\r\n     private EntityC entityC;\r\n+    private EntityD entityD;\r\n \r\n     public void setUp() {\r\n-        setUp(EntityA.class, EntityB.class, EntityC.class, EntityD.class);\r\n+        setUp(EntityA.class, EntityB.class, EntityC.class, EntityD.class, EntityE.class);\r\n \r\n+        createTestData();\r\n+    }\r\n+\r\n+    private void createTestData() {\r\n         entityA = new EntityA();\r\n+        entityB = new EntityB();\r\n         entityC = new EntityC();\r\n-        EntityD entityD = new EntityD();\r\n+        entityD = new EntityD();\r\n         entityA.setName(\"entityA\");\r\n-        entityB = new EntityB();\r\n         entityB.setName(\"entityB\");\r\n         entityC.setName(\"entityC\");\r\n         entityD.setName(\"entityD\");\r\n@@ -52,7 +57,6 @@ public void setUp() {\n     }\r\n \r\n     public void testSqlOrder() {\r\n-\r\n         EntityManager em = emf.createEntityManager();\r\n         try {\r\n             em.getTransaction().begin();\r\n@@ -70,7 +74,7 @@ public void testSqlOrder() {\n             EntityC newEntityC = new EntityC();\r\n             newEntityC.setName(\"newEntityC\");\r\n             newEntityD = new EntityD();\r\n-            newEntityD.setName(\"newEntityD\");\r\n+            newEntityD.setName(\"newNewEntityD\");\r\n             newEntityC.setEntityD(newEntityD);\r\n             entityB.setEntityC(newEntityC);\r\n \r\n@@ -84,4 +88,70 @@ public void testSqlOrder() {\n             em.close();\r\n         }\r\n     }\r\n+    \r\n+    public void testSimpleCycle() {\r\n+        EntityManager em = emf.createEntityManager();\r\n+        try {\r\n+            em.getTransaction().begin();\r\n+            entityD.setEntityA(entityA);\r\n+            em.persist(entityA);\r\n+            em.getTransaction().commit();\r\n+        }\r\n+        finally {\r\n+            if (em.getTransaction().isActive())\r\n+                em.getTransaction().rollback();\r\n+            em.close();\r\n+        }\r\n+    }\r\n+    \r\n+    public void testComplexCycle() {\r\n+        EntityManager em = emf.createEntityManager();\r\n+        try {\r\n+            EntityE entityE = new EntityE();\r\n+            entityE.setName(\"entityE\");\r\n+            entityE.setEntityB(entityB);\r\n+\r\n+            em.getTransaction().begin();\r\n+            em.persist(entityE);\r\n+            entityD.setEntityA(entityA);\r\n+            em.persist(entityA);\r\n+            em.getTransaction().commit();\r\n+            \r\n+            em.getTransaction().begin();\r\n+            em.remove(entityE);\r\n+            em.remove(entityA);\r\n+            em.getTransaction().commit();\r\n+        }\r\n+        finally {\r\n+            if (em.getTransaction().isActive())\r\n+                em.getTransaction().rollback();\r\n+            em.close();\r\n+        }\r\n+    }\r\n+\r\n+    public void testComplexTwoCycles() {\r\n+        EntityManager em = emf.createEntityManager();\r\n+        try {\r\n+            EntityE entityE = new EntityE();\r\n+            entityE.setName(\"entityE\");\r\n+            entityE.setEntityB(entityB);\r\n+\r\n+            em.getTransaction().begin();\r\n+            em.persist(entityE);\r\n+            entityD.setEntityA(entityA);\r\n+            entityD.setEntityB(entityB);\r\n+            em.persist(entityA);\r\n+            em.getTransaction().commit();\r\n+            \r\n+            em.getTransaction().begin();\r\n+            em.remove(entityE);\r\n+            em.remove(entityA);\r\n+            em.getTransaction().commit();\r\n+        }\r\n+        finally {\r\n+            if (em.getTransaction().isActive())\r\n+                em.getTransaction().rollback();\r\n+            em.close();\r\n+        }\r\n+    }\r\n }\r"}]}

