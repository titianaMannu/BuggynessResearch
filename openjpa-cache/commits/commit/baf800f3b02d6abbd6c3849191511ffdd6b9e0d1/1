{"sha":"baf800f3b02d6abbd6c3849191511ffdd6b9e0d1","node_id":"MDY6Q29tbWl0MjA2MzY0OmJhZjgwMGYzYjAyZDZhYmJkNmMzODQ5MTkxNTExZmZkZDZiOWUwZDE=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2009-09-29T02:43:32Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2009-09-29T02:43:32Z"},"message":"OPENJPA-1050: Use generics for BrokerFactory\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@819800 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"cf6ca928d3bdb5b568870f92ba433f608fd8092c","url":"https://api.github.com/repos/apache/openjpa/git/trees/cf6ca928d3bdb5b568870f92ba433f608fd8092c"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1","html_url":"https://github.com/apache/openjpa/commit/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1","comments_url":"https://api.github.com/repos/apache/openjpa/commits/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/comments","author":null,"committer":null,"parents":[{"sha":"9d37d74a105f2a97061e127791555495ccdc055b","url":"https://api.github.com/repos/apache/openjpa/commits/9d37d74a105f2a97061e127791555495ccdc055b","html_url":"https://github.com/apache/openjpa/commit/9d37d74a105f2a97061e127791555495ccdc055b"}],"stats":{"total":321,"additions":131,"deletions":190},"files":[{"sha":"ef4f759d56440c3e791cc619b1633a05c5a7a001","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCBrokerFactory.java","status":"modified","additions":4,"deletions":7,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCBrokerFactory.java?ref=baf800f3b02d6abbd6c3849191511ffdd6b9e0d1","patch":"@@ -20,8 +20,6 @@\n \n import java.util.Arrays;\n import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.Properties;\n import java.util.Map;\n \n import org.apache.commons.lang.StringUtils;\n@@ -44,6 +42,7 @@\n  * @author Abe White\n  * @author Marc Prud'hommeaux\n  */\n+@SuppressWarnings(\"serial\")\n public class JDBCBrokerFactory\n     extends AbstractBrokerFactory {\n \n@@ -67,7 +66,7 @@ public static JDBCBrokerFactory newInstance(ConfigurationProvider cp) {\n      * Invoked from {@link Bootstrap#getBrokerFactory}.\n      */\n     public static JDBCBrokerFactory getInstance(ConfigurationProvider cp) {\n-        Map props = cp.getProperties();\n+        Map<String,Object> props = cp.getProperties();\n         Object key = toPoolKey(props);\n         JDBCBrokerFactory factory = (JDBCBrokerFactory)\n             getPooledFactoryForKey(key);\n@@ -134,7 +133,7 @@ protected void synchronizeMappings(ClassLoader loader,\n             return;\n \n         MappingRepository repo = conf.getMappingRepositoryInstance();\n-        Collection classes = repo.loadPersistentTypes(false, loader);\n+        Collection<Class<?>> classes = repo.loadPersistentTypes(false, loader);\n         if (classes.isEmpty())\n             return;\n \n@@ -145,9 +144,7 @@ protected void synchronizeMappings(ClassLoader loader,\n             \"SynchronizeMappings\");\n \n         // initialize the schema\n-        Class cls;\n-        for (Iterator itr = classes.iterator(); itr.hasNext();) {\n-            cls = (Class) itr.next();\n+        for (Class<?> cls : classes) {\n             try {\n                 tool.run(cls);\n             } catch (IllegalArgumentException iae) {"},{"sha":"4f1956fdc67553d40cea53b28e752e24784b65d1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","status":"modified","additions":12,"deletions":23,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","raw_url":"https://github.com/apache/openjpa/raw/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java?ref=baf800f3b02d6abbd6c3849191511ffdd6b9e0d1","patch":"@@ -18,37 +18,29 @@\n  */\n package org.apache.openjpa.enhance;\n \n-import java.lang.instrument.Instrumentation;\n-import java.lang.instrument.ClassFileTransformer;\n import java.lang.instrument.ClassDefinition;\n-import java.lang.instrument.UnmodifiableClassException;\n-import java.lang.reflect.InvocationTargetException;\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.Instrumentation;\n import java.lang.reflect.Method;\n import java.security.ProtectionDomain;\n import java.util.Map;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.ArrayList;\n-import java.io.IOException;\n \n import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.util.JavaVersions;\n import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.util.InternalException;\n-import org.apache.openjpa.util.UserException;\n \n /**\n  * Redefines the method bodies of existing classes. Supports Java 5 VMs that\n- * have a javaagent installed on the command line as well as newer VMs without\n- * any javaagent flag.\n+ * have a java agent installed on the command line as well as newer VMs without\n+ * any <code>-javaagent</code> flag.\n  *\n  * @since 1.0.0\n  */\n public class ClassRedefiner {\n \n-    private static final Localizer _loc = \n-        Localizer.forPackage(ClassRedefiner.class);\n+    private static final Localizer _loc = Localizer.forPackage(ClassRedefiner.class);\n \n     private static Boolean _canRedefine = null;\n \n@@ -59,18 +51,17 @@\n      * this method is a no-op.\n      */\n     public static void redefineClasses(OpenJPAConfiguration conf,\n-        final Map<Class,byte[]> classes) {\n+        final Map<Class<?>,byte[]> classes) {\n         Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\n         if (classes == null || classes.size() == 0 || !canRedefineClasses(log))\n             return;\n \n         Instrumentation inst = null;\n         ClassFileTransformer t = null;\n         try {\n-            inst =\n-                InstrumentationFactory.getInstrumentation(log);\n+            inst = InstrumentationFactory.getInstrumentation(log);\n \n-            Class[] array = classes.keySet().toArray(new Class[classes.size()]);\n+            Class<?>[] array = classes.keySet().toArray(new Class[classes.size()]);\n             if (JavaVersions.VERSION >= 6) {\n                 log.trace(_loc.get(\"retransform-types\", classes.keySet()));\n \n@@ -120,15 +111,13 @@ public static void redefineClasses(OpenJPAConfiguration conf,\n     public static boolean canRedefineClasses(Log log) {\n         if (_canRedefine == null) {\n             try {\n-                Instrumentation inst = InstrumentationFactory\n-                    .getInstrumentation(log);\n+                Instrumentation inst = InstrumentationFactory.getInstrumentation(log);\n                 if (inst == null) {\n                     _canRedefine = Boolean.FALSE;\n                 } else if (JavaVersions.VERSION == 5) {\n-                    // if inst is non-null and we're using Java 5,\n+                    // if instrumentation is non-null and we're using Java 5,\n                     // isRetransformClassesSupported isn't available,\n-                    // so we use the more basic class redefinition\n-                    // instead.\n+                    // so we use the more basic class redefinition instead.\n                     _canRedefine = Boolean.TRUE;\n                 } else {\n                     _canRedefine = (Boolean) Instrumentation.class.getMethod("},{"sha":"719d09e77cfab525cf33ec614f4c1193c0b39302","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","status":"modified","additions":31,"deletions":38,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","raw_url":"https://github.com/apache/openjpa/raw/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java?ref=baf800f3b02d6abbd6c3849191511ffdd6b9e0d1","patch":"@@ -25,7 +25,6 @@\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -78,20 +77,19 @@\n      *\n      * @since 1.0.0\n      */\n-    public static List<Class> prepareUnenhancedClasses(\n+    public static List<Class<?>> prepareUnenhancedClasses(\n         final OpenJPAConfiguration conf,\n-        final Collection<? extends Class> classes,\n+        final Collection<? extends Class<?>> classes,\n         final ClassLoader envLoader) {\n         if (classes == null)\n             return null;\n         if (classes.size() == 0)\n-            return Collections.EMPTY_LIST;\n+            return Collections.emptyList();\n \n         Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\n-        if (conf.getRuntimeUnenhancedClassesConstant()\n-            != RuntimeUnenhancedClassesModes.SUPPORTED) {\n-            Collection unenhanced = new ArrayList();\n-            for (Class cls : classes)\n+        if (conf.getRuntimeUnenhancedClassesConstant() != RuntimeUnenhancedClassesModes.SUPPORTED) {\n+            Collection<Class<?>> unenhanced = new ArrayList<Class<?>>();\n+            for (Class<?> cls : classes)\n                 if (!PersistenceCapable.class.isAssignableFrom(cls))\n                     unenhanced.add(cls);\n             if (unenhanced.size() > 0) {\n@@ -123,28 +121,26 @@\n \n         boolean redefine = ClassRedefiner.canRedefineClasses(log);\n         if (redefine)\n-            log.info(_loc.get(\"enhance-and-subclass-and-redef-start\",\n-                classes));\n+            log.info(_loc.get(\"enhance-and-subclass-and-redef-start\", classes));\n         else\n-            log.info(_loc.get(\"enhance-and-subclass-no-redef-start\",\n-                classes));\n+            log.info(_loc.get(\"enhance-and-subclass-no-redef-start\",  classes));\n \n-        final Map<Class, byte[]> map = new HashMap<Class, byte[]>();\n-        final List subs = new ArrayList(classes.size());\n-        final List ints = new ArrayList(classes.size());\n-        Set<Class> unspecified = null;\n-        for (Iterator iter = classes.iterator(); iter.hasNext(); ) {\n-            final Class cls = (Class) iter.next();\n+        final Map<Class<?>, byte[]> map = new HashMap<Class<?>, byte[]>();\n+        final List<Class<?>> subs = new ArrayList<Class<?>>(classes.size());\n+        final List<Class<?>> ints = new ArrayList<Class<?>>(classes.size());\n+        Set<Class<?>> unspecified = null;\n+        for (Class<?> cls : classes) {\n+            final Class<?> c = cls;\n             final PCEnhancer enhancer = new PCEnhancer(conf, cls); \n \n             enhancer.setBytecodeWriter(new BytecodeWriter() {\n                 public void write(BCClass bc) throws IOException {\n-                    ManagedClassSubclasser.write(bc, enhancer, map,\n-                        cls, subs, ints);\n+                    ManagedClassSubclasser.write(bc, enhancer, map, c, subs, ints);\n                 }\n             });\n-            if (redefine)\n+            if (redefine) {\n                 enhancer.setRedefine(true);\n+            }\n             enhancer.setCreateSubclass(true);\n             enhancer.setAddDefaultConstructor(true);\n \n@@ -157,13 +153,11 @@ public void write(BCClass bc) throws IOException {\n             // reconfiguration at the end of this method.\n             ClassMetaData meta = enhancer.getMetaData();\n             if (meta == null) {\n-                throw new MetaDataException(_loc.get(\"no-meta\", cls)).\n-                        setFatal(true);\n+                throw new MetaDataException(_loc.get(\"no-meta\", cls)).setFatal(true);\n             }\n             configureMetaData(meta, conf, redefine, false);\n \n-            unspecified = collectRelatedUnspecifiedTypes(enhancer.getMetaData(),\n-                classes, unspecified);\n+            unspecified = collectRelatedUnspecifiedTypes(enhancer.getMetaData(), classes, unspecified);\n \n             int runResult = enhancer.run();\n             if (runResult == PCEnhancer.ENHANCE_PC) {\n@@ -177,24 +171,23 @@ public void write(BCClass bc) throws IOException {\n         }\n \n         if (unspecified != null && !unspecified.isEmpty())\n-            throw new UserException(_loc.get(\"unspecified-unenhanced-types\",\n-                classes, unspecified));\n+            throw new UserException(_loc.get(\"unspecified-unenhanced-types\", classes, unspecified));\n \n         ClassRedefiner.redefineClasses(conf, map);\n-        for (Class cls : map.keySet()) {\n+        for (Class<?> cls : map.keySet()) {\n             setIntercepting(conf, envLoader, cls);\n             configureMetaData(conf, envLoader, cls, redefine);\n         }\n-        for (Class cls : (Collection<Class>) subs)\n+        for (Class<?> cls : subs)\n             configureMetaData(conf, envLoader, cls, redefine);\n-        for (Class cls : (Collection<Class>) ints)\n+        for (Class<?> cls : ints)\n             setIntercepting(conf, envLoader, cls);\n \n         return subs;\n     }\n \n-    private static Set<Class> collectRelatedUnspecifiedTypes(ClassMetaData meta,\n-        Collection<? extends Class> classes, Set<Class> unspecified) {\n+    private static Set<Class<?>> collectRelatedUnspecifiedTypes(ClassMetaData meta,\n+        Collection<? extends Class<?>> classes, Set<Class<?>> unspecified) {\n         unspecified = collectUnspecifiedType(meta.getPCSuperclass(), classes,\n             unspecified);\n \n@@ -217,20 +210,20 @@ public void write(BCClass bc) throws IOException {\n         return unspecified;\n     }\n \n-    private static Set<Class> collectUnspecifiedType(Class cls,\n-        Collection<? extends Class> classes, Set<Class> unspecified) {\n+    private static Set<Class<?>> collectUnspecifiedType(Class<?> cls,\n+        Collection<? extends Class<?>> classes, Set<Class<?>> unspecified) {\n         if (cls != null && !classes.contains(cls)\n             && !ImplHelper.isManagedType(null, cls)\n             && !cls.isInterface()) {\n             if (unspecified == null)\n-                unspecified = new HashSet<Class>();\n+                unspecified = new HashSet<Class<?>>();\n             unspecified.add(cls);\n         }\n         return unspecified;\n     }\n \n     private static void configureMetaData(OpenJPAConfiguration conf,\n-        ClassLoader envLoader, Class cls, boolean redefineAvailable) {\n+        ClassLoader envLoader, Class<?> cls, boolean redefineAvailable) {\n         ClassMetaData meta = conf.getMetaDataRepositoryInstance()\n             .getMetaData(cls, envLoader, true);\n         configureMetaData(meta, conf, redefineAvailable, true);\n@@ -272,7 +265,7 @@ private static void configureMetaData(ClassMetaData meta,\n     }\n \n     private static void write(BCClass bc, PCEnhancer enhancer,\n-        Map<Class, byte[]> map, Class cls, List subs, List ints)\n+        Map<Class<?>, byte[]> map, Class<?> cls, List<Class<?>> subs, List<Class<?>> ints)\n         throws IOException {\n \n         if (bc == enhancer.getManagedTypeBytecode()) {\n@@ -313,7 +306,7 @@ private static void debugBytecodes(BCClass bc) throws IOException {\n     }\n \n     private static void setIntercepting(OpenJPAConfiguration conf,\n-        ClassLoader envLoader, Class cls) {\n+        ClassLoader envLoader, Class<?> cls) {\n         ClassMetaData meta = conf.getMetaDataRepositoryInstance()\n             .getMetaData(cls, envLoader, true);\n         meta.setIntercepting(true);"},{"sha":"f2fb0d797fa4b6af120634697444617e1be45fae","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","status":"modified","additions":48,"deletions":73,"changes":121,"blob_url":"https://github.com/apache/openjpa/blob/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java?ref=baf800f3b02d6abbd6c3849191511ffdd6b9e0d1","patch":"@@ -28,7 +28,6 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-import java.util.TreeSet;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.locks.ReentrantLock;\n \n@@ -57,6 +56,7 @@\n import org.apache.openjpa.lib.util.J2DoPrivHelper;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashSet;\n+import org.apache.openjpa.meta.MetaDataModes;\n import org.apache.openjpa.meta.MetaDataRepository;\n import org.apache.openjpa.util.GeneralException;\n import org.apache.openjpa.util.InvalidStateException;\n@@ -77,8 +77,7 @@\n public abstract class AbstractBrokerFactory\n     implements BrokerFactory {\n \n-    private static final Localizer _loc = Localizer.forPackage\n-        (AbstractBrokerFactory.class);\n+    private static final Localizer _loc = Localizer.forPackage(AbstractBrokerFactory.class);\n \n     // static mapping of configurations to pooled broker factories\n     private static final Map<Object,AbstractBrokerFactory> _pool = \n@@ -111,7 +110,7 @@\n     private transient Map<Object, Class<?>[]> _lifecycleListeners = null;\n \n     // transaction listeners to pass to each broker\n-    private transient List _transactionListeners = null;\n+    private transient List<Object> _transactionListeners = null;\n \n     // key under which this instance can be stored in the broker pool\n     // and later identified\n@@ -124,7 +123,7 @@\n      *\n      * @since 1.1.0\n      */\n-    protected static Object toPoolKey(Map map) {\n+    protected static Object toPoolKey(Map<String,Object> map) {\n         Object key = Configurations.getProperty(\"Id\", map);\n         return ( key != null) ? key : map;\n     }\n@@ -209,7 +208,7 @@ public Broker newBroker(String user, String pass, boolean managed, int connRetai\n             assertOpen();\n             makeReadOnly();\n \n-            BrokerImpl broker = null;\n+            Broker broker = null;\n             if (findExisting)\n                 broker = findBroker(user, pass, managed);\n             if (broker == null) {\n@@ -224,22 +223,19 @@ public Broker newBroker(String user, String pass, boolean managed, int connRetai\n         }\n     }\n \n-    void initializeBroker(boolean managed, int connRetainMode,\n-        BrokerImpl broker, boolean fromDeserialization) {\n+    void initializeBroker(boolean managed, int connRetainMode, Broker broker, boolean fromDeserialization) {\n         assertOpen();\n         makeReadOnly();\n         \n         DelegatingStoreManager dsm = createDelegatingStoreManager();\n \n-        broker.initialize(this, dsm, managed, connRetainMode,\n-            fromDeserialization);\n+        ((BrokerImpl) broker).initialize(this, dsm, managed, connRetainMode, fromDeserialization);\n         if (!fromDeserialization)\n             addListeners(broker);\n \n         // if we're using remote events, register the event manager so\n         // that it can broadcast commit notifications from the broker\n-        RemoteCommitEventManager remote = _conf.\n-            getRemoteCommitEventManager();\n+        RemoteCommitEventManager remote = _conf.getRemoteCommitEventManager();\n         if (remote.areRemoteEventsEnabled())\n             broker.addTransactionListener(remote);\n \n@@ -251,19 +247,15 @@ void initializeBroker(boolean managed, int connRetainMode,\n     /**\n      * Add factory-registered lifecycle listeners to the broker.\n      */\n-    protected void addListeners(BrokerImpl broker) {\n+    protected void addListeners(Broker broker) {\n         if (_lifecycleListeners != null && !_lifecycleListeners.isEmpty()) {\n-            Map.Entry entry;\n-            for (Iterator itr = _lifecycleListeners.entrySet().iterator();\n-                itr.hasNext();) {\n-                entry = (Map.Entry) itr.next();\n-                broker.addLifecycleListener(entry.getKey(), (Class[])\n-                    entry.getValue());\n+            for (Map.Entry<Object,Class<?>[]> entry : _lifecycleListeners.entrySet()) {\n+                broker.addLifecycleListener(entry.getKey(), entry.getValue());\n             }\n         }\n \n         if (_transactionListeners != null && !_transactionListeners.isEmpty()) {\n-            for (Iterator itr = _transactionListeners.iterator();\n+            for (Iterator<Object> itr = _transactionListeners.iterator();\n                 itr.hasNext(); ) {\n                 broker.addTransactionListener(itr.next());\n             }\n@@ -294,7 +286,7 @@ private void loadPersistentTypes(ClassLoader envLoader) {\n             Collection<Class<?>> clss = _conf.getMetaDataRepositoryInstance().\n                 loadPersistentTypes(false, loader, _conf.isInitializeEagerly());\n             if (clss.isEmpty())\n-                _pcClassNames = Collections.EMPTY_SET;\n+                _pcClassNames = Collections.emptyList();\n             else {\n                 Collection<String> c = new ArrayList<String>(clss.size());\n                 for (Iterator<Class<?>> itr = clss.iterator(); itr.hasNext();) {\n@@ -310,31 +302,28 @@ private void loadPersistentTypes(ClassLoader envLoader) {\n         } else {\n             // reload with this loader\n             if (getPcClassLoaders().add(loader)) {\n-                for (Iterator itr = _pcClassNames.iterator(); itr.hasNext();) {\n+                for (String clsName : _pcClassNames) {\n                     try {\n-                        Class cls =\n-                            Class.forName((String) itr.next(), true, loader);\n+                        Class<?> cls = Class.forName(clsName, true, loader);\n                         if (needsSub(cls))\n                             toRedefine.add(cls);\n                     } catch (Throwable t) {\n-                        _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME)\n-                            .warn(null, t);\n+                        _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME).warn(null, t);\n                     }\n                 }\n             }\n         }\n \n         // get the ManagedClassSubclasser into the loop\n-        ManagedClassSubclasser.prepareUnenhancedClasses(\n-            _conf, toRedefine, envLoader);\n+        ManagedClassSubclasser.prepareUnenhancedClasses(_conf, toRedefine, envLoader);\n     }\n \n-    private boolean needsSub(Class cls) {\n+    private boolean needsSub(Class<?> cls) {\n         return !cls.isInterface()\n             && !PersistenceCapable.class.isAssignableFrom(cls);\n     }\n \n-    public void addLifecycleListener(Object listener, Class[] classes) {\n+    public void addLifecycleListener(Object listener, Class<?>[] classes) {\n         lock();\n         try {\n             assertOpen();\n@@ -362,7 +351,7 @@ public void addTransactionListener(Object listener) {\n         try {\n             assertOpen();\n             if (_transactionListeners == null)\n-                _transactionListeners = new LinkedList();\n+                _transactionListeners = new LinkedList<Object>();\n             _transactionListeners.add(listener);\n         } finally {\n             unlock();\n@@ -405,9 +394,7 @@ public void close() {\n             }\n \n             // close all brokers\n-            Broker broker;\n-            for (Iterator itr = _brokers.iterator(); itr.hasNext();) {\n-                broker = (Broker) itr.next();\n+            for (Broker broker : _brokers) {\n                 // Check for null because _brokers may contain weak references\n                 if ((broker != null) && (!broker.isClosed()))\n                     broker.close();\n@@ -491,14 +478,14 @@ protected Object readResolve()\n             return factory;\n \n         // reset these transient fields to empty values\n-        _transactional = new ConcurrentHashMap();\n+        _transactional = new ConcurrentHashMap<Object,Collection<Broker>>();\n         _brokers = newBrokerSet();\n \n         makeReadOnly();\n         return this;\n     }\n \n-    private Set newBrokerSet() {\n+    private Set<Broker> newBrokerSet() {\n         BrokerValue bv;\n         if (_conf instanceof OpenJPAConfigurationImpl)\n             bv = ((OpenJPAConfigurationImpl) _conf).brokerPlugin;\n@@ -507,11 +494,9 @@ private Set newBrokerSet() {\n \n         if (FinalizingBrokerImpl.class.isAssignableFrom(\n             bv.getTemplateBrokerType(_conf))) {\n-            return MapBackedSet.decorate(new ConcurrentHashMap(),\n-                new Object() { });\n+            return MapBackedSet.decorate(new ConcurrentHashMap(), new Object() { });\n         } else {\n-            return new ConcurrentReferenceHashSet(\n-                ConcurrentReferenceHashSet.WEAK);\n+            return new ConcurrentReferenceHashSet<Broker>(ConcurrentReferenceHashSet.WEAK);\n         }\n     }\n \n@@ -534,7 +519,7 @@ private Set newBrokerSet() {\n      * pooling can return a matching manager before a new {@link StoreManager}\n      * is created.\n      */\n-    protected BrokerImpl findBroker(String user, String pass, boolean managed) {\n+    protected Broker findBroker(String user, String pass, boolean managed) {\n         if (managed)\n             return findTransactionalBroker(user, pass);\n         return null;\n@@ -572,7 +557,7 @@ protected void setup() {\n      * Find a managed runtime broker associated with the\n      * current transaction, or returns null if none.\n      */\n-    protected BrokerImpl findTransactionalBroker(String user, String pass) {\n+    protected Broker findTransactionalBroker(String user, String pass) {\n         Transaction trans;\n         ManagedRuntime mr = _conf.getManagedRuntimeInstance();\n         Object txKey;\n@@ -591,16 +576,13 @@ protected BrokerImpl findTransactionalBroker(String user, String pass) {\n             throw new GeneralException(e);\n         }\n \n-        Collection brokers = (Collection) _transactional.get(txKey);\n+        Collection<Broker> brokers = _transactional.get(txKey);\n         if (brokers != null) {\n             // we don't need to synchronize on brokers since one JTA transaction\n             // can never be active on multiple concurrent threads.\n-            BrokerImpl broker;\n-            for (Iterator itr = brokers.iterator(); itr.hasNext();) {\n-                broker = (BrokerImpl) itr.next();\n-                if (StringUtils.equals(broker.getConnectionUserName(),\n-                    user) && StringUtils.equals\n-                    (broker.getConnectionPassword(), pass))\n+            for (Broker broker : brokers) {\n+                if (StringUtils.equals(broker.getConnectionUserName(), user) \n+                 && StringUtils.equals(broker.getConnectionPassword(), pass))\n                     return broker;\n             }\n         }\n@@ -641,15 +623,13 @@ public void makeReadOnly() {\n             if (log.isInfoEnabled())\n                 log.info(getFactoryInitializationBanner());\n             if (log.isTraceEnabled()) {\n-                Map props = _conf.toProperties(true);\n+                Map<String,Object> props = _conf.toProperties(true);\n                 String lineSep = J2DoPrivHelper.getLineSeparator();\n                 StringBuffer buf = new StringBuffer();\n-                Map.Entry entry;\n-                for (Iterator itr = props.entrySet().iterator();\n-                    itr.hasNext();) {\n-                    entry = (Map.Entry) itr.next();\n-                    buf.append(entry.getKey()).append(\": \").\n-                        append(entry.getValue());\n+                Map.Entry<?,?> entry;\n+                for (Iterator<Map.Entry<String,Object>> itr = props.entrySet().iterator(); itr.hasNext();) {\n+                    entry = itr.next();\n+                    buf.append(entry.getKey()).append(\": \").append(entry.getValue());\n                     if (itr.hasNext())\n                         buf.append(lineSep);\n                 }\n@@ -662,8 +642,8 @@ public void makeReadOnly() {\n             // register the metdata repository to auto-load persistent types\n             // and make sure types are enhanced\n             MetaDataRepository repos = _conf.getMetaDataRepositoryInstance();\n-            repos.setValidate(repos.VALIDATE_RUNTIME, true);\n-            repos.setResolve(repos.MODE_MAPPING_INIT, true);\n+            repos.setValidate(MetaDataRepository.VALIDATE_RUNTIME, true);\n+            repos.setResolve(MetaDataModes.MODE_MAPPING_INIT, true);\n             PCRegistry.addRegisterClassListener(repos);\n \n             // freeze underlying configuration and eagerly initialize to\n@@ -715,24 +695,20 @@ private void assertOpen() {\n      * failed objects in the nested exceptions.\n      */\n     private void assertNoActiveTransaction() {\n-        Collection excs;\n+        Collection<Throwable> excs;\n         if (_transactional.isEmpty())\n             return;\n \n-        excs = new ArrayList(_transactional.size());\n-        for (Iterator trans = _transactional.values().iterator();\n-            trans.hasNext();) {\n-            Collection brokers = (Collection) trans.next();\n-            for (Iterator itr = brokers.iterator(); itr.hasNext();) {\n-                excs.add(new InvalidStateException(_loc.get(\"active\")).\n-                    setFailedObject(itr.next()));\n+        excs = new ArrayList<Throwable>(_transactional.size());\n+        for (Collection<Broker> brokers : _transactional.values()) {\n+            for (Broker broker : brokers) {\n+                excs.add(new InvalidStateException(_loc.get(\"active\")).setFailedObject(broker));\n             }\n         }\n \n         if (!excs.isEmpty())\n             throw new InvalidStateException(_loc.get(\"nested-exceps\")).\n-                setNestedThrowables((Throwable[]) excs.toArray\n-                    (new Throwable[excs.size()]));\n+                setNestedThrowables((Throwable[]) excs.toArray(new Throwable[excs.size()]));\n     }\n \n     /**\n@@ -765,10 +741,10 @@ boolean syncWithManagedTransaction(BrokerImpl broker, boolean begin) {\n             // threads using the same trans since one JTA transaction can never\n             // be active on multiple concurrent threads.\n             Object txKey = mr.getTransactionKey();\n-            Collection brokers = (Collection) _transactional.get(txKey);\n+            Collection<Broker> brokers = _transactional.get(txKey);\n             \n             if (brokers == null) {\n-                brokers = new ArrayList(2);\n+                brokers = new ArrayList<Broker>(2);\n                 _transactional.put(txKey, brokers);\n                 trans.registerSynchronization(new RemoveTransactionSync(txKey));\n             }\n@@ -844,10 +820,9 @@ public void afterCompletion(int status) {\n     /**\n      * Method insures that deserialized EMF has this reference re-instantiated\n      */\n-    private Collection getPcClassLoaders() {\n+    private Collection<ClassLoader> getPcClassLoaders() {\n        if (_pcClassLoaders == null)\n-         _pcClassLoaders = new ConcurrentReferenceHashSet(\n-             ConcurrentReferenceHashSet.WEAK);\n+         _pcClassLoaders = new ConcurrentReferenceHashSet<ClassLoader>(ConcurrentReferenceHashSet.WEAK);\n           \n        return _pcClassLoaders;\n     }"},{"sha":"9c135280e99cabce38888f2c1eafd094ddaa97b0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java?ref=baf800f3b02d6abbd6c3849191511ffdd6b9e0d1","patch":"@@ -20,7 +20,6 @@\n \n import java.io.Serializable;\n import java.util.Map;\n-import java.util.Properties;\n import java.util.Set;\n \n import org.apache.openjpa.conf.OpenJPAConfiguration;\n@@ -83,7 +82,7 @@ public Broker newBroker(String user, String pass, boolean managed,\n      *\n      * @since 0.3.3\n      */\n-    public void addLifecycleListener(Object listener, Class[] classes);\n+    public void addLifecycleListener(Object listener, Class<?>[] classes);\n \n     /**\n      * Remove a listener for lifecycle-related events."},{"sha":"6eaaeb5a2e482e8e24127fb2eaebeb416756a14d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolver.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolver.java","raw_url":"https://github.com/apache/openjpa/raw/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolver.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ClassResolver.java?ref=baf800f3b02d6abbd6c3849191511ffdd6b9e0d1","patch":"@@ -40,6 +40,5 @@\n      * was obtained; may be null if operating outside\n      * the context of persistence environment\n      */\n-    public ClassLoader getClassLoader(Class contextClass,\n-        ClassLoader envLoader);\n+    public ClassLoader getClassLoader(Class<?> contextClass, ClassLoader envLoader);\n }"},{"sha":"708f6a4e788111ce5020f158051585bfff34bc08","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configuration.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configuration.java","raw_url":"https://github.com/apache/openjpa/raw/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configuration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configuration.java?ref=baf800f3b02d6abbd6c3849191511ffdd6b9e0d1","patch":"@@ -173,7 +173,7 @@\n      * @param storeDefaults if true, then properties will be written\n      * out even if they match the default value for a property\n      */\n-    public Map toProperties(boolean storeDefaults);\n+    public Map<String,Object> toProperties(boolean storeDefaults);\n     \n     /**\n      * Get the set of all known property keys, including any equivalent keys,"},{"sha":"d432ffc255b26e410b4f883c6af5f388c1aadc84","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationProvider.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationProvider.java","raw_url":"https://github.com/apache/openjpa/raw/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ConfigurationProvider.java?ref=baf800f3b02d6abbd6c3849191511ffdd6b9e0d1","patch":"@@ -34,13 +34,13 @@\n     /**\n      * Return properties loaded thus far, or empty map if none.\n      */\n-    public Map getProperties();\n+    public Map<String,Object> getProperties();\n \n     /**\n      * Add the given properties to those in this provider, overwriting\n-     * any exisitng properties under the same keys.\n+     * any existing properties under the same keys.\n      */\n-    public void addProperties(Map props);\n+    public void addProperties(Map<?,?> props);\n \n     /**\n      * Add a single property, overwriting any existing property under the"},{"sha":"a62569b9bb2fa9e8f17c8ffdaa1b1128e27c5e31","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","status":"modified","additions":5,"deletions":6,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","raw_url":"https://github.com/apache/openjpa/raw/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java?ref=baf800f3b02d6abbd6c3849191511ffdd6b9e0d1","patch":"@@ -263,9 +263,8 @@ public void testRelations() {\n     }\n \n     public void testEnhancer() throws IOException {\n-        List<Class> subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\n-            emf.getConfiguration(),\n-            Collections.singleton(getUnenhancedClass()), null);\n+        List<Class<?>> subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\n+            emf.getConfiguration(), Collections.singleton(getUnenhancedClass()), null);\n         Class sub = subs.get(0);\n         assertNotNull(sub);\n         assertEquals(\"org.apache.openjpa.enhance.\"\n@@ -588,9 +587,9 @@ private void listenerHelper(boolean userDefined, boolean sub)\n     public void testGetMetaDataOfSubtype() {\n         ClassMetaData meta = JPAFacadeHelper.getMetaData(emf,\n             getUnenhancedClass());\n-        List<Class> subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\n-            emf.getConfiguration(),\n-            Collections.singleton(getUnenhancedClass()), null);\n+        List<Class<?>> subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\n+            emf.getConfiguration(), Collections.singleton(getUnenhancedClass()),\n+            null);\n         assertSame(meta, JPAFacadeHelper.getMetaData(emf, subs.get(0)));\n \n         meta = JPAFacadeHelper.getMetaData(emf, getUnenhancedSubclass());"},{"sha":"4604dcbc408c3ccbad22a8350ad925e0142f4813","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java","raw_url":"https://github.com/apache/openjpa/raw/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java?ref=baf800f3b02d6abbd6c3849191511ffdd6b9e0d1","patch":"@@ -398,7 +398,7 @@ protected int graphSize() {\n     /**\n      * An additional type that must be available in this PC. May be null.\n      */\n-    protected Class getSecondaryType() {\n+    protected Class<?> getSecondaryType() {\n         return null;\n     }\n "},{"sha":"ddca1d3c1985ac3362f6da3bec24e83deb391f23","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","status":"modified","additions":24,"deletions":34,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","raw_url":"https://github.com/apache/openjpa/raw/baf800f3b02d6abbd6c3849191511ffdd6b9e0d1/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java?ref=baf800f3b02d6abbd6c3849191511ffdd6b9e0d1","patch":"@@ -21,8 +21,8 @@\n import java.lang.instrument.ClassFileTransformer;\n import java.lang.instrument.IllegalClassFormatException;\n import java.security.ProtectionDomain;\n-import java.util.BitSet;\n import java.util.Map;\n+\n import javax.persistence.EntityManager;\n import javax.persistence.spi.ClassTransformer;\n import javax.persistence.spi.LoadState;\n@@ -35,18 +35,13 @@\n import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\n import org.apache.openjpa.enhance.PCClassFileTransformer;\n import org.apache.openjpa.enhance.PCEnhancerAgent;\n-import org.apache.openjpa.enhance.PersistenceCapable;\n-import org.apache.openjpa.enhance.StateManager;\n import org.apache.openjpa.kernel.Bootstrap;\n import org.apache.openjpa.kernel.BrokerFactory;\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.lib.conf.Configuration;\n import org.apache.openjpa.lib.conf.ConfigurationProvider;\n import org.apache.openjpa.lib.conf.Configurations;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashSet;\n-import org.apache.openjpa.meta.FieldMetaData;\n import org.apache.openjpa.meta.MetaDataModes;\n import org.apache.openjpa.meta.MetaDataRepository;\n import org.apache.openjpa.persistence.validation.ValidationUtils;\n@@ -66,10 +61,8 @@\n     static final String CLASS_TRANSFORMER_OPTIONS = \"ClassTransformerOptions\";\n     private static final String EMF_POOL = \"EntityManagerFactoryPool\";\n \n-    private static final Localizer _loc = Localizer.forPackage(\n-        PersistenceProviderImpl.class);\n+    private static final Localizer _loc = Localizer.forPackage(PersistenceProviderImpl.class);\n \n-    private static final String _name = PersistenceProviderImpl.class.getName();\n     private Log _log;\n     /**\n      * Loads the entity manager specified by <code>name</code>, applying\n@@ -82,8 +75,7 @@\n      * This does no pooling of EntityManagersFactories.\n      * @return EntityManagerFactory or null\n      */\n-    public OpenJPAEntityManagerFactory createEntityManagerFactory(String name,\n-        String resource, Map m) {\n+    public OpenJPAEntityManagerFactory createEntityManagerFactory(String name, String resource, Map m) {\n         PersistenceProductDerivation pd = new PersistenceProductDerivation();\n         try {\n             Object poolValue = Configurations.removeProperty(EMF_POOL, m);\n@@ -108,9 +100,18 @@ public OpenJPAEntityManagerFactory createEntityManagerFactory(String name,\n             if (_log != null) {\n                 _log.error(_loc.get(\"create-emf-error\", name), e);\n             }\n+            \n             /*\n+             * \n              * Maintain 1.x behavior of throwing exceptions, even though\n-             * JPA2 9.2 - createEMF \"must\" return null for PU it can't handle\n+             * JPA2 9.2 - createEMF \"must\" return null for PU it can't handle.\n+             * \n+             * JPA 2.0 Specification Section 9.2 states:\n+             * \"If a provider does not qualify as the provider for the named persistence unit, \n+             * it must return null when createEntityManagerFactory is invoked on it.\"\n+             * That specification compliance behavior has happened few lines above on null return. \n+             * Throwing runtime exception in the following code is valid (and useful) behavior\n+             * because the qualified provider has encountered an unexpected situation.\n              */\n             throw PersistenceExceptions.toPersistenceException(e);                \n         }\n@@ -135,13 +136,11 @@ private BrokerFactory getBrokerFactory(ConfigurationProvider cp,\n             return Bootstrap.getBrokerFactory(cp, loader);\n     }\n \n-    public OpenJPAEntityManagerFactory createEntityManagerFactory(String name,\n-        Map m) {\n+    public OpenJPAEntityManagerFactory createEntityManagerFactory(String name, Map m) {\n         return createEntityManagerFactory(name, null, m);\n     }\n \n-    public OpenJPAEntityManagerFactory createContainerEntityManagerFactory(\n-        PersistenceUnitInfo pui, Map m) {\n+    public OpenJPAEntityManagerFactory createContainerEntityManagerFactory(PersistenceUnitInfo pui, Map m) {\n         PersistenceProductDerivation pd = new PersistenceProductDerivation();\n         try {\n             Object poolValue = Configurations.removeProperty(EMF_POOL, m);\n@@ -151,8 +150,7 @@ public OpenJPAEntityManagerFactory createContainerEntityManagerFactory(\n \n             // add enhancer\n             Exception transformerException = null;\n-            String ctOpts = (String) Configurations.getProperty\n-                (CLASS_TRANSFORMER_OPTIONS, pui.getProperties());\n+            String ctOpts = (String) Configurations.getProperty(CLASS_TRANSFORMER_OPTIONS, pui.getProperties());\n             try {\n                 pui.addTransformer(new ClassTransformerImpl(cp, ctOpts,\n                     pui.getNewTempClassLoader(), newConfigurationImpl()));\n@@ -164,24 +162,17 @@ public OpenJPAEntityManagerFactory createContainerEntityManagerFactory(\n             // if the BrokerImpl hasn't been specified, switch to the\n             // non-finalizing one, since anything claiming to be a container\n             // should be doing proper resource management.\n-            if (!Configurations.containsProperty(BrokerValue.KEY,\n-                cp.getProperties())) {\n-                cp.addProperty(\"openjpa.\" + BrokerValue.KEY, \n-                    getDefaultBrokerAlias());\n+            if (!Configurations.containsProperty(BrokerValue.KEY, cp.getProperties())) {\n+                cp.addProperty(\"openjpa.\" + BrokerValue.KEY, getDefaultBrokerAlias());\n             }\n \n-            BrokerFactory factory = getBrokerFactory(cp, poolValue,\n-                pui.getClassLoader());\n+            BrokerFactory factory = getBrokerFactory(cp, poolValue, pui.getClassLoader());\n             if (transformerException != null) {\n-                Log log = factory.getConfiguration().getLog(\n-                    OpenJPAConfiguration.LOG_RUNTIME);\n+                Log log = factory.getConfiguration().getLog(OpenJPAConfiguration.LOG_RUNTIME);\n                 if (log.isTraceEnabled()) {\n-                    log.warn(\n-                        _loc.get(\"transformer-registration-error-ex\", pui),\n-                        transformerException);\n+                    log.warn(_loc.get(\"transformer-registration-error-ex\", pui), transformerException);\n                 } else {\n-                    log.warn(\n-                        _loc.get(\"transformer-registration-error\", pui));\n+                    log.warn(_loc.get(\"transformer-registration-error\", pui));\n                 }\n             }\n             \n@@ -234,10 +225,9 @@ protected OpenJPAConfiguration newConfigurationImpl() {\n         private ClassTransformerImpl(ConfigurationProvider cp, String props, \n             final ClassLoader tmpLoader, OpenJPAConfiguration conf) {\n             cp.setInto(conf);\n-            // use the tmp loader for everything\n+            // use the temporary loader for everything\n             conf.setClassResolver(new ClassResolver() {\n-                public ClassLoader getClassLoader(Class context, \n-                    ClassLoader env) {\n+                public ClassLoader getClassLoader(Class<?> context, ClassLoader env) {\n                     return tmpLoader;\n                 }\n             });"}]}

