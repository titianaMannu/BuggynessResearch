{"sha":"bd340fbe15afd807dfed403a005c1d2a02ba1a8d","node_id":"MDY6Q29tbWl0MjA2MzY0OmJkMzQwZmJlMTVhZmQ4MDdkZmVkNDAzYTAwNWMxZDJhMDJiYTFhOGQ=","commit":{"author":{"name":"Stephen Kim","email":"skim@apache.org","date":"2006-09-28T16:34:05Z"},"committer":{"name":"Stephen Kim","email":"skim@apache.org","date":"2006-09-28T16:34:05Z"},"message":"PNewProvisional again.  I think I covered the object graph reflush issue\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@450916 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"2bb2aa798f5365247571f6d3508e43b478dae60f","url":"https://api.github.com/repos/apache/openjpa/git/trees/2bb2aa798f5365247571f6d3508e43b478dae60f"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/bd340fbe15afd807dfed403a005c1d2a02ba1a8d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/bd340fbe15afd807dfed403a005c1d2a02ba1a8d","html_url":"https://github.com/apache/openjpa/commit/bd340fbe15afd807dfed403a005c1d2a02ba1a8d","comments_url":"https://api.github.com/repos/apache/openjpa/commits/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/comments","author":null,"committer":null,"parents":[{"sha":"98d1da1fba419b8c6aec97dacbd4496a367c9b90","url":"https://api.github.com/repos/apache/openjpa/commits/98d1da1fba419b8c6aec97dacbd4496a367c9b90","html_url":"https://github.com/apache/openjpa/commit/98d1da1fba419b8c6aec97dacbd4496a367c9b90"}],"stats":{"total":297,"additions":233,"deletions":64},"files":[{"sha":"dad32ec805c1b695e8c153dedf3da54d35804bac","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedFieldStrategy.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedFieldStrategy.java?ref=bd340fbe15afd807dfed403a005c1d2a02ba1a8d","patch":"@@ -627,6 +627,10 @@ public boolean isFlushedDirty() {\n             return isFlushed();\n         }\n \n+        public boolean isProvisional() {\n+            return _owner.isProvisional();\n+        }\n+\n         public BitSet getLoaded() {\n             // consider everything loaded\n             if (_full == null) {"},{"sha":"5b1eeb690a3f4c3554d84a163eb8a6bd809e7fc8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","status":"modified","additions":5,"deletions":4,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","raw_url":"https://github.com/apache/openjpa/raw/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java?ref=bd340fbe15afd807dfed403a005c1d2a02ba1a8d","patch":"@@ -94,7 +94,7 @@ public Object attach(Object pc) {\n \n         CallbackException excep = null;\n         try {\n-            return attach(pc, null, null, null);\n+            return attach(pc, null, null, null, true);\n         } catch (CallbackException ce) {\n             excep = ce;\n             return null; // won't be reached as the exceps will be rethrown\n@@ -122,7 +122,7 @@ public Object attach(Object pc) {\n             int i = 0;\n             for (Iterator itr = instances.iterator(); itr.hasNext(); i++) {\n                 try {\n-                    attached[i] = attach(itr.next(), null, null, null);\n+                    attached[i] = attach(itr.next(), null, null, null, true);\n                 } catch (OpenJPAException ke) {\n                     // track exceptions and optimistic failed objects\n                     if (opt && !(ke instanceof OptimisticException))\n@@ -212,9 +212,10 @@ private void throwExceptions(List exceps, List failed, boolean opt) {\n      * @param into the instance we're attaching into\n      * @param owner state manager for <code>into</code>\n      * @param ownerMeta the field we traversed to find <code>toAttach</code>\n+     * @param explicit whether to make new instances explicitly persistent\n      */\n     Object attach(Object toAttach, PersistenceCapable into,\n-        OpenJPAStateManager owner, ValueMetaData ownerMeta) {\n+        OpenJPAStateManager owner, ValueMetaData ownerMeta, boolean explicit) {\n         if (toAttach == null)\n             return null;\n \n@@ -233,7 +234,7 @@ Object attach(Object toAttach, PersistenceCapable into,\n             getMetaDataRepositoryInstance().getMetaData(toAttach.getClass(),\n             _broker.getClassLoader(), true);\n         return getStrategy(toAttach).attach(this, toAttach, meta, into,\n-            owner, ownerMeta);\n+            owner, ownerMeta, explicit);\n     }\n \n     /**"},{"sha":"f6dc12fd6f2925dae846657bc49f951f4e43e9e1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java","status":"modified","additions":16,"deletions":10,"changes":26,"blob_url":"https://github.com/apache/openjpa/blob/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java?ref=bd340fbe15afd807dfed403a005c1d2a02ba1a8d","patch":"@@ -55,10 +55,11 @@\n      * @param into instance we're attaching into\n      * @param owner state manager for <code>into</code>\n      * @param ownerMeta field we traversed to find <code>toAttach</code>\n+     * @param explicit whether to make new instances explicitly persistent\n      */\n     public abstract Object attach(AttachManager manager,\n         Object toAttach, ClassMetaData meta, PersistenceCapable into,\n-        OpenJPAStateManager owner, ValueMetaData ownerMeta);\n+        OpenJPAStateManager owner, ValueMetaData ownerMeta, boolean explicit);\n \n     /**\n      * Return the identity of the given detached instance.\n@@ -73,10 +74,12 @@ protected abstract void provideField(Object toAttach, StateManagerImpl sm,\n         int field);\n \n     /**\n-     * Return a PNew managed object for the given detached instance.\n+     * Return a PNew/PNewProvisional managed object for the given detached \n+     * instance.\n      */\n     protected StateManagerImpl persist(AttachManager manager,\n-        PersistenceCapable pc, ClassMetaData meta, Object appId) {\n+        PersistenceCapable pc, ClassMetaData meta, Object appId, \n+        boolean explicit) {\n         PersistenceCapable newInstance;\n         if (!manager.getCopyNew())\n             newInstance = pc;\n@@ -86,7 +89,7 @@ else if (appId == null) // datastore identity\n             newInstance = pc.pcNewInstance(null, appId, false);\n \n         return (StateManagerImpl) manager.getBroker().persist\n-            (newInstance, appId, manager.getBehavior());\n+            (newInstance, appId, explicit, manager.getBehavior());\n     }\n \n     /**\n@@ -191,14 +194,16 @@ protected boolean attachField(AttachManager manager, Object toAttach,\n                             manager.getDetachedObjectId(frmpc))) {\n                             intopc = null;\n                         }\n-                        frmpc = manager.attach(frmpc, intopc, sm, fmd);\n+                        frmpc = manager.attach(frmpc, intopc, sm, fmd, false);\n                     }\n                     if (frmpc != topc)\n                         sm.settingObjectField(into, i, topc, frmpc, set);\n                 }\n                 break;\n             case JavaTypes.COLLECTION:\n                 Collection frmc = (Collection) fetchObjectField(i);\n+                System.out.println(\"Fetch:\" + fmd + \":\" + frmc\n+                    + \":\" + nullLoaded);\n                 if (frmc == null && !nullLoaded)\n                     return false;\n                 Collection toc = (Collection) sm.fetchObjectField(i);\n@@ -320,7 +325,7 @@ protected Collection attachCollection(AttachManager manager,\n             if (vmd.getCascadeAttach() == ValueMetaData.CASCADE_NONE)\n                 elem = getReference(manager, itr.next(), sm, vmd);\n             else\n-                elem = manager.attach(itr.next(), null, sm, vmd);\n+                elem = manager.attach(itr.next(), null, sm, vmd, false);\n             coll.add(elem);\n         }\n         return coll;\n@@ -432,13 +437,13 @@ protected Map attachMap(AttachManager manager, Map orig,\n                 if (keymd.getCascadeAttach() == ValueMetaData.CASCADE_NONE)\n                     key = getReference(manager, key, sm, keymd);\n                 else\n-                    key = manager.attach(key, null, sm, keymd);\n+                    key = manager.attach(key, null, sm, keymd, false);\n                 val = entry.getValue();\n                 if (valmd.isDeclaredTypePC()) {\n                     if (valmd.getCascadeAttach() == ValueMetaData.CASCADE_NONE)\n                         val = getReference(manager, val, sm, valmd);\n                     else\n-                        val = manager.attach(val, null, sm, valmd);\n+                        val = manager.attach(val, null, sm, valmd, false);\n                 }\n                 map.put(key, val);\n             }\n@@ -449,7 +454,8 @@ protected Map attachMap(AttachManager manager, Map orig,\n                 if (valmd.getCascadeAttach() == ValueMetaData.CASCADE_NONE)\n                     val = getReference(manager, entry.getValue(), sm, valmd);\n                 else\n-                    val = manager.attach(entry.getValue(), null, sm, valmd);\n+                    val = manager.attach(entry.getValue(), null, sm, valmd, \n+                        false);\n                 entry.setValue(val);\n             }\n         }\n@@ -479,7 +485,7 @@ private Object replaceArray(AttachManager manager, Object frma,\n                 if (vmd.getCascadeAttach() == ValueMetaData.CASCADE_NONE)\n                     elem = getReference(manager, elem, sm, vmd);\n                 else\n-                    elem = manager.attach(elem, null, sm, vmd);\n+                    elem = manager.attach(elem, null, sm, vmd, false);\n             }\n             diff = diff || !equals(elem, Array.get(toa, i), pc);\n             Array.set(newa, i, elem);"},{"sha":"cbd9a438d68a6f3b070fe10e968d3d24e5ee5463","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":37,"deletions":7,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=bd340fbe15afd807dfed403a005c1d2a02ba1a8d","patch":"@@ -2152,7 +2152,25 @@ protected void endTransaction(int status) {\n     // Object lifecycle\n     ////////////////////\n \n+    public void persist(Object obj, OpCallbacks call) {\n+        persist(obj, null, true, call);\n+    }\n+\n+    public OpenJPAStateManager persist(Object obj, Object id,\n+        OpCallbacks call) {\n+        return persist(obj, id, true, call);\n+    }\n+\n     public void persistAll(Collection objs, OpCallbacks call) {\n+        persistAll(objs, true, call);\n+    }\n+\n+    /**\n+     * Persist the given objects.  Indicate whether this was an explicit persist\n+     * (PNEW) or a provisonal persist (PNEWPROVISIONAL).\n+     */\n+    public void persistAll(Collection objs, boolean explicit, \n+        OpCallbacks call) {\n         if (objs.isEmpty())\n             return;\n \n@@ -2163,7 +2181,7 @@ public void persistAll(Collection objs, OpCallbacks call) {\n \n             for (Iterator itr = objs.iterator(); itr.hasNext();) {\n                 try {\n-                    persist(itr.next(), call);\n+                    persist(itr.next(), explicit, call);\n                 } catch (UserException ue) {\n                     exceps = add(exceps, ue);\n                 }\n@@ -2212,11 +2230,20 @@ private void throwNestedExceptions(List exceps, boolean datastore) {\n         throw err.setNestedThrowables(t).setFatal(fatal);\n     }\n \n-    public void persist(Object obj, OpCallbacks call) {\n-        persist(obj, null, call);\n+    /**\n+     * Persist the given object.  Indicate whether this was an explicit persist\n+     * (PNEW) or a provisonal persist (PNEWPROVISIONAL)\n+     */\n+    public void persist(Object obj, boolean explicit, OpCallbacks call) {\n+        persist(obj, null, explicit, call);\n     }\n \n-    public OpenJPAStateManager persist(Object obj, Object id,\n+    /**\n+     * Persist the given object.  Indicate whether this was an explicit persist\n+     * (PNEW) or a provisonal persist (PNEWPROVISIONAL).\n+     * See {@link Broker} for details on this method.\n+     */\n+    public OpenJPAStateManager persist(Object obj, Object id, boolean explicit,\n         OpCallbacks call) {\n         if (obj == null)\n             return null;\n@@ -2299,9 +2326,12 @@ else if (meta.getIdentityType() == ClassMetaData.ID_UNKNOWN)\n \n             // create new sm\n             sm = new StateManagerImpl(id, meta, this);\n-            if ((_flags & FLAG_ACTIVE) != 0)\n-                sm.initialize(pc, PCState.PNEW);\n-            else\n+            if ((_flags & FLAG_ACTIVE) != 0) {\n+                if (explicit)\n+                    sm.initialize(pc, PCState.PNEW);\n+                else\n+                    sm.initialize(pc, PCState.PNEWPROVISIONAL);\n+            } else\n                 sm.initialize(pc, PCState.PNONTRANSNEW);\n             if ((action & OpCallbacks.ACT_CASCADE) != 0)\n                 sm.cascadePersist(call);"},{"sha":"c9d0cc9ff588b122b046a4b56ea87019d7ddc5d3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java?ref=bd340fbe15afd807dfed403a005c1d2a02ba1a8d","patch":"@@ -70,7 +70,7 @@ protected void provideField(Object toAttach, StateManagerImpl sm,\n \n     public Object attach(AttachManager manager, Object toAttach,\n         ClassMetaData meta, PersistenceCapable into, OpenJPAStateManager owner,\n-        ValueMetaData ownerMeta) {\n+        ValueMetaData ownerMeta, boolean explicit) {\n         BrokerImpl broker = manager.getBroker();\n         PersistenceCapable pc = (PersistenceCapable) toAttach;\n \n@@ -94,7 +94,8 @@ public Object attach(AttachManager manager, Object toAttach,\n             sm = (StateManagerImpl) broker.embed(into, null, owner, ownerMeta);\n             into = sm.getPersistenceCapable();\n         } else if (state == null) {\n-            sm = persist(manager, pc, meta, ApplicationIds.create(pc, meta));\n+            sm = persist(manager, pc, meta, ApplicationIds.create(pc, meta),\n+                explicit);\n             into = sm.getPersistenceCapable();\n         } else if (!embedded && into == null) {\n             Object id = getDetachedObjectId(manager, pc);\n@@ -117,7 +118,7 @@ public Object attach(AttachManager manager, Object toAttach,\n                 // the transaction was rolled back; the danger is that\n                 // the instance was made persistent, detached, committed,\n                 // and then deleted, but this is an uncommon case\n-                sm = persist(manager, pc, meta, id);\n+                sm = persist(manager, pc, meta, id, explicit);\n                 into = sm.getPersistenceCapable();\n \n                 // nullify the state, since the new instance won't have one"},{"sha":"fc1c2acc85528e55178df049aee3c83a8efe0fd4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","status":"modified","additions":7,"deletions":2,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java?ref=bd340fbe15afd807dfed403a005c1d2a02ba1a8d","patch":"@@ -87,7 +87,7 @@ public DetachedStateManager(PersistenceCapable pc, OpenJPAStateManager sm,\n \n     public Object attach(AttachManager manager, Object toAttach,\n         ClassMetaData meta, PersistenceCapable into, OpenJPAStateManager owner,\n-        ValueMetaData ownerMeta) {\n+        ValueMetaData ownerMeta, boolean explicit) {\n         BrokerImpl broker = manager.getBroker();\n         StateManagerImpl sm = null;\n         if (_embedded) {\n@@ -225,7 +225,8 @@ public Object attach(AttachManager manager, Object toAttach,\n                         PersistenceCapable toPC = null;\n                         if (objval != null && fields[i].isEmbeddedPC())\n                             toPC = (PersistenceCapable) objval;\n-                        objval = manager.attach(objval, toPC, sm, fields[i]);\n+                        objval = manager.attach(objval, toPC, sm, fields[i],\n+                            false);\n                     }\n                     if (_dirty.get(i))\n                         sm.settingObjectField(pc, i, (!loaded.get(i)) ? null\n@@ -688,6 +689,10 @@ public boolean isFlushedDirty() {\n         throw new UnsupportedOperationException();\n     }\n \n+    public boolean isProvisional() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n     public BitSet getLoaded() {\n         return _loaded;\n     }"},{"sha":"74615d6f3359616397ef3977b2aaf2f53416e7c6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java?ref=bd340fbe15afd807dfed403a005c1d2a02ba1a8d","patch":"@@ -101,6 +101,10 @@ public boolean isFlushedDirty() {\n         return false;\n     }\n \n+    public boolean isProvisional() {\n+        return false;\n+    }\n+\n     public BitSet getLoaded() {\n         throw new UnsupportedOperationException();\n     }"},{"sha":"ab19a2fd2507c7a0073967f5d6354cabf7801a51","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java?ref=bd340fbe15afd807dfed403a005c1d2a02ba1a8d","patch":"@@ -317,6 +317,10 @@ public boolean isFlushedDirty() {\n         return false;\n     }\n \n+    public boolean isProvisional() {\n+        return false;\n+    }\n+\n     public BitSet getLoaded() {\n         throw new UnsupportedOperationException();\n     }"},{"sha":"6ab1dddf324b7cf69f160eb1d2725d9a8ab4a47f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java?ref=bd340fbe15afd807dfed403a005c1d2a02ba1a8d","patch":"@@ -120,6 +120,11 @@\n      */\n     public boolean isFlushedDirty();\n \n+    /**\n+     * Return whether this object is provisionally persistent.\n+     */\n+    public boolean isProvisional();\n+\n     /**\n      * Return a read-only mask of the indexes of all loaded fields.\n      */"},{"sha":"ca888ee707058ce73c2afa28375b67b8396f8d16","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCState.java","status":"modified","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCState.java","raw_url":"https://github.com/apache/openjpa/raw/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCState.java?ref=bd340fbe15afd807dfed403a005c1d2a02ba1a8d","patch":"@@ -62,6 +62,11 @@\n      */\n     public static final PCState PNEWDELETED = new PNewDeletedState();\n \n+    /**\n+     * Persistent-New-Provisional\n+     */\n+    public static final PCState PNEWPROVISIONAL = new PNewProvisionalState();\n+\n     /**\n      * Persistent-Nontransactinoal\n      */\n@@ -228,6 +233,15 @@ PCState delete(StateManagerImpl context) {\n         return this;\n     }\n \n+    /**\n+     * Return the state to transition to after making no longer provisional. \n+     * The context is not given because no actions should be taken.\n+     */\n+    PCState nonprovisional(StateManagerImpl context, boolean flush, \n+        boolean logical, OpCallbacks call) {\n+        return this;\n+    }\n+\n     /**\n      * Perform any actions necesssary and return the proper lifecycle state\n      * on a call to {@link StoreContext#nontransactional} with the given\n@@ -402,6 +416,15 @@ boolean isPendingTransactional() {\n         return false;\n     }\n \n+    /**\n+     * Return whether this is a state that will become transient\n+     * at the end of the next transaction.\n+     * Returns <code>false</code> by default.\n+     */\n+    boolean isProvisional() {\n+        return false;\n+    }\n+\n     /**\n      * Whether this state requires a version check when being flushed, \n      * assuming the system is configured for version checks.\n@@ -430,6 +453,8 @@ protected Object readResolve()\n             return PDELETED;\n         if (this instanceof PNewDeletedState)\n             return PNEWDELETED;\n+        if (this instanceof PNewProvisionalState)\n+            return PNEWPROVISIONAL;\n         if (this instanceof PNonTransState)\n             return PNONTRANS;\n         if (this instanceof PNonTransDirtyState)"},{"sha":"2e5aa83ce925eb948ddcf1a8013f4120c59b1640","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewProvisionalState.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewProvisionalState.java","raw_url":"https://github.com/apache/openjpa/raw/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewProvisionalState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewProvisionalState.java?ref=bd340fbe15afd807dfed403a005c1d2a02ba1a8d","patch":"@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.kernel;\n+\n+/**\n+ * Lifecycle state.\n+ * Represents an instance that was made persistent via reachability within the\n+ * current\ttransaction.\n+ *\n+ * @author Steve Kim\n+ * @author: Abe White\n+ */\n+class PNewProvisionalState\n+    extends PNewState {\n+\n+    PCState persist(StateManagerImpl context) {\n+        return PNEW;\n+    }\n+\n+    PCState nonprovisional(StateManagerImpl context, boolean flush, \n+        boolean logical, OpCallbacks call) {\n+        if (flush)\n+            beforeFlush(context, logical, call);\n+\n+        return PNEW;\n+    }\n+\n+    PCState commit(StateManagerImpl context) {\n+        return TRANSIENT;\n+    }\n+\n+    PCState commitRetain(StateManagerImpl context) {\n+        return TRANSIENT;\n+    }\n+\n+    boolean isProvisional() {\n+        return true;\n+    }\n+}"},{"sha":"0f790e344409c9973cfcd97be0d27c9792509dfd","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","status":"modified","additions":43,"deletions":33,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java?ref=bd340fbe15afd807dfed403a005c1d2a02ba1a8d","patch":"@@ -250,21 +250,22 @@ public void persist(OpCallbacks call) {\n             case JavaTypes.PC_UNTYPED:\n                 if (!_broker.isDetachedNew() && _broker.isDetached(objval))\n                     return; // allow but ignore\n-                _broker.persist(objval, call);\n+                _broker.persist(objval, false, call);\n                 break;\n             case JavaTypes.ARRAY:\n-                _broker.persistAll(Arrays.asList((Object[]) objval), call);\n+                _broker.persistAll(Arrays.asList((Object[]) objval), false, \n+                    call);\n                 break;\n             case JavaTypes.COLLECTION:\n-                _broker.persistAll((Collection) objval, call);\n+                _broker.persistAll((Collection) objval, false, call);\n                 break;\n             case JavaTypes.MAP:\n                 if (fmd.getKey().getCascadePersist()\n                     == ValueMetaData.CASCADE_IMMEDIATE)\n-                    _broker.persistAll(((Map) objval).keySet(), call);\n+                    _broker.persistAll(((Map) objval).keySet(), false, call);\n                 if (fmd.getElement().getCascadePersist()\n                     == ValueMetaData.CASCADE_IMMEDIATE)\n-                    _broker.persistAll(((Map) objval).values(), call);\n+                    _broker.persistAll(((Map) objval).values(), false, call);\n                 break;\n         }\n     }\n@@ -460,14 +461,14 @@ private void gatherCascadeRefresh(Collection coll, OpCallbacks call) {\n      * pc fields. Return true if the field needs to be replaced with the\n      * new value.\n      */\n-    public boolean preFlush(OpCallbacks call) {\n+    public boolean preFlush(boolean logical, OpCallbacks call) {\n         // only care about object fields\n         FieldMetaData fmd = _sm.getMetaData().getField(field);\n         if (fmd.getDeclaredTypeCode() < JavaTypes.OBJECT)\n             return false;\n \n         // perform pers-by-reach and dependent refs\n-        boolean ret = preFlush(fmd, call);\n+        boolean ret = preFlush(fmd, logical, call);\n \n         // manage inverses\n         InverseManager manager = _broker.getInverseManager();\n@@ -523,7 +524,8 @@ public void serialize(ObjectOutput out, boolean def)\n     /**\n      * Helper method to perform pre flush actions on the current object.\n      */\n-    private boolean preFlush(FieldMetaData fmd, OpCallbacks call) {\n+    private boolean preFlush(FieldMetaData fmd, boolean logical, \n+        OpCallbacks call) {\n         // check for illegal nulls\n         if (objval == null) {\n             if (fmd.getNullValue() == FieldMetaData.NULL_EXCEPTION\n@@ -552,13 +554,13 @@ private boolean preFlush(FieldMetaData fmd, OpCallbacks call) {\n         // check for pcs in field value\n         if (preFlush(fmd, fmd.getDeclaredTypeCode(),\n             fmd.getKey().getDeclaredTypeCode(),\n-            fmd.getElement().getDeclaredTypeCode(), false, call))\n+            fmd.getElement().getDeclaredTypeCode(), false, logical, call))\n             return true;\n \n         // also check for pcs in externalized values\n         if (fmd.isExternalized())\n             preFlush(fmd, fmd.getTypeCode(), fmd.getKey().getTypeCode(),\n-                fmd.getElement().getTypeCode(), true, call);\n+                fmd.getElement().getTypeCode(), true, logical, call);\n         return false;\n     }\n \n@@ -567,7 +569,7 @@ private boolean preFlush(FieldMetaData fmd, OpCallbacks call) {\n      * dependent objects won't be deleted.\n      */\n     private boolean preFlush(FieldMetaData fmd, int type, int keyType,\n-        int elemType, boolean external, OpCallbacks call) {\n+        int elemType, boolean external, boolean logical, OpCallbacks call) {\n         Object val = objval;\n         if (val == null)\n             return false;\n@@ -582,14 +584,14 @@ private boolean preFlush(FieldMetaData fmd, int type, int keyType,\n                     if (external)\n                         val = fmd.getExternalValue(val, _broker);\n                     if (val != null)\n-                        preFlushPC(fmd, val, call);\n+                        preFlushPC(fmd, val, logical, call);\n                 }\n                 break;\n             case JavaTypes.PC_UNTYPED:\n                 if (external)\n                     val = fmd.getExternalValue(val, _broker);\n                 if (val != null)\n-                    preFlushPC(fmd, val, call);\n+                    preFlushPC(fmd, val, logical, call);\n                 break;\n             case JavaTypes.ARRAY:\n                 if (fmd.getElement().isEmbeddedPC())\n@@ -599,7 +601,8 @@ else if (elemType == JavaTypes.PC\n                     if (external)\n                         val = fmd.getExternalValue(val, _broker);\n                     if (val != null)\n-                        preFlushPCs(fmd.getElement(), (Object[]) val, call);\n+                        preFlushPCs(fmd.getElement(), (Object[]) val, logical, \n+                            call);\n                 }\n                 break;\n             case JavaTypes.COLLECTION:\n@@ -616,14 +619,16 @@ else if (val instanceof Proxy) {\n                         // lrs fields\n                         ChangeTracker ct = ((Proxy) val).getChangeTracker();\n                         if (ct != null && ct.isTracking()) {\n-                            preFlushPCs(fmd.getElement(), ct.getAdded(), call);\n+                            preFlushPCs(fmd.getElement(), ct.getAdded(), \n+                                logical, call);\n                             preFlushPCs(fmd.getElement(), ct.getChanged(),\n-                                call);\n+                                logical, call);\n                             flushed = true;\n                         }\n                     }\n                     if (!flushed && val != null)\n-                        preFlushPCs(fmd.getElement(), (Collection) val, call);\n+                        preFlushPCs(fmd.getElement(), (Collection) val, logical,\n+                            call);\n                 }\n                 break;\n             case JavaTypes.MAP:\n@@ -647,13 +652,16 @@ else if (val instanceof Proxy) {\n                             getChangeTracker();\n                         if (ct != null && ct.isTracking() && ct.getTrackKeys())\n                         {\n-                            preFlushPCs(fmd.getKey(), ct.getAdded(), call);\n-                            preFlushPCs(fmd.getKey(), ct.getChanged(), call);\n+                            preFlushPCs(fmd.getKey(), ct.getAdded(), logical,\n+                                call);\n+                            preFlushPCs(fmd.getKey(), ct.getChanged(), logical,\n+                                call);\n                             flushed = true;\n                         }\n                     }\n                     if (!flushed && val != null)\n-                        preFlushPCs(fmd.getKey(), ((Map) val).keySet(), call);\n+                        preFlushPCs(fmd.getKey(), ((Map) val).keySet(), logical,\n+                            call);\n                 }\n \n                 if (!valEmbed && (elemType == JavaTypes.PC\n@@ -669,21 +677,21 @@ else if (val instanceof Proxy) {\n                         if (ct != null && ct.isTracking()) {\n                             if (ct.getTrackKeys()) {\n                                 preFlushPCs(fmd.getElement(), ct.getAdded(),\n-                                    (Map) val, call);\n+                                    (Map) val, logical, call);\n                                 preFlushPCs(fmd.getElement(), ct.getChanged(),\n-                                    (Map) val, call);\n+                                    (Map) val, logical, call);\n                             } else {\n                                 preFlushPCs(fmd.getElement(), ct.getAdded(),\n-                                    call);\n+                                    logical, call);\n                                 preFlushPCs(fmd.getElement(), ct.getChanged(),\n-                                    call);\n+                                    logical, call);\n                             }\n                             flushed = true;\n                         }\n                     }\n                     if (!flushed && val != null)\n                         preFlushPCs(fmd.getElement(), ((Map) val).values(),\n-                            call);\n+                            logical, call);\n                 }\n                 break;\n         }\n@@ -695,35 +703,36 @@ else if (val instanceof Proxy) {\n      * the given keys.\n      */\n     private void preFlushPCs(ValueMetaData vmd, Collection keys, Map map,\n-        OpCallbacks call) {\n+        boolean logical, OpCallbacks call) {\n         for (Iterator itr = keys.iterator(); itr.hasNext();)\n-            preFlushPC(vmd, map.get(itr.next()), call);\n+            preFlushPC(vmd, map.get(itr.next()), logical, call);\n     }\n \n     /**\n      * Make new objects persistent and ref all valid persistent objects in\n      * the given array.\n      */\n     private void preFlushPCs(ValueMetaData vmd, Object[] objs,\n-        OpCallbacks call) {\n+        boolean logical, OpCallbacks call) {\n         for (int i = 0; i < objs.length; i++)\n-            preFlushPC(vmd, objs[i], call);\n+            preFlushPC(vmd, objs[i], logical, call);\n     }\n \n     /**\n      * Make new objects persistent and ref all valid persistent objects in\n      * the given collection.\n      */\n     private void preFlushPCs(ValueMetaData vmd, Collection objs,\n-        OpCallbacks call) {\n+        boolean logical, OpCallbacks call) {\n         for (Iterator itr = objs.iterator(); itr.hasNext();)\n-            preFlushPC(vmd, itr.next(), call);\n+            preFlushPC(vmd, itr.next(), logical, call);\n     }\n \n     /**\n      * Perform pre flush operations on the given object.\n      */\n-    private void preFlushPC(ValueMetaData vmd, Object obj, OpCallbacks call) {\n+    private void preFlushPC(ValueMetaData vmd, Object obj, boolean logical,\n+        OpCallbacks call) {\n         if (obj == null)\n             return;\n \n@@ -740,7 +749,7 @@ private void preFlushPC(ValueMetaData vmd, Object obj, OpCallbacks call) {\n                         Exceptions.toString(_sm.getManagedInstance()))).\n                     setFailedObject(obj);\n         } else\n-            sm = _broker.persist(obj, null, call);\n+            sm = _broker.persist(obj, null, true, call);\n \n         if (sm != null) {\n             // if deleted and not managed inverse, die\n@@ -750,6 +759,7 @@ private void preFlushPC(ValueMetaData vmd, Object obj, OpCallbacks call) {\n                     Exceptions.toString(obj), vmd,\n                     Exceptions.toString(_sm.getManagedInstance()))).\n                     setFailedObject(obj);\n+            ((StateManagerImpl) sm).nonprovisional(true, logical, call);\n             ((StateManagerImpl) sm).setDereferencedDependent(false, true);\n         }\n     }"},{"sha":"4ee44ea087a24070eae4bba43d0ff304b515d332","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"modified","additions":22,"deletions":1,"changes":23,"blob_url":"https://github.com/apache/openjpa/blob/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=bd340fbe15afd807dfed403a005c1d2a02ba1a8d","patch":"@@ -369,6 +369,10 @@ public boolean isFlushedDirty() {\n         return (_flags & FLAG_FLUSHED_DIRTY) > 0;\n     }\n \n+    public boolean wasPreFlushed() {\n+        return (_flags & FLAG_PRE_FLUSHED) > 0;\n+    }\n+\n     public BitSet getLoaded() {\n         return _loaded;\n     }\n@@ -993,6 +997,16 @@ void transactional() {\n         setPCState(_state.transactional(this));\n     }\n \n+    /**\n+     * Delegates to the current state.\n+     *\n+     * @see PCState#nonprovisional\n+     * @see Broker#nonprovisional\n+     */\n+    void nonprovisional(boolean flush, boolean logical, OpCallbacks call) {\n+        setPCState(_state.nonprovisional(this, flush, logical, call));\n+    }\n+\n     /**\n      * Delegates to the current state.\n      *\n@@ -1252,6 +1266,10 @@ public boolean isPendingTransactional() {\n         return _state.isPendingTransactional();\n     }\n \n+    public boolean isProvisional() {\n+        return _state.isProvisional();\n+    }\n+\n     public boolean isPersistent() {\n         return _state.isPersistent();\n     }\n@@ -2619,6 +2637,9 @@ void unproxyFields() {\n      * for all strategies that don't require flushing.\n      */\n     void preFlush(boolean logical, OpCallbacks call) {\n+        if ((_flags & FLAG_PRE_FLUSHED) != 0)\n+            return;\n+\n         if (isPersistent()) {\n             fireLifecycleEvent(LifecycleEvent.BEFORE_STORE);\n             _flags |= FLAG_PRE_FLUSHED;\n@@ -2632,7 +2653,7 @@ void preFlush(boolean logical, OpCallbacks call) {\n                 if ((logical || !assignField(i, true)) && !_flush.get(i)\n                     && _dirty.get(i)) {\n                     provideField(_pc, _single, i);\n-                    if (_single.preFlush(call))\n+                    if (_single.preFlush(logical, call))\n                         replaceField(_pc, _single, i);\n                     else\n                         _single.clear();"},{"sha":"17de89ba7aeb803b9085ccafc59774f47725f936","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","status":"modified","additions":5,"deletions":4,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/bd340fbe15afd807dfed403a005c1d2a02ba1a8d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java?ref=bd340fbe15afd807dfed403a005c1d2a02ba1a8d","patch":"@@ -59,7 +59,7 @@ protected void provideField(Object toAttach, StateManagerImpl sm,\n \n     public Object attach(AttachManager manager, Object toAttach,\n         ClassMetaData meta, PersistenceCapable into, OpenJPAStateManager owner,\n-        ValueMetaData ownerMeta) {\n+        ValueMetaData ownerMeta, boolean explicit) {\n         BrokerImpl broker = manager.getBroker();\n         PersistenceCapable pc = (PersistenceCapable) toAttach;\n \n@@ -82,7 +82,8 @@ public Object attach(AttachManager manager, Object toAttach,\n             sm = (StateManagerImpl) broker.embed(into, null, owner, ownerMeta);\n             into = sm.getPersistenceCapable();\n         } else if (isNew) {\n-            sm = persist(manager, pc, meta, ApplicationIds.create(pc, meta));\n+            sm = persist(manager, pc, meta, ApplicationIds.create(pc, meta),\n+                explicit);\n             into = sm.getPersistenceCapable();\n         } else if (!embedded && into == null) {\n             Object id = getDetachedObjectId(manager, toAttach);\n@@ -235,8 +236,8 @@ private Object attachInPlace(AttachManager manager, StateManagerImpl sm,\n         PersistenceCapable intoPC = (into == null) ? null\n             : into.getPersistenceCapable();\n         if (vmd.isEmbedded())\n-            return manager.attach(pc, intoPC, sm, vmd);\n-        return manager.attach(pc, intoPC, null, null);\n+            return manager.attach(pc, intoPC, sm, vmd, false);\n+        return manager.attach(pc, intoPC, null, null, false);\n     }\n \n     /**"}]}

