{"sha":"be33af366ccef84a8767ceee03e99b171fc9ccff","node_id":"MDY6Q29tbWl0MjA2MzY0OmJlMzNhZjM2NmNjZWY4NGE4NzY3Y2VlZTAzZTk5YjE3MWZjOWNjZmY=","commit":{"author":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2010-02-25T00:11:33Z"},"committer":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2010-02-25T00:11:33Z"},"message":"OPENJPA-1531: Adding support for a interval style syntax in the openjpa.DataCache.EvictionSchedule property. Added code changes, test case, and doc.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@916052 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"bba4348c47442911eb577710a9a0b12a5812a49e","url":"https://api.github.com/repos/apache/openjpa/git/trees/bba4348c47442911eb577710a9a0b12a5812a49e"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/be33af366ccef84a8767ceee03e99b171fc9ccff","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/be33af366ccef84a8767ceee03e99b171fc9ccff","html_url":"https://github.com/apache/openjpa/commit/be33af366ccef84a8767ceee03e99b171fc9ccff","comments_url":"https://api.github.com/repos/apache/openjpa/commits/be33af366ccef84a8767ceee03e99b171fc9ccff/comments","author":null,"committer":null,"parents":[{"sha":"c9e2d17fd561f17e996e993c46682200b4b4cda9","url":"https://api.github.com/repos/apache/openjpa/commits/c9e2d17fd561f17e996e993c46682200b4b4cda9","html_url":"https://github.com/apache/openjpa/commit/c9e2d17fd561f17e996e993c46682200b4b4cda9"}],"stats":{"total":324,"additions":133,"deletions":191},"files":[{"sha":"6bee40660932305e68c1ab700edb0adde85b592c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","status":"modified","additions":48,"deletions":17,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/be33af366ccef84a8767ceee03e99b171fc9ccff/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","raw_url":"https://github.com/apache/openjpa/raw/be33af366ccef84a8767ceee03e99b171fc9ccff/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java?ref=be33af366ccef84a8767ceee03e99b171fc9ccff","patch":"@@ -21,19 +21,23 @@\n import java.security.AccessController;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Calendar;\n import java.util.Date;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n import java.util.StringTokenizer;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.util.J2DoPrivHelper;\n import org.apache.openjpa.lib.util.Localizer;\n-import java.util.concurrent.ConcurrentHashMap;\n import org.apache.openjpa.util.InvalidStateException;\n import org.apache.openjpa.util.UserException;\n+\n import serp.util.Strings;\n \n /**\n@@ -54,7 +58,7 @@\n \n     private Map _caches = new ConcurrentHashMap();\n     private boolean _stop = false;\n-    private int _interval = 2;\n+    private int _interval = 1;\n     private Log _log;\n     private Thread _thread;\n \n@@ -63,14 +67,14 @@ public DataCacheScheduler(OpenJPAConfiguration conf) {\n     }\n \n     /**\n-     * The interval time in minutes between cache checks. Defaults to 2.\n+     * The interval time in minutes between cache checks. Defaults to 1.\n      */\n     public int getInterval() {\n         return _interval;\n     }\n \n     /**\n-     * The interval time in minutes between cache checks. Defaults to 2.\n+     * The interval time in minutes between cache checks. Defaults to 1.\n      */\n     public void setInterval(int interval) {\n         _interval = interval;\n@@ -181,19 +185,46 @@ protected void evict(DataCache cache) {\n         final int[] min;\n \n         public Schedule(String date) {\n-            StringTokenizer token = new StringTokenizer(date, \" \\t\");\n-            if (token.countTokens() != 5)\n-                throw new UserException(_loc.get(\"bad-count\", date)).\n-                    setFatal(true);\n-            try {\n-                min = parse(token.nextToken(), 0, 60);\n-                hour = parse(token.nextToken(), 0, 24);\n-                dayOfMonth = parse(token.nextToken(), 1, 31);\n-                month = parse(token.nextToken(), 1, 13);\n-                dayOfWeek = parse(token.nextToken(), 1, 8);\n-            } catch (Throwable t) {\n-                throw new UserException(_loc.get(\"bad-schedule\", date), t).\n-                    setFatal(true);\n+            int[] tmin = null;\n+            if (date.startsWith(\"+\")) {\n+                Calendar cal = Calendar.getInstance();\n+                int interval = Integer.parseInt(date.substring(1));\n+                int currMin = cal.get(Calendar.MINUTE);\n+                \n+                tmin = new int[60/interval];\n+                for(int i = 0; i<tmin.length;i++){\n+                    int temp;\n+                    if(i==0){\n+                        temp=currMin+interval;\n+                    }else{\n+                        temp=tmin[i-1]+interval;\n+                    }\n+                    if(temp >= 60 ){\n+                        temp -= 60;\n+                    }\n+                    tmin[i]=temp;\n+                }\n+                Arrays.sort(tmin);\n+\n+                min = tmin;\n+                hour = WILDCARD;\n+                dayOfMonth = WILDCARD;\n+                month = WILDCARD;\n+                dayOfWeek = WILDCARD;\n+            }else{\n+            \n+                StringTokenizer token = new StringTokenizer(date, \" \\t\");\n+                if (token.countTokens() != 5)\n+                    throw new UserException(_loc.get(\"bad-count\", date)).setFatal(true);\n+                try {\n+                    min = parse(token.nextToken(), 0, 60);\n+                    hour = parse(token.nextToken(), 0, 24);\n+                    dayOfMonth = parse(token.nextToken(), 1, 31);\n+                    month = parse(token.nextToken(), 1, 13);\n+                    dayOfWeek = parse(token.nextToken(), 1, 8);\n+                } catch (Throwable t) {\n+                    throw new UserException(_loc.get(\"bad-schedule\", date), t).setFatal(true);\n+                }\n             }\n         }\n "},{"sha":"718fb25056572a74a9e4d2983930b99743f322cd","filename":"openjpa-persistence-jdbc/pom.xml","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/be33af366ccef84a8767ceee03e99b171fc9ccff/openjpa-persistence-jdbc/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/be33af366ccef84a8767ceee03e99b171fc9ccff/openjpa-persistence-jdbc/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/pom.xml?ref=be33af366ccef84a8767ceee03e99b171fc9ccff","patch":"@@ -809,7 +809,6 @@\n                         <exclude>org/apache/openjpa/persistence/conf/TestOpenJPAConfiguration.java</exclude>\n                         <exclude>org/apache/openjpa/persistence/datacache/TestCacheMultiThreadedLoad.java</exclude>\n                         <exclude>org/apache/openjpa/persistence/datacache/TestConcurrentDataCache.java</exclude>\n-                        <exclude>org/apache/openjpa/persistence/datacache/TestDataCacheScheduler.java</exclude>\n                         <exclude>org/apache/openjpa/persistence/datacache/TestDistributedKodoDataCache.java</exclude>\n                         <exclude>org/apache/openjpa/persistence/datacache/TestFlushDataCache.java</exclude>\n                         <exclude>org/apache/openjpa/persistence/datacache/TestJPQL2Queries.java</exclude>"},{"sha":"16b609c5e833445b8377199eb11226b9b7a6ff80","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheScheduler.java","status":"modified","additions":70,"deletions":172,"changes":242,"blob_url":"https://github.com/apache/openjpa/blob/be33af366ccef84a8767ceee03e99b171fc9ccff/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheScheduler.java","raw_url":"https://github.com/apache/openjpa/raw/be33af366ccef84a8767ceee03e99b171fc9ccff/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheScheduler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheScheduler.java?ref=be33af366ccef84a8767ceee03e99b171fc9ccff","patch":"@@ -20,33 +20,17 @@\n \n import java.util.Calendar;\n import java.util.Date;\n-import java.util.HashMap;\n-import java.util.Map;\n \n-\n-import org.apache.openjpa.persistence.datacache.common.apps.ScheduledEviction;\n-import org.apache.openjpa.persistence.common.utils.AbstractTestCase;\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n-import org.apache.openjpa.datacache.DataCache;\n-import org.apache.openjpa.datacache.DataCacheScheduler;\n import org.apache.openjpa.datacache.ConcurrentDataCache;\n-import org.apache.openjpa.persistence.JPAFacadeHelper;\n-import org.apache.openjpa.persistence.OpenJPAEntityManager;\n-import org.apache.openjpa.persistence.OpenJPAEntityManagerFactory;\n-import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n-import org.apache.openjpa.persistence.OpenJPAPersistence;\n-import org.apache.openjpa.util.Id;\n-\n-public class TestDataCacheScheduler\n-    extends AbstractTestCase {\n-\n-    private static final String MINUTES = getMinutes();\n+import org.apache.openjpa.datacache.DataCacheScheduler;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerSPI;\n+import org.apache.openjpa.persistence.datacache.common.apps.ScheduledEviction;\n+import org.apache.openjpa.persistence.test.SingleEMTestCase;\n \n-    public TestDataCacheScheduler(String str) {\n-        super(str, \"datacachecactusapp\");\n-    }\n+public class TestDataCacheScheduler extends SingleEMTestCase {\n \n-    private static String getMinutes() {\n+    private static String getMinutesString() {\n         StringBuffer buf = new StringBuffer();\n         for (int i = 0; i < 60; i++) {\n             if (i % 2 == 0)\n@@ -56,172 +40,86 @@ private static String getMinutes() {\n     }\n \n     public void setUp() {\n-        deleteAll(ScheduledEviction.class);\n-    }\n-\n-    public void testRuntime()\n-        throws Exception {\n-        String sched = MINUTES + \" * * * *\";\n-        Map propsMap = new HashMap();\n-        propsMap.put(\"openjpa.DataCache\", \"true(EvictionSchedule=\\\"\" + sched\n-                + \"\\\")\");\n-        propsMap.put(\"openjpa.RemoteCommitProvider\", \"sjvm\");\n-        propsMap.put(\"openjpa.FlushBeforeQueries\", \"true\");\n-        propsMap.put(\"openjpa.BrokerImpl\", CacheTestBroker.class.getName());\n-        OpenJPAEntityManagerFactory emf =\n-            (OpenJPAEntityManagerFactory) getEmf(propsMap);\n-\n-        ((OpenJPAEntityManagerFactorySPI) OpenJPAPersistence.cast(emf))\n-            .getConfiguration().getDataCacheManagerInstance()\n-            .getDataCacheScheduler().setInterval(1);\n-        DataCache cache = JPAFacadeHelper.getMetaData(emf,\n-            ScheduledEviction.class).getDataCache();\n-\n-        OpenJPAEntityManager em = (OpenJPAEntityManager) emf\n-            .createEntityManager();\n-        startTx(em);\n-        ScheduledEviction pc = new ScheduledEviction(\"Foo\");\n-        em.persist(pc);\n-        Object oid = em.getObjectId(pc);\n-        Object oidwithclass = new Id(ScheduledEviction.class, oid.toString());\n-        endTx(em);\n-        endEm(em);\n-\n-        cache.clear();// clear and wait until next run.\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        if (cal.get(Calendar.MINUTE) % 2 == 0)\n-            Thread.currentThread().sleep\n-                ((60 - cal.get(Calendar.SECOND)) * 1000);\n-        cal.setTime(new Date());\n-        assertTrue(cal.get(Calendar.MINUTE) % 2 == 1);\n-        em = (OpenJPAEntityManager) emf.createEntityManager();\n-        em.find(ScheduledEviction.class, oid);\n-        endEm(em);\n-        assertTrue(cache.contains(oidwithclass));\n-\n-        Thread.currentThread().sleep(130 * 1000);\n-        assertFalse(cache.contains(oidwithclass));\n-        emf.close();\n+        setUp(ScheduledEviction.class, CLEAR_TABLES\n+            );\n     }\n \n-    /**\n-     * too slow ! *\n-     */\n-    //FIXME Seetha Sep 26,2006\n-    /*public void XXXtestRunnable()\n-        throws Exception {\n-        KodoPersistenceManager pm = getPM();\n-        OpenJPAConfiguration conf = pm.getConfiguration();\n+    public void testBasic() throws Exception {\n+        OpenJPAConfiguration conf = ((OpenJPAEntityManagerSPI) em).getConfiguration();\n         DataCacheScheduler scheduler = new DataCacheScheduler(conf);\n+        // Make the scheduler run every 1 minute\n         scheduler.setInterval(1);\n+        DummyCache cache1 = new DummyCache();\n+        DummyCache cache2 = new DummyCache();\n \n         Calendar cal = Calendar.getInstance();\n         cal.setTime(new Date());\n-        int minute = (cal.get(Calendar.MINUTE) + 2) % 60;\n-        StringBuffer sched = new StringBuffer();\n-        sched.append(minute).append(' ');\n-        sched.append(\"* \");\n-        sched.append(\"* \");\n-        sched.append(\"* \");\n-        sched.append(\"* \");\n-        DummyCache cache = new DummyCache();\n-        scheduler.scheduleEviction(cache, sched.toString());\n-\n-        Thread thread = new Thread(scheduler);\n-        thread.setDaemon(true);\n-        thread.start();\n-        // test that it did not run yet...\n-        Thread.currentThread().sleep(90 * 1000); // 90 seconds\n-        assertEquals(0, cache.clearCount);\n-        // test that it ran...\n-        Thread.currentThread().sleep(45 * 1000); // 45 seconds\n-        assertEquals(1, cache.clearCount);\n-        // test that it wasn't too eager\n-        Thread.currentThread().sleep(50 * 1000); // 90 seconds\n-        assertEquals(1, cache.clearCount);\n-        scheduler.stop();\n-    }*/\n-\n-    /**\n-     * too slow *\n-     */\n-    /* public void XXXtestMonth()\n-        throws Exception {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        int month = cal.get(Calendar.MONTH);\n-        int month2 = month + 1;\n-        if (month2 > 12)\n-            month2 = 1;\n-        doTest(\"* * \" + month + \" *\", \"* * \" + month2 + \" *\");\n-    }*/\n-\n-    /**\n-     * too slow *\n-     */\n-    /* public void XXXtestDayOfMonth()\n-        throws Exception {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        int dom = cal.get(Calendar.DAY_OF_MONTH);\n-        doTest(\"* \" + dom + \" * *\", \"* \" + (dom % 12 + 1) + \" * *\");\n-    }*/\n-    public void testDayOfWeek()\n-        throws Exception {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        int day = cal.get(Calendar.DAY_OF_WEEK);\n-        doTest(\"* * * \" + day, \"* * * \" + (day % 7 + 1));\n-    }\n-\n-    public void testHour()\n-        throws Exception {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        int hour = cal.get(Calendar.HOUR_OF_DAY);\n-        doTest(hour + \" * * *\", ((hour + 1) % 24) + \" * * *\");\n+        int currMin = cal.get(Calendar.MINUTE);\n+        int plusOne = currMin+1;\n+        int plusTwo = plusOne+1;\n+        if(plusOne>=60){\n+            plusOne-=60;\n+        }\n+        if(plusTwo>=60){\n+            plusTwo-=60;\n+        }\n+        // Schedule eviction to happen the next two minutes\n+        scheduler.scheduleEviction(cache2, plusOne+\",\"+plusTwo+\" * * * *\");\n+\n+        // Schedule eviction to happen every mintue on cache 1\n+        scheduler.scheduleEviction(cache1, (\"+1\"));\n+        \n+        Thread.currentThread().sleep(61000);\n+        assertEquals(1,cache1.getClearCount());\n+        assertEquals(1,cache2.getClearCount());\n+        \n+        Thread.currentThread().sleep(60000);\n+        assertEquals(2,cache1.getClearCount());\n+        assertEquals(2,cache2.getClearCount());\n+        \n+        Thread.currentThread().sleep(60000);\n+        assertEquals(3,cache1.getClearCount());\n+        assertEquals(2,cache2.getClearCount());\n     }\n \n     /**\n      * Pass in 4 out of 5 tokens.\n      */\n-    private void doTest(String valid, String invalid)\n-        throws Exception {\n-\n-        OpenJPAEntityManagerFactory emf =\n-            (OpenJPAEntityManagerFactory) getEmf();\n-        OpenJPAConfiguration conf =\n-            ((OpenJPAEntityManagerFactorySPI) OpenJPAPersistence.cast(emf))\n-                .getConfiguration();\n-\n-        DataCacheScheduler scheduler = new DataCacheScheduler(conf);\n-        scheduler.setInterval(1);\n-\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        String sched = ((cal.get(Calendar.MINUTE) + 1) % 60) + \" \";\n-        DummyCache validCache = new DummyCache();\n-        scheduler.scheduleEviction(validCache, sched + valid);\n-        DummyCache invalidCache = new DummyCache();\n-        scheduler.scheduleEviction(invalidCache, sched + invalid);\n-        Thread thread = new Thread(scheduler);\n-        thread.setDaemon(true);\n-        thread.start();\n-        // test that it did not run yet...\n-        Thread.currentThread().sleep(70 * 1000); // 70 seconds\n-        scheduler.stop();\n-//        assertEquals(2, validCache.clearCount);\n-        assertTrue(\"Wrong invocation count: \" + validCache.clearCount,\n-            validCache.clearCount == 1 || validCache.clearCount == 2);\n-        assertEquals(0, invalidCache.clearCount);\n-    }\n-\n+    // private void doTest(String valid, String invalid) throws Exception {\n+    //\n+    // OpenJPAEntityManagerFactory emf = (OpenJPAEntityManagerFactory) getEmf();\n+    // OpenJPAConfiguration conf = ((OpenJPAEntityManagerFactorySPI)\n+    // OpenJPAPersistence.cast(emf)).getConfiguration();\n+    //\n+    // DataCacheScheduler scheduler = new DataCacheScheduler(conf);\n+    // scheduler.setInterval(1);\n+    //\n+    // Calendar cal = Calendar.getInstance();\n+    // cal.setTime(new Date());\n+    // String sched = ((cal.get(Calendar.MINUTE) + 1) % 60) + \" \";\n+    // DummyCache validCache = new DummyCache();\n+    // scheduler.scheduleEviction(validCache, sched + valid);\n+    // DummyCache invalidCache = new DummyCache();\n+    // scheduler.scheduleEviction(invalidCache, sched + invalid);\n+    // Thread thread = new Thread(scheduler);\n+    // thread.setDaemon(true);\n+    // thread.start();\n+    // // test that it did not run yet...\n+    // Thread.currentThread().sleep(70 * 1000); // 70 seconds\n+    // scheduler.stop();\n+    // // assertEquals(2, validCache.clearCount);\n+    // assertTrue(\"Wrong invocation count: \" + validCache.clearCount, validCache.clearCount == 1\n+    // || validCache.clearCount == 2);\n+    // assertEquals(0, invalidCache.clearCount);\n+    // }\n     private class DummyCache extends ConcurrentDataCache {\n \n         int clearCount = 0;\n \n-        public void clear() {\n+        public synchronized int getClearCount(){\n+            return clearCount;\n+        }\n+        public synchronized void clear() {\n             clearCount++;\n         }\n     }"},{"sha":"cad4b83a3e554ef6c2fda87acf67fba2294a52ad","filename":"openjpa-project/src/doc/manual/ref_guide_caching.xml","status":"modified","additions":15,"deletions":1,"changes":16,"blob_url":"https://github.com/apache/openjpa/blob/be33af366ccef84a8767ceee03e99b171fc9ccff/openjpa-project/src/doc/manual/ref_guide_caching.xml","raw_url":"https://github.com/apache/openjpa/raw/be33af366ccef84a8767ceee03e99b171fc9ccff/openjpa-project/src/doc/manual/ref_guide_caching.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_caching.xml?ref=be33af366ccef84a8767ceee03e99b171fc9ccff","patch":"@@ -277,7 +277,7 @@ for more information on the <classname>DataCache</classname> annotation.\n             </indexterm>\n A cache can specify that it should be cleared at certain times rather than using\n data timeouts. The <literal>EvictionSchedule</literal> property of OpenJPA's\n-cache implementation accepts a <literal>cron</literal> style eviction schedule.\n+cache implementation can be input in two different formats. The first is a <literal>cron</literal> style eviction schedule.\n The format of this property is a whitespace-separated list of five tokens, where\n the <literal>*</literal> symbol (asterisk), indicates match all. The tokens are,\n in order:\n@@ -317,6 +317,20 @@ past 3 PM on Sunday.\n <programlisting>\n true(EvictionSchedule='15,45 15 * * 1')\n </programlisting>\n+            <para>\n+The second format for this property is an interval style eviction schedule. The \n+format of this property is a <literal>+</literal> followed by the number of minutes \n+between each time that the cache should be evicted.\n+            </para>\n+            <para>            \n+For example, the following openjpa.DataCache setting schedules the default cache \n+to evict values from the cache every 120 minutes.            \n+            </para>\n+            <para>            \n+<programlisting>\n+true(EvictionSchedule='+120')\n+</programlisting>\n+            </para>\n <section id=\"ref_guide_cache_distribution\">\n    <title>Distributing instances across cache partitions</title>\n             <para>"}]}

