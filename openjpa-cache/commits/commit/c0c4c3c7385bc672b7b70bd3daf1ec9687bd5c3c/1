{"sha":"c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c","node_id":"MDY6Q29tbWl0MjA2MzY0OmMwYzRjM2M3Mzg1YmM2NzJiN2I3MGJkM2RhZjFlYzk2ODdiZDVjM2M=","commit":{"author":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-10-06T01:04:34Z"},"committer":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-10-06T01:04:34Z"},"message":"Fixes relating to multiple same-typed embedded fields loading eager relations,\nand deep vertical inheritance hierarchies where the base class's primary key \nis auto-assigned on insert.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@453449 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"434958622907bff5009283d3bfcf10951ef0fec3","url":"https://api.github.com/repos/apache/openjpa/git/trees/434958622907bff5009283d3bfcf10951ef0fec3"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c","html_url":"https://github.com/apache/openjpa/commit/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c","comments_url":"https://api.github.com/repos/apache/openjpa/commits/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/comments","author":null,"committer":null,"parents":[{"sha":"1dbb7a90440054478141cf8dfb699529c52e847d","url":"https://api.github.com/repos/apache/openjpa/commits/1dbb7a90440054478141cf8dfb699529c52e847d","html_url":"https://github.com/apache/openjpa/commit/1dbb7a90440054478141cf8dfb699529c52e847d"}],"stats":{"total":229,"additions":151,"deletions":78},"files":[{"sha":"96095ecaad395c3906123c716cdad0e18b38077f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java?ref=c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c","patch":"@@ -931,7 +931,7 @@ private FieldMapping createEagerSelects(Select sel, ClassMapping mapping,\n                 && sel.eagerClone(fms[i], jtype, false, 1) != null)\n                 continue;\n \n-            boolean hasJoin = fetch.hasJoin(fms[i].getFullName());\n+            boolean hasJoin = fetch.hasJoin(fms[i].getFullName(false));\n \n             // if the field declares a preferred select mode of join or does not\n             // have a preferred mode and we're doing a by-id lookup, try"},{"sha":"b8df85696f0343693333ea92d51bb5abce2d99dc","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/PropertiesReverseCustomizer.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/PropertiesReverseCustomizer.java","raw_url":"https://github.com/apache/openjpa/raw/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/PropertiesReverseCustomizer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/PropertiesReverseCustomizer.java?ref=c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c","patch":"@@ -156,7 +156,7 @@ public String getClassCode(ClassMapping mapping) {\n     }\n \n     public void customize(FieldMapping field) {\n-        String type = getProperty(field.getFullName() + \".type\");\n+        String type = getProperty(field.getFullName(false) + \".type\");\n         if (type != null)\n             field.setDeclaredType(Strings.toClass(type, null));\n     }\n@@ -195,7 +195,7 @@ public String getFieldName(ClassMapping dec, Column[] cols, ForeignKey fk,\n     }\n \n     public String getInitialValue(FieldMapping field) {\n-        return getProperty(field.getFullName() + \".value\");\n+        return getProperty(field.getFullName(false) + \".value\");\n     }\n \n     public String getDeclaration(FieldMapping field) {"},{"sha":"4e2fe32c196e54a8924035e776e341ea5db5ed78","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","status":"modified","additions":52,"deletions":12,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","raw_url":"https://github.com/apache/openjpa/raw/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java?ref=c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c","patch":"@@ -16,6 +16,7 @@\n package org.apache.openjpa.jdbc.schema;\n \n import java.sql.DatabaseMetaData;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n \n@@ -161,24 +162,59 @@ public boolean isLogical() {\n     }\n \n     /**\n-     * Whether the primary key columns of this key are auto-incrementing.\n+     * Whether the primary key columns of this key are auto-incrementing, or\n+     * whether they themselves are members of a foreign key who's primary key\n+     * is auto-incrementing (recursing to arbitrary depth).\n      */\n     public boolean isPrimaryKeyAutoAssigned() {\n-        if (_autoAssign == null) {\n-            Column[] cols = getPrimaryKeyColumns();\n-            if (cols.length == 0)\n-                return false;\n+        if (_autoAssign != null)\n+            return _autoAssign.booleanValue();\n+        return isPrimaryKeyAutoAssigned(new ArrayList(3));\n+    }\n+\n+    /**\n+     * Helper to calculate whether this foreign key depends on auto-assigned \n+     * columns.  Recurses appropriately if the primary key columns this key\n+     * joins to are themselves members of a foreign key that is dependent on\n+     * auto-assigned columns.  Caches calculated auto-assign value as a side \n+     * effect.\n+     *\n+     * @param seen track seen foreign keys to prevent infinite recursion in\n+     * the case of foreign key cycles\n+     */\n+    private boolean isPrimaryKeyAutoAssigned(List seen) {\n+        if (_autoAssign != null) \n+            return _autoAssign.booleanValue();\n \n-            boolean auto = false;\n-            for (int i = 0; i < cols.length; i++) {\n-                if (cols[i].isAutoAssigned()) {\n-                    auto = true;\n-                    break;\n+        Column[] cols = getPrimaryKeyColumns();\n+        if (cols.length == 0) {\n+            _autoAssign = Boolean.FALSE;\n+            return false;\n+        }\n+\n+        for (int i = 0; i < cols.length; i++) {\n+            if (cols[i].isAutoAssigned()) {\n+                _autoAssign = Boolean.TRUE;\n+                return true;\n+            }\n+        }\n+\n+        ForeignKey[] fks = _pkTable.getForeignKeys();\n+        seen.add(this);\n+        for (int i = 0; i < cols.length; i++) {\n+            for (int j = 0; j < fks.length; j++) {\n+                if (fks[j].getPrimaryKeyColumn(cols[i]) == null)\n+                    continue;\n+                if (!seen.contains(fks[j])\n+                    && fks[j].isPrimaryKeyAutoAssigned(seen)) {\n+                    _autoAssign = Boolean.TRUE;\n+                    return true;\n                 }\n             }\n-            _autoAssign = (auto) ? Boolean.TRUE : Boolean.FALSE;\n         }\n-        return _autoAssign.booleanValue();\n+\n+        _autoAssign = Boolean.FALSE;\n+        return false;\n     }\n \n     /**\n@@ -498,6 +534,8 @@ public void join(Column local, Column toPK) {\n         // force re-cache\n         _locals = null;\n         _pks = null;\n+        if (_autoAssign == Boolean.FALSE)\n+            _autoAssign = null;\n     }\n \n     /**\n@@ -583,6 +621,8 @@ public boolean removeJoin(Column col) {\n         if ((_joins == null || _joins.isEmpty())\n             && (_constsPK == null || _constsPK.isEmpty()))\n             _pkTable = null;\n+        if (remd && _autoAssign == Boolean.TRUE)\n+            _autoAssign = null;\n         return remd;\n     }\n "},{"sha":"b505c11fd8bf8529cbfba0523e297da19b3b53a4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java?ref=c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c","patch":"@@ -524,7 +524,7 @@ public FetchConfiguration traverse(FieldMetaData fm) {\n         FetchConfigurationImpl clone = newInstance(_state);\n         clone._parent = this;\n         clone._availableDepth = reduce(_availableDepth);\n-        clone._fromField = fm.getFullName();\n+        clone._fromField = fm.getFullName(false);\n         clone._fromType = type;\n         clone._availableRecursion = getAvailableRecursionDepth(fm, type, true);\n         return clone;\n@@ -537,7 +537,7 @@ private boolean includes(FieldMetaData fmd) {\n         if ((fmd.isInDefaultFetchGroup() \n             && hasFetchGroup(FetchGroup.NAME_DEFAULT))\n             || hasFetchGroup(FetchGroup.NAME_ALL)\n-            || hasField(fmd.getFullName()))\n+            || hasField(fmd.getFullName(false)))\n             return true;\n         String[] fgs = fmd.getCustomFetchGroups();\n         for (int i = 0; i < fgs.length; i++)"},{"sha":"9ae6641385cb7841b88cb572fe244c6e418be60e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","raw_url":"https://github.com/apache/openjpa/raw/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java?ref=c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c","patch":"@@ -442,12 +442,12 @@ protected Expression evalFetchJoins(QueryExpressions exps) {\n         JPQLNode[] outers = root().findChildrenByID(JJTOUTERFETCHJOIN);\n         for (int i = 0; outers != null && i < outers.length; i++)\n             (joins == null ? joins = new TreeSet() : joins).\n-                add(getPath(onlyChild(outers[i])).last().getFullName());\n+                add(getPath(onlyChild(outers[i])).last().getFullName(false));\n \n         JPQLNode[] inners = root().findChildrenByID(JJTINNERFETCHJOIN);\n         for (int i = 0; inners != null && i < inners.length; i++)\n             (joins == null ? joins = new TreeSet() : joins).\n-                add(getPath(onlyChild(inners[i])).last().getFullName());\n+                add(getPath(onlyChild(inners[i])).last().getFullName(false));\n \n         if (joins != null)\n             exps.fetchPaths = (String[]) joins."},{"sha":"7b9e100cbc421f50662da129a5368874e1b7a525","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java?ref=c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c","patch":"@@ -2327,7 +2327,8 @@ public int compare(Object o1, Object o2) {\n             FieldMetaData f2 = (FieldMetaData) o2;\n             if (f1.getListingIndex() == f2.getListingIndex()) {\n                 if (f1.getIndex() == f2.getIndex())\n-                    return f1.getFullName ().compareTo (f2.getFullName ());\n+                    return f1.getFullName(false).compareTo\n+                        (f2.getFullName(false));\n \t\t\t\tif (f1.getIndex () == -1)\n \t\t\t\t\treturn 1;\n \t\t\t\tif (f2.getIndex () == -1)"},{"sha":"aa0ab3d12f18b9664a0ea98a21bec1c2382596cc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","status":"modified","additions":19,"deletions":8,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java?ref=c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c","patch":"@@ -127,6 +127,7 @@\n     private Class _dec = null;\n     private ClassMetaData _decMeta = null;\n     private String _fullName = null;\n+    private String _embedFullName = null;\n     private int _resMode = MODE_NONE;\n \n     // load/store info\n@@ -275,6 +276,7 @@ public void setDeclaringType(Class cls) {\n         _dec = cls;\n         _decMeta = null;\n         _fullName = null;\n+        _embedFullName = null;\n     }\n \n     /**\n@@ -297,12 +299,20 @@ public String getName() {\n     }\n \n     /**\n-     * The field name, qualified by the owning class.\n+     * The field name, qualified by the owning class and optionally the\n+     * embedding owner's name (if any).\n      */\n-    public String getFullName() {\n+    public String getFullName(boolean embedOwner) {\n         if (_fullName == null)\n             _fullName = getDeclaringType().getName() + \".\" + _name;\n-        return _fullName;\n+        if (embedOwner && _embedFullName == null) {\n+            if (_owner.getEmbeddingMetaData() == null)\n+                _embedFullName = _fullName;\n+            else\n+                _embedFullName = _owner.getEmbeddingMetaData().\n+                    getFieldMetaData().getFullName(true) + \".\" + _fullName;\n+        }\n+        return (embedOwner) ? _embedFullName : _fullName;\n     }\n \n     /**\n@@ -1433,26 +1443,27 @@ private static boolean isStoreContextParameter(Class type) {\n     }\n \n     public int hashCode() {\n-        return getFullName().hashCode();\n+        return getFullName(true).hashCode();\n     }\n \n     public boolean equals(Object other) {\n         if (other == this)\n             return true;\n         if (!(other instanceof FieldMetaData))\n             return false;\n-        return getFullName().equals(((FieldMetaData) other).getFullName());\n+        return getFullName(true).equals(((FieldMetaData) other).\n+            getFullName(true));\n     }\n \n     public int compareTo(Object other) {\n         if (other == null)\n             return 1;\n-        return getFullName().compareTo(((FieldMetaData) other).\n-            getFullName());\n+        return getFullName(true).compareTo(((FieldMetaData) other).\n+            getFullName(true));\n     }\n \n     public String toString() {\n-        return getFullName();\n+        return getFullName(true);\n     }\n \n     ////////////////////////"},{"sha":"12a25ebe94f70fbd38b88f463eaa217b3cccb43c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaDataImpl.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaDataImpl.java","raw_url":"https://github.com/apache/openjpa/raw/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaDataImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ValueMetaDataImpl.java?ref=c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c","patch":"@@ -316,7 +316,7 @@ public void setTypeOverride(Class val) {\n     }\n \n     public String toString() {\n-        String ret = _owner.getFullName();\n+        String ret = _owner.getFullName(true);\n         if (this == _owner.getKey())\n             return ret + \"<key:\" + _decType + \">\";\n         if (this == _owner.getElement()) {"},{"sha":"96861e8b08eba4ee253e4b624c610345f596591a","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","status":"modified","additions":59,"deletions":46,"changes":105,"blob_url":"https://github.com/apache/openjpa/blob/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java?ref=c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c","patch":"@@ -179,17 +179,21 @@ public Connection decorate(Connection conn) throws SQLException {\n         return new LoggingConnection(conn);\n     }\n \n+    /**\n+     * Include SQL in exception.\n+     */\n     private SQLException wrap(SQLException sqle, Statement stmnt) {\n         if (sqle instanceof ReportingSQLException)\n             return (ReportingSQLException) sqle;\n-\n         return new ReportingSQLException(sqle, stmnt);\n     }\n \n+    /**\n+     * Include SQL in exception.\n+     */\n     private SQLException wrap(SQLException sqle, String sql) {\n         if (sqle instanceof ReportingSQLException)\n             return (ReportingSQLException) sqle;\n-\n         return new ReportingSQLException(sqle, sql);\n     }\n \n@@ -202,6 +206,9 @@ private SQLException wrap(SQLException sqle, String sql) {\n         public void handleWarning(SQLWarning warning) throws SQLException;\n     }\n \n+    /**\n+     * Logging connection.\n+     */\n     private class LoggingConnection extends DelegatingConnection {\n \n         public LoggingConnection(Connection conn) throws SQLException {\n@@ -242,7 +249,6 @@ protected Statement createStatement(int type, int concurrency,\n \n         public void commit() throws SQLException {\n             long start = System.currentTimeMillis();\n-\n             try {\n                 super.commit();\n             } finally {\n@@ -254,7 +260,6 @@ public void commit() throws SQLException {\n \n         public void rollback() throws SQLException {\n             long start = System.currentTimeMillis();\n-\n             try {\n                 super.rollback();\n             } finally {\n@@ -266,7 +271,6 @@ public void rollback() throws SQLException {\n \n         public void close() throws SQLException {\n             long start = System.currentTimeMillis();\n-\n             try {\n                 super.close();\n             } finally {\n@@ -397,6 +401,22 @@ protected DatabaseMetaData getMetaData(boolean wrap)\n             return new LoggingDatabaseMetaData(super.getMetaData(false));\n         }\n \n+        /**\n+         * Log time elapsed since given start.\n+         */\n+        private void logTime(long startTime) throws SQLException {\n+            if (_logs.isSQLEnabled())\n+                _logs.logSQL(\"spent\", startTime, this); \n+        }\n+\n+        /**\n+         * Log time elapsed since given start.\n+         */\n+        private void logSQL(Statement stmnt) throws SQLException {\n+            if (_logs.isSQLEnabled())\n+                _logs.logSQL(\"executing \" + stmnt, this); \n+        }\n+\n         /**\n          * Handle any {@link SQLWarning}s on the current {@link Connection}.\n          *\n@@ -451,7 +471,7 @@ private void handleSQLWarning(ResultSet rs) throws SQLException {\n          *\n          * @param warning the warning to handle\n          */\n-        void handleSQLWarning(SQLWarning warning) throws SQLException {\n+        private void handleSQLWarning(SQLWarning warning) throws SQLException {\n             if (warning == null)\n                 return;\n             if (_warningAction == WARN_IGNORE)\n@@ -490,6 +510,9 @@ void handleSQLWarning(SQLWarning warning) throws SQLException {\n             }\n         }\n \n+        /**\n+         * Metadata wrapper that logs actions.\n+         */\n         private class LoggingDatabaseMetaData\n             extends DelegatingDatabaseMetaData {\n \n@@ -698,57 +721,49 @@ protected ResultSet wrapResult(ResultSet rs, boolean wrap) {\n \n             public void cancel() throws SQLException {\n                 if (_logs.isJDBCEnabled())\n-                    _logs.logJDBC(\"cancel \" + this + \": \" + _sql,\n-                        LoggingConnection.this);\n-\n+                    _logs.logJDBC(\"cancel \" + this, LoggingConnection.this);\n                 super.cancel();\n             }\n \n             protected ResultSet executeQuery(String sql, boolean wrap)\n                 throws SQLException {\n-                long start = System.currentTimeMillis();\n-\n                 _sql = sql;\n+                logSQL(this);\n+                long start = System.currentTimeMillis();\n                 try {\n                     return super.executeQuery(sql, wrap);\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingStatement.this);\n                 } finally {\n-                    if (_logs.isSQLEnabled())\n-                        _logs.logSQL(\"executing \" + this, start,\n-                            LoggingConnection.this);\n+                    logTime(start);\n                     handleSQLWarning(LoggingStatement.this);\n                 }\n             }\n \n             public int executeUpdate(String sql) throws SQLException {\n-                long start = System.currentTimeMillis();\n-\n                 _sql = sql;\n+                logSQL(this);\n+                long start = System.currentTimeMillis();\n                 try {\n                     return super.executeUpdate(sql);\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingStatement.this);\n                 } finally {\n-                    if (_logs.isSQLEnabled())\n-                        _logs.logSQL(\"executing \" + this, start,\n-                            LoggingConnection.this);\n+                    logTime(start);\n                     handleSQLWarning(LoggingStatement.this);\n                 }\n             }\n \n             public boolean execute(String sql) throws SQLException {\n-                long start = System.currentTimeMillis();\n-\n                 _sql = sql;\n+                logSQL(this);\n+                long start = System.currentTimeMillis();\n                 try {\n                     return super.execute(sql);\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingStatement.this);\n                 } finally {\n-                    if (_logs.isSQLEnabled())\n-                        _logs.logSQL(\"executing \" + this, start,\n-                            LoggingConnection.this);\n+                    logTime(start);\n                     handleSQLWarning(LoggingStatement.this);\n                 }\n             }\n@@ -775,78 +790,78 @@ protected ResultSet wrapResult(ResultSet rs, boolean wrap) {\n \n             protected ResultSet executeQuery(String sql, boolean wrap)\n                 throws SQLException {\n+                logSQL(this);\n                 long start = System.currentTimeMillis();\n-\n                 try {\n                     return super.executeQuery(sql, wrap);\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingPreparedStatement.this);\n                 } finally {\n-                    log(\"executing\", start);\n+                    logTime(start);\n                     clearLogParameters(true);\n                     handleSQLWarning(LoggingPreparedStatement.this);\n                 }\n             }\n \n             public int executeUpdate(String sql) throws SQLException {\n+                logSQL(this);\n                 long start = System.currentTimeMillis();\n-\n                 try {\n                     return super.executeUpdate(sql);\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingPreparedStatement.this);\n                 } finally {\n-                    log(\"executing\", start);\n+                    logTime(start);\n                     clearLogParameters(true);\n                     handleSQLWarning(LoggingPreparedStatement.this);\n                 }\n             }\n \n             public boolean execute(String sql) throws SQLException {\n+                logSQL(this);\n                 long start = System.currentTimeMillis();\n-\n                 try {\n                     return super.execute(sql);\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingPreparedStatement.this);\n                 } finally {\n-                    log(\"executing\", start);\n+                    logTime(start);\n                     clearLogParameters(true);\n                     handleSQLWarning(LoggingPreparedStatement.this);\n                 }\n             }\n \n             protected ResultSet executeQuery(boolean wrap) throws SQLException {\n+                logSQL(this);\n                 long start = System.currentTimeMillis();\n-\n                 try {\n                     return super.executeQuery(wrap);\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingPreparedStatement.this);\n                 } finally {\n-                    log(\"executing\", start);\n+                    logTime(start);\n                     clearLogParameters(true);\n                     handleSQLWarning(LoggingPreparedStatement.this);\n                 }\n             }\n \n             public int executeUpdate() throws SQLException {\n+                logSQL(this);\n                 long start = System.currentTimeMillis();\n-\n                 try {\n                     return super.executeUpdate();\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingPreparedStatement.this);\n                 } finally {\n-                    log(\"executing\", start);\n+                    logTime(start);\n                     clearLogParameters(true);\n                     handleSQLWarning(LoggingPreparedStatement.this);\n                 }\n             }\n \n             public int[] executeBatch() throws SQLException {\n+                logSQL(this);\n                 long start = System.currentTimeMillis();\n-\n                 try {\n                     return super.executeBatch();\n                 } catch (SQLException se) {\n@@ -884,21 +899,21 @@ public int executeUpdate() throws SQLException {\n                     }\n                     throw wrap(se, LoggingPreparedStatement.this);\n                 } finally {\n-                    log(\"executing batch\", start);\n+                    logTime(start);\n                     clearLogParameters(true);\n                     handleSQLWarning(LoggingPreparedStatement.this);\n                 }\n             }\n \n             public boolean execute() throws SQLException {\n+                logSQL(this);\n                 long start = System.currentTimeMillis();\n-\n                 try {\n                     return super.execute();\n                 } catch (SQLException se) {\n                     throw wrap(se, LoggingPreparedStatement.this);\n                 } finally {\n-                    log(\"executing\", start);\n+                    logTime(start);\n                     clearLogParameters(true);\n                     handleSQLWarning(LoggingPreparedStatement.this);\n                 }\n@@ -1024,8 +1039,9 @@ public void setObject(int i, Object o) throws SQLException {\n             }\n \n             public void addBatch() throws SQLException {\n+                if (_logs.isSQLEnabled())\n+                    _logs.logSQL(\"batching \" + this, LoggingConnection.this);\n                 long start = System.currentTimeMillis();\n-\n                 try {\n                     super.addBatch();\n                     if (shouldTrackParameters()) {\n@@ -1040,7 +1056,7 @@ public void addBatch() throws SQLException {\n                     }\n                 }\n                 finally {\n-                    log(\"batching\", start);\n+                    logTime(start);\n                 }\n             }\n \n@@ -1124,12 +1140,6 @@ protected void appendInfo(StringBuffer buf) {\n                 super.appendInfo(buf);\n             }\n \n-            private void log(String msg, long startTime) throws SQLException {\n-                if (_logs.isSQLEnabled())\n-                    _logs.logSQL(msg + \" \" + this, startTime,\n-                        LoggingConnection.this);\n-            }\n-\n             private void clearLogParameters(boolean batch) {\n                 if (_params != null)\n                     _params.clear();\n@@ -1192,6 +1202,9 @@ private void setLogParameter(int index, String val) {\n             }\n         }\n \n+        /**\n+         * Warning-handling result set.\n+         */\n         private class LoggingResultSet extends DelegatingResultSet {\n \n             public LoggingResultSet(ResultSet rs, Statement stmnt) {"},{"sha":"5bc0dc5091505664ac9c3560562f307ac85fa9df","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/SimpleRegex.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/SimpleRegex.java","raw_url":"https://github.com/apache/openjpa/raw/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/SimpleRegex.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/SimpleRegex.java?ref=c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c","patch":"@@ -78,6 +78,13 @@ else if (star == -1) {\n                 if (!mobile && targetPos != target.length() - len)\n                     return false;\n \n+                // In anycase, the remaining length of the target must be\n+                // at least as long as the remaining length of the expression.\n+                // (We check now to avoid sending a negative start pos to\n+                // indexOf)\n+                if (target.length() < len)\n+                    return false;\n+\n                 // Match the end of the target to the remainder of the\n                 // expression\n                 int match = indexOf(target, target.length() - len, exprPos,"},{"sha":"a698226aa2c9dd23f577d66fd061f587510eb5be","filename":"openjpa-project/src/doc/manual/ref_guide_runtime.xml","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-project/src/doc/manual/ref_guide_runtime.xml","raw_url":"https://github.com/apache/openjpa/raw/c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c/openjpa-project/src/doc/manual/ref_guide_runtime.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_runtime.xml?ref=c0c4c3c7385bc672b7b70bd3daf1ec9687bd5c3c","patch":"@@ -928,15 +928,16 @@ mag.setPageCount(300);\n oem.setSavepoint(\"pages\");\n \n mag.setPrice(mag.getPageCount() * pricePerPage);\n-// we decide to release pages since price depends on pages.\n+// we decide to release \"pages\"...\n oem.releaseSavepoint(\"pages\");\n+// ... and set a new savepoint which includes all changes\n oem.setSavepoint(\"price\");\n \n mag.setPrice(testPrice);\n-...\n-\n // we determine the test price is not good\n oem.rollbackToSavepoint(\"price\");\n+// had we chosen to not release \"pages\", we might have rolled back to\n+// \"pages\" instead\n \n // the price is now restored to mag.getPageCount() * pricePerPage\n oem.getTransaction().commit();"}]}

