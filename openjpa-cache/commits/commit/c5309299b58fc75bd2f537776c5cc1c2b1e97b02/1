{"sha":"c5309299b58fc75bd2f537776c5cc1c2b1e97b02","node_id":"MDY6Q29tbWl0MjA2MzY0OmM1MzA5Mjk5YjU4ZmM3NWJkMmY1Mzc3NzZjNWNjMWMyYjFlOTdiMDI=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2008-02-22T01:09:05Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2008-02-22T01:09:05Z"},"message":"OPENJPA-521. This is a partial fix; we should be able to avoid the looping in clearInverseRelationCache with a bit of extra data structures in FieldMetaData, probably populated during FieldMetaData.getOrder() or MetaDataRepository.newOrder().\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@630063 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"98c06cb161f661ca2ccc74c307e73de3b642be8c","url":"https://api.github.com/repos/apache/openjpa/git/trees/98c06cb161f661ca2ccc74c307e73de3b642be8c"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/c5309299b58fc75bd2f537776c5cc1c2b1e97b02","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/c5309299b58fc75bd2f537776c5cc1c2b1e97b02","html_url":"https://github.com/apache/openjpa/commit/c5309299b58fc75bd2f537776c5cc1c2b1e97b02","comments_url":"https://api.github.com/repos/apache/openjpa/commits/c5309299b58fc75bd2f537776c5cc1c2b1e97b02/comments","author":null,"committer":null,"parents":[{"sha":"4c70963f1a990787ffa2495016b5142c0fbd0747","url":"https://api.github.com/repos/apache/openjpa/commits/4c70963f1a990787ffa2495016b5142c0fbd0747","html_url":"https://github.com/apache/openjpa/commit/4c70963f1a990787ffa2495016b5142c0fbd0747"}],"stats":{"total":62,"additions":61,"deletions":1},"files":[{"sha":"72c9b7182a4fcabc7e580943ebbcaf3fd9695faf","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataImpl.java","status":"modified","additions":61,"deletions":1,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/c5309299b58fc75bd2f537776c5cc1c2b1e97b02/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataImpl.java","raw_url":"https://github.com/apache/openjpa/raw/c5309299b58fc75bd2f537776c5cc1c2b1e97b02/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataImpl.java?ref=c5309299b58fc75bd2f537776c5cc1c2b1e97b02","patch":"@@ -20,10 +20,11 @@\n \n import java.util.BitSet;\n \n-import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.AbstractPCData;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.PCData;\n import org.apache.openjpa.kernel.PCDataImpl;\n+import org.apache.openjpa.kernel.PCState;\n import org.apache.openjpa.kernel.StoreContext;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n@@ -119,6 +120,65 @@ public synchronized void store(OpenJPAStateManager sm, BitSet fields) {\n         super.store(sm, fields);\n     }\n \n+    /**\n+     * Store field-level information from the given state manager.\n+     * Special process of checking if the cached collection data is out of order.\n+     */\n+    protected void storeField(OpenJPAStateManager sm, FieldMetaData fmd) {\n+        if (fmd.getManagement() != fmd.MANAGE_PERSISTENT)\n+            return;\n+        int index = fmd.getIndex();\n+\n+        // if the field is a collection and has \"order by\" set, don't cache\n+        // it if this store is coming from a create or update (i.e., only\n+        // enlist in cache if this is coming from a database read).\n+        if (fmd.getOrders().length > 0) {\n+            if (sm.getPCState() == PCState.PNEW)\n+                return;\n+            if (sm.getPCState() == PCState.PDIRTY) {\n+                clearData(index);\n+                return;\n+            }\n+        }\n+\n+        super.storeField(sm, fmd);\n+\n+        // If this field is used in \"order by\", we need to invalidate cache\n+        // for the collection that refer to this field.\n+        if (sm.getPCState() == PCState.PDIRTY) {\n+            clearInverseRelationCache(sm, fmd);\n+        }\n+    }\n+\n+    /**\n+     * Check if this field is in use of \"order by\" by other field collections\n+     * in inverse relation. If it is, clear the other field cache because it\n+     * could be out of order.\n+     */\n+    protected void clearInverseRelationCache(OpenJPAStateManager sm,\n+        FieldMetaData fmd) {\n+        ClassMetaData cmd = sm.getMetaData();\n+        FieldMetaData[] fields = cmd.getFields();\n+        for (int i = 0; i < fields.length; i++) {\n+            FieldMetaData[] inverses = fields[i].getInverseMetaDatas();\n+            if (inverses.length == 0)\n+                continue;\n+            for (int j = 0; j < inverses.length; j++) {\n+                if (inverses[j].getOrderDeclaration()\n+                    .indexOf(fmd.getName()) != -1) {\n+                    DataCache cache = sm.getMetaData().getDataCache();\n+                    Object oid = sm.getContext().getObjectId(sm.fetch(i));\n+                    DataCachePCData data = cache.get(oid);\n+                    if ((data != null) &&\n+                        (data instanceof DataCachePCDataImpl)) {\n+                        ((DataCachePCDataImpl) data)\n+                            .clearData(inverses[j].getIndex());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     protected Object toData(FieldMetaData fmd, Object val, StoreContext ctx) {\n         // avoid caching large result set fields\n         if (fmd.isLRS() || fmd.isStream())"}]}

