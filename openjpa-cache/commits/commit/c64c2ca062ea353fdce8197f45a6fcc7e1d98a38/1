{"sha":"c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","node_id":"MDY6Q29tbWl0MjA2MzY0OmM2NGMyY2EwNjJlYTM1M2ZkY2U4MTk3ZjQ1YTZmY2M3ZTFkOThhMzg=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-05-14T03:25:56Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-05-14T03:25:56Z"},"message":"Some core utility classes. These are all JDK1.3-safe. I have not committed required libraries; we'll need to set up our build + lib infrastructure. To compile this codebase, you'll need serp, commons collections, commons lang, log4j, commons logging, jdbc3 stubs, and the xml apis to be available.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@406215 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"285ed1ff56c40dbbee1f938eefd1a41d6e41d860","url":"https://api.github.com/repos/apache/openjpa/git/trees/285ed1ff56c40dbbee1f938eefd1a41d6e41d860"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","html_url":"https://github.com/apache/openjpa/commit/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","comments_url":"https://api.github.com/repos/apache/openjpa/commits/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/comments","author":null,"committer":null,"parents":[{"sha":"c3d9053a6b2d64f57a6657a0570055071c559a6c","url":"https://api.github.com/repos/apache/openjpa/commits/c3d9053a6b2d64f57a6657a0570055071c559a6c","html_url":"https://github.com/apache/openjpa/commit/c3d9053a6b2d64f57a6657a0570055071c559a6c"}],"stats":{"total":29673,"additions":29673,"deletions":0},"files":[{"sha":"11324a47b40a7aca6659e793e374e037935bc6af","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/BooleanValue.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/BooleanValue.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/BooleanValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/BooleanValue.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+\n+/**\n+ *\tA boolean {@link Value}.\n+ *\n+ *\t@author\tMarc Prud'hommeaux\n+ */\n+public class BooleanValue\n+\textends Value\n+{\n+ \tprivate boolean value;\n+\n+\n+\tpublic BooleanValue (String prop)\n+\t{\n+\t\tsuper (prop);\n+\t\tsetAliasListComprehensive (true);\n+\t}\n+\n+\n+\tpublic Class getValueType ()\n+\t{\n+\t\treturn boolean.class;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe internal value.\n+\t */\n+\tpublic void set (boolean value)\n+\t{\n+\t\tboolean oldValue = this.value;\n+\t\tthis.value = value;\n+\t\tif (oldValue != value)\n+\t\t\tvalueChanged ();\n+\t}\n+\n+\n+\t/**\n+\t *\tThe internal value.\n+\t */\n+\tpublic boolean get ()\n+\t{\n+\t\treturn value;\n+\t}\n+\n+\n+\tprotected String getInternalString ()\n+\t{\n+\t\treturn String.valueOf (value);\n+\t}\n+\n+\n+\tprotected void setInternalString (String val)\n+\t{\n+\t\tset (Boolean.valueOf (val).booleanValue ());\n+\t}\n+\n+\n+\tprotected void setInternalObject (Object obj)\n+\t{\n+\t\tif (obj == null)\n+\t\t\tset (false);\n+\t\telse\n+\t\t\tset (((Boolean) obj).booleanValue ());\n+\t}\n+}"},{"sha":"3383954b9f403c24ea09fb70d3c1d8d2515ff3b1","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/Configurable.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/Configurable.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/Configurable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/Configurable.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+\n+/**\n+ *\t<p>This interface provides a mechanism for notifying interested\n+ *\tobjects when configuration events occur. It provides an object\n+ *\twith the opportunity to set itself up for configuration and to\n+ *\tperform any necessary post-configuration.</p>\n+ *\n+ *\t@author\tPatrick Linskey\n+ */\n+public interface Configurable\n+{\n+\t/**\n+\t *\tInvoked prior to setting bean properties. \n+\t */\n+\tpublic void setConfiguration (Configuration conf);\n+\n+\n+\t/**\n+\t *\tInvoked before bean property configuration is begun on this object.\n+\t */\n+\tpublic void startConfiguration ();\n+\n+\n+\t/**\n+\t *\tInvoked upon completion of bean property configuration for this object.\n+\t */\n+\tpublic void endConfiguration ();\n+}"},{"sha":"2345c4e083a456a1be6a071ccd3fabf77bc38ced","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/Configuration.java","status":"added","additions":199,"deletions":0,"changes":199,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/Configuration.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/Configuration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/Configuration.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,199 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+\n+import java.beans.*;\n+import java.io.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.log.*;\n+import org.apache.openjpa.lib.util.Closeable; \n+\n+\n+/**\n+ *\t<p>Interface for generic configuration objects.  Includes the ability\n+ *\tto write configuration to and from {@link Properties} instances.</p>\n+ *\n+ *\t@author Marc Prud'hommeaux\n+ *\t@author Abe White\n+ */\n+public interface Configuration\n+\textends BeanInfo, Serializable, Closeable, Cloneable\n+{\n+\t/**\n+\t *\tAttribute of returned {@link Value} property descriptors listing \n+\t *\trecognized values for the property.\n+\t */\n+\tpublic static final String ATTRIBUTE_ALLOWED_VALUES = \"allowedValues\";\n+\n+\t/**\n+\t *\tAttribute of the returned {@link Value} property descriptors naming \n+\t *\tthe property's type or category.\n+\t */\t\n+\tpublic static final String ATTRIBUTE_TYPE = \"propertyType\";\n+\n+\t/**\n+\t *\tAttribute of the returned {@link Value} property descriptors naming \n+\t *\tthe property' hierarchical category.\n+\t */\t\n+\tpublic static final String ATTRIBUTE_CATEGORY = \"propertyCategory\";\n+\n+\t/**\n+\t *\tAttribute of the returned {@link Value} property descriptors naming \n+\t *\tthe property's ordering in its category.\n+\t */\t\n+\tpublic static final String ATTRIBUTE_ORDER = \"propertyCategoryOrder\";\n+\n+\n+\t/**\n+\t *\tReturn the product name.  Defaults to <code>solarmetric</code>.\n+\t */\n+\tpublic String getProductName ();\n+\n+\n+\t/**\n+\t *\tThe log factory. If no log factory has been set explicitly,\n+ \t *\tthis method will create one.\n+\t */\n+\tpublic LogFactory getLogFactory ();\n+\n+\n+\t/**\n+\t * \t The log factory.\n+\t */\n+\tpublic void setLogFactory (LogFactory factory);\n+\n+\n+\t/**\n+\t *\tLog plugin setting.\n+\t */\n+\tpublic String getLog ();\n+\n+\n+\t/**\n+\t *\tLog plugin setting.\n+\t */\n+\tpublic void setLog (String log);\n+\n+\n+\t/**\n+\t *\tReturn the log for the given category.\n+\t *\n+\t *\t@see\t#getLogFactory\n+\t */\n+\tpublic Log getLog (String category);\n+\n+\n+\t/**\n+\t *\tReturn the log to use for configuration messages.\n+\t */\n+\tpublic Log getConfigurationLog ();\n+\n+\n+\t/**\n+\t *\tReturn the log to use for management messages.\n+\t */\n+\tpublic Log getManagementLog ();\n+\n+\n+\t/**\n+\t *\tReturn the log to use for profiling messages.\n+\t */\n+\tpublic Log getProfilingLog ();\n+\n+\n+\t/**\n+\t *\tReturn the {@link Value} for the given property, or null if none.\n+\t */\n+\tpublic Value getValue (String property);\n+\n+\n+\t/**\n+\t *\tReturn the set of all {@link Value}s.\n+\t */\n+\tpublic Value[] getValues ();\n+\n+\n+\t/**\n+\t *\tA properties representation of this Configuration.\n+\t *\tNote that changes made to this properties object will\n+\t *\tnot be automatically reflected in this Configuration object.\n+\t *\n+\t *\t@param storeDefaults if true, then properties will be written\n+\t * \t\t\t\t\t\tout even if they match the default value\n+\t * \t\t\t\t\t\tfor a property\n+\t */\n+\tpublic Properties toProperties (boolean storeDefaults);\n+\n+\n+\t/**\n+\t *\tSet this Configuration via the given map.  Any keys missing from\n+\t *\tthe given map will not be set. Note that changes made to this map \n+\t *\twill not be automatically reflected in this Configuration object.\n+\t *\n+\t *\tIMPORTANT: If the map contains instantiated objects (rather than \n+\t *\tstring values), only the string representation of those objects\n+\t *\tare considered in this configuration's <code>equals</code> and \n+\t *\t<code>hashCode</code> methods.   If the object's property has no\n+\t *\tstring form (such as an {@link ObjectValue}), the object is not\n+\t *\tpart of the equality and hashing calculations.\n+\t */\n+\tpublic void fromProperties (Map map);\n+\n+\n+\t/** \n+\t *  Adds a listener for any property changes.  The property events fired\n+\t * \twill <b>not</b> include the old value.\n+\t *  \n+\t *  @param  listener  \tthe listener to receive notification\n+\t *  \t\t\t\t\tof property changes\n+\t */\n+\tpublic void addPropertyChangeListener (PropertyChangeListener listener);\n+\n+\n+\t/** \n+\t *  Removes a listener for any property changes.\n+\t *  \n+\t *  @param  listener  the listener to remove\n+\t */\n+\tpublic void removePropertyChangeListener (PropertyChangeListener listener);\n+\n+\n+\t/**\n+\t *\tLock down the configuration's state.  Attempting to set state on a\n+\t *\tread-only configuration results in an exception.\n+\t */\n+\tpublic void setReadOnly (boolean readOnly);\n+\n+\n+\t/**\n+\t *\tReturn true if this configuration is immutable.\n+\t */\n+\tpublic boolean isReadOnly ();\n+\n+\n+\t/**\n+\t *\tFree the resources used by this object.\n+\t */\n+\tpublic void close ();\n+\n+\n+\t/**\n+\t *\tReturn a copy of this configuration.\n+\t */\n+\tpublic Object clone ();\n+}"},{"sha":"dc62aa4d9b3946003c647af0cd67cfc961fb1640","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/ConfigurationImpl.java","status":"added","additions":900,"deletions":0,"changes":900,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/ConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/ConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/ConfigurationImpl.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,900 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+\n+import java.awt.*;\n+import java.beans.*;\n+import java.io.*;\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.util.List;\n+\n+import org.apache.commons.lang.*;\n+\n+import org.apache.openjpa.lib.log.*;\n+import org.apache.openjpa.lib.util.*;\n+\n+import serp.util.*;\n+\n+\n+/**\n+ *  <p>Default implementation of the {@link Configuration} interface.\n+ *\tSubclasses can choose to obtain configuration \n+ *\tinformation from JNDI, Properties, a Bean-builder, etc.  This class\n+ *\tprovides base configuration functionality, including serialization,\n+ *\tthe <code>equals</code> and <code>hashCode</code> contracts, and default\n+ *\tproperty loading.</p>\n+ *\n+ *\t<p>Subclasses should be sure to pass in <code>false</code> to the\n+ *\tconstructor when they call it, then call {@link #loadDefaults} themselves \n+ *\tif they want to load default properties.  Otherwise, their field \n+ *\tinitializations will overwrite the defaults that were loaded.</p>\n+ *\n+ *\t<p>Property descriptors for {@link Value} instances are constructed from \n+ *\tthe {@link Localizer} for the package of the configuration class. The \n+ *\tfollowing localized strings will be used for describing a value, where\n+ *\t<em>name</em> is the last token of the value's property string:\n+ *  <ul>\n+ *  <li><em>name</em>-name: The name that will be displayed for the\n+ * \t\toption in a user interface; required.</li>\n+ *  <li><em>name</em>-desc: A brief description of the option; required.</li>\n+ *  <li><em>name</em>-type: The type or category name for this option; \n+ *\t\trequired.</li>\n+ *  <li><em>name</em>-expert: True if this is an expert option, false \n+ *\t\totherwise; defaults to false.</li>\n+ *\t<li><em>name</em>-values: Set of expected or common values, excluding \n+ *\t\talias keys; optional.</li>\n+ *\t<li><em>name</em>-interface: The class name of an interface whose \n+ *\t\tdiscoverable implementations should be included in the set of expected \n+ *\t\tor common values; optional.</li>\t\n+ *  <li><em>name</em>-cat: The hierarchical category for the property\n+ *  \tname, separated by \".\".\n+ *  <li><em>name</em>-displayorder: The order in which the property should\n+ *  \tbe displayer.</li>\n+ *  </ul></p>\n+ *\n+ *\t@author\tAbe White\n+ */\n+public class ConfigurationImpl\n+\timplements Configuration, Externalizable, ValueListener\n+{\n+\tprivate static final Localizer _loc = Localizer.forPackage \n+\t\t(ConfigurationImpl.class);\n+\n+\tprotected final PluginValue logFactoryPlugin;\n+\n+\tprivate boolean \t_readOnly\t= false;\n+\tprivate Properties\t_props\t\t= null;\n+\tprivate boolean\t\t_defaults\t= false;\n+\tprivate final List\t_vals \t\t= new ArrayList ();\n+\n+\t// property listener helper\n+\tprivate PropertyChangeSupport _changeSupport = null;\n+\n+\t// cache descriptors\n+\tprivate PropertyDescriptor[] _pds = null;\n+\tprivate MethodDescriptor[] _mds = null;\n+\n+\n+\t/**\n+\t *\tDefault constructor.  Attempts to load default properties through\n+\t *\tsystem's configured {@link ConfigurationProvider}s.\n+\t */\n+\tpublic ConfigurationImpl ()\n+\t{\n+\t\tthis (true);\n+\t}\n+\n+\n+\t/**\n+\t *\tConstructor.\n+ \t *\n+\t *\t@param\tloadDefaults\twhether to attempt to load the default\n+\t *\t\t\t\t\t\t\tproperties\n+\t */\n+\tpublic ConfigurationImpl (boolean loadDefaults)\n+\t{\n+\t\tlogFactoryPlugin = addPlugin (\"org.apache.openjpa.lib.Log\", true);\n+\t\tString[] aliases = new String[] {\n+\t\t\t\"true\", \"org.apache.openjpa.lib.log.LogFactoryImpl\",\n+\t\t\t\"commons\", \"org.apache.openjpa.lib.log.CommonsLogFactory\",\t\n+\t\t\t\"log4j\", \"org.apache.openjpa.lib.log.Log4JLogFactory\",\t\n+\t\t\t\"none\", \"org.apache.openjpa.lib.log.NoneLogFactory\",\n+\t\t\t\"false\", \"org.apache.openjpa.lib.log.NoneLogFactory\",\t\n+\t\t};\n+\t\tlogFactoryPlugin.setAliases (aliases);\n+\t\tlogFactoryPlugin.setDefault (aliases[0]);\n+\t\tlogFactoryPlugin.setClassName (aliases[1]);\n+\n+\t\tif (loadDefaults)\n+\t\t\tloadDefaults ();\n+\t}\n+\n+\n+\t/**\n+\t *\tAutomatically load default values from the system's \n+\t *\t{@link ConfigurationProvider}s, and from System properties.\n+\t */\n+\tpublic synchronized boolean loadDefaults ()\n+\t{\n+\t\tConfigurationProvider provider = Configurations.loadDefaults \n+\t\t\t(getClass ().getClassLoader ());\n+\t\tif (provider != null)\n+\t\t\tprovider.setInto (this);\n+\n+\t\t// load system properties; let them override any others\n+\t\ttry\n+\t\t{\n+\t\t\tfromProperties (new HashMap (System.getProperties ()));\n+\t\t}\n+\t\tcatch (SecurityException se)\n+\t\t{\n+\t\t\t// security manager might disallow this\n+\t\t}\n+\n+\t\t_defaults = true;\n+\t\tif (provider == null)\n+\t\t{\n+\t\t\tLog log = getConfigurationLog ();\n+\t\t\tif (log.isTraceEnabled ())\n+\t\t\t\tlog.trace (_loc.get (\"no-providers\"));\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\n+\tpublic String getProductName ()\n+\t{\n+\t\treturn \"solarmetric\";\n+\t}\n+\n+\n+\tpublic LogFactory getLogFactory ()\n+\t{\n+\t\tsynchronized (logFactoryPlugin)\n+\t\t{\n+\t\t\tif (logFactoryPlugin.get () == null)\n+\t\t\t\tlogFactoryPlugin.instantiate (LogFactory.class, this);\n+\t\t}\n+\t\treturn (LogFactory) logFactoryPlugin.get ();\n+\t}\n+\n+\n+\tpublic void setLogFactory (LogFactory logFactory)\n+\t{\n+\t\tassertNotReadOnly ();\n+\t\tlogFactoryPlugin.set (logFactory);\t\n+\t}\n+\n+\n+\tpublic String getLog ()\n+\t{\n+\t\treturn logFactoryPlugin.getString ();\n+\t}\n+\n+\n+\tpublic void setLog (String log)\n+\t{\n+\t\tassertNotReadOnly ();\n+\t\tlogFactoryPlugin.setString (log);\n+\t}\n+\n+\n+\tpublic Log getLog (String category)\n+\t{\n+\t\treturn getLogFactory ().getLog (category);\n+\t}\n+\n+\n+\t/**\n+\t *\tReturns the logging channel <code>org.apache.openjpa.lib.Runtime</code> by\n+\t *\tdefault.\n+\t */\n+\tpublic Log getConfigurationLog ()\n+\t{\n+\t\treturn getLog (\"org.apache.openjpa.lib.Runtime\");\n+\t}\n+\n+\n+\t/**\n+\t *\tReturns the logging channel <code>org.apache.openjpa.lib.Manage</code> by\n+\t *\tdefault.\n+\t */\n+\tpublic Log getManagementLog ()\n+\t{\n+\t\treturn getLog (\"org.apache.openjpa.lib.Manage\");\n+\t}\n+\n+\n+\t/**\n+\t *\tReturns the logging channel <code>org.apache.openjpa.lib.Profile</code> by\n+\t *\tdefault.\n+\t */\n+\tpublic Log getProfilingLog ()\n+\t{\n+\t\treturn getLog (\"org.apache.openjpa.lib.Profile\");\n+\t}\n+\n+\n+\tpublic Value[] getValues ()\n+\t{\n+\t\treturn (Value[]) _vals.toArray (new Value[_vals.size ()]);\n+\t}\n+\n+\n+\tpublic Value getValue (String property)\n+\t{\n+\t\tif (property == null)\n+\t\t\treturn null;\n+\n+\t\tValue val;\n+\t\tfor (int i = 0; i < _vals.size (); i++)\n+\t\t{\n+\t\t\tval = (Value) _vals.get (i);\n+\t\t\tif (val.getProperty ().equals (property))\n+\t\t\t\treturn val;\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\n+\tpublic void setReadOnly (boolean readOnly)\n+\t{\n+\t\t_readOnly = readOnly;\n+\t}\n+\n+\n+\tpublic boolean isReadOnly ()\n+\t{\n+\t\treturn _readOnly;\n+\t}\n+\n+\n+\tpublic synchronized void addPropertyChangeListener \n+\t\t(PropertyChangeListener listener)\n+\t{\n+\t\tif (_changeSupport == null)\n+\t\t\t_changeSupport = new PropertyChangeSupport (this); \n+\t\t_changeSupport.addPropertyChangeListener (listener);\n+\t}\n+\n+\n+\tpublic void removePropertyChangeListener (PropertyChangeListener listener)\n+\t{\n+\t\tif (_changeSupport != null)\n+\t\t\t_changeSupport.removePropertyChangeListener (listener);\n+\t}\n+\n+\n+\tpublic void valueChanged (Value val)\n+\t{\n+\t\tif (_changeSupport == null && _props == null)\n+\t\t\treturn;\n+\n+\t\tString newString = val.getString ();\n+\t\tif (_changeSupport != null)\n+\t\t\t_changeSupport.firePropertyChange (val.getProperty (), null, \n+\t\t\t\tnewString);\n+\n+\t\t// keep cached props up to date\n+\t\tif (_props != null)\n+\t\t{\n+\t\t\tif (newString == null)\n+\t\t\t\t_props.remove (val.getProperty ());\n+\t\t\telse if (_props.containsKey (val.getProperty ())\n+\t\t\t\t|| val.getDefault () == null\n+\t\t\t\t|| !val.getDefault ().equals (newString))\n+\t\t\t\t_props.put (val.getProperty (), newString);\n+\t\t}\n+\t}\n+\n+\n+\tpublic void close ()\n+\t{\n+\t}\n+\n+\n+\t///////////////////////////\n+\t// BeanInfo implementation\n+\t///////////////////////////\n+\n+\n+\tpublic BeanInfo[] getAdditionalBeanInfo ()\n+\t{\n+\t\treturn new BeanInfo[0];\n+\t}\n+\n+\n+\tpublic BeanDescriptor getBeanDescriptor ()\n+\t{\n+\t\treturn new BeanDescriptor (getClass ());\n+\t}\n+\n+\n+\tpublic int getDefaultEventIndex ()\n+\t{\n+\t\treturn 0;\n+\t}\n+\n+\n+\tpublic int getDefaultPropertyIndex ()\n+\t{\n+\t\treturn 0;\n+\t}\n+\n+\n+\tpublic EventSetDescriptor[] getEventSetDescriptors ()\n+\t{\n+\t\treturn new EventSetDescriptor[0];\n+\t}\n+\n+\n+\tpublic Image getIcon (int kind)\n+\t{\n+\t\treturn null;\n+\t}\n+\n+\n+\tpublic synchronized MethodDescriptor[] getMethodDescriptors ()\n+\t{\n+\t\tif (_mds != null)\n+\t\t\treturn _mds;\n+\t\tPropertyDescriptor[] pds = getPropertyDescriptors ();\n+\t\t_mds = new MethodDescriptor[pds.length * 2];\n+\t\tfor (int i = 0; i < pds.length; i++)\n+\t\t{\n+\t\t\t_mds[i * 2] = new MethodDescriptor (pds[i].getWriteMethod ());\n+\t\t\t_mds[(i * 2) + 1] = new MethodDescriptor (pds[i].getReadMethod ());\n+\t\t}\n+\t\treturn _mds;\n+\t}\n+\n+\n+\tpublic synchronized PropertyDescriptor[] getPropertyDescriptors ()\n+\t{\n+\t\tif (_pds != null)\n+\t\t\treturn _pds;\n+\n+\t\t_pds = new PropertyDescriptor[_vals.size ()];\n+\t\tList failures = null;\n+\t\tValue val;\n+\t\tfor (int i = 0; i < _vals.size (); i++)\n+\t\t{\n+\t\t\tval = (Value) _vals.get (i);\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\t_pds[i] = getPropertyDescriptor (val);\n+\t\t\t}\n+\t\t\tcatch (MissingResourceException mre)\n+\t\t\t{\n+\t\t\t\tif (failures == null)\n+\t\t\t\t\tfailures = new ArrayList ();\n+\n+\t\t\t\tfailures.add (val.getProperty ());\n+\t\t\t}\n+\t\t\tcatch (IntrospectionException ie)\n+\t\t\t{\n+\t\t\t\tif (failures == null)\n+\t\t\t\t\tfailures = new ArrayList ();\n+\n+\t\t\t\tfailures.add (val.getProperty ());\n+\t\t\t}\n+\t\t}\n+\t\tif (failures != null)\n+\t\t\tthrow new ParseException (_loc.get (\"invalid-property-descriptors\",\n+\t\t\t\tfailures));\n+\n+\t\treturn _pds;\n+\t}\n+\n+\n+\t/**\n+\t *\tCreate a property descriptor for the given value.\n+\t */\n+\tprivate PropertyDescriptor getPropertyDescriptor (Value val)\n+\t\tthrows IntrospectionException\n+\t{\n+\t\tString prop = val.getProperty ();\n+\t\tprop = prop.substring (prop.lastIndexOf ('.') + 1);\n+\n+\t\t// set up property descriptor\n+\t\tPropertyDescriptor pd = new PropertyDescriptor \n+\t\t\t(Introspector.decapitalize (prop), getClass ());\n+\t\tpd.setDisplayName (findLocalized (prop + \"-name\", true));\n+\t\tpd.setShortDescription (findLocalized (prop + \"-desc\", true));\n+\t\tpd.setExpert (\"true\".equals (findLocalized (prop + \"-expert\", false)));\n+\n+\t\ttry\n+\t\t{\n+\t\t\tpd.setReadMethod (getClass ().getMethod (\"get\" \n+\t\t\t\t+ StringUtils.capitalize (prop), (Class[]) null));\n+\t\t\tpd.setWriteMethod (getClass ().getMethod (\"set\" \n+\t\t\t\t+ StringUtils.capitalize (prop), new Class[] \n+\t\t\t\t{pd.getReadMethod ().getReturnType ()}));\n+\t\t}\n+\t\tcatch (Throwable t) \n+\t\t{\n+\t\t\tthrow new IntrospectionException (t.toString ());\n+\t\t}\n+\n+\t\n+\t\tString type = findLocalized (prop + \"-type\", true);\n+\t\tif (type != null)\n+\t\t\tpd.setValue (ATTRIBUTE_TYPE, type);\n+\n+\t\tString cat = findLocalized (prop + \"-cat\", false);\n+\t\tif (cat != null)\n+\t\t\tpd.setValue (ATTRIBUTE_CATEGORY, cat);\n+\n+\t\tString order = findLocalized (prop + \"-displayorder\", false);\n+\t\tif (order != null)\n+\t\t\tpd.setValue (ATTRIBUTE_ORDER, order);\n+\t\t\n+\t\t// collect allowed values from aliase keys, listed values, and\n+\t\t// interface implementors\n+\t\tCollection allowed = new TreeSet ();\n+\t\tList aliases = Collections.EMPTY_LIST;\n+\t\tif (val.getAliases () != null)\n+\t\t{\n+\t\t\taliases = Arrays.asList (val.getAliases ());\n+\t\t\tfor (int i = 0; i < aliases.size (); i += 2)\n+\t\t\t\tallowed.add (aliases.get (i));\n+\t\t}\n+\t\tString[] vals = Strings.split (findLocalized (prop \n+\t\t\t+ \"-values\", false), \",\", 0);\n+\t\tfor (int i = 0; i < vals.length; i++)\n+\t\t\tif (!aliases.contains (vals[i]))\n+\t\t\t\tallowed.add (vals[i]);\n+\t\ttry\n+\t\t{\n+\t\t\tClass intf = Class.forName (findLocalized (prop \n+\t\t\t\t+ \"-interface\", true), false, getClass ().getClassLoader ());\n+\t\t\tString[] impls = Services.getImplementors (intf);\n+\t\t\tfor (int i = 0; i < impls.length; i++)\n+\t\t\t\tif (!aliases.contains (impls[i]))\n+\t\t\t\t\tallowed.add (impls[i]);\n+\t\t}\n+\t\tcatch (Exception e)\n+\t\t{\n+\t\t}\n+\t\tif (!allowed.isEmpty ())\n+\t\t\tpd.setValue (ATTRIBUTE_ALLOWED_VALUES, (String[]) allowed.toArray\n+\t\t\t\t(new String[allowed.size ()]));\n+\n+\t\treturn pd;\n+\t}\n+\n+\n+\t/**\n+\t *\tFind the given localized string, or return null if not found.\n+\t */\n+\tprivate String findLocalized (String key, boolean fatal)\n+\t{\n+\t\t// find the localizer package that contains this key\n+\t\tLocalizer loc = null;\n+\t\tfor (Class cls = getClass (); cls != Object.class;\n+\t\t\tcls = cls.getSuperclass ())\n+\t\t{\n+\t\t\tloc = Localizer.forPackage (cls);\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\treturn loc.getFatal (key);\n+\t\t\t}\n+\t\t\tcatch (MissingResourceException mse)\n+\t\t\t{\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (fatal)\n+\t\t\tthrow new MissingResourceException (key,\n+\t\t\t\tgetClass ().getName (), key);\n+\t\treturn null;\n+\t}\n+\n+\n+\t////////////////\n+\t// To/from maps\n+\t////////////////\n+\n+\n+\tpublic synchronized Properties toProperties (boolean storeDefaults)\n+\t{\n+\t\t// clone properties before making any modifications; we need to keep\n+\t\t// the internal properties instance consistent to maintain equals and\n+\t\t// hashcode contracts\n+\t\tProperties clone;\n+\t\tif (_props == null)\n+\t\t\tclone = new Properties ();\n+\t\telse\n+\t\t\tclone = (Properties) _props.clone ();\n+\n+\t\t// if no existing properties or the properties should contain entries\n+\t\t// with default values, add values to properties\n+\t\tif (_props == null || storeDefaults)\n+\t\t{\n+\t\t\tValue val;\n+\t\t\tString str;\n+\t\t\tfor (int i = 0; i < _vals.size (); i++)\n+\t\t\t{\n+\t\t\t\t// if key in existing properties, we already know value is up \n+\t\t\t\t// to date\n+\t\t\t\tval = (Value) _vals.get (i);\n+\t\t\t\tif (_props != null && _props.containsKey (val.getProperty ()))\n+\t\t\t\t\tcontinue;\n+\n+\t\t\t\tstr = val.getString ();\n+\t\t\t\tif (str != null && (storeDefaults \n+\t\t\t\t\t|| !str.equals (val.getDefault ())))\n+\t\t\t\t\tclone.put (val.getProperty (), str);\n+\t\t\t}\n+\t\t\tif (_props == null)\n+\t\t\t\t_props = (Properties) clone.clone ();\n+\t\t}\n+\t\treturn clone;\n+\t}\n+\n+\n+\tpublic synchronized void fromProperties (Map map)\n+\t{\n+\t\tif (map == null || map.isEmpty ())\n+\t\t\treturn;\n+\t\tassertNotReadOnly ();\n+\n+\t\t// if the only previous call was to load defaults, forget them.\n+\t\t// this way we preserve the original formatting of the user's props\n+\t\t// instead of the defaults.  this is important for caching on\n+\t\t// configuration objects\n+\t\tif (_defaults)\n+\t\t{\n+\t\t\t_props = null;\n+\t\t\t_defaults = false;\n+\t\t}\n+\t\t\n+\t\tMap remaining = new HashMap (map);\n+\t\tValue val;\n+\t\tObject set;\n+\t\tfor (int i = 0; i < _vals.size (); i++)\n+\t\t{\n+\t\t\tval = (Value) _vals.get (i);\n+\t\t\tset = map.get (val.getProperty ());\n+\t\t\tif (set == null)\n+\t\t\t\tcontinue;\n+\n+\t\t\tif (set instanceof String)\n+\t\t\t{\n+\t\t\t\tif (!StringUtils.equals ((String) set, val.getString ()))\n+\t\t\t\t\tval.setString ((String) set);\n+\t\t\t}\n+\t\t\telse\n+\t\t\t\tval.setObject (set);\n+\n+\t\t\tremaining.remove (val.getProperty ());\n+\t\t}\n+\n+\t\t// cache properties\n+\t\tif (_props == null && map instanceof Properties)\n+\t\t\t_props = (Properties) map;\n+\n+\t\t// convention is to point product at a resource with the \n+\t\t// <product>.properties System property; remove that property so we\n+\t\t// we don't warn about it\n+\t\tremaining.remove (getProductName () + \".properties\");\n+\n+\t\t// now warn if there are any remaining properties that there\n+\t\t// is an unhandled prop\n+\t\tMap.Entry entry;\n+\t\tfor (Iterator itr = remaining.entrySet ().iterator (); itr.hasNext ();)\n+\t\t{\n+\t\t\tentry = (Map.Entry) itr.next ();\n+\t\t\tif (entry.getKey () != null)\n+\t\t\t\twarnInvalidProperty ((String) entry.getKey ());\n+\t\t}\n+\t}\n+\n+\n+\t/** \n+\t *  Issue a warning that the specified property is not valid.\n+\t */\n+\tprivate void warnInvalidProperty (String propName)\n+\t{\n+\t\tif (!isInvalidProperty (propName))\n+\t\t\treturn;\n+\t\tLog log = getConfigurationLog ();\n+\t\tif (log == null || !log.isWarnEnabled ())\n+\t\t\treturn;\n+\n+\t\t// try to find the closest string to the invalid property\n+\t\t// so that we can provide a hint in case of a misspelling\n+\t\tString closest = StringDistance.getClosestLevenshteinDistance\n+\t\t\t(propName, new PropertyList (), 15);\n+\n+\t\tif (closest == null)\n+\t\t\tlog.warn (_loc.get (\"invalid-property\", propName));\n+\t\telse\n+\t\t\tlog.warn (_loc.get (\"invalid-property-hint\", propName, closest));\n+\t}\n+\n+\n+\t/** \n+\t *  Returns true if the specified property name should raise a warning\n+\t *  if it is not found in the list of known properties.\n+\t */\n+\tprotected boolean isInvalidProperty (String propName)\n+\t{\n+\t\t// by default, we don't warn on any properties, since we don't\n+\t\t// know what property pattern will be used for the base config\n+\t\treturn false;\n+\t}\n+\n+\n+\t/**\n+\t *\tThis method loads the named resource as a properties file.  It is\n+\t *\tuseful for auto-configuration tools so users can specify a\n+\t *\t<code>properties</code> value with the name of a resource.\n+\t */\n+\tpublic void setProperties (String resourceName)\n+\t\tthrows IOException\n+\t{\n+\t\tConfigurations.load (resourceName, getClass ().getClassLoader ()).\n+\t\t\tsetInto (this);\n+\t}\n+\n+\n+\t/**\n+\t *\tThis method loads the named file as a properties file.  It is\n+\t *\tuseful for auto-configuration tools so users can specify a\n+\t *\t<code>propertiesFile</code> value with the name of a file.\n+\t */\n+\tpublic void setPropertiesFile (File file)\n+\t\tthrows IOException\n+\t{\n+\t\tConfigurations.load (file, getClass ().getClassLoader ()).\n+\t\t\tsetInto (this);\n+\t}\n+\n+\n+\t/////////////\n+\t// Utilities\n+\t/////////////\n+\n+\n+\t/**\n+\t *\tChecks if the configuration is read only and if so throws an\n+\t *\texception, otherwise returns silently.  \n+\t *\tImplementations\tshould call this method before setting any state.\n+\t */\n+\tprotected void assertNotReadOnly ()\n+\t{\n+\t\tif (isReadOnly ())\n+\t\t\tthrow new IllegalStateException (_loc.get (\"read-only\"));\n+\t}\n+\n+\n+\t/**\n+\t *\tPerforms an equality check based on the properties returned from\n+\t *\t{@link #toProperties}. \n+\t */\n+\tpublic boolean equals (Object other)\n+\t{\n+\t\tif (other == this)\n+\t\t\treturn true;\n+\t\tif (other == null)\n+\t\t\treturn false;\n+\t\tif (!getClass ().equals (other.getClass ()))\n+\t\t\treturn false;\n+\t\t\n+\t\t// compare properties\n+\t\tConfigurationImpl conf = (ConfigurationImpl) other;\n+\t\tProperties p1 = (_props == null) ? toProperties (false) : _props;\n+\t\tProperties p2 = (conf._props == null) ? conf.toProperties (false)\n+\t\t\t: conf._props;\n+\t\treturn p1.equals (p2);\n+\t}\n+\n+\n+\t/**\n+\t *\tComputes hash code based on the properties returned from\n+\t *\t{@link #toProperties}.\n+\t */\n+\tpublic int hashCode ()\n+\t{\n+\t\tif (_props != null)\n+\t\t\treturn _props.hashCode ();\n+\t\treturn toProperties (false).hashCode ();\n+\t}\n+\n+\n+\t/**\n+\t *\tImplementation of the {@link Externalizable} interface to read from\n+\t *\tthe properties written by {@link #writeExternal}.\n+\t */\n+\tpublic void readExternal (ObjectInput in)\n+\t\tthrows IOException, ClassNotFoundException\n+\t{\n+\t\tfromProperties ((Map) in.readObject ());\t\t\n+\t}\n+\n+\n+\t/**\n+\t *\tImplementation of the {@link Externalizable} interface to write\n+\t *\tthe properties returned by {@link #toProperties}.\n+\t */\n+\tpublic void writeExternal (ObjectOutput out)\n+\t\tthrows IOException\n+\t{\n+\t\tif (_props != null)\n+\t\t\tout.writeObject (_props);\n+\t\telse\n+\t\t\tout.writeObject (toProperties (false));\n+\t}\n+\n+\n+\t/**\n+\t *\tUses {@link #toProperties} and {@link #fromProperties} to clone\n+\t *\tconfiguration.\n+\t */\n+\tpublic Object clone ()\n+\t{\n+\t\ttry\n+\t\t{\n+\t\t\tConstructor cons = getClass ().getConstructor \n+\t\t\t\t(new Class[] { boolean.class });\n+\t\t\tConfiguration clone = (Configuration) cons.newInstance\n+\t\t\t\t(new Object[] { Boolean.FALSE });\n+\t\t\tclone.fromProperties (toProperties (true));\n+\t\t\treturn clone;\n+\t\t}\n+\t\tcatch (RuntimeException re)\n+\t\t{\n+\t\t\tthrow re;\n+\t\t}\n+\t\tcatch (Exception e)\n+\t\t{\n+\t\t\tthrow new ParseException (e);\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tAdd the given value to the set of configuration properties.\n+\t */\n+\tprotected Value addValue (Value val)\n+\t{\n+\t\t_vals.add (val);\n+\t\tval.setListener (this);\n+\t\treturn val;\n+\t}\n+\n+\n+\t/**\n+\t *\tAdd the given value to the set of configuration properties.\n+\t */\n+\tprotected StringValue addString (String property)\n+\t{\n+\t\tStringValue val = new StringValue (property);\n+\t\taddValue (val);\n+\t\treturn val;\n+\t}\n+\n+\n+\t/**\n+\t *\tAdd the given value to the set of configuration properties.\n+\t */\n+\tprotected FileValue addFile (String property)\n+\t{\n+\t\tFileValue val = new FileValue (property);\n+\t\taddValue (val);\n+\t\treturn val;\n+\t}\n+\n+\n+\t/**\n+\t *\tAdd the given value to the set of configuration properties.\n+\t */\n+\tprotected IntValue addInt (String property)\n+\t{\n+\t\tIntValue val = new IntValue (property);\n+\t\taddValue (val);\n+\t\treturn val;\n+\t}\n+\n+\n+\t/**\n+\t *\tAdd the given value to the set of configuration properties.\n+\t */\n+\tprotected DoubleValue addDouble (String property)\n+\t{\n+\t\tDoubleValue val = new DoubleValue (property);\n+\t\taddValue (val);\n+\t\treturn val;\n+\t}\n+\n+\n+\t/**\n+\t *\tAdd the given value to the set of configuration properties.\n+\t */\n+\tprotected BooleanValue addBoolean (String property)\n+\t{\n+\t\tBooleanValue val = new BooleanValue (property);\n+\t\taddValue (val);\n+\t\treturn val;\n+\t}\n+\n+\n+\t/**\n+\t *\tAdd the given value to the set of configuration properties.\n+\t */\n+\tprotected StringListValue addStringList (String property)\n+\t{\n+\t\tStringListValue val = new StringListValue (property);\n+\t\taddValue (val);\n+\t\treturn val;\n+\t}\n+\n+\n+\t/**\n+\t *\tAdd the given value to the set of configuration properties.\n+\t */\n+\tprotected ObjectValue addObject (String property)\n+\t{\n+\t\tObjectValue val = new ObjectValue (property);\n+\t\taddValue (val);\n+\t\treturn val;\n+\t}\n+\n+\n+\t/**\n+\t *\tAdd the given value to the set of configuration properties.\n+\t */\n+\tprotected PluginValue addPlugin (String property, boolean singleton)\n+\t{\n+\t\tPluginValue val = new PluginValue (property, singleton);\n+\t\taddValue (val);\n+\t\treturn val;\n+\t}\n+\n+\n+\t/**\n+\t *\tAdd the given value to the set of configuration properties.\n+\t */\n+\tprotected PluginListValue addPluginList (String property)\n+\t{\n+\t\tPluginListValue val = new PluginListValue (property);\n+\t\taddValue (val);\n+\t\treturn val;\n+\t}\n+\n+\n+\t/**\n+\t *\tExposes our values list as a list of property names.\n+\t */ \n+\tprivate class PropertyList\n+\t\textends AbstractList\n+\t{\n+\t\tpublic Object get (int i)\n+\t\t{\n+\t\t\treturn ((Value) _vals.get (i)).getProperty ();\n+\t\t}\n+\n+\n+\t\tpublic int size ()\n+\t\t{\n+\t\t\treturn _vals.size ();\n+\t\t}\n+\t}\n+}"},{"sha":"85ce06569d24d92f764fd43e9c64575dc64c5877","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/ConfigurationProvider.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/ConfigurationProvider.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/ConfigurationProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/ConfigurationProvider.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+\n+\n+/**\n+ *\tImplementations of this interface can populate {@link Configuration}s in\n+ *\tsome environment-specific way.  Implementations must implement the \n+ *\t<code>equals</code> and <code>hashCode</code> methods so that equivalent\n+ *\tconfigurations compare equal.\n+ *\n+ * \t@since 4.0.0\n+ *\t@nojavadoc\n+ */\n+public interface ConfigurationProvider\n+{\n+\t/**\n+\t *\tLoad defaults, or return false if no defaults for this provider found.\n+\t */\n+\tpublic boolean loadDefaults (ClassLoader loader)\n+\t\tthrows Exception;\n+\n+\n+\t/**\n+\t *\tLoad the given given resource, or return false if it is not a resource \n+\t *\tthis provider understands.  The given class loader may be null.\n+\t */\n+\tpublic boolean load (String resource, ClassLoader loader)\n+\t\tthrows Exception;\n+\n+\n+\t/**\n+\t *\tLoad given file, or return false if it is not a file this provider \n+\t *\tunderstands.\n+\t */\n+\tpublic boolean load (File file)\n+\t\tthrows Exception;\n+\n+\n+\t/**\n+\t *\tReturn properties loaded thus far, or empty map if none.\n+\t */\n+\tpublic Map getProperties ();\n+\n+\n+\t/**\n+\t *\tAdd the given properties to those in this provider, overwriting\n+\t *\tany exisitng properties under the same keys.\n+\t */\n+\tpublic void addProperties (Map props);\n+\n+\n+\t/**\n+\t *\tSet loaded information into the given configuration.\n+\t */\n+\tpublic void setInto (Configuration conf);\n+}"},{"sha":"6c85bd9597349014aa9151bd306d353cd928d967","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/Configurations.java","status":"added","additions":672,"deletions":0,"changes":672,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/Configurations.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/Configurations.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/Configurations.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,672 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+import javax.naming.*;\n+\n+import org.apache.commons.lang.exception.*;\n+\n+import org.apache.openjpa.lib.log.*;\n+import org.apache.openjpa.lib.util.*;\n+\n+import serp.util.*;\n+\n+\n+/**\n+ *\t<p>Utility methods dealing with configuration.</p>\n+ *\n+ *\t@author\tAbe White\n+ *\t@nojavadoc\n+ */\n+public class Configurations\n+{\n+\tprivate static final Localizer _loc = Localizer.forPackage \n+\t\t(Configurations.class);\n+\n+\n+\t/**\n+\t *\tReturn the class name from the given plugin string, or null if none.\n+ \t */\n+\tpublic static String getClassName (String plugin)\n+\t{\n+\t\treturn getPluginComponent (plugin, true);\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the properties part of the given plugin string, or null if none.\n+\t */\n+\tpublic static String getProperties (String plugin)\n+\t{\n+\t\treturn getPluginComponent (plugin, false);\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn either the class name or properties string from a plugin string.\n+\t */\n+\tprivate static String getPluginComponent (String plugin, boolean clsName)\n+\t{\n+\t\tif (plugin != null)\n+\t\t\tplugin = plugin.trim ();\n+\t\tif (plugin == null || plugin.length () == 0)\n+\t\t\treturn null;\n+\n+\t\tint openParen = -1;\n+\t\tif (plugin.charAt (plugin.length () - 1) == ')')\n+\t\t\topenParen = plugin.indexOf ('(');\n+\t\tif (openParen == -1)\n+\t\t{\n+\t\t\tint eq = plugin.indexOf ('=');\n+\t\t\tif (eq == -1)\n+\t\t\t\treturn (clsName) ? plugin : null;\t\n+\t\t\treturn (clsName) ? null : plugin;\n+\t\t}\n+\n+\t\t// clsName(props) form\n+\t\tif (clsName)\n+\t\t\treturn plugin.substring (0, openParen).trim ();\n+\t\tString prop = plugin.substring (openParen + 1, \n+\t\t\tplugin.length () - 1).trim ();\n+\t\treturn (prop.length () == 0) ? null : prop;\n+\t}\n+\n+\n+\t/**\n+\t *\tCombine the given class name and properties into a plugin string.\n+\t */\n+\tpublic static String getPlugin (String clsName, String props)\n+\t{\n+\t\tif (clsName == null || clsName.length () == 0)\n+\t\t\treturn props;\n+\t\tif (props == null || props.length () == 0)\n+\t\t\treturn clsName;\n+\t\treturn clsName + \"(\" + props + \")\";\n+\t}\n+\n+\n+\t/**\n+\t *\tCreate the instance with the given class name, using the given\n+\t *\tclass loader.  No configuration of the instance is performed by \n+\t *\tthis method.\n+\t */\n+\tpublic static Object newInstance (String clsName, ClassLoader loader)\n+\t{\t\n+\t\treturn newInstance (clsName, null, null, loader, true);\n+\t}\n+\n+\n+\t/**\n+\t *\tCreate and configure an instance with the given class name and\n+\t *\tproperties.\n+\t */\n+\tpublic static Object newInstance (String clsName, Configuration conf,\n+\t\tString props, ClassLoader loader)\n+\t{\n+\t\tObject obj = newInstance (clsName, null, conf, loader, true);\n+\t\tconfigureInstance (obj, conf, props);\n+\t\treturn obj;\n+\t}\n+\n+\n+\t/**\n+\t *\tHelper method used by members of this package to instantiate plugin\n+\t *\tvalues.\n+\t */\n+\tstatic Object newInstance (String clsName, Value val, Configuration conf,\n+\t\tClassLoader loader, boolean fatal)\n+\t{\n+\t\tif (clsName == null || clsName.length () == 0)\n+\t\t\treturn null;\n+\t\tif (loader == null && conf != null)\n+\t\t\tloader = conf.getClass ().getClassLoader ();\n+\n+\t\tClass cls = null;\n+\t\ttry\n+\t\t{\n+\t\t\tcls = Strings.toClass (clsName, loader);\n+\t\t}\n+\t\tcatch (RuntimeException re)\n+\t\t{\n+\t\t\tif (val != null)\n+\t\t\t\tre = getCreateException (clsName, val, re);\n+\t\t\tif (fatal)\n+\t\t\t\tthrow re;\n+\t\t\tLog log = (conf == null) ? null : conf.getConfigurationLog ();\n+\t\t\tif (log != null && log.isErrorEnabled ())\n+\t\t\t\tlog.error (re);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\ttry\n+\t\t{\n+\t\t\treturn cls.newInstance ();\n+\t\t}\n+\t\tcatch (Exception e)\n+\t\t{\n+\t\t\tRuntimeException re = new NestableRuntimeException (_loc.get \n+\t\t\t\t(\"obj-create\", cls), e);\n+\t\t\tif (fatal)\n+\t\t\t\tthrow re;\n+\t\t\tLog log = (conf == null) ? null : conf.getConfigurationLog ();\n+\t\t\tif (log != null && log.isErrorEnabled ())\n+\t\t\t\tlog.error (re);\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tHelper method to throw an informative description on instantiation \n+\t *\terror.\n+\t */\n+\tprivate static RuntimeException getCreateException (String clsName, \n+\t\tValue val, Exception e)\n+\t{\n+\t\t// re-throw the exception with some better information\n+\t\tfinal String msg;\n+\t\tfinal Object[] params;\n+\n+\t\tString alias = val.alias (clsName);\n+\t\tString[] aliases = val.getAliases ();\n+\t\tString[] keys;\n+\t\tif (aliases.length == 0)\n+\t\t\tkeys = aliases;\n+\t\telse\n+\t\t{\n+\t\t\tkeys = new String[aliases.length / 2];\n+\t\t\tfor (int i = 0; i < aliases.length; i += 2)\n+\t\t\t\tkeys[i / 2] = aliases[i];\n+\t\t}\n+\n+\t\tString closest;\n+\t\tif (keys.length == 0)\n+\t\t{\n+\t\t\tmsg = \"invalid-plugin\";\n+\t\t\tparams = new Object[] { val.getProperty (), alias, e.toString (), };\n+\t\t}\n+\t\telse if ((closest = StringDistance.getClosestLevenshteinDistance\n+\t\t\t(alias, keys, 0.5f)) == null)\n+\t\t{\n+\t\t\tmsg = \"invalid-plugin-aliases\";\n+\t\t\tparams = new Object[] { \n+\t\t\t\tval.getProperty (), alias, e.toString (), \n+\t\t\t\tnew TreeSet (Arrays.asList (keys)),\n+\t\t\t};\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tmsg = \"invalid-plugin-aliases-hint\";\n+\t\t\tparams = new Object[] { \n+\t\t\t\tval.getProperty (), alias, e.toString (), \n+\t\t\t\tnew TreeSet (Arrays.asList (keys)), closest,\n+\t\t\t};\n+\t\t}\n+\t\treturn new ParseException (_loc.get (msg, params), e);\n+\t}\n+\n+\n+\t/**\n+\t *\tConfigures the given object with the given properties by\n+\t *\tmatching the properties string to the object's setter\n+\t *\tmethods. The properties string should be in the form\n+\t *\t\"prop1=val1, prop2=val2 ...\". Does not validate that setter\n+\t *\tmethods exist for the properties.\n+\t *\n+\t *\t@throws\t\tRuntimeException on configuration error\n+\t */\n+\tpublic static void configureInstance (Object obj, Configuration conf, \n+\t\tString properties)\n+\t{\n+\t\tconfigureInstance (obj, conf, properties, null);\n+\t}\n+\n+\n+\t/**\n+\t *\tConfigures the given object with the given properties by\n+\t *\tmatching the properties string to the object's setter\n+\t *\tmethods. The properties string should be in the form\n+\t *\t\"prop1=val1, prop2=val2 ...\". Validates that setter methods\n+\t *\texist for the properties.\n+\t *\n+\t *\t@throws\t\tRuntimeException on configuration error\n+\t */\n+\tpublic static void configureInstance (Object obj, Configuration conf, \n+\t\tString properties, String configurationName)\n+\t{\n+\t\tif (obj == null)\n+\t\t\treturn;\n+\n+\t\tProperties props = null;\n+\t\tif (properties != null && properties.length () > 0)\n+\t\t\tprops = parseProperties (properties);\n+\t\tconfigureInstance (obj, conf, props, configurationName);\n+\t}\n+\n+\n+\t/**\n+\t *\tConfigures the given object with the given properties by\n+\t *\tmatching the properties string to the object's setter\n+\t *\tmethods. Does not validate that setter methods exist for the\n+\t *\tproperties.\n+\t *\n+\t *\t@throws\t\tRuntimeException on configuration error\n+\t */\n+\tpublic static void configureInstance (Object obj, Configuration conf, \n+\t\tProperties properties)\n+\t{\n+\t\tconfigureInstance (obj, conf, properties, null);\n+\t}\n+\n+\n+\t/**\n+\t *\tConfigures the given object with the given properties by\n+\t *\tmatching the properties string to the object's setter\n+\t *\tmethods. If <code>configurationName</code> is\n+\t *\tnon-<code>null</code>, validates that setter methods exist for\n+\t *\tthe properties.\n+\t *\n+\t *\t@throws\t\tRuntimeException on configuration error\n+\t */\n+\tpublic static void configureInstance (Object obj, Configuration conf, \n+\t\tProperties properties, String configurationName)\n+\t{\n+\t\tif (obj == null)\n+\t\t\treturn;\n+\n+\t\tOptions opts = null;\n+\t\tif (properties instanceof Options)\n+\t\t\topts = (Options) properties;\n+\t\telse if (properties != null)\n+\t\t{\n+\t\t\topts = new Options ();\n+\t\t\topts.putAll (properties);\t\n+\t\t}\n+\n+\t\tConfigurable configurable = null;\n+\t\tif (conf != null && obj instanceof Configurable)\n+\t\t\tconfigurable = (Configurable) obj;\n+\n+\t\tif (configurable != null)\n+\t\t{\n+\t\t\tconfigurable.setConfiguration (conf);\t\n+\t\t\tconfigurable.startConfiguration ();\n+\t\t}\n+\t\tif (opts != null)\n+\t\t{\n+\t\t\tMap invalidEntries = opts.setInto (obj);\n+\t\t\tif (obj instanceof GenericConfigurable)\n+\t\t\t\t((GenericConfigurable) obj).setInto (invalidEntries);\n+\n+\t\t\tif (!invalidEntries.isEmpty () && configurationName != null)\n+\t\t\t{\n+\t\t\t\tString msg = null;\n+\t\t\t\tString first = (String) invalidEntries.keySet ().iterator ()\n+\t\t\t\t\t.next ();\n+\t\t\t\tif (invalidEntries.keySet ().size () == 1 &&\n+\t\t\t\t\tfirst.indexOf ('.') == -1)\n+\t\t\t\t{\n+\t\t\t\t\t// if there's just one misspelling and this is not a\n+\t\t\t\t\t// path traversal, check for near misses.\n+\t\t\t\t\tCollection options =\n+\t\t\t\t\t\tOptions.findOptionsFor (obj.getClass ());\n+\t\t\t\t\tString close = StringDistance.getClosestLevenshteinDistance\n+\t\t\t\t\t\t(first, options, 0.75f);\n+\t\t\t\t\tif (close != null)\n+\t\t\t\t\t\tmsg = _loc.get (\"invalid-config-param-hint\",\n+\t\t\t\t\t\t\tnew Object[] {\n+\t\t\t\t\t\t\t\tconfigurationName,\n+\t\t\t\t\t\t\t\tobj.getClass (),\n+\t\t\t\t\t\t\t\tfirst,\n+\t\t\t\t\t\t\t\tclose,\n+\t\t\t\t\t\t\t\toptions,\n+\t\t\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\tif (msg == null)\n+\t\t\t\t{\n+\t\t\t\t\tmsg = _loc.get (\"invalid-config-params\", new String[] {\n+\t\t\t\t\t\tconfigurationName,\n+\t\t\t\t\t\tobj.getClass ().getName (),\n+\t\t\t\t\t\tinvalidEntries.keySet ().toString (),\n+\t\t\t\t\t\tOptions.findOptionsFor (obj.getClass ()).toString (),\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\t\t\t\tthrow new ParseException (msg);\n+\t\t\t}\n+\t\t}\n+\t\tif (configurable != null)\n+\t\t\tconfigurable.endConfiguration ();\n+\t}\n+\n+\n+\t/**\n+\t *\tTurn a set of properties into a comma-separated string.\n+\t */\n+\tpublic static String serializeProperties (Map map)\n+\t{\n+\t\tif (map == null || map.isEmpty ())\n+\t\t\treturn null;\n+\t\n+\t\tStringBuffer buf = new StringBuffer ();\n+\t\tMap.Entry entry;\n+\t\tString val;\n+\t\tfor (Iterator itr = map.entrySet ().iterator (); itr.hasNext ();)\n+\t\t{\n+\t\t\tentry = (Map.Entry) itr.next ();\n+\t\t\tif (buf.length () > 0)\n+\t\t\t\tbuf.append (\", \");\n+\t\t\tbuf.append (entry.getKey ()).append ('=');\n+\t\t\tval = String.valueOf (entry.getValue ());\n+\t\t\tif (val.indexOf (',') != -1)\n+\t\t\t\tbuf.append ('\"').append (val).append ('\"');\n+\t\t\telse\n+\t\t\t\tbuf.append (val);\n+\t\t}\n+\t\treturn buf.toString ();\n+\t}\n+\n+\n+\t/**\n+\t *\tParse a set of properties from a comma-separated string.\n+\t */\n+\tpublic static Options parseProperties (String properties)\n+\t{\n+\t\tOptions opts = new Options ();\n+\t\tif (properties == null)\n+\t\t\treturn opts;\n+\t\tproperties = properties.trim ();\n+\t\tif (properties.length () == 0)\n+\t\t\treturn opts;\n+\n+\t\ttry\n+\t\t{\n+\t\t\tString[] props = Strings.split (properties, \",\", 0);\n+\t\t\tint idx;\n+\t\t\tchar quote;\n+\t\t\tString prop;\n+\t\t\tString val;\n+\t\t\tfor (int i = 0; i < props.length; i++)\n+\t\t\t{\n+\t\t\t\tidx = props[i].indexOf ('=');\n+\t\t\t\tif (idx == -1)\n+\t\t\t\t{\n+\t\t\t\t\t// if the key is not assigned to any value, set the\n+\t\t\t\t\t// value to the same thing as the key, and continue.\n+\t\t\t\t\t// This permits GenericConfigurable instances to\n+\t\t\t\t\t// behave meaningfully. We might consider setting the\n+\t\t\t\t\t// value to some well-known \"value was not set, but\n+\t\t\t\t\t// key is present\" string so that instances getting\n+\t\t\t\t\t// values injected can differentiate between a mentioned\n+\t\t\t\t\t// property and one set to a particular value.\n+\t\t\t\t\tprop = props[i];\n+\t\t\t\t\tval = prop;\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\tprop = props[i].substring (0, idx).trim ();\n+\t\t\t\t\tval = props[i].substring (idx + 1).trim ();\n+\t\t\t\t}\n+\n+\t\t\t\t// if the value is quoted, read until the end quote\n+\t\t\t\tif (((val.startsWith (\"\\\"\") && val.endsWith (\"\\\"\"))\n+\t\t\t\t\t|| (val.startsWith (\"'\") && val.endsWith (\"'\")))\n+\t\t\t\t\t&& val.length () > 1)\n+\t\t\t\t\tval = val.substring (1, val.length () - 1);\n+\t\t\t\telse if (val.startsWith (\"\\\"\") || val.startsWith (\"'\"))\n+\t\t\t\t{\n+\t\t\t\t\tquote = val.charAt (0);\n+\t\t\t\t\tStringBuffer buf = new StringBuffer (val.substring (1));\n+\t\t\t\t\tint quotIdx;\n+\t\t\t\t\twhile (++i < props.length)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tbuf.append (\",\");\n+\n+\t\t\t\t\t\tquotIdx = props[i].indexOf (quote);\n+\t\t\t\t\t\tif (quotIdx != -1)\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tbuf.append (props[i].substring (0, quotIdx));\n+\t\t\t\t\t\t\tif (quotIdx + 1 < props[i].length ())\n+\t\t\t\t\t\t\t\tbuf.append (props[i].substring (quotIdx + 1));\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t\tbuf.append (props[i]);\n+\t\t\t\t\t}\n+\t\t\n+\t\t\t\t\tval = buf.toString ();\n+\t\t\t\t}\n+\n+\t\t\t\topts.put (prop, val);\n+\t\t\t}\n+\t\t\treturn opts;\n+\t\t}\n+\t\tcatch (RuntimeException re)\n+\t\t{\n+\t\t\tthrow new ParseException (_loc.get (\"prop-parse\", properties), re);\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tSet the given {@link Configuration} instance from the command line\n+\t *\toptions provided.  All property names of the given configuration are\n+\t *\trecognized; additionally, if a <code>properties</code> or \n+\t *\t<code>p</code> argument exists, the resource it\n+\t *\tpoints to will be loaded and set into the given configuration instance.\n+\t *\tIt can point to either a file or a resource name. \n+\t */\n+\tpublic static void populateConfiguration (Configuration conf, Options opts)\n+\t{\n+\t\tString props = opts.removeProperty (\"properties\", \"p\", null);\n+\t\tif (props != null && props.length () > 0)\n+\t\t{\n+\t\t\tFile file = new File (props);\n+\t\t\tConfigurationProvider provider;\n+\t\t\tif (file.isFile ())\n+\t\t\t\tprovider = load (file, null);\t\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tfile = new File (\"META-INF\" + File.separatorChar + props);\n+\t\t\t\tif (file.isFile ())\n+\t\t\t\t\tprovider = load (file, null);\n+\t\t\t\telse\n+\t\t\t\t\tprovider = load (props, null);\n+\t\t\t}\n+\t\t\tprovider.setInto (conf);\n+\t\t}\n+\t\topts.setInto (conf);\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn a {@link ConfigurationProvider} that has parsed system defaults,\n+\t *\tor null if no provider or defaults found.\n+\t */\n+\tpublic static ConfigurationProvider loadDefaults (ClassLoader loader)\n+\t{\n+\t\tif (loader == null)\n+\t\t\tloader = Thread.currentThread ().getContextClassLoader ();\n+\t\tClass[] impls = Services.getImplementorClasses\n+\t\t\t(ConfigurationProvider.class, loader);\n+\t\tConfigurationProvider provider = null;\n+\t\tStringBuffer errs = null;\n+\t\tfor (int i = 0; i < impls.length; i++)\n+\t\t{\n+\t\t\tprovider = newProvider (impls[i]);\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tif (provider != null && provider.loadDefaults (loader))\n+\t\t\t\t\treturn provider;\n+\t\t\t}\n+\t\t\tcatch (MissingResourceException mre)\n+\t\t\t{\n+\t\t\t\tthrow mre;\n+\t\t\t}\n+\t\t\tcatch (Exception e)\n+\t\t\t{\n+\t\t\t\tif (errs == null)\n+\t\t\t\t\terrs = new StringBuffer ();\n+\t\t\t\telse\n+\t\t\t\t\terrs.append (\", \");\n+\t\t\t\terrs.append (e.toString ());\n+\t\t\t}\n+\t\t}\n+\t\tif (errs != null)\n+\t\t\tthrow new MissingResourceException (errs.toString (),\n+\t\t\t\tConfigurations.class.getName (), \"defaults\");\n+\t\treturn null;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn a new new configuration provider instance of the given class,\n+\t *\tor null if the class cannot be instantiated.\n+\t */\n+\tprivate static ConfigurationProvider newProvider (Class cls)\n+\t{\n+\t\ttry\n+\t\t{\n+\t\t\treturn (ConfigurationProvider) cls.newInstance ();\n+\t\t}\n+\t\tcatch (InstantiationException e)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\t\tcatch (IllegalAccessException e)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn a {@link ConfigurationProvider} that has parsed the given \n+\t *\tresource.  Throws {@link MissingResourceException} if resource does\n+\t *\tnot exist.\n+\t */\n+\tpublic static ConfigurationProvider load (String resource, \n+\t\tClassLoader loader)\n+\t{\n+\t\tif (resource == null || resource.length () == 0)\n+\t\t\treturn null;\n+\n+\t\tif (loader == null)\n+\t\t\tloader = Thread.currentThread ().getContextClassLoader ();\n+\t\tClass[] impls = Services.getImplementorClasses\n+\t\t\t(ConfigurationProvider.class, loader);\n+\t\tConfigurationProvider provider = null;\n+\t\tStringBuffer errs = null;\n+\t\tfor (int i = 0; i < impls.length; i++)\n+\t\t{\n+\t\t\tprovider = newProvider (impls[i]);\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tif (provider != null && provider.load (resource, loader))\n+\t\t\t\t\treturn provider;\n+\t\t\t}\n+\t\t\tcatch (MissingResourceException mre)\n+\t\t\t{\n+\t\t\t\tthrow mre;\n+\t\t\t}\n+\t\t\tcatch (Exception e)\n+\t\t\t{\n+\t\t\t\tif (errs == null)\n+\t\t\t\t\terrs = new StringBuffer ();\n+\t\t\t\telse\n+\t\t\t\t\terrs.append (\", \");\n+\t\t\t\terrs.append (e.toString ());\n+\t\t\t}\n+\t\t}\n+\t\tString msg = (errs == null) ? resource : errs.toString ();\n+\t\tthrow new MissingResourceException (msg,\n+\t\t\tConfigurations.class.getName (), resource);\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn a {@link ConfigurationProvider} that has parsed the given \n+\t *\tfile.  Throws {@link MissingResourceException} if file does\n+\t *\tnot exist.\n+\t */\n+\tpublic static ConfigurationProvider load (File file, ClassLoader loader)\n+\t{\n+\t\tif (file == null)\n+\t\t\treturn null;\n+\n+\t\tif (loader == null)\n+\t\t\tloader = Thread.currentThread ().getContextClassLoader ();\n+\t\tClass[] impls = Services.getImplementorClasses\n+\t\t\t(ConfigurationProvider.class, loader);\n+\t\tConfigurationProvider provider = null;\n+\t\tStringBuffer errs = null;\n+\t\tfor (int i = 0; i < impls.length; i++)\n+\t\t{\n+\t\t\tprovider = newProvider (impls[i]);\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tif (provider != null && provider.load (file))\n+\t\t\t\t\treturn provider;\n+\t\t\t}\n+\t\t\tcatch (MissingResourceException mre)\n+\t\t\t{\n+\t\t\t\tthrow mre;\n+\t\t\t}\n+\t\t\tcatch (Exception e)\n+\t\t\t{\n+\t\t\t\tif (errs == null)\n+\t\t\t\t\terrs = new StringBuffer ();\n+\t\t\t\telse\n+\t\t\t\t\terrs.append (\", \");\n+\t\t\t\terrs.append (e.toString ());\n+\t\t\t}\n+\t\t}\n+\t\tString msg = (errs == null) ? file.toString () : errs.toString ();\n+\t\tthrow new MissingResourceException (msg,\n+\t\t\tConfigurations.class.getName (), file.toString ());\n+\t}\n+\n+\n+\t/**\n+\t *\tLooks up the given name in JNDI.  If the name is null, null is \n+\t *\treturned.\n+\t */\n+\tpublic static Object lookup (String name)\n+\t{\n+\t\tif (name == null || name.length () == 0)\n+\t\t\treturn null;\n+\n+\t\tContext ctx = null;\n+\t\ttry\n+\t\t{\n+\t\t\tctx = new InitialContext ();\n+\t\t\treturn ctx.lookup (name);\t\n+\t\t}\n+\t\tcatch (NamingException ne)\n+\t\t{\n+\t\t\tthrow new NestableRuntimeException (_loc.get (\"naming-err\", name), \n+\t\t\t\tne);\n+\t\t}\n+\t\tfinally\n+\t\t{\n+\t\t\tif (ctx != null)\n+\t\t\t\ttry { ctx.close (); } catch (Exception e) {}\n+\t\t}\n+\t}\n+}"},{"sha":"9697e654d8527ae54303674cf22310f9ec288f9a","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/DoubleValue.java","status":"added","additions":85,"deletions":0,"changes":85,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/DoubleValue.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/DoubleValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/DoubleValue.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+\n+/**\n+ *\tA double {@link Value}.\n+ *\n+ *\t@author\tMarc Prud'hommeaux\n+ */\n+public class DoubleValue\n+\textends Value\n+{\n+ \tprivate double value;\n+\n+\n+\tpublic DoubleValue (String prop)\n+\t{\n+\t\tsuper (prop);\n+\t}\n+\n+\n+\tpublic Class getValueType ()\n+\t{\n+\t\treturn double.class;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe internal value.\n+\t */\n+\tpublic void set (double value)\n+\t{\n+\t\tdouble oldValue = this.value;\n+\t\tthis.value = value;\n+\t\tif (oldValue != value)\n+\t\t\tvalueChanged ();\n+\t}\n+\n+\n+\t/**\n+\t *\tThe internal value.\n+\t */\n+\tpublic double get ()\n+\t{\n+\t\treturn value;\n+\t}\n+\n+\n+\tprotected String getInternalString ()\n+\t{\n+\t\treturn String.valueOf (value);\n+\t}\n+\n+\n+\tprotected void setInternalString (String val)\n+\t{\n+\t\tif (val == null || val.length () == 0)\n+\t\t\tset (0D);\n+\t\telse\n+\t\t\tset (Double.parseDouble (val));\n+\t}\n+\n+\n+\tprotected void setInternalObject (Object obj)\n+\t{\n+\t\tif (obj == null)\n+\t\t\tset (0D);\n+\t\telse\n+\t\t\tset (((Number) obj).doubleValue ());\n+\t}\n+}"},{"sha":"3a66a0fd059444d5aeed6a984bdd624cc33e6bf7","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/FileValue.java","status":"added","additions":85,"deletions":0,"changes":85,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/FileValue.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/FileValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/FileValue.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+import java.io.*;\n+\n+import org.apache.commons.lang.*;\n+\n+\n+/**\n+ *\tA {@link File} {@link Value}.\n+ *\n+ *\t@author\tMarc Prud'hommeaux\n+ */\n+public class FileValue\n+\textends Value\n+{\n+ \tprivate File value;\n+\n+\n+\tpublic FileValue (String prop)\n+\t{\n+\t\tsuper (prop);\n+\t}\n+\n+\n+\tpublic Class getValueType ()\n+\t{\n+\t\treturn File.class;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe internal value.\n+\t */\n+\tpublic void set (File value)\n+\t{\n+\t\tFile oldValue = this.value;\n+\t\tthis.value = value;\n+\t\tif (!ObjectUtils.equals (oldValue, value))\n+\t\t\tvalueChanged ();\n+\t}\n+\n+\n+\t/**\n+\t *\tThe internal value.\n+\t */\n+\tpublic File get ()\n+\t{\n+\t\treturn value;\n+\t}\n+\n+\n+\tprotected String getInternalString ()\n+\t{\n+\t\treturn (value == null) ? null : value.getAbsolutePath ();\n+\t}\n+\n+\n+\tprotected void setInternalString (String val)\n+\t{\n+\t\tset (new File (val));\n+\t}\n+\n+\n+\tprotected void setInternalObject (Object obj)\n+\t{\n+\t\tset ((File) obj);\n+\t}\n+}\n+\n+"},{"sha":"4e878281d608beda8bc0411d254183087d54c5d5","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/GenericConfigurable.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/GenericConfigurable.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/GenericConfigurable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/GenericConfigurable.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+\n+import java.util.*;\n+\n+\n+/**\n+ *\t<p>Implementations of this interface may perform additional\n+ *\tgeneric configuration with any key-value pairs that cannot be set\n+ *\tinto the object via the normal {@link org.apache.openjpa.lib.util.Options#setInto}\n+ *\tmeans.</p>\n+ *\n+ *\t@author\tPatrick Linskey\n+ */\n+public interface GenericConfigurable\n+{\n+\t/**\n+\t *\tPerform any generic configuration based on the data in\n+\t *\t<code>m</code>. This method should remove any values in\n+\t *\t<code>m</code> that have been successfully processed; if any\n+\t *\tvalues remain in <code>m</code> after this method is executed,\n+\t *\tan exception will be thrown identifying those key-value pairs\n+\t *\tas invalid.\n+\t */\n+\tpublic void setInto (Map m);\n+}"},{"sha":"38bb78d78b94e326a0c22c86f9b4593fb705fb08","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/IntValue.java","status":"added","additions":85,"deletions":0,"changes":85,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/IntValue.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/IntValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/IntValue.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+\n+/**\n+ *\tAn int {@link Value}.\n+ *\n+ *\t@author\tMarc Prud'hommeaux\n+ */\n+public class IntValue\n+\textends Value\n+{\n+ \tprivate int value;\n+\n+\n+\tpublic IntValue (String prop)\n+\t{\n+\t\tsuper (prop);\n+\t}\n+\n+\n+\tpublic Class getValueType ()\n+\t{\n+\t\treturn int.class;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe internal value.\n+\t */\n+\tpublic void set (int value)\n+\t{\n+\t\tint oldValue = this.value;\n+\t\tthis.value = value;\n+\t\tif (value != oldValue)\n+\t\t\tvalueChanged ();\n+\t}\n+\n+\n+\t/**\n+\t *\tThe internal value.\n+\t */\n+\tpublic int get ()\n+\t{\n+\t\treturn this.value;\n+\t}\n+\n+\n+\tprotected String getInternalString ()\n+\t{\n+\t\treturn String.valueOf (this.value);\n+\t}\n+\n+\n+\tprotected void setInternalString (String val)\n+\t{\n+\t\tif (val == null || val.length () == 0)\n+\t\t\tset (0);\n+\t\telse\n+\t\t\tset (Integer.parseInt (val));\n+\t}\n+\n+\n+\tprotected void setInternalObject (Object obj)\n+\t{\n+\t\tif (obj == null)\n+\t\t\tset (0);\n+\t\telse\n+\t\t\tset (((Number) obj).intValue ());\n+\t}\n+}"},{"sha":"c56f089d8c6352e50a2ee4f3e6627e01b7a47f50","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/MapConfigurationProvider.java","status":"added","additions":113,"deletions":0,"changes":113,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/MapConfigurationProvider.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/MapConfigurationProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/MapConfigurationProvider.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.log.*;\n+import org.apache.openjpa.lib.util.*;\n+\n+\n+/**\n+ *\t<p>Simple configuration provider that sets configuration based on a \n+ *\tprovided map.</p>\n+ *\n+ *\t@author\t\tAbe White \n+ *\t@nojavadoc\n+ */\n+public class MapConfigurationProvider\n+\timplements ConfigurationProvider\n+{\n+\tprivate static final Localizer _loc = Localizer.forPackage\n+\t\t(MapConfigurationProvider.class);\n+\n+\tprivate Map _props = null;\n+\n+\n+\t/**\n+\t *\tConstruct with null properties.\n+\t */\n+\tpublic MapConfigurationProvider ()\n+\t{\n+\t}\n+\n+\n+\t/**\n+\t *\tConstructor; supply properties map.\n+\t */\n+\tpublic MapConfigurationProvider (Map props)\n+\t{\n+\t\taddProperties (props);\n+\t}\n+\n+\n+\tpublic boolean loadDefaults (ClassLoader loader)\n+\t\tthrows Exception\n+\t{\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean load (String resource, ClassLoader loader)\n+\t\tthrows Exception\n+\t{\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean load (File file)\n+\t\tthrows Exception\n+\t{\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic Map getProperties ()\n+\t{\n+\t\treturn _props;\n+\t}\n+\n+\n+\tpublic void addProperties (Map props)\n+\t{\n+\t\tif (props == null || props.isEmpty ())\n+\t\t\treturn;\n+\t\tif (_props == null)\n+\t\t\t_props = props;\n+\t\telse\n+\t\t\t_props.putAll (props);\n+\t}\n+\n+\n+\tpublic void setInto (Configuration conf)\n+\t{\n+\t\tsetInto (conf, conf.getConfigurationLog ());\n+\t}\n+\n+\n+\t/**\n+\t *\tSet properties into configuration.  If the log is non-null, will log\n+\t *\ta TRACE message about the set.\n+\t */\n+\tprotected void setInto (Configuration conf, Log log)\n+\t{\n+\t\tif (log != null && log.isTraceEnabled ())\n+\t\t\tlog.trace (_loc.get (\"conf-load\", _props));\n+\t\tconf.fromProperties (_props);\n+\t}\n+}"},{"sha":"57b10968d40dde76373d8873e2b92bf459fbd26d","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/NoneConfigurationProvider.java","status":"added","additions":81,"deletions":0,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/NoneConfigurationProvider.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/NoneConfigurationProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/NoneConfigurationProvider.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import org.apache.commons.collections.*;\n+\n+\n+/**\n+ *\t<p>No-op configuration provider.</p>\n+ *\n+ *\t@author\t\tAbe White \n+ *\t@nojavadoc\n+ */\n+public class NoneConfigurationProvider\n+\timplements ConfigurationProvider\n+{\n+\tprivate static final NoneConfigurationProvider _instance = \n+\t\tnew NoneConfigurationProvider ();\n+\n+\n+\t/**\n+\t *\tSingleton.\n+\t */\n+\tpublic static NoneConfigurationProvider getInstance ()\n+\t{\n+\t\treturn _instance;\n+\t}\n+\n+\n+\tpublic boolean loadDefaults (ClassLoader loader)\n+\t{\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean load (String resource, ClassLoader loader)\n+\t{\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean load (File file)\n+\t{\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic Map getProperties ()\n+\t{\n+\t\treturn MapUtils.EMPTY_MAP;\n+\t}\n+\n+\n+\tpublic void addProperties (Map props)\n+\t{\n+\t\tif (props != null && !props.isEmpty ())\n+\t\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setInto (Configuration conf)\n+\t{\n+\t}\n+}"},{"sha":"412bac4adb9ea720e106a975872b1322115d0cd9","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/ObjectValue.java","status":"added","additions":114,"deletions":0,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/ObjectValue.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/ObjectValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/ObjectValue.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+\n+import org.apache.commons.lang.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+\n+\n+/**\n+ *\t<p>An object {@link Value}.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ */\n+public class ObjectValue\n+\textends Value\n+{\n+\tprivate static final Localizer _loc = Localizer.forPackage \n+\t\t(ObjectValue.class);\n+\n+\tprivate Object _value = null;\n+\n+\n+\tpublic ObjectValue (String prop)\n+\t{\n+\t\tsuper (prop);\n+\t}\n+\n+\n+\t/**\n+\t *\tThe internal value.\n+\t */\n+\tpublic Object get ()\n+\t{\n+\t\treturn _value;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe internal value.\n+\t */\n+\tpublic void set (Object obj)\n+\t{\n+\t\tset (obj, false);\n+\t}\n+\n+\n+\t/**\n+\t *\tThe internal value.\n+\t *\n+\t *\t@param\tderived\tif true, this value was derived from other properties\n+\t */\n+\tpublic void set (Object obj, boolean derived)\n+\t{\n+\t\tObject oldValue = _value;\n+\t\t_value = obj;\n+\t\tif (!derived && !ObjectUtils.equals (obj, oldValue))\n+\t\t{\n+\t\t\tobjectChanged ();\n+\t\t\tvalueChanged ();\n+\t\t}\n+\t}\n+\n+\n+\tpublic Class getValueType ()\n+\t{\n+\t\treturn Object.class;\n+\t}\n+\n+\n+\t/**\n+\t *\tImplement this method to synchronize internal data with the new\n+\t *\tobject value.\n+\t */\n+\tprotected void objectChanged ()\n+\t{\n+\t}\n+\n+\n+\tprotected String getInternalString ()\n+\t{\n+\t\treturn null;\n+\t}\n+\n+\n+\tprotected void setInternalString (String str)\n+\t{\n+\t\tif (str == null)\n+\t\t\tset (null);\n+\t\telse\n+\t\t\tthrow new IllegalArgumentException (_loc.get (\"cant-set-string\", \n+\t\t\t\tgetProperty ()));\n+\t}\n+\n+\n+\tprotected void setInternalObject (Object obj)\n+\t{\n+\t\tset (obj);\n+\t}\n+} "},{"sha":"99032dbad4745d8de91241b212473206892003b7","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/PluginListValue.java","status":"added","additions":263,"deletions":0,"changes":263,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/PluginListValue.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/PluginListValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/PluginListValue.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+\n+/**\n+ *\t<p>A list of plugins.  Defaults and aliases on plugin lists apply only\n+ *\tto individual class names.</p>\n+ *\n+ *\t@see\tPluginValue\n+ *\t@author\tAbe White\n+ */\n+public class PluginListValue\n+\textends ObjectValue\n+{\n+\tprivate static final String[] EMPTY = new String[0];\n+\n+\tprivate String[] _names\t= EMPTY;\n+\tprivate String[] _props\t= EMPTY;\t\n+\n+\n+\tpublic PluginListValue (String prop)\n+\t{\n+\t\tsuper (prop);\n+\t}\n+\n+\t\n+\t/**\n+\t *\tThe plugin class names.\n+\t */\n+\tpublic String[] getClassNames ()\n+\t{\n+\t\treturn _names;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe plugin class names.\n+\t */\n+\tpublic void setClassNames (String[] names)\n+\t{\n+\t\tif (names == null)\n+\t\t\tnames = EMPTY;\n+\t\t_names = names;\n+\t\tset (null, true);\n+\t\tvalueChanged ();\n+\t}\n+\n+\t\n+\t/**\n+\t *\tThe plugin properties.\n+\t */\n+\tpublic String[] getProperties ()\n+\t{\n+\t\treturn _props;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe plugin properties.\n+\t */\n+\tpublic void setProperties (String[] props)\n+\t{\n+\t\tif (props == null)\n+\t\t\tprops = EMPTY;\n+\t\t_props = props;\n+\t\tset (null, true);\n+\t\tvalueChanged ();\n+\t}\n+\n+\n+\t/** \n+\t *  Instantiate the plugins as instances of the given class.\n+\t */\n+\tpublic Object[] instantiate (Class elemType, Configuration conf)\n+\t{\n+\t\treturn instantiate (elemType, conf, true);\n+\t}\n+\n+\n+\t/** \n+\t *  Instantiate the plugins as instances of the given class.\n+\t */\n+\tpublic Object[] instantiate (Class elemType, Configuration conf,\n+\t\tboolean fatal)\n+\t{\n+\t\tObject[] ret;\n+\t\tif (_names.length == 0)\n+\t\t\tret = (Object[]) Array.newInstance (elemType, 0);\n+\t\telse\n+\t\t{\n+\t\t\tret = (Object[]) Array.newInstance (elemType, _names.length);\n+\t\t\tfor (int i = 0; i < ret.length; i++)\n+\t\t\t{\n+\t\t\t\tret[i] = newInstance (_names[i], elemType, conf, fatal);\n+\t\t\t\tConfigurations.configureInstance (ret[i], conf, _props[i], \n+\t\t\t\t\tgetProperty ());\n+\t\t\t}\n+\t\t}\n+\t\tset (ret, true);\n+\t\treturn ret;\n+\t}\n+\n+\n+\t/**\n+\t *\tAllow subclasses to instantiate additional plugins.  This method does\n+\t *\tnot perform configuration.\n+\t */\n+\tpublic Object newInstance (String clsName, Class type, \n+\t\tConfiguration conf, boolean fatal)\n+\t{\n+\t\treturn Configurations.newInstance (clsName, this, conf,\n+\t\t\ttype.getClassLoader (), fatal);\n+\t}\n+\n+\n+\t/**\n+\t *\tOverride to recognize aliases of the class name without the attached\t\n+\t *\tproperties string.\n+\t */\n+\tpublic String getString ()\n+\t{\n+\t\tif (_names.length == 0)\n+\t\t\treturn null;\n+\n+\t\tStringBuffer buf = new StringBuffer ();\n+\t\tfor (int i = 0; i < _names.length; i++)\n+\t\t{\n+\t\t\tif (i > 0)\n+\t\t\t\tbuf.append (\", \");\n+\t\t\tbuf.append (Configurations.getPlugin (alias(_names[i]), _props[i]));\n+\t\t}\n+\t\tif (buf.length () == 0)\n+\t\t\treturn null;\n+\t\treturn buf.toString ();\n+\t}\n+\n+\n+\t/**\n+\t *\tOverride to recognize aliases of the plugin name without the attached\t\n+\t *\tproperties string.\n+\t */\n+\tpublic void setString (String str)\n+\t{\n+\t\tif (str == null || str.length () == 0)\n+\t\t\tstr = getDefault ();\n+\t\tif (str == null || str.length () == 0)\n+\t\t{\n+\t\t\t_names = EMPTY;\n+\t\t\t_props = EMPTY;\n+\t\t\tset (null, true);\n+\t\t\tvalueChanged ();\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// split up the string; each element might be a class name, or a\n+\t\t// class name with properties settings\n+\t\tList plugins = new ArrayList ();\n+\t\tStringBuffer plugin = new StringBuffer ();\n+\t\tboolean inParen = false;\n+\t\tchar c;\n+\t\tfor (int i = 0; i < str.length (); i++)\n+\t\t{\n+\t\t\tc = str.charAt (i);\n+\t\t\tswitch (c)\n+\t\t\t{\n+\t\t\tcase '(':\n+\t\t\t\tinParen = true;\n+\t\t\t\tplugin.append (c);\n+\t\t\t\tbreak;\n+\t\t\tcase ')':\n+\t\t\t\tinParen = false;\n+\t\t\t\tplugin.append (c);\n+\t\t\t\tbreak;\n+\t\t\tcase ',':\n+\t\t\t\tif (inParen)\n+\t\t\t\t\tplugin.append (c);\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\tplugins.add (plugin.toString ());\n+\t\t\t\t\tplugin = new StringBuffer ();\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tplugin.append (c);\n+\t\t\t}\n+\t\t}\n+\t\tif (plugin.length () > 0)\n+\t\t\tplugins.add (plugin.toString ());\n+\n+\t\t// parse each plugin element into its name and properties\n+\t\tList names = new ArrayList ();\n+\t\tList props = new ArrayList ();\n+\t\tString clsName;\n+\t\tfor (int i = 0; i < plugins.size (); i++)\n+\t\t{\n+\t\t\tstr = (String) plugins.get (i);\n+\t\t\tclsName = unalias (Configurations.getClassName (str));\n+\t\t\tif (clsName != null)\n+\t\t\t{\n+\t\t\t\tnames.add (clsName);\n+\t\t\t\tprops.add (Configurations.getProperties (str));\n+\t\t\t}\n+\t\t}\n+\t\t_names = (String[]) names.toArray (new String[names.size ()]);\n+\t\t_props = (String[]) props.toArray (new String[props.size ()]);\n+\t\tset (null, true);\n+\t\tvalueChanged ();\n+\t}\n+\n+\n+\tpublic Class getValueType ()\n+\t{\n+\t\treturn Object[].class;\n+\t}\n+\n+\n+\tprotected void objectChanged ()\n+\t{\n+\t\tObject[] vals = (Object[]) get ();\n+\t\tif (vals == null || vals.length == 0)\n+\t\t\t_names = EMPTY;\n+\t\telse\n+\t\t{\n+\t\t\t_names = new String[vals.length];\n+\t\t\tfor (int i = 0; i < vals.length; i++)\n+\t\t\t\t_names[i] = (vals[i] == null) ? null \n+\t\t\t\t\t: vals[i].getClass ().getName ();\n+\t\t}\n+\t\t_props = EMPTY;\n+\t}\n+\n+\n+\tprotected String getInternalString ()\n+\t{\n+\t\t// should never get called\n+\t\tthrow new IllegalStateException ();\n+\t}\n+\n+\n+\tprotected void setInternalString (String str)\n+\t{\n+\t\t// should never get called\n+\t\tthrow new IllegalStateException ();\n+\t}\n+}"},{"sha":"fabd56053f75d69a99f0c27ae7dfb0ec9eee9421","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/PluginValue.java","status":"added","additions":202,"deletions":0,"changes":202,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/PluginValue.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/PluginValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/PluginValue.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+\n+import org.apache.commons.lang.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+\n+\n+/**\n+ *\t<p>A plugin {@link Value} consisting of plugin name and properties.  \n+ *\tPlugins should be specified in the form:<br /> \n+ *\t<code>&lt;plugin-name&gt;(&lt;prop1&gt;=&lt;val1&gt;, ...)</code><br />\n+ *\tBoth the plugin name and prop list are optional, so that the following\n+ *\tforms are also valid:<br />\n+ *\t<code>&lt;plugin-name&gt;</code><br />\n+ *\t<code>&lt;prop1&gt;=&lt;val1&gt; ...</code></p>\n+ *\n+ *\t<p>Defaults and aliases on plugin values apply only to the plugin name.</p>\n+ *\n+ *\t@author\tAbe White\n+ */\n+public class PluginValue\n+\textends ObjectValue\n+{\n+\tprivate static final Localizer _loc = Localizer.forPackage\n+\t\t(PluginValue.class);\n+\n+\tprivate final boolean\t_singleton;\n+\tprivate String \t\t\t_name \t= null;\n+\tprivate String \t\t\t_props \t= null;\n+\n+\n+\tpublic PluginValue (String prop, boolean singleton)\n+\t{\n+\t\tsuper (prop);\n+\t\t_singleton = singleton;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhether this value is a singleton.\n+\t */\n+\tpublic boolean isSingleton ()\n+\t{\n+\t\treturn _singleton;\n+\t}\n+\n+\t\n+\t/**\n+\t *\tThe plugin class name.\n+\t */\n+\tpublic String getClassName ()\n+\t{\n+\t\treturn _name;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe plugin class name.\n+\t */\n+\tpublic void setClassName (String name)\n+\t{\n+\t\tString oldName = _name;\n+\t\t_name = name;\n+\t\tif (!StringUtils.equals (oldName, name))\n+\t\t{\n+\t\t\tif (_singleton)\n+\t\t\t\tset (null, true);\n+\t\t\tvalueChanged ();\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tThe plugin properties.\n+\t */\n+\tpublic String getProperties ()\n+\t{\n+\t\treturn _props;\t\n+\t}\n+\n+\n+\t/**\n+\t *\tThe plugin properties.\n+\t */\n+\tpublic void setProperties (String props)\n+\t{\n+\t\tString oldProps = _props;\n+\t\t_props = props;\n+\t\tif (!StringUtils.equals (oldProps, props))\n+\t\t{\n+\t\t\tif (_singleton)\n+\t\t\t\tset (null, true);\n+\t\t\tvalueChanged ();\n+\t\t}\n+\t}\n+\n+\n+\t/** \n+\t *  Instantiate the plugin as an instance of the given class. Equivalent\n+\t *\tto <code>instantiate (type, conf, true)</code>.\n+\t */\n+\tpublic Object instantiate (Class type, Configuration conf)\n+\t{\n+\t\treturn instantiate (type, conf, true);\n+\t}\n+\n+\n+\t/** \n+\t *  Instantiate the plugin as an instance of the given class.\n+\t */\n+\tpublic Object instantiate (Class type, Configuration conf, boolean fatal)\n+\t{ \n+\t\tObject obj = newInstance (_name, type, conf, true);\n+\t\tConfigurations.configureInstance (obj, conf, _props, \n+\t\t\t(fatal) ? getProperty () : null);\n+\t\tif (_singleton)\n+\t\t\tset (obj, true);\n+\t\treturn obj;\n+\t}\n+\n+\n+\t/**\n+\t *\tAllow subclasses to instantiate additional plugins.  This method does\n+\t *\tnot perform configuration.\n+\t */\n+\tpublic Object newInstance (String clsName, Class type, \n+\t\tConfiguration conf, boolean fatal)\n+\t{\n+\t\treturn Configurations.newInstance (clsName, this, conf,\n+\t\t\ttype.getClassLoader (), fatal);\n+\t}\n+\n+\n+\tpublic void set (Object obj, boolean derived)\n+\t{\n+\t\tif (!_singleton)\n+\t\t\tthrow new IllegalStateException (_loc.get (\"not-singleton\",\n+\t\t\t\tgetProperty ()));\n+\t\tsuper.set (obj, derived);\n+\t}\n+\n+\n+\tpublic String getString ()\n+\t{\n+\t\treturn Configurations.getPlugin (alias (_name), _props);\n+\t}\n+\n+\n+\tpublic void setString (String str)\n+\t{\n+\t\t_name = Configurations.getClassName (str);\n+\t\t_name = unalias (_name);\n+\t\t_props = Configurations.getProperties (str);\n+\t\tif (_singleton)\n+\t\t\tset (null, true);\n+\t\tvalueChanged ();\n+\t}\n+\n+\n+\tpublic Class getValueType ()\n+\t{\n+\t\treturn Object.class;\n+\t}\n+\n+\n+\tprotected void objectChanged ()\n+\t{\n+\t\tObject obj = get ();\n+\t\t_name = (obj == null) ? unalias (null) : obj.getClass ().getName ();\n+\t\t_props = null;\n+\t}\n+\n+\n+\tprotected String getInternalString ()\n+\t{\n+\t\t// should never get called\n+\t\tthrow new IllegalStateException ();\n+\t}\n+\n+\n+\tprotected void setInternalString (String str)\n+\t{\n+\t\t// should never get called\n+\t\tthrow new IllegalStateException ();\n+\t}\n+}"},{"sha":"27f75a83b4ac5a79785ab2604f8d20aa03ce2f30","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/StringListValue.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/StringListValue.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/StringListValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/StringListValue.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+\n+import serp.util.*;\n+\n+\n+/**\n+ *\t<p>A comma-separated list of string values.</p>\n+ *\n+ *\t@author\tAbe White\n+ */\n+public class StringListValue\n+\textends Value\n+{\n+\tpublic static final String[] EMPTY = new String[0];\n+\n+ \tprivate String[] _values = EMPTY;\n+\n+\n+\tpublic StringListValue (String prop)\n+\t{\n+\t\tsuper (prop);\n+\t}\n+\n+\n+\t/**\n+\t *\tThe internal value.\n+\t */\n+\tpublic void set (String[] values)\n+\t{\n+\t\t_values = (values == null) ? EMPTY : values;\n+\t\tvalueChanged ();\n+\t}\n+\n+\n+\t/**\n+\t *\tThe internal value.\n+\t */\n+\tpublic String[] get ()\n+\t{\n+\t\treturn _values;\n+\t}\n+\n+\n+\tpublic Class getValueType ()\n+\t{\n+\t\treturn String[].class;\n+\t}\n+\n+\n+\tprotected String getInternalString ()\n+\t{\n+\t\treturn Strings.join (_values, \", \");\n+\t}\n+\n+\n+\tprotected void setInternalString (String val)\n+\t{\n+\t\tString[] vals = Strings.split (val, \",\", 0);\n+\t\tif (vals != null)\n+\t\t\tfor (int i = 0; i < vals.length; i++)\n+\t\t\t\tvals[i] = vals[i].trim ();\n+\t\tset (vals);\n+\t}\n+\n+\n+\tprotected void setInternalObject (Object obj)\n+\t{\n+\t\tset ((String[]) obj);\n+\t}\n+}\n+"},{"sha":"6f816d46e716e1a3a7680fb10a70f693d9a4120d","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/StringValue.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/StringValue.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/StringValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/StringValue.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+import org.apache.commons.lang.*;\n+\n+\n+/**\n+ *\tA string {@link Value}.\n+ *\n+ *\t@author\tMarc Prud'hommeaux\n+ */\n+public class StringValue\n+\textends Value\n+{\n+ \tprivate String value;\n+\n+\n+\tpublic StringValue (String prop)\n+\t{\n+\t\tsuper (prop);\n+\t}\n+\n+\n+\tpublic Class getValueType ()\n+\t{\n+\t\treturn String.class;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe internal value.\n+\t */\n+\tpublic String get ()\n+\t{\n+\t\treturn value;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe internal value.\n+\t */\n+\tpublic void set (String value)\n+\t{\n+\t\tString oldValue = this.value;\n+\t\tthis.value = value;\n+\t\tif (!StringUtils.equals (value, oldValue))\n+\t\t\tvalueChanged ();\n+\t}\n+\n+\n+\tprotected String getInternalString ()\n+\t{\n+\t\treturn get ();\n+\t}\n+\n+\n+\tprotected void setInternalString (String val)\n+\t{\n+\t\tset (val);\n+\t}\n+\n+\n+\tprotected void setInternalObject (Object obj)\n+\t{\n+\t\tset ((String) obj);\n+\t}\n+}\n+"},{"sha":"498352660827e0265b321f0034b18e919d1af2d8","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/Value.java","status":"added","additions":378,"deletions":0,"changes":378,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/Value.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/Value.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/Value.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+\n+import java.util.*;\n+\n+import org.apache.commons.lang.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+\n+\n+/** \n+ *  A configuration value.\n+ *  \n+ *  @author  Marc Prud'hommeaux\n+ */\n+public abstract class Value\n+\timplements Cloneable\n+{\n+\tprivate static final String[] EMPTY_ALIASES = new String[0];\n+\tprivate static final Localizer s_loc = Localizer.forPackage (Value.class);\n+\n+\tprivate String \t\t\tprop\t= null;\n+\tprivate String \t\t\tdef \t= null;\n+\tprivate String[] \t\taliases\t= null;\n+\tprivate ValueListener\tlisten\t= null;\n+\tprivate boolean\t\t\taliasListComprehensive = false;\n+\n+\n+\t/**\n+\t *  Constructor.  Supply the property name.\n+\t *\n+\t *\t@see\t#setProperty\n+\t */\n+\tpublic Value (String prop)\n+\t{\n+\t\tsetProperty (prop);\n+\t}\n+\n+\n+\t/**\n+\t *\tDefault constructor.\n+\t */\n+\tpublic Value ()\n+\t{\n+\t}\n+\n+\n+\t/** \n+\t *  The property name that will be used when setting or\n+\t *  getting this value in a {@link Map}.\n+\t */\n+\tpublic String getProperty ()\n+\t{\n+\t\treturn prop;\n+\t}\n+\n+\n+\t/** \n+\t *  The property name that will be used when setting or\n+\t *  getting this value in a {@link Map}.\n+\t */\n+\tpublic void setProperty (String prop)\n+\t{\n+\t\tthis.prop = prop;\n+\t}\n+\n+\n+\t/**\n+\t *\tAliases for the value in the form key1, value1, key2, value2, ...\n+\t *\tAll alias values must be in string form.\n+\t */\n+\tpublic String[] getAliases ()\n+\t{\n+\t\treturn (aliases == null) ? EMPTY_ALIASES : aliases;\n+\t}\n+\n+\n+\t/**\n+\t *\tAliases for the value in the form key1, value1, key2, value2, ...\n+\t *\tAll alias values must be in string form.\n+\t */\n+\tpublic void setAliases (String[] aliases)\n+\t{\n+\t\tthis.aliases = aliases;\n+\t}\n+\n+\n+\t/**\n+\t *\tReplaces an existing alias, or adds the given alias to the front of the\n+\t *\talias list if it does not already exist.  All alias values must be in \n+\t *\tstring form.\n+\t */\n+\tpublic void setAlias (String key, String value)\n+\t{\n+\t\tString[] aliases = getAliases ();\n+\t\tfor (int i = 0; i < aliases.length; i += 2)\n+\t\t{\n+\t\t\tif (key.equals (aliases[i]))\n+\t\t\t{\n+\t\t\t\taliases[i + 1] = value;\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// add as new alias\n+\t\tString[] newAliases = new String[aliases.length + 2];\n+\t\tSystem.arraycopy (aliases, 0, newAliases, 2, aliases.length);\n+\t\tnewAliases[0] = key;\n+\t\tnewAliases[1] = value;\n+\t\tthis.aliases = newAliases;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhether or not the alias list defines all possible settings for this\n+\t *\tvalue. If so, an error will be generated when attempting to invoke\n+\t *\tany method on this value with an unknown option.\n+\t */\n+\tpublic boolean isAliasListComprehensive ()\n+\t{\n+\t\treturn aliasListComprehensive;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhether or not the alias list defines all possible settings for this\n+\t *\tvalue. If so, an error will be generated when attempting to invoke\n+\t *\tany method on this value with an unknown option.\n+\t */\n+\tpublic void setAliasListComprehensive (boolean aliasListIsComprehensive)\n+\t{\n+\t\tthis.aliasListComprehensive = aliasListIsComprehensive;\n+\t}\n+\n+\n+\t/**\n+\t *\tAlias the given setting.\n+\t */\n+\tpublic String alias (String str)\n+\t{\n+\t\treturn alias (str, aliases, false);\n+\t}\n+\n+\n+\t/**\n+\t *\tAlias the given setting.\n+\t */\n+\tprotected String alias (String str, String[] aliases, boolean nullNotFound)\n+\t{\n+\t\tif (str != null)\n+\t\t\tstr = str.trim ();\n+\t\tif (aliases == null || aliases.length == 0)\n+\t\t\treturn (nullNotFound) ? null : str;\n+\n+\t\tboolean empty = str != null && str.length () == 0;\n+\t\tfor (int i = 1; i < aliases.length; i += 2)\n+\t\t\tif (StringUtils.equals (str, aliases[i])\n+\t\t\t\t|| (empty && aliases[i] == null))\n+\t\t\t\treturn aliases[i - 1];\t\n+\t\treturn (nullNotFound) ? null : str;\n+\t}\n+\n+\n+\t/**\n+\t *\tUnalias the given setting.\n+\t */\n+\tpublic String unalias (String str)\n+\t{\n+\t\treturn unalias (str, aliases, false);\n+\t}\n+\n+\n+\t/**\n+\t *\tUnalias the given setting.\n+\t */\n+\tprotected String unalias (String str, String[] aliases, \n+\t\tboolean nullNotFound)\n+\t{\n+\t\tif (str != null)\n+\t\t\tstr = str.trim ();\n+\n+\t\tboolean empty = str != null && str.length () == 0;\n+\t\tif (str == null || (empty && def != null))\n+\t\t\tstr = def;\n+\t\tif (aliases != null)\n+\t\t\tfor (int i = 0; i < aliases.length; i += 2)\n+\t\t\t\tif (StringUtils.equals (str, aliases[i])\n+\t\t\t\t\t|| StringUtils.equals (str, aliases[i+1])\n+\t\t\t\t\t|| (empty && aliases[i] == null))\n+\t\t\t\t\treturn aliases[i + 1];\n+\n+\t\tif (isAliasListComprehensive () && aliases != null)\n+\t\t\tthrow new ParseException (s_loc.get (\"invalid-enumerated-config\",\n+\t\t\t\tgetProperty (), str, Arrays.asList (aliases)));\n+\n+\t\treturn (nullNotFound) ? null : str;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe default value for the property as a string.\n+\t */\n+\tpublic String getDefault ()\n+\t{\n+\t\treturn def;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe default value for the propert as a string.\n+\t */\n+\tpublic void setDefault (String def)\n+\t{\n+\t\tthis.def = def;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn a stringified version of this value.  If the current value has\n+\t *\ta short alias key, the alias key is returned.\n+\t */\n+\tpublic String getString ()\n+\t{\n+\t\treturn alias (getInternalString ());\n+\t}\n+\n+\n+\t/**\n+\t *\tSet this value from the given string.  If the given string is null or\n+\t *\tempty and a default is defined, the default is used.  If the given \n+\t *\tstring (or default) is an alias key, it will be converted to the \n+\t *\tcorresponding value internally. \n+\t */\n+\tpublic void setString (String val)\n+\t{\n+\t\tString str = unalias (val);\n+\t\ttry\n+\t\t{\n+\t\t\tsetInternalString (str);\n+\t\t}\n+\t\tcatch (ParseException pe)\n+\t\t{\n+\t\t\tthrow pe;\n+\t\t}\n+\t\tcatch (RuntimeException re)\n+\t\t{\n+\t\t\tthrow new ParseException (prop + \": \" + val, re);\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tSet this value as an object.\n+\t */\n+\tpublic void setObject (Object obj)\n+\t{\n+\t\t// if setting to null set as string to get defaults into play\n+\t\tif (obj == null && def != null)\n+\t\t\tsetString (null);\n+\t\telse\n+\t\t{\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tsetInternalObject (obj);\n+\t\t\t}\n+\t\t\tcatch (ParseException pe)\n+\t\t\t{\n+\t\t\t\tthrow pe;\n+\t\t\t}\n+\t\t\tcatch (RuntimeException re)\n+\t\t\t{\n+\t\t\t\tthrow new ParseException (prop + \": \" + obj, re);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\n+\t/** \n+\t *  Returns the type of the property that this Value represents.\n+\t */\n+\tpublic abstract Class getValueType ();\n+\n+\n+\t/**\n+ \t *\tReturn the internal string form of this value.\n+\t */\n+\tprotected abstract String getInternalString ();\n+\n+\n+\t/**\n+\t *\tSet this value from the given string.\n+\t */\n+\tprotected abstract void setInternalString (String str);\n+\n+\n+\t/**\n+\t *\tSet this value from an object.\n+\t */\n+\tprotected abstract void setInternalObject (Object obj);\n+\n+\n+\t/**\n+\t *\tListener for value changes.\n+\t */\n+\tpublic ValueListener getListener ()\n+\t{\n+\t\treturn this.listen;\n+\t}\n+\n+\n+\t/**\n+\t *\tListener for value changes.\n+\t */\n+\tpublic void setListener (ValueListener listen)\n+\t{\n+\t\tthis.listen = listen;\n+\t}\n+\n+\n+\t/**\n+\t *\tSubclasses should call this method when their inernal value changes.\n+\t */\n+\tpublic void valueChanged ()\n+\t{\n+\t\tif (listen != null)\n+\t\t\tlisten.valueChanged (this);\n+\t}\n+\n+\n+\tpublic int hashCode ()\n+\t{\n+\t\tString str = getString ();\n+\t\tint strHash =  (str == null) ? 0 : str.hashCode ();\n+\t\tint propHash = (prop == null) ? 0 : prop.hashCode ();\n+\t\treturn strHash ^ propHash;\n+\t}\n+\n+\n+\tpublic boolean equals (Object other)\n+\t{\n+\t\tif (other == this)\n+\t\t\treturn true;\n+\t\tif (!(other instanceof Value))\n+\t\t\treturn false;\n+\n+\t\tValue o = (Value)other;\n+\t\treturn StringUtils.equals (prop, o.getProperty ()) \n+\t\t\t&& StringUtils.equals (getString (), o.getString ());\t\n+\t}\n+\n+\n+\tpublic Object clone ()\n+\t{\n+\t\ttry\n+\t\t{\n+\t\t\treturn super.clone ();\n+\t\t}\n+\t\tcatch (CloneNotSupportedException cnse)\n+\t\t{\n+\t\t\treturn null;\t\n+\t\t}\n+\t}\n+}"},{"sha":"392d2ceefacb8887bdca9609ab17401164bbc001","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/ValueListener.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/ValueListener.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/ValueListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/ValueListener.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+\n+/**\n+ *\t<p>Components can listen on {@link Value} objects for changes directly.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ */\n+public interface ValueListener\n+{\n+\t/**\n+\t *\tCallback used by {@link Value} objects to notify listener of \n+\t *\tchange.\n+\t */\n+\tpublic void valueChanged (Value val);\n+}"},{"sha":"14c0f047520e7155eb3ad6b5a6e2919af64e61ab","filename":"openjpa-lib/java/org/apache/openjpa/lib/conf/package.html","status":"added","additions":23,"deletions":0,"changes":23,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/package.html","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/conf/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/conf/package.html?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+<html>\n+<body>\n+\t<p><strong>Configuration Framework</strong></p>\n+\t<p>\n+\t\tThis package provides an extendable product configuration framework.\n+\t</p>\n+</body>\n+</html>"},{"sha":"48a86cb16bf2da764abb28c08314562c6e89825f","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/AbstractJDBCListener.java","status":"added","additions":121,"deletions":0,"changes":121,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/AbstractJDBCListener.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/AbstractJDBCListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/AbstractJDBCListener.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+/** \n+ *  An abstract implementation of the {@link JDBCListener}\n+ *  listener. It allows simple implementation of fine-grained\n+ *  event handling.\n+ *\n+ *  @author  Marc Prud'hommeaux\n+ */\n+public class AbstractJDBCListener\n+\timplements JDBCListener\n+{\n+\t/** \n+\t *  Catch-all for unhandled events.  This method is called by all other\n+\t *\tevent methods if you do not override them.  Does nothing by default.\n+\t */\n+\tprotected void eventOccurred (JDBCEvent event)\n+\t{\n+\t}\n+\n+\n+\tpublic void beforePrepareStatement (JDBCEvent event)\n+\t{\n+\t\teventOccurred (event);\n+\t}\n+\n+\n+\tpublic void afterPrepareStatement (JDBCEvent event)\n+\t{\n+\t\teventOccurred (event);\n+\t}\n+\n+\n+\tpublic void beforeCreateStatement (JDBCEvent event)\n+\t{\n+\t\teventOccurred (event);\n+\t}\n+\n+\n+\tpublic void afterCreateStatement (JDBCEvent event)\n+\t{\n+\t\teventOccurred (event);\n+\t}\n+\n+\n+\tpublic void beforeExecuteStatement (JDBCEvent event)\n+\t{\n+\t\teventOccurred (event);\n+\t}\n+\n+\n+\tpublic void afterExecuteStatement (JDBCEvent event)\n+\t{\n+\t\teventOccurred (event);\n+\t}\n+\n+\n+\tpublic void beforeCommit (JDBCEvent event)\n+\t{\n+\t\teventOccurred (event);\n+\t}\n+\n+\n+\tpublic void afterCommit (JDBCEvent event)\n+\t{\n+\t\teventOccurred (event);\n+\t}\n+\n+\n+\tpublic void beforeRollback (JDBCEvent event)\n+\t{\n+\t\teventOccurred (event);\n+\t}\n+\n+\n+\tpublic void afterRollback (JDBCEvent event)\n+\t{\n+\t\teventOccurred (event);\n+\t}\n+\n+\n+\tpublic void beforeReturn (JDBCEvent event)\n+\t{\n+\t\teventOccurred (event);\n+\t}\n+\n+\n+\tpublic void afterReturn (JDBCEvent event)\n+\t{\n+\t\teventOccurred (event);\n+\t}\n+\n+\n+\tpublic void afterConnect (JDBCEvent event)\n+\t{\n+\t\teventOccurred (event);\n+\t}\n+\n+\n+\tpublic void beforeClose (JDBCEvent event)\n+\t{\n+\t\teventOccurred (event);\n+\t}\n+}\n+"},{"sha":"96be7be1904202f84ef5544cfe99bda0819920eb","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/ConfiguringConnectionDecorator.java","status":"added","additions":209,"deletions":0,"changes":209,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/ConfiguringConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/ConfiguringConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/ConfiguringConnectionDecorator.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,209 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+import java.sql.*;\n+\n+\n+/**\n+ *\t<p>Connection decorator that can configure some properties of the \n+ *\tunderlying connection.  Understands the following properties:\n+ *\t<ul>\n+ *\t<li>QueryTimeout</li>\n+ *\t<li>TransactionIsolation ({@link Connection} constants)</li>\n+ *\t<li>AutoCommit</li>\n+ *\t</ul></p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public class ConfiguringConnectionDecorator\n+\timplements ConnectionDecorator\n+{\n+\tprivate int \t_isolation \t\t= -1;\n+\tprivate int \t_queryTimeout\t= -1;\n+\tprivate Boolean\t_autoCommit\t\t= null;\n+\n+\n+\t/**\n+\t *\tThe number of seconds to wait for a query to execute before\n+\t *\tterminating it.\n+\t */\n+\tpublic int getQueryTimeout ()\n+\t{\n+\t\treturn _queryTimeout;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe number of seconds to wait for a query to execute before\n+\t *\tterminating it.\n+\t */\n+\tpublic void setQueryTimeout (int timeout)\n+\t{\n+\t\t_queryTimeout = timeout;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe transaction isolation level.\n+\t */\n+\tpublic int getTransactionIsolation ()\n+\t{\n+\t\treturn _isolation;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe transaction isolation level.\n+\t */\n+\tpublic void setTransactionIsolation (int isolation)\n+\t{\n+\t\t_isolation = isolation;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhether auto commit should be on.  Use null to keep\n+\t *\tthe connection's default setting.  Defaults to null.\n+\t */\n+\tpublic Boolean getAutoCommit ()\n+\t{\n+\t \treturn _autoCommit;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhether auto commit should be on.  Use null to keep\n+\t *\tthe connection's default setting.  Defaults to null.\n+\t */\n+\tpublic void setAutoCommit (Boolean autoCommit)\n+\t{\n+\t \t_autoCommit = autoCommit;\n+\t}\n+\n+\n+\tpublic Connection decorate (Connection conn)\n+\t\tthrows SQLException\n+\t{\n+\t\tif (_isolation == Connection.TRANSACTION_NONE || _queryTimeout != -1\n+\t\t\t|| _autoCommit != null)\n+\t\t\tconn = new ConfiguringConnection (conn);\n+\t\tif (_isolation != -1 && _isolation != Connection.TRANSACTION_NONE)\n+\t\t\tconn.setTransactionIsolation (_isolation);\n+\t\treturn conn;\n+\t}\n+\n+\n+\t/**\n+\t *\tDecorator to configure connection components correctly.\n+\t */\n+\tprivate class ConfiguringConnection\n+\t\textends DelegatingConnection\n+\t{\n+\t\tprivate boolean _curAutoCommit = false;\n+\n+\n+\t\tpublic ConfiguringConnection (Connection conn)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tsuper (conn);\n+\t\t\tif (_autoCommit != null)\n+\t\t\t{\n+\t\t\t\t_curAutoCommit = ConfiguringConnection.this.getAutoCommit ();\n+\t\t\t\tif (_curAutoCommit != _autoCommit.booleanValue ())\n+\t\t\t\t\tsetAutoCommit (_autoCommit.booleanValue ());\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\tpublic void setAutoCommit (boolean auto)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tif (_isolation != TRANSACTION_NONE)\n+\t\t\t{\n+\t\t\t\tsuper.setAutoCommit (auto);\n+\t\t\t\t_curAutoCommit = auto;\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\tpublic void commit ()\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tif (_isolation != TRANSACTION_NONE)\n+\t\t\t\tsuper.commit ();\n+\t\t\tif (_autoCommit != null\n+\t\t\t\t&& _autoCommit.booleanValue () != _curAutoCommit)\n+\t\t\t\tsetAutoCommit (_autoCommit.booleanValue ());\n+\t\t}\n+\n+\n+\t\tpublic void rollback ()\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tif (_isolation != TRANSACTION_NONE)\n+\t\t\t\tsuper.rollback ();\n+\t\t\tif (_autoCommit != null\n+\t\t\t\t&& _autoCommit.booleanValue () != _curAutoCommit)\n+\t\t\t\tsetAutoCommit (_autoCommit.booleanValue ());\n+\t\t}\n+\n+\n+\t\tprotected PreparedStatement prepareStatement (String sql, boolean wrap)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tPreparedStatement stmnt = super.prepareStatement (sql, wrap);\n+\t\t\tif (_queryTimeout != -1)\n+\t\t\t\tstmnt.setQueryTimeout (_queryTimeout);\n+\t\t\treturn stmnt;\n+\t\t}\n+\n+\n+\t\tprotected PreparedStatement prepareStatement (String sql, int rsType,\n+\t\t\tint rsConcur, boolean wrap)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tPreparedStatement stmnt = super.prepareStatement (sql, rsType, \n+\t\t\t\trsConcur, wrap);\n+\t\t\tif (_queryTimeout != -1)\n+\t\t\t\tstmnt.setQueryTimeout (_queryTimeout);\n+\t\t\treturn stmnt;\n+\t\t}\n+\n+\n+\t\tprotected Statement createStatement (boolean wrap)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tStatement stmnt = super.createStatement (wrap);\n+\t\t\tif (_queryTimeout != -1)\n+\t\t\t\tstmnt.setQueryTimeout (_queryTimeout);\n+\t\t\treturn stmnt;\n+\t\t}\n+\n+\n+\t\tprotected Statement createStatement (int rsType, int rsConcur, \n+\t\t\tboolean wrap)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tStatement stmnt = super.createStatement (rsType, rsConcur, wrap);\n+\t\t\tif (_queryTimeout != -1)\n+\t\t\t\tstmnt.setQueryTimeout (_queryTimeout);\n+\t\t\treturn stmnt;\n+\t\t}\n+\t}\n+}"},{"sha":"395ee66e59c660217c20e12a79abed35c36b9c89","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/ConnectionDecorator.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/ConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/ConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/ConnectionDecorator.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+import java.sql.*;\n+\n+\n+/**\n+ *\t<p>A connection decorator can wrap {@link Connection}s before they are\n+ *\treturned to the user to add functionality.</p>\n+ *\n+ *\t@author\tAbe White\n+ */\n+public interface ConnectionDecorator\n+{\n+\t/**\n+\t *\tDecorate the given connection if desired.\n+\t */\n+\tpublic Connection decorate (Connection conn)\n+\t\tthrows SQLException;\n+}"},{"sha":"4c15a2a897432d792086358be51f5ba4c3b55fc2","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/ConnectionRequestInfo.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/ConnectionRequestInfo.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/ConnectionRequestInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/ConnectionRequestInfo.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+import org.apache.commons.lang.*;\n+\n+\n+/**\n+ *\t<p>Information about a JDBC connection request.</p>\n+ *\n+ *\t@author\t\tMarc Prud'hommeaux\n+ *\t@nojavadoc\n+ */\n+public class ConnectionRequestInfo\n+{\n+\tpublic String user = null;\n+\tpublic String pass = null;\n+\n+\n+\tpublic ConnectionRequestInfo ()\n+\t{\n+\t}\n+\n+\n+\tpublic ConnectionRequestInfo (String user, String pass)\n+\t{\n+\t\tthis.user = user;\n+\t\tthis.pass = pass;\n+\t}\n+\n+\n+\tpublic int hashCode ()\n+\t{\n+\t\treturn (((user == null) ? 0 : user.hashCode ())\n+\t\t\t+ ((pass == null) ? 0 : pass.hashCode ()))\n+\t\t\t% Integer.MAX_VALUE;\n+\t}\n+\n+\n+\tpublic boolean equals (Object other)\n+\t{\n+\t\tif (other == this)\n+\t\t\treturn true;\n+\t\tif (!(other instanceof ConnectionRequestInfo))\n+\t\t\treturn false;\n+\n+\t\tConnectionRequestInfo cri = (ConnectionRequestInfo) other;\n+\t\treturn StringUtils.equals (user, cri.user)\n+\t\t\t&& StringUtils.equals (pass, cri.pass);\n+\t}\n+}"},{"sha":"656726cea6aa590b753b25d1a8c3796c2652cb84","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/DataSourceLogs.java","status":"added","additions":178,"deletions":0,"changes":178,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DataSourceLogs.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DataSourceLogs.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DataSourceLogs.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+import java.sql.*;\n+import java.util.*;\n+import javax.sql.*;\n+\n+import org.apache.openjpa.lib.log.*;\n+\n+\n+/** \n+ *  Provies basic logging facilities to a DataSource.\n+ *  \n+ *  @author  Marc Prud'hommeaux\n+ *\t@nojavadoc\n+ */\n+public class DataSourceLogs\n+{\n+\tprivate Log _jdbcLog\t= null;\n+\tprivate Log _sqlLog\t\t= null;\n+\n+\n+\tpublic DataSourceLogs ()\n+\t{\n+\t}\n+\n+\n+\tpublic DataSourceLogs (Log jdbcLog, Log sqlLog)\n+\t{\n+\t\t_jdbcLog = jdbcLog;\n+\t\t_sqlLog = sqlLog;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe log to write JDBC messages to.\n+\t */\n+\tpublic Log getJDBCLog ()\n+\t{\n+\t\treturn (_jdbcLog == null) ? NoneLogFactory.NoneLog.getInstance () \n+\t\t\t: _jdbcLog;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe log to write JDBC messages to.\n+\t */\n+\tpublic void setJDBCLog (Log log)\n+\t{\n+\t\t_jdbcLog = log;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn true if JDBC logging is enabled.\n+\t */\n+\tpublic boolean isJDBCEnabled ()\n+\t{\n+\t\treturn (_jdbcLog != null && _jdbcLog.isTraceEnabled ());\n+\t}\n+\n+\n+\t/**\n+\t *\tThe log to write SQL messages to.\n+\t */\n+\tpublic Log getSQLLog ()\n+\t{\n+\t\treturn (_sqlLog == null) ? NoneLogFactory.NoneLog.getInstance () \n+\t\t\t: _sqlLog;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe log to write SQL messages to.\n+\t */\n+\tpublic void setSQLLog (Log log)\n+\t{\n+\t\t_sqlLog = log;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn true if SQL logging is enabled.\n+\t */\n+\tpublic boolean isSQLEnabled ()\n+\t{\n+\t\treturn (_sqlLog != null && _sqlLog.isTraceEnabled ());\n+\t}\n+\n+\n+\t/**\n+\t *\tLog a JDBC message on behalf of the given connection.\n+\t */\n+\tpublic void logJDBC (String msg, Connection conn)\n+\t{\n+\t\tlog (msg, conn, _jdbcLog);\n+\t}\n+\n+\n+\t/**\n+\t *\tLog a JDBC message on behalf of the given connection.\n+\t */\n+\tpublic void logJDBC (String msg, long startTime, Connection conn)\n+\t{\n+\t\tlog (msg, conn, _jdbcLog, startTime);\n+\t}\n+\n+\n+\t/**\n+\t *\tLog a SQL message on behalf of the given connection.\n+\t */\n+\tpublic void logSQL (String msg, Connection conn)\n+\t{\n+\t\tlog (msg, conn, _sqlLog);\n+\t}\n+\n+\n+\t/**\n+\t *\tLog a SQL message on behalf of the given connection.\n+\t */\n+\tpublic void logSQL (String msg, long startTime, Connection conn)\n+\t{\n+\t\tlog (msg, conn, _sqlLog, startTime);\n+\t}\n+\n+\n+\t/**\n+\t *\tLog a message to the given logger.\n+\t */\n+\tprivate static void log (String msg, Connection conn, Log log)\n+\t{\n+\t\tlog (msg, conn, log, -1);\n+\t}\n+\n+\n+\t/**\n+\t *\tLog a message to the given logger.\n+\t */\n+\tprivate static void log (String msg, Connection conn,\n+\t\tLog log, long startTime)\n+\t{\n+\t\tif (log == null || !log.isTraceEnabled ())\n+\t\t\treturn;\n+\n+\t\tlong totalTime = -1;\n+\t\tif (startTime != -1)\n+\t\t\ttotalTime = System.currentTimeMillis () - startTime;\n+\n+\t\tStringBuffer buf = new StringBuffer (25 + msg.length ());\n+\t\tbuf.append (\"<t \").append (Thread.currentThread ().hashCode ());\n+\t\tif (conn != null)\n+\t\t\tbuf.append (\", \").append (conn);\n+\t\tbuf.append (\"> \");\n+\n+\t\t// in the time != -1, append time profiling information\n+\t\tif (totalTime != -1)\n+\t\t\tbuf.append (\"[\").append (totalTime).append (\" ms] \");\n+\n+\t\tbuf.append (msg);\n+\t\tlog.trace (buf.toString ());\n+\t}\n+}\n+"},{"sha":"9f3cbeedfaceff4f90aa57860eeb06a1d910a82d","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","status":"added","additions":172,"deletions":0,"changes":172,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+import java.sql.*;\n+import java.util.*;\n+import javax.sql.*;\n+\n+\n+/**\n+ *\t<p>Delegating data source that maintains a list of \n+ *\t{@link ConnectionDecorator}s.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public class DecoratingDataSource\n+\textends DelegatingDataSource\n+{\n+\tprivate static final int INITIAL_SIZE = 7;\n+\n+\tprivate volatile List \t_decorators\t= null;\n+\tprivate boolean\t\t\t_conf\t\t= false;\n+\n+\n+\t/**\n+\t *\tConstructor.  Supply wrapped data source.\n+\t */\n+\tpublic DecoratingDataSource (DataSource ds)\n+\t{\n+\t\tsuper (ds);\n+\t}\n+\n+\n+\t/**\n+\t *\tWhether the datasource is in configuration mode.  Configuration mode\n+\t *\tallows more efficient modification of the decorator chain.  No \n+\t *\tconnections can be obtained while in configuration mode.\n+\t */\n+\tpublic boolean isConfiguring ()\n+\t{\n+\t\treturn _conf;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhether the datasource is in configuration mode.  Configuration mode\n+\t *\tallows more efficient modification of the decorator chain.  No \n+\t *\tconnections can be obtained while in configuration mode.\n+\t */\n+\tpublic void setConfiguring (boolean conf)\n+\t{\n+\t\t_conf = conf;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn a read-only list of connection decorators in the order they were\n+\t *\tadded.\n+\t */\n+\tpublic Collection getDecorators ()\n+\t{\n+\t\treturn (_decorators == null) ? Collections.EMPTY_LIST\n+\t\t\t: Collections.unmodifiableCollection (_decorators);\n+\t}\n+\n+\n+\t/**\n+\t *\tAdd a connection decorator.\n+\t */\n+\tpublic synchronized void addDecorator (ConnectionDecorator decorator)\n+\t{\n+\t\tif (decorator == null)\n+\t\t\tthrow new NullPointerException (\"decorator == null\");\n+\n+\t\tif (_conf)\n+\t\t{\n+\t\t\tif (_decorators == null)\n+\t\t\t\t_decorators = new ArrayList (INITIAL_SIZE);\n+\t\t\t_decorators.add (decorator);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\t// copy so we don't have to synchronize iteration in decorate\n+\t\t\tint size = (_decorators == null) ? 1 : _decorators.size () + 1;\n+\t\t\tList copy = new ArrayList (Math.max (INITIAL_SIZE, size));\n+\t\t\tif (_decorators != null)\n+\t\t\t\tcopy.addAll (_decorators);\t\t\n+\t\t\tcopy.add (decorator);\n+\t\t\t_decorators = copy;\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tRemove a connection decorator.\n+\t */\n+\tpublic synchronized boolean removeDecorator (ConnectionDecorator decorator)\n+\t{\n+\t\tif (decorator == null || _decorators == null \n+\t\t\t|| !_decorators.contains (decorator))\n+\t\t\treturn false;\n+\n+\t\tif (_conf)\n+\t\t\t_decorators.remove (decorator);\n+\t\telse\n+\t\t{\n+\t\t\t// copy so we don't have to synchronize iteration in decorate\n+\t\t\tList copy = new ArrayList (Math.max (INITIAL_SIZE, \n+\t\t\t\t_decorators.size () - 1));\n+\t\t\tfor (int i = 0; i < _decorators.size (); i++)\n+\t\t\t\tif (_decorators.get (i) != decorator)\n+\t\t\t\t\tcopy.add (_decorators.get (i));\n+\t\t\t_decorators = copy;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\n+\t/**\n+\t *\tClear all decorators.\n+\t */\n+\tpublic synchronized void clearDecorators ()\n+\t{\n+\t\t_decorators = null;\n+\t}\n+\n+\n+\tpublic Connection getConnection ()\n+\t\tthrows SQLException\n+\t{\n+\t\tConnection conn = super.getConnection ();\n+\t\treturn decorate (conn);\n+\t}\n+\n+\n+\tpublic Connection getConnection (String user, String pass)\n+\t\tthrows SQLException\n+\t{\n+\t\tConnection conn = super.getConnection (user, pass);\n+\t\treturn decorate (conn);\n+\t}\n+\n+\n+\tprivate Connection decorate (Connection conn)\n+\t\tthrows SQLException\n+\t{\n+\t\tif (_conf)\n+\t\t\tthrow new IllegalStateException ();\n+\n+\t\t// use local in case _decorators replaced during loop\n+\t\tList dec = _decorators;\n+\t\tif (dec != null)\n+\t\t\tfor (int i = 0; i < dec.size (); i++)\n+\t\t\t\tconn = ((ConnectionDecorator) dec.get (i)).decorate (conn);\t\n+\t\treturn conn;\n+\t}\n+}"},{"sha":"a001541d6b90ba431964f0e7b6ed603bf6e484b1","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java","status":"added","additions":1251,"deletions":0,"changes":1251,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingCallableStatement.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,1251 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+import java.io.*;\n+import java.math.*;\n+import java.net.*;\n+import java.sql.*;\n+import java.sql.Date;\t\t\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.lib.util.Closeable; \n+\n+\n+/**\n+ *\t<p>{@link CallableStatement} that delegates to an internal statement.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ */\n+public class DelegatingCallableStatement \n+\timplements CallableStatement, Closeable\n+{\n+\tprivate final CallableStatement \t\t\t_stmnt;\n+\tprivate final DelegatingCallableStatement\t_del;\n+\tprivate final Connection\t\t\t\t\t_conn;\n+\n+\n+\tpublic DelegatingCallableStatement (CallableStatement stmnt, \n+\t\tConnection conn)\n+\t{\n+\t\t_conn = conn;\n+\t\t_stmnt = stmnt;\n+\t\tif (_stmnt instanceof DelegatingCallableStatement)\n+\t\t\t_del = (DelegatingCallableStatement) _stmnt;\n+\t\telse\n+\t\t\t_del = null;\n+\t}\n+\n+\n+\tprivate ResultSet wrapResult (boolean wrap, ResultSet rs)\n+\t{\n+\t\tif (!wrap)\n+\t\t\treturn rs;\n+\n+\t\t// never wrap null\n+\t\tif (rs == null)\n+\t\t\treturn null;\n+\n+\t\treturn new DelegatingResultSet (rs, this);\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the wrapped statement.\n+\t */\n+\tpublic CallableStatement getDelegate ()\n+\t{\n+\t\treturn _stmnt;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the base underlying data store statement.\n+\t */\n+\tpublic CallableStatement getInnermostDelegate ()\n+\t{\n+\t\treturn (_del == null) ? _stmnt : _del.getInnermostDelegate ();\n+\t}\n+\n+\n+\tpublic int hashCode ()\n+\t{\n+\t\treturn getInnermostDelegate ().hashCode ();\n+\t}\n+\n+\n+\tpublic boolean equals (Object other)\n+\t{\n+\t\tif (other == this)\n+\t\t\treturn true;\n+\t\tif (other instanceof DelegatingCallableStatement)\n+\t\t\tother = ((DelegatingCallableStatement) other).\n+\t\t\t\tgetInnermostDelegate ();\n+\t\treturn getInnermostDelegate ().equals (other);\n+\t}\n+\n+\n+\tpublic String toString ()\n+\t{\n+\t\tStringBuffer buf = new StringBuffer (\"prepstmnt \").append (hashCode ());\n+\t\tappendInfo (buf);\n+\t\treturn buf.toString ();\n+\t}\n+\n+\n+\tprotected void appendInfo (StringBuffer buf)\n+\t{\n+\t\tif (_del != null)\n+\t\t\t_del.appendInfo (buf);\n+\t}\n+\n+\n+    public ResultSet executeQuery (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\treturn executeQuery (true);\n+\t}\n+\n+\n+\t/**\n+ \t *\tExecute the query, with the option of not wrapping it in a\n+\t *\t{@link DelegatingResultSet}, which is the default.\n+\t */\n+\tprotected ResultSet executeQuery (String sql, boolean wrap)\n+\t\tthrows SQLException\n+\t{\n+\t\tResultSet rs;\n+\t\tif (_del != null)\n+\t\t\trs = _del.executeQuery (sql, false);\n+\t\telse\n+\t\t\trs = _stmnt.executeQuery (sql);\n+\n+\t\treturn wrapResult (wrap, rs);\n+\t}\n+\n+\n+    public int executeUpdate (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.executeUpdate (str);\n+\t}\n+\n+\n+    public boolean execute (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.execute (str);\n+\t}\n+\n+\n+    public void close () \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.close ();\n+\t}\n+\n+\n+    public int getMaxFieldSize () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getMaxFieldSize ();\n+\t}\n+\n+\n+    public void setMaxFieldSize (int i) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setMaxFieldSize (i);\n+\t}\n+\n+\n+    public int getMaxRows () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getMaxRows ();\n+\t}\n+\n+\n+    public void setMaxRows (int i) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setMaxRows (i);\n+\t}\n+\n+\n+    public void setEscapeProcessing (boolean bool) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setEscapeProcessing (bool);\n+\t}\n+\n+\n+    public int getQueryTimeout () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getQueryTimeout ();\n+\t}\n+\n+\n+    public void setQueryTimeout (int i) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setQueryTimeout (i);\n+\t}\n+\n+\n+    public void cancel () \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.cancel ();\n+\t}\n+\n+\n+    public SQLWarning getWarnings () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getWarnings ();\n+\t}\n+\n+\n+    public void clearWarnings () \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.clearWarnings ();\n+\t}\n+\n+\n+    public void setCursorName (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setCursorName (str);\n+\t}\n+\n+\n+    public ResultSet getResultSet () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn getResultSet (true);\n+\t}\n+\n+\n+\t/**\n+ \t *\tGet the last result set, with the option of not wrapping it in a\n+\t *\t{@link DelegatingResultSet}, which is the default.\n+\t */\n+\tprotected ResultSet getResultSet (boolean wrap)\n+\t\tthrows SQLException\n+\t{\n+\t\tResultSet rs;\n+\t\tif (_del != null)\n+\t\t\trs = _del.getResultSet (false);\n+\t\telse\n+\t\t\trs = _stmnt.getResultSet ();\n+\n+\t\treturn wrapResult (wrap, rs);\n+\t}\n+\n+\n+    public int getUpdateCount () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getUpdateCount ();\n+\t}\n+\n+\n+    public boolean getMoreResults () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getMoreResults ();\n+\t}\n+\n+\n+    public void setFetchDirection (int i) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setFetchDirection (i);\n+\t}\n+\n+\n+    public int getFetchDirection () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getFetchDirection ();\n+\t}\n+\n+\n+    public void setFetchSize (int i) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setFetchSize (i);\n+\t}\n+\n+\n+    public int getFetchSize () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getFetchSize ();\n+\t}\n+\n+\n+    public int getResultSetConcurrency () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getResultSetConcurrency ();\n+\t}\n+\n+\n+    public int getResultSetType () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getResultSetType ();\n+\t}\n+\n+\n+    public void addBatch (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.addBatch (str);\n+\t}\n+\n+\n+    public void clearBatch () \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.clearBatch ();\n+\t}\n+\n+\n+    public int[] executeBatch ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.executeBatch ();\n+\t}\n+\n+\n+    public Connection getConnection () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _conn;\n+\t}\n+\n+\n+\tpublic ResultSet executeQuery () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn executeQuery (true);\n+\t}\n+\n+\n+\t/**\n+ \t *\tExecute the query, with the option of not wrapping it in a\n+\t *\t{@link DelegatingResultSet}, which is the default.\n+\t */\n+\tprotected ResultSet executeQuery (boolean wrap)\n+\t\tthrows SQLException\n+\t{\n+\t\tResultSet rs;\n+\t\tif (_del != null)\n+\t\t\trs = _del.executeQuery (false);\n+\t\telse\n+\t\t\trs = _stmnt.executeQuery ();\n+\n+\t\treturn wrapResult (wrap, rs);\n+\t}\n+\n+\n+\tpublic int executeUpdate  () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.executeUpdate ();\n+\t}\n+\n+\n+\tpublic void setNull (int i1, int i2) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setNull (i1, i2);\n+\t}\n+\n+\n+\tpublic void setBoolean (int i, boolean b) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setBoolean (i, b);\n+\t}\n+\n+\n+\tpublic void setByte (int i, byte b) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setByte (i, b);\n+\t}\n+\n+\n+\tpublic void setShort (int i, short s) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setShort (i, s);\n+\t}\n+\n+\n+\tpublic void setInt (int i1, int i2) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setInt (i1, i2);\n+\t}\n+\n+\n+\tpublic void setLong (int i, long l) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setLong (i, l);\n+\t}\n+\n+\n+\tpublic void setFloat (int i, float f) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setFloat (i, f);\n+\t}\n+\n+\n+\tpublic void setDouble (int i, double d) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setDouble (i, d);\n+\t}\n+\n+\n+\tpublic void setBigDecimal (int i, BigDecimal bd) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setBigDecimal (i, bd);\n+\t}\n+\n+\n+\tpublic void setString (int i, String s) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setString (i, s);\n+\t}\n+\n+\n+\tpublic void setBytes (int i, byte[] b) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setBytes (i, b);\n+\t}\n+\n+\n+\tpublic void setDate (int i, Date d) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setDate (i, d);\n+\t}\n+\n+\n+\tpublic void setTime (int i, Time t) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setTime (i, t);\n+\t}\n+\n+\n+\tpublic void setTimestamp (int i, Timestamp t) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setTimestamp (i, t);\n+\t}\n+\n+\n+\tpublic void setAsciiStream (int i1, InputStream is, int i2) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setAsciiStream (i1, is, i2);\n+\t}\n+\n+\n+\tpublic void setUnicodeStream (int i1, InputStream is, int i2) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setUnicodeStream (i1, is, i2);\n+\t}\n+\n+\n+\tpublic void setBinaryStream (int i1, InputStream is, int i2) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setBinaryStream (i1, is, i2);\n+\t}\n+\n+\n+    public void clearParameters () \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.clearParameters ();\n+\t}\n+\n+\n+\tpublic void setObject (int i1, Object o, int i2, int i3) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setObject (i1, o, i2, i3);\n+\t}\n+\n+\n+\tpublic void setObject (int i1, Object o, int i2)\n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setObject (i1, o, i2);\n+\t}\n+\n+\n+\tpublic void setObject (int i, Object o) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setObject (i, o);\n+\t}\n+\n+\n+    public boolean execute () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.execute ();\n+\t}\n+\n+\n+    public void addBatch () \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.addBatch ();\n+\t}\n+\n+\n+\tpublic void setCharacterStream (int i1, Reader r, int i2)\n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setCharacterStream (i1, r, i2);\n+\t}\n+\n+\n+\tpublic void setRef (int i, Ref r) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setRef (i, r);\n+\t}\n+\n+\n+\tpublic void setBlob (int i, Blob b) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setBlob (i, b);\n+\t}\n+\n+\n+\tpublic void setClob (int i, Clob c) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setClob (i, c);\n+\t}\n+\n+\n+\tpublic void setArray (int i, Array a) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setArray (i, a);\n+\t}\n+\n+\n+    public ResultSetMetaData getMetaData () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getMetaData ();\n+\t}\n+\n+\n+\tpublic void setDate (int i, Date d, Calendar c) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setDate (i, d, c);\n+\t}\n+\n+\n+\tpublic void setTime (int i, Time t, Calendar c) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setTime (i, t, c);\n+\t}\n+\n+\n+\tpublic void setTimestamp (int i, Timestamp t, Calendar c) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setTimestamp (i, t, c);\n+\t}\n+\n+\n+\tpublic void setNull (int i1, int i2, String s) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setNull (i1, i2, s);\n+\t}\n+\n+\n+\t// JDBC 3.0 (unsupported) methods follow; these are required to be able \n+\t// to compile against JDK 1.4\n+\n+\n+\tpublic boolean getMoreResults (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic ResultSet getGeneratedKeys ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int executeUpdate (String s, int i) \n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int executeUpdate (String s, int[] ia)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int executeUpdate (String s, String[] sa)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic boolean execute (String s, int i)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic boolean execute (String s, int[] ia)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic boolean execute (String s, String[] sa)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int getResultSetHoldability ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setURL (int i, URL url)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic ParameterMetaData getParameterMetaData ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\t/////////////////////////////\n+\t// CallableStatement methods\n+\t/////////////////////////////\n+\n+\n+\tpublic void registerOutParameter (int i1, int i2)\n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.registerOutParameter (i1, i2);\n+\t}\n+\n+\n+\tpublic void registerOutParameter (int i1, int i2, int i3)\n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.registerOutParameter (i1, i2, i3);\n+\t}\n+\n+\n+\tpublic boolean wasNull ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.wasNull ();\n+\t}\n+\n+\n+\tpublic String getString (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getString (i);\n+\t}\n+\n+\n+\tpublic boolean getBoolean (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getBoolean (i);\n+\t}\n+\n+\n+\tpublic byte getByte (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getByte (i);\n+\t}\n+\n+\n+\tpublic short getShort (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getShort (i);\n+\t}\n+\n+\n+\tpublic int getInt (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getInt (i);\n+\t}\n+\n+\n+\tpublic long getLong (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getLong (i);\n+\t}\n+\n+\n+\tpublic float getFloat (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getFloat (i);\n+\t}\n+\n+\n+\tpublic double getDouble (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getDouble (i);\n+\t}\n+\n+\n+\tpublic BigDecimal getBigDecimal (int a, int b)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getBigDecimal (a, b);\n+\t}\n+\n+\n+\tpublic byte[] getBytes (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getBytes (i);\n+\t}\n+\n+\n+\tpublic Date getDate (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getDate (i);\n+\t}\n+\n+\n+\tpublic Time getTime (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getTime (i);\n+\t}\n+\n+\n+\tpublic Timestamp getTimestamp (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getTimestamp (i);\n+\t}\n+\n+\n+\tpublic Object getObject (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getObject (i);\n+\t}\n+\n+\n+\tpublic BigDecimal getBigDecimal (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getBigDecimal (i);\n+\t}\n+\n+\n+\tpublic Object getObject (int i, Map m)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getObject (i, m);\n+\t}\n+\n+\n+\tpublic Ref getRef (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getRef (i);\n+\t}\n+\n+\n+\tpublic Blob getBlob (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getBlob (i);\n+\t}\n+\n+\n+\tpublic Clob getClob (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getClob (i);\n+\t}\n+\n+\n+\tpublic Array getArray (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getArray (i);\n+\t}\n+\n+\n+\tpublic Date getDate (int i, Calendar c)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getDate (i, c);\n+\t}\n+\n+\n+\tpublic Time getTime (int i, Calendar c)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getTime (i, c);\n+\t}\n+\n+\n+\tpublic Timestamp getTimestamp (int i, Calendar c)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getTimestamp (i, c);\n+\t}\n+\n+\n+\tpublic void registerOutParameter (int i1, int i2, String s)\n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.registerOutParameter (i1, i2, s);\n+\t}\n+\n+\n+\t// JDBC 3.0 (unsupported) methods follow; these are required to be able \n+\t// to compile against JDK 1.4\n+\n+\n+\tpublic void registerOutParameter (String s, int i)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void registerOutParameter (String s, int i1, int i2)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void registerOutParameter (String s1, int i, String s2)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic URL getURL (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setURL (String a, URL b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic URL getURL (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setNull (String a, int b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setBoolean (String a, boolean b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setByte (String a, byte b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setShort (String a, short b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setInt (String a, int b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setLong (String a, long b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setFloat (String a, float b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setDouble (String a, double b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setBigDecimal (String a, BigDecimal b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setString (String a, String b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setBytes (String a, byte[] b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setDate (String a, Date b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setTime (String a, Time b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setTimestamp (String a, Timestamp b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setAsciiStream (String a, InputStream b, int c)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setBinaryStream (String a, InputStream b, int c)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setObject (String a, Object b, int c, int d)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setObject (String a, Object b, int c)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setObject (String a, Object b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setCharacterStream (String a, Reader b, int c)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setDate (String a, Date b, Calendar c)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setTime (String a, Time b, Calendar c)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setTimestamp (String a, Timestamp b, Calendar c)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setNull (String a, int b, String c)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic String getString (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic boolean getBoolean (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic byte getByte (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic short getShort (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int getInt (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic long getLong (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic float getFloat (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic double getDouble (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic byte[] getBytes (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic Date getDate (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic Time getTime (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic Timestamp getTimestamp (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic Object getObject (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic BigDecimal getBigDecimal (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic Object getObject (String a, Map b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic Ref getRef (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic Blob getBlob (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic Clob getClob (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic Array getArray (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic Date getDate (String a, Calendar b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic Time getTime (String a, Calendar b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic Timestamp getTimestamp (String a, Calendar b)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+}"},{"sha":"f4a13afa9459bbbd6ad47ce92333c33d58d50f31","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingConnection.java","status":"added","additions":751,"deletions":0,"changes":751,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingConnection.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingConnection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingConnection.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,751 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+import java.lang.reflect.*;\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.commons.lang.exception.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.lib.util.Closeable;\n+\n+import serp.util.*;\n+\n+\n+/**\n+ *\t<p>Wrapper around an existing connection.  Subclasses can override the\n+ *\tmethods whose behavior they mean to change.  The <code>equals</code> and \n+ *\t<code>hashCode</code> methods pass through to the base underlying data \n+ *\tstore connection.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ */\n+public class DelegatingConnection\n+\timplements Connection, Closeable\n+{\n+\t// jdbc 3 method keys\n+\tprivate static final Object SET_HOLDABILITY         = new Object ();\n+\tprivate static final Object GET_HOLDABILITY         = new Object ();\n+\tprivate static final Object SET_SAVEPOINT_NONAME    = new Object ();\n+\tprivate static final Object SET_SAVEPOINT           = new Object ();\n+\tprivate static final Object ROLLBACK_SAVEPOINT      = new Object ();\n+\tprivate static final Object RELEASE_SAVEPOINT       = new Object ();\n+\tprivate static final Object CREATE_STATEMENT        = new Object ();\n+\tprivate static final Object PREPARE_STATEMENT       = new Object ();\n+\tprivate static final Object PREPARE_CALL            = new Object ();\n+\tprivate static final Object PREPARE_WITH_KEYS       = new Object ();\n+\tprivate static final Object PREPARE_WITH_INDEX      = new Object ();\n+    private static final Object PREPARE_WITH_NAMES      = new Object ();\n+\n+\tprivate static final Localizer _loc = Localizer.forPackage\n+\t\t(DelegatingConnection.class);\n+\n+\tprivate static final Map _jdbc3;\n+\tstatic\n+\t{\n+\t\tboolean jdbc3 = false;\n+\t\tMethod m = null;\n+\t\ttry\n+\t\t{\n+\t\t\tm = Connection.class.getMethod (\"setSavepoint\",\n+\t\t\t\tnew Class[] { String.class });\n+\t\t\tjdbc3 = true;\n+\t\t}\n+\t\tcatch (Throwable t) {}\n+\n+\t\tif (jdbc3)\n+\t\t{\n+\t\t\t_jdbc3 = new HashMap ();\n+\t\t\t_jdbc3.put (SET_SAVEPOINT, m);\n+\t\t}\n+\t\telse\n+\t\t\t_jdbc3 = null;\n+    }\n+\n+\tprivate final Connection \t\t\t_conn;\n+\tprivate final DelegatingConnection \t_del;\n+\n+\n+\tpublic DelegatingConnection (Connection conn)\n+\t{\n+\t\t_conn = conn;\n+\t\tif (conn instanceof DelegatingConnection)\n+\t\t\t_del = (DelegatingConnection) _conn;\n+\t\telse\n+\t\t\t_del = null;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the wrapped connection.\n+\t */\n+\tpublic Connection getDelegate ()\n+\t{\n+\t\treturn _conn;\n+\t}\n+\n+\t\n+\t/**\n+\t *\tReturn the base underlying data store connection.\n+\t */\n+\tpublic Connection getInnermostDelegate ()\n+\t{\n+\t\treturn (_del == null) ? _conn : _del.getInnermostDelegate ();\n+\t}\n+\n+\n+\tpublic int hashCode ()\n+\t{\n+\t\treturn getInnermostDelegate ().hashCode ();\n+\t}\n+\n+\n+\tpublic boolean equals (Object other)\n+\t{\n+\t\tif (other == this)\n+\t\t\treturn true;\n+\t\tif (other instanceof DelegatingConnection)\n+\t\t\tother = ((DelegatingConnection) other).getInnermostDelegate ();\n+\t\treturn getInnermostDelegate ().equals (other);\n+\t}\n+\n+\n+\tpublic String toString ()\n+\t{\n+\t\tStringBuffer buf = new StringBuffer (\"conn \").append (hashCode ());\n+\t\tappendInfo (buf);\n+\t\treturn buf.toString ();\n+\t}\n+\n+\n+\tprotected void appendInfo (StringBuffer buf)\n+\t{\n+\t\tif (_del != null)\n+\t\t\t_del.appendInfo (buf);\n+\t}\n+\n+\n+\tpublic Statement createStatement () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn createStatement (true);\n+\t}\n+\n+\n+\t/**\n+ \t *\tCreate a statement, with the option of not wrapping it in a\n+\t *\t{@link DelegatingStatement}, which is the default.\n+\t */\n+\tprotected Statement createStatement (boolean wrap)\n+\t\tthrows SQLException\n+\t{\n+\t\tStatement stmnt;\n+\t\tif (_del != null)\n+\t\t\tstmnt = _del.createStatement (false);\n+\t\telse\n+\t\t\tstmnt = _conn.createStatement ();\n+\t\tif (wrap)\n+\t\t\tstmnt = new DelegatingStatement (stmnt, this);\n+\t\treturn stmnt;\n+\t}\n+\n+\n+\tpublic PreparedStatement prepareStatement (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\treturn prepareStatement (str, true);\n+\t}\n+\n+\n+\t/**\n+ \t *\tPrepare a statement, with the option of not wrapping it in a\n+\t *\t{@link DelegatingPreparedStatement}, which is the default.\n+\t */\n+\tprotected PreparedStatement prepareStatement (String str, boolean wrap) \n+\t\tthrows SQLException\n+\t{\n+\t\tPreparedStatement stmnt;\n+\t\tif (_del != null)\n+\t\t\tstmnt = _del.prepareStatement (str, false);\n+\t\telse\n+\t\t\tstmnt = _conn.prepareStatement (str);\n+\t\tif (wrap)\n+\t\t\tstmnt = new DelegatingPreparedStatement (stmnt, this);\n+\t\treturn stmnt;\n+\t}\n+\n+\n+\tpublic CallableStatement prepareCall (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\treturn prepareCall (str, true);\n+\t}\n+\n+\n+\t/**\n+ \t *\tPrepare a call, with the option of not wrapping it in a\n+\t *\t{@link DelegatingCallableStatement}, which is the default.\n+\t */\n+\tprotected CallableStatement prepareCall (String str, boolean wrap) \n+\t\tthrows SQLException\n+\t{\n+\t\tCallableStatement stmnt;\n+\t\tif (_del != null)\n+\t\t\tstmnt = _del.prepareCall (str, false);\n+\t\telse\n+\t\t\tstmnt = _conn.prepareCall (str);\n+\t\tif (wrap)\n+\t\t\tstmnt = new DelegatingCallableStatement (stmnt, this);\n+\t\treturn stmnt;\n+\t}\n+\n+\n+\tpublic String nativeSQL (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _conn.nativeSQL (str);\n+\t}\n+\n+\n+\tpublic void setAutoCommit (boolean bool) \n+\t\tthrows SQLException\n+\t{\n+\t\t_conn.setAutoCommit (bool);\n+\t}\n+\n+\n+\tpublic boolean getAutoCommit () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _conn.getAutoCommit ();\n+\t}\n+\n+\n+\tpublic void commit () \n+\t\tthrows SQLException\n+\t{\n+\t\t_conn.commit ();\n+\t}\n+\n+\n+\tpublic void rollback () \n+\t\tthrows SQLException\n+\t{\n+\t\t_conn.rollback ();\n+\t}\n+\n+\n+\tpublic void close () \n+\t\tthrows SQLException\n+\t{\n+\t\t_conn.close ();\n+\t}\n+\n+\n+\tpublic boolean isClosed () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _conn.isClosed ();\n+\t}\n+\n+\n+\tpublic DatabaseMetaData getMetaData () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn getMetaData (true);\n+\t}\n+\n+\n+\t/**\n+ \t *\tReturn the metadata, with the option of not wrapping it in a\n+\t *\t{@link DelegatingDatabaseMetaData}, which is the default.\n+\t */\n+\tprotected DatabaseMetaData getMetaData (boolean wrap)\n+\t\tthrows SQLException\n+\t{\n+\t\tDatabaseMetaData meta;\n+\t\tif (_del != null)\n+\t\t\tmeta = _del.getMetaData (false);\n+\t\telse\n+\t\t\tmeta = _conn.getMetaData ();\n+\t\tif (wrap)\n+\t\t\tmeta = new DelegatingDatabaseMetaData (meta, this);\n+\t\treturn meta;\n+\t}\n+\n+\n+\tpublic void setReadOnly (boolean bool) \n+\t\tthrows SQLException\n+\t{\n+\t\t_conn.setReadOnly (bool);\n+\t}\n+\n+\n+\tpublic boolean isReadOnly () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _conn.isReadOnly ();\n+\t}\n+\n+\n+\tpublic void setCatalog (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\t_conn.setCatalog (str);\n+\t}\n+\n+\n+\tpublic String getCatalog () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _conn.getCatalog ();\n+\t}\n+\n+\n+\tpublic void setTransactionIsolation (int i) \n+\t\tthrows SQLException\n+\t{\n+\t\t_conn.setTransactionIsolation (i);\n+\t}\n+\n+\n+\tpublic int getTransactionIsolation () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _conn.getTransactionIsolation ();\n+\t}\n+\n+\n+\tpublic SQLWarning getWarnings () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _conn.getWarnings ();\n+\t}\n+\n+\n+\tpublic void clearWarnings () \n+\t\tthrows SQLException\n+\t{\n+\t\t_conn.clearWarnings ();\n+\t}\n+\n+\n+\tpublic Statement createStatement (int type, int concur) \n+\t\tthrows SQLException\n+\t{\n+\t\treturn createStatement (type, concur, true);\n+\t}\n+\n+\n+\t/**\n+ \t *\tCreate a statement, with the option of not wrapping it in a\n+\t *\t{@link DelegatingStatement}, which is the default.\n+\t */\n+\tprotected Statement createStatement (int type, int concur, boolean wrap)\n+\t\tthrows SQLException\n+\t{\n+\t\tStatement stmnt;\n+\t\tif (_del != null)\n+\t\t\tstmnt = _del.createStatement (type, concur, false);\n+\t\telse\n+\t\t\tstmnt = _conn.createStatement (type, concur);\n+\t\tif (wrap)\n+\t\t\tstmnt = new DelegatingStatement (stmnt, this);\n+\t\treturn stmnt;\n+\t}\n+\n+\n+\tpublic PreparedStatement prepareStatement (String str, int type,\n+\t\tint concur) \n+\t\tthrows SQLException\n+\t{\n+\t\treturn prepareStatement (str, type, concur, true);\n+\t}\n+\n+\n+\t/**\n+ \t *\tPrepare a statement, with the option of not wrapping it in a\n+\t *\t{@link DelegatingPreparedStatement}, which is the default.\n+\t */\n+\tprotected PreparedStatement prepareStatement (String str, int type,\n+\t\tint concur, boolean wrap) \n+\t\tthrows SQLException\n+\t{\n+\t\tPreparedStatement stmnt;\n+\t\tif (_del != null)\n+\t\t\tstmnt = _del.prepareStatement (str, type, concur, false);\n+\t\telse\n+\t\t\tstmnt = _conn.prepareStatement (str, type, concur);\n+\t\tif (wrap)\n+\t\t\tstmnt = new DelegatingPreparedStatement (stmnt, this);\n+\t\treturn stmnt;\n+\t}\n+\n+\n+\tpublic CallableStatement prepareCall (String str, int type, int concur) \n+\t\tthrows SQLException\n+\t{\n+\t\treturn prepareCall (str, type, concur, true);\n+\t}\n+\n+\n+\t/**\n+ \t *\tPrepare a call, with the option of not wrapping it in a\n+\t *\t{@link DelegatingCallableStatement}, which is the default.\n+\t */\n+\tprotected CallableStatement prepareCall (String str, int type, int concur, \n+\t\tboolean wrap) \n+\t\tthrows SQLException\n+\t{\n+\t\tCallableStatement stmnt;\n+\t\tif (_del != null)\n+\t\t\tstmnt = _del.prepareCall (str, type, concur, false);\n+\t\telse\n+\t\t\tstmnt = _conn.prepareCall (str, type, concur);\n+\t\tif (wrap)\n+\t\t\tstmnt = new DelegatingCallableStatement (stmnt, this);\n+\t\treturn stmnt;\n+\t}\n+\n+\n+\tpublic Map getTypeMap () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _conn.getTypeMap ();\n+\t}\n+\n+\n+\tpublic void setTypeMap (Map map) \n+\t\tthrows SQLException\n+\t{\n+\t\t_conn.setTypeMap (map);\n+\t}\n+\n+\n+\t// JDBC 3.0 methods follow; these are required to be able to \n+\t// compile against JDK 1.4; these methods will not work on\n+\t// previous JVMs\n+\n+\n+\tpublic void setHoldability (int holdability)\n+\t\tthrows SQLException\n+\t{\n+\t\tassertJDBC3 ();\n+\t\tMethod m = (Method) _jdbc3.get (SET_HOLDABILITY);\n+\t\tif (m == null)\n+\t\t\tm = createJDBC3Method (SET_HOLDABILITY, \"setHoldability\",\n+\t\t\t\tnew Class[] {int.class});\n+\t\tinvokeJDBC3 (m, new Object[] {Numbers.valueOf (holdability)});\n+\t}\n+\n+\n+\tpublic int getHoldability ()\n+\t\tthrows SQLException\n+\t{\n+\t\tassertJDBC3 ();\n+\t\tMethod m = (Method) _jdbc3.get (GET_HOLDABILITY);\n+\t\tif (m == null)\n+\t\t\tm = createJDBC3Method (GET_HOLDABILITY, \"getHoldability\", null);\n+\t\treturn ((Number) invokeJDBC3 (m, null)).intValue ();\n+\t}\n+\n+\n+\tpublic Savepoint setSavepoint ()\n+\t\tthrows SQLException\n+\t{\n+\t\tassertJDBC3 ();\n+\t\tMethod m = (Method) _jdbc3.get (SET_SAVEPOINT_NONAME);\n+\t\tif (m == null)\n+\t\t\tm = createJDBC3Method (SET_SAVEPOINT_NONAME, \"setSavepoint\", null);\n+\t\treturn (Savepoint) invokeJDBC3 (m, null);\n+\t}\n+\n+\n+\tpublic Savepoint setSavepoint (String savepoint)\n+\t\tthrows SQLException\n+\t{\n+\t\tassertJDBC3 ();\n+\t\tMethod m = (Method) _jdbc3.get (SET_SAVEPOINT);\n+\t\tif (m == null)\n+\t\t\tm = createJDBC3Method (SET_SAVEPOINT, \"setSavepoint\", \n+\t\t\t\tnew Class[] {String.class});\n+\t\treturn (Savepoint) invokeJDBC3 (m, new Object[] {savepoint});\n+\t}\n+\n+\n+\tpublic void rollback (Savepoint savepoint)\n+\t\tthrows SQLException\n+\t{\n+\t\tassertJDBC3 ();\n+\t\tMethod m = (Method) _jdbc3.get (ROLLBACK_SAVEPOINT);\n+\t\tif (m == null)\n+\t\t\tm = createJDBC3Method (ROLLBACK_SAVEPOINT, \"rollback\", \n+\t\t\t\tnew Class[] {Savepoint.class});\n+\t\tinvokeJDBC3 (m, new Object[] {savepoint});\n+\t}\n+\n+\n+\tpublic void releaseSavepoint (Savepoint savepoint)\n+\t\tthrows SQLException\n+\t{\n+\t\tassertJDBC3 ();\n+\t\tMethod m = (Method) _jdbc3.get (RELEASE_SAVEPOINT);\n+\t\tif (m == null)\n+\t\t\tm = createJDBC3Method (RELEASE_SAVEPOINT, \"releaseSavepoint\", \n+\t\t\t\tnew Class[] {Savepoint.class});\n+\t\tinvokeJDBC3 (m, new Object[] {savepoint});\n+\t}\n+\n+\n+\tpublic Statement createStatement (int resultSetType,\n+\t\tint resultSetConcurrency, int resultSetHoldability)\n+\t\tthrows SQLException\n+\t{\n+\t\tassertJDBC3 ();\n+\t\treturn createStatement (resultSetType, resultSetConcurrency, \n+\t\t\tresultSetHoldability, true);\n+\t}\n+\n+\n+\tprotected Statement createStatement (int resultSetType,\n+\t\tint resultSetConcurrency, int resultSetHoldability, boolean wrap)\n+\t\tthrows SQLException\n+\t{\n+\t\tStatement stmnt;\n+\t\tif (_del != null)\n+\t\t\tstmnt = _del.createStatement (resultSetType, resultSetConcurrency,\n+\t\t\t\tresultSetHoldability, false);\n+\t\telse\n+\t\t{\n+\t\t\tMethod m = (Method) _jdbc3.get (CREATE_STATEMENT);\n+\t\t\tif (m == null)\n+\t\t\t\tm = createJDBC3Method (CREATE_STATEMENT, \"createStatement\", \n+\t\t\t\t\tnew Class[] {int.class, int.class, int.class});\n+\t\t\tstmnt = (Statement) invokeJDBC3 (m, new Object[] {\n+\t\t\t\tNumbers.valueOf (resultSetType), \n+\t\t\t\tNumbers.valueOf (resultSetConcurrency),\n+\t\t\t\tNumbers.valueOf (resultSetHoldability)});\n+\t\t}\n+\t\tif (wrap)\n+\t\t\tstmnt = new DelegatingStatement (stmnt, this);\n+\t\treturn stmnt;\n+\t}\n+\n+\n+\tpublic PreparedStatement prepareStatement (String sql,\n+\t\tint resultSetType, int resultSetConcurrency, int resultSetHoldability)\n+\t\tthrows SQLException\n+\t{\n+\t\tassertJDBC3 ();\n+\t\treturn prepareStatement (sql, resultSetType, resultSetConcurrency,\n+\t\t\tresultSetHoldability, true);\n+\t}\n+\n+\n+\tprotected PreparedStatement prepareStatement (String sql,\n+\t\tint resultSetType, int resultSetConcurrency, int resultSetHoldability,\n+\t\tboolean wrap)\n+\t\tthrows SQLException\n+\t{\n+\t\tPreparedStatement stmnt;\n+\t\tif (_del != null)\n+\t\t\tstmnt = _del.prepareStatement (sql, resultSetType, \n+\t\t\t\tresultSetConcurrency, resultSetHoldability, false);\n+\t\telse\n+\t\t{\n+\t\t\tMethod m = (Method) _jdbc3.get (PREPARE_STATEMENT);\n+\t\t\tif (m == null)\n+\t\t\t\tm = createJDBC3Method (PREPARE_STATEMENT, \"prepareStatement\", \n+\t\t\t\t\tnew Class[]{String.class, int.class, int.class, int.class});\n+\t\t\tstmnt = (PreparedStatement) invokeJDBC3 (m, new Object[] { sql,\n+\t\t\t\tNumbers.valueOf (resultSetType), \n+\t\t\t\tNumbers.valueOf (resultSetConcurrency),\n+\t\t\t\tNumbers.valueOf (resultSetHoldability)});\n+\t\t}\n+\t\tif (wrap)\n+\t\t\tstmnt = new DelegatingPreparedStatement (stmnt, this);\n+\t\treturn stmnt;\n+\t}\n+\n+\n+\tpublic CallableStatement prepareCall (String sql,\n+\t\tint resultSetType, int resultSetConcurrency, int resultSetHoldability)\n+\t\tthrows SQLException\n+\t{\n+\t\tassertJDBC3 ();\n+\t\treturn prepareCall (sql, resultSetType, resultSetConcurrency,\n+\t\t\tresultSetHoldability, true);\n+\t}\n+\n+\n+\tprotected CallableStatement prepareCall (String sql, int resultSetType, \n+\t\tint resultSetConcurrency, int resultSetHoldability, boolean wrap)\n+\t\tthrows SQLException\n+\t{\n+\t\tCallableStatement stmnt;\n+\t\tif (_del != null)\n+\t\t\tstmnt = _del.prepareCall (sql, resultSetType, \n+\t\t\t\tresultSetConcurrency, resultSetHoldability, false);\n+\t\telse\n+\t\t{\n+\t\t\tMethod m = (Method) _jdbc3.get (PREPARE_CALL);\n+\t\t\tif (m == null)\n+\t\t\t\tm = createJDBC3Method (PREPARE_CALL, \"prepareCall\", \n+\t\t\t\t\tnew Class[]{String.class, int.class, int.class, int.class});\n+\t\t\tstmnt = (CallableStatement) invokeJDBC3 (m, new Object[] { sql,\n+\t\t\t\tNumbers.valueOf (resultSetType), \n+\t\t\t\tNumbers.valueOf (resultSetConcurrency),\n+\t\t\t\tNumbers.valueOf (resultSetHoldability)});\n+\t\t}\n+\t\tif (wrap)\n+\t\t\tstmnt = new DelegatingCallableStatement (stmnt, this);\n+\t\treturn stmnt;\n+\t}\n+\n+\n+\tpublic PreparedStatement prepareStatement (String sql,\n+\t\tint autoGeneratedKeys)\n+\t\tthrows SQLException\n+\t{\n+\t\tassertJDBC3 ();\n+\t\treturn prepareStatement (sql, autoGeneratedKeys, true);\n+\t}\n+\n+\n+\tprotected PreparedStatement prepareStatement (String sql,\n+\t\tint autoGeneratedKeys, boolean wrap)\n+\t\tthrows SQLException\n+\t{\n+\t\tPreparedStatement stmnt;\n+\t\tif (_del != null)\n+\t\t\tstmnt = _del.prepareStatement (sql, autoGeneratedKeys); \n+\t\telse\n+\t\t{\n+\t\t\tMethod m = (Method) _jdbc3.get (PREPARE_WITH_KEYS);\n+\t\t\tif (m == null)\n+\t\t\t\tm = createJDBC3Method (PREPARE_WITH_KEYS, \"prepareStatement\", \n+\t\t\t\t\tnew Class[] {String.class, int.class});\n+\t\t\tstmnt = (PreparedStatement) invokeJDBC3 (m, new Object[] { sql,\n+\t\t\t\tNumbers.valueOf (autoGeneratedKeys)});\n+\t\t}\n+\t\tif (wrap)\n+\t\t\tstmnt = new DelegatingPreparedStatement (stmnt, this);\n+\t\treturn stmnt;\n+\t}\n+\n+\n+\tpublic PreparedStatement prepareStatement (String sql, int[] columnIndexes)\n+\t\tthrows SQLException\n+\t{\n+\t\tassertJDBC3 ();\n+\t\treturn prepareStatement (sql, columnIndexes, true);\n+\t}\n+\n+\n+\tprotected PreparedStatement prepareStatement (String sql, \n+\t\tint[] columnIndexes, boolean wrap)\n+\t\tthrows SQLException\n+\t{\n+\t\tPreparedStatement stmnt;\n+\t\tif (_del != null)\n+\t\t\tstmnt = _del.prepareStatement (sql, columnIndexes, wrap); \n+\t\telse\n+\t\t{\n+\t\t\tMethod m = (Method) _jdbc3.get (PREPARE_WITH_INDEX);\n+\t\t\tif (m == null)\n+\t\t\t\tm = createJDBC3Method (PREPARE_WITH_INDEX, \"prepareStatement\", \n+\t\t\t\t\tnew Class[] {String.class, int[].class});\n+\t\t\tstmnt = (PreparedStatement) invokeJDBC3 (m, new Object[] { sql,\n+\t\t\t\tcolumnIndexes});\n+\t\t}\n+\t\tif (wrap)\n+\t\t\tstmnt = new DelegatingPreparedStatement (stmnt, this);\n+\t\treturn stmnt;\n+\t}\n+\n+\n+\tpublic PreparedStatement prepareStatement (String sql, String[] columnNames)\n+\t\tthrows SQLException\n+\t{\n+\t\tassertJDBC3 ();\n+\t\treturn prepareStatement (sql, columnNames, true);\n+\t}\n+\n+\n+\tprotected PreparedStatement prepareStatement (String sql, \n+\t\tString[] columnNames, boolean wrap)\n+\t\tthrows SQLException\n+\t{\n+\t\tassertJDBC3 ();\n+\t\tPreparedStatement stmnt;\n+\t\tif (_del != null)\n+\t\t\tstmnt = _del.prepareStatement (sql, columnNames, wrap); \n+\t\telse\n+\t\t{\n+\t\t\tMethod m = (Method) _jdbc3.get (PREPARE_WITH_NAMES);\n+\t\t\tif (m == null)\n+\t\t\t\tm = createJDBC3Method (PREPARE_WITH_NAMES, \"prepareStatement\", \n+\t\t\t\t\tnew Class[] {String.class, String[].class});\n+\t\t\tstmnt = (PreparedStatement) invokeJDBC3 (m, new Object[] { sql,\n+\t\t\t\tcolumnNames});\n+\t\t}\n+\t\tif (wrap)\n+\t\t\tstmnt = new DelegatingPreparedStatement (stmnt, this);\n+\t\treturn stmnt;\n+\t}\n+\n+\n+\tprivate static void assertJDBC3 ()\n+\t{\n+\t\tif (_jdbc3 == null)\n+\t\t\tthrow new UnsupportedOperationException (_loc.get (\"not-jdbc3\"));\n+\t}\n+\n+\n+\tprivate Object invokeJDBC3 (Method m, Object[] args)\n+\t\tthrows SQLException\n+\t{\n+\t\ttry\n+\t\t{\n+\t\t\treturn m.invoke (_conn, args);\n+\t\t}\n+\t\tcatch (Throwable t)\n+\t\t{\n+\t\t\tif (t instanceof SQLException)\n+\t\t\t\tthrow (SQLException) t;\n+\t\t\tthrow new NestableRuntimeException (_loc.get (\"invoke-jdbc3\"), t);\n+\t\t}\n+\t}\n+\n+\n+\tprivate static Method createJDBC3Method (Object key, String name, \n+\t\tClass[] args)\n+\t{\n+\t\ttry\n+\t\t{\n+\t\t\tMethod m = Connection.class.getMethod (name, args);\n+\t\t\t_jdbc3.put (key, m);\n+\t\t\treturn m;\n+\t\t}\n+\t\tcatch (Throwable t)\n+\t\t{\n+\t\t\tthrow new NestableRuntimeException (_loc.get (\"error-jdbc3\"), t);\n+\t\t}\n+\t}\n+}"},{"sha":"47a46f4e32fc5fce3d6b0b325c292cf02b544198","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingDataSource.java","status":"added","additions":156,"deletions":0,"changes":156,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingDataSource.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+import java.io.*;\n+import java.sql.*;\n+import javax.sql.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.lib.util.Closeable; \n+\n+\n+/**\n+ *\t<p>Wrapper around an existing data source.  Subclasses can override the\n+ *\tmethods whose behavior they mean to change.  The <code>equals</code> and \n+ *\t<code>hashCode</code> methods pass through to the base underlying data \n+ *\tstore.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ */\n+public class DelegatingDataSource\n+\timplements DataSource, Closeable\n+{\n+\tprivate final DataSource \t\t\t_ds;\n+\tprivate final DelegatingDataSource\t_del;\n+\n+\n+\t/**\n+\t *\tConstructor.  Supply wrapped data source.\n+\t */\n+\tpublic DelegatingDataSource (DataSource ds)\n+\t{\n+\t\t_ds = ds;\n+\n+\t\tif (_ds instanceof DelegatingDataSource)\n+\t\t\t_del = (DelegatingDataSource) _ds;\n+\t\telse\n+\t\t\t_del = null;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the wrapped data source.\n+\t */\n+\tpublic DataSource getDelegate ()\n+\t{\n+\t\treturn _ds;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the inner-most wrapped delegate.\n+\t */\n+\tpublic DataSource getInnermostDelegate ()\n+\t{\n+\t\treturn (_del == null) ? _ds : _del.getInnermostDelegate ();\n+\t}\n+\n+\n+\tpublic int hashCode ()\n+\t{\n+\t\treturn getInnermostDelegate ().hashCode ();\n+\t}\n+\n+\n+\tpublic boolean equals (Object other)\n+\t{\n+\t\tif (other == this)\n+\t\t\treturn true;\n+\t\tif (other instanceof DelegatingDataSource)\n+\t\t\tother = ((DelegatingDataSource) other).getInnermostDelegate ();\n+\t\treturn getInnermostDelegate ().equals (other);\t\n+\t}\n+\n+\n+\tpublic String toString ()\n+\t{\n+\t\tStringBuffer buf = new StringBuffer (\"datasource \").\n+\t\t\tappend (hashCode ());\n+\t\tappendInfo (buf);\n+\t\treturn buf.toString ();\n+\t}\n+\n+\n+\tprotected void appendInfo (StringBuffer buf)\n+\t{\n+\t\tif (_del != null)\n+\t\t\t_del.appendInfo (buf);\n+\t}\n+\n+\n+\tpublic PrintWriter getLogWriter ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _ds.getLogWriter ();\n+\t}\n+\n+\n+    public void setLogWriter (PrintWriter out) \n+\t\tthrows SQLException\n+\t{\n+\t\t_ds.setLogWriter (out);\n+\t}\n+\n+\n+\tpublic int getLoginTimeout ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _ds.getLoginTimeout ();\n+\t}\n+\n+\n+    public void setLoginTimeout (int timeout)\n+\t\tthrows SQLException\n+\t{\n+\t\t_ds.setLoginTimeout (timeout);\n+\t}\n+\n+\n+\tpublic Connection getConnection ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _ds.getConnection ();\n+\t}\n+\n+\n+\tpublic Connection getConnection (String user, String pass)\n+\t\tthrows SQLException\n+\t{\n+\t\tif (user == null && pass == null)\n+\t\t\treturn _ds.getConnection ();\n+\t\treturn _ds.getConnection (user, pass);\n+\t}\n+\n+\n+\tpublic void close ()\n+\t\tthrows Exception\n+\t{\n+\t\tif (_ds instanceof Closeable)\n+\t\t\t((Closeable) _ds).close ();\n+\t}\n+}"},{"sha":"4a35db219b2c6d13c2af338a330351b08ebfb9e3","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","status":"added","additions":1265,"deletions":0,"changes":1265,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,1265 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+import java.io.*;\n+import java.sql.*;\n+import java.util.*;\n+\n+\n+/**\n+ *\t<p>Wrapper around a DatabaseMetadata instance.</p>\n+ *\n+ *\t@author\t\tMarc Prud'hommeaux\n+ */\n+public class DelegatingDatabaseMetaData\n+\timplements DatabaseMetaData\n+{\n+\tprivate final DatabaseMetaData \t_metaData;\n+\tprivate final Connection\t \t_conn;\n+\n+\n+\tpublic DelegatingDatabaseMetaData (DatabaseMetaData metaData,\n+\t\tConnection conn)\n+\t{\n+\t\t_conn = conn;\n+\t\t_metaData = metaData;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the base underlying database metadata.\n+\t */\n+\tpublic DatabaseMetaData getInnermostDelegate ()\n+\t{\n+\t\treturn _metaData instanceof DelegatingDatabaseMetaData ?\n+\t\t\t((DelegatingDatabaseMetaData)_metaData).getInnermostDelegate ()\n+\t\t\t: _metaData;\n+\t}\n+\n+\n+\tpublic int hashCode ()\n+\t{\n+\t\treturn getInnermostDelegate ().hashCode ();\n+\t}\n+\n+\n+\tpublic boolean equals (Object other)\n+\t{\n+\t\tif (other == this)\n+\t\t\treturn true;\n+\t\tif (other instanceof DelegatingDatabaseMetaData)\n+\t\t\tother = ((DelegatingDatabaseMetaData) other)\n+\t\t\t.getInnermostDelegate ();\n+\t\treturn getInnermostDelegate ().equals (other);\n+\t}\n+\n+\n+\tpublic String toString ()\n+\t{\n+\t\tStringBuffer buf = new StringBuffer (\"metadata \").append (hashCode ());\n+\t\tbuf.append (\"[\").append (_metaData.toString ()).append (\"]\");\n+\t\treturn buf.toString ();\n+\t}\n+\n+\n+\tpublic boolean allProceduresAreCallable ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.allProceduresAreCallable ();\n+\t}\n+\n+\n+\tpublic boolean allTablesAreSelectable ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.allTablesAreSelectable ();\n+\t}\n+\n+\n+\tpublic boolean dataDefinitionCausesTransactionCommit ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.dataDefinitionCausesTransactionCommit ();\n+\t}\n+\n+\n+\tpublic boolean dataDefinitionIgnoredInTransactions ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.dataDefinitionIgnoredInTransactions ();\n+\t}\n+\n+\n+\tpublic boolean deletesAreDetected (int type)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.deletesAreDetected (type);\n+\t}\n+\n+\n+\tpublic boolean doesMaxRowSizeIncludeBlobs ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.doesMaxRowSizeIncludeBlobs ();\n+\t}\n+\n+\n+\tpublic ResultSet getBestRowIdentifier (String catalog,\n+\t\tString schema, String table, int scope, boolean nullable)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getBestRowIdentifier (catalog, schema,\n+\t\t\ttable, scope, nullable);\n+\t}\n+\n+\n+\tpublic ResultSet getCatalogs ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getCatalogs ();\n+\t}\n+\n+\n+\tpublic String getCatalogSeparator ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getCatalogSeparator ();\n+\t}\n+\n+\n+\tpublic String getCatalogTerm ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getCatalogTerm ();\n+\t}\n+\n+\n+\tpublic ResultSet getColumnPrivileges (String catalog, String schema,\n+\t\tString table, String columnNamePattern)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getColumnPrivileges (catalog, schema,\n+\t\t\ttable, columnNamePattern);\n+\t}\n+\n+\n+\tpublic ResultSet getColumns (String catalog, String schemaPattern,\n+\t\tString tableNamePattern, String columnNamePattern)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getColumns (catalog, schemaPattern,\n+\t\t\ttableNamePattern, columnNamePattern);\n+\t}\n+\n+\n+\tpublic Connection getConnection ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _conn;\n+\t}\n+\n+\n+\tpublic ResultSet getCrossReference (String primaryCatalog,\n+\t\tString primarySchema, String primaryTable, String foreignCatalog,\n+\t\tString foreignSchema, String foreignTable)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getCrossReference (primaryCatalog, primarySchema,\n+\t\t\tprimaryTable, foreignCatalog, foreignSchema, foreignTable);\n+\t}\n+\n+\n+\tpublic String getDatabaseProductName ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getDatabaseProductName ();\n+\t}\n+\n+\n+\tpublic String getDatabaseProductVersion ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getDatabaseProductVersion ();\n+\t}\n+\n+\n+\tpublic int getDefaultTransactionIsolation ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getDefaultTransactionIsolation ();\n+\t}\n+\n+\n+\tpublic int getDriverMajorVersion ()\n+\t{\n+\t\treturn _metaData.getDriverMajorVersion ();\n+\t}\n+\n+\n+\tpublic int getDriverMinorVersion ()\n+\t{\n+\t\treturn _metaData.getDriverMinorVersion ();\n+\t}\n+\n+\n+\tpublic String getDriverName ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getDriverName ();\n+\t}\n+\n+\n+\tpublic String getDriverVersion ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getDriverVersion ();\n+\t}\n+\n+\n+\tpublic ResultSet getExportedKeys (String catalog, String schema,\n+\t\tString table)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getExportedKeys (catalog, schema, table);\n+\t}\n+\n+\n+\tpublic String getExtraNameCharacters ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getExtraNameCharacters ();\n+\t}\n+\n+\n+\tpublic String getIdentifierQuoteString ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getIdentifierQuoteString ();\n+\t}\n+\n+\n+\tpublic ResultSet getImportedKeys (String catalog, String schema,\n+\t\tString table)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getImportedKeys (catalog, schema, table);\n+\t}\n+\n+\n+\tpublic ResultSet getIndexInfo (String catalog, String schema,\n+\t\tString table, boolean unique, boolean approximate)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getIndexInfo (catalog, schema, table, unique,\n+\t\t\tapproximate);\n+\t}\n+\n+\n+\tpublic int getMaxBinaryLiteralLength ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxBinaryLiteralLength ();\n+\t}\n+\n+\n+\tpublic int getMaxCatalogNameLength ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxCatalogNameLength ();\n+\t}\n+\n+\n+\tpublic int getMaxCharLiteralLength ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxCharLiteralLength ();\n+\t}\n+\n+\n+\tpublic int getMaxColumnNameLength ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxColumnNameLength ();\n+\t}\n+\n+\n+\tpublic int getMaxColumnsInGroupBy ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxColumnsInGroupBy ();\n+\t}\n+\n+\n+\tpublic int getMaxColumnsInIndex ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxColumnsInIndex ();\n+\t}\n+\n+\n+\tpublic int getMaxColumnsInOrderBy ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxColumnsInOrderBy ();\n+\t}\n+\n+\n+\tpublic int getMaxColumnsInSelect ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxColumnsInSelect ();\n+\t}\n+\n+\n+\tpublic int getMaxColumnsInTable ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxColumnsInTable ();\n+\t}\n+\n+\n+\tpublic int getMaxConnections ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxConnections ();\n+\t}\n+\n+\n+\tpublic int getMaxCursorNameLength ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxCursorNameLength ();\n+\t}\n+\n+\n+\tpublic int getMaxIndexLength ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxIndexLength ();\n+\t}\n+\n+\n+\tpublic int getMaxProcedureNameLength ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxProcedureNameLength ();\n+\t}\n+\n+\n+\tpublic int getMaxRowSize ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxRowSize ();\n+\t}\n+\n+\n+\tpublic int getMaxSchemaNameLength ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxSchemaNameLength ();\n+\t}\n+\n+\n+\tpublic int getMaxStatementLength ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxStatementLength ();\n+\t}\n+\n+\n+\tpublic int getMaxStatements ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxStatements ();\n+\t}\n+\n+\n+\tpublic int getMaxTableNameLength ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxTableNameLength ();\n+\t}\n+\n+\n+\tpublic int getMaxTablesInSelect ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxTablesInSelect ();\n+\t}\n+\n+\n+\tpublic int getMaxUserNameLength ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getMaxUserNameLength ();\n+\t}\n+\n+\n+\tpublic String getNumericFunctions ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getNumericFunctions ();\n+\t}\n+\n+\n+\tpublic ResultSet getPrimaryKeys (String catalog, String schema,\n+\t\tString table)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getPrimaryKeys (catalog, schema, table);\n+\t}\n+\n+\n+\tpublic ResultSet getProcedureColumns (String catalog, String schemaPattern,\n+\t\tString procedureNamePattern, String columnNamePattern)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getProcedureColumns (catalog, schemaPattern,\n+\t\t\tprocedureNamePattern, columnNamePattern);\n+\t}\n+\n+\n+\tpublic ResultSet getProcedures (String catalog, String schemaPattern,\n+\t\tString procedureNamePattern)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getProcedures (catalog, schemaPattern,\n+\t\t\tprocedureNamePattern);\n+\t}\n+\n+\n+\tpublic String getProcedureTerm ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getProcedureTerm ();\n+\t}\n+\n+\n+\tpublic ResultSet getSchemas ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getSchemas ();\n+\t}\n+\n+\n+\tpublic String getSchemaTerm ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getSchemaTerm ();\n+\t}\n+\n+\n+\tpublic String getSearchStringEscape ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getSearchStringEscape ();\n+\t}\n+\n+\n+\tpublic String getSQLKeywords ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getSQLKeywords ();\n+\t}\n+\n+\n+\tpublic String getStringFunctions ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getStringFunctions ();\n+\t}\n+\n+\n+\tpublic String getSystemFunctions ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getSystemFunctions ();\n+\t}\n+\n+\n+\tpublic ResultSet getTablePrivileges (String catalog,\n+\t\tString schemaPattern, String tableNamePattern)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getTablePrivileges (catalog, schemaPattern,\n+\t\t\ttableNamePattern);\n+\t}\n+\n+\n+\tpublic ResultSet getTables (String catalog, String schemaPattern,\n+\t\tString tableNamePattern, String[] types)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getTables (catalog, schemaPattern,\n+\t\t\ttableNamePattern, types);\n+\t}\n+\n+\n+\tpublic ResultSet getTableTypes ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getTableTypes ();\n+\t}\n+\n+\n+\tpublic String getTimeDateFunctions ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getTimeDateFunctions ();\n+\t}\n+\n+\n+\tpublic ResultSet getTypeInfo ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getTypeInfo ();\n+\t}\n+\n+\n+\tpublic ResultSet getUDTs (String catalog, String schemaPattern,\n+\t\tString typeNamePattern, int[] types)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getUDTs (catalog, schemaPattern,\n+\t\t\ttypeNamePattern, types);\n+\t}\n+\n+\n+\tpublic String getURL ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getURL ();\n+\t}\n+\n+\n+\tpublic String getUserName ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getUserName ();\n+\t}\n+\n+\n+\tpublic ResultSet getVersionColumns (String catalog,\n+\t\tString schema, String table)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.getVersionColumns (catalog, schema, table);\n+\t}\n+\n+\n+\tpublic boolean insertsAreDetected (int type)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.insertsAreDetected (type);\n+\t}\n+\n+\n+\tpublic boolean isCatalogAtStart ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.isCatalogAtStart ();\n+\t}\n+\n+\n+\tpublic boolean isReadOnly ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.isReadOnly ();\n+\t}\n+\n+\n+\tpublic boolean nullPlusNonNullIsNull ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.nullPlusNonNullIsNull ();\n+\t}\n+\n+\n+\tpublic boolean nullsAreSortedAtEnd ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.nullsAreSortedAtEnd ();\n+\t}\n+\n+\n+\tpublic boolean nullsAreSortedAtStart ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.nullsAreSortedAtStart ();\n+\t}\n+\n+\n+\tpublic boolean nullsAreSortedHigh ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.nullsAreSortedHigh ();\n+\t}\n+\n+\n+\tpublic boolean nullsAreSortedLow ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.nullsAreSortedLow ();\n+\t}\n+\n+\n+\tpublic boolean othersDeletesAreVisible (int type)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.othersDeletesAreVisible (type);\n+\t}\n+\n+\n+\tpublic boolean othersInsertsAreVisible (int type)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.othersInsertsAreVisible (type);\n+\t}\n+\n+\n+\tpublic boolean othersUpdatesAreVisible (int type)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.othersUpdatesAreVisible (type);\n+\t}\n+\n+\n+\tpublic boolean ownDeletesAreVisible (int type)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.ownDeletesAreVisible (type);\n+\t}\n+\n+\n+\tpublic boolean ownInsertsAreVisible (int type)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.ownInsertsAreVisible (type);\n+\t}\n+\n+\n+\tpublic boolean ownUpdatesAreVisible (int type)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.ownUpdatesAreVisible (type);\n+\t}\n+\n+\n+\tpublic boolean storesLowerCaseIdentifiers ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.storesLowerCaseIdentifiers ();\n+\t}\n+\n+\n+\tpublic boolean storesLowerCaseQuotedIdentifiers ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.storesLowerCaseQuotedIdentifiers ();\n+\t}\n+\n+\n+\tpublic boolean storesMixedCaseIdentifiers ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.storesMixedCaseIdentifiers ();\n+\t}\n+\n+\n+\tpublic boolean storesMixedCaseQuotedIdentifiers ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.storesMixedCaseQuotedIdentifiers ();\n+\t}\n+\n+\n+\tpublic boolean storesUpperCaseIdentifiers ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.storesUpperCaseIdentifiers ();\n+\t}\n+\n+\n+\tpublic boolean storesUpperCaseQuotedIdentifiers ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.storesUpperCaseQuotedIdentifiers ();\n+\t}\n+\n+\n+\tpublic boolean supportsAlterTableWithAddColumn ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsAlterTableWithAddColumn ();\n+\t}\n+\n+\n+\tpublic boolean supportsAlterTableWithDropColumn ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsAlterTableWithDropColumn ();\n+\t}\n+\n+\n+\tpublic boolean supportsANSI92EntryLevelSQL ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsANSI92EntryLevelSQL ();\n+\t}\n+\n+\n+\tpublic boolean supportsANSI92FullSQL ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsANSI92FullSQL ();\n+\t}\n+\n+\n+\tpublic boolean supportsANSI92IntermediateSQL ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsANSI92IntermediateSQL ();\n+\t}\n+\n+\n+\tpublic boolean supportsBatchUpdates ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsBatchUpdates ();\n+\t}\n+\n+\n+\tpublic boolean supportsCatalogsInDataManipulation ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsCatalogsInDataManipulation ();\n+\t}\n+\n+\n+\tpublic boolean supportsCatalogsInIndexDefinitions ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsCatalogsInIndexDefinitions ();\n+\t}\n+\n+\n+\tpublic boolean supportsCatalogsInPrivilegeDefinitions ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsCatalogsInPrivilegeDefinitions ();\n+\t}\n+\n+\n+\tpublic boolean supportsCatalogsInProcedureCalls ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsCatalogsInProcedureCalls ();\n+\t}\n+\n+\n+\tpublic boolean supportsCatalogsInTableDefinitions ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsCatalogsInTableDefinitions ();\n+\t}\n+\n+\n+\tpublic boolean supportsColumnAliasing ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsColumnAliasing ();\n+\t}\n+\n+\n+\tpublic boolean supportsConvert ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsConvert ();\n+\t}\n+\n+\n+\tpublic boolean supportsConvert (int fromType, int toType)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsConvert (fromType, toType);\n+\t}\n+\n+\n+\tpublic boolean supportsCoreSQLGrammar ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsCoreSQLGrammar ();\n+\t}\n+\n+\n+\tpublic boolean supportsCorrelatedSubqueries ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsCorrelatedSubqueries ();\n+\t}\n+\n+\n+\tpublic boolean supportsDataDefinitionAndDataManipulationTransactions ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData\n+\t\t\t.supportsDataDefinitionAndDataManipulationTransactions ();\n+\t}\n+\n+\n+\tpublic boolean supportsDataManipulationTransactionsOnly ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsDataManipulationTransactionsOnly ();\n+\t}\n+\n+\n+\tpublic boolean supportsDifferentTableCorrelationNames ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsDifferentTableCorrelationNames ();\n+\t}\n+\n+\n+\tpublic boolean supportsExpressionsInOrderBy ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsExpressionsInOrderBy ();\n+\t}\n+\n+\n+\tpublic boolean supportsExtendedSQLGrammar ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsExtendedSQLGrammar ();\n+\t}\n+\n+\n+\tpublic boolean supportsFullOuterJoins ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsFullOuterJoins ();\n+\t}\n+\n+\n+\tpublic boolean supportsGroupBy ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsGroupBy ();\n+\t}\n+\n+\n+\tpublic boolean supportsGroupByBeyondSelect ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsGroupByBeyondSelect ();\n+\t}\n+\n+\n+\tpublic boolean supportsGroupByUnrelated ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsGroupByUnrelated ();\n+\t}\n+\n+\n+\tpublic boolean supportsIntegrityEnhancementFacility ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsIntegrityEnhancementFacility ();\n+\t}\n+\n+\n+\tpublic boolean supportsLikeEscapeClause ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsLikeEscapeClause ();\n+\t}\n+\n+\n+\tpublic boolean supportsLimitedOuterJoins ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsLimitedOuterJoins ();\n+\t}\n+\n+\n+\tpublic boolean supportsMinimumSQLGrammar ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsMinimumSQLGrammar ();\n+\t}\n+\n+\n+\tpublic boolean supportsMixedCaseIdentifiers ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsMixedCaseIdentifiers ();\n+\t}\n+\n+\n+\tpublic boolean supportsMixedCaseQuotedIdentifiers ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsMixedCaseQuotedIdentifiers ();\n+\t}\n+\n+\n+\tpublic boolean supportsMultipleResultSets ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsMultipleResultSets ();\n+\t}\n+\n+\n+\tpublic boolean supportsMultipleTransactions ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsMultipleTransactions ();\n+\t}\n+\n+\n+\tpublic boolean supportsNonNullableColumns ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsNonNullableColumns ();\n+\t}\n+\n+\n+\tpublic boolean supportsOpenCursorsAcrossCommit ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsOpenCursorsAcrossCommit ();\n+\t}\n+\n+\n+\tpublic boolean supportsOpenCursorsAcrossRollback ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsOpenCursorsAcrossRollback ();\n+\t}\n+\n+\n+\tpublic boolean supportsOpenStatementsAcrossCommit ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsOpenStatementsAcrossCommit ();\n+\t}\n+\n+\n+\tpublic boolean supportsOpenStatementsAcrossRollback ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsOpenStatementsAcrossRollback ();\n+\t}\n+\n+\n+\tpublic boolean supportsOrderByUnrelated ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsOrderByUnrelated ();\n+\t}\n+\n+\n+\tpublic boolean supportsOuterJoins ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsOuterJoins ();\n+\t}\n+\n+\n+\tpublic boolean supportsPositionedDelete ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsPositionedDelete ();\n+\t}\n+\n+\n+\tpublic boolean supportsPositionedUpdate ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsPositionedUpdate ();\n+\t}\n+\n+\n+\tpublic boolean supportsResultSetConcurrency (int type, int concurrency)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsResultSetConcurrency (type, concurrency);\n+\t}\n+\n+\n+\tpublic boolean supportsResultSetType (int type)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsResultSetType (type);\n+\t}\n+\n+\n+\tpublic boolean supportsSchemasInDataManipulation ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsSchemasInDataManipulation ();\n+\t}\n+\n+\n+\tpublic boolean supportsSchemasInIndexDefinitions ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsSchemasInIndexDefinitions ();\n+\t}\n+\n+\n+\tpublic boolean supportsSchemasInPrivilegeDefinitions ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsSchemasInPrivilegeDefinitions ();\n+\t}\n+\n+\n+\tpublic boolean supportsSchemasInProcedureCalls ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsSchemasInProcedureCalls ();\n+\t}\n+\n+\n+\tpublic boolean supportsSchemasInTableDefinitions ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsSchemasInTableDefinitions ();\n+\t}\n+\n+\n+\tpublic boolean supportsSelectForUpdate ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsSelectForUpdate ();\n+\t}\n+\n+\n+\tpublic boolean supportsStoredProcedures ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsStoredProcedures ();\n+\t}\n+\n+\n+\tpublic boolean supportsSubqueriesInComparisons ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsSubqueriesInComparisons ();\n+\t}\n+\n+\n+\tpublic boolean supportsSubqueriesInExists ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsSubqueriesInExists ();\n+\t}\n+\n+\n+\tpublic boolean supportsSubqueriesInIns ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsSubqueriesInIns ();\n+\t}\n+\n+\n+\tpublic boolean supportsSubqueriesInQuantifieds ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsSubqueriesInQuantifieds ();\n+\t}\n+\n+\n+\tpublic boolean supportsTableCorrelationNames ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsTableCorrelationNames ();\n+\t}\n+\n+\n+\tpublic boolean supportsTransactionIsolationLevel (int level)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsTransactionIsolationLevel (level);\n+\t}\n+\n+\n+\tpublic boolean supportsTransactions ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsTransactions ();\n+\t}\n+\n+\n+\tpublic boolean supportsUnion ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsUnion ();\n+\t}\n+\n+\n+\tpublic boolean supportsUnionAll ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.supportsUnionAll ();\n+\t}\n+\n+\n+\tpublic boolean updatesAreDetected (int type)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.updatesAreDetected (type);\n+\t}\n+\n+\n+\tpublic boolean usesLocalFilePerTable ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.usesLocalFilePerTable ();\n+\t}\n+\n+\n+\tpublic boolean usesLocalFiles ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _metaData.usesLocalFiles ();\n+\t}\n+\n+\n+\t// JDBC 3.0 methods (unsupported) follow; these are required to be able to \n+\t// compile against JDK 1.4\n+\n+\n+\tpublic boolean supportsSavepoints ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic boolean supportsNamedParameters ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic boolean supportsMultipleOpenResults ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic boolean supportsGetGeneratedKeys ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic ResultSet getSuperTypes (String catalog, String schemaPatter,\n+\t\tString typeNamePattern)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic ResultSet getSuperTables (String catalog, String schemaPatter,\n+\t\tString tableNamePattern)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic ResultSet getAttributes (String catalog, String schemaPatter,\n+\t\tString typeNamePattern, String attributeNamePattern)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic boolean supportsResultSetHoldability (int holdability)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int getResultSetHoldability ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int getDatabaseMajorVersion ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int getDatabaseMinorVersion ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int getJDBCMajorVersion ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int getJDBCMinorVersion ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int getSQLStateType ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic boolean locatorsUpdateCopy ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic boolean supportsStatementPooling ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+}\n+"},{"sha":"476eb7e1e8ef6d6c0c62d2865e2e72c91233c675","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingPreparedStatement.java","status":"added","additions":684,"deletions":0,"changes":684,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingPreparedStatement.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingPreparedStatement.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingPreparedStatement.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,684 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+import java.io.*;\n+import java.math.*;\n+import java.net.*;\n+import java.sql.*;\n+import java.sql.Date;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.lib.util.Closeable;\n+\n+\n+/**\n+ *\t<p>Wrapper around an existing statement.  Subclasses can override the\n+ *\tmethods whose behavior they mean to change.  The <code>equals</code> and \n+ *\t<code>hashCode</code> methods pass through to the base underlying data \n+ *\tstore statement.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ */\n+public class DelegatingPreparedStatement\n+\timplements PreparedStatement, Closeable\n+{\n+\tprivate final PreparedStatement \t\t\t_stmnt;\n+\tprivate final DelegatingPreparedStatement\t_del;\n+\tprivate final Connection\t\t\t\t\t_conn;\n+\n+\n+\tpublic DelegatingPreparedStatement (PreparedStatement stmnt, \n+\t\tConnection conn)\n+\t{\n+\t\t_conn = conn;\n+\t\t_stmnt = stmnt;\n+\t\tif (_stmnt instanceof DelegatingPreparedStatement)\n+\t\t\t_del = (DelegatingPreparedStatement) _stmnt;\n+\t\telse\n+\t\t\t_del = null;\n+\t}\n+\n+\n+\tprotected ResultSet wrapResult (ResultSet rs, boolean wrap)\n+\t{\n+\t\tif (!wrap || rs == null)\n+\t\t\treturn rs;\n+\t\treturn new DelegatingResultSet (rs, this);\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the wrapped statement.\n+\t */\n+\tpublic PreparedStatement getDelegate ()\n+\t{\n+\t\treturn _stmnt;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the base underlying data store statement.\n+\t */\n+\tpublic PreparedStatement getInnermostDelegate ()\n+\t{\n+\t\treturn (_del == null) ? _stmnt : _del.getInnermostDelegate ();\n+\t}\n+\n+\n+\tpublic int hashCode ()\n+\t{\n+\t\treturn getInnermostDelegate ().hashCode ();\n+\t}\n+\n+\n+\tpublic boolean equals (Object other)\n+\t{\n+\t\tif (other == this)\n+\t\t\treturn true;\n+\t\tif (other instanceof DelegatingPreparedStatement)\n+\t\t\tother = ((DelegatingPreparedStatement) other).\n+\t\t\t\tgetInnermostDelegate ();\n+\t\treturn getInnermostDelegate ().equals (other);\n+\t}\n+\n+\n+\tpublic String toString ()\n+\t{\n+\t\tStringBuffer buf = new StringBuffer (\"prepstmnt \").append (hashCode ());\n+\t\tappendInfo (buf);\n+\t\treturn buf.toString ();\n+\t}\n+\n+\n+\tprotected void appendInfo (StringBuffer buf)\n+\t{\n+\t\tif (_del != null)\n+\t\t\t_del.appendInfo (buf);\n+\t}\n+\n+\n+    public ResultSet executeQuery (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\treturn executeQuery (str, true);\n+\t}\n+\n+\n+\t/**\n+ \t *\tExecute the query, with the option of not wrapping it in a\n+\t *\t{@link DelegatingResultSet}, which is the default.\n+\t */\n+\tprotected ResultSet executeQuery (String sql, boolean wrap)\n+\t\tthrows SQLException\n+\t{\n+\t\tResultSet rs;\n+\t\tif (_del != null)\n+\t\t\trs = _del.executeQuery (sql, false);\n+\t\telse\n+\t\t\trs = _stmnt.executeQuery (sql);\n+\t\treturn wrapResult (rs, wrap);\n+\t}\n+\n+\n+    public int executeUpdate (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.executeUpdate (str);\n+\t}\n+\n+\n+    public boolean execute (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.execute (str);\n+\t}\n+\n+\n+    public void close () \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.close ();\n+\t}\n+\n+\n+    public int getMaxFieldSize () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getMaxFieldSize ();\n+\t}\n+\n+\n+    public void setMaxFieldSize (int i) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setMaxFieldSize (i);\n+\t}\n+\n+\n+    public int getMaxRows () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getMaxRows ();\n+\t}\n+\n+\n+    public void setMaxRows (int i) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setMaxRows (i);\n+\t}\n+\n+\n+    public void setEscapeProcessing (boolean bool) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setEscapeProcessing (bool);\n+\t}\n+\n+\n+    public int getQueryTimeout () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getQueryTimeout ();\n+\t}\n+\n+\n+    public void setQueryTimeout (int i) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setQueryTimeout (i);\n+\t}\n+\n+\n+    public void cancel () \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.cancel ();\n+\t}\n+\n+\n+    public SQLWarning getWarnings () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getWarnings ();\n+\t}\n+\n+\n+    public void clearWarnings () \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.clearWarnings ();\n+\t}\n+\n+\n+    public void setCursorName (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setCursorName (str);\n+\t}\n+\n+\n+    public ResultSet getResultSet () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn getResultSet (true);\n+\t}\n+\n+\n+\t/**\n+ \t *\tGet the last result set, with the option of not wrapping it in a\n+\t *\t{@link DelegatingResultSet}, which is the default.\n+\t */\n+\tprotected ResultSet getResultSet (boolean wrap)\n+\t\tthrows SQLException\n+\t{\n+\t\tResultSet rs;\n+\t\tif (_del != null)\n+\t\t\trs = _del.getResultSet (false);\n+\t\telse\n+\t\t\trs = _stmnt.getResultSet ();\n+\t\treturn wrapResult (rs, wrap);\n+\t}\n+\n+\n+    public int getUpdateCount () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getUpdateCount ();\n+\t}\n+\n+\n+    public boolean getMoreResults () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getMoreResults ();\n+\t}\n+\n+\n+    public void setFetchDirection (int i) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setFetchDirection (i);\n+\t}\n+\n+\n+    public int getFetchDirection () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getFetchDirection ();\n+\t}\n+\n+\n+    public void setFetchSize (int i) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setFetchSize (i);\n+\t}\n+\n+\n+    public int getFetchSize () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getFetchSize ();\n+\t}\n+\n+\n+    public int getResultSetConcurrency () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getResultSetConcurrency ();\n+\t}\n+\n+\n+    public int getResultSetType () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getResultSetType ();\n+\t}\n+\n+\n+    public void addBatch (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.addBatch (str);\n+\t}\n+\n+\n+    public void clearBatch () \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.clearBatch ();\n+\t}\n+\n+\n+    public int[] executeBatch ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.executeBatch ();\n+\t}\n+\n+\n+    public Connection getConnection () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _conn;\n+\t}\n+\n+\n+\tpublic ResultSet executeQuery () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn executeQuery (true);\n+\t}\n+\n+\n+\t/**\n+ \t *\tExecute the query, with the option of not wrapping it in a\n+\t *\t{@link DelegatingResultSet}, which is the default.\n+\t */\n+\tprotected ResultSet executeQuery (boolean wrap)\n+\t\tthrows SQLException\n+\t{\n+\t\tResultSet rs;\n+\t\tif (_del != null)\n+\t\t\trs = _del.executeQuery (false);\n+\t\telse\n+\t\t\trs = _stmnt.executeQuery ();\n+\t\treturn wrapResult (rs, wrap);\n+\t}\n+\n+\n+\tpublic int executeUpdate  () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.executeUpdate ();\n+\t}\n+\n+\n+\tpublic void setNull (int i1, int i2) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setNull (i1, i2);\n+\t}\n+\n+\n+\tpublic void setBoolean (int i, boolean b) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setBoolean (i, b);\n+\t}\n+\n+\n+\tpublic void setByte (int i, byte b) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setByte (i, b);\n+\t}\n+\n+\n+\tpublic void setShort (int i, short s) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setShort (i, s);\n+\t}\n+\n+\n+\tpublic void setInt (int i1, int i2) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setInt (i1, i2);\n+\t}\n+\n+\n+\tpublic void setLong (int i, long l) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setLong (i, l);\n+\t}\n+\n+\n+\tpublic void setFloat (int i, float f) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setFloat (i, f);\n+\t}\n+\n+\n+\tpublic void setDouble (int i, double d) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setDouble (i, d);\n+\t}\n+\n+\n+\tpublic void setBigDecimal (int i, BigDecimal bd) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setBigDecimal (i, bd);\n+\t}\n+\n+\n+\tpublic void setString (int i, String s) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setString (i, s);\n+\t}\n+\n+\n+\tpublic void setBytes (int i, byte[] b) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setBytes (i, b);\n+\t}\n+\n+\n+\tpublic void setDate (int i, Date d) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setDate (i, d);\n+\t}\n+\n+\n+\tpublic void setTime (int i, Time t) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setTime (i, t);\n+\t}\n+\n+\n+\tpublic void setTimestamp (int i, Timestamp t) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setTimestamp (i, t);\n+\t}\n+\n+\n+\tpublic void setAsciiStream (int i1, InputStream is, int i2) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setAsciiStream (i1, is, i2);\n+\t}\n+\n+\n+\tpublic void setUnicodeStream (int i1, InputStream is, int i2) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setUnicodeStream (i1, is, i2);\n+\t}\n+\n+\n+\tpublic void setBinaryStream (int i1, InputStream is, int i2) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setBinaryStream (i1, is, i2);\n+\t}\n+\n+\n+    public void clearParameters () \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.clearParameters ();\n+\t}\n+\n+\n+\tpublic void setObject (int i1, Object o, int i2, int i3) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setObject (i1, o, i2, i3);\n+\t}\n+\n+\n+\tpublic void setObject (int i1, Object o, int i2)\n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setObject (i1, o, i2);\n+\t}\n+\n+\n+\tpublic void setObject (int i, Object o) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setObject (i, o);\n+\t}\n+\n+\n+    public boolean execute () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.execute ();\n+\t}\n+\n+\n+    public void addBatch () \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.addBatch ();\n+\t}\n+\n+\n+\tpublic void setCharacterStream (int i1, Reader r, int i2)\n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setCharacterStream (i1, r, i2);\n+\t}\n+\n+\n+\tpublic void setRef (int i, Ref r) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setRef (i, r);\n+\t}\n+\n+\n+\tpublic void setBlob (int i, Blob b) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setBlob (i, b);\n+\t}\n+\n+\n+\tpublic void setClob (int i, Clob c) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setClob (i, c);\n+\t}\n+\n+\n+\tpublic void setArray (int i, Array a) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setArray (i, a);\n+\t}\n+\n+\n+    public ResultSetMetaData getMetaData () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getMetaData ();\n+\t}\n+\n+\n+\tpublic void setDate (int i, Date d, Calendar c) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setDate (i, d, c);\n+\t}\n+\n+\n+\tpublic void setTime (int i, Time t, Calendar c) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setTime (i, t, c);\n+\t}\n+\n+\n+\tpublic void setTimestamp (int i, Timestamp t, Calendar c) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setTimestamp (i, t, c);\n+\t}\n+\n+\n+\tpublic void setNull (int i1, int i2, String s) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setNull (i1, i2, s);\n+\t}\n+\n+\n+\t// JDBC 3.0 (unsupported) method follow; these are required to be able \n+\t// to compile against JDK 1.4\n+\n+\n+\tpublic boolean getMoreResults (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic ResultSet getGeneratedKeys ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int executeUpdate (String s, int i) \n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int executeUpdate (String s, int[] ia)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int executeUpdate (String s, String[] sa)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic boolean execute (String s, int i)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic boolean execute (String s, int[] ia)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic boolean execute (String s, String[] sa)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int getResultSetHoldability ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void setURL (int i, URL url)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic ParameterMetaData getParameterMetaData ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+}"},{"sha":"56cdcb9e7158dd231b5be4914f87e7a8dcd135bc","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingResultSet.java","status":"added","additions":1085,"deletions":0,"changes":1085,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingResultSet.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingResultSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingResultSet.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,1085 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+import java.io.*;\n+import java.math.*;\n+import java.net.*;\n+import java.sql.*;\n+import java.sql.Date;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.lib.util.Closeable;\n+\n+\n+/**\n+ *\t<p>Wrapper around an existing result set.  Subclasses can override the\n+ *\tmethods whose behavior they mean to change.  The <code>equals</code> and \n+ *\t<code>hashCode</code> methods pass through to the base underlying data \n+ *\tstore statement.</p>\n+ *\n+ *\t@author \tMarc Prud'hommeaux\n+ */\n+public class DelegatingResultSet\n+\timplements ResultSet, Closeable\n+{\n+\tprivate final ResultSet \t\t\t_rs;\n+\tprivate final DelegatingResultSet\t_del;\n+\tprivate final Statement \t\t\t_stmnt;\n+\n+\n+\tpublic DelegatingResultSet (ResultSet rs, Statement stmnt)\n+\t{\n+\t\tif (rs == null)\n+\t\t\tthrow new IllegalArgumentException ();\n+\n+\t\t_stmnt = stmnt;\n+\t\t_rs = rs;\n+\t\tif (_rs instanceof DelegatingResultSet)\n+\t\t\t_del = (DelegatingResultSet) _rs;\n+\t\telse\n+\t\t\t_del = null;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the wrapped result set.\n+\t */\n+\tpublic ResultSet getDelegate ()\n+\t{\n+\t\treturn _rs;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the inner-most wrapped delegate.\n+\t */\n+\tpublic ResultSet getInnermostDelegate ()\n+\t{\n+\t\treturn (_del == null) ? _rs : _del.getInnermostDelegate ();\n+\t}\n+\n+\n+\tpublic int hashCode ()\n+\t{\n+\t\treturn _rs.hashCode ();\n+\t}\n+\n+\n+\tpublic boolean equals (Object other)\n+\t{\n+\t\tif (other == this)\n+\t\t\treturn true;\n+\t\tif (other instanceof DelegatingResultSet)\n+\t\t\tother = ((DelegatingResultSet) other).getInnermostDelegate ();\n+\t\treturn getInnermostDelegate ().equals (other);\n+\t}\n+\n+\n+\tpublic String toString ()\n+\t{\n+\t\tStringBuffer buf = new StringBuffer (\"resultset \").append (hashCode ());\n+\t\tappendInfo (buf);\n+\t\treturn buf.toString ();\n+\t}\n+\n+\n+\tprotected void appendInfo (StringBuffer buf)\n+\t{\n+\t\tif (_del != null)\n+\t\t\t_del.appendInfo (buf);\n+\t}\n+\n+\n+    public boolean next ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.next ();\n+\t}\n+\n+\n+    public void close ()\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.close ();\n+\t}\n+\n+\n+    public boolean wasNull ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.wasNull ();\n+\t}\n+\n+\n+    public String getString (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getString (a);\n+\t}\n+\n+\n+    public boolean getBoolean (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getBoolean (a);\n+\t}\n+\n+\n+    public byte getByte (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getByte (a);\n+\t}\n+\n+\n+    public short getShort (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getShort (a);\n+\t}\n+\n+\n+    public int getInt (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getInt (a);\n+\t}\n+\n+\n+    public long getLong (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getLong (a);\n+\t}\n+\n+\n+    public float getFloat (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getFloat (a);\n+\t}\n+\n+\n+    public double getDouble (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getDouble (a);\n+\t}\n+\n+\n+    public BigDecimal getBigDecimal (int a, int b)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getBigDecimal (a, b);\n+\t}\n+\n+\n+    public byte[] getBytes (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getBytes (a);\n+\t}\n+\n+\n+    public Date getDate (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getDate (a);\n+\t}\n+\n+\n+    public Time getTime (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getTime (a);\n+\t}\n+\n+\n+    public Timestamp getTimestamp (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getTimestamp (a);\n+\t}\n+\n+\n+    public InputStream getAsciiStream (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getAsciiStream (a);\n+\t}\n+\n+\n+    public InputStream getUnicodeStream (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getUnicodeStream (a);\n+\t}\n+\n+\n+    public InputStream getBinaryStream (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getBinaryStream (a);\n+\t}\n+\n+\n+    public String getString (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getString (a);\n+\t}\n+\n+\n+    public boolean getBoolean (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getBoolean (a);\n+\t}\n+\n+\n+    public byte getByte (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getByte (a);\n+\t}\n+\n+\n+    public short getShort (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getShort (a);\n+\t}\n+\n+\n+    public int getInt (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getInt (a);\n+\t}\n+\n+\n+    public long getLong (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getLong (a);\n+\t}\n+\n+\n+    public float getFloat (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getFloat (a);\n+\t}\n+\n+\n+    public double getDouble (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getDouble (a);\n+\t}\n+\n+\n+    public BigDecimal getBigDecimal (String a, int b)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getBigDecimal (a, b);\n+\t}\n+\n+\n+    public byte[] getBytes (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getBytes (a);\n+\t}\n+\n+\n+    public Date getDate (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getDate (a);\n+\t}\n+\n+\n+    public Time getTime (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getTime (a);\n+\t}\n+\n+\n+    public Timestamp getTimestamp (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getTimestamp (a);\n+\t}\n+\n+\n+    public InputStream getAsciiStream (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getAsciiStream (a);\n+\t}\n+\n+\n+    public InputStream getUnicodeStream (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getUnicodeStream (a);\n+\t}\n+\n+\n+    public InputStream getBinaryStream (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getBinaryStream (a);\n+\t}\n+\n+\n+    public SQLWarning getWarnings ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getWarnings ();\n+\t}\n+\n+\n+    public void clearWarnings ()\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.clearWarnings ();\n+\t}\n+\n+\n+    public String getCursorName ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getCursorName ();\n+\t}\n+\n+\n+    public ResultSetMetaData getMetaData ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getMetaData ();\n+\t}\n+\n+\n+    public Object getObject (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getObject (a);\n+\t}\n+\n+\n+    public Object getObject (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getObject (a);\n+\t}\n+\n+\n+    public int findColumn (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.findColumn (a);\n+\t}\n+\n+\n+    public Reader getCharacterStream (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getCharacterStream (a);\n+\t}\n+\n+\n+    public Reader getCharacterStream (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getCharacterStream (a);\n+\t}\n+\n+\n+    public BigDecimal getBigDecimal (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getBigDecimal (a);\n+\t}\n+\n+\n+    public BigDecimal getBigDecimal (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getBigDecimal (a);\n+\t}\n+\n+\n+    public boolean isBeforeFirst ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.isBeforeFirst ();\n+\t}\n+\n+\n+    public boolean isAfterLast ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.isAfterLast ();\n+\t}\n+\n+\n+    public boolean isFirst ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.isFirst ();\n+\t}\n+\n+\n+    public boolean isLast ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.isLast ();\n+\t}\n+\n+\n+    public void beforeFirst ()\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.beforeFirst ();\n+\t}\n+\n+\n+    public void afterLast ()\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.afterLast ();\n+\t}\n+\n+\n+    public boolean first ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.first ();\n+\t}\n+\n+\n+    public boolean last ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.last ();\n+\t}\n+\n+\n+    public int getRow ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getRow ();\n+\t}\n+\n+\n+    public boolean absolute (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.absolute (a);\n+\t}\n+\n+\n+    public boolean relative (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.relative (a);\n+\t}\n+\n+\n+    public boolean previous ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.previous ();\n+\t}\n+\n+\n+    public void setFetchDirection (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.setFetchDirection (a);\n+\t}\n+\n+\n+    public int getFetchDirection ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getFetchDirection ();\n+\t}\n+\n+\n+    public void setFetchSize (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.setFetchSize (a);\n+\t}\n+\n+\n+    public int getFetchSize ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getFetchSize ();\n+\t}\n+\n+\n+    public int getType ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getType ();\n+\t}\n+\n+\n+    public int getConcurrency ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getConcurrency ();\n+\t}\n+\n+\n+    public boolean rowUpdated ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.rowUpdated ();\n+\t}\n+\n+\n+    public boolean rowInserted ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.rowInserted ();\n+\t}\n+\n+\n+    public boolean rowDeleted ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.rowDeleted ();\n+\t}\n+\n+\n+    public void updateNull (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateNull (a);\n+\t}\n+\n+\n+    public void updateBoolean (int a, boolean b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateBoolean (a, b);\n+\t}\n+\n+\n+    public void updateByte (int a, byte b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateByte (a, b);\n+\t}\n+\n+\n+    public void updateShort (int a, short b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateShort (a, b);\n+\t}\n+\n+\n+    public void updateInt (int a, int b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateInt (a, b);\n+\t}\n+\n+\n+    public void updateLong (int a, long b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateLong (a, b);\n+\t}\n+\n+\n+    public void updateFloat (int a, float b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateFloat (a, b);\n+\t}\n+\n+\n+    public void updateDouble (int a, double b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateDouble (a, b);\n+\t}\n+\n+\n+    public void updateBigDecimal (int a, BigDecimal b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateBigDecimal (a, b);\n+\t}\n+\n+\n+    public void updateString (int a, String b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateString (a, b);\n+\t}\n+\n+\n+    public void updateBytes (int a, byte[] b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateBytes (a, b);\n+\t}\n+\n+\n+    public void updateDate (int a, Date b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateDate (a, b);\n+\t}\n+\n+\n+    public void updateTime (int a, Time b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateTime (a, b);\n+\t}\n+\n+\n+    public void updateTimestamp (int a, Timestamp b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateTimestamp (a, b);\n+\t}\n+\n+\n+    public void updateAsciiStream (int a, InputStream in, int b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateAsciiStream (a, in, b);\n+\t}\n+\n+\n+    public void updateBinaryStream (int a, InputStream in, int b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateBinaryStream (a, in, b);\n+\t}\n+\n+\n+    public void updateCharacterStream (int a, Reader reader, int b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateCharacterStream (a, reader, b);\n+\t}\n+\n+\n+    public void updateObject (int a, Object ob, int b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateObject (a, ob, b);\n+\t}\n+\n+\n+    public void updateObject (int a, Object ob)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateObject (a, ob);\n+\t}\n+\n+\n+    public void updateNull (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateNull (a);\n+\t}\n+\n+\n+    public void updateBoolean (String a, boolean b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateBoolean (a, b);\n+\t}\n+\n+\n+    public void updateByte (String a, byte b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateByte (a, b);\n+\t}\n+\n+\n+    public void updateShort (String a, short b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateShort (a, b);\n+\t}\n+\n+\n+    public void updateInt (String a, int b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateInt (a, b);\n+\t}\n+\n+\n+    public void updateLong (String a, long b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateLong (a, b);\n+\t}\n+\n+\n+    public void updateFloat (String a, float b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateFloat (a, b);\n+\t}\n+\n+\n+    public void updateDouble (String a, double b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateDouble (a, b);\n+\t}\n+\n+\n+    public void updateBigDecimal (String a, BigDecimal b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateBigDecimal (a, b);\n+\t}\n+\n+\n+    public void updateString (String a, String b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateString (a, b);\n+\t}\n+\n+\n+    public void updateBytes (String a, byte[] b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateBytes (a, b);\n+\t}\n+\n+\n+    public void updateDate (String a, Date b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateDate (a, b);\n+\t}\n+\n+\n+    public void updateTime (String a, Time b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateTime (a, b);\n+\t}\n+\n+\n+    public void updateTimestamp (String a, Timestamp b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateTimestamp (a, b);\n+\t}\n+\n+\n+    public void updateAsciiStream (String a, InputStream in, int b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateAsciiStream (a, in, b);\n+\t}\n+\n+\n+    public void updateBinaryStream (String a, InputStream in, int b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateBinaryStream (a, in, b);\n+\t}\n+\n+\n+    public void updateCharacterStream (String a, Reader reader, int b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateCharacterStream (a, reader, b);\n+\t}\n+\n+\n+    public void updateObject (String a, Object ob, int b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateObject (a, ob, b);\n+\t}\n+\n+\n+    public void updateObject (String a, Object b)\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateObject (a, b);\n+\t}\n+\n+\n+    public void insertRow ()\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.insertRow ();\n+\t}\n+\n+\n+    public void updateRow ()\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.updateRow ();\n+\t}\n+\n+\n+    public void deleteRow ()\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.deleteRow ();\n+\t}\n+\n+\n+    public void refreshRow ()\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.refreshRow ();\n+\t}\n+\n+\n+    public void cancelRowUpdates ()\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.cancelRowUpdates ();\n+\t}\n+\n+\n+    public void moveToInsertRow ()\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.moveToInsertRow ();\n+\t}\n+\n+\n+    public void moveToCurrentRow ()\n+\t\tthrows SQLException\n+\t{\n+\t\t_rs.moveToCurrentRow ();\n+\t}\n+\n+\n+    public Statement getStatement ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt;\n+\t}\n+\n+\n+    public Object getObject (int a, Map b)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getObject (a, b);\n+\t}\n+\n+\n+    public Ref getRef (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getRef (a);\n+\t}\n+\n+\n+    public Blob getBlob (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getBlob (a);\n+\t}\n+\n+\n+    public Clob getClob (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getClob (a);\n+\t}\n+\n+\n+    public Array getArray (int a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getArray (a);\n+\t}\n+\n+\n+    public Object getObject (String a, Map b)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getObject (a, b);\n+\t}\n+\n+\n+    public Ref getRef (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getRef (a);\n+\t}\n+\n+\n+    public Blob getBlob (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getBlob (a);\n+\t}\n+\n+\n+    public Clob getClob (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getClob (a);\n+\t}\n+\n+\n+    public Array getArray (String a)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getArray (a);\n+\t}\n+\n+\n+    public Date getDate (int a, Calendar b)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getDate (a, b);\n+\t}\n+\n+\n+    public Date getDate (String a, Calendar b)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getDate (a, b);\n+\t}\n+\n+\n+    public Time getTime (int a, Calendar b)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getTime (a, b);\n+\t}\n+\n+\n+    public Time getTime (String a, Calendar b)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getTime (a, b);\n+\t}\n+\n+\n+    public Timestamp getTimestamp (int a, Calendar b)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getTimestamp (a, b);\n+\t}\n+\n+\n+    public Timestamp getTimestamp (String a, Calendar b)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _rs.getTimestamp (a, b);\n+\t}\n+\n+\n+\t// JDBC 3.0 (unsupported) method follow; these are required to be able \n+\t// to compile against JDK 1.4\n+\n+\n+\tpublic URL getURL (int column)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic URL getURL (String columnName)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void updateRef (int column, Ref ref)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void updateRef (String columnName, Ref ref)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void updateBlob (int column, Blob blob)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void updateBlob (String columnName, Blob blob)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void updateClob (int column, Clob clob)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void updateClob (String columnName, Clob clob)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void updateArray (int column, Array array)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic void updateArray (String columnName, Array array)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+}\n+"},{"sha":"d85b3e6ebca94e420aa4d3f7f8be390bb85241de","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingStatement.java","status":"added","additions":402,"deletions":0,"changes":402,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingStatement.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingStatement.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/DelegatingStatement.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,402 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+import java.sql.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+\n+\n+/**\n+ *\t<p>Wrapper around an existing statement.  Subclasses can override the\n+ *\tmethods whose behavior they mean to change.  The <code>equals</code> and \n+ *\t<code>hashCode</code> methods pass through to the base underlying data \n+ *\tstore statement.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ */\n+public class DelegatingStatement\n+\timplements Statement, Closeable\n+{\n+\tprivate final Statement \t\t\t_stmnt;\n+\tprivate final DelegatingStatement\t_del;\n+\tprivate final Connection\t\t\t_conn;\n+\n+\n+\tpublic DelegatingStatement (Statement stmnt, Connection conn)\n+\t{\n+\t\t_conn = conn;\n+\t\t_stmnt = stmnt;\n+\t\tif (stmnt instanceof DelegatingStatement)\n+\t\t\t_del = (DelegatingStatement) stmnt;\n+\t\telse\n+\t\t\t_del = null;\n+\t}\n+\n+\n+\tprotected ResultSet wrapResult (ResultSet rs, boolean wrap)\n+\t{\n+\t\tif (!wrap || rs == null)\n+\t\t\treturn rs;\n+\t\treturn new DelegatingResultSet (rs, this);\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the wrapped statement.\n+\t */\n+\tpublic Statement getDelegate ()\n+\t{\n+\t\treturn _stmnt;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the base underlying data store statement.\n+\t */\n+\tpublic Statement getInnermostDelegate ()\n+\t{\n+\t\treturn (_del == null) ? _stmnt : _del.getInnermostDelegate ();\n+\t}\n+\n+\n+\tpublic int hashCode ()\n+\t{\n+\t\treturn getInnermostDelegate ().hashCode ();\n+\t}\n+\n+\n+\tpublic boolean equals (Object other)\n+\t{\n+\t\tif (other == this)\n+\t\t\treturn true;\n+\t\tif (other instanceof DelegatingStatement)\n+\t\t\tother = ((DelegatingStatement) other).getInnermostDelegate ();\n+\t\treturn getInnermostDelegate ().equals (other);\n+\t}\n+\n+\n+\tpublic String toString ()\n+\t{\n+\t\tStringBuffer buf = new StringBuffer (\"stmnt \").append (hashCode ());\n+\t\tappendInfo (buf);\n+\t\treturn buf.toString ();\n+\t}\n+\n+\n+\tprotected void appendInfo (StringBuffer buf)\n+\t{\n+\t\tif (_del != null)\n+\t\t\t_del.appendInfo (buf);\n+\t}\n+\n+\n+    public ResultSet executeQuery (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\treturn executeQuery (str, true);\n+\t}\n+\n+\n+\t/**\n+ \t *\tExecute the query, with the option of not wrapping it in a\n+\t *\t{@link DelegatingResultSet}, which is the default.\n+\t */\n+\tprotected ResultSet executeQuery (String sql, boolean wrap)\n+\t\tthrows SQLException\n+\t{\n+\t\tResultSet rs;\n+\t\tif (_del != null)\n+\t\t\trs = _del.executeQuery (sql, false);\n+\t\telse\n+\t\t\trs = _stmnt.executeQuery (sql);\n+\t\treturn wrapResult (rs, wrap);\n+\t}\n+\n+\n+    public int executeUpdate (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.executeUpdate (str);\n+\t}\n+\n+\n+    public boolean execute (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.execute (str);\n+\t}\n+\n+\n+    public void close () \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.close ();\n+\t}\n+\n+\n+    public int getMaxFieldSize () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getMaxFieldSize ();\n+\t}\n+\n+\n+    public void setMaxFieldSize (int i) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setMaxFieldSize (i);\n+\t}\n+\n+\n+    public int getMaxRows () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getMaxRows ();\n+\t}\n+\n+\n+    public void setMaxRows (int i) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setMaxRows (i);\n+\t}\n+\n+\n+    public void setEscapeProcessing (boolean bool) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setEscapeProcessing (bool);\n+\t}\n+\n+\n+    public int getQueryTimeout () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getQueryTimeout ();\n+\t}\n+\n+\n+    public void setQueryTimeout (int i) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setQueryTimeout (i);\n+\t}\n+\n+\n+    public void cancel () \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.cancel ();\n+\t}\n+\n+\n+    public SQLWarning getWarnings () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getWarnings ();\n+\t}\n+\n+\n+    public void clearWarnings () \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.clearWarnings ();\n+\t}\n+\n+\n+    public void setCursorName (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setCursorName (str);\n+\t}\n+\n+\n+    public ResultSet getResultSet () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn getResultSet (true);\n+\t}\n+\n+\n+\t/**\n+ \t *\tGet the last result set, with the option of not wrapping it in a\n+\t *\t{@link DelegatingResultSet}, which is the default.\n+\t */\n+\tprotected ResultSet getResultSet (boolean wrap)\n+\t\tthrows SQLException\n+\t{\n+\t\tResultSet rs;\n+\t\tif (_del != null)\n+\t\t\trs = _del.getResultSet (false);\n+\t\telse\n+\t\t\trs = _stmnt.getResultSet ();\n+\t\treturn wrapResult (rs, wrap);\n+\t}\n+\n+\n+    public int getUpdateCount () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getUpdateCount ();\n+\t}\n+\n+\n+    public boolean getMoreResults () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getMoreResults ();\n+\t}\n+\n+\n+    public void setFetchDirection (int i) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setFetchDirection (i);\n+\t}\n+\n+\n+    public int getFetchDirection () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getFetchDirection ();\n+\t}\n+\n+\n+    public void setFetchSize (int i) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.setFetchSize (i);\n+\t}\n+\n+\n+    public int getFetchSize () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getFetchSize ();\n+\t}\n+\n+\n+    public int getResultSetConcurrency () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getResultSetConcurrency ();\n+\t}\n+\n+\n+    public int getResultSetType () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.getResultSetType ();\n+\t}\n+\n+\n+    public void addBatch (String str) \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.addBatch (str);\n+\t}\n+\n+\n+    public void clearBatch () \n+\t\tthrows SQLException\n+\t{\n+\t\t_stmnt.clearBatch ();\n+\t}\n+\n+\n+    public int[] executeBatch ()\n+\t\tthrows SQLException\n+\t{\n+\t\treturn _stmnt.executeBatch ();\n+\t}\n+\n+\n+    public Connection getConnection () \n+\t\tthrows SQLException\n+\t{\n+\t\treturn _conn;\n+\t}\n+\n+\n+\t// JDBC 3.0 (unsupported) method follow; these are required to be able \n+\t// to compile against JDK 1.4\n+\n+\n+\tpublic boolean getMoreResults (int i)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic ResultSet getGeneratedKeys ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int executeUpdate (String s, int i) \n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int executeUpdate (String s, int[] ia)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int executeUpdate (String s, String[] sa)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic boolean execute (String s, int i)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic boolean execute (String s, int[] ia)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic boolean execute (String s, String[] sa)\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tpublic int getResultSetHoldability ()\n+\t\tthrows SQLException\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+}\n+"},{"sha":"62543360683ae79b697a4731ed79f2087c1f79bd","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/JDBCEvent.java","status":"added","additions":175,"deletions":0,"changes":175,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/JDBCEvent.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/JDBCEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/JDBCEvent.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+\n+/** \n+ *  <p>A JDBC event.  The event source will be the connection.</p>\n+ *  \n+ *\t@see\tJDBCListener\n+ *  @author  Marc Prud'hommeaux\n+ *  @author  Abe White\n+ */\n+public class JDBCEvent\n+\textends EventObject\n+{\n+\t/** \n+\t *  Type code indicating that a {@link Statement} is being prepared.\n+\t */\n+\tpublic static final short BEFORE_PREPARE_STATEMENT = 1;\n+\n+\t/** \n+\t *  Type code indicating that a {@link Statement} is being prepared.\n+\t */\n+\tpublic static final short AFTER_PREPARE_STATEMENT = 2;\n+\n+\t/** \n+\t *  Type code indicating that a {@link Statement} is being created.\n+\t */\n+\tpublic static final short BEFORE_CREATE_STATEMENT = 3;\n+\n+\t/** \n+\t *  Type code indicating that a {@link Statement} is being created.\n+\t */\n+\tpublic static final short AFTER_CREATE_STATEMENT = 4;\n+\n+\t/** \n+\t *  Type code indicating that a {@link Statement} is about to be executed.\n+\t */\n+\tpublic static final short BEFORE_EXECUTE_STATEMENT = 5;\n+\n+\t/** \n+\t *  Type code indicating that a {@link Statement} completed execution.\n+\t */\n+\tpublic static final short AFTER_EXECUTE_STATEMENT = 6;\n+\n+\t/** \n+\t *  Type code indicating that a {@link Connection} is about to be committed.\n+\t */\n+\tpublic static final short BEFORE_COMMIT = 7;\n+\n+\t/** \n+\t *  Type code indicating that a {@link Connection} was just committed.\n+\t */\n+\tpublic static final short AFTER_COMMIT = 8;\n+\n+\t/** \n+\t *  Type code indicating that a rollback is about to occur.\n+\t */\n+\tpublic static final short BEFORE_ROLLBACK = 9;\n+\n+\t/** \n+\t *  Type code indicating that a rollback just occured.\n+\t */\n+\tpublic static final short AFTER_ROLLBACK = 10;\n+\n+\t/**\n+\t *\tType code indicating that a connection was obtained.  This does\n+\t *\tnot necessarily mean that the connection is new if pooling is enabled.\n+\t */\n+\tpublic static final short AFTER_CONNECT = 11;\n+\n+\t/**\n+\t *\tType code indicating that a connection was closed.  This does\n+\t *\tnot necessarily mean that the underlying database connection was \n+\t *\tsevered if pooling is enabled.\n+\t */\n+\tpublic static final short BEFORE_CLOSE = 12;\n+\n+\tprivate final short\t\t\t\t\ttype;\n+\tprivate final long \t\t\t\t\ttime;\n+\tprivate final String\t\t\t\tsql;\n+\tprivate final JDBCEvent \t\t\tassociatedEvent;\n+\tprivate final transient Statement \tstatement;\n+\n+\n+\t/**\n+\t *\tConstructor.\n+\t */\n+\tpublic JDBCEvent (Connection source, short type, JDBCEvent associatedEvent, \n+\t\tStatement statement, String sql)\n+\t{\n+\t\tsuper (source);\n+\t\tthis.type = type;\n+\t\tthis.time = System.currentTimeMillis ();\n+\t\tthis.associatedEvent = associatedEvent;\n+\t\tthis.sql = sql;\n+\t\tthis.statement = statement;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the event's type code.\n+\t */\n+\tpublic final short getType ()\n+\t{\n+\t\treturn type;\n+\t}\n+\n+\n+\t/** \n+\t *  Return the Connection for this event.\n+\t */\n+\tpublic final Connection getConnection ()\n+\t{\n+\t\treturn (Connection) getSource ();\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the time the event was constructed.\n+\t */\n+\tpublic final long getTime ()\n+\t{\n+\t\treturn time;\n+\t}\n+\n+\n+\t/** \n+\t *  Return the associated {@link JDBCEvent} for this event.\n+\t * \tFor AFTER_XXX events, this will typically be the JDBCEvent \n+\t *\tthat was created in the\tBEFORE_XXX stage. This may be null when\n+\t * \tan association is not appropriate for the event.\n+\t */\n+\tpublic final JDBCEvent getAssociatedEvent ()\n+\t{\n+\t\treturn associatedEvent;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the SQL associated with this event; may be null.\n+\t */\n+\tpublic final String getSQL ()\n+\t{\n+\t\treturn sql;\n+\t}\n+\n+\n+\t/** \n+\t *  Return the Statement for this event, may be null for events\n+\t * \tunrelated to Statement execution.\n+\t */\n+\tpublic final Statement getStatement ()\n+\t{\n+\t\treturn statement;\n+\t}\n+}\n+"},{"sha":"920931fcd6bde8359d30b8bb43d51d1cbd29a65b","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","status":"added","additions":381,"deletions":0,"changes":381,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,381 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+import java.sql.*;\n+import javax.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+\n+\n+/**\n+ *\t<p>Manages the firing of {@link JDBCEvent}s.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public class JDBCEventConnectionDecorator\n+\textends AbstractEventManager\n+\timplements ConnectionDecorator\n+{\n+\tpublic Connection decorate (Connection conn)\n+\t{\n+\t\tif (!hasListeners ())\n+\t\t\treturn conn;\n+\t\treturn new EventConnection (conn); \n+\t}\n+\n+\n+\t/**\n+\t *\tFire the given event to all listeners.  Prevents creation of an\n+\t *\tevent object when there are no listeners.\n+\t */\n+\tprivate JDBCEvent fireEvent (Connection source, short type, \n+\t\tJDBCEvent associatedEvent, Statement stmnt, String sql)\n+\t{\n+\t\tif (!hasListeners ())\n+\t\t\treturn null;\n+\n+\t\tJDBCEvent event = new JDBCEvent (source, type, associatedEvent,\n+\t\t\tstmnt, sql);\n+\t\tfireEvent (event);\n+\t\treturn event;\n+\t}\n+\n+\n+\t/**\n+\t *\tFire the given event to all listeners.\n+\t */\n+\tprotected void fireEvent (Object event, Object listener)\n+\t{\n+\t\tJDBCListener listen = (JDBCListener) listener;\n+\t\tJDBCEvent ev = (JDBCEvent) event;\n+\t\tswitch (ev.getType ())\n+\t\t{\n+\t\tcase JDBCEvent.BEFORE_PREPARE_STATEMENT:\n+\t\t\tlisten.beforePrepareStatement (ev);\n+\t\t\tbreak;\n+\t\tcase JDBCEvent.AFTER_PREPARE_STATEMENT:\n+\t\t\tlisten.afterPrepareStatement (ev);\n+\t\t\tbreak;\n+\t\tcase JDBCEvent.BEFORE_CREATE_STATEMENT:\n+\t\t\tlisten.beforeCreateStatement (ev);\n+\t\t\tbreak;\n+\t\tcase JDBCEvent.AFTER_CREATE_STATEMENT:\n+\t\t\tlisten.afterCreateStatement (ev);\n+\t\t\tbreak;\n+\t\tcase JDBCEvent.BEFORE_EXECUTE_STATEMENT:\n+\t\t\tlisten.beforeExecuteStatement (ev);\n+\t\t\tbreak;\n+\t\tcase JDBCEvent.AFTER_EXECUTE_STATEMENT:\n+\t\t\tlisten.afterExecuteStatement (ev);\n+\t\t\tbreak;\n+\t\tcase JDBCEvent.BEFORE_COMMIT:\n+\t\t\tlisten.beforeCommit (ev);\n+\t\t\tbreak;\n+\t\tcase JDBCEvent.AFTER_COMMIT:\n+\t\t\tlisten.afterCommit (ev);\n+\t\t\tbreak;\n+\t\tcase JDBCEvent.BEFORE_ROLLBACK:\n+\t\t\tlisten.beforeRollback (ev);\n+\t\t\tbreak;\n+\t\tcase JDBCEvent.AFTER_ROLLBACK:\n+\t\t\tlisten.afterRollback (ev);\n+\t\t\tbreak;\n+\t\tcase JDBCEvent.AFTER_CONNECT:\n+\t\t\tlisten.afterConnect (ev);\n+\t\t\tbreak;\n+\t\tcase JDBCEvent.BEFORE_CLOSE:\n+\t\t\tlisten.beforeClose (ev);\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\t\n+\t/**\n+\t *\tFires events as appropriate.\n+\t */\n+\tprivate class EventConnection\n+\t\textends DelegatingConnection\n+\t{\n+\t\tpublic EventConnection (Connection conn)\n+\t\t{\n+\t\t\tsuper (conn);\n+\t\t\tfireEvent (getDelegate (), JDBCEvent.AFTER_CONNECT, \n+\t\t\t\tnull, null, null);\n+\t\t}\n+\n+\n+\t\tpublic void commit ()\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tJDBCEvent before = fireEvent (getDelegate (), \n+\t\t\t\tJDBCEvent.BEFORE_COMMIT, null, null, null);\n+\t\t\ttry\n+\t\t\t{ \n+\t\t\t\tsuper.commit ();\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tfireEvent (getDelegate (), JDBCEvent.AFTER_COMMIT, before,\n+\t\t\t\t\tnull, null);\t\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\tpublic void rollback ()\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tJDBCEvent before = fireEvent (getDelegate (), \n+\t\t\t\tJDBCEvent.BEFORE_ROLLBACK, null, null, null);\n+\t\t\ttry\n+\t\t\t{ \n+\t\t\t\tsuper.rollback ();\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tfireEvent (getDelegate (), JDBCEvent.AFTER_ROLLBACK, before, \n+\t\t\t\t\tnull, null);\t\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\tprotected Statement createStatement (boolean wrap)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tJDBCEvent before = fireEvent (getDelegate (), \n+\t\t\t\tJDBCEvent.BEFORE_CREATE_STATEMENT, null, null, null);\n+\t\t\tStatement stmnt = null;\n+\t\t\ttry\n+\t\t\t{ \n+\t\t\t\tstmnt = new EventStatement (super.createStatement (false),\n+\t\t\t\t\tEventConnection.this);\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tfireEvent (getDelegate (), JDBCEvent.AFTER_CREATE_STATEMENT, \n+\t\t\t\t\tbefore, stmnt, null);\t\n+\t\t\t}\n+\t\t\treturn stmnt;\n+\t\t}\n+\n+\n+\t\tprotected Statement createStatement (int rsType, int rsConcur, \n+\t\t\tboolean wrap)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tJDBCEvent before = fireEvent (getDelegate (), \n+\t\t\t\tJDBCEvent.BEFORE_CREATE_STATEMENT, null, null, null);\n+\t\t\tStatement stmnt = null;\n+\t\t\ttry\n+\t\t\t{ \n+\t\t\t\tstmnt = new EventStatement (super.createStatement \n+\t\t\t\t\t(rsType, rsConcur, false), EventConnection.this);\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tfireEvent (getDelegate (), JDBCEvent.AFTER_CREATE_STATEMENT, \n+\t\t\t\t\tbefore, stmnt, null);\t\n+\t\t\t}\n+\t\t\treturn stmnt;\n+\t\t}\n+\n+\n+\t\tprotected PreparedStatement prepareStatement (String sql, boolean wrap)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tJDBCEvent before = fireEvent (getDelegate (), \n+\t\t\t\tJDBCEvent.BEFORE_PREPARE_STATEMENT, null, null, sql);\n+\t\t\tPreparedStatement stmnt = null;\n+\t\t\ttry\n+\t\t\t{ \n+\t\t\t\tstmnt = new EventPreparedStatement (super.prepareStatement \n+\t\t\t\t\t(sql, false), EventConnection.this, sql); \n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tfireEvent (getDelegate (), JDBCEvent.AFTER_PREPARE_STATEMENT, \n+\t\t\t\t\tbefore, stmnt, sql);\t\n+\t\t\t}\n+\t\t\treturn stmnt;\n+\t\t}\n+\n+\n+\t\tprotected PreparedStatement prepareStatement (String sql, int rsType,\n+\t\t\tint rsConcur, boolean wrap)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tJDBCEvent before = fireEvent (getDelegate (), \n+\t\t\t\tJDBCEvent.BEFORE_PREPARE_STATEMENT, null, null, sql);\n+\t\t\tPreparedStatement stmnt = null;\n+\t\t\ttry\n+\t\t\t{ \n+\t\t\t\tstmnt = new EventPreparedStatement (super.prepareStatement \n+\t\t\t\t\t(sql, rsType, rsConcur, false), EventConnection.this, sql);\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tfireEvent (getDelegate (), JDBCEvent.AFTER_PREPARE_STATEMENT, \n+\t\t\t\t\tbefore, stmnt, sql);\t\n+\t\t\t}\n+\t\t\treturn stmnt;\n+\t\t}\n+\n+\n+\t\tpublic void close ()\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tfireEvent (getDelegate (), JDBCEvent.BEFORE_CLOSE,\n+\t\t\t\t\tnull, null, null);\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tsuper.close ();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tFires events as appropriate.\n+\t */\n+\tprivate class EventPreparedStatement\n+\t\textends DelegatingPreparedStatement\n+\t{\n+\t\tprivate final EventConnection\t_conn;\n+\t\tprivate final String \t\t\t_sql;\n+\n+\n+\t\tpublic EventPreparedStatement (PreparedStatement ps, \n+\t\t\tEventConnection conn, String sql)\n+\t\t{\n+\t\t\tsuper (ps, conn);\n+\t\t\t_conn = conn;\n+\t\t\t_sql = sql;\n+\t\t}\n+\n+\n+\t\tpublic int executeUpdate ()\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tJDBCEvent before = fireEvent (_conn.getDelegate (), \n+\t\t\t\tJDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate (), _sql);\n+\t\t\ttry\n+\t\t\t{ \n+\t\t\t\treturn super.executeUpdate ();\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tfireEvent (_conn.getDelegate (), \n+\t\t\t\t\tJDBCEvent.AFTER_EXECUTE_STATEMENT, before, \n+\t\t\t\t\tgetDelegate (), _sql);\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\tprotected ResultSet executeQuery (boolean wrap)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tJDBCEvent before = fireEvent (_conn.getDelegate (), \n+\t\t\t\tJDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate (), _sql);\n+\t\t\ttry\n+\t\t\t{ \n+\t\t\t\treturn super.executeQuery (wrap);\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tfireEvent (_conn.getDelegate (), \n+\t\t\t\t\tJDBCEvent.AFTER_EXECUTE_STATEMENT, before, \n+\t\t\t\t\tgetDelegate (), _sql);\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\tpublic int[] executeBatch ()\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tJDBCEvent before = fireEvent (_conn.getDelegate (), \n+\t\t\t\tJDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate (), _sql);\n+\t\t\ttry\n+\t\t\t{ \n+\t\t\t\treturn super.executeBatch ();\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tfireEvent (_conn.getDelegate (), \n+\t\t\t\t\tJDBCEvent.AFTER_EXECUTE_STATEMENT, before, \n+\t\t\t\t\tgetDelegate (), _sql);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tFires events as appropriate.\n+\t */\n+\tprivate class EventStatement\n+\t\textends DelegatingStatement\n+\t{\n+\t\tprivate final EventConnection _conn;\n+\n+\n+\t\tpublic EventStatement (Statement stmnt, EventConnection conn)\n+\t\t{\n+\t\t\tsuper (stmnt, conn);\n+\t\t\t_conn = conn;\n+\t\t}\n+\n+\n+\t\tpublic int executeUpdate (String sql)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tJDBCEvent before = fireEvent (_conn.getDelegate (), \n+\t\t\t\tJDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate (), sql);\n+\t\t\ttry\n+\t\t\t{ \n+\t\t\t\treturn super.executeUpdate (sql);\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tfireEvent (_conn.getDelegate (), \n+\t\t\t\t\tJDBCEvent.AFTER_EXECUTE_STATEMENT, before, \n+\t\t\t\t\tgetDelegate (), sql);\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\tprotected ResultSet executeQuery (String sql, boolean wrap)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tJDBCEvent before = fireEvent (_conn.getDelegate (), \n+\t\t\t\tJDBCEvent.BEFORE_EXECUTE_STATEMENT, null, getDelegate (), sql);\n+\t\t\ttry\n+\t\t\t{ \n+\t\t\t\treturn super.executeQuery (sql, wrap);\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tfireEvent (_conn.getDelegate (), \n+\t\t\t\t\tJDBCEvent.AFTER_EXECUTE_STATEMENT, before, \n+\t\t\t\t\tgetDelegate (), sql);\n+\t\t\t}\n+\t\t}\n+\t}\n+}"},{"sha":"10a303475cfd00ef7003cee97202b0914c483c39","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/JDBCListener.java","status":"added","additions":99,"deletions":0,"changes":99,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/JDBCListener.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/JDBCListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/JDBCListener.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+/** \n+ *\tA listener for all {@link JDBCEvent}s that occur.\n+ *\n+ *\t@see\tAbstractJDBCListener\n+ *  @author  Marc Prud'hommeaux\n+ *\t@author\tAbe White\n+ */\n+public interface JDBCListener\n+{\n+\t/**\n+\t *\t@see JDBCEvent#BEFORE_PREPARE_STATEMENT\n+\t */\n+\tpublic void beforePrepareStatement (JDBCEvent event);\n+\n+\n+\t/**\n+\t *\t@see JDBCEvent#AFTER_PREPARE_STATEMENT\n+\t */\n+\tpublic void afterPrepareStatement (JDBCEvent event);\n+\n+\n+\t/**\n+\t *\t@see JDBCEvent#BEFORE_CREATE_STATEMENT\n+\t */\n+\tpublic void beforeCreateStatement (JDBCEvent event);\n+\n+\n+\t/**\n+\t *\t@see JDBCEvent#AFTER_CREATE_STATEMENT\n+\t */\n+\tpublic void afterCreateStatement (JDBCEvent event);\n+\n+\n+\t/**\n+\t *\t@see JDBCEvent#BEFORE_EXECUTE_STATEMENT\n+\t */\n+\tpublic void beforeExecuteStatement (JDBCEvent event);\n+\n+\n+\t/**\n+\t *\t@see JDBCEvent#AFTER_EXECUTE_STATEMENT\n+\t */\n+\tpublic void afterExecuteStatement (JDBCEvent event);\n+\n+\n+\t/**\n+\t *\t@see JDBCEvent#BEFORE_COMMIT\n+\t */\n+\tpublic void beforeCommit (JDBCEvent event);\n+\n+\n+\t/**\n+\t *\t@see JDBCEvent#AFTER_COMMIT\n+\t */\n+\tpublic void afterCommit (JDBCEvent event);\n+\n+\n+\t/**\n+\t *\t@see JDBCEvent#BEFORE_ROLLBACK\n+\t */\n+\tpublic void beforeRollback (JDBCEvent event);\n+\n+\n+\t/**\n+\t *\t@see JDBCEvent#AFTER_ROLLBACK\n+\t */\n+\tpublic void afterRollback (JDBCEvent event);\n+\n+\n+\t/**\n+\t *\t@see JDBCEvent#AFTER_CONNECT\n+\t */\n+\tpublic void afterConnect (JDBCEvent event);\n+\n+\n+\t/**\n+\t *\t@see JDBCEvent#BEFORE_CLOSE\n+\t */\n+\tpublic void beforeClose (JDBCEvent event);\n+}\n+"},{"sha":"4fda798b6b14d8543d29bd26677e22a52dae4545","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","status":"added","additions":1775,"deletions":0,"changes":1775,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,1775 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+import java.io.*;\n+import java.math.*;\n+import java.sql.*;\n+import java.sql.Date;\n+import java.util.*;\n+import javax.sql.*;\n+\n+import org.apache.openjpa.lib.log.*;\n+\n+\n+/** \n+ *  A {@link ConnectionDecorator} that creates logging connections and\n+ *\t{@link ReportingSQLException}s.\n+ *  \n+ *  @author  Marc Prud'hommeaux\n+ *\t@nojavadoc\n+ */\n+public class LoggingConnectionDecorator\n+\timplements ConnectionDecorator\n+{\n+\tprivate static final String SEP = System.getProperty (\"line.separator\");\n+\n+\tprivate static final int WARN_IGNORE = 0;\n+   \tprivate static final int WARN_LOG_TRACE = 1;\n+   \tprivate static final int WARN_LOG_INFO = 2;\n+   \tprivate static final int WARN_LOG_WARN = 3;\n+   \tprivate static final int WARN_LOG_ERROR = 4;\n+   \tprivate static final int WARN_THROW = 5;\n+   \tprivate static final int WARN_HANDLE = 6;\n+   \tprivate static final String[] WARNING_ACTIONS = new String[7];\n+\tstatic\n+   \t{\n+\t\tWARNING_ACTIONS[WARN_IGNORE] = \"ignore\";\n+\t\tWARNING_ACTIONS[WARN_LOG_TRACE] = \"trace\";\n+\t\tWARNING_ACTIONS[WARN_LOG_INFO] = \"info\";\n+\t\tWARNING_ACTIONS[WARN_LOG_WARN] = \"warn\";\n+\t\tWARNING_ACTIONS[WARN_LOG_ERROR] = \"error\";\n+\t\tWARNING_ACTIONS[WARN_THROW] = \"throw\";\n+\t\tWARNING_ACTIONS[WARN_HANDLE] = \"handle\";\n+\t}\n+\n+\tprivate final DataSourceLogs _logs = new DataSourceLogs ();\n+\tprivate SQLFormatter _formatter;\n+\tprivate boolean _prettyPrint;\n+\tprivate int _prettyPrintLineLength = 60;\n+\tprivate int _warningAction = WARN_IGNORE;\n+   \tprivate SQLWarningHandler _warningHandler;\n+   \tprivate boolean _trackParameters = true;\n+\n+\n+\t/**\n+\t *\tIf set to <code>true</code>, pretty-print SQL by running it\n+\t *\tthrough {@link SQLFormatter#prettyPrint}. If\n+\t *\t<code>false</code>, don't pretty-print, and output SQL logs in\n+\t *\ta single line. Pretty-printed SQL can be easier for a human to\n+\t *\tread, but is harder to parse with tools like grep.\n+\t */\n+\tpublic void setPrettyPrint (boolean prettyPrint)\n+\t{\n+\t\t_prettyPrint = prettyPrint;\n+\t\tif (_formatter == null && _prettyPrint)\n+\t\t{\n+\t\t\t_formatter = new SQLFormatter ();\n+\t\t\t_formatter.setLineLength (_prettyPrintLineLength);\n+\t\t}\n+\t\telse if (!_prettyPrint)\n+\t\t\t_formatter = null;\n+\t}\n+\n+\n+\t/**\n+\t *\t@see {@link #setPrettyPrint}\n+\t */\n+\tpublic boolean getPrettyPrint ()\n+\t{\n+\t\treturn _prettyPrint;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe number of characters to print per line when\n+\t *\tpretty-printing of SQL is enabled. Defaults to 60 to provide\n+\t *\tsome space for any ant-related characters on the left of a\n+\t *\tstandard 80-character display.\n+\t */\n+\tpublic void setPrettyPrintLineLength (int length)\n+\t{\n+\t\t_prettyPrintLineLength = length;\n+\t\tif (_formatter != null)\n+\t\t\t_formatter.setLineLength (length);\n+\t}\n+\n+\n+\t/**\n+\t *\t@see {@link #setPrettyPrintLineLength}\n+\t */\n+\tpublic int getPrettyPrintLineLength ()\n+\t{\n+\t\treturn _prettyPrintLineLength;\n+\t}\n+\n+\n+\t/** \n+\t *  Whether to track parameters for the purposes of reporting exceptions. \n+\t */\n+\tpublic void setTrackParameters (boolean trackParameters)\n+\t{\n+\t\t_trackParameters = trackParameters;\n+\t}\n+\n+\n+\t/** \n+\t *  Whether to track parameters for the purposes of reporting exceptions. \n+\t */\n+\tpublic boolean getTrackParameters ()\n+\t{\n+\t\treturn _trackParameters;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhat to do with SQL warnings.\n+\t */\n+\tpublic void setWarningAction (String warningAction)\n+\t{\n+\t\tint index = Arrays.asList (WARNING_ACTIONS).indexOf (warningAction);\n+\t\tif (index < 0)\n+\t\t\tindex = WARN_IGNORE;\n+\t\t_warningAction = index;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhat to do with SQL warnings.\n+\t */\n+\tpublic String getWarningAction ()\n+\t{\n+\t\treturn WARNING_ACTIONS[_warningAction];\n+\t}\n+\n+\n+\t/**\n+\t *\tWhat to do with SQL warnings.\n+\t */\n+\tpublic void setWarningHandler (SQLWarningHandler warningHandler)\n+\t{\n+\t\t_warningHandler = warningHandler;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhat to do with SQL warnings.\n+\t */\n+\tpublic SQLWarningHandler getWarningHandler ()\n+\t{\n+\t\treturn _warningHandler;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe log to write to.\n+\t */\n+\tpublic DataSourceLogs getLogs ()\n+\t{\n+\t\treturn _logs;\n+\t}\n+\n+\n+\tpublic Connection decorate (Connection conn)\n+\t\tthrows SQLException\n+\t{\n+\t\treturn new LoggingConnection (conn);\n+\t}\n+\n+\n+\tprivate SQLException wrap (SQLException sqle, Statement stmnt)\n+\t{\n+\t\tif (sqle instanceof ReportingSQLException)\n+\t\t\treturn (ReportingSQLException)sqle;\n+\n+\t\treturn new ReportingSQLException (sqle, stmnt);\n+\t}\n+\n+\n+\tprivate SQLException wrap (SQLException sqle, String sql)\n+\t{\n+\t\tif (sqle instanceof ReportingSQLException)\n+\t\t\treturn (ReportingSQLException)sqle;\n+\n+\t\treturn new ReportingSQLException (sqle, sql);\n+\t}\n+\n+\n+\tprivate static String getExceptionMessage (SQLException sqle,\n+\t\tStatement stmnt)\n+\t{\n+\t\ttry\n+\t\t{\n+\t\t\treturn sqle.getMessage () + \" {\" + stmnt + \"} \"\n+\t\t\t\t+ \"[code=\" + sqle.getErrorCode () + \", state=\"\n+\t\t\t\t+ sqle.getSQLState () + \"]\";\n+\t\t}\n+\t\tcatch (Throwable t)\n+\t\t{\n+\t\t\treturn sqle.getMessage ();\n+\t\t}\n+\t}\n+\n+\n+\t/** \n+\t *  Interface that allows customization of what to do when\n+\t *  {@link SQLWarning}s occur.\n+\t */\n+\tpublic static interface SQLWarningHandler\n+\t{\n+\t\tpublic void handleWarning (SQLWarning warning)\n+\t\t\tthrows SQLException;\n+\t}\n+\n+\n+\tprivate class LoggingConnection\n+\t\textends DelegatingConnection\n+\t{\n+\t\tpublic LoggingConnection (Connection conn)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tsuper (conn);\n+\t\t}\n+\t\n+\t\n+    \tprotected PreparedStatement prepareStatement (String sql, boolean wrap) \n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tPreparedStatement stmnt = super.prepareStatement (sql, false);\n+\t\t\t\treturn new LoggingPreparedStatement (stmnt, sql);\n+\t\t\t}\n+\t\t\tcatch (SQLException se)\n+\t\t\t{\n+\t\t\t\tthrow wrap (se, sql);\n+\t\t\t}\n+\t\t}\n+\t\n+\t\n+    \tprotected PreparedStatement prepareStatement (String sql, int rsType, \n+\t\t\tint rsConcur, boolean wrap) \n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tPreparedStatement stmnt = super.prepareStatement \n+\t\t\t\t\t(sql, rsType, rsConcur, false);\n+\t\t\t\treturn new LoggingPreparedStatement (stmnt, sql);\n+\t\t\t}\n+\t\t\tcatch (SQLException se)\n+\t\t\t{\n+\t\t\t\tthrow wrap (se, sql);\n+\t\t\t}\n+\t\t}\n+\t\n+\t\n+\t\tprotected Statement createStatement (boolean wrap)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tStatement stmnt = super.createStatement (false);\n+\t\t\treturn new LoggingStatement (stmnt);\n+\t\t}\n+\t\n+\t\n+    \tprotected Statement createStatement (int type, int concurrency, \n+\t\t\tboolean wrap) \n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tStatement stmnt = super.createStatement (type, concurrency, false);\n+\t\t\treturn new LoggingStatement (stmnt);\n+\t\t}\n+\t\n+\t\n+\t\tpublic void commit ()\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tlong start = System.currentTimeMillis ();\n+\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tsuper.commit ();\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"commit\", start, this);\n+\t\t\t\thandleSQLWarning ();\n+\t\t\t}\n+\t\t}\n+\t\n+\t\n+\t\tpublic void rollback ()\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tlong start = System.currentTimeMillis ();\n+\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tsuper.rollback ();\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"rollback\", start, this);\n+\t\t\t\thandleSQLWarning ();\n+\t\t\t}\n+\t\t}\n+\t\n+\t\n+\t\tpublic void close ()\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tlong start = System.currentTimeMillis ();\n+\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tsuper.close ();\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"close\", start, this);\n+\t\t\t}\n+\t\t}\n+\t\n+\n+\t\tpublic Savepoint setSavepoint ()\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tlong start = System.currentTimeMillis ();\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\treturn super.setSavepoint ();\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"savepoint\", start, this);\n+\t\t\t\thandleSQLWarning ();\n+\t\t\t}\n+\t\t}\n+\t\n+\n+\t\tpublic Savepoint setSavepoint (String name)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tlong start = System.currentTimeMillis ();\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\treturn super.setSavepoint (name);\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"savepoint: \" + name, start, this);\n+\t\t\t\thandleSQLWarning ();\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\tpublic void rollback (Savepoint savepoint)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tlong start = System.currentTimeMillis ();\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tsuper.rollback (savepoint);\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t{\n+\t\t\t\t\tString name = null;\n+\t\t\t\t\ttry\n+\t\t\t\t\t{\n+\t\t\t\t\t\tname = savepoint.getSavepointName ();\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (SQLException sqe)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tname = String.valueOf (savepoint.getSavepointId ());\n+\t\t\t\t\t}\n+\t\t\t\t\t_logs.logJDBC (\"rollback: \" + name, start, this);\n+\t\t\t\t}\n+\t\t\t\thandleSQLWarning ();\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\tpublic void releaseSavepoint (Savepoint savepoint)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tlong start = System.currentTimeMillis ();\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tsuper.releaseSavepoint (savepoint);\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t{\n+\t\t\t\t\tString name = null;\n+\t\t\t\t\ttry\n+\t\t\t\t\t{\n+\t\t\t\t\t\tname = savepoint.getSavepointName ();\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (SQLException sqe)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tname = String.valueOf (savepoint.getSavepointId ());\n+\t\t\t\t\t}\n+\t\t\t\t\t_logs.logJDBC (\"release: \" + name, start, this);\n+\t\t\t\t}\n+\t\t\t\thandleSQLWarning ();\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\tprotected Statement createStatement (int resultSetType,\n+\t\t\tint resultSetConcurrency, int resultSetHoldability, boolean wrap)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tStatement stmnt = super.createStatement (resultSetType, \n+\t\t\t\tresultSetConcurrency, resultSetHoldability, false);\n+\t\t\thandleSQLWarning ();\n+\t\t\treturn new LoggingStatement (stmnt);\n+\t\t}\n+\n+\n+\t\tprotected PreparedStatement prepareStatement (String sql, \n+\t\t\tint resultSetType, int resultSetConcurrency, \n+\t\t\tint resultSetHoldability, boolean wrap)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tPreparedStatement stmnt = super.prepareStatement \n+\t\t\t\t\t(sql, resultSetType, resultSetConcurrency, \n+\t\t\t\t\tresultSetHoldability, false);\n+\t\t\t\thandleSQLWarning ();\n+\t\t\t\treturn new LoggingPreparedStatement (stmnt, sql);\n+\t\t\t}\n+\t\t\tcatch (SQLException se)\n+\t\t\t{\n+\t\t\t\tthrow wrap (se, sql);\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\tprotected PreparedStatement prepareStatement (String sql, \n+\t\t\tint autoGeneratedKeys, boolean wrap)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tPreparedStatement stmnt = super.prepareStatement \n+\t\t\t\t\t(sql, autoGeneratedKeys, false);\n+\t\t\t\thandleSQLWarning ();\n+\t\t\t\treturn new LoggingPreparedStatement (stmnt, sql);\n+\t\t\t}\n+\t\t\tcatch (SQLException se)\n+\t\t\t{\n+\t\t\t\tthrow wrap (se, sql);\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\tprotected PreparedStatement prepareStatement (String sql, \n+\t\t\tint[] columnIndexes, boolean wrap)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tPreparedStatement stmnt = super.prepareStatement \n+\t\t\t\t\t(sql, columnIndexes, false);\n+\t\t\t\thandleSQLWarning ();\n+\t\t\t\treturn new LoggingPreparedStatement (stmnt, sql);\n+\t\t\t}\n+\t\t\tcatch (SQLException se)\n+\t\t\t{\n+\t\t\t\tthrow wrap (se, sql);\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\tprotected PreparedStatement prepareStatement (String sql, \n+\t\t\tString[] columnNames, boolean wrap)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tPreparedStatement stmnt = super.prepareStatement \n+\t\t\t\t\t(sql, columnNames, false);\n+\t\t\t\thandleSQLWarning ();\n+\t\t\t\treturn new LoggingPreparedStatement (stmnt, sql);\n+\t\t\t}\n+\t\t\tcatch (SQLException se)\n+\t\t\t{\n+\t\t\t\tthrow wrap (se, sql);\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\tprotected DatabaseMetaData getMetaData (boolean wrap)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\treturn new LoggingDatabaseMetaData (super.getMetaData (false));\n+\t\t}\n+\n+\n+\t\t/** \n+\t\t *  Handle any {@link SQLWarning}s on the current {@link Connection}.\n+\t\t *\n+\t\t *  @see #handleSQLWarning(SQLWarning) \n+\t\t */\n+\t\tprivate void handleSQLWarning ()\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tif (_warningAction == WARN_IGNORE)\n+\t\t\t\treturn;\n+\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\thandleSQLWarning (getWarnings ());\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tclearWarnings ();\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\t/** \n+\t\t *  Handle any {@link SQLWarning}s on the specified {@link Statement}.\n+\t\t *\n+\t\t *  @see #handleSQLWarning(SQLWarning)\n+\t\t */\n+\t\tprivate void handleSQLWarning (Statement stmnt)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tif (_warningAction == WARN_IGNORE)\n+\t\t\t\treturn;\n+\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\thandleSQLWarning (stmnt.getWarnings ());\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tstmnt.clearWarnings ();\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\t/** \n+\t\t *  Handle any {@link SQLWarning}s on the specified {@link ResultSet}.\n+\t\t *\n+\t\t *  @see #handleSQLWarning(SQLWarning)\n+\t\t */\n+\t\tprivate void handleSQLWarning (ResultSet rs)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tif (_warningAction == WARN_IGNORE)\n+\t\t\t\treturn;\n+\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\thandleSQLWarning (rs.getWarnings ());\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\trs.clearWarnings ();\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\t/** \n+\t\t *  Handle the specified {@link SQLWarning} depending on the\n+\t\t *  setting of the {@link #setWarningAction} attribute.\n+\t\t *  \n+\t\t *  @param  warning  the warning to handle\n+\t\t */\n+\t\tvoid handleSQLWarning (SQLWarning warning)\n+\t\t\tthrows SQLException\n+\t\t{\n+\t\t\tif (warning == null)\n+\t\t\t\treturn;\n+\t\t\tif (_warningAction == WARN_IGNORE)\n+\t\t\t\treturn;\n+\n+\t\t\tLog log = _logs.getJDBCLog ();\n+\t\t\tfor ( ; warning != null; warning = warning.getNextWarning ())\n+\t\t\t{\n+\t\t\t\tswitch (_warningAction)\n+\t\t\t\t{\n+\t\t\t\tcase WARN_LOG_TRACE:\n+\t\t\t\t\tif (log.isTraceEnabled ())\n+\t\t\t\t\t\tlog.trace (warning);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase WARN_LOG_INFO:\n+\t\t\t\t\tif (log.isInfoEnabled ())\n+\t\t\t\t\t\tlog.info (warning);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase WARN_LOG_WARN:\n+\t\t\t\t\tif (log.isWarnEnabled ())\n+\t\t\t\t\t\tlog.warn (warning);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase WARN_LOG_ERROR:\n+\t\t\t\t\tif (log.isErrorEnabled ())\n+\t\t\t\t\t\tlog.error (warning);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase WARN_THROW:\n+\t\t\t\t\t// just throw it as if it were a SQLException\n+\t\t\t\t\tthrow warning;\n+\t\t\t\tcase WARN_HANDLE:\n+\t\t\t\t\tif (_warningHandler != null)\n+\t\t\t\t\t\t_warningHandler.handleWarning (warning);\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\t// ignore\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\tprivate class LoggingDatabaseMetaData\n+\t\t\textends DelegatingDatabaseMetaData\n+\t\t{\n+\t\t\tpublic LoggingDatabaseMetaData (DatabaseMetaData meta)\n+\t\t\t{\n+\t\t\t\tsuper (meta, LoggingConnection.this);\n+\t\t\t}\n+\n+\n+\t\t\tpublic ResultSet getBestRowIdentifier (String catalog,\n+\t\t\t\tString schema, String table, int scope, boolean nullable)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getBestRowIdentifier: \"\n+\t\t\t\t\t\t+ catalog + \", \" + schema + \", \" + table, \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getBestRowIdentifier (catalog, schema,\n+\t\t\t\t\ttable, scope, nullable);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic ResultSet getCatalogs ()\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getCatalogs\", \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getCatalogs ();\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic ResultSet getColumnPrivileges (String catalog, String schema,\n+\t\t\t\tString table, String columnNamePattern)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getColumnPrivileges: \" \n+\t\t\t\t\t\t+ catalog + \", \" + schema + \", \" + table, \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getColumnPrivileges (catalog, schema,\n+\t\t\t\t\ttable, columnNamePattern);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic ResultSet getColumns (String catalog, String schemaPattern,\n+\t\t\t\tString tableNamePattern, String columnNamePattern)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getColumns: \"\n+\t\t\t\t\t\t+ catalog + \", \" + schemaPattern + \", \"\n+\t\t\t\t\t\t+ tableNamePattern + \", \" + columnNamePattern, \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getColumns (catalog, schemaPattern,\n+\t\t\t\t\ttableNamePattern, columnNamePattern);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic ResultSet getCrossReference (String primaryCatalog,\n+\t\t\t\tString primarySchema, String primaryTable,\n+\t\t\t\tString foreignCatalog, String foreignSchema,\n+\t\t\t\tString foreignTable)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getCrossReference: \"\n+\t\t\t\t\t\t+ primaryCatalog + \", \" + primarySchema + \", \"\n+\t\t\t\t\t\t+ primaryTable + \", \" + foreignCatalog + \", \"\n+\t\t\t\t\t\t+ foreignSchema + \", \" + foreignSchema, \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getCrossReference (primaryCatalog, primarySchema,\n+\t\t\t\t\tprimaryTable, foreignCatalog, foreignSchema, foreignTable);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic ResultSet getExportedKeys (String catalog, String schema,\n+\t\t\t\tString table)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getExportedKeys: \"\n+\t\t\t\t\t\t+ catalog + \", \" + schema + \", \" + table, \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getExportedKeys (catalog, schema, table);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic ResultSet getImportedKeys (String catalog, String schema,\n+\t\t\t\tString table)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getImportedKeys: \"\n+\t\t\t\t\t\t+ catalog + \", \" + schema + \", \" + table, \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getImportedKeys (catalog, schema, table);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic ResultSet getIndexInfo (String catalog, String schema,\n+\t\t\t\tString table, boolean unique, boolean approximate)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getIndexInfo: \"\n+\t\t\t\t\t\t+ catalog + \", \" + schema + \", \" + table, \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getIndexInfo (catalog, schema, table, unique,\n+\t\t\t\t\tapproximate);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic ResultSet getPrimaryKeys (String catalog, String schema,\n+\t\t\t\tString table)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getPrimaryKeys: \"\n+\t\t\t\t\t\t+ catalog + \", \" + schema + \", \" + table, \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getPrimaryKeys (catalog, schema, table);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic ResultSet getProcedureColumns (String catalog,\n+\t\t\t\tString schemaPattern, String procedureNamePattern,\n+\t\t\t\tString columnNamePattern)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getProcedureColumns: \"\n+\t\t\t\t\t\t+ catalog + \", \" + schemaPattern + \", \"\n+\t\t\t\t\t\t+ procedureNamePattern + \", \" + columnNamePattern, \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getProcedureColumns (catalog, schemaPattern,\n+\t\t\t\t\tprocedureNamePattern, columnNamePattern);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic ResultSet getProcedures (String catalog,\n+\t\t\t\tString schemaPattern, String procedureNamePattern)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getProcedures: \"\n+\t\t\t\t\t\t+ catalog + \", \" + schemaPattern + \", \"\n+\t\t\t\t\t\t+ procedureNamePattern, \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getProcedures (catalog, schemaPattern,\n+\t\t\t\t\tprocedureNamePattern);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic ResultSet getSchemas ()\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getSchemas\", \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getSchemas ();\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic ResultSet getTablePrivileges (String catalog,\n+\t\t\t\tString schemaPattern, String tableNamePattern)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getTablePrivileges\", \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getTablePrivileges (catalog, schemaPattern,\n+\t\t\t\t\ttableNamePattern);\n+\t\t\t}\n+\t\t\n+\t\t\t\t\n+\t\t\tpublic ResultSet getTables (String catalog, String schemaPattern,\n+\t\t\t\tString tableNamePattern, String[] types)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getTables: \"\n+\t\t\t\t\t\t+ catalog + \", \" + schemaPattern + \", \"\n+\t\t\t\t\t\t+ tableNamePattern, \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getTables (catalog, schemaPattern,\n+\t\t\t\t\ttableNamePattern, types);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic ResultSet getTableTypes ()\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getTableTypes\", \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getTableTypes ();\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic ResultSet getTypeInfo ()\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getTypeInfo\", \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getTypeInfo ();\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic ResultSet getUDTs (String catalog, String schemaPattern,\n+\t\t\t\tString typeNamePattern, int[] types)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getUDTs\", \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getUDTs (catalog, schemaPattern,\n+\t\t\t\t\ttypeNamePattern, types);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic ResultSet getVersionColumns (String catalog,\n+\t\t\t\tString schema, String table)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"getVersionColumns: \"\n+\t\t\t\t\t\t+ catalog + \", \" + schema + \", \" + table, \n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\treturn super.getVersionColumns (catalog, schema, table);\n+\t\t\t}\n+\t\t}\n+\t\n+\t\n+\t\t/**\n+\t\t *\tStatement wrapper that logs SQL to the parent data source and\n+\t\t *\tremembers the last piece of SQL to be executed on it.\n+\t\t */\n+\t\tprivate class LoggingStatement\n+\t\t\textends DelegatingStatement\n+\t\t{\n+\t\t\tprivate String _sql = null;\n+\t\t\n+\t\t\n+\t\t\tpublic LoggingStatement (Statement stmnt)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsuper (stmnt, LoggingConnection.this);\n+\t\t\t}\n+\t\t\t\n+\t\t\t\n+\t\t\tpublic void appendInfo (StringBuffer buf)\n+\t\t\t{\n+\t\t\t\tif (_sql != null)\n+\t\t\t\t{\n+\t\t\t\t\tbuf.append (\" \");\n+\t\t\t\t\tif (_formatter != null)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tbuf.append (SEP);\n+\t\t\t\t\t\tbuf.append (_formatter.prettyPrint (_sql));\n+\t\t\t\t\t}\n+\t\t\t\t\telse\n+\t\t\t\t\t{\n+\t\t\t\t\t\tbuf.append (_sql);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+          \n+                \n+\t\t\tprotected ResultSet wrapResult (ResultSet rs, boolean wrap)\n+\t\t\t{   \n+\t\t\t\tif (!wrap || rs == null)\n+\t\t\t\t\treturn super.wrapResult (rs, wrap);\n+\t\t\t\treturn new LoggingResultSet (rs, this);\n+\t\t\t}\n+\n+\n+\t    \tpublic void cancel ()\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"cancel \" + this + \": \" + _sql,\n+\t\t\t\t\t\tLoggingConnection.this);\n+\n+\t\t\t\tsuper.cancel ();\n+\t\t\t}\n+\t\n+\t\n+   \t\t \tprotected ResultSet executeQuery (String sql, boolean wrap) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tlong start = System.currentTimeMillis ();\n+\n+\t\t\t\t_sql = sql;\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\treturn super.executeQuery (sql, wrap);\n+\t\t\t\t}\n+\t\t\t\tcatch (SQLException se)\n+\t\t\t\t{\n+\t\t\t\t\tthrow wrap (se, LoggingStatement.this);\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\tif (_logs.isSQLEnabled ())\n+\t\t\t\t\t\t_logs.logSQL (\"executing \" + this, start, \n+\t\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\t\thandleSQLWarning (LoggingStatement.this);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\n+\t\t\n+\t    \tpublic int executeUpdate (String sql) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tlong start = System.currentTimeMillis ();\n+\n+\t\t\t\t_sql = sql;\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\treturn super.executeUpdate (sql);\n+\t\t\t\t}\n+\t\t\t\tcatch (SQLException se)\n+\t\t\t\t{\n+\t\t\t\t\tthrow wrap (se, LoggingStatement.this);\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\tif (_logs.isSQLEnabled ())\n+\t\t\t\t\t\t_logs.logSQL (\"executing \" + this, start, \n+\t\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\t\thandleSQLWarning (LoggingStatement.this);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\n+\t\t\n+\t    \tpublic boolean execute (String sql) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tlong start = System.currentTimeMillis ();\n+\n+\t\t\t\t_sql = sql;\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\treturn super.execute (sql);\n+\t\t\t\t}\n+\t\t\t\tcatch (SQLException se)\n+\t\t\t\t{\n+\t\t\t\t\tthrow wrap (se, LoggingStatement.this);\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\tif (_logs.isSQLEnabled ())\n+\t\t\t\t\t\t_logs.logSQL (\"executing \" + this, start, \n+\t\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t\t\thandleSQLWarning (LoggingStatement.this);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\n+\t\n+\t\tprivate class LoggingPreparedStatement\n+\t\t\textends DelegatingPreparedStatement\n+\t\t{\n+\t\t\tprivate final String \t_sql;\n+\t\t\tprivate List\t\t\t_params\t= null;\n+\t\t\tprivate List\t\t\t_paramBatch = null;\n+\t\n+\t\n+\t\t\tpublic LoggingPreparedStatement (PreparedStatement stmnt,\n+\t\t\t\tString sql)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsuper (stmnt, LoggingConnection.this);\n+\t\t\t\t_sql = sql;\n+\t\t\t}\n+\n+\n+\t\t\tprotected ResultSet wrapResult (ResultSet rs, boolean wrap)\n+\t\t\t{\n+\t\t\t\tif (!wrap || rs == null)\n+\t\t\t\t\treturn super.wrapResult (rs, wrap);\n+\t\t\t\treturn new LoggingResultSet (rs, this);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t    \tprotected ResultSet executeQuery (String sql, boolean wrap) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tlong start = System.currentTimeMillis ();\n+\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\treturn super.executeQuery (sql, wrap);\n+\t\t\t\t}\n+\t\t\t\tcatch (SQLException se)\n+\t\t\t\t{\n+\t\t\t\t\tthrow wrap (se, LoggingPreparedStatement.this);\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\tlog (\"executing\", start);\n+\t\t\t\t\tclearLogParameters (true);\n+\t\t\t\t\thandleSQLWarning (LoggingPreparedStatement.this);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\n+\t\t\n+\t    \tpublic int executeUpdate (String sql) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tlong start = System.currentTimeMillis ();\n+\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\treturn super.executeUpdate (sql);\n+\t\t\t\t}\n+\t\t\t\tcatch (SQLException se)\n+\t\t\t\t{\n+\t\t\t\t\tthrow wrap (se, LoggingPreparedStatement.this);\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\tlog (\"executing\", start);\n+\t\t\t\t\tclearLogParameters (true);\n+\t\t\t\t\thandleSQLWarning (LoggingPreparedStatement.this);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\n+\t\t\n+\t    \tpublic boolean execute (String sql) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tlong start = System.currentTimeMillis ();\n+\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\treturn super.execute (sql);\n+\t\t\t\t}\n+\t\t\t\tcatch (SQLException se)\n+\t\t\t\t{\n+\t\t\t\t\tthrow wrap (se, LoggingPreparedStatement.this);\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\tlog (\"executing\", start);\n+\t\t\t\t\tclearLogParameters (true);\n+\t\t\t\t\thandleSQLWarning (LoggingPreparedStatement.this);\n+\t\t\t\t}\n+\t\t\t}\n+\t\n+\t\n+\t\t\tprotected ResultSet executeQuery (boolean wrap) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tlong start = System.currentTimeMillis ();\n+\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\treturn super.executeQuery (wrap);\n+\t\t\t\t}\n+\t\t\t\tcatch (SQLException se)\n+\t\t\t\t{\n+\t\t\t\t\tthrow wrap (se, LoggingPreparedStatement.this);\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\tlog (\"executing\", start);\n+\t\t\t\t\tclearLogParameters (true);\n+\t\t\t\t\thandleSQLWarning (LoggingPreparedStatement.this);\n+\t\t\t\t}\n+\t\t\t}\n+\t\n+\t\n+\t\t\tpublic int executeUpdate  () \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tlong start = System.currentTimeMillis ();\n+\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\treturn super.executeUpdate ();\n+\t\t\t\t}\n+\t\t\t\tcatch (SQLException se)\n+\t\t\t\t{\n+\t\t\t\t\tthrow wrap (se, LoggingPreparedStatement.this);\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\tlog (\"executing\", start);\n+\t\t\t\t\tclearLogParameters (true);\n+\t\t\t\t\thandleSQLWarning (LoggingPreparedStatement.this);\n+\t\t\t\t}\n+\t\t\t}\n+\t\n+\t\n+\t\t\tpublic int[] executeBatch ()\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tlong start = System.currentTimeMillis ();\n+\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\treturn super.executeBatch ();\n+\t\t\t\t}\n+\t\t\t\tcatch (SQLException se)\n+\t\t\t\t{\n+\t\t\t\t\t// if the exception is a BatchUpdateException, and\n+\t\t\t\t\t// we are tracking parameters, then set the current\n+\t\t\t\t\t// parameter set to be the index of the failed\n+\t\t\t\t\t// statement so that the ReportingSQLException will\n+\t\t\t\t\t// show the correct param\n+\t\t\t\t\tif (se instanceof BatchUpdateException \n+\t\t\t\t\t\t&& _paramBatch != null && shouldTrackParameters ())\n+\t\t\t\t\t{\n+\t\t\t\t\t\tint[] count = ((BatchUpdateException)se).\n+\t\t\t\t\t\t\tgetUpdateCounts ();\n+\t\t\t\t\t\tif (count != null && count.length <= _paramBatch.size())\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tint index = -1;\n+\t\t\t\t\t\t\tfor (int i = 0; i < count.length; i++)\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t// -3 is Statement.STATEMENT_FAILED, but is\n+\t\t\t\t\t\t\t\t// only available in JDK 1.4+\n+\t\t\t\t\t\t\t\tif (count[i] == -3)\n+\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\tindex = i;\n+\t\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t// no -3 element: it may be that the server stopped\n+\t\t\t\t\t\t\t// processing, so the size of the count will be\n+\t\t\t\t\t\t\t// the index\n+\t\t\t\t\t\t\tif (index == -1)\n+\t\t\t\t\t\t\t\tindex = count.length + 1;\n+\n+\t\t\t\t\t\t\t// set the current params to the saved values\n+\t\t\t\t\t\t\tif (index < _paramBatch.size ())\n+\t\t\t\t\t\t\t\t_params = (List)_paramBatch.get (index);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tthrow wrap (se, LoggingPreparedStatement.this);\n+\t\t\t\t}\t\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\tlog (\"executing batch\", start);\n+\t\t\t\t\tclearLogParameters (true);\n+\t\t\t\t\thandleSQLWarning (LoggingPreparedStatement.this);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\n+\t\t\n+\t    \tpublic boolean execute () \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tlong start = System.currentTimeMillis ();\n+\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\treturn super.execute ();\n+\t\t\t\t}\n+\t\t\t\tcatch (SQLException se)\n+\t\t\t\t{\n+\t\t\t\t\tthrow wrap (se, LoggingPreparedStatement.this);\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\tlog (\"executing\", start);\n+\t\t\t\t\tclearLogParameters (true);\n+\t\t\t\t\thandleSQLWarning (LoggingPreparedStatement.this);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\n+\t    \tpublic void cancel ()\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isJDBCEnabled ())\n+\t\t\t\t\t_logs.logJDBC (\"cancel \" + this + \": \" + _sql,\n+\t\t\t\t\t\tLoggingConnection.this);\n+\n+\t\t\t\tsuper.cancel ();\n+\t\t\t}\n+\t\n+\t\n+\t\t\tpublic void setNull (int i1, int i2) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i1, \"null\", null);\n+\t\t\t\tsuper.setNull (i1, i2);\n+\t\t\t}\n+\t\n+\t\n+\t\t\tpublic void setBoolean (int i, boolean b) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, b);\n+\t\t\t\tsuper.setBoolean (i, b);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setByte (int i, byte b) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, b);\n+\t\t\t\tsuper.setByte (i,b);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setShort (int i, short s) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, s);\n+\t\t\t\tsuper.setShort (i, s);\n+\t\t\t}\n+\t\n+\t\n+\t\t\tpublic void setInt (int i1, int i2) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i1, i2);\n+\t\t\t\tsuper.setInt (i1, i2);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setLong (int i, long l) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, l);\n+\t\t\t\tsuper.setLong (i, l);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setFloat (int i, float f) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, f);\n+\t\t\t\tsuper.setFloat (i, f);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setDouble (int i, double d) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, d);\n+\t\t\t\tsuper.setDouble (i, d);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setBigDecimal (int i, BigDecimal bd) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, \"BigDecimal\", bd);\n+\t\t\t\tsuper.setBigDecimal (i, bd);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setString (int i, String s) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, \"String\", s);\n+\t\t\t\tsuper.setString (i, s);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setBytes (int i, byte[] b) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, \"byte[]\", b);\n+\t\t\t\tsuper.setBytes (i, b);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setDate (int i, Date d) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, \"Date\", d);\n+\t\t\t\tsuper.setDate (i, d);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setTime (int i, Time t) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, \"Time\", t);\n+\t\t\t\tsuper.setTime (i, t);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setTimestamp (int i, Timestamp t) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, \"Timestamp\", t);\n+\t\t\t\tsuper.setTimestamp (i, t);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setAsciiStream (int i1, InputStream is, int i2) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i1, \"InputStream\", is);\n+\t\t\t\tsuper.setAsciiStream (i1, is, i2);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setUnicodeStream (int i1, InputStream is, int i2) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i1, \"InputStream\", is);\n+\t\t\t\tsuper.setUnicodeStream (i2, is, i2);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setBinaryStream (int i1, InputStream is, int i2) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i1, \"InputStream\", is);\n+\t\t\t\tsuper.setBinaryStream (i1, is, i2);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t    \tpublic void clearParameters () \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tclearLogParameters (false);\n+\t\t\t\tsuper.clearParameters ();\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setObject (int i1, Object o, int i2, int i3) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i1, \"Object\", o);\n+\t\t\t\tsuper.setObject (i1, o, i2, i3);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setObject (int i1, Object o, int i2)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i1, \"Object\", o);\n+\t\t\t\tsuper.setObject (i1, o, i2);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setObject (int i, Object o) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, \"Object\", o);\n+\t\t\t\tsuper.setObject (i, o);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t    \tpublic void addBatch () \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tlong start = System.currentTimeMillis ();\n+\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\tsuper.addBatch ();\n+\t\t\t\t\tif (shouldTrackParameters ())\n+\t\t\t\t\t{\n+\t\t\t\t\t\t// make sure our list is initialized\n+\t\t\t\t\t\tif (_paramBatch == null) \n+\t\t\t\t\t\t\t_paramBatch = new ArrayList ();\n+                        // copy parameters since they will be re-used\n+\t\t\t\t\t\tif (_params != null)\n+\t\t\t\t\t\t\t_paramBatch.add (new ArrayList (_params));\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t_paramBatch.add (null);\n+                    }\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\tlog (\"batching\", start);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setCharacterStream (int i1, Reader r, int i2)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i1, \"Reader\", r);\n+\t\t\t\tsuper.setCharacterStream (i1, r, i2);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setRef (int i, Ref r) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, \"Ref\", r);\n+\t\t\t\tsuper.setRef (i, r);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setBlob (int i, Blob b) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, \"Blob\", b);\n+\t\t\t\tsuper.setBlob (i, b);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setClob (int i, Clob c) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, \"Clob\", c);\n+\t\t\t\tsuper.setClob (i, c);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setArray (int i, Array a) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, \"Array\", a);\n+\t\t\t\tsuper.setArray (i, a);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t    \tpublic ResultSetMetaData getMetaData () \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\treturn super.getMetaData ();\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setDate (int i, Date d, Calendar c) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, \"Date\", d);\n+\t\t\t\tsuper.setDate (i, d, c);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setTime (int i, Time t, Calendar c) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, \"Time\", t);\n+\t\t\t\tsuper.setTime (i, t, c);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setTimestamp (int i, Timestamp t, Calendar c) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i, \"Timestamp\", t);\n+\t\t\t\tsuper.setTimestamp (i, t, c);\n+\t\t\t}\n+\t\t\n+\t\t\n+\t\t\tpublic void setNull (int i1, int i2, String s) \n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tsetLogParameter (i1, \"null\", null);\n+\t\t\t\tsuper.setNull (i1, i2, s);\n+\t\t\t}\n+\t\n+\t\n+\t\t\tprotected void appendInfo (StringBuffer buf)\n+\t\t\t{\n+\t\t\t\tbuf.append (\" \");\n+\t\t\t\tif (_formatter != null)\n+\t\t\t\t{\n+\t\t\t\t\tbuf.append (SEP);\n+\t\t\t\t\tbuf.append (_formatter.prettyPrint (_sql));\n+\t\t\t\t\tbuf.append (SEP);\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\tbuf.append (_sql);\n+\t\t\t\t}\n+\t\n+\t\t\t\tStringBuffer paramBuf = null;\n+\t\t\t\tif (_params != null && !_params.isEmpty ())\n+\t\t\t\t{\n+\t\t\t\t\tparamBuf = new StringBuffer ();\n+\t\t\t\t\tfor (Iterator itr = _params.iterator (); itr.hasNext ();)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tparamBuf.append (itr.next ());\n+\t\t\t\t\t\tif (itr.hasNext ())\n+\t\t\t\t\t\t\tparamBuf.append (\", \");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\n+\t\t\t\tif (paramBuf != null)\n+\t\t\t\t{\n+\t\t\t\t\tif (!_prettyPrint)\n+\t\t\t\t\t\tbuf.append (\" \");\n+\t\t\t\t\tbuf.append (\"[params=\").\n+\t\t\t\t\t\tappend (paramBuf.toString ()).append (\"]\");\n+\t\t\t\t}\n+\t\t\t\tsuper.appendInfo (buf);\n+\t\t\t}\n+\t\n+\t\n+\t\t\tprivate void log (String msg, long startTime)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\tif (_logs.isSQLEnabled ())\n+\t\t\t\t\t_logs.logSQL (msg + \" \" + this, startTime,\n+\t\t\t\t\t\tLoggingConnection.this);\n+\t\t\t}\n+\t\n+\t\n+\t\t\tprivate void clearLogParameters (boolean batch)\n+\t\t\t{\n+\t\t\t\tif (_params != null)\n+\t\t\t\t\t_params.clear ();\n+\t\t\t\tif (batch && _paramBatch != null)\n+\t\t\t\t\t_paramBatch.clear ();\n+\t\t\t}\n+\n+\n+\t\t\tprivate boolean shouldTrackParameters ()\n+\t\t\t{\n+\t\t\t\treturn _trackParameters || _logs.isSQLEnabled ();\n+\t\t\t}\n+\t\n+\t\n+\t\t\tprivate void setLogParameter (int index, boolean val)\n+\t\t\t{\n+\t\t\t\tif (shouldTrackParameters ())\n+\t\t\t\t\tsetLogParameter (index, \"(boolean) \" + val);\n+\t\t\t}\n+\t\n+\t\n+\t\t\tprivate void setLogParameter (int index, byte val)\n+\t\t\t{\n+\t\t\t\tif (shouldTrackParameters ())\n+\t\t\t\t\tsetLogParameter (index, \"(byte) \" + val);\n+\t\t\t}\n+\t\n+\t\n+\t\t\tprivate void setLogParameter (int index, double val)\n+\t\t\t{\n+\t\t\t\tif (shouldTrackParameters ())\n+\t\t\t\t\tsetLogParameter (index, \"(double) \" + val);\n+\t\t\t}\n+\t\n+\t\n+\t\t\tprivate void setLogParameter (int index, float val)\n+\t\t\t{\n+\t\t\t\tif (shouldTrackParameters ())\n+\t\t\t\t\tsetLogParameter (index, \"(float) \" + val);\n+\t\t\t}\n+\t\n+\t\n+\t\t\tprivate void setLogParameter (int index, int val)\n+\t\t\t{\n+\t\t\t\tif (shouldTrackParameters ())\n+\t\t\t\t\tsetLogParameter (index, \"(int) \" + val);\n+\t\t\t}\n+\t\n+\t\n+\t\t\tprivate void setLogParameter (int index, long val)\n+\t\t\t{\n+\t\t\t\tif (shouldTrackParameters ())\n+\t\t\t\t\tsetLogParameter (index, \"(long) \" + val);\n+\t\t\t}\n+\t\n+\t\n+\t\t\tprivate void setLogParameter (int index, short val)\n+\t\t\t{\n+\t\t\t\tif (shouldTrackParameters ())\n+\t\t\t\t\tsetLogParameter (index, \"(short) \" + val);\n+\t\t\t}\n+\t\n+\t\n+\t\t\tprivate void setLogParameter (int index, String type, Object val)\n+\t\t\t{\n+\t\t\t\tif (shouldTrackParameters ())\n+\t\t\t\t\tsetLogParameter (index, \"(\" + type + \") \" + val);\n+\t\t\t}\n+\t\n+\t\n+\t\t\tprivate void setLogParameter (int index, String val)\n+\t\t\t{\n+\t\t\t\tif (_params == null)\n+\t\t\t\t\t_params = new ArrayList ();\n+\t\t\t\twhile (_params.size () < index)\n+\t\t\t\t\t_params.add (null);\n+\t\t\t\tif (val.length () > 80)\n+\t\t\t\t\tval = val.substring (0, 77) + \"...\";\n+\t\t\t\t_params.set (index - 1, val);\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\tprivate class LoggingResultSet\n+\t\t\textends DelegatingResultSet\n+\t\t{\n+\t\t\tpublic LoggingResultSet (ResultSet rs, Statement stmnt)\n+\t\t\t{\n+\t\t\t\tsuper (rs, stmnt);\n+\t\t\t}\n+\n+\n+\t\t\tpublic boolean next ()\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\treturn super.next ();\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\thandleSQLWarning (LoggingResultSet.this);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\n+\t\t\tpublic void close ()\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\tsuper.close ();\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\thandleSQLWarning (LoggingResultSet.this);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\n+\t\t\tpublic void beforeFirst ()\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\tsuper.beforeFirst ();\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\thandleSQLWarning (LoggingResultSet.this);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\n+\t\t\tpublic void afterLast ()\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\tsuper.afterLast ();\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\thandleSQLWarning (LoggingResultSet.this);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\n+\t\t\tpublic boolean first ()\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\treturn super.first ();\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\thandleSQLWarning (LoggingResultSet.this);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\n+\t\t\tpublic boolean last ()\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\treturn super.last ();\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\thandleSQLWarning (LoggingResultSet.this);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\n+\t\t\tpublic boolean absolute (int a)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\treturn super.absolute (a);\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\thandleSQLWarning (LoggingResultSet.this);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\n+\t\t\tpublic boolean relative (int a)\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\treturn super.relative (a);\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\thandleSQLWarning (LoggingResultSet.this);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\n+\t\t\tpublic boolean previous ()\n+\t\t\t\tthrows SQLException\n+\t\t\t{\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\treturn super.previous ();\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\thandleSQLWarning (LoggingResultSet.this);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}"},{"sha":"6582996d860ead1f97614f49e241245fcf1d1e26","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/ReportingSQLException.java","status":"added","additions":109,"deletions":0,"changes":109,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/ReportingSQLException.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/ReportingSQLException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/ReportingSQLException.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+import java.sql.*;\n+\n+\n+/** \n+ *  <p>A {@link SQLException} that contains information about\n+ *  the {@link Statement} SQL that caused the exception.</p>\n+ *  \n+ *  @author  Marc Prud'hommeaux\n+ *\t@nojavadoc\n+ */\n+public class ReportingSQLException\n+\textends SQLException\n+{\n+\tprivate final transient Statement\t_stmnt;\n+\tprivate final SQLException\t\t\t_sqle;\n+\n+\tpublic ReportingSQLException (SQLException sqle,\n+\t\tStatement stmnt, String sql)\n+\t{\n+\t\tsuper (getExceptionMessage (sqle, stmnt, sql));\n+\t\tthis._sqle = sqle;\n+\t\tthis._stmnt = stmnt;\n+\t\tsetNextException (sqle);\n+\t}\n+\n+\n+\tpublic ReportingSQLException (SQLException sqle, String sql)\n+\t{\n+\t\tthis (sqle, null, sql);\n+\t}\n+\n+\n+\tpublic ReportingSQLException (SQLException sqle, Statement stmnt)\n+\t{\n+\t\tthis (sqle, stmnt, null);\n+\t}\n+\n+\n+\t/** \n+\t *  Returns the SQL state of the underlying {@link SQLException}.\n+\t */\n+\tpublic String getSQLState ()\n+\t{\n+\t\treturn _sqle.getSQLState ();\n+\t}\n+\n+\n+\t/** \n+\t *  Returns the error code of the underlying {@link SQLException}.\n+\t */\n+\tpublic int getErrorCode ()\n+\t{\n+\t\treturn _sqle.getErrorCode ();\n+\t}\n+\n+\n+\t/** \n+\t *  Returns the {@link Statement} that caused the exception.\n+\t */\n+\tpublic Statement getStatement ()\n+\t{\n+\t\treturn _stmnt;\n+\t}\n+\n+\n+\tprivate static String getExceptionMessage (SQLException sqle,\n+\t\tStatement stmnt, String sql)\n+\t{\n+\t\ttry\n+\t\t{\n+\t\t\tif (stmnt != null)\n+\t\t\t\treturn sqle.getMessage () + \" {\" + stmnt + \"} \"\n+\t\t\t\t\t+ \"[code=\" + sqle.getErrorCode () + \", state=\"\n+\t\t\t\t\t+ sqle.getSQLState () + \"]\";\n+\t\t\telse if (sql != null)\n+\t\t\t\treturn sqle.getMessage () + \" {\" + sql + \"} \"\n+\t\t\t\t\t+ \"[code=\" + sqle.getErrorCode () + \", state=\"\n+\t\t\t\t\t+ sqle.getSQLState () + \"]\";\n+\t\t\telse\n+\t\t\t\treturn sqle.getMessage () + \" \"\n+\t\t\t\t\t+ \"[code=\" + sqle.getErrorCode () + \", state=\"\n+\t\t\t\t\t+ sqle.getSQLState () + \"]\";\n+\t\t}\n+\t\tcatch (Throwable t)\n+\t\t{\n+\t\t\treturn sqle.getMessage ();\n+\t\t}\n+\t}\n+}\n+\n+"},{"sha":"2d4ca3ea7f61f43d870de5f790b4989459d8864b","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/SQLFormatter.java","status":"added","additions":331,"deletions":0,"changes":331,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/SQLFormatter.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/SQLFormatter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/SQLFormatter.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,331 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+\n+import java.util.*;\n+\n+\n+/*\n+ *\tLots of this could be abstracted out into a word-wrapping class.\n+ */\n+\n+/**\n+ *\t<p>Converts single-line SQL strings into nicely-formatted\n+ *\tmulti-line, indented statements.</p>\n+ *\n+\t<p>Example:\n+ \t<code>SELECT * from PERSON t0, COMPANY t1 WHERE t0.ID = 10 AND \\\n+t0.COMPANY_ID = t1.ID AND t1.NAME = 'OpenJPA'</code>\n+ \tbecomes \n+ \t<code>SELECT * \n+    FROM PERSON t0, COMPANY t1 \n+    WHERE t0.ID = 10 AND t0.COMPANY_ID = t1.ID AND t1.NAME = 'OpenJPA'\\\n+</code>\n+\tand\n+ \t<code>INSERT INTO PERSON VALUES ('Patrick', 'Linskey', 'OpenJPA', \\\n+'202 595 2064 x1111')</code>\n+ \tbecomes \n+ \t<code>INSERT INTO PERSON VALUES ('Patrick', 'Linskey', 'OpenJPA', '202 \n+        595 2064 x1111')</code>\n+\tetc.</p>\n+ *\n+ *\t@author\tPatrick Linskey\n+ */\n+public class SQLFormatter\n+{\n+\tprivate boolean \tmultiLine = false;\n+\tprivate boolean \tdoubleSpace = true;\n+\tprivate String \t\tnewline = System.getProperty (\"line.separator\");\n+\tprivate int\t\t\tlineLength = 72;\n+\tprivate String\t\twrapIndent = \"        \";\n+\tprivate String\t\tclauseIndent = \"    \";\n+\n+\n+\tprivate static final String[] selectSeparators = new String[] {\n+\t\t\t\"FROM \",\n+\t\t\t\"WHERE \",\n+\t\t\t\"ORDER BY \", // ### is this order correct?\n+\t\t\t\"GROUP BY \",\n+\t\t\t\"HAVING \",\n+\t\t};\n+\n+\tprivate static final String[] insertSeparators = new String[] {\n+\t\t\t\"VALUES \",\n+\t\t};\n+\n+\tprivate static final String[] updateSeparators = new String[] {\n+\t\t\t\"SET \",\n+\t\t\t\"WHERE \",\n+\t\t};\n+\n+\tprivate static final String[] deleteSeparators = new String[] {\n+\t\t\t\"WHERE \",\n+\t\t};\n+\n+\tprivate static final String[] createTableSeparators = new String[] {\n+\t\t\t\"( \",\n+\t\t};\n+\n+\tprivate static final String[] createIndexSeparators = new String[] {\n+\t\t\t\"ON \",\n+\t\t\t\"( \",\n+\t\t};\n+\n+\n+\tpublic void setNewline (String val)\n+\t{\n+\t\tnewline = val;\n+\t}\n+\n+\n+\tpublic String getNewline ()\n+\t{\n+\t\treturn newline;\n+\t}\n+\n+\n+\tpublic void setLineLength (int val)\n+\t{\n+\t\tlineLength = val;\n+\t}\n+\n+\n+\tpublic int getLineLength ()\n+\t{\n+\t\treturn lineLength;\n+\t}\n+\n+\n+\tpublic void setWrapIndent (String val)\n+\t{\n+\t\twrapIndent = val;\n+\t}\n+\n+\n+\tpublic String getWrapIndent ()\n+\t{\n+\t\treturn wrapIndent;\n+\t}\n+\n+\n+\tpublic void setClauseIndent (String val)\n+\t{\n+\t\tclauseIndent = val;\n+\t}\n+\n+\n+\tpublic String getClauseIndent ()\n+\t{\n+\t\treturn clauseIndent;\n+\t}\n+\n+\n+\t/** \n+\t *  If true, then try to parse multi-line SQL statements.\n+\t */\n+\tpublic void setMultiLine (boolean multiLine)\n+\t{\n+\t\tthis.multiLine = multiLine;\n+\t}\n+\n+\n+\t/** \n+\t *  If true, then try to parse multi-line SQL statements.\n+\t */\n+\tpublic boolean getMultiLine ()\n+\t{\n+\t\treturn this.multiLine;\n+\t}\n+\n+\n+\n+\t/** \n+\t *  If true, then output two lines after multi-line statements.\n+\t */\n+\tpublic void setDoubleSpace (boolean doubleSpace)\n+\t{\n+\t\tthis.doubleSpace = doubleSpace;\n+\t}\n+\n+\n+\t/** \n+\t *  If true, then output two lines after multi-line statements.\n+\t */\n+\tpublic boolean getDoubleSpace ()\n+\t{\n+\t\treturn this.doubleSpace;\n+\t}\n+\n+\n+\n+\tpublic Object prettyPrint (Object sqlObject)\n+\t{\n+\t\tif (!multiLine)\n+\t\t{\n+\t\t\treturn prettyPrintLine (sqlObject);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tStringBuffer sql = new StringBuffer (sqlObject.toString ());\n+\t\t\tStringBuffer buf = new StringBuffer (sql.length ());\n+\n+\t\t\twhile (sql.length () > 0)\n+\t\t\t{\n+\t\t\t\tString line = null;\n+\n+\t\t\t\tint index = Math.max (sql.toString ().indexOf (\";\\n\"),\n+\t\t\t\t\tsql.toString ().indexOf (\";\\r\"));\n+\t\t\t\tif (index == -1)\n+\t\t\t\t\tline = sql.toString ();\n+\t\t\t\telse\n+\t\t\t\t\tline = sql.substring (0, index + 2);\n+\n+\t\t\t\t// remove the current line from the sql buffer\n+\t\t\t\tsql.delete (0, line.length ());\n+\n+\t\t\t\tbuf.append (prettyPrintLine (line));\n+\t\t\t\tfor (int i = 0; i < 1 + (getDoubleSpace () ? 1 : 0); i++)\n+\t\t\t\t\tbuf.append (System.getProperty (\"line.separator\"));\n+\t\t\t}\n+\n+\t\t\treturn buf.toString ();\n+\t\t}\n+\t}\n+\n+\n+\tprivate Object prettyPrintLine (Object sqlObject)\n+\t{\n+\t\tString sql = sqlObject.toString ().trim ();\n+\t\tString lowerCaseSql = sql.toLowerCase ();\n+\n+\t\tString[] separators;\n+\t\tif (lowerCaseSql.startsWith (\"select\"))\n+\t\t\tseparators = selectSeparators;\n+\t\telse if (lowerCaseSql.startsWith (\"insert\"))\n+\t\t\tseparators = insertSeparators;\n+\t\telse if (lowerCaseSql.startsWith (\"update\"))\n+\t\t\tseparators = updateSeparators;\n+\t\telse if (lowerCaseSql.startsWith (\"delete\"))\n+\t\t\tseparators = deleteSeparators;\n+\t\telse if (lowerCaseSql.startsWith (\"create table\"))\n+\t\t\tseparators = createTableSeparators;\n+\t\telse if (lowerCaseSql.startsWith (\"create index\"))\n+\t\t\tseparators = createIndexSeparators;\n+\t\telse\n+\t\t\tseparators = new String[0];\n+\n+\t\tint start = 0;\n+\t\tint end = -1;\n+\t\tStringBuffer clause;\n+\t\tList clauses = new ArrayList ();\n+\t\tclauses.add (new StringBuffer ());\n+\t\tfor (int i = 0; i < separators.length; i++)\n+\t\t{\n+\t\t\tend = lowerCaseSql.indexOf (\" \" + separators[i].toLowerCase (), \n+\t\t\t\tstart);\n+\t\t\tif (end == -1)\n+\t\t\t\tbreak;\n+\n+\t\t\tclause = (StringBuffer) clauses.get (clauses.size () - 1);\n+\t\t\tclause.append (sql.substring (start, end));\n+\n+\t\t\tclause = new StringBuffer ();\n+\t\t\tclauses.add (clause);\n+\t\t\tclause.append (clauseIndent);\n+\t\t\tclause.append (separators[i]);\n+\n+\t\t\tstart = end + 1 + separators[i].length ();\n+\t\t}\n+\n+\t\tclause = (StringBuffer) clauses.get (clauses.size () - 1);\n+\t\tclause.append (sql.substring (start));\n+\n+\n+\t\tStringBuffer pp = new StringBuffer (sql.length ());\n+\t\tfor (Iterator iter = clauses.iterator (); iter.hasNext (); )\n+\t\t{\n+\t\t\tpp.append (wrapLine (((StringBuffer) iter.next ()).toString ()));\n+\t\t\tif (iter.hasNext ())\n+\t\t\t\tpp.append (newline);\n+\t\t}\n+\n+\t\treturn pp.toString ();\n+\t}\n+\n+\n+\tprivate String wrapLine (String line)\n+\t{\n+\t\tStringBuffer lines = new StringBuffer (line.length ());\n+\n+\t\t// ensure that any leading whitespace is preserved.\n+\t\tfor (int i = 0; i < line.length () && \n+\t\t\t\t (line.charAt (i) == ' ' || line.charAt (i) == '\\t'); i++)\n+\t\t{\n+\t\t\tlines.append (line.charAt (i));\n+\t\t}\n+\n+\t\tStringTokenizer tok = new StringTokenizer (line);\n+\t\tint length = 0;\n+\t\tString elem;\n+\t\twhile (tok.hasMoreTokens ())\n+\t\t{\n+\t\t\telem = tok.nextToken ();\n+\t\t\tlength += elem.length ();\n+\n+\t\t\t// if we would have exceeded the max, write out a newline\n+\t\t\t// before writing the elem.\n+\t\t\tif (length >= lineLength)\n+\t\t\t{\n+\t\t\t\tlines.append (newline);\n+\t\t\t\tlines.append (wrapIndent);\n+\t\t\t\tlines.append (elem);\n+\t\t\t\tlines.append (' ');\n+\t\t\t\tlength = wrapIndent.length () + elem.length () + 1;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\t// if the current length is greater than the max, then the\n+\t\t\t// last word alone was too long, so just write out a\n+\t\t\t// newline and move on.\n+\t\t\tif (elem.length () >= lineLength)\n+\t\t\t{\n+\t\t\t\tlines.append (elem);\n+\t\t\t\tif (tok.hasMoreTokens ())\n+\t\t\t\t\tlines.append (newline);\n+\t\t\t\tlines.append (wrapIndent);\n+\t\t\t\tlength = wrapIndent.length ();\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t\n+\t\t\tlines.append (elem);\n+\t\t\tlines.append (' ');\n+\t\t\tlength++;\n+\t\t}\n+\n+\t\treturn lines.toString ();\n+\t}\n+\n+\n+\tpublic static void main (String [] args) \n+\t{\n+\t\tSQLFormatter formatter = new SQLFormatter ();\n+\t\tfor (int i = 0; i < args.length; i++)\n+\t\t{\n+\t\t\tSystem.out.println (formatter.prettyPrint (args[i]));\n+\t\t}\n+\t}\n+}"},{"sha":"e6e918d37faf9f377ab4b58601690729ac3370e8","filename":"openjpa-lib/java/org/apache/openjpa/lib/jdbc/package.html","status":"added","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/package.html","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/jdbc/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/jdbc/package.html?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,26 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+<html>\n+<body>\n+\t<p><strong>Database Connectivity</strong></p>\n+\t<p>\n+\t\tIncludes an implementation of the {@link javax.sql.DataSource} APIs \n+\t\taround a normal JDBC 1.x driver.  Implements connection pooling and\n+\t\tprepared statement caching.  Also includes a framework for firing and\n+\t \tconsuming JDBC-related events.\n+\t</p>\n+</body>\n+</html>"},{"sha":"ecd021a6dfbacf6ebe50599fd5f41f5a06b09921","filename":"openjpa-lib/java/org/apache/openjpa/lib/log/AbstractLog.java","status":"added","additions":195,"deletions":0,"changes":195,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/AbstractLog.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/AbstractLog.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/log/AbstractLog.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.log;\n+\n+\n+import java.io.*;\n+\n+\n+/** \n+ *  A simple implementation of the {@link Log} interface. Writes\n+ *  output to stdout.\n+ *\n+ *\t@author\tPatrick Linskey\n+ */\n+public abstract class AbstractLog\n+\timplements Log\n+{\n+\t/** \n+\t *  Check to see if the specified logging level is enabled.\n+\t */\n+\tprotected abstract boolean isEnabled (short level);\n+\n+\n+\t/** \n+\t *  Send the specified log message to the handler.\n+\t *  \n+\t *  @param  level\tthe level of the log message\n+\t *  @param  message\tthe message to send\n+\t *  @param  t\t\tthe Throwable, or null if this is not an error\n+\t */\n+\tprotected abstract void log (short level, String message, Throwable t);\n+\n+\n+\tpublic boolean isTraceEnabled ()\n+\t{\n+\t\treturn isEnabled (TRACE);\n+\t}\n+\n+\n+\tpublic boolean isDebugEnabled ()\n+\t{\n+\t\treturn isEnabled (DEBUG);\n+\t}\n+\n+\n+\tpublic boolean isInfoEnabled ()\n+\t{\n+\t\treturn isEnabled (INFO);\n+\t}\n+\n+\n+\tpublic boolean isWarnEnabled ()\n+\t{\n+\t\treturn isEnabled (WARN);\n+\t}\n+\n+\n+\tpublic boolean isErrorEnabled ()\n+\t{\n+\t\treturn isEnabled (ERROR);\n+\t}\n+\n+\n+\tpublic boolean isFatalEnabled ()\n+\t{\n+\t\treturn isEnabled (FATAL);\n+\t}\n+\n+\n+\tpublic void trace (Object message)\n+\t{\n+\t\ttrace (message, throwableParam (message, null));\n+\t}\n+\n+\n+\tpublic void trace (Object message, Throwable t)\n+\t{\n+\t\tif (isTraceEnabled ())\n+\t\t\tlog (TRACE, toString (message), throwableParam (message, t));\n+\t}\n+\n+\n+\tpublic void debug (Object message)\n+\t{\n+\t\tdebug (message, throwableParam (message, null));\n+\t}\n+\n+\n+\tpublic void debug (Object message, Throwable t)\n+\t{\n+\t\tif (isDebugEnabled ())\n+\t\t\tlog (DEBUG, toString (message), throwableParam (message, t));\n+\t}\n+\n+\n+\tpublic void info (Object message)\n+\t{\n+\t\tinfo (message, throwableParam (message, null));\n+\t}\n+\n+\n+\tpublic void info (Object message, Throwable t)\n+\t{\n+\t\tif (isInfoEnabled ())\n+\t\t\tlog (INFO, toString (message), throwableParam (message, t));\n+\t}\n+\n+\n+\tpublic void warn (Object message)\n+\t{\n+\t\twarn (message, throwableParam (message, null));\n+\t}\n+\n+\n+\tpublic void warn (Object message, Throwable t)\n+\t{\n+\t\tif (isWarnEnabled ())\n+\t\t\tlog (WARN, toString (message), throwableParam (message, t));\n+\t}\n+\n+\n+\tpublic void error (Object message)\n+\t{\n+\t\terror (message, throwableParam (message, null));\n+\t}\n+\n+\n+\tpublic void error (Object message, Throwable t)\n+\t{\n+\t\tif (isErrorEnabled ())\n+\t\t\tlog (ERROR, toString (message), throwableParam (message, t));\n+\t}\n+\n+\n+\tpublic void fatal (Object message)\n+\t{\n+\t\tfatal (message, throwableParam (message, null));\n+\t}\n+\n+\n+\tpublic void fatal (Object message, Throwable t)\n+\t{\n+\t\tif (isFatalEnabled ())\n+\t\t\tlog (FATAL, toString (message), throwableParam (message, t));\n+\t}\n+\n+\n+\t/** \n+\t *  Utility method to obtain a stack trace as a String.\n+\t */\n+\tprotected static String getStackTrace (Throwable t)\n+\t{\n+\t\tStringWriter sw = new StringWriter ();\n+\t\tPrintWriter pw = new PrintWriter (sw, true);\n+\t\tt.printStackTrace (pw);\n+\t\tpw.close ();\n+\t\treturn sw.toString ();\n+\t}\n+\n+\n+\t/**\n+\t *\tIf either given instance is a throwable, return it.\n+\t */\n+\tprivate static Throwable throwableParam (Object message, Throwable t)\n+\t{\n+\t\tif (t != null)\n+\t\t\treturn t;\n+\t\tif (message instanceof Throwable)\n+\t\t\treturn (Throwable)message;\n+\n+\t\treturn null;\n+\t}\n+\n+\n+\t/**\n+\t *\tEfficiently turn the given object into a string.\n+ \t */\n+\tprivate static String toString (Object o)\n+\t{\n+\t\treturn (o == null) ? \"null\" : o.toString ();\n+\t}\n+}"},{"sha":"bb54cf2fb552aa0a7c9a24c85b1281d77cacd7a1","filename":"openjpa-lib/java/org/apache/openjpa/lib/log/CommonsLogFactory.java","status":"added","additions":175,"deletions":0,"changes":175,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/CommonsLogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/CommonsLogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/log/CommonsLogFactory.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.log;\n+\n+\n+import java.util.*;\n+\n+\n+/**\n+ *\t{@link LogFactory} implementation that delegates to the commons logging\n+ *\tframework.\n+ *\n+ *\t@author\tPatrick Linskey\n+ */\n+public class CommonsLogFactory\n+\textends LogFactoryAdapter\n+{\n+\tprivate org.apache.commons.logging.LogFactory _factory;\n+\n+\n+\tpublic CommonsLogFactory ()\n+\t{\n+\t\t_factory = org.apache.commons.logging.LogFactory.getFactory ();\n+\t}\n+\n+\n+\tprotected org.apache.openjpa.lib.log.Log newLogAdapter (String channel)\n+\t{\n+\t\treturn new LogAdapter (_factory.getInstance (channel));\n+\t}\n+\n+\n+\t/**\n+\t *\tAdapts a commons logging log to the {@link org.apache.openjpa.lib.log.Log} \n+\t *\tinterface.\n+\t */\n+\tpublic static class LogAdapter\n+\t\timplements org.apache.openjpa.lib.log.Log\n+\t{\n+\t\tprivate org.apache.commons.logging.Log _log;\n+\n+\n+\t\tprivate LogAdapter (org.apache.commons.logging.Log wrapee)\n+\t\t{\n+\t\t\t_log = wrapee;\n+\t\t}\n+\n+\n+\t\tpublic org.apache.commons.logging.Log getDelegate ()\n+\t\t{\n+\t\t\treturn _log;\n+\t\t}\n+\n+\n+\t\tpublic boolean isDebugEnabled ()\n+\t\t{\n+\t\t\treturn _log.isDebugEnabled ();\n+\t\t}\n+\n+\n+\t\tpublic boolean isErrorEnabled ()\n+\t\t{\n+\t\t\treturn _log.isErrorEnabled ();\n+\t\t}\n+\n+\n+\t\tpublic boolean isFatalEnabled ()\n+\t\t{\n+\t\t\treturn _log.isFatalEnabled ();\n+\t\t}\n+\n+\n+\t\tpublic boolean isInfoEnabled ()\n+\t\t{\n+\t\t\treturn _log.isInfoEnabled ();\n+\t\t}\n+\n+\n+\t\tpublic boolean isTraceEnabled ()\n+\t\t{\n+\t\t\treturn _log.isTraceEnabled ();\n+\t\t}\n+\n+\n+\t\tpublic boolean isWarnEnabled ()\n+\t\t{\n+\t\t\treturn _log.isWarnEnabled ();\n+\t\t}\n+\n+\n+\t\tpublic void trace (Object o)\n+\t\t{\n+\t\t\t_log.trace (o);\n+\t\t}\n+\n+\n+\t\tpublic void trace (Object o, Throwable t)\n+\t\t{\n+\t\t\t_log.trace (o, t);\n+\t\t}\n+\n+\n+\t\tpublic void debug (Object o)\n+\t\t{\n+\t\t\t_log.debug (o);\n+\t\t}\n+\n+\n+\t\tpublic void debug (Object o, Throwable t)\n+\t\t{\n+\t\t\t_log.debug (o, t);\n+\t\t}\n+\n+\n+\t\tpublic void info (Object o)\n+\t\t{\n+\t\t\t_log.info (o);\n+\t\t}\n+\n+\n+\t\tpublic void info (Object o, Throwable t)\n+\t\t{\n+\t\t\t_log.info (o, t);\n+\t\t}\n+\n+\n+\t\tpublic void warn (Object o)\n+\t\t{\n+\t\t\t_log.warn (o);\n+\t\t}\n+\n+\n+\t\tpublic void warn (Object o, Throwable t)\n+\t\t{\n+\t\t\t_log.warn (o, t);\n+\t\t}\n+\n+\n+\t\tpublic void error (Object o)\n+\t\t{\n+\t\t\t_log.error (o);\n+\t\t}\n+\n+\n+\t\tpublic void error (Object o, Throwable t)\n+\t\t{\n+\t\t\t_log.error (o, t);\n+\t\t}\n+\n+\n+\t\tpublic void fatal (Object o)\n+\t\t{\n+\t\t\t_log.fatal (o);\n+\t\t}\n+\n+\n+\t\tpublic void fatal (Object o, Throwable t)\n+\t\t{\n+\t\t\t_log.fatal (o, t);\n+\t\t}\n+\t}\n+}"},{"sha":"30503a9e9927d62d2c58a8697ccc3318330db8f5","filename":"openjpa-lib/java/org/apache/openjpa/lib/log/Log.java","status":"added","additions":165,"deletions":0,"changes":165,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/Log.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/Log.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/log/Log.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.log;\n+\n+\n+/**\n+ *\tLogging interface that is independent of other logging frameworks. \n+ *\n+ *\t@author Patrick Linskey\n+ *\t@author\tAbe White\n+ */\n+public interface Log\n+{\n+\tpublic static final short TRACE\t= 1;\n+\tpublic static final short DEBUG\t= 2;\n+\tpublic static final short INFO\t= 3;\n+\tpublic static final short WARN\t= 4;\n+\tpublic static final short ERROR\t= 5;\n+\tpublic static final short FATAL\t= 6;\n+\n+\n+\t/**\n+\t *\tReturns if the {@link #TRACE} log level is enabled.\n+\t */\n+    public boolean isTraceEnabled ();\n+\n+\n+\t/**\n+\t *\tReturns if the {@link #DEBUG} log level is enabled.\n+\t */\n+    public boolean isDebugEnabled ();\n+\n+\n+\t/**\n+\t *\tReturns if the {@link #INFO} log level is enabled.\n+\t */\n+    public boolean isInfoEnabled ();\n+\n+\n+\t/**\n+\t *\tReturns if the {@link #WARN} log level is enabled.\n+\t */\n+    public boolean isWarnEnabled ();\n+\n+\n+\t/**\n+\t *\tReturns if the {@link #ERROR} log level is enabled.\n+\t */\n+    public boolean isErrorEnabled ();\n+\n+\n+\t/**\n+\t *\tReturns if the {@link #FATAL} log level is enabled.\n+\t */\n+    public boolean isFatalEnabled ();\n+\n+\n+\t/**\n+\t *\tWrite out a log message at the {@link #TRACE}\n+\t *\tlevel with the stringification of <code>o</code> as the body\n+\t *\tof the message.\n+\t */\n+    public void trace (Object o);\n+\n+\n+\t/**\n+\t *\tWrite out a log message at the {@link #TRACE}\n+\t *\tlevel with the stringification of <code>o</code> as the body\n+\t *\tof the message, also outputting <code>t</code> to the log.\n+\t */\n+    public void trace (Object o, Throwable t);\n+\n+\n+\t/**\n+\t *\tWrite out a log message at the {@link #DEBUG}\n+\t *\tlevel with the stringification of <code>o</code> as the body\n+\t *\tof the message, also outputting <code>t</code> to the log.\n+\t */\n+    public void debug (Object o);\n+\n+\n+\t/**\n+\t *\tWrite out a log message at the {@link #DEBUG}\n+\t *\tlevel with the stringification of <code>o</code> as the body\n+\t *\tof the message, also outputting <code>t</code> to the log.\n+\t */\n+    public void debug (Object o, Throwable t);\n+\n+\n+\t/**\n+\t *\tWrite out a log message at the {@link #INFO}\n+\t *\tlevel with the stringification of <code>o</code> as the body\n+\t *\tof the message, also outputting <code>t</code> to the log.\n+\t */\n+    public void info (Object o);\n+\n+\n+\t/**\n+\t *\tWrite out a log message at the {@link #INFO}\n+\t *\tlevel with the stringification of <code>o</code> as the body\n+\t *\tof the message, also outputting <code>t</code> to the log.\n+\t */\n+    public void info (Object o, Throwable t);\n+\n+\n+\t/**\n+\t *\tWrite out a log message at the {@link #WARN}\n+\t *\tlevel with the stringification of <code>o</code> as the body\n+\t *\tof the message, also outputting <code>t</code> to the log.\n+\t */\n+    public void warn (Object o);\n+\n+\n+\t/**\n+\t *\tWrite out a log message at the {@link #WARN}\n+\t *\tlevel with the stringification of <code>o</code> as the body\n+\t *\tof the message, also outputting <code>t</code> to the log.\n+\t */\n+    public void warn (Object o, Throwable t);\n+\n+\n+\t/**\n+\t *\tWrite out a log message at the {@link #ERROR}\n+\t *\tlevel with the stringification of <code>o</code> as the body\n+\t *\tof the message, also outputting <code>t</code> to the log.\n+\t */\n+    public void error (Object o);\n+\n+\n+\t/**\n+\t *\tWrite out a log message at the {@link #ERROR}\n+\t *\tlevel with the stringification of <code>o</code> as the body\n+\t *\tof the message, also outputting <code>t</code> to the log.\n+\t */\n+    public void error (Object o, Throwable t);\n+\n+\n+\t/**\n+\t *\tWrite out a log message at the {@link #FATAL}\n+\t *\tlevel with the stringification of <code>o</code> as the body\n+\t *\tof the message, also outputting <code>t</code> to the log.\n+\t */\n+    public void fatal (Object o);\n+\n+\n+\t/**\n+\t *\tWrite out a log message at the {@link #FATAL}\n+\t *\tlevel with the stringification of <code>o</code> as the body\n+\t *\tof the message, also outputting <code>t</code> to the log.\n+\t */\n+    public void fatal (Object o, Throwable t);\n+}"},{"sha":"95a970a3701a30c4d7a7eab5950ddbae42d31c22","filename":"openjpa-lib/java/org/apache/openjpa/lib/log/Log4JLogFactory.java","status":"added","additions":166,"deletions":0,"changes":166,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/Log4JLogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/Log4JLogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/log/Log4JLogFactory.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.log;\n+\n+\n+import java.util.*;\n+\n+import org.apache.log4j.*;\n+\n+\n+/**\n+ *\t{@link LogFactory} implementation that delegates to the Log4J framework.\n+ *\n+ *\t@author\tPatrick Linskey\n+ */\n+public class Log4JLogFactory\n+\textends LogFactoryAdapter\n+{\n+\tprotected Log newLogAdapter (String channel)\n+\t{\n+\t\treturn new LogAdapter ((Logger) LogManager.getLogger (channel));\n+\t}\n+\n+\n+\t/**\n+\t *\tAdapts a Log4J logger to the {@link org.apache.openjpa.lib.log.Log} interface.\n+\t */\n+\tpublic static class LogAdapter\n+\t\timplements Log\n+\t{\n+\t\tprivate Logger _log;\n+\n+\n+\t\tprivate LogAdapter (Logger wrapee)\n+\t\t{\n+\t\t\t_log = wrapee;\n+\t\t}\n+\n+\n+\t\tpublic Logger getDelegate ()\n+\t\t{\n+\t\t\treturn _log;\n+\t\t}\n+\n+\n+\t\tpublic boolean isTraceEnabled ()\n+\t\t{\n+\t\t\treturn isDebugEnabled ();\n+\t\t}\n+\n+\n+\t\tpublic boolean isDebugEnabled ()\n+\t\t{\n+\t\t\treturn _log.getEffectiveLevel ().toInt () >= Level.DEBUG_INT;\n+\t\t}\n+\n+\n+\t\tpublic boolean isInfoEnabled ()\n+\t\t{\n+\t\t\treturn _log.getEffectiveLevel ().toInt () >= Level.INFO_INT;\n+\t\t}\n+\n+\n+\t\tpublic boolean isWarnEnabled ()\n+\t\t{\n+\t\t\treturn _log.getEffectiveLevel ().toInt () >= Level.WARN_INT;\n+\t\t}\n+\n+\n+\t\tpublic boolean isErrorEnabled ()\n+\t\t{\n+\t\t\treturn _log.getEffectiveLevel ().toInt () >= Level.ERROR_INT;\n+\t\t}\n+\n+\n+\t\tpublic boolean isFatalEnabled ()\n+\t\t{\n+\t\t\treturn _log.getEffectiveLevel ().toInt () >= Level.FATAL_INT;\n+\t\t}\n+\n+\n+\t\tpublic void trace (Object o)\n+\t\t{\n+\t\t\t_log.debug (o);\n+\t\t}\n+\n+\n+\t\tpublic void trace (Object o, Throwable t)\n+\t\t{\n+\t\t\t_log.debug (o, t);\n+\t\t}\n+\n+\n+\t\tpublic void debug (Object o)\n+\t\t{\n+\t\t\t_log.debug (o);\n+\t\t}\n+\n+\n+\t\tpublic void debug (Object o, Throwable t)\n+\t\t{\n+\t\t\t_log.debug (o, t);\n+\t\t}\n+\n+\n+\t\tpublic void info (Object o)\n+\t\t{\n+\t\t\t_log.info (o);\n+\t\t}\n+\n+\n+\t\tpublic void info (Object o, Throwable t)\n+\t\t{\n+\t\t\t_log.info (o, t);\n+\t\t}\n+\n+\n+\t\tpublic void warn (Object o)\n+\t\t{\n+\t\t\t_log.warn (o);\n+\t\t}\n+\n+\n+\t\tpublic void warn (Object o, Throwable t)\n+\t\t{\n+\t\t\t_log.warn (o, t);\n+\t\t}\n+\n+\n+\t\tpublic void error (Object o)\n+\t\t{\n+\t\t\t_log.error (o);\n+\t\t}\n+\n+\n+\t\tpublic void error (Object o, Throwable t)\n+\t\t{\n+\t\t\t_log.error (o, t);\n+\t\t}\n+\n+\n+\t\tpublic void fatal (Object o)\n+\t\t{\n+\t\t\t_log.fatal (o);\n+\t\t}\n+\n+\n+\t\tpublic void fatal (Object o, Throwable t)\n+\t\t{\n+\t\t\t_log.fatal (o, t);\n+\t\t}\n+\t}\n+}"},{"sha":"f11732529fa033813c237df8fc1fe4c380e41934","filename":"openjpa-lib/java/org/apache/openjpa/lib/log/LogFactory.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/LogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/LogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/log/LogFactory.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.log;\n+\n+\n+/**\n+ *\t<p>Factory for log instances.</p>\n+ *\n+ *\t@author\tAbe White\n+ */\n+public interface LogFactory\n+{\n+\t/**\n+\t *\tReturn a log for the given channel name.\n+\t */\n+\tpublic Log getLog (String channel);\n+}"},{"sha":"172c5fa935ffa035351e0923cf89a87e42dc18bb","filename":"openjpa-lib/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.log;\n+\n+\n+import java.util.*;\n+\n+\n+/**\n+ *\t<p>Base type that aids in adapting an external log framework to the \n+ *\t{@link LogFactory}.</p> \n+ *\n+ *\t@author\tAbe White\n+ */\t\n+public abstract class LogFactoryAdapter\n+\timplements LogFactory\n+{\n+\t// cache category to log adapters\n+\tprivate Map _logs = new HashMap ();\n+\n+\n+\tpublic synchronized Log getLog (String channel)\n+\t{\n+\t\tLog log = (Log) _logs.get (channel);\n+\t\tif (log == null)\n+\t\t{\n+\t\t\tlog = newLogAdapter (channel);\n+\t\t\t_logs.put (channel, log);\n+\t\t}\n+\t\treturn log;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn a log adapter for the given channel.\n+\t */\n+\tprotected abstract Log newLogAdapter (String channel);\n+}"},{"sha":"a9eaf175b74c7309c6ccca5f00a7c03e65a89afd","filename":"openjpa-lib/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","status":"added","additions":382,"deletions":0,"changes":382,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/log/LogFactoryImpl.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,382 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.log;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.conf.*;\n+import org.apache.openjpa.lib.util.*;\n+\n+\n+/**\n+ *\tDefault {@link LogFactory} implementation.  For ease of automatic\n+ *\tconfiguration, this implementation keys on only the last dot-separated \n+ *\ttoken of the log channel name.\n+ *\n+ *\t@author\tPatrick Linskey\n+ */\n+public class LogFactoryImpl\n+\timplements LogFactory, GenericConfigurable\n+{\n+\tprivate static Localizer _loc = Localizer.forPackage (LogFactoryImpl.class);\n+\n+\tpublic static final String TRACE_STR = _loc.get (\"log-trace\");\n+\tpublic static final String DEBUG_STR = _loc.get (\"log-debug\");\n+\tpublic static final String INFO_STR = _loc.get (\"log-info\");\n+\tpublic static final String WARN_STR = _loc.get (\"log-warn\");\n+\tpublic static final String ERROR_STR = _loc.get (\"log-error\");\n+\tpublic static final String FATAL_STR = _loc.get (\"log-fatal\");\n+\n+\tpublic static final String STDOUT = \"stdout\";\n+\tpublic static final String STDERR = \"stderr\";\n+\n+\tprivate static final String NEWLINE = System.getProperty (\"line.separator\");\n+\n+\n+\t/**\n+\t *\tThe time at which this factory was initialized.\n+\t */\n+\tprotected final long initializationMillis;\n+\n+\n+\t/**\n+\t *\tThe {@link Log}s that this factory manages, keyed by log\n+\t *\tchannel name.\n+\t */\n+\tprivate Map _logs = new HashMap (); // HashMap<String,Log>\n+\n+\n+\t/**\n+\t *\tThe default logging level.\n+\t */\n+\tprivate short _defaultLogLevel = Log.INFO;\n+\n+\n+\tprivate String _diagContext = null;\n+\n+\n+\t/**\n+\t *\tStorage for logging level configuration specified at\n+\t *\tconfiguration time.\n+\t */\n+\tprivate Map _configuredLevels = new HashMap (); // HashMap<String,Integer>\n+\n+\n+\t/**\n+\t *\tThe stream to write to.  Defaults to System.err.\n+\t */\n+\tprivate PrintStream _out = System.err;\n+\n+\n+\tpublic LogFactoryImpl ()\n+\t{\n+\t\tinitializationMillis = System.currentTimeMillis ();\n+\t}\n+\n+\n+\tpublic synchronized Log getLog (String channel)\n+\t{\n+\t\tLogImpl l = (LogImpl) _logs.get (channel);\n+\t\tif (l == null)\n+\t\t{\n+\t\t\tl = newLogImpl ();\n+\t\t\tl.setChannel (channel);\n+\t\t\tShort lvl = (Short) _configuredLevels.get (shorten (channel));\n+\t\t\tl.setLevel (lvl == null ? _defaultLogLevel : lvl.shortValue ());\n+\t\t\t_logs.put (channel, l);\n+\t\t}\n+\t\treturn l;\n+\t}\n+\n+\n+\t/**\n+\t *\tCreate a new log.  The log will be cached.\n+\t */\n+\tprotected LogImpl newLogImpl ()\n+\t{\n+\t\treturn new LogImpl ();\n+\t}\n+\n+\n+\t/**\n+\t *\tThe string name of the default level for unconfigured log channels;\n+\t *\tused for automatic configuration.\n+\t */\n+\tpublic void setDefaultLevel (String level)\n+\t{\n+\t\t_defaultLogLevel = getLevel (level);\n+\t}\n+\n+\n+\t/**\n+\t *\tThe default level for unconfigured log channels.\n+\t */\n+\tpublic short getDefaultLevel ()\n+\t{\n+\t\treturn _defaultLogLevel;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe default level for unconfigured log channels.\n+\t */\n+\tpublic void setDefaultLevel (short level)\n+\t{\n+\t\t_defaultLogLevel = level;\n+\t}\n+\n+\n+\t/**\n+\t *\tA string to prefix all log messages with. Set to\n+\t *\t<code>null</code> for no prefix.\n+\t */\n+\tpublic void setDiagnosticContext (String val)\n+\t{\n+\t\t_diagContext = val;\n+\t}\n+\n+\n+\t/**\n+\t *\tA string to prefix all log messages with. Set to\n+\t *\t<code>null</code> for no prefix.\n+\t */\n+\tpublic String getDiagnosticContext ()\n+\t{\n+\t\treturn _diagContext;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe stream to write to.  Recognized values are: <code>stdout</code>\n+\t *\tand <code>stderr</code>.   Any other value will be considered a \n+\t *\tfile name.\n+\t */\n+\tpublic void setFile (String file)\n+\t{\n+\t\tif (STDOUT.equals (file))\n+\t\t\t_out = System.out;\n+\t\telse if (STDERR.equals (file))\n+\t\t\t_out = System.err;\n+\t\telse\n+\t\t{\n+\t\t\tFile f = Files.getFile (file, null);\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\t_out = new PrintStream (new FileOutputStream \n+\t\t\t\t\t(f.getCanonicalPath (), true));\n+\t\t\t}\n+\t\t\tcatch (IOException ioe)\n+\t\t\t{\n+\t\t\t\tthrow new IllegalArgumentException (_loc.get (\"log-bad-file\",\n+\t\t\t\t\tfile) + \" \" + ioe.toString ());\n+\t\t\t}\n+\t\t} \n+\t} \n+\n+\n+\t/**\n+\t *\tThe stream to write to.\n+\t */\n+\tpublic PrintStream getStream ()\n+\t{\n+\t\treturn _out;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe stream to write to.\n+\t */\n+\tpublic void setStream (PrintStream stream)\n+\t{\n+\t\tif (stream == null)\n+\t\t\tthrow new NullPointerException (\"stream == null\");\n+\t\t_out = stream;\n+\t}\n+\n+\n+\t/** \n+\t *  Returns a string representation of the specified log level constant.\n+\t */\n+\tpublic static String getLevelName (short level)\n+\t{\n+\t\tswitch (level)\n+\t\t{\n+\t\tcase Log.TRACE:\n+\t\t\treturn TRACE_STR;\n+\t\tcase Log.DEBUG:\n+\t\t\treturn DEBUG_STR;\n+\t\tcase Log.INFO:\n+\t\t\treturn INFO_STR;\n+\t\tcase Log.WARN:\n+\t\t\treturn WARN_STR;\n+\t\tcase Log.ERROR:\n+\t\t\treturn ERROR_STR;\n+\t\tcase Log.FATAL:\n+\t\t\treturn FATAL_STR;\n+\t\tdefault:\n+\t\t\treturn _loc.get (\"log-unknown\");\n+\t\t}\n+\t}\n+\n+\n+\t/** \n+\t *  Returns a symbolic constant for the specified string level.\n+\t */\n+\tpublic static short getLevel (String str)\n+\t{\n+\t\tstr = str.toUpperCase ().trim ();\n+\t\tshort val = \n+\t\t\tTRACE_STR.equals (str) \t? Log.TRACE\t:\n+\t\t\tDEBUG_STR.equals (str) \t? Log.DEBUG\t:\n+\t\t\tINFO_STR.equals (str) \t? Log.INFO \t:\n+\t\t\tWARN_STR.equals (str) \t? Log.WARN\t:\n+\t\t\tERROR_STR.equals (str) \t? Log.ERROR\t:\n+\t\t\tFATAL_STR.equals (str) \t? Log.FATAL\t: -1;\n+\n+\t\tif (val == -1)\n+\t\t\tthrow new IllegalArgumentException \n+\t\t\t\t(_loc.get (\"log-bad-constant\", str));\n+\n+\t\treturn val;\n+\t}\n+\n+\n+\t// ---------- GenericConfigurable implementation ----------\n+\n+\tpublic void setInto (Map m)\n+\t{\n+\t\tif (!m.isEmpty ())\n+\t\t{\n+\t\t\tMap.Entry e;\n+\t\t\tfor (Iterator iter = m.entrySet ().iterator (); iter.hasNext (); )\n+\t\t\t{\n+\t\t\t\te = (Map.Entry) iter.next ();\n+\t\t\t\t_configuredLevels.put (shorten ((String) e.getKey ()),\n+\t\t\t\t\tnew Short (getLevel ((String) e.getValue ())));\n+\t\t\t}\n+\t\t\tm.clear ();\n+\t\t}\n+\t}\n+\n+\n+\tprivate static String shorten (String channel)\n+\t{\n+\t\treturn channel.substring (channel.lastIndexOf ('.') + 1);\n+\t}\n+\n+\n+\t/** \n+\t *  A simple implementation of the {@link Log} interface. Writes\n+\t *  output to stderr.\n+\t */\n+\tpublic class LogImpl\n+\t\textends AbstractLog\n+\t{\n+\t\tprivate short \t_level = INFO;\n+\t\tprivate String \t_channel;\n+\n+\n+\t\tprotected boolean isEnabled (short level)\n+\t\t{\n+\t\t\treturn level >= _level;\n+\t\t}\n+\n+\n+\t\tprotected void log (short level, String message, Throwable t)\n+\t\t{\n+\t\t\tString msg = formatMessage (level, message, t);\n+\t\t\tsynchronized (_out)\n+\t\t\t{\n+\t\t\t\t_out.print (msg);\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\t/**\n+\t\t *\tConvert <code>message</code> into a string ready to be written to\n+\t\t *\tthe log.  The string should include the terminating newline.\n+\t \t *\n+\t\t *\t@param\tt\tmay be null\n+\t\t */\n+\t\tprotected String formatMessage (short level, String message, \n+\t\t\tThrowable t)\n+\t\t{\n+\t\t\t// we write to a StringBuffer and then flush it all at\n+\t\t\t// once as a single line, since some environments (e.g., JBoss)\n+\t\t\t// override the System output stream to flush any calls\n+\t\t\t// to write without regard to line breaks, making the\n+\t\t\t// output incomprehensibe.\n+\t\t\tStringBuffer buf = new StringBuffer ();\n+\n+\t\t\tbuf.append (getOffset ());\n+\t\t\tbuf.append (\"  \");\n+\t\t\tif (_diagContext != null)\n+\t\t\t\tbuf.append (_diagContext).append (\"  \");\n+\t\t\tbuf.append (getLevelName (level));\n+\t\t\tif (level == INFO || level == WARN)\n+\t\t\t\tbuf.append (\" \");\n+\t\t\tbuf.append (\"  [\");\n+\t\t\tbuf.append (Thread.currentThread ().getName ());\n+\t\t\tbuf.append (\"] \");\n+\t\t\tbuf.append (_channel);\n+\t\t\tbuf.append (\" - \");\n+\t\t\tbuf.append (message);\n+\t\t\tbuf.append (NEWLINE);\n+\n+\t\t\tif (t != null)\n+\t\t\t{\n+\t\t\t\tStringWriter swriter = new StringWriter ();\n+\t\t\t\tPrintWriter pwriter = new PrintWriter (swriter);\n+\t\t\t\tt.printStackTrace (pwriter);\n+\t\t\t\tpwriter.flush ();\n+\t\t\t\tbuf.append (swriter.toString ());\n+\t\t\t}\n+\t\t\treturn buf.toString ();\n+\t\t}\n+\n+\n+\t\tprivate long getOffset ()\n+\t\t{\n+\t\t\treturn System.currentTimeMillis () - initializationMillis;\n+\t\t}\n+\n+\n+\t\tpublic void setChannel (String val)\n+\t\t{\n+\t\t\t_channel = val;\n+\t\t}\n+\n+\n+\t\tpublic String getChannel ()\n+\t\t{\n+\t\t\treturn _channel;\n+\t\t}\n+\n+\n+\t\tpublic void setLevel (short val)\n+\t\t{\n+\t\t\t_level = val;\n+\t\t}\n+\n+\n+\t\tpublic short getLevel ()\n+\t\t{\n+\t\t\treturn _level;\n+\t\t}\n+\t}\n+}"},{"sha":"0169998a88dc2551b33264666468d0fdd76bc335","filename":"openjpa-lib/java/org/apache/openjpa/lib/log/LogOutputStream.java","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/LogOutputStream.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/LogOutputStream.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/log/LogOutputStream.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.log;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.log.*;\n+\n+\n+/**\n+ *\t<p>Many standard components log to {@link OutputStream}s.\n+ *\tThis wrapper class extends the {@link ByteArrayOutputStream}\n+ *\tclass and writes all given data to an underlying {@link Log} instance\n+ *\twhenever it is flushed and the internally held byte array contains a \n+ *\tnewline.</p>\n+ *\n+ *\t@author\t\tAbe White, Marc Prud'hommeaux\n+ */\n+public class LogOutputStream\n+\textends ByteArrayOutputStream\n+{\n+\tprivate static final String _sep = System.getProperty (\"line.separator\");\n+\n+\tprivate final int _level;\n+\tprivate final Log _log;\n+\n+\t\n+\t/**\n+\t *\tConstructor.\n+\t *\t\n+\t *\t@param\tlog\t\tthe log to log to\n+\t *\t@param\tlevel\tthe level to log at\n+\t */\n+\tpublic LogOutputStream (Log log, int level)\n+\t{\n+\t\t_log = log;\n+\t\t_level = level;\n+\t}\n+\t\n+\t\n+\tpublic void flush ()\n+\t\tthrows IOException\n+\t{\n+\t\tsuper.flush ();\n+\n+\t\tString msg = new String (toByteArray ());\n+\t\tif (msg != null && msg.length () > 0 && msg.indexOf (_sep) != -1)\n+\t\t{\n+\t\t\t// break up the message based on the line separator; this\n+\t\t\t// may be because the flushed buffer contains mutliple lines\n+\t\t\tfor (StringTokenizer tok = new StringTokenizer (msg, _sep);\n+\t\t\t\ttok.hasMoreTokens (); )\n+\t\t\t{\n+\t\t\t\tString next = tok.nextToken ();\n+\t\t\t\tlog (next);\n+\t\t\t}\n+\n+\t\t\t// clear the internally held byte array\n+\t\t\treset ();\n+\t\t}\n+\t}\n+\n+\n+\tprivate void log (String msg)\n+\t{\n+\t\tswitch (_level)\n+\t\t{\n+\t\tcase Log.TRACE:\n+\t\t\t_log.trace (msg);\n+\t\t\tbreak;\n+\t\tcase Log.DEBUG:\n+\t\t\t_log.debug (msg);\n+\t\t\tbreak;\n+\t\tcase Log.INFO:\n+\t\t\t_log.info (msg);\n+\t\t\tbreak;\n+\t\tcase Log.WARN:\n+\t\t\t_log.warn (msg);\n+\t\t\tbreak;\n+\t\tcase Log.ERROR:\n+\t\t\t_log.error (msg);\n+\t\t\tbreak;\n+\t\tcase Log.FATAL:\n+\t\t\t_log.fatal (msg);\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+}\n+"},{"sha":"29290ef657425aff3909b3f9020ecd9c17b2a328","filename":"openjpa-lib/java/org/apache/openjpa/lib/log/MultiLogFactory.java","status":"added","additions":266,"deletions":0,"changes":266,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/MultiLogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/MultiLogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/log/MultiLogFactory.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.log;\n+\n+import java.util.*;\n+\n+\n+/**\n+ * \tA LogFactory implementation to pass events through multiple\n+ * \tLogFactory implementations (such as log4j and LogPanelFactory).\n+ * \n+ * \t@author Steve Kim\n+ */\n+public class MultiLogFactory \n+\timplements LogFactory\n+{\n+\tprivate List _delegates;\n+\t\n+\t\n+\t/**\n+\t * create an instance with two delegates\n+\t */ \n+\tpublic MultiLogFactory (LogFactory d1, LogFactory d2)\n+\t{\n+\t\tthis (new LogFactory [] { d1, d2 });\n+\t}\n+\n+\n+\tpublic MultiLogFactory (LogFactory d1, LogFactory d2, LogFactory d3)\n+\t{\n+\t\tthis (new LogFactory [] { d1, d2, d3 });\n+\t}\n+\n+\t\n+\t/**\n+\t * create an instance with the given delegates\n+\t */\n+\tpublic MultiLogFactory (LogFactory [] delegates)\n+\t{\n+\t\t_delegates = new LinkedList (Arrays.asList (delegates));;\n+\t}\n+\n+\n+\tpublic synchronized void addLogFactory (LogFactory factory)\n+\t{\n+\t\t_delegates.add (factory);\n+\t}\n+\n+\n+\tpublic synchronized void removeLogFactory (LogFactory factory)\n+\t{\n+\t\t_delegates.remove (factory);\n+\t}\n+\n+\t\n+\t/**\n+\t *\tReturns the delegates that this MultiLogFactory delegates\n+\t *\tmessages to.\n+\t */\n+\tpublic synchronized LogFactory[] getDelegates ()\n+\t{\n+\t\treturn (LogFactory[])_delegates.toArray (new LogFactory[0]);\n+\t}\n+\n+\n+\t/**\n+\t * returns a Log impl that combines all logs.\n+\t */\n+\tpublic synchronized Log getLog (String channel)\n+\t{\n+\t\tList logs = new ArrayList (_delegates.size ());\n+\t\tfor (Iterator i = _delegates.iterator (); i.hasNext (); )\n+\t\t{\n+\t\t\tLogFactory f = (LogFactory)i.next ();\n+\t\t\tif (f != null)\n+\t\t\t{\n+\t\t\t\tLog l = f.getLog (channel);\n+\t\t\t\tif (l != null)\n+\t\t\t\t\tlogs.add (l);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new MultiLog ((Log[])logs.toArray (new Log[logs.size ()]));\n+\t}\n+\n+\n+\t/**\n+\t * Combinatory Log impl.\n+\t */\n+\tprivate static class MultiLog implements Log\n+\t{\n+\t\tprivate Log[] _logs;\n+\n+\t\tpublic MultiLog (Log[] logs)\n+\t\t{\n+\t\t\t_logs = logs;\n+\t\t}\n+\n+\n+\t\t/**\n+\t\t *\tReturn the logs that this log delegates to.\n+\t\t */\n+\t\tpublic Log[] getDelegates ()\n+\t\t{\n+\t\t\treturn _logs;\n+\t\t}\n+\n+\n+\t\tpublic void trace (Object msg)\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\t_logs[i].trace (msg);\n+\t\t}\n+\n+\t\t\n+\t\tpublic void trace (Object msg, Throwable t)\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\t_logs[i].trace (msg, t);\n+\t\t}\n+\n+\t\t\n+\t\tpublic void info (Object msg)\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\t_logs[i].info (msg);\n+\t\t}\n+\n+\t\t\n+\t\tpublic void info (Object msg, Throwable t)\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\t_logs[i].info (msg, t);\n+\t\t}\n+\n+\t\t\n+\t\tpublic void debug (Object msg)\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\t_logs[i].debug (msg);\n+\t\t}\n+\n+\t\t\n+\t\tpublic void debug (Object msg, Throwable t)\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\t_logs[i].debug (msg, t);\n+\t\t}\n+\n+\t\t\n+\t\tpublic void warn (Object msg)\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\t_logs[i].warn (msg);\n+\t\t}\n+\n+\t\t\n+\t\tpublic void warn (Object msg, Throwable t)\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\t_logs[i].warn (msg, t);\n+\t\t}\n+\n+\t\t\n+\t\tpublic void error (Object msg)\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\t_logs[i].error (msg);\n+\t\t}\n+\n+\t\t\n+\t\tpublic void error (Object msg, Throwable t)\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\t_logs[i].error (msg, t);\n+\t\t}\n+\t\t\n+\n+\t\tpublic void fatal (Object msg)\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\t_logs[i].fatal (msg);\n+\t\t}\n+\n+\t\t\n+\t\tpublic void fatal (Object msg, Throwable t)\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\t_logs[i].fatal (msg, t);\n+\t\t}\n+\n+\t\t\n+\t\tpublic boolean isTraceEnabled ()\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\tif (_logs[i].isTraceEnabled ())\n+\t\t\t\t\treturn true;\n+\n+\t\t\treturn false;\n+\t\t}\n+\n+\n+\t\tpublic boolean isInfoEnabled ()\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\tif (_logs[i].isInfoEnabled ())\n+\t\t\t\t\treturn true;\n+\n+\t\t\treturn false;\n+\t\t}\n+\n+\n+\t\tpublic boolean isWarnEnabled ()\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\tif (_logs[i].isWarnEnabled ())\n+\t\t\t\t\treturn true;\n+\n+\t\t\treturn false;\n+\t\t}\n+\n+\n+\t\tpublic boolean isDebugEnabled ()\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\tif (_logs[i].isDebugEnabled ())\n+\t\t\t\t\treturn true;\n+\n+\t\t\treturn false;\n+\t\t}\n+\n+\n+\n+\t\tpublic boolean isErrorEnabled ()\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\tif (_logs[i].isErrorEnabled ())\n+\t\t\t\t\treturn true;\n+\n+\t\t\treturn false;\n+\t\t}\n+\n+\n+\t\tpublic boolean isFatalEnabled ()\n+\t\t{\n+\t\t\tfor (int i = 0; i < _logs.length; i++)\n+\t\t\t\tif (_logs[i].isFatalEnabled ())\n+\t\t\t\t\treturn true;\n+\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+}"},{"sha":"91bae6e3dcf12ef063eef9cc55c5ac4b823c9542","filename":"openjpa-lib/java/org/apache/openjpa/lib/log/NoneLogFactory.java","status":"added","additions":145,"deletions":0,"changes":145,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/NoneLogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/NoneLogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/log/NoneLogFactory.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.log;\n+\n+\n+/**\n+ *\tA log factory implementation that does not do any logging, as\n+ *\tquickly as possible.\n+ *\n+ *\t@author\tPatrick Linskey\n+ */\n+public class NoneLogFactory\n+\timplements LogFactory\n+{\n+\tpublic final Log getLog (String channel)\n+\t{\n+\t\treturn NoneLog.getInstance ();\n+\t}\n+\n+\n+\t/**\n+\t *\tNo-op log.\n+\t */\n+\tpublic static class NoneLog\n+\t\timplements Log\n+\t{\n+\t\tprivate static final NoneLog s_log = new NoneLog ();\n+\n+\n+\t\tpublic static NoneLog getInstance ()\n+\t\t{\n+\t\t\treturn s_log;\n+\t\t}\n+\n+\n+\t\tpublic final boolean isDebugEnabled ()\n+\t\t{\n+\t\t\treturn false;\n+\t\t}\n+\n+\n+\t\tpublic final boolean isErrorEnabled ()\n+\t\t{\n+\t\t\treturn false;\n+\t\t}\n+\n+\n+\t\tpublic final boolean isFatalEnabled ()\n+\t\t{\n+\t\t\treturn false;\n+\t\t}\n+\n+\n+\t\tpublic final boolean isInfoEnabled ()\n+\t\t{\n+\t\t\treturn false;\n+\t\t}\n+\n+\n+\t\tpublic final boolean isTraceEnabled ()\n+\t\t{\n+\t\t\treturn false;\n+\t\t}\n+\n+\n+\t\tpublic final boolean isWarnEnabled ()\n+\t\t{\n+\t\t\treturn false;\n+\t\t}\n+\n+\n+\t\tpublic final void trace (Object o)\n+\t\t{\n+\t\t}\n+\n+\n+\t\tpublic final void trace (Object o, Throwable t)\n+\t\t{\n+\t\t}\n+\n+\n+\t\tpublic final void debug (Object o)\n+\t\t{\n+\t\t}\n+\n+\n+\t\tpublic final void debug (Object o, Throwable t)\n+\t\t{\n+\t\t}\n+\n+\n+\t\tpublic final void info (Object o)\n+\t\t{\n+\t\t}\n+\n+\n+\t\tpublic final void info (Object o, Throwable t)\n+\t\t{\n+\t\t}\n+\n+\n+\t\tpublic final void warn (Object o)\n+\t\t{\n+\t\t}\n+\n+\n+\t\tpublic final void warn (Object o, Throwable t)\n+\t\t{\n+\t\t}\n+\n+\n+\t\tpublic final void error (Object o)\n+\t\t{\n+\t\t}\n+\n+\n+\t\tpublic final void error (Object o, Throwable t)\n+\t\t{\n+\t\t}\n+\n+\n+\t\tpublic final void fatal (Object o)\n+\t\t{\n+\t\t}\n+\n+\n+\t\tpublic final void fatal (Object o, Throwable t)\n+\t\t{\n+\t\t}\n+\t}\n+}\n+"},{"sha":"dabb3ac8315b2bf96ea1f67d787032d652cad6f6","filename":"openjpa-lib/java/org/apache/openjpa/lib/log/package.html","status":"added","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/package.html","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/log/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/log/package.html?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,26 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+<html>\n+<body>\n+\t<p><strong>Logging</strong></p>\n+\t<p>\n+\t\tThis package provides a lightweight logging interface, a simple\n+\t\timplementation that writes logging output to the console and\n+\t\tallows for basic log configuration, and plug-ins for the Apache\n+\t\tCommons Logging and the Apache Log4J frameworks.\n+\t</p>\n+</body>\n+</html>"},{"sha":"d9200498d484da883fc2516f74bc1df5ffbcea72","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/CFMetaDataParser.java","status":"added","additions":410,"deletions":0,"changes":410,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/CFMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/CFMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/CFMetaDataParser.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import org.xml.sax.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+\n+import serp.util.*;\n+\n+\n+/**\n+ *\t<p>Custom SAX parser used by the system to quickly parse metadata files \n+ *\tfor classes.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public class CFMetaDataParser\n+\textends XMLMetaDataParser\n+{\n+\tstatic final String[] PACKAGES = new String[] {\n+\t\t\"java.lang.\", \"java.util.\", \"java.math.\"\n+\t};\n+\tprivate static final Localizer _loc = Localizer.forPackage \n+\t\t(CFMetaDataParser.class);\n+\n+\t// the current package and class being parsed\n+\tprivate String _package\t= null;\n+\tprivate String _class\t= null;\n+\n+\n+\tpublic CFMetaDataParser ()\n+\t{\n+\t\tsetParseText (false);\n+\t}\n+\n+\n+\t/**\n+\t *\tThe name of the package element.  Defaults to \"package\".\n+\t */\n+\tprotected boolean isPackageElementName (String name)\n+\t{\n+\t\treturn \"package\".equals (name);\n+\t}\n+\n+\n+\t/**\n+\t *\tThe attribute of the package element that holds the name, or null to\n+\t *\tuse the element text.  Defaults to \"name\".\n+\t */\n+\tprotected String getPackageAttributeName ()\n+\t{\n+\t\treturn \"name\";\n+\t}\n+\n+\n+\t/**\n+\t *\tThe depth of the package element.  Defaults to 1.\n+\t */\n+\tprotected int getPackageElementDepth ()\n+\t{\n+\t\treturn 1;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe name of the class element.  Defaults to \"class\".\n+\t */\n+\tprotected boolean isClassElementName (String name)\n+\t{\n+\t\treturn \"class\".equals (name);\n+\t}\n+\n+\n+\t/**\n+\t *\tThe attribute of the class element that holds the name, or null to\n+\t *\tuse the element text.  Defaults to \"name\".\n+\t */\n+\tprotected String getClassAttributeName ()\n+\t{\n+\t\treturn \"name\";\n+\t}\n+\n+\n+\t/**\n+\t *\tThe depth of the class element.  Defaults to 2.\n+\t */\n+\tprotected int getClassElementDepth ()\n+\t{\n+\t\treturn 2;\n+\t}\n+\n+\n+\tprotected boolean startElement (String name, Attributes attrs)\n+\t\tthrows SAXException\n+\t{\n+\t\t// skip root element\n+\t\tint depth = currentDepth ();\n+\t\tif (depth == 0)\n+\t\t\treturn true;\n+\n+\t\ttry\n+\t\t{\n+\t\t\tif (depth == getPackageElementDepth ()\n+\t\t\t\t&& isPackageElementName (name))\n+\t\t\t\treturn startPackage (name, attrs);\n+\t\t\tif (depth == getClassElementDepth () && isClassElementName (name))\n+\t\t\t\treturn startClass (name, attrs);\n+\t\t\tif (depth > getClassElementDepth () && _class != null \n+\t\t\t\t&& getClassAttributeName () != null)\n+\t\t\t\treturn startClassElement (name, attrs);\n+\t\t\tif (depth > getPackageElementDepth () && _package != null \n+\t\t\t\t&& getPackageAttributeName () != null)\n+\t\t\t\treturn startPackageElement (name, attrs);\n+\t\t\treturn startSystemElement (name, attrs);\n+\t\t}\n+\t\tcatch (SAXException se)\n+\t\t{\n+\t\t\tthrow se;\n+\t\t}\n+\t\tcatch (NullPointerException npe)\n+\t\t{\n+\t\t\tthrow getException (_loc.get (\"parse-error\", name), npe);\n+\t\t}\n+\t}\n+\t\n+\n+\tprotected void endElement (String name)\n+\t\tthrows SAXException\n+\t{\n+\t\t// skip root element\n+\t\tint depth = currentDepth ();\n+\t\tif (depth == 0)\n+\t\t\treturn;\n+\n+\t\ttry\n+\t\t{\n+\t\t\tif (depth == getPackageElementDepth () \n+\t\t\t\t&& isPackageElementName (name))\n+\t\t\t\tendPackage (name);\n+\t\t\telse if (depth == getClassElementDepth () \n+\t\t\t\t&& isClassElementName (name))\n+\t\t\t\tendClass (name);\n+\t\t\telse if (depth > getClassElementDepth () && _class != null \n+\t\t\t\t&& getClassAttributeName () != null) \n+\t\t\t\tendClassElement (name);\n+\t\t\telse if (depth > getPackageElementDepth () && _package != null \n+\t\t\t\t&& getPackageAttributeName () != null)\n+\t\t\t\tendPackageElement (name);\n+\t\t\telse\n+\t\t\t\tendSystemElement (name);\n+\t\t}\n+\t\tcatch (SAXException se)\n+\t\t{\n+\t\t\tthrow se;\n+\t\t}\n+\t\tcatch (NullPointerException npe)\n+\t\t{\n+\t\t\tthrow getException (_loc.get (\"parse-error\", name), npe);\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tStart a package.  Parses out package attribute by default.\n+\t *\tReturn false to skip package element and its contents.\n+\t */\n+\tprotected boolean startPackage (String elem, Attributes attrs)\n+\t\tthrows SAXException\n+\t{\n+\t\tif (getPackageAttributeName () != null)\n+\t\t{\n+\t\t\t_package = attrs.getValue (getPackageAttributeName ());\n+\t\t\tif (_package == null)\n+\t\t\t\t_package = \"\";\n+\t\t}\n+\t\treturn true;\t\n+\t}\n+\n+\n+\t/**\n+\t *\tEnd a package.  Parses contained text by default.\n+\t */\n+\tprotected void endPackage (String elem)\n+\t{\n+\t\tif (getPackageAttributeName () != null)\n+\t\t\t_package = null;\n+\t\telse\n+\t\t\t_package = currentText ();\n+\t}\n+\n+\n+\t/**\n+\t *\tStart a class.  Parses out class name by default.  Return \n+\t *\tfalse to skip class element and its contents. \n+\t */\n+\tprotected boolean startClass (String elem, Attributes attrs)\n+\t\tthrows SAXException\n+\t{\n+\t\tif (getClassAttributeName () != null)\n+\t\t{\n+\t\t\t_class = attrs.getValue (getClassAttributeName ());\n+\t\t\tif (_package != null && _package.length () > 0 \n+\t\t\t\t&& _class.indexOf ('.') == -1)\n+\t\t\t\t_class = _package + \".\" + _class;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\n+\t/**\n+\t *\tEnd a class.  Parses contained text by default.\n+\t */\n+\tprotected void endClass (String elem)\n+\t\tthrows SAXException\n+\t{\n+\t\tif (getClassAttributeName () != null)\n+\t\t\t_class = null;\n+\t\telse\n+\t\t{\n+\t\t\t_class = currentText ();\n+\t\t\tif (_package != null && _package.length () > 0 \n+\t\t\t\t&& _class.indexOf ('.') == -1)\n+\t\t\t\t_class = _package + \".\" + _class;\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tOverride this method marking the start of an element outside of any\n+\t *\tpackage or class.\n+\t */\n+\tprotected boolean startSystemElement (String name, Attributes attrs)\n+\t\tthrows SAXException\n+\t{\n+\t\treturn false;\n+\t}\n+\n+\n+\t/**\n+\t *\tOverride this method marking the end of an element outside of any\n+\t *\tpackage or class.\n+\t */\n+\tprotected void endSystemElement (String name)\n+\t\tthrows SAXException\n+\t{\n+\t}\n+\n+\n+\t/**\n+\t *\tOverride this method marking the start of an element within a declared\n+\t *\tpackage.\n+\t */\n+\tprotected boolean startPackageElement (String name, Attributes attrs)\n+\t\tthrows SAXException\n+\t{\n+\t\treturn false;\n+\t}\n+\n+\n+\t/**\n+\t *\tOverride this method marking the end of an element within a declared \n+\t *\tpackage.\n+\t */\n+\tprotected void endPackageElement (String name)\n+\t\tthrows SAXException\n+\t{\n+\t}\n+\n+\n+\t/**\n+\t *\tOverride this method marking the start of an element within a declared \n+\t *\tclass.\n+\t */\n+\tprotected boolean startClassElement (String name, Attributes attrs)\n+\t\tthrows SAXException\n+\t{\n+\t\treturn false;\n+\t}\n+\n+\n+\t/**\n+\t *\tOverride this method marking the end of an element within a declared \n+\t *\tclass.\n+\t */\n+\tprotected void endClassElement (String name)\n+\t\tthrows SAXException\n+\t{\n+\t}\n+\n+\n+\t/**\n+\t *\tOverride this method to clear any state and ready the parser for\n+\t *\ta new document.  Subclasses should call \n+\t *\t<code>super.reset ()</code> to clear superclass state.\n+\t */\n+\tprotected void reset ()\n+\t{\n+\t\tsuper.reset ();\n+\t\t_package = null;\n+\t\t_class = null;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the current class being parsed; the returned name will\n+\t *\tbe fully qualified.\n+\t */\n+\tprotected String currentClassName ()\n+\t{\n+\t\treturn _class;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the current package being parsed.\n+\t */\n+\tprotected String currentPackage ()\n+\t{\n+\t\treturn _package;\n+\t}\n+\n+\n+\t/**\n+\t *\tHelper method to create the {@link Class} for the given name, \n+\t *\ttaking into account the package currently being parsed for relative\n+\t *\tclass names.\n+\t */\n+\tprotected Class classForName (String name, boolean resolve)\n+\t\tthrows SAXException\n+\t{\n+\t\tif (name == null)\n+\t\t\treturn null;\n+\t\tClass cls = classForName (name, _package, resolve, \n+\t\t\tcurrentClassLoader ());\n+\t\tif (cls == null)\n+\t\t\tthrow getException (_loc.get (\"invalid-class\", name));\n+\t\treturn cls;\n+\t}\n+\n+\n+\t/**\n+ \t *\tLoad the given class name against the given package and the set\n+\t *\tof accepted standard packages.  Return null if the class cannot be\n+\t *\tloaded.\n+\t */\n+\tpublic static Class classForName (String name, String pkg, \n+\t\tboolean resolve, ClassLoader loader)\n+\t{\n+\t\tif (name == null || name.length () == 0)\n+\t\t\treturn null;\n+\n+\t\tif (loader == null)\n+\t\t\tloader = Thread.currentThread ().getContextClassLoader ();\n+\t\tboolean fullName = name.indexOf ('.') != -1;\n+\t\tboolean noPackage = pkg == null || pkg.length () == 0;\n+\t\ttry\n+\t\t{\n+\t\t\tif (fullName || noPackage)\n+\t\t\t\treturn Strings.toClass (name, resolve, loader);\n+\t\t\treturn Strings.toClass (pkg + \".\" + name, resolve, loader);\n+\t\t}\n+\t\tcatch (RuntimeException re)\n+\t\t{\n+\t\t}\n+\n+\t\t// if not a full name, now try the name without a package\n+\t\tif (!fullName && !noPackage)\n+\t\t{\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\treturn Strings.toClass (name, resolve, loader);\n+\t\t\t}\n+\t\t\tcatch (RuntimeException re)\n+\t\t\t{\n+\t\t\t}\n+\t\t}\n+\n+\t\t// try with standard packages\n+\t\tif (!fullName)\n+\t\t{\t\n+\t\t\tfor (int i = 0; i < PACKAGES.length; i++)\n+\t\t\t{\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\treturn Strings.toClass(PACKAGES[i] + name, resolve, loader);\n+\t\t\t\t}\n+\t\t\t\tcatch (RuntimeException re)\n+\t\t\t\t{\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+}"},{"sha":"5cec47844013b8489bfaa47f92c556c06f901526","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/CFMetaDataSerializer.java","status":"added","additions":116,"deletions":0,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/CFMetaDataSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/CFMetaDataSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/CFMetaDataSerializer.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.util.*;\n+\n+import org.apache.commons.collections.map.*;\n+import org.xml.sax.*;\n+\n+\n+/**\n+ *\t<p>Helps serialize metadata objects to package and class elements.</p>\n+ *\n+ *\t@see\tCFMetaDataParser\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public abstract class CFMetaDataSerializer\n+\textends XMLMetaDataSerializer\n+{\n+\tprivate String _package = null;\n+\n+\n+\t/**\n+\t *\tThe default package for objects being serialized. \n+\t */\n+\tprotected String getPackage ()\n+\t{\n+\t\treturn _package;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe default package for objects being serialized. \n+\t */\n+\tprotected void setPackage (String pkg)\n+\t{\n+\t\t_package = pkg;\n+\t}\n+\n+\n+\t/**\n+\t *\tHelper method to group objects by package.\n+\t *\n+\t *\t@return\t\tmapping of package name to a collection of objects in\n+\t *\t\t\t\tthat package\n+\t */\n+\tprotected Map groupByPackage (Collection objs)\n+\t\tthrows SAXException\n+\t{\n+\t\tMap packages = new LinkedMap ();\n+\t\tString packageName;\n+\t\tCollection packageObjs;\n+\t\tObject obj;\n+\t\tfor (Iterator itr = objs.iterator (); itr.hasNext ();)\n+\t\t{\n+\t\t\tobj = itr.next ();\n+\t\t\tpackageName = getPackage (obj);\n+\t\t\tpackageObjs = (Collection) packages.get (packageName);\n+\t\t\tif (packageObjs == null)\n+\t\t\t{\n+\t\t\t\tpackageObjs = new LinkedList ();\n+\t\t\t\tpackages.put (packageName, packageObjs);\n+\t\t\t}\n+\t\t\tpackageObjs.add (obj);\n+\t\t}\n+\t\treturn packages;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the package name of the given object, or null if not in a \n+\t *\tpackage.  Used by {@link #groupByPackage}.  Returns null by default.\n+\t */\n+\tprotected String getPackage (Object obj)\n+\t{\n+\t\treturn null;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturns the given class name, stripping the package if it is not\n+\t *\tneeded.\n+\t */\n+\tprotected String getClassName (String name)\n+\t{\n+\t\t// check if in current package; make sure not in a sub-package\n+\t\tif (_package != null \n+\t\t\t&& name.lastIndexOf ('.') == _package.length ()\n+\t\t\t&& name.startsWith (_package))\n+\t\t\treturn name.substring (_package.length () + 1);\n+\n+\t\t// check other known packages\n+\t\tString[] packages = CFMetaDataParser.PACKAGES;\n+\t\tfor (int i = 0; i < packages.length; i++)\n+\t\t\tif (name.startsWith (packages[i]) \n+\t\t\t\t&& name.lastIndexOf ('.') == packages[i].length () - 1)\n+\t\t\t\treturn name.substring (packages[i].length ());\n+\t\treturn name;\n+\t}\n+}"},{"sha":"79eb6161ddfaecd941e8858eea402df38fb2a059","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/ClassAnnotationMetaDataFilter.java","status":"added","additions":203,"deletions":0,"changes":203,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/ClassAnnotationMetaDataFilter.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/ClassAnnotationMetaDataFilter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/ClassAnnotationMetaDataFilter.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.io.*;\n+\n+import serp.bytecode.lowlevel.*;\n+\n+\n+/**\n+ *\t<p>Filter that looks for classes with one of a set of annotations.\n+ *\tSee JDK 1.5 JVM spec for details on annotation bytecode:<br />\n+ *\tjava.sun.com/docs/books/vmspec/2nd-edition/ClassFileFormat-final-draft.pdf\n+ *\t</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public class ClassAnnotationMetaDataFilter\n+\timplements MetaDataFilter\n+{\n+\tprivate final String[] _annos;\n+\n+\n+\t/**\n+\t *\tConstructor; supply annotation to match against.\n+\t */\n+\tpublic ClassAnnotationMetaDataFilter (Class anno)\n+\t{\n+\t\tthis (new Class[] { anno });\n+\t}\n+\n+\n+\t/**\n+\t *\tConstructor; supply annotations to match against.\n+\t */\n+\tpublic ClassAnnotationMetaDataFilter (Class[] annos)\n+\t{\n+\t\t_annos = new String[annos.length];\n+\t\tfor (int i = 0; i < annos.length; i++)\n+\t\t\t_annos[i] = \"L\" + annos[i].getName ().replace ('.', '/') + \";\";\n+\t}\n+\n+\n+\tpublic boolean matches (Resource rsrc)\n+\t\tthrows IOException\n+\t{\n+\t\tif (_annos.length == 0 || !rsrc.getName ().endsWith (\".class\"))\n+\t\t\treturn false;\n+\n+\t\tConstantPoolTable table = new ConstantPoolTable (rsrc.getContent ());\n+\t\tint idx = table.getEndIndex ();\n+\t\tidx += 6; // skip access, cls, super\n+\n+\t\t// skip interfaces\n+\t\tint interfaces = table.readUnsignedShort (idx);\n+\t\tidx += 2 + interfaces * 2;\n+\n+\t\t// skip fields and methods\n+\t\tint fields = table.readUnsignedShort (idx); \n+\t\tidx += 2;\n+\t\tfor (int i = 0; i < fields; i++)\n+\t\t\tidx += skipFieldOrMethod (table, idx);\n+\t\tint methods = table.readUnsignedShort (idx);\n+\t\tidx += 2;\n+\t\tfor (int i = 0; i < methods; i++)\n+\t\t\tidx += skipFieldOrMethod (table, idx);\t\n+\n+\t\t// look for annotation attrs\n+\t\tint attrs = table.readUnsignedShort (idx);\n+\t\tidx += 2;\n+\t\tint name;\n+\t\tfor (int i = 0; i < attrs; i++)\n+\t\t{\n+\t\t\tname = table.readUnsignedShort (idx);\n+\t\t\tidx += 2;\n+\t\t\tif (\"RuntimeVisibleAnnotations\".equals (table.readString \n+\t\t\t\t(table.get (name))))\t\n+\t\t\t\treturn matchAnnotations (table, idx + 4);\n+\t\t\tidx += 4 + table.readInt (idx);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn whether the given annotations match our candidates.\n+\t */\n+\tprivate boolean matchAnnotations (ConstantPoolTable table, int idx)\n+\t{\n+\t\tint annos = table.readUnsignedShort (idx);\n+\t\tidx += 2;\n+\n+\t\tint type;\n+\t\tint props;\n+\t\tfor (int i = 0; i < annos; i++)\n+\t\t{\n+\t\t\ttype = table.readUnsignedShort (idx);\n+\t\t\tidx += 2;\n+\t\t\tif (matchAnnotation (table.readString (table.get (type))))\n+\t\t\t\treturn true;\n+\n+\t\t\tprops = table.readUnsignedShort (idx);\t\n+\t\t\tidx += 2;\n+\t\t\tfor (int j = 0; j < props; j++)\n+\t\t\t{\n+\t\t\t\tidx += 2; // name\n+\t\t\t\tidx += skipAnnotationPropertyValue (table, idx);\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn whether the given annotation matches our candidates.\n+\t */\n+\tprivate boolean matchAnnotation (String name)\n+\t{\n+\t\tfor (int i = 0; i < _annos.length; i++)\n+\t\t\tif (name.equals (_annos[i]))\n+\t\t\t\treturn true;\n+\t\treturn false;\n+\t}\n+\n+\n+\t/**\n+\t *\tSkip an annotation property value, returning the number of bytes \n+\t *\tskipped.\n+\t */\n+\tprivate static int skipAnnotationPropertyValue (ConstantPoolTable table, \n+\t\tint idx)\n+\t{\n+\t\tint skipped = 0;\n+\t\tswitch (table.readByte (idx + skipped++)) // value type\n+\t\t{\n+\t\tcase 'Z': // bool\n+\t\tcase 'B': // byte\n+\t\tcase 'C': // char\n+\t\tcase 'D': // double\n+\t\tcase 'F': // float\n+\t\tcase 'I': // int\n+\t\tcase 'J': // long\n+\t\tcase 'S': // short\n+\t\tcase 's': // string\n+\t\tcase 'c': // class\n+\t\t\tskipped += 2;\n+\t\t\tbreak;\n+\t\tcase 'e': // enum ptr\n+\t\t\tskipped += 4;\n+\t\t\tbreak;\n+\t\tcase '[': // array\n+\t\t\tint size = table.readUnsignedShort (idx + skipped);\n+\t\t\tskipped += 2;\n+\t\t\tfor (int i = 0; i < size; i++)\n+\t\t\t\tskipped += skipAnnotationPropertyValue (table, idx + skipped);\n+\t\t\tbreak;\n+\t\tcase '@': // anno\n+\t\t\tskipped += 2; // type\n+\t\t\tint props = table.readUnsignedShort (idx + skipped);\t\n+\t\t\tskipped += 2;\n+\t\t\tfor (int j = 0; j < props; j++)\n+\t\t\t{\n+\t\t\t\tskipped += 2; // name\n+\t\t\t\tskipped += skipAnnotationPropertyValue (table, \n+\t\t\t\t\tidx + skipped);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\treturn skipped;\n+\t}\n+\n+\n+\t/**\n+\t *\tSkip the current field or method, returning the number of bytes skipped.\n+\t */\n+\tprivate static int skipFieldOrMethod (ConstantPoolTable table, int idx)\n+\t{\n+\t\tint attrs = table.readUnsignedShort (idx + 6);\n+\t\tint skipped = 8;\n+\t\tint len;\n+\t\tfor (int i = 0; i < attrs; i++)\n+\t\t{\n+\t\t\tlen = table.readInt (idx + skipped + 2);\n+\t\t\tskipped += 6 + len;\n+\t\t}\n+\t\treturn skipped;\n+\t}\n+}"},{"sha":"a3550cc7907a14b8307e702b8af6dd6fc954db17","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/ClassArgParser.java","status":"added","additions":696,"deletions":0,"changes":696,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/ClassArgParser.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/ClassArgParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/ClassArgParser.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,696 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import org.apache.commons.lang.exception.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+\n+import serp.bytecode.lowlevel.*;\n+import serp.util.*;\n+\n+\n+/**\n+ *\t<p>Parser used to resolve arguments into java classes.\n+ *\tInterprets command-line args as either class names, .class files or \n+ *\tresources, .java files or resources, or metadata files or resources \n+ *\tconforming to the common format defined by {@link CFMetaDataParser}.\n+ *\tTransforms the information in these args into {@link Class} instances.</p>\n+ *\n+ *\t<p>Note that when parsing .java files, only the main class in the file\n+ *\tis detected.  Other classes defined in the file, such as inner classes,\n+ *\tare not added to the returned classes list.</p>\n+ *\n+ *\t@author\tAbe White\n+ *\t@nojavadoc\n+ */\n+public class ClassArgParser\n+{\n+\tprivate static final int TOKEN_EOF\t \t\t\t= -1;\n+\tprivate static final int TOKEN_NONE \t\t\t= 0;\n+\tprivate static final int TOKEN_PACKAGE\t\t\t= 1;\n+\tprivate static final int TOKEN_CLASS \t\t\t= 2;\n+\tprivate static final int TOKEN_PACKAGE_NOATTR\t= 3;\n+\tprivate static final int TOKEN_CLASS_NOATTR\t\t= 4;\n+\n+\tprivate static final Localizer _loc = Localizer.forPackage \n+\t\t(ClassArgParser.class);\n+\n+\tprivate ClassLoader _loader \t\t\t= null;\n+\tprivate char[]\t\t_packageAttr\t\t= \"name\".toCharArray ();\n+\tprivate char[]\t\t_classAttr\t\t\t= \"name\".toCharArray ();\n+\tprivate char[][]\t_beginElements\t\t= { { 'p' }, { 'c' } };\n+\tprivate char[][] \t_endElements\t\t= { \"ackage\".toCharArray (),\n+\t\t\t\t\t\t\t\t\t\t\t\t\"lass\".toCharArray () };\n+\n+\t/**\n+\t *\tThe class loader with which to load parsed classes.\n+\t */\n+\tpublic ClassLoader getClassLoader ()\n+\t{\n+\t\treturn _loader;\n+\t}\n+\n+\t\n+\t/**\n+\t *\tThe class loader with which to load parsed classes.\n+\t */\n+\tpublic void setClassLoader (ClassLoader loader)\n+\t{\n+\t\t_loader = loader;\n+\t}\n+\n+\n+\t/**\n+\t *\tSet the the relevant metadata file structure so that metadata files\n+\t *\tcontaining class names can be parsed.  Null attribute names indicate\n+\t *\tthat the text content of the element contains the data.\n+\t */\n+\tpublic void setMetaDataStructure (String packageElementName, \n+\t\tString packageAttributeName, String[] classElementNames, \n+\t\tString classAttributeName)\n+\t{\n+\t\t// calculate how many chars deep we have to go to identify each element\n+\t\t// name as unique.  this is extremely inefficient for large N, but \n+\t\t// should never be called for more than a few elements\n+\t\tchar[] buf = new char[classElementNames.length + 1];\n+\t\tint charIdx = 0;\n+\t\tfor (; true; charIdx++)\n+\t\t{\n+\t\t\tfor (int i = 0; i < buf.length; i++)\n+\t\t\t{\n+\t\t\t\tif (i == 0)\n+\t\t\t\t{\n+\t\t\t\t\tif (charIdx == packageElementName.length ())\n+\t\t\t\t\t\tthrow new UnsupportedOperationException (_loc.get \n+\t\t\t\t\t\t\t(\"cant-diff-elems\"));\n+\t\t\t\t\tbuf[i] = packageElementName.charAt (charIdx);\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\tif (charIdx == classElementNames[i - 1].length ())\n+\t\t\t\t\t\tthrow new UnsupportedOperationException (_loc.get \n+\t\t\t\t\t\t\t(\"cant-diff-elems\"));\n+\t\t\t\t\tbuf[i] = classElementNames[i - 1].charAt (charIdx);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (charsUnique (buf))\n+\t\t\t\tbreak;\n+\t\t}\n+\n+\t\t_packageAttr = (packageAttributeName == null) ? null \n+\t\t\t: packageAttributeName.toCharArray ();\n+\t\t_classAttr = (classAttributeName == null) ? null \n+\t\t\t: classAttributeName.toCharArray ();\n+\t\t_beginElements = new char[classElementNames.length + 1][];\n+\t\t_endElements = new char[classElementNames.length + 1][];\n+\t\t_beginElements[0] = packageElementName.substring (0, charIdx + 1).\n+\t\t\ttoCharArray ();\n+\t\t_endElements[0] = packageElementName.substring (charIdx + 1).\n+\t\t\ttoCharArray ();\n+\t\tfor (int i = 0; i < classElementNames.length; i++)\n+\t\t{\n+\t\t\t_beginElements[i + 1] = classElementNames[i].\n+\t\t\t\tsubstring (0, charIdx + 1).toCharArray ();\n+\t\t\t_endElements[i + 1] = classElementNames[i].\n+\t\t\t\tsubstring (charIdx + 1).toCharArray ();\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn true if all characters in given buffer are unique.\n+\t */\n+\tprivate static boolean charsUnique (char[] buf)\n+\t{\n+\t\tfor (int i = buf.length - 1; i >= 0; i--)\n+\t\t\tfor (int j = 0; j < i; j++)\n+\t\t\t\tif (buf[j] == buf[i])\n+\t\t\t\t\treturn false;\n+\t\treturn true;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the {@link Class} representation of the class(es) named in the\n+\t *\tgiven arg.\n+\t *\n+ \t *\t@param\targ\t\ta class name, .java file, .class file, or metadata \n+\t *\t\t\t\t\tfile naming\tthe type(s) to act on\n+\t */\n+\tpublic Class[] parseTypes (String arg)\n+\t{\n+\t\tString[] names = parseTypeNames (arg);\n+\t\tClass[] objs = new Class[names.length];\n+\t\tfor (int i = 0; i < names.length; i++)\n+\t\t\tobjs[i] = Strings.toClass (names[i], _loader);\n+\t\treturn objs;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the {@link Class} representation of the class(es) named in the\n+\t *\tgiven metadatas.\n+\t */\n+\tpublic Class[] parseTypes (MetaDataIterator itr)\n+\t{\n+\t\tString[] names = parseTypeNames (itr);\n+\t\tClass[] objs = new Class[names.length];\n+\t\tfor (int i = 0; i < names.length; i++)\n+\t\t\tobjs[i] = Strings.toClass (names[i], _loader);\n+\t\treturn objs;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn a mapping of each metadata resource to an array of its \n+\t *\tcontained classes.\n+\t */\n+\tpublic Map mapTypes (MetaDataIterator itr)\n+\t{\n+\t\tMap map = mapTypeNames (itr);\n+\t\tMap.Entry entry;\n+\t\tString[] names;\n+\t\tClass[] objs;\n+\t\tfor (Iterator i = map.entrySet ().iterator (); i.hasNext ();)\n+\t\t{\n+\t\t\tentry = (Map.Entry) i.next ();\n+\t\t\tnames = (String[]) entry.getValue ();\n+\t\t\tobjs = new Class[names.length];\n+\t\t\tfor (int j = 0; j < names.length; j++)\n+\t\t\t\tobjs[j] = Strings.toClass (names[j], _loader);\n+\t\t\tentry.setValue (objs);\n+\t\t}\n+\t\treturn map;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the names of the class(es) from the given arg. \n+\t *\n+ \t *\t@param\targ\t\ta class name, .java file, .class file, or metadata \n+\t *\t\t\t\t\tfile naming\tthe type(s) to act on\n+\t *\t@throws\tIllegalArgumentException with appropriate message on error\n+\t */\n+\tpublic String[] parseTypeNames (String arg)\n+\t{\n+\t\tif (arg == null)\n+\t\t\treturn new String[0];\n+\n+\t\ttry\n+\t\t{\n+\t\t\tFile file = Files.getFile (arg, _loader);\n+\t\t\tif (arg.endsWith (\".class\"))\n+\t\t\t\treturn new String[] { getFromClassFile (file) };\n+\t\t\tif (arg.endsWith (\".java\"))\n+\t\t\t\treturn new String[] { getFromJavaFile (file) };\n+\t\t\tif (file.exists ())\n+\t\t\t{\n+\t\t\t\tCollection col = getFromMetaDataFile (file);\n+\t\t\t\treturn (String[]) col.toArray (new String[col.size ()]);\n+\t\t\t}\n+\t\t}\n+\t\tcatch (Exception e)\n+\t\t{\n+\t\t\tthrow new NestableRuntimeException (_loc.get (\"class-arg\", arg), e);\n+\t\t}\n+\n+\t\t// must be a class name\n+\t\treturn new String[] { arg };\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the names of the class(es) from the given metadatas. \n+\t */\n+\tpublic String[] parseTypeNames (MetaDataIterator itr)\n+\t{\n+\t\tif (itr == null)\n+\t\t\treturn new String[0];\n+\n+\t\tList names = new ArrayList ();\n+\t\tObject source = null;\n+\t\ttry\n+\t\t{\n+\t\t\twhile (itr.hasNext ())\n+\t\t\t{\n+\t\t\t\tsource = itr.next ();\n+\t\t\t\tappendTypeNames (source, itr.getInputStream (), names);\n+\t\t\t}\n+\t\t}\n+\t\tcatch (Exception e)\n+\t\t{\n+\t\t\tthrow new NestableRuntimeException (_loc.get (\"class-arg\", source),\n+\t\t\t\te); \n+\t\t}\n+\t\treturn (String[]) names.toArray (new String[names.size ()]);\t\n+\t}\n+\n+\n+\t/**\n+\t *\tParse the names in the given metadata iterator stream, closing the\n+\t *\tstream on completion.\n+\t */\n+\tprivate void appendTypeNames (Object source, InputStream in, List names)\n+\t\tthrows IOException\n+\t{\n+\t\ttry\n+\t\t{\n+\t\t\tif (source.toString ().endsWith (\".class\"))\n+\t\t\t\tnames.add (getFromClass (in));\t\t\t\n+\t\t\tnames.addAll (getFromMetaData (new InputStreamReader (in)));\n+\t\t}\n+\t\tfinally\n+\t\t{\n+\t\t\ttry { in.close (); } catch (IOException ioe) {}\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn a mapping of each metadata resource to an array of its contained\n+\t *\tclass names.\n+\t */\n+\tpublic Map mapTypeNames (MetaDataIterator itr)\n+\t{\n+\t\tif (itr == null)\n+\t\t\treturn Collections.EMPTY_MAP;\n+\n+\t\tMap map = new HashMap ();\n+\t\tObject source = null;\n+\t\tList names = new ArrayList ();\n+\t\ttry\n+\t\t{\n+\t\t\twhile (itr.hasNext ())\n+\t\t\t{\n+\t\t\t\tsource = itr.next ();\n+\t\t\t\tappendTypeNames (source, itr.getInputStream (), names);\n+\t\t\t\tif (!names.isEmpty ())\n+\t\t\t\t\tmap.put (source, (String[]) names.toArray \n+\t\t\t\t\t\t(new String[names.size ()]));\n+\t\t\t\tnames.clear ();\n+\t\t\t}\n+\t\t}\n+\t\tcatch (Exception e)\n+\t\t{\n+\t\t\tthrow new NestableRuntimeException (_loc.get (\"class-arg\", source),\n+\t\t\t\te); \n+\t\t}\n+\t\treturn map;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturns the class named in the given .class file.\n+\t */\n+\tprivate String getFromClassFile (File file)\n+\t\tthrows IOException\n+\t{\n+\t\tFileInputStream fin = null;\n+\t\ttry\n+\t\t{\n+\t\t\tfin = new FileInputStream (file);\n+\t\t\treturn getFromClass (fin);\n+\t\t}\n+\t\tfinally\n+\t\t{\n+\t\t\tif (fin != null)\n+\t\t\t\ttry { fin.close (); } catch (IOException ioe) {}\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tReturns the class name in the given .class bytecode.\n+\t */\n+\tprivate String getFromClass (InputStream in)\n+\t\tthrows IOException\n+\t{\n+\t\tConstantPoolTable table = new ConstantPoolTable (in);\n+\t\tint idx = table.getEndIndex ();\n+\t\tidx += 2;\t// access flags\n+\t\tint clsEntry = table.readUnsignedShort (idx);\n+\t\tint utfEntry = table.readUnsignedShort (table.get (clsEntry));\n+\t\treturn table.readString (table.get (utfEntry)).replace ('/', '.');\n+\t}\n+\n+\n+\t/**\n+\t *\tReturns the class named in the given .java file.\n+\t */\n+\tprivate String getFromJavaFile (File file)\n+\t\tthrows IOException\n+\t{\n+\t\tBufferedReader in = null;\n+\t\ttry\n+\t\t{\n+\t\t\t// find the line with the package declaration\n+\t\t\tin = new BufferedReader (new FileReader (file));\n+\t\t\tString line;\n+\t\t\tStringBuffer pack = null;\n+\t\t\twhile ((line = in.readLine ()) != null)\n+\t\t\t{\n+\t\t\t\tline = line.trim ();\n+\t\t\t\tif (line.startsWith (\"package \"))\n+\t\t\t\t{\n+\t\t\t\t\tline = line.substring (8).trim ();\n+\t\t\t\t\t\n+\t\t\t\t\t// strip off anything beyond the package declaration\n+\t\t\t\t\tpack = new StringBuffer ();\n+\t\t\t\t\tfor (int i = 0; i < line.length (); i++)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tif (Character.isJavaIdentifierPart (line.charAt (i))\n+\t\t\t\t\t\t\t|| line.charAt (i) == '.')\n+\t\t\t\t\t\t\tpack.append (line.charAt (i));\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// strip '.java'\n+\t\t\tString clsName = file.getName ();\n+\t\t\tclsName = clsName.substring (0, clsName.length () - 5);\n+\n+\t\t\t// prefix with package\n+\t\t\tif (pack != null && pack.length () > 0)\n+\t\t\t\tclsName = pack + \".\" + clsName;\n+\n+\t\t\treturn clsName;\n+\t\t}\n+\t\tfinally\n+\t\t{\n+\t\t\tif (in != null)\n+\t\t\t\ttry { in.close (); } catch (IOException ioe) {}\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tReturns the classes named in the given common format metadata file.\n+\t */\n+\tprivate Collection getFromMetaDataFile (File file)\n+\t\tthrows IOException\n+\t{\n+\t\tFileReader in = null;\n+\t\ttry\n+\t\t{\n+\t\t\tin = new FileReader (file);\n+\t\t\treturn getFromMetaData (in);\n+\t\t}\n+\t\tfinally\n+\t\t{\n+\t\t\tif (in != null)\n+\t\t\t\ttry { in.close (); } catch (IOException ioe) {}\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tReturns the classes named in the given common format metadata stream.\n+\t */\n+\tprivate Collection getFromMetaData (Reader xml)\n+\t\tthrows IOException\n+\t{ \n+\t\tCollection names = new ArrayList ();\n+\t\tBufferedReader in = new BufferedReader (xml);\n+\n+\t\tboolean comment = false;\n+\t\tint token = TOKEN_NONE;\n+\t\tString pkg = \"\";\n+\t\tString name;\n+\t\tread: for (int ch = 0, last = 0, last2 = 0; \n+\t\t\tch == '<' || (ch = in.read ()) != -1; last2 = last, last = ch)\n+\t\t{\n+\t\t\t// handle comments\n+\t\t\tif (comment && last2 == '-' && last == '-' && ch == '>')\n+\t\t\t{\n+\t\t\t\tcomment = false;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (comment)\n+\t\t\t{\n+\t\t\t\tif (ch == '<')\n+\t\t\t\t{\n+\t\t\t\t\tch = in.read ();\n+\t\t\t\t\tif (ch == -1)\n+\t\t\t\t\t\tbreak read;\n+\t\t\t\t}\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tif (last2 == '<' && last == '!' && ch == '-')\n+\t\t\t{\n+\t\t\t\tcomment = true;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\t// if not an element start, skip it\n+\t\t\tif (ch != '<')\n+\t\t\t\tcontinue;\n+\t\t\ttoken = TOKEN_NONE; // reset token\n+\t\t\tlast = ch;\t// update needed for comment detection\n+\t\t\tch = readThroughWhitespace (in);\n+\t\t\tif (ch == '/' || ch == '!' || ch == '?')\n+\t\t\t\tcontinue;\n+\n+\t\t\t// read element name; look for packages and classes\n+\t\t\ttoken = readElementToken (ch, in);\n+\t\t\tswitch (token)\n+\t\t\t{\n+\t\t\tcase TOKEN_EOF:\n+\t\t\t\tbreak read;\n+\t\t\tcase TOKEN_PACKAGE:\n+\t\t\t\tpkg = readAttribute (in, _packageAttr);\n+\t\t\t\tif (pkg == null)\n+\t\t\t\t\tbreak read;\n+\t\t\t\tbreak;\n+\t\t\tcase TOKEN_PACKAGE_NOATTR:\n+\t\t\t\tpkg = readElementText (in);\n+\t\t\t\tif (pkg == null)\n+\t\t\t\t\tbreak read;\n+\t\t\t\tch = '<'; // reading element text reads to next '<'\n+\t\t\t\tbreak;\n+\t\t\tcase TOKEN_CLASS:\n+\t\t\t\tname = readAttribute (in, _classAttr);\n+\t\t\t\tif (name == null)\n+\t\t\t\t\tbreak read;\n+\t\t\t\tif (pkg.length () > 0 && name.indexOf ('.') == -1)\n+\t\t\t\t\tnames.add (pkg + \".\" + name);\n+\t\t\t\telse\n+\t\t\t\t\tnames.add (name);\n+\t\t\t\tbreak;\n+\t\t\tcase TOKEN_CLASS_NOATTR:\n+\t\t\t\tname = readElementText (in);\n+\t\t\t\tif (name == null)\n+\t\t\t\t\tbreak read;\n+\t\t\t\tch = '<'; // reading element text reads to next '<'\n+\t\t\t\tif (pkg.length () > 0 && name.indexOf ('.') == -1)\n+\t\t\t\t\tnames.add (pkg + \".\" + name);\n+\t\t\t\telse\n+\t\t\t\t\tnames.add (name);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\treturn names;\n+\t}\n+\n+\n+\t/**\n+\t *\tRead the name of the current XML element and return the matching token.\n+\t */\n+\tprivate int readElementToken (int ch, Reader in)\n+\t\tthrows IOException\n+\t{\n+\t\t// look through the beginning element names to find what element this\n+\t\t// might be (if any)\n+\t\tint matchIdx = -1;\n+\t\tint matched = 0;\n+\t\tint dq = 0;\n+\t\tfor (int beginIdx = 0; beginIdx < _beginElements[0].length; beginIdx++)\n+\t\t{\n+\t\t\tif (beginIdx != 0)\n+\t\t\t\tch = in.read ();\n+\t\t\tif (ch == -1)\n+\t\t\t\treturn TOKEN_EOF;\n+\n+\t\t\tmatched = 0;\n+\t\t\tfor (int i = 0; i < _beginElements.length; i++)\n+\t\t\t{\n+\t\t\t\tif ((dq & (2 << i)) != 0)\n+\t\t\t\t\tcontinue;\n+\n+\t\t\t\tif (ch == _beginElements[i][beginIdx])\n+\t\t\t\t{\n+\t\t\t\t\tmatchIdx = i;\n+\t\t\t\t\tmatched++;\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t\tdq |= 2 << i;\n+\t\t\t}\n+\n+\t\t\tif (matched == 0)\n+\t\t\t\tbreak;\n+\t\t}\n+\t\tif (matched != 1)\n+\t\t\treturn TOKEN_NONE;\n+\n+\t\t// make sure the rest of the element name matches\n+\t\tchar[] match = _endElements[matchIdx];\n+\t\tfor (int i = 0; i < match.length; i++)\n+\t\t{\n+\t\t\tch = in.read ();\n+\t\t\tif (ch == -1)\n+\t\t\t\treturn TOKEN_EOF;\n+\t\t\tif (ch != match[i])\n+\t\t\t\treturn TOKEN_NONE;\n+\t\t}\n+\n+\t\t// read the next char to make sure we finished the element name\n+\t\tch = in.read ();\n+\t\tif (ch == -1)\n+\t\t\treturn TOKEN_EOF;\n+\t\tif (ch == '>')\n+\t\t{\n+\t\t\tif (matchIdx == 0 && _packageAttr == null)\n+\t\t\t\treturn TOKEN_PACKAGE_NOATTR;\n+\t\t\tif (matchIdx != 0 && _classAttr == null)\n+\t\t\t\treturn TOKEN_CLASS_NOATTR;\t\n+\t\t}\n+\t\telse if (Character.isWhitespace ((char) ch))\n+\t\t{\n+\t\t\tif (matchIdx == 0 && _packageAttr != null) \n+\t\t\t\treturn TOKEN_PACKAGE;\n+\t\t\tif (matchIdx != 0 && _classAttr != null)\n+\t\t\t\treturn TOKEN_CLASS;\n+\t\t}\n+\t\treturn TOKEN_NONE;\n+\t}\n+\n+\n+\t/**\n+\t *\tRead the attribute with the given name in chars of the current XML \n+\t *\telement.\n+\t */\n+\tprivate String readAttribute (Reader in, char[] name)\n+\t\tthrows IOException\n+\t{\n+\t\tint expected = 0;\n+\t\tfor (int ch, last = 0; true; last = ch)\n+\t\t{\n+\t\t\tch = in.read ();\n+\t\t\tif (ch == -1)\n+\t\t\t\treturn null;\n+\t\t\tif (ch == '>')\n+\t\t\t\treturn \"\";\n+\n+\t\t\t// if not expected char or still looking for 'n' and previous\n+\t\t\t// char is not whitespace, keep looking\n+\t\t\tif (ch != name[expected] || (expected == 0 && last != 0 \n+\t\t\t\t&& !Character.isWhitespace ((char) last)))\n+\t\t\t{\n+\t\t\t\texpected = 0;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\t// found expected char; have we found the whole \"name\"?\n+\t\t\texpected++;\n+\t\t\tif (expected == name.length)\n+\t\t\t{\n+\t\t\t\t// make sure the next char is '='\n+\t\t\t\tch = readThroughWhitespace (in);\n+\t\t\t\tif (ch == -1)\n+\t\t\t\t\treturn null;\n+\t\t\t\tif (ch != '=')\n+\t\t\t\t{\n+\t\t\t\t\texpected = 0;\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\t// toss out any subsequent whitespace and the next char, which\n+\t\t\t\t// is the opening quote for the attr value, then read until the\n+\t\t\t\t// closing quote\n+\t\t\t\treadThroughWhitespace (in);\n+\t\t\t\treturn readAttributeValue (in);\t\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tRead the current text value until the next element.\n+\t */\n+\tprivate String readElementText (Reader in)\n+\t\tthrows IOException\n+\t{\n+\t\tStringBuffer buf = null;\n+\t\tint ch;\n+\t\twhile (true)\n+\t\t{\n+\t\t\tch = in.read ();\n+\t\t\tif (ch == -1)\n+\t\t\t\treturn null;\n+\t\t\tif (ch == '<')\n+\t\t\t\tbreak;\n+\t\t\tif (Character.isWhitespace ((char) ch))\n+\t\t\t\tcontinue;\n+\t\t\tif (buf == null)\n+\t\t\t\tbuf = new StringBuffer ();\n+\t\t\tbuf.append ((char) ch);\n+\t\t}\n+\t\treturn (buf == null) ? \"\" : buf.toString ();\n+\t}\n+\n+\n+\t/**\n+\t *\tRead until the next non-whitespace character.\n+\t */\n+\tprivate int readThroughWhitespace (Reader in)\n+\t\tthrows IOException\n+\t{\n+\t\tint ch;\n+\t\twhile (true)\n+\t\t{\n+\t\t\tch = in.read ();\n+\t\t\tif (ch == -1 || !Character.isWhitespace ((char) ch))\n+\t\t\t\treturn ch;\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the current attribute value.\n+\t */\n+\tprivate String readAttributeValue (Reader in)\n+\t\tthrows IOException\n+\t{\n+\t\tStringBuffer buf = new StringBuffer ();\n+\t\tint ch;\n+\t\twhile (true)\n+\t\t{\n+\t\t\tch = in.read ();\n+\t\t\tif (ch == -1)\n+\t\t\t\treturn null;\n+\t\t\tif (ch == '\\'' || ch == '\"')\n+\t\t\t\treturn buf.toString ();\n+\t\t\tbuf.append ((char) ch);\n+\t\t}\n+\t}\n+}"},{"sha":"0a6ccc4fdfe3a49c9287bce3afa5325e5f56ed63","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/ClassMetaDataIterator.java","status":"added","additions":200,"deletions":0,"changes":200,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/ClassMetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/ClassMetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/ClassMetaDataIterator.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.io.*;\n+import java.net.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+\n+import serp.util.*;\n+\n+\n+/**\n+ *\t<p>Iterator over all metadata resources that might contain the\n+ *\tmetadata for a given class, starting with the most general.  Assumes that\n+ *\tpackage-level resources are named \"package.&lt;suffix&gt;\".</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public class ClassMetaDataIterator\n+\timplements MetaDataIterator\n+{\n+\tprivate final ClassLoader\t_loader;\n+\tprivate final List\t\t\t_locs;\n+\tprivate int\t\t\t\t\t_loc\t= -1;\n+\tprivate final List\t\t\t_urls \t= new ArrayList (3);\n+\tprivate int\t\t\t\t\t_url\t= -1;\n+\n+\n+\t/**\n+\t *\tConstructor; supply the class whose metadata to find, the suffix\n+\t *\tof metadata files, and whether to parse top-down or bottom-up.\n+\t */\n+\tpublic ClassMetaDataIterator (Class cls, String suffix, boolean topDown)\n+\t{\n+\t\tthis (cls, suffix, null, topDown);\n+\t}\n+\n+\n+\t/**\n+\t *\tConstructor; supply the class whose metadata to find, the suffix\n+\t *\tof metadata files, and whether to parse top-down or bottom-up.\n+\t */\n+\tpublic ClassMetaDataIterator (Class cls, String suffix, ClassLoader loader,\n+\t\tboolean topDown)\n+\t{\n+\t\t// skip classes that can't have metadata\n+\t\tif (cls != null && (cls.isPrimitive ()\n+\t\t\t|| cls.getName ().startsWith (\"java.\")\n+\t\t\t|| cls.getName ().startsWith (\"javax.\")))\n+\t\t{\n+\t\t\t_loader = null;\n+\t\t\t_locs = Collections.EMPTY_LIST;\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (loader == null)\n+\t\t{\n+\t\t\tMultiClassLoader multi = new MultiClassLoader ();\n+\t\t\tmulti.addClassLoader (multi.SYSTEM_LOADER);\n+\t\t\tmulti.addClassLoader (multi.THREAD_LOADER);\n+\t\t\tmulti.addClassLoader (getClass ().getClassLoader ());\n+\t\t\tif (cls != null && cls.getClassLoader () != null)\n+\t\t\t\tmulti.addClassLoader (cls.getClassLoader ());\n+\t\t\tloader = multi;\n+\t\t}\n+\t\t_loader = loader;\n+\n+\t\t// collect the set of all possible metadata locations; start with\n+\t\t// system locations\n+\t\t_locs = new ArrayList ();\n+\t\t_locs.add (\"META-INF/package\" + suffix);\n+\t\t_locs.add (\"WEB-INF/package\" + suffix);\n+\t\t_locs.add (\"package\" + suffix);\n+\n+\t\t// put this legacy location at the end regardless of whether we're \n+\t\t// going top down or bottom up so we don't have to parse it as often\n+\t\t// during testing\n+\t\tif (!topDown)\n+\t\t\t_locs.add (\"system\" + suffix);\n+\n+\t\tif (cls != null)\n+\t\t{\n+\t\t\t// also check:\n+\t\t\t// 1. for each package from the top down to cls' package:\n+\t\t\t//\t\t<path>/package<suffix>\n+\t\t\t//\t\t<path>/<package-name><suffix> \t\t(legacy support)\n+\t\t\t// \t\t<path>/../<package-name><suffix>\t(legacy support)\n+\t\t\t// 2. <path>/<class-name><suffix>\n+\t\t\tString pkg = Strings.getPackageName (cls).replace ('.', '/');\n+\t\t\tif (pkg.length () > 0)\n+\t\t\t{\n+\t\t\t\tint idx, start = 0;\n+\t\t\t\tString pkgName, path, upPath = \"\";\n+\t\t\t\tdo\n+\t\t\t\t{\n+\t\t\t\t\tidx = pkg.indexOf ('/', start);\n+\t\t\t\t\tif (idx == -1)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tpkgName = (start == 0) ? pkg : pkg.substring (start);\n+\t\t\t\t\t\tpath = pkg + \"/\";\n+\t\t\t\t\t}\n+\t\t\t\t\telse\n+\t\t\t\t\t{\n+\t\t\t\t\t\tpkgName = pkg.substring (start, idx);\n+\t\t\t\t\t\tpath = pkg.substring (0, idx + 1);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t_locs.add (path + \"package\" + suffix);\n+\t\t\t\t\t_locs.add (path + pkgName + suffix); \t// legacy\n+\t\t\t\t\t_locs.add (upPath + pkgName + suffix);\t// legacy\n+\t\t\t\t\tif (idx == -1)\n+\t\t\t\t\t\t_locs.add (path + Strings.getClassName (cls) + suffix);\n+\n+\t\t\t\t\tstart = idx + 1;\n+\t\t\t\t\tupPath = path;\n+\t\t\t\t}\n+\t\t\t\twhile (idx != -1);\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\t// <class-name><suffix> for top-level classes\n+\t\t\t\t_locs.add (cls.getName () + suffix);\n+\t\t\t}\n+\t\t}\n+\t\tif (topDown)\n+\t\t\t_locs.add (\"system\" + suffix);\t// legacy\n+\t\telse\n+\t\t\tCollections.reverse (_locs);\n+\t}\n+\n+\n+\tpublic boolean hasNext ()\n+\t\tthrows IOException\n+\t{\n+\t\tEnumeration e;\n+\t\twhile (_url + 1 >= _urls.size ())\n+\t\t{\n+\t\t\tif (++_loc >= _locs.size ())\n+\t\t\t\treturn false;\n+\n+\t\t\t_url = -1;\n+\t\t\t_urls.clear ();\n+\t\t\te = _loader.getResources ((String) _locs.get (_loc));\n+\t\t\twhile (e.hasMoreElements ())\n+\t\t\t\t_urls.add (e.nextElement ());\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\n+\tpublic Object next ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (!hasNext ())\n+\t\t\tthrow new NoSuchElementException ();\n+\t\treturn _urls.get (++_url);\n+\t}\n+\n+\t\n+\tpublic InputStream getInputStream ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (_url == -1 || _url >= _urls.size ())\n+\t\t\tthrow new IllegalStateException ();\n+\t\treturn ((URL) _urls.get (_url)).openStream ();\n+\t}\n+\n+\n+\tpublic File getFile ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (_url == -1 || _url >= _urls.size ())\n+\t\t\tthrow new IllegalStateException ();\n+\t\tFile file = new File (URLDecoder.decode (((URL) _urls.get (_url)).\n+\t\t\tgetFile ()));\n+\t\treturn (file.exists ()) ? file : null;\n+\t}\n+\n+\n+\tpublic void close ()\n+\t{\n+\t}\n+}"},{"sha":"c8c7bd4913108d0417444e4e5e050b28ee270ab1","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/ClasspathMetaDataIterator.java","status":"added","additions":85,"deletions":0,"changes":85,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/ClasspathMetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/ClasspathMetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/ClasspathMetaDataIterator.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.zip.*;\n+\n+import serp.util.*;\n+\n+\n+/**\n+ *\t<p>Iterator over directories in the classpath.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public class ClasspathMetaDataIterator\n+\textends MetaDataIteratorChain\n+{\n+\t/**\n+\t *\tDefault constructor; iterates over all classpath elements.\n+\t */\n+\tpublic ClasspathMetaDataIterator ()\n+\t\tthrows IOException\n+\t{\n+\t\tthis (null, null);\n+\t}\n+\n+\n+\t/**\n+\t *\tConstructor; supply the classpath directories to scan and an optional\n+\t *\tresource filter.  The given directories may be null to scan all \n+\t *\tclasspath directories.\n+\t */\n+\tpublic ClasspathMetaDataIterator (String[] dirs, MetaDataFilter filter)\n+\t\tthrows IOException\n+\t{\n+\t\tProperties props = System.getProperties ();\n+\t\tString path = props.getProperty (\"java.class.path\");\n+\t\tString[] tokens = Strings.split (path,\n+\t\t\tprops.getProperty (\"path.separator\"), 0);\n+\n+\t\tfor (int i = 0; i < tokens.length; i++)\n+\t\t{\n+\t\t\tif (dirs != null && dirs.length != 0 && !endsWith (tokens[i], dirs))\n+\t\t\t\tcontinue;\n+\n+\t\t\tFile file = new File (tokens[i]);\n+\t\t\tif (!file.exists ())\n+\t\t\t\tcontinue;\n+\t\t\tif (file.isDirectory ())\n+\t\t\t\taddIterator (new FileMetaDataIterator (file, filter));\n+\t\t\telse if (tokens[i].endsWith (\".jar\"))\n+\t\t\t\taddIterator (new ZipFileMetaDataIterator (new ZipFile (file),\n+\t\t\t\t\tfilter));\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn true if the given token ends with any of the given strings.\n+\t */\n+\tprivate static boolean endsWith (String token, String[] suffs)\n+\t{\n+\t\tfor (int i = 0; i < suffs.length; i++)\n+\t\t\tif (token.endsWith (suffs[i]))\n+\t\t\t\treturn true;\n+\t\treturn false;\n+\t}\n+}"},{"sha":"f4d4f8e149dac88dbdfee66870955558b1f05921","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/FileMetaDataIterator.java","status":"added","additions":175,"deletions":0,"changes":175,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/FileMetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/FileMetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/FileMetaDataIterator.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+\n+\n+/**\n+ *\t<p>Iterator over a file, or over all metadata resources below a given \n+ *\tdirectory.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public class FileMetaDataIterator\n+\timplements MetaDataIterator\n+{\n+\tprivate static final long SCAN_LIMIT = 100000;\n+\n+\tprivate static final Localizer _loc = Localizer.forPackage\n+\t\t(FileMetaDataIterator.class);\n+\n+\tprivate final Iterator\t_itr;\n+\tprivate File\t\t\t_file = null;\n+\n+\n+\t/**\n+\t *\tConstructor; supply metadata file.\n+\t */\n+\tpublic FileMetaDataIterator (File file)\n+\t{\n+\t\t_itr = Collections.singleton (file).iterator ();\n+\t}\n+\n+\n+\t/**\n+\t *\tConstructor; supply root of directory tree to search and optional \n+\t *\tfile filter.\n+\t */\n+\tpublic FileMetaDataIterator (File dir, MetaDataFilter filter)\n+\t\tthrows IOException\n+\t{\n+\t\tif (dir == null)\n+\t\t\t_itr = null;\n+\t\telse\n+\t\t{\n+\t\t\tCollection metas = new ArrayList ();\n+\t\t\tFileResource rsrc = (filter == null) ? null : new FileResource ();\n+\t\t\tscan (dir, filter, rsrc, metas, 0);\n+\t\t\t_itr = metas.iterator ();\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tScan all files below the given one for metadata files, adding them\n+\t *\tto the given collection.\n+\t */\n+\tprivate int scan (File file, MetaDataFilter filter, FileResource rsrc, \n+\t\tCollection metas, int scanned)\n+\t\tthrows IOException\n+\t{\n+\t\tif (scanned > SCAN_LIMIT)\n+\t\t\tthrow new IllegalStateException (_loc.get (\"too-many-files\",\n+\t\t\t\tString.valueOf (SCAN_LIMIT)));\n+\t\tscanned++;\n+\n+\t\tif (filter == null)\n+\t\t\tmetas.add (file);\n+\t\telse\n+\t\t{\n+\t\t\trsrc.setFile (file);\n+\t\t\tif (filter.matches (rsrc))\n+\t\t\t\tmetas.add (file);\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tFile[] files = file.listFiles ();\n+\t\t\t\tif (files != null)\n+\t\t\t\t\tfor (int i = 0; i < files.length; i++)\n+\t\t\t\t\t\tscanned = scan (files[i], filter, rsrc, metas, scanned);\n+\t\t\t}\n+\t\t}\n+\t\treturn scanned;\n+\t}\n+\n+\n+\tpublic boolean hasNext ()\n+\t{\n+\t\treturn _itr != null && _itr.hasNext ();\n+\t}\n+\n+\n+\tpublic Object next ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (_itr == null)\n+\t\t\tthrow new NoSuchElementException ();\n+\n+\t\t_file = (File) _itr.next ();\n+\t\treturn _file.getAbsoluteFile ().toURL ();\n+\t}\n+\n+\t\n+\tpublic InputStream getInputStream ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (_file == null)\n+\t\t\tthrow new IllegalStateException ();\n+\t\treturn new FileInputStream (_file);\n+\t}\n+\n+\n+\tpublic File getFile ()\n+\t{\n+\t\tif (_file == null)\n+\t\t\tthrow new IllegalStateException ();\n+\t\treturn _file;\n+\t}\n+\n+\n+\tpublic void close ()\n+\t{\n+\t}\n+\n+\n+\tprivate static class FileResource\n+\t\timplements MetaDataFilter.Resource\n+\t{\n+\t\tprivate File _file = null;\n+\n+\n+\t\tpublic void setFile (File file)\n+\t\t{\n+\t\t\t_file = file;\n+\t\t}\n+\n+\n+\t\tpublic String getName ()\n+\t\t{\n+\t\t\treturn _file.getName ();\n+\t\t}\n+\n+\n+\t\tpublic byte[] getContent ()\n+\t\t\tthrows IOException\n+\t\t{\n+\t\t\tlong len = _file.length ();\n+\t\t\tif (len <= 0)\n+\t\t\t\treturn new byte[0];\n+\n+\t\t\tbyte[] content = new byte[(int) len];\n+\t\t\tFileInputStream fin = new FileInputStream (_file);\n+\t\t\tfin.read (content);\n+\t\t\tfin.close ();\n+\t\t\treturn content;\n+\t\t}\n+\t}\n+}"},{"sha":"93d48e3e0079d69dc9f9acd336632a7813a703f9","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataFilter.java","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataFilter.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataFilter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataFilter.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.io.*;\n+\n+\n+/**\n+ *\t<p>Filters metadata resources.  Typically used to constrain the results\n+ *\tof a {@link MetaDataIterator}.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public interface MetaDataFilter\n+{\n+\t/**\n+\t *\tReturn whether the given resource passes the filter.\n+\t */\n+\tpublic boolean matches (Resource rsrc)\n+\t\tthrows IOException;\n+\n+\n+\t/**\n+\t *\tInformation about a metadata resource.\n+\t */\n+\tpublic static interface Resource\n+\t{\n+\t\t/**\n+\t\t *\tThe name of the resource.\n+\t \t */\n+\t\tpublic String getName ();\n+\n+\n+\t\t/**\n+\t \t *\tResource content.\n+\t\t */\n+\t\tpublic byte[] getContent ()\n+\t\t\tthrows IOException;\n+\t}\n+}"},{"sha":"1d76545cf55755d0c8d9cc04e4d144dda635f945","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataIterator.java","status":"added","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataIterator.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.io.*;\n+\n+import org.apache.openjpa.lib.util.Closeable; // also in java.io (in 1.5)\n+\n+\n+/**\n+ *\t<p>Iterator over metadata resources.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ */\n+public interface MetaDataIterator\n+\textends Closeable\n+{\n+\t/**\n+\t *\tReturn whether there is another resource to iterate over.\n+\t */\n+\tpublic boolean hasNext ()\n+\t\tthrows IOException;\n+\n+\n+\t/**\n+\t *\tReturn the next metadata resource.\n+\t */\n+\tpublic Object next ()\n+\t\tthrows IOException;\n+\n+\t\n+\t/**\n+\t *\tReturn the last-iterated metadata resource content as a stream.\n+ \t */\n+\tpublic InputStream getInputStream ()\n+\t\tthrows IOException;\n+\n+\n+\t/**\n+\t *\tReturn the last-iterated metadata resource content as a file, or null\n+\t *\tif not an extant file.\n+ \t */\n+\tpublic File getFile ()\n+\t\tthrows IOException;\n+\n+\n+\t/**\n+\t *\tClose the resources used by this iterator.\n+\t */\n+\tpublic void close ();\n+}\n+"},{"sha":"3fee4cd672af7253b14c276eeba9fb85344ce985","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataIteratorChain.java","status":"added","additions":124,"deletions":0,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataIteratorChain.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataIteratorChain.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataIteratorChain.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+\n+\n+/**\n+ *\t<p>Metadata iterator that combines several iterators.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public class MetaDataIteratorChain\n+\timplements MetaDataIterator\n+{\n+\tprivate List \t\t\t\t_itrs\t= null;\n+\tprivate int\t \t\t\t\t_cur\t= -1;\n+\tprivate MetaDataIterator\t_itr\t= null;\n+\n+\n+\t/**\n+\t *\tDefault constructor.\n+\t */\n+\tpublic MetaDataIteratorChain ()\n+\t{\n+\t}\n+\n+\n+\t/**\n+\t *\tCombine two iterators.\n+\t */\n+\tpublic MetaDataIteratorChain (MetaDataIterator itr1, MetaDataIterator itr2)\n+\t{\n+\t\t_itrs = new ArrayList (2);\n+\t\t_itrs.add (itr1);\n+\t\t_itrs.add (itr2);\n+\t}\n+\n+\n+\t/**\n+\t *\tAdd an iterator to the chain.\n+\t */\n+\tpublic void addIterator (MetaDataIterator itr)\n+\t{\n+\t\tif (_cur != -1)\n+\t\t\tthrow new IllegalStateException ();\n+\t\tif (_itrs == null)\n+\t\t\t_itrs = new ArrayList (4);\n+\t\t_itrs.add (itr);\n+\t}\n+\n+\n+\tpublic boolean hasNext ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (_itrs == null)\n+\t\t\treturn false;\n+\t\tif (_cur == -1)\n+\t\t\t_cur = 0;\n+\n+\t\tMetaDataIterator itr;\n+\t\tfor (; _cur < _itrs.size (); _cur++)\n+\t\t{\n+\t\t\titr = (MetaDataIterator) _itrs.get (_cur);\n+\t\t\tif (itr.hasNext ())\n+\t\t\t{\n+\t\t\t\t_itr = itr;\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\t_itr = null;\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic Object next ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (!hasNext ())\n+\t\t\tthrow new NoSuchElementException ();\n+\t\treturn _itr.next ();\n+\t}\n+\n+\n+\tpublic InputStream getInputStream ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (_itr == null)\n+\t\t\tthrow new IllegalStateException ();\n+\t\treturn _itr.getInputStream ();\n+\t}\n+\n+\n+\tpublic File getFile ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (_itr == null)\n+\t\t\tthrow new IllegalStateException ();\n+\t\treturn _itr.getFile ();\n+\t}\n+\n+\n+\tpublic void close ()\n+\t{\n+\t\tfor (Iterator itr = _itrs.iterator (); itr.hasNext ();)\n+\t\t\t((MetaDataIterator) itr.next ()).close ();\n+\t}\n+}"},{"sha":"8799dd9c1bdffbb2b3bc691078d56374c9d75d6d","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataParser.java","status":"added","additions":98,"deletions":0,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataParser.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.io.*;\n+import java.net.*;\n+import java.util.*;\n+\n+\n+/**\n+ *\t<p>Interface for metadata parsers.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public interface MetaDataParser\n+{\n+\t/**\n+\t *\tThe classloader to use to resolve resources, or null for impl-defined\n+\t *\tdefault.\n+\t */\n+\tpublic void setClassLoader (ClassLoader loader);\n+\n+\n+\t/**\n+\t *\tReturn the results from the last parse.\n+\t */\n+\tpublic List getResults ();\n+\t\n+\n+\t/**\n+\t *\tParse the given resource.\n+\t */\n+\tpublic void parse (String rsrc)\n+\t\tthrows IOException;\n+\n+\n+\t/**\n+\t *\tParse the given resource.\n+\t */\n+\tpublic void parse (URL url)\n+\t\tthrows IOException;\n+\n+\n+\t/**\n+\t *\tParse the given file, which may be a directory, in which case it\n+\t *\twill be scanned recursively for metadata files.\n+\t */\n+\tpublic void parse (File file)\n+\t\tthrows IOException;\n+\n+\n+\t/**\n+\t *\tParse all possible metadata locations for the given class, going \n+\t *\ttop-down or bottom-up.  If the class is null, only top-level locations \n+\t *\twill be parsed.\n+\t */\n+\tpublic void parse (Class cls, boolean topDown)\n+\t\tthrows IOException;\n+\n+\n+\t/**\n+\t *\tParse the metadata in the given reader.\n+ \t *\n+\t *\t@param\tcontent\t\treader containing the metadata to parse\n+\t *\t@param\tsourceName\tthe name of the source being parsed, for use\n+\t *\t\t\t\t\t\tin error messages\n+\t */\t\n+\tpublic void parse (Reader content, String sourceName)\n+\t\tthrows IOException;\n+\n+\n+\t/**\n+\t *\tParse the metadata supplied by the given iterator.\n+\t */\n+\tpublic void parse (MetaDataIterator itr)\n+\t\tthrows IOException;\n+\n+\n+\t/**\n+\t *\tClears the cache of parsed resource names.\n+\t */\n+\tpublic void clear ();\n+}"},{"sha":"fa12a8952c9239dd7f4f7f8a63885ca851281fe3","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataSerializer.java","status":"added","additions":84,"deletions":0,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/MetaDataSerializer.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+\n+\n+/**\n+ *\t<p>Interface for meta data serializers.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public interface MetaDataSerializer\n+{\n+\tpublic static final int COMPACT\t= 0;\n+\tpublic static final int PRETTY\t= 1;\n+\tpublic static final int APPEND\t= 2;\n+\tpublic static final int VERBOSE\t= 4;\n+\n+\n+\t/**\n+\t *\tSerialize the current set of objects to the files from which they were\n+\t *\tparsed.  Any objects for which a source file cannot be determined will\n+  \t *\tnot be included in the output.  \n+\t *\n+ \t *\t@param\tflags\tbit flags specifying the output flags; e.g. \n+\t *\t\t\t\t\t{@link PRETTY #PRETTY}\n+\t */\n+\tpublic void serialize (int flags)\n+\t\tthrows IOException;\n+\n+\n+\t/** \n+\t *\tSerialize the current set of objects to the files from which they were\n+\t *\tparsed.  The objects must implement the {@link SourceTracker}\n+\t *\tinterface.\n+\t *\n+\t *  @param  output  if null, then serialize directly to the file system;\n+\t *  \t\t\t\tothwerwise, populate the specified {@link Map} with\n+\t *  \t\t\t\tkeys that are the {@link File} instances, and\n+\t *  \t\t\t\tvalues that are the {@link String} contents of\n+\t *  \t\t\t\tthe metadata\n+ \t *\t@param\tflags\tbit flags specifying the output flags; e.g. \n+\t *\t\t\t\t\t{@link PRETTY #PRETTY}\n+\t */\n+\tpublic void serialize (Map output, int flags)\n+\t\tthrows IOException;\n+\n+\n+\t/**\n+\t *\tSerialize the current set of objects to the given file.\n+\t *\n+ \t *\t@param\tflags\tbit flags specifying the output flags; e.g. \n+\t *\t\t\t\t\t{@link PRETTY #PRETTY} | {@link APPEND #APPEND}\n+\t */\n+\tpublic void serialize (File file, int flags)\n+\t\tthrows IOException;\n+\n+\n+\t/**\n+\t *\tSerialize the current set of objects to the given stream.\n+\t *\n+ \t *\t@param\tflags\tbit flags specifying the output flags; e.g. \n+\t *\t\t\t\t\t{@link PRETTY #PRETTY}\n+\t */\n+\tpublic void serialize (Writer out, int flags)\n+\t\tthrows IOException;\n+}"},{"sha":"c6ad3ccd0b057589f909958d764b5a5c0aec1c59","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/ResourceMetaDataIterator.java","status":"added","additions":112,"deletions":0,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/ResourceMetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/ResourceMetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/ResourceMetaDataIterator.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.io.*;\n+import java.net.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+\n+\n+/**\n+ *\t<p>Iterator over a given metadata resource.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public class ResourceMetaDataIterator\n+\timplements MetaDataIterator\n+{\n+\tprivate List\t_urls\t= null;\n+\tprivate int\t\t_url\t= -1;\n+\n+\n+\t/**\n+\t *\tConstructor; supply the resource to parse.\n+\t */\n+\tpublic ResourceMetaDataIterator (String rsrc)\n+\t\tthrows IOException\n+\t{\n+\t\tthis (rsrc, null);\n+\t}\n+\n+\n+\t/**\n+\t *\tConstructor; supply the resource to parse.\n+\t */\n+\tpublic ResourceMetaDataIterator (String rsrc, ClassLoader loader)\n+\t\tthrows IOException\n+\t{\n+\t\tif (loader == null)\n+\t\t{\n+\t\t\tMultiClassLoader multi = new MultiClassLoader ();\n+\t\t\tmulti.addClassLoader (multi.SYSTEM_LOADER);\n+\t\t\tmulti.addClassLoader (multi.THREAD_LOADER);\n+\t\t\tmulti.addClassLoader (getClass ().getClassLoader ());\n+\t\t\tloader = multi;\n+\t\t}\n+\n+\t\tEnumeration e = loader.getResources (rsrc);\n+\t\twhile (e.hasMoreElements ())\n+\t\t{\n+\t\t\tif (_urls == null)\n+\t\t\t\t_urls = new ArrayList (3);\n+\t\t\t_urls.add (e.nextElement ());\n+\t\t}\n+\t}\n+\n+\n+\tpublic boolean hasNext ()\n+\t{\n+\t\treturn _urls != null && _url + 1 < _urls.size ();\n+\t}\n+\n+\n+\tpublic Object next ()\n+\t{\n+\t\tif (!hasNext ())\n+\t\t\tthrow new NoSuchElementException ();\n+\t\treturn _urls.get (++_url);\n+\t}\n+\n+\t\n+\tpublic InputStream getInputStream ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (_url == -1 || _url >= _urls.size ())\n+\t\t\tthrow new IllegalStateException ();\n+\t\treturn ((URL) _urls.get (_url)).openStream ();\n+\t}\n+\n+\n+\tpublic File getFile ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (_url == -1 || _url >= _urls.size ())\n+\t\t\tthrow new IllegalStateException ();\n+\t\tFile file = new File (URLDecoder.decode (((URL) _urls.get (_url)).\n+\t\t\tgetFile ()));\n+\t\treturn (file.exists ()) ? file : null;\n+\t}\n+\n+\n+\tpublic void close ()\n+\t{\n+\t}\n+}\n+"},{"sha":"00f6eac32ac095213aa25b6c8faeb0ceb85fe507","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/SourceTracker.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/SourceTracker.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/SourceTracker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/SourceTracker.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.io.*;\n+\n+\n+/**\n+ *\t<p>Interface that can optionally be implemented by metadata\n+ *\tto include the source file from which the metadata was originally\n+ *\tparsed.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ */\n+public interface SourceTracker\n+{\n+\tpublic static final int SRC_OTHER\t\t= 0;\n+\tpublic static final int SRC_ANNOTATIONS\t= 1;\n+\tpublic static final int SRC_XML\t\t\t= 2;\n+\n+\n+\t/**\n+\t *\tReturn the file from which this instance was parsed.\n+\t */\n+\tpublic File getSourceFile ();\n+\n+\n+\t/**\n+\t *\tReturn the domain-dependent scope of this instance within its file.  \n+\t */\n+\tpublic Object getSourceScope ();\n+\n+\n+\t/**\n+\t *\tReturn the type of source.\n+\t */\n+\tpublic int getSourceType ();\n+\n+\n+\t/**\n+\t *\tReturn the domain-meaningful name of the resource that was loaded\n+\t *\tfrom this source. I.e., if we had loaded the source for a Java\n+\t *\tclass, this would return the name of the class.\n+\t */\n+\tpublic String getResourceName ();\n+}"},{"sha":"066ade85a7a06c47f67dc403c98cf5c4e1df9f99","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/SourceTrackers.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/SourceTrackers.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/SourceTrackers.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/SourceTrackers.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import org.apache.openjpa.lib.util.*;\n+\n+\n+/**\n+ *\tUtility class for performing common operations on {@link SourceTracker}s.\n+ *\n+ *\t@since 3.3.1\n+ */\n+public class SourceTrackers\n+{\n+\tprivate static final Localizer _loc =\n+\t\tLocalizer.forPackage (SourceTrackers.class);\n+\n+\tprivate static final String SEP = System.getProperty (\"line.separator\");\n+\n+\n+\t/**\n+\t *\tCreate a message appropriate for display to the user describing\n+\t *\tthe location(s) that <code>trackers</code> were loaded from.\n+\t *\n+\t *\t@param trackers\tthe source-trackers for which location info should\n+\t * \t\t\t\t\tbe provided.\n+\t */\n+\tpublic static String getSourceLocationMessage (SourceTracker[] trackers)\n+\t{\n+\t\tStringBuffer buf = new StringBuffer (20 * (trackers.length + 1));\n+\t\tbuf.append (_loc.get (\"source-trackers-location-header\")).append (SEP);\n+\t\tString sourceFilePath;\n+\t\tfor (int i = 0; i < trackers.length; i++)\n+\t\t{\n+\t\t\tsourceFilePath = (trackers[i].getSourceFile () == null ?\n+\t\t\t\t_loc.get (\"source-tracker-file-unknown\") : \n+\t\t\t\ttrackers[i].getSourceFile ().getAbsolutePath ());\n+\t\t\tbuf.append (\"  \").append (_loc.get (\n+\t\t\t\t\"source-trackers-location-line-item\",\n+\t\t\t\ttrackers[i].getResourceName (), sourceFilePath));\n+\t\t\tif (i < trackers.length - 1)\n+\t\t\t\tbuf.append (SEP);\n+\t\t}\n+\t\treturn buf.toString ();\n+\t}\n+}"},{"sha":"80c4971084ef98f73575b98c680b6cf46d09f941","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/SuffixMetaDataFilter.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/SuffixMetaDataFilter.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/SuffixMetaDataFilter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/SuffixMetaDataFilter.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+/**\n+ *\t<p>Filters metadata iteration based on resource name suffix.</p>\n+ *\n+ *\t@author\tAbe White\n+ *\t@nojavadoc\n+ */\n+public class SuffixMetaDataFilter\n+\timplements MetaDataFilter\n+{\n+\tprivate final String _suffix;\n+\n+\n+\t/**\n+\t *\tConstructor; supply suffix to match against.\n+\t */\n+\tpublic SuffixMetaDataFilter (String suffix)\n+\t{\n+\t\t_suffix = suffix;\n+\t}\n+\n+\n+\tpublic boolean matches (Resource rsrc)\n+\t{\n+\t\tString name = rsrc.getName ();\n+\t\treturn name != null && name.endsWith (_suffix);\n+\t}\n+}"},{"sha":"39c3161e8a3df6ab66add4a0b8b2ba8abd945ac6","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/URLMetaDataIterator.java","status":"added","additions":88,"deletions":0,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/URLMetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/URLMetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/URLMetaDataIterator.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.io.*;\n+import java.net.*;\n+\n+\n+/**\n+ *\t<p>Iterator over the metadata resource represented by a URL.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public class URLMetaDataIterator\n+\timplements MetaDataIterator\n+{\n+\tprivate final URL \t_url;\n+\tprivate boolean\t\t_iterated = false;\n+\n+\n+\t/**\n+\t *\tConstructor; supply resource URL.\n+\t */\n+\tpublic URLMetaDataIterator (URL url)\n+\t{\n+\t\t_url = url;\n+\t}\n+\n+\n+\tpublic boolean hasNext ()\n+\t{\n+\t\treturn _url != null && !_iterated;\n+\t}\n+\n+\n+\tpublic Object next ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (!hasNext ())\n+\t\t\tthrow new IllegalStateException ();\n+\n+\t\t_iterated = true;\n+\t\treturn _url;\n+\t}\n+\n+\t\n+\tpublic InputStream getInputStream ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (!_iterated)\n+\t\t\tthrow new IllegalStateException ();\n+\t\tif (_url == null)\n+\t\t\treturn null;\n+\t\treturn _url.openStream ();\n+\t}\n+\n+\n+\tpublic File getFile ()\n+\t{\n+\t\tif (!_iterated)\n+\t\t\tthrow new IllegalStateException ();\n+\t\tif (_url == null)\n+\t\t\treturn null;\n+\t\tFile file = new File (URLDecoder.decode (_url.getPath ()));\n+\t\treturn (file.exists ()) ? file : null;\n+\t}\n+\n+\n+\tpublic void close ()\n+\t{\n+\t}\n+}\n+"},{"sha":"fff38f598d18227782e2d58e46bc7ec5f3da0d43","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/XMLMetaDataParser.java","status":"added","additions":780,"deletions":0,"changes":780,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/XMLMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/XMLMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/XMLMetaDataParser.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,780 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.util.*;\n+import java.io.*;\n+import java.net.*;\n+import javax.xml.parsers.*;\n+\n+import org.xml.sax.helpers.*;\n+import org.xml.sax.ext.*;\n+import org.xml.sax.*;\n+\n+import org.apache.openjpa.lib.log.*;\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.lib.xml.*;\n+\n+\n+/**\n+ *\t<p>Custom SAX parser used by the system to quickly parse metadata files.\n+ *\tSubclasses should handle the processing of the content.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public abstract class XMLMetaDataParser\n+\textends DefaultHandler\n+\timplements LexicalHandler, MetaDataParser\n+{\n+\tprivate static final Localizer _loc = Localizer.forPackage\n+\t\t(XMLMetaDataParser.class);\n+\n+\t// map of classloaders to sets of parsed locations, so that we don't parse\n+\t// the same resource multiple times for the same class\n+\tprivate Map _parsed = null;\n+\n+\tprivate Log\t\t\t_log\t\t\t= null;\n+\tprivate boolean\t\t_validating \t= true;\n+\tprivate boolean\t\t_systemId\t\t= true;\n+\tprivate boolean\t\t_caching\t\t= true;\n+\tprivate boolean\t\t_parseText\t\t= true;\n+\tprivate boolean\t\t_parseComments\t= true;\n+\tprivate String\t\t_suffix\t\t\t= null;\n+\tprivate ClassLoader\t_loader\t\t\t= null;\n+\tprivate ClassLoader\t_curLoader\t\t= null;\n+\n+\t// state for current parse\n+\tprivate final Collection\t_curResults\t= new LinkedList ();\n+\tprivate List\t\t\t\t_results\t= null;\n+\tprivate String \t\t\t\t_sourceName\t= null;\n+\tprotected File\t\t\t\t_sourceFile\t= null;\n+\tprivate StringBuffer \t\t_text\t\t= null;\n+\tprivate List\t\t\t\t_comments\t= null;\n+\tprivate Location\t\t\t_location\t= new Location ();\n+\tprivate LexicalHandler\t\t_lh\t\t\t= null;\n+\tprivate int\t\t\t\t\t_depth\t\t= -1;\n+\tprivate int\t\t\t\t\t_ignore\t\t= Integer.MAX_VALUE;\n+\n+\n+\t/**\n+\t *\tWhether to parse element text.\n+\t */\n+\tpublic boolean getParseText ()\n+\t{\n+\t\treturn _parseText;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhether to parse element text.\n+\t */\n+\tpublic void setParseText (boolean text)\n+\t{\n+\t\t_parseText = text;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhether to parse element comments.\n+\t */\n+\tpublic boolean getParseComments ()\n+\t{\n+\t\treturn _parseComments;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhether to parse element comments.\n+\t */\n+\tpublic void setParseComments (boolean comments)\n+\t{\n+\t\t_parseComments = comments;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe XML document location.\n+\t */\n+\tpublic Location getLocation ()\n+\t{\n+\t\treturn _location;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe lexical handler that should be registered with the SAX parser used\n+\t *\tby this class. Since the <code>org.xml.sax.ext</code> package is not\n+\t *\ta required part of SAX2, this handler might not be used by the parser.\n+\t */\n+\tpublic LexicalHandler getLexicalHandler ()\n+\t{\n+\t\treturn _lh;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe lexical handler that should be registered with the SAX parser used\n+\t *\tby this class. Since the <code>org.xml.sax.ext</code> package is not\n+\t *\ta required part of SAX2, this handler might not be used by the parser.\n+\t */\n+\tpublic void setLexicalHandler (LexicalHandler lh)\n+\t{\n+\t\t_lh = lh;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe XML document location.\n+\t */\n+\tpublic void setLocation (Location location)\n+\t{\n+\t\t_location = location;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhether to use the source name as the XML system id.\n+\t */\n+\tpublic boolean getSourceIsSystemId ()\n+\t{\n+\t\treturn _systemId;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhether to use the source name as the XML system id.\n+\t */\n+\tpublic void setSourceIsSystemId (boolean systemId)\n+\t{\n+\t\t_systemId = systemId;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhether this is a validating parser.\n+\t */\n+\tpublic boolean isValidating ()\n+\t{\n+\t\treturn _validating;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhether this is a validating parser.\n+\t */\n+\tpublic void setValidating (boolean validating)\n+\t{\n+\t\t_validating = validating;\n+\t}\n+\n+\n+\t/**\n+\t *\tExpected suffix for metadata resources, or null if unknown.\n+ \t */\n+\tpublic String getSuffix ()\n+\t{\n+\t\treturn _suffix;\n+\t}\n+\n+\n+\t/**\n+\t *\tExpected suffix for metadata resources, or null if unknown.\n+ \t */\n+\tpublic void setSuffix (String suffix)\n+\t{\n+\t\t_suffix = suffix;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhether parsed resource names are cached to avoid duplicate parsing.\n+\t */\n+\tpublic boolean isCaching ()\n+\t{\n+\t\treturn _caching;\n+\t}\n+\n+\n+\t/**\n+\t *\tWhether parsed resource names are cached to avoid duplicate parsing.\n+\t */\n+\tpublic void setCaching (boolean caching)\n+\t{\n+\t\t_caching = caching;\n+\t\tif (!caching)\n+\t\t\tclear ();\n+\t}\n+\n+\n+\t/**\n+\t *\tThe log to write to.\n+\t */\n+\tpublic Log getLog ()\n+\t{\n+\t\treturn _log;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe log to write to.\n+\t */\n+\tpublic void setLog (Log log)\n+\t{\n+\t\t_log = log;\n+\t}\n+\n+\n+\t/**\n+\t *\tClassloader to use for class name resolution.\n+\t */\n+\tpublic ClassLoader getClassLoader ()\n+\t{\n+\t\treturn _loader;\n+\t}\n+\n+\n+\t/**\n+\t *\tClassloader to use for class name resolution.\n+\t */\n+\tpublic void setClassLoader (ClassLoader loader)\n+\t{\n+\t\t_loader = loader;\n+\t}\n+\n+\n+\tpublic List getResults ()\n+\t{\n+\t\tif (_results == null)\n+\t\t\treturn Collections.EMPTY_LIST;\n+\t\treturn _results;\n+\t}\n+\n+\n+\tpublic void parse (String rsrc)\n+\t\tthrows IOException\n+\t{\n+\t\tif (rsrc != null)\n+\t\t\tparse (new ResourceMetaDataIterator (rsrc, _loader));\n+\t}\n+\n+\n+\tpublic void parse (URL url)\n+\t\tthrows IOException\n+\t{\n+\t\tif (url != null)\n+\t\t\tparse (new URLMetaDataIterator (url));\n+\t}\n+\n+\n+\tpublic void parse (File file)\n+\t\tthrows IOException\n+\t{\n+\t\tif (file == null)\n+\t\t\treturn;\n+\t\tif (!file.isDirectory ())\n+\t\t\tparse (new FileMetaDataIterator (file));\n+\t\telse\n+\t\t{\n+\t\t\tString suff = (_suffix == null) ? \"\" : _suffix;\n+\t\t\tparse (new FileMetaDataIterator (file, \n+\t\t\t\tnew SuffixMetaDataFilter (suff)));\n+\t\t}\n+\t}\n+\n+\n+\tpublic void parse (Class cls, boolean topDown)\n+\t\tthrows IOException\n+\t{\n+\t\tString suff = (_suffix == null) ? \"\" : _suffix;\n+\t\tparse (new ClassMetaDataIterator (cls, suff, topDown), !topDown);\n+\t}\n+\n+\n+\tpublic void parse (Reader xml, String sourceName)\n+\t\tthrows IOException\n+\t{\n+\t\tif (xml != null && (sourceName == null || !parsed (sourceName)))\n+\t\t\tparseNewResource (xml, sourceName);\n+\t}\n+\n+\n+\tpublic void parse (MetaDataIterator itr)\n+\t\tthrows IOException\n+\t{\n+\t\tparse (itr, false);\n+\t}\n+\n+\n+\t/**\n+\t *\tParse the resources returned by the given iterator, optionally stopping\n+\t *\twhen the first valid resource is found.\n+\t */\t\n+\tprivate void parse (MetaDataIterator itr, boolean stopFirst)\n+\t\tthrows IOException\n+\t{\n+\t\tif (itr == null)\n+\t\t\treturn;\n+\t\ttry\n+\t\t{\n+\t\t\tString sourceName;\n+\t\t\twhile (itr.hasNext ())\n+\t\t\t{\n+\t\t\t\tsourceName = itr.next ().toString ();\n+\t\t\t\tif (parsed (sourceName))\n+\t\t\t\t{\n+\t\t\t\t\tif (stopFirst)\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t\t// individual files of the resource might already be parsed\n+\t\t\t\t_sourceFile = itr.getFile ();\n+\t\t\t\tparseNewResource (new InputStreamReader (itr.getInputStream ()),\n+\t\t\t\t\tsourceName);\n+\t\t\t\tif (stopFirst)\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tfinally\n+\t\t{\n+\t\t\titr.close ();\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tParse a previously-unseen source.  All parsing methods delegate\n+\t *\tto this one.\n+\t */\n+\tprotected void parseNewResource (Reader xml, String sourceName)\n+\t\tthrows IOException\n+\t{\n+\t\tif (_log != null && _log.isInfoEnabled ())\n+\t\t\t_log.info (_loc.get (\"start-parse\", sourceName));\n+\n+\t\t// parse the metadata with a SAX parser\n+\t\ttry\n+\t\t{\n+\t\t\t_sourceName = sourceName;\n+\t\t\tSAXParser parser = XMLFactory.getSAXParser (_validating, true);\n+\t\t\tObject schema = null;\n+\t\t\tif (_validating)\n+\t\t\t{\n+\t\t\t\tschema = getSchemaSource ();\n+\t\t\t\tif (schema == null)\n+\t\t\t\t\txml = new DocTypeReader (xml, getDocType ());\n+\t\t\t}\n+\n+\t\t\tif (_parseComments || _lh != null)\n+\t\t\t\tparser.setProperty\n+\t\t\t\t\t(\"http://xml.org/sax/properties/lexical-handler\", this);\n+\n+\t\t\tif (schema != null)\n+\t\t\t{\n+\t\t\t\tparser.setProperty \n+\t\t\t\t\t(\"http://java.sun.com/xml/jaxp/properties/schemaLanguage\",\n+\t\t\t\t\t\"http://www.w3.org/2001/XMLSchema\");\n+\t\t\t\tparser.setProperty\n+\t\t\t\t\t(\"http://java.sun.com/xml/jaxp/properties/schemaSource\",\n+\t\t\t\t\tschema);\n+\t\t\t}\n+\t\t\t\n+\t\t\tInputSource is = new InputSource (xml);\n+\t\t\tif (_systemId && sourceName != null)\n+\t\t\t\tis.setSystemId (sourceName);\n+\t\t\tparser.parse (is, this);\n+\t\t\tfinish ();\n+\t\t}\n+\t\tcatch (SAXException se)\n+\t\t{\n+\t\t\tIOException ioe = new IOException (se.toString ());\n+\t\t\tJavaVersions.initCause (ioe, se);\n+\t\t\tthrow ioe;\n+\t\t}\n+\t\tfinally\n+\t\t{\n+\t\t\treset ();\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn true if the given source is parsed.  Otherwise, record that\n+\t *\tit will be parsed.\n+\t */\n+\tprotected boolean parsed (String src)\n+\t{\n+\t\tif (!_caching)\n+\t\t\treturn false;\n+\t\tif (_parsed == null)\n+\t\t\t_parsed = new HashMap ();\n+\n+\t\tClassLoader loader = currentClassLoader ();\n+\t\tboolean added;\n+\t\tsynchronized (_parsed)\n+\t\t{\n+\t\t\tSet set = (Set) _parsed.get (loader);\n+\t\t\tif (set == null)\n+\t\t\t{\n+\t\t\t\tset = new HashSet ();\n+\t\t\t\t_parsed.put (loader, set);\n+\t\t\t}\n+\t\t\tadded = set.add (src);\n+\t\t}\n+\t\tif (!added && _log != null && _log.isTraceEnabled ())\n+\t\t\t_log.trace (_loc.get (\"already-parsed\", src));\n+\t\treturn !added;\n+\t}\n+\n+\n+\tpublic void clear ()\n+\t{\n+\t\tif (_log != null && _log.isTraceEnabled ())\n+\t\t\t_log.trace (_loc.get (\"clear-parser\", this));\n+\t\tif (_parsed != null)\n+\t\t\t_parsed.clear ();\n+\t}\n+\n+\n+\tpublic void error (SAXParseException se)\n+\t\tthrows SAXException\n+\t{\n+\t\tthrow getException (se.toString ());\n+\t}\n+\n+\n+\tpublic void fatalError (SAXParseException se)\n+\t\tthrows SAXException\n+\t{\n+\t\tthrow getException (se.toString ());\n+\t}\n+\n+\n+\tpublic void setDocumentLocator (Locator locator)\n+\t{\n+\t\t_location.setLocator (locator);\n+\t}\n+\n+\n+\tpublic void startElement (String uri, String name, String qName,\n+\t\tAttributes attrs)\n+\t\tthrows SAXException\n+\t{\n+\t\t_depth++;\n+\t\tif (_depth <= _ignore)\n+\t\t\tif (!startElement (qName, attrs))\n+\t\t\t\tignoreContent (true);\n+\t}\n+\n+\n+\tpublic void endElement (String uri, String name, String qName)\n+\t\tthrows SAXException\n+\t{\n+\t\tif (_depth < _ignore)\n+\t\t\tendElement (qName);\n+\t\t_text = null;\n+\t\tif (_comments != null)\n+\t\t\t_comments.clear ();\n+\t\tif (_depth == _ignore)\n+\t\t\t_ignore = Integer.MAX_VALUE;\n+\t\t_depth--;\n+\t}\n+\n+\n+\tpublic void characters (char[] ch, int start, int length)\n+\t{\n+\t\tif (_parseText && _depth <= _ignore)\n+\t\t{\n+\t\t\tif (_text == null)\n+\t\t\t\t_text = new StringBuffer ();\n+\t\t\t_text.append (ch, start, length);\n+\t\t}\n+\t}\n+\n+\n+\tpublic void comment (char[] ch, int start, int length)\n+\t\tthrows SAXException\n+\t{\n+\t\tif (_parseComments && _depth <= _ignore)\n+\t\t{\n+\t\t\tif (_comments == null)\n+\t\t\t\t_comments = new ArrayList (3);\n+\t\t\t_comments.add (String.valueOf (ch, start, length));\n+\t\t}\n+\t\tif (_lh != null)\n+\t\t\t_lh.comment (ch, start, length);\n+\t}\n+\n+\n+\tpublic void startCDATA ()\n+\t\tthrows SAXException\n+\t{\n+\t\tif (_lh != null)\n+\t\t\t_lh.startCDATA ();\n+\t}\n+\n+\n+\tpublic void endCDATA ()\n+\t\tthrows SAXException\n+\t{\n+\t\tif (_lh != null)\n+\t\t\t_lh.endCDATA ();\n+\t}\n+\n+\n+\tpublic void startDTD (String name, String publicId, String systemId)\n+\t\tthrows SAXException\n+\t{\n+\t\tif (_lh != null)\n+\t\t\t_lh.startDTD (name, publicId, systemId);\n+\t}\n+\n+\n+\tpublic void endDTD ()\n+\t\tthrows SAXException\n+\t{\n+\t\tif (_lh != null)\n+\t\t\t_lh.endDTD ();\n+\t}\n+\n+\n+\tpublic void startEntity (String name)\n+\t\tthrows SAXException\n+\t{\n+\t\tif (_lh != null)\n+\t\t\t_lh.startEntity (name);\n+\t}\n+\n+\n+\tpublic void endEntity (String name)\n+\t\tthrows SAXException\n+\t{\n+\t\tif (_lh != null)\n+\t\t\t_lh.endEntity (name);\n+\t}\n+\n+\n+\t/**\n+\t *\tOverride this method marking the start of some element.  If this method\n+\t *\treturns false, the content of the element and the end element event will\n+\t *\tbe ignored.\n+\t */\n+\tprotected abstract boolean startElement (String name, Attributes attrs)\n+\t\tthrows SAXException;\n+\n+\n+\t/**\n+\t *\tOverride this method marking the end of some element.\n+\t */\n+\tprotected abstract void endElement (String name)\n+\t\tthrows SAXException;\n+\n+\n+\t/**\n+\t *\tAdd a result to be returned from the current parse.\n+\t */\n+\tprotected void addResult (Object result)\n+\t{\n+\t\tif (_log != null && _log.isTraceEnabled ())\n+\t\t\t_log.trace (_loc.get (\"add-result\", result));\n+\t\t_curResults.add (result);\n+\t}\n+\n+\n+\t/**\n+\t *\tOverride this method to finish up after a parse; this is only\n+\t *\tcalled if no errors are encountered during parsing.  Subclasses should\n+\t *\tcall <code>super.finish ()</code> to resolve superclass state.\n+\t */\n+\tprotected void finish ()\n+\t{\n+\t\tif (_log != null && _log.isTraceEnabled ())\n+\t\t\t_log.trace (_loc.get (\"end-parse\", getSourceName ()));\n+\t\t_results = new ArrayList (_curResults);\n+\t}\n+\n+\n+\t/**\n+\t *\tOverride this method to clear any state and ready the parser for\n+\t *\ta new document.  Subclasses should call\n+\t *\t<code>super.reset ()</code> to clear superclass state.\n+\t */\n+\tprotected void reset ()\n+\t{\n+\t\t_curResults.clear ();\n+\t\t_curLoader = null;\n+\t\t_sourceName = null;\n+\t\t_sourceFile = null;\n+\t\t_depth = -1;\n+\t\t_ignore = Integer.MAX_VALUE;\n+\t\tif (_comments != null)\n+\t\t\t_comments.clear ();\n+\t}\n+\n+\n+\t/**\n+\t *\tImplement to return the XML schema source for the document.  Returns\n+\t *\tnull by default.  May return:\n+\t *\t<ul>\n+\t *\t<li><code>String</code> pointing to schema URI.</li>\n+\t *\t<li><code>InputStream</code> containing schema contents.</li> \n+\t *\t<li><code>InputSource</code> containing schema contents.</li> \n+\t *\t<li><code>File</code> containing schema contents.</li> \n+\t *\t<li>Array of any of the above elements.</li>\n+\t *\t</ul>\n+\t */\n+\tprotected Object getSchemaSource ()\n+\t\tthrows IOException\n+\t{\n+\t\treturn null;\n+\t}\n+\n+\n+\t/**\n+\t *\tOverride this method to return any <code>DOCTYPE</code> declaration\n+\t *\tthat should be dynamically included in xml documents that will be\n+\t *\tvalidated.  Returns null by default.\n+\t */\n+\tprotected Reader getDocType ()\n+\t\tthrows IOException\n+\t{\n+\t\treturn null;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the name of the source file being parsed.\n+\t */\n+\tprotected String getSourceName ()\n+\t{\n+\t\treturn _sourceName;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the file of the source being parsed.\n+ \t */\n+\tprotected File getSourceFile ()\n+\t{\n+\t\treturn _sourceFile;\n+\t}\n+\n+\n+\t/**\n+\t *\tAdd current comments to the given entity.  By default, assumes entity\n+\t *\tis {@link Commentable}.\n+\t */\n+\tprotected void addComments (Object obj)\n+\t{\n+\t\tString[] comments = currentComments ();\n+\t\tif (comments.length > 0 && obj instanceof Commentable)\n+\t\t\t((Commentable) obj).setComments (comments);\n+\t}\n+\n+\n+\t/**\n+\t *\tArray of comments for the current node, or empty array if none.\n+\t */\n+\tprotected String[] currentComments ()\n+\t{\n+\t\tif (_comments == null || _comments.isEmpty ())\n+\t\t\treturn Commentable.EMPTY_COMMENTS;\n+\t\treturn (String[]) _comments.toArray (new String[_comments.size ()]);\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the text value within the current node.\n+\t */\n+\tprotected String currentText ()\n+\t{\n+\t\tif (_text == null)\n+\t\t\treturn \"\";\n+\t\treturn _text.toString ().trim ();\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the current location within the source file.\n+\t */\n+\tprotected String currentLocation ()\n+\t{\n+\t\treturn \" [\" + _loc.get (\"loc-prefix\") + _location.getLocation () + \"]\";\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the parse depth.  Within the root element, the depth is 0,\n+\t *\twithin the first nested element, it is 1, and so forth.\n+\t */\n+\tprotected int currentDepth ()\n+\t{\n+\t\treturn _depth;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the class loader to use when resolving resources and loading\n+\t *\tclasses.\n+\t */\n+\tprotected ClassLoader currentClassLoader ()\n+\t{\n+\t\tif (_loader != null)\n+\t\t\treturn _loader;\n+\t\tif (_curLoader == null)\n+\t\t\t_curLoader = Thread.currentThread ().getContextClassLoader ();\n+\t\treturn _curLoader;\n+\t}\n+\n+\n+\t/**\n+\t *\tIgnore all content below the current element.\n+\t *\n+\t *\t@param\tignoreEnd\twhether to ignore the end element event\n+\t */\n+\tprotected void ignoreContent (boolean ignoreEnd)\n+\t{\n+\t\t_ignore = _depth;\n+\t\tif (!ignoreEnd)\n+\t\t\t_ignore++;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturns a SAXException with the source file name and the given error\n+\t *\tmessage.\n+\t */\n+\tprotected SAXException getException (String msg)\n+\t{\n+\t\treturn new SAXException (getSourceName () + currentLocation () +\n+\t\t\t\": \" + msg);\n+\t}\n+\n+\n+\t/**\n+\t *\tReturns a SAXException with the source file name and the given error\n+\t *\tmessage.\n+\t */\n+\tprotected SAXException getException (String msg, Throwable cause)\n+\t{\n+\t\tif (cause != null && _log != null && _log.isTraceEnabled ())\n+\t\t\t_log.trace (cause);\n+\t\treturn new SAXException (getSourceName () + currentLocation () +\n+\t\t\t\": \" + msg + \" [\" + cause + \"]\");\n+\t}\n+}"},{"sha":"d4c832735864c1f46b59314633e7d3cca2682641","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/XMLMetaDataSerializer.java","status":"added","additions":418,"deletions":0,"changes":418,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/XMLMetaDataSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/XMLMetaDataSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/XMLMetaDataSerializer.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,418 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+import javax.xml.transform.*;\n+import javax.xml.transform.sax.*;\n+import javax.xml.transform.stream.*;\n+\n+import org.xml.sax.*;\n+import org.xml.sax.helpers.*;\n+import org.xml.sax.ext.*;\n+\n+import org.apache.openjpa.lib.log.*;\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.lib.xml.*;\n+\n+\n+/**\n+ *\t<p>Abstract base type for serlializers that transfer groups of objects\n+ *\tto XML.  Includes a way of serializing objects back to the XML files\n+ *\tthey were parsed from.</p>\n+ *\n+ *\t<p>Serializers are not thread safe.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public abstract class XMLMetaDataSerializer\n+\timplements MetaDataSerializer\n+{\n+\tprivate static final Localizer _loc = Localizer.forPackage\n+\t\t(XMLMetaDataSerializer.class);\n+\tprivate static final SAXTransformerFactory _factory =\n+\t\t(SAXTransformerFactory) TransformerFactory.newInstance ();\n+\n+\tprivate Log _log = null;\n+\n+\t// current serialization state\n+\tprivate final AttributesImpl \t_attrs\t\t= new AttributesImpl ();\n+\tprivate ContentHandler \t\t\t_handler \t= null;\n+\tprivate int\t\t\t\t\t\t_flags\t\t= 0;\n+\tprivate File\t\t\t\t\t_backup\t\t= null;\n+\n+\n+\t/**\n+\t *\tThe log to write to.\n+ \t */\n+\tpublic Log getLog ()\n+\t{\n+\t\treturn _log;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe log to write to.\n+ \t */\n+\tpublic void setLog (Log log)\n+\t{\n+\t\t_log = log;\n+\t}\n+\n+\n+\tpublic void serialize (int flags)\n+\t\tthrows IOException\n+\t{\n+\t\tserialize ((Map) null, flags);\n+\t}\n+\n+\n+\tpublic void serialize (Map output, int flags)\n+\t\tthrows IOException\n+\t{\n+\t\tMap files = getFileMap ();\n+\t\tif (files == null)\n+\t\t\treturn;\n+\n+\t\t// for each file, serialize objects\n+\t\tMap.Entry entry;\n+\t\tfor (Iterator itr = files.entrySet ().iterator (); itr.hasNext ();)\n+\t\t{\n+\t\t\tentry = (Map.Entry) itr.next ();\n+\t\t\tFile file = (File) entry.getKey ();\n+\t\t\tCollection fileObjs = (Collection) entry.getValue ();\n+\n+\t\t\tif (_log != null && _log.isInfoEnabled ())\n+\t\t\t\t_log.info (_loc.get (\"ser-file\", file));\n+\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tTransformerHandler trans = _factory.newTransformerHandler ();\n+\t\t\t\tWriter writer;\n+\t\t\t\tif (output == null)\n+\t\t\t\t{\n+\t\t\t\t\t_backup = prepareWrite (file);\n+\t\t\t\t\twriter = new FileWriter (file);\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t\twriter = new StringWriter ();\n+\n+\t\t\t\tWriter xml = writer;\n+\t\t\t\tif ((flags & PRETTY) > 0)\n+\t\t\t\t\txml = new XMLWriter (writer);\n+\t\t\t\ttrans.setResult (new StreamResult (xml));\n+\t\t\t\tserialize (fileObjs, trans, flags);\n+\n+\t\t\t\tif (output != null)\n+\t\t\t\t\toutput.put (file, ((StringWriter) writer).toString ());\n+\t\t\t}\n+\t\t\tcatch (SAXException se)\n+\t\t\t{\n+\t\t\t\tthrow new IOException (se.toString ());\n+\t\t\t}\n+\t\t\tcatch (TransformerConfigurationException tce)\n+\t\t\t{\n+\t\t\t\tthrow new IOException (tce.toString ());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tPrepare to write to the given file.  Back up the file and make sure the\n+\t *\tpath to it is created.\n+\t */\n+\tprotected File prepareWrite (File file)\n+\t\tthrows IOException\n+\t{\n+\t\tFile backup = Files.backup (file, false);\n+\t\tif (backup == null)\n+\t\t{\n+\t\t\tFile parent = file.getParentFile ();\n+\t\t\tif (parent != null && !parent.exists ())\n+\t\t\t\tparent.mkdirs ();\n+\t\t}\n+\t\treturn backup;\n+\t}\n+\n+\n+\t/** \n+\t *  Returns a {@link Map} with keys of the {@link File} to be\n+\t *  written to, and values of a {@link Collection} of\n+\t *  {@link SourceTracker} instances.\n+\t */\n+\tprotected Map getFileMap ()\n+\t{\n+\t\tCollection objs = getObjects ();\n+\t\tif (objs == null || objs.isEmpty ())\n+\t\t\treturn null;\n+\n+\t\t// create a map of files to lists of objects\n+\t\tMap files = new HashMap ();\n+\t\tFile file;\n+\t\tCollection fileObjs;\n+\t\tObject obj;\n+\t\tfor (Iterator itr = objs.iterator (); itr.hasNext ();)\n+\t\t{\n+\t\t\tobj = itr.next ();\n+\t\t\tfile = getSourceFile (obj);\n+\t\t\tif (file == null)\n+\t\t\t{\n+\t\t\t\tif (_log != null && _log.isTraceEnabled ())\n+\t\t\t\t\t_log.trace (_loc.get (\"no-file\", obj));\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\n+\t\t\tfileObjs = (Collection) files.get (file);\n+\t\t\tif (fileObjs == null)\t\n+\t\t\t{\n+\t\t\t\tfileObjs = new LinkedList ();\n+\t\t\t\tfiles.put (file, fileObjs);\n+\t\t\t}\n+\t\t\tfileObjs.add (obj);\n+\t\t}\n+\n+\t\treturn files;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the source file for the given instance.  By default, checks\n+\t *\tto see if the instance implements {@link SourceTracker}.\n+\t */\n+\tprotected File getSourceFile (Object obj)\n+\t{\n+\t\tif (obj instanceof SourceTracker) \n+\t\t\treturn ((SourceTracker) obj).getSourceFile ();\n+\t\treturn null;\n+\t}\n+\n+\n+\tpublic void serialize (File file, int flags)\n+\t\tthrows IOException\n+\t{\n+\t\tif (_log != null)\n+\t\t\t_log.info (_loc.get (\"ser-file\", file));\n+\n+\t\t_backup = prepareWrite (file);\n+\t\tFileWriter out = new FileWriter (file.getCanonicalPath (), \n+\t\t\t(flags & APPEND) > 0);\n+\t\tserialize (out, flags);\n+\t\tout.close ();\n+\t}\n+\n+\n+\tpublic void serialize (Writer out, int flags)\n+\t\tthrows IOException\n+\t{\n+\t\ttry\n+\t\t{\n+\t\t\tif ((flags & PRETTY) > 0)\n+\t\t\t\tserialize (new StreamResult (new XMLWriter (out)), flags);\n+\t\t\telse\n+\t\t\t\tserialize (new StreamResult (out), flags);\n+\t\t}\n+\t\tcatch (SAXException se)\n+\t\t{\n+\t\t\tthrow new IOException (se.toString ());\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tSerialize the current set of objects to the given result.\n+\t */\n+\tpublic void serialize (Result result, int flags)\n+\t\tthrows SAXException\n+\t{\n+\t\ttry\n+\t\t{\n+\t\t\tTransformerHandler trans = _factory.newTransformerHandler ();\t\t\n+\t\t\ttrans.setResult (result);\n+\t\t\tserialize (trans, flags);\n+\t\t}\n+\t\tcatch (TransformerConfigurationException tce)\n+\t\t{\n+\t\t\tthrow new SAXException (tce);\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tSerilize the current set of objects to a series of SAX events on the \n+\t *\tgiven handler.\n+\t */\n+\tpublic void serialize (ContentHandler handler, int flags)\n+\t\tthrows SAXException\n+\t{\n+\t\tserialize (getObjects (), handler, flags);\n+\t}\n+\n+\n+\t/**\n+\t *\tSerialize the given collection of objects to the given handler.\n+\t */\n+\tprivate void serialize (Collection objs, ContentHandler handler, int flags)\n+\t\tthrows SAXException\n+\t{\n+\t\tif (_log != null && _log.isTraceEnabled ())\n+\t\t\t_log.trace (_loc.get (\"ser-objs\", objs));\n+\n+\t\t_handler = handler;\n+\t\t_flags = flags;\n+\t\ttry\n+\t\t{\n+\t\t\tif (!objs.isEmpty ())\n+\t\t\t{\n+\t\t\t\thandler.startDocument ();\n+\t\t\t\tserialize (objs);\n+\t\t\t\thandler.endDocument ();\n+\t\t\t}\n+\t\t}\n+\t\tfinally\n+\t\t{\n+\t\t\treset ();\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tWhether this serialization is in verbose mode.\n+\t */\n+\tprotected boolean isVerbose ()\n+\t{\n+\t\treturn (_flags & VERBOSE) > 0;\n+\t}\n+\n+\n+\t/**\n+\t *\tThe backup file made for the current file being parsed.\n+\t */\n+\tprotected File currentBackupFile ()\n+\t{\n+\t\treturn _backup;\n+\t}\n+\n+\n+\t/**\n+\t *\tStart an element with the current attribute settings.  Clears the\n+\t *\tattributes as well.\n+\t */\n+\tprotected void startElement (String name)\n+\t\tthrows SAXException\n+\t{\n+\t\t_handler.startElement (\"\", name, name, _attrs);\n+\t\t_attrs.clear ();\n+\t}\n+\n+\n+\t/**\n+\t *\tEnd the current element.\n+\t */\n+\tprotected void endElement (String name)\n+\t\tthrows SAXException\n+\t{\n+\t\t_handler.endElement (\"\", name, name);\n+\t}\n+\n+\n+\t/**\n+\t *\tAdd text to the current element.\n+\t */\n+\tprotected void addText (String text)\n+\t\tthrows SAXException\n+\t{\n+\t\t_handler.characters (text.toCharArray (), 0, text.length ());\n+\t}\n+\n+\n+\t/**\n+\t *\tAdd an attribute to the current group.\n+\t */\n+\tprotected void addAttribute (String name, String value)\n+\t{\n+\t\t_attrs.addAttribute (\"\", name, name, \"CDATA\", value);\n+\t}\n+\n+\n+\t/**\n+\t *\tThe current attributes.\n+\t */\n+\tprotected Attributes getAttributes ()\n+\t{\n+\t\treturn _attrs;\n+\t}\n+\n+\n+\t/**\n+\t *\tAdd a comment to the stream.\n+\t */\n+\tprotected void addComments (String[] comments)\n+\t\tthrows SAXException\n+\t{\n+\t\tif (comments == null || comments.length == 0\n+\t\t\t|| !(_handler instanceof LexicalHandler))\n+\t\t\treturn;\n+\n+\t\tLexicalHandler lh = (LexicalHandler) _handler;\n+\t\tchar[] chars;\n+\t\tfor (int i = 0; i < comments.length; i++)\n+\t\t{\n+\t\t\tchars = comments[i].toCharArray ();\n+\t\t\tlh.comment (chars, 0, chars.length);\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t *\tWrite the given entity's comments.  By default, tests if entity is\n+\t *\t{@link Commentable}.\n+\t */\n+\tprotected void addComments (Object obj)\n+\t\tthrows SAXException\n+\t{\n+\t\tif (obj instanceof Commentable)\n+\t\t\taddComments (((Commentable) obj).getComments ());\n+\t}\n+\n+\n+\t/**\n+\t *\tReset serialization state for the next document.\n+\t */\n+\tprotected void reset ()\n+\t{\n+\t\t_attrs.clear ();\n+\t\t_handler = null;\n+\t\t_flags = 0;\n+\t\t_backup = null;\n+\t}\n+\n+\n+\t/**\n+\t *\tSerialize the given set of objects.\n+\t */\n+\tprotected abstract void serialize (Collection objs)\n+\t\tthrows SAXException;\n+\n+\n+\t/**\n+\t *\tReturn the current set of objects for serialization.\n+\t */\n+\tprotected abstract Collection getObjects ();\n+}"},{"sha":"af838acbfa1802609cd238ed99517a3636e204e8","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/ZipFileMetaDataIterator.java","status":"added","additions":156,"deletions":0,"changes":156,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/ZipFileMetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/ZipFileMetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/ZipFileMetaDataIterator.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.io.*;\n+import java.net.*;\n+import java.util.*;\n+import java.util.zip.*;\n+\n+\n+/**\n+ *\t<p>Iterator over all metadata resources in a given zip file.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public class ZipFileMetaDataIterator\n+\timplements MetaDataIterator, MetaDataFilter.Resource\n+{\n+\tprivate final ZipFile\t\t\t_file;\n+\tprivate final MetaDataFilter\t_filter;\n+\tprivate final Enumeration \t\t_entries;\n+\tprivate final boolean\t\t\t_close;\n+\tprivate ZipEntry\t\t\t\t_entry \t= null;\n+\tprivate ZipEntry\t\t\t\t_last\t= null;\n+\n+\n+\t/**\n+\t *\tConstructor; supply zip/jar URL and optional file filter.\n+\t */\n+\tpublic ZipFileMetaDataIterator (URL url, MetaDataFilter filter)\n+\t\tthrows IOException\n+\t{\n+\t\t_file = (url == null) ? null : (ZipFile) url.getContent ();\n+\t\t_filter = filter;\n+\t\t_entries = (_file == null) ? null : _file.entries ();\n+\t\t_close = false;\n+\t}\n+\n+\n+\t/**\n+\t *\tConstructor; supply zip file and optional file filter.\n+\t */\n+\tpublic ZipFileMetaDataIterator (ZipFile file, MetaDataFilter filter)\n+\t{\n+\t\t_file = file;\n+\t\t_filter = filter;\n+\t\t_entries = (file == null) ? null : file.entries ();\n+\t\t_close = true;\n+\t}\n+\n+\n+\tpublic boolean hasNext ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (_entries == null)\n+\t\t\treturn false;\n+\n+\t\t// search for next metadata file\n+\t\twhile (_entry == null && _entries.hasMoreElements ())\n+\t\t{\n+\t\t\t_entry = (ZipEntry) _entries.nextElement ();\n+\t\t\tif (_filter != null && !_filter.matches (this))\n+\t\t\t\t_entry = null;\n+\t\t}\n+\t\treturn _entry != null;\n+\t}\n+\n+\n+\tpublic Object next ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (!hasNext ())\n+\t\t\tthrow new NoSuchElementException ();\n+\t\tString ret = _entry.getName (); \n+\t\t_last = _entry;\n+\t\t_entry = null;\n+\t\treturn ret;\n+\t}\n+\n+\n+\tpublic InputStream getInputStream ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (_last == null)\n+\t\t\tthrow new IllegalStateException ();\n+\t\treturn _file.getInputStream (_last);\n+\t}\n+\n+\n+\tpublic File getFile ()\n+\t{\n+\t\tif (_last == null)\n+\t\t\tthrow new IllegalStateException ();\n+\t\treturn null;\n+\t}\n+\n+\n+\tpublic void close ()\n+\t{\n+\t\tif (_close)\n+\t\t\ttry { _file.close (); } catch (IOException ioe) {}\n+\t}\n+\n+\n+\t//////////////////////////////////////////\n+\t// MetaDataFilter.Resource implementation\n+\t//////////////////////////////////////////\n+\n+\n+\tpublic String getName ()\n+\t{\n+\t\treturn _entry.getName ();\n+\t}\n+\n+\n+\tpublic byte[] getContent ()\n+\t\tthrows IOException\n+\t{\n+\t\tlong size = _entry.getSize ();\n+\t\tif (size == 0)\n+\t\t\treturn new byte[0];\n+\n+\t\tInputStream in = _file.getInputStream (_entry);\n+\t\tbyte[] content;\n+\t\tif (size < 0)\n+\t\t{\n+\t\t\tByteArrayOutputStream bout = new ByteArrayOutputStream ();\n+\t\t\tbyte[] buf = new byte[1024];\n+\t\t\tfor (int r; (r = in.read (buf)) != -1; bout.write (buf, 0, r));\n+\t\t\tcontent = bout.toByteArray ();\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tcontent = new byte[(int) size];\n+\t\t\tin.read (content);\n+\t\t}\n+\t\tin.close ();\n+\t\treturn content;\n+\t}\n+}\n+"},{"sha":"ceefd53c89ecff8f541523be7a850517197bd8ea","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/ZipStreamMetaDataIterator.java","status":"added","additions":182,"deletions":0,"changes":182,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/ZipStreamMetaDataIterator.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/ZipStreamMetaDataIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/ZipStreamMetaDataIterator.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.meta;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.zip.*;\n+\n+\n+/**\n+ *\t<p>Iterator over all metadata resources in a given zip input stream.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+public class ZipStreamMetaDataIterator\n+\timplements MetaDataIterator, MetaDataFilter.Resource\n+{\n+\tprivate final ZipInputStream\t_stream;\n+\tprivate final MetaDataFilter\t_filter;\n+\tprivate ZipEntry\t\t\t\t_entry \t= null;\n+\tprivate ZipEntry\t\t\t\t_last \t= null;\n+\tprivate byte[]\t\t\t\t\t_buf\t= null;\n+\n+\n+\t/**\n+\t *\tConstructor; supply zip stream and optional metadata filter.\n+\t */\n+\tpublic ZipStreamMetaDataIterator (ZipInputStream stream, \n+\t\tMetaDataFilter filter)\n+\t{\n+\t\t_stream = stream;\n+\t\t_filter = filter;\n+\t}\n+\n+\n+\tpublic boolean hasNext ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (_stream == null)\n+\t\t\treturn false;\n+\t\tif (_entry != null)\n+\t\t\treturn true;\n+\n+\t\t// close last rsrc\n+\t\tif (_buf == null && _last != null)\n+\t\t\t_stream.closeEntry ();\n+\t\t_last = null;\n+\t\t_buf = null;\n+\n+\t\t// search for next file\n+\t\tZipEntry entry;\n+\t\twhile (_entry == null && (entry = _stream.getNextEntry ()) != null)\n+\t\t{\n+\t\t\t_entry = entry;\n+\t\t\tif (_filter != null && !_filter.matches (this))\n+\t\t\t{\n+\t\t\t\t_entry = null;\n+\t\t\t\t_stream.closeEntry ();\n+\t\t\t}\n+\t\t}\n+\t\treturn _entry != null;\n+\t}\n+\n+\n+\tpublic Object next ()\n+\t\tthrows IOException\n+\t{\n+\t\tif (!hasNext ())\n+\t\t\tthrow new NoSuchElementException ();\n+\t\tString ret = _entry.getName ();\n+\t\t_last = _entry;\n+\t\t_entry = null;\n+\t\treturn ret;\n+\t}\n+\n+\n+\tpublic InputStream getInputStream ()\n+\t{\n+\t\tif (_last == null)\n+\t\t\tthrow new IllegalStateException ();\n+\n+\t\tif (_buf != null)\n+\t\t\treturn new ByteArrayInputStream (_buf);\n+\t\treturn new NoCloseInputStream ();\n+\t}\n+\n+\n+\tpublic File getFile ()\n+\t{\n+\t\treturn null;\n+\t}\n+\n+\n+\tpublic void close ()\n+\t{\n+\t\ttry { _stream.close (); } catch (IOException ioe) {}\n+\t}\n+\n+\n+\t//////////////////////////////////////////\n+\t// MetaDataFilter.Resource implementation\n+\t//////////////////////////////////////////\n+\n+\n+\tpublic String getName ()\n+\t{\n+\t\treturn _entry.getName ();\n+\t}\n+\n+\n+\tpublic byte[] getContent ()\n+\t\tthrows IOException\n+\t{\n+\t\t// buffer content so that future calls to getInputStream can read\n+\t\t// the same data\n+\t\tint size = (int) _entry.getSize ();\n+\t\tif (size < 0)\n+\t\t{\n+\t\t\tByteArrayOutputStream bout = new ByteArrayOutputStream ();\n+\t\t\tbyte[] buf = new byte[1024];\n+\t\t\tfor (int r; (r = _stream.read (buf)) != -1; bout.write (buf, 0, r));\n+\t\t\t_buf = bout.toByteArray ();\n+\t\t}\n+\t\telse \n+\t\t{\n+\t\t\t_buf = new byte[size];\t\t\n+\t\t\t_stream.read (_buf);\n+\t\t}\n+\t\t_stream.closeEntry ();\n+\t\treturn _buf;\n+\t}\n+\n+\n+\t/**\n+\t *\tNon-closing input stream used to make sure the underlying zip\n+\t *\tstream is not closed.\n+\t */\n+\tprivate class NoCloseInputStream\n+\t\textends InputStream\n+\t{\n+\t\tpublic int available ()\n+\t\t\tthrows IOException\n+\t\t{\n+\t\t\treturn _stream.available ();\n+\t\t}\n+\n+\n+\t\tpublic int read ()\n+\t\t\tthrows IOException\n+\t\t{\n+\t\t\treturn _stream.read ();\n+\t\t}\n+\n+\n+\t\tpublic int read (byte[] b, int off, int len)\n+\t\t\tthrows IOException\n+\t\t{\n+\t\t\treturn _stream.read (b, off, len);\n+\t\t}\n+\n+\n+\t\tpublic void close ()\n+\t\t{\n+\t\t}\n+\t}\n+}\n+"},{"sha":"31399be115ff6d0ffa4b7e3ac2c61961c539efb2","filename":"openjpa-lib/java/org/apache/openjpa/lib/meta/package.html","status":"added","additions":23,"deletions":0,"changes":23,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/package.html","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/meta/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/meta/package.html?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+<html>\n+<body>\n+\t<p><strong>Metadata Framework</strong></p>\n+\t<p>\n+\t\tExtendable framework for metadata parsing and serializing.\n+\t</p>\n+</body>\n+</html>"},{"sha":"fa8ee8626f71a233d96a40afde0aade9f9a47e9a","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/AbstractListIterator.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/AbstractListIterator.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/AbstractListIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/AbstractListIterator.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.rop;\n+\n+\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+\n+\n+/**\n+ *\t<p>Abstract read-only list iterator.</p>\n+ *\n+ *\t@author\t\tAbe White\n+ *\t@nojavadoc\n+ */\n+abstract class AbstractListIterator\n+\timplements ListIterator\n+{\n+\tprivate static final Localizer _loc = Localizer.forPackage\n+\t\t(AbstractListIterator.class);\n+\n+\n+\tpublic void add (Object o)\n+\t{\n+\t\tthrow new UnsupportedOperationException (_loc.get (\"read-only\"));\n+\t}\n+\n+\n+\tpublic void set (Object o)\n+\t{\n+\t\tthrow new UnsupportedOperationException (_loc.get (\"read-only\"));\n+\t}\n+\n+\n+\tpublic void remove ()\n+\t{\n+\t\tthrow new UnsupportedOperationException (_loc.get (\"read-only\"));\n+\t}\n+}"},{"sha":"62791c8c6cee7221b84864ee1eb86598e2e9bac9","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/AbstractNonSequentialResultList.java","status":"added","additions":225,"deletions":0,"changes":225,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/AbstractNonSequentialResultList.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/AbstractNonSequentialResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/AbstractNonSequentialResultList.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,225 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.rop;\n+\n+\n+import java.util.*;\n+\n+import org.apache.commons.lang.*;\n+\n+\n+/** \n+ *  <p>Abstract base class for random-access result lists.  Unlike the\n+ *\t{@link AbstractList}, this class doesn't rely on the \n+ *\t{@link Collection#size} method.</p>\n+ *  \n+ *  @author Abe White\n+ *\t@nojavadoc\n+ */\n+public abstract class AbstractNonSequentialResultList\n+\textends AbstractResultList\n+{\n+\tprotected static final Object PAST_END = new Object ();\n+\n+\n+\t/**\n+\t *\tImplement this method and {@link #size}.  Return {@link #PAST_END}\n+\t *\tif the index is out of bounds.\n+ \t */\n+\tprotected abstract Object getInternal (int index);\n+\n+\n+\tpublic boolean contains (Object o)\n+\t{\n+\t\tassertOpen ();\n+\t\tObject obj;\n+\t\tfor (int i = 0; true; i++)\n+\t\t{\n+\t\t\tobj = getInternal (i);\n+\t\t\tif (obj == PAST_END)\n+\t\t\t\tbreak;\n+\t\t\tif (ObjectUtils.equals (o, obj))\n+\t\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean containsAll (Collection c)\n+\t{\n+\t\tassertOpen ();\n+\t\tfor (Iterator itr = c.iterator (); itr.hasNext ();)\n+\t\t\tif (!contains (itr.next ()))\n+\t\t\t\treturn false;\n+\t\treturn true;\n+\t}\n+\n+\n+\tpublic Object get (int index)\n+\t{\n+\t\tassertOpen ();\n+\t\tObject obj = getInternal (index);\n+\t\tif (obj == PAST_END)\n+\t\t\tthrow new NoSuchElementException ();\n+\t\treturn obj;\n+\t}\n+\n+\n+\tpublic int indexOf (Object o)\n+\t{\n+\t\tassertOpen ();\n+\t\tObject obj;\n+\t\tfor (int i = 0; true; i++)\n+\t\t{\n+\t\t\tobj = getInternal (i);\n+\t\t\tif (obj == PAST_END)\n+\t\t\t\tbreak;\n+\t\t\tif (ObjectUtils.equals (o, obj))\n+\t\t\t\treturn i;\n+\t\t}\n+\t\treturn -1;\n+\t}\n+\n+\n+\tpublic int lastIndexOf (Object o)\n+\t{\n+\t\tassertOpen ();\n+\t\tint index = -1;\n+\t\tObject obj;\n+\t\tfor (int i = 0; true; i++)\n+\t\t{\n+\t\t\tobj = getInternal (i);\n+\t\t\tif (obj == PAST_END)\n+\t\t\t\tbreak;\n+\t\t\tif (ObjectUtils.equals (o, obj))\n+\t\t\t\tindex = i;\n+\t\t}\n+\t\treturn index;\n+\t}\n+\n+\n+\tpublic boolean isEmpty ()\n+\t{\n+\t\tassertOpen ();\n+\t\treturn getInternal (0) == PAST_END;\n+\t}\n+\n+\n+\tpublic Iterator iterator ()\n+\t{\n+\t\treturn listIterator ();\n+\t}\n+\n+\n+\tpublic ListIterator listIterator ()\n+\t{\n+\t\treturn listIterator (0);\n+\t}\n+\n+\n+\tpublic ListIterator listIterator (int index)\n+\t{\n+\t\treturn new ResultListIterator (new Itr (index), this);\n+\t}\n+\n+\n+\tpublic Object[] toArray ()\n+\t{\n+\t\tassertOpen ();\n+\t\tArrayList list = new ArrayList ();\n+\t\tObject obj;\n+\t\tfor (int i = 0; true; i++)\n+\t\t{\n+\t\t\tobj = getInternal (i);\n+\t\t\tif (obj == PAST_END)\n+\t\t\t\tbreak;\n+\t\t\tlist.add (obj);\n+\t\t}\n+\t\treturn list.toArray ();\n+\t}\n+\n+\n+\tpublic Object[] toArray (Object[] a)\n+\t{\n+\t\tassertOpen ();\n+\t\tArrayList list = new ArrayList ();\n+\t\tObject obj;\n+\t\tfor (int i = 0; true; i++)\n+\t\t{\n+\t\t\tobj = getInternal (i);\n+\t\t\tif (obj == PAST_END)\n+\t\t\t\tbreak;\n+\t\t\tlist.add (obj);\n+\t\t}\n+\t\treturn list.toArray (a);\n+\t}\n+\n+\n+\tprivate class Itr\n+\t\textends AbstractListIterator\n+\t{\n+\t\tprivate int \t_idx\t= 0;\n+\t\tprivate Object\t_next\t= PAST_END;\n+\n+\n+\t\tpublic Itr (int index)\n+\t\t{\n+\t\t\t_idx = index;\n+\t\t}\n+\n+\n+\t\tpublic int nextIndex ()\n+\t\t{\n+\t\t\treturn _idx;\n+\t\t}\n+\n+\n+\t\tpublic int previousIndex ()\n+\t\t{\n+\t\t\treturn _idx - 1;\n+\t\t}\n+\n+\n+\t\tpublic boolean hasNext ()\n+\t\t{\n+\t\t\t_next = getInternal (_idx);\n+\t\t\treturn _next != PAST_END;\t\n+\t\t}\n+\n+\n+\t\tpublic boolean hasPrevious ()\n+\t\t{\n+\t\t\treturn _idx > 0;\n+\t\t}\n+\n+\n+\t\tpublic Object previous ()\n+\t\t{\n+\t\t\tif (_idx == 0)\n+\t\t\t\tthrow new NoSuchElementException ();\n+\t\t\treturn getInternal (--_idx);\n+\t\t}\n+\n+\n+\t\tpublic Object next ()\n+\t\t{\n+\t\t\tif (!hasNext ())\n+\t\t\t\tthrow new NoSuchElementException ();\n+\t\t\t_idx++;\n+\t\t\treturn _next;\n+\t\t}\n+\t}\n+}"},{"sha":"9062dd15b5e1851b0b4820261046c67092d47ac9","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/AbstractResultList.java","status":"added","additions":116,"deletions":0,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/AbstractResultList.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/AbstractResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/AbstractResultList.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.rop;\n+\n+\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+\n+\n+/** \n+ *  <p>Abstract base class for read-only result lists.</p>\n+ *  \n+ *  @author Abe White\n+ *\t@nojavadoc\n+ */\n+public abstract class AbstractResultList\n+\timplements ResultList\n+{\n+\tprivate static final Localizer _loc = Localizer.forPackage \n+\t\t(AbstractResultList.class);\n+\n+\n+\tpublic void add (int index, Object element)\n+\t{\n+\t\tthrow new UnsupportedOperationException (_loc.get (\"read-only\"));\n+\t}\n+\n+\n+\tpublic boolean add (Object o)\n+\t{\n+\t\tthrow new UnsupportedOperationException (_loc.get (\"read-only\"));\n+\t}\n+\n+\n+\tpublic boolean addAll (Collection c)\n+\t{\n+\t\tthrow new UnsupportedOperationException (_loc.get (\"read-only\"));\n+\t}\n+\n+\n+\tpublic boolean addAll (int index, Collection c)\n+\t{\n+\t\tthrow new UnsupportedOperationException (_loc.get (\"read-only\"));\n+\t}\n+\n+\n+\tpublic Object remove (int index)\n+\t{\n+\t\tthrow new UnsupportedOperationException (_loc.get (\"read-only\"));\n+\t}\n+\t\t\n+\t\n+\tpublic boolean remove (Object o)\n+\t{\n+\t\tthrow new UnsupportedOperationException (_loc.get (\"read-only\"));\n+\t}\n+\n+\n+\tpublic boolean removeAll (Collection c)\n+\t{\n+\t\tthrow new UnsupportedOperationException (_loc.get (\"read-only\"));\n+\t}\n+\n+\n+\tpublic boolean retainAll (Collection c)\n+\t{\n+\t\tthrow new UnsupportedOperationException (_loc.get (\"read-only\"));\n+\t}\n+\n+\n+\tpublic Object set (int index, Object element)\n+\t{\n+\t\tthrow new UnsupportedOperationException (_loc.get (\"read-only\"));\n+\t}\n+\n+\n+\tpublic void clear ()\n+\t{\n+\t\tthrow new UnsupportedOperationException (_loc.get (\"read-only\"));\n+\t}\n+\n+\n+\tpublic List subList (int from, int to)\n+\t{\n+\t\tthrow new UnsupportedOperationException ();\n+\t}\n+\n+\n+\tprotected void finalize ()\n+\t\tthrows Throwable\n+\t{\n+\t\tsuper.finalize ();\n+\t\tclose ();\n+\t}\n+\n+\n+\tprotected void assertOpen ()\n+\t{\n+\t\tif (isClosed ())\n+\t\t\tthrow new NoSuchElementException (_loc.get (\"closed\"));\n+\t}\n+}"},{"sha":"a67dd9ac7d045bb9c550146bf2650e03979aa047","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/AbstractSequentialResultList.java","status":"added","additions":134,"deletions":0,"changes":134,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/AbstractSequentialResultList.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/AbstractSequentialResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/AbstractSequentialResultList.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.rop;\n+\n+\n+import java.util.*;\n+\n+import org.apache.commons.lang.*;\n+\n+\n+/** \n+ *  <p>Abstract base class for sequential result lists.  Unlike the\n+ *\t{@link AbstractSequentialList}, this class doesn't rely on the \n+ *\t{@link Collection#size} method.</p>\n+ *  \n+ *  @author Abe White\n+ *\t@nojavadoc\n+ */\n+public abstract class AbstractSequentialResultList\n+\textends AbstractResultList\n+{\n+\t/**\n+\t *\tImplement this method and {@link #size}.\n+ \t */\n+\tprotected abstract ListIterator itr (int index);\n+\n+\n+\tpublic boolean contains (Object o)\n+\t{\n+\t\tassertOpen ();\n+\t\tfor (Iterator itr = itr (0); itr.hasNext ();)\n+\t\t\tif (ObjectUtils.equals (o, itr.next ()))\n+\t\t\t\treturn true;\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean containsAll (Collection c)\n+\t{\n+\t\tassertOpen ();\n+\t\tfor (Iterator itr = c.iterator (); itr.hasNext ();)\n+\t\t\tif (!contains (itr.next ()))\n+\t\t\t\treturn false;\n+\t\treturn true;\n+\t}\n+\n+\n+\tpublic Object get (int index)\n+\t{\n+\t\tassertOpen ();\n+\t\treturn itr (index).next ();\n+\t}\n+\n+\n+\tpublic int indexOf (Object o)\n+\t{\n+\t\tassertOpen ();\n+\t\tint index = 0;\n+\t\tfor (Iterator itr = itr (0); itr.hasNext (); index++)\n+\t\t\tif (ObjectUtils.equals (o, itr.next ()))\n+\t\t\t\treturn index;\n+\t\treturn -1;\n+\t}\n+\n+\n+\tpublic int lastIndexOf (Object o)\n+\t{\n+\t\tassertOpen ();\n+\t\tint index = -1;\n+\t\tint i = 0;\n+\t\tfor (Iterator itr = itr (0); itr.hasNext (); i++)\n+\t\t\tif (ObjectUtils.equals (o, itr.next ()))\n+\t\t\t\tindex = i;\n+\t\treturn index;\n+\t}\n+\n+\n+\tpublic boolean isEmpty ()\n+\t{\n+\t\tassertOpen ();\n+\t\treturn !itr (0).hasNext ();\n+\t}\n+\n+\n+\tpublic Iterator iterator ()\n+\t{\n+\t\treturn listIterator ();\n+\t}\n+\n+\n+\tpublic ListIterator listIterator ()\n+\t{\n+\t\treturn listIterator (0);\n+\t}\n+\n+\n+\tpublic ListIterator listIterator (int index)\n+\t{\n+\t\treturn new ResultListIterator (itr (index), this);\n+\t}\n+\n+\n+\tpublic Object[] toArray ()\n+\t{\n+\t\tassertOpen ();\n+\t\tArrayList list = new ArrayList ();\n+\t\tfor (Iterator itr = itr (0); itr.hasNext ();)\n+\t\t\tlist.add (itr.next ());\n+\t\treturn list.toArray ();\n+\t}\n+\n+\n+\tpublic Object[] toArray (Object[] a)\n+\t{\n+\t\tassertOpen ();\n+\t\tArrayList list = new ArrayList ();\n+\t\tfor (Iterator itr = itr (0); itr.hasNext ();)\n+\t\t\tlist.add (itr.next ());\n+\t\treturn list.toArray (a);\n+\t}\n+}"},{"sha":"644ed7e91a10dd15c3eb6726195e8b184311aa26","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/EagerResultList.java","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/EagerResultList.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/EagerResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/EagerResultList.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.rop;\n+\n+\n+import java.util.*;\n+\n+\n+/**\n+ *\tSimple, non-lazy ResultList implementation\n+ *\n+ *\t@author Patrick Linskey\n+ *\t@nojavadoc\n+ */\n+public class EagerResultList\n+\textends ListResultList\n+\timplements ResultList\n+{\n+\tpublic EagerResultList (ResultObjectProvider rop)\n+\t{\n+\t\tsuper (new ArrayList ());\n+\t\ttry\n+\t\t{\n+\t\t\trop.open ();\n+\t\t\twhile (rop.next ())\n+\t\t\t\tgetDelegate ().add (rop.getResultObject ());\n+\t\t}\n+\t\tcatch (RuntimeException re)\n+\t\t{\n+\t\t\tthrow re;\n+\t\t}\n+\t\tcatch (Exception e)\n+\t\t{\n+\t\t\trop.handleCheckedException (e);\n+\t\t}\n+\t\tfinally\n+\t\t{\n+\t\t\ttry { rop.close (); } catch (Exception e) {}\n+\t\t}\n+\t}\n+}\n+"},{"sha":"1a67c949c34d265ef5de49dd10fcd5d3f8d8d0ca","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/LazyForwardResultList.java","status":"added","additions":249,"deletions":0,"changes":249,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/LazyForwardResultList.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/LazyForwardResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/LazyForwardResultList.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.rop;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+\n+\n+/**\n+ *\t<p>Lazy forward-only result list.</p>\n+ *\n+ *\t@author Abe White\n+ *\t@nojavadoc\n+ */\n+public class LazyForwardResultList\n+\textends AbstractSequentialResultList\n+\timplements ResultList\n+{\n+\tprivate static final int OPEN \t= 0;\n+\tprivate static final int CLOSED\t= 1;\n+\tprivate static final int FREED\t= 2;\n+\n+\tprivate ResultObjectProvider\t_rop\t= null;\n+\tprivate final List \t\t\t\t_list\t= new ArrayList ();\n+\tprivate int\t\t\t\t\t\t_state\t= OPEN;\n+\tprivate int\t\t\t\t\t\t_size\t= -1;\n+\n+\n+\tpublic LazyForwardResultList (ResultObjectProvider rop)\n+\t{\n+\t\t_rop = rop;\n+\t\ttry\n+\t\t{\n+\t\t\t_rop.open ();\n+\t\t}\n+\t\tcatch (RuntimeException re)\n+\t\t{\n+\t\t\tclose ();\n+\t\t\tthrow re;\n+\t\t}\n+\t\tcatch (Exception e)\n+\t\t{\n+\t\t\tclose ();\n+\t\t\t_rop.handleCheckedException (e);\n+\t\t}\n+\t}\n+\n+\n+\tpublic boolean isProviderOpen ()\n+\t{\n+\t\treturn _state == OPEN;\n+\t}\n+\n+\n+\tpublic boolean isClosed ()\n+\t{\n+\t\treturn _state == CLOSED;\n+\t}\n+\n+\n+\tpublic void close ()\n+\t{\n+\t\tif (_state != CLOSED)\n+\t\t{\n+\t\t\tfree ();\n+\t\t\t_state = CLOSED;\n+\t\t}\n+\t}\n+\n+\n+\tpublic Object get (int index)\n+\t{\n+\t\tassertOpen ();\n+\n+\t\t// optimization for getting sequntially\n+\t\tif (index == _list.size ())\n+\t\t\taddNext ();\n+\t\tif (index < _list.size ())\n+\t\t\treturn _list.get (index);\n+\n+\t\treturn super.get (index);\n+\t}\n+\n+\n+\tprotected ListIterator itr (int index)\n+\t{\n+\t\treturn (_state != OPEN) ? _list.listIterator (index) : new Itr (index);\n+\t}\n+\n+\n+\tpublic int size ()\n+\t{\n+\t\tassertOpen ();\n+\t\tif (_size != -1)\n+\t\t\treturn _size;\n+\t\tif (_state != OPEN)\n+\t\t\treturn _list.size ();\n+\t\ttry\n+\t\t{\n+\t\t\t_size = _rop.size ();\n+\t\t\treturn _size;\n+\t\t}\n+\t\tcatch (RuntimeException re)\n+\t\t{\n+\t\t\tclose ();\n+\t\t\tthrow re;\n+\t\t}\n+\t\tcatch (Exception e)\n+\t\t{\n+\t\t\tclose ();\n+\t\t\t_rop.handleCheckedException (e);\n+\t\t\treturn -1;\n+\t\t}\n+\t}\n+\n+\n+\tprivate boolean addNext ()\n+\t{\n+\t\ttry\n+\t\t{\n+\t\t\tif (!_rop.next ())\n+\t\t\t{\n+\t\t\t\tfree ();\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\t_list.add (_rop.getResultObject ());\n+\t\t\treturn true;\n+\t\t}\n+\t\tcatch (RuntimeException re)\n+\t\t{\n+\t\t\tclose ();\n+\t\t\tthrow re;\n+\t\t}\n+\t\tcatch (Exception e)\n+\t\t{\n+\t\t\tclose ();\n+\t\t\t_rop.handleCheckedException (e);\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\n+\tprivate void free ()\n+\t{\n+\t\tif (_state == OPEN)\n+\t\t{\n+\t\t\ttry { _rop.close (); } catch (Exception e) {}\n+\t\t\t_state = FREED;\n+\t\t}\n+\t}\n+\n+\n+\tpublic Object writeReplace ()\n+\t\tthrows ObjectStreamException\n+\t{\n+\t\t// fully traverse results\n+\t\tif (_state == OPEN)\n+\t\t\tfor (Iterator itr = itr (_list.size ()); itr.hasNext ();)\n+\t\t\t\titr.next ();\n+\t\treturn _list;\n+\t}\n+\n+\n+\tpublic int hashCode ()\n+\t{\n+\t\t// superclass tries to traverses entire list for hashcode \n+\t\treturn System.identityHashCode (this);\n+\t}\n+\n+\n+\tpublic boolean equals (Object other)\n+\t{\n+\t\t// superclass tries to traverse entire list for equality\n+\t\treturn other == this;\n+\t}\n+\n+\n+\tprivate class Itr\n+\t\textends AbstractListIterator\n+\t{\n+\t\tprivate int _idx = 0;\n+\n+\n+\t\tpublic Itr (int index)\n+\t\t{\n+\t\t\t_idx = Math.min (index, _list.size ());\n+\t\t\twhile (_idx < index)\n+\t\t\t\tnext ();\n+\t\t}\n+\n+\n+\t\tpublic int nextIndex ()\n+\t\t{\n+\t\t\treturn _idx;\n+\t\t}\n+\n+\n+\t\tpublic int previousIndex ()\n+\t\t{\n+\t\t\treturn _idx - 1;\n+\t\t}\n+\n+\n+\t\tpublic boolean hasNext ()\n+\t\t{\n+\t\t\tif (_list.size () > _idx)\n+\t\t\t\treturn true;\n+\t\t\tif (_state != OPEN)\n+\t\t\t\treturn false;\n+\t\t\treturn addNext ();\n+\t\t}\n+\n+\n+\t\tpublic boolean hasPrevious ()\n+\t\t{\n+\t\t\treturn _idx > 0;\n+\t\t}\n+\n+\n+\t\tpublic Object previous ()\n+\t\t{\n+\t\t\tif (_idx == 0)\n+\t\t\t\tthrow new NoSuchElementException ();\n+\t\t\treturn _list.get (--_idx);\n+\t\t}\n+\n+\n+\t\tpublic Object next ()\n+\t\t{\n+\t\t\tif (!hasNext ())\n+\t\t\t\tthrow new NoSuchElementException ();\n+\t\t\treturn _list.get (_idx++);\n+\t\t}\n+\t}\n+}"},{"sha":"3b20746ecb8ad8c7aa4b45d1e339844a3832a1cb","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/ListResultList.java","status":"added","additions":156,"deletions":0,"changes":156,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/ListResultList.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/ListResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/ListResultList.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38","patch":"@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.openjpa.lib.rop;\n+\n+\n+import java.util.*;\n+\n+\n+/** \n+ *  <p>A basic {@link ResultList} implementation that wraps a normal list.</p>\n+ *  \n+ *  @author Abe White\n+ *\t@nojavadoc\n+ */\n+public class ListResultList\n+\textends AbstractResultList\n+{\n+\tprivate final List \t_list;\n+\tprivate boolean \t_closed = false;\n+\n+\n+\t/**\n+\t *\tConstructor.  Supply delegate.\n+\t */\n+\tpublic ListResultList (List list)\n+\t{\n+\t\t_list = list;\n+\t}\n+\n+\n+\t/**\n+\t *\tReturn the wrapped list.\n+\t */\n+\tpublic List getDelegate ()\n+\t{\n+\t\treturn _list;\n+\t}\n+\n+\n+\tpublic boolean isProviderOpen ()\n+\t{\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean isClosed ()\n+\t{\n+\t\treturn _closed;\n+\t}\n+\n+\n+\tpublic void close ()\n+\t{\n+\t\t_closed = true;\n+\t}\n+\n+\n+\tpublic boolean contains (Object o)\n+\t{\n+\t\tassertOpen ();\n+\t\treturn _list.contains (o);\n+\t}\n+\n+\n+\tpublic boolean containsAll (Collection c)\n+\t{\n+\t\tassertOpen ();\n+\t\treturn _list.containsAll (c);\n+\t}\n+\n+\n+\tpublic Object get (int index)\n+\t{\n+\t\tassertOpen ();\n+\t\treturn _list.get (index);\n+\t}\n+\n+\n+\tpublic int indexOf (Object o)\n+\t{\n+\t\tassertOpen ();\n+\t\treturn _list.indexOf (o);\n+\t}\n+\n+\n+\tpublic int lastIndexOf (Object o)\n+\t{\n+\t\tassertOpen ();\n+\t\treturn _list.lastIndexOf (o);\n+\t}\n+\n+\n+\tpublic int size ()\n+\t{\n+\t\tassertOpen ();\n+\t\treturn _list.size ();\n+\t}\n+\n+\n+\tpublic boolean isEmpty ()\n+\t{\n+\t\tassertOpen ();\n+\t\treturn _list.isEmpty ();\n+\t}\n+\n+\n+\tpublic Iterator iterator ()\n+\t{\n+\t\treturn listIterator ();\n+\t}\n+\n+\n+\tpublic ListIterator listIterator ()\n+\t{\n+\t\treturn new ResultListIterator (_list.listIterator (), this);\n+\t}\n+\n+\n+\tpublic ListIterator listIterator (int index)\n+\t{\n+\t\treturn new ResultListIterator (_list.listIterator (index), this);\n+\t}\n+\n+\n+\tpublic Object[] toArray ()\n+\t{\n+\t\tassertOpen ();\n+\t\treturn _list.toArray ();\n+\t}\n+\n+\n+\tpublic Object[] toArray (Object[] a)\n+\t{\n+\t\tassertOpen ();\n+\t\treturn _list.toArray (a);\n+\t}\n+\n+\t\n+\tpublic Object writeReplace ()\n+\t{\n+\t\treturn _list;\n+\t}\n+}"},{"sha":"899298ee0570a1b43bcc74ebfde1ddba2bf8b6d1","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/ListResultObjectProvider.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/ListResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/ListResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/ListResultObjectProvider.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"cfce81450522edab9e856338406cac2cca63400d","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/MergedResultObjectProvider.java","status":"added","additions":283,"deletions":0,"changes":283,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/MergedResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/MergedResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/MergedResultObjectProvider.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"150727b5b1efc167b462462d0514c33008994698","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/RandomAccessResultList.java","status":"added","additions":280,"deletions":0,"changes":280,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/RandomAccessResultList.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/RandomAccessResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/RandomAccessResultList.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"5e9ebfc848a5706754c6212538486184506d95a4","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/RangeResultObjectProvider.java","status":"added","additions":165,"deletions":0,"changes":165,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/RangeResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/RangeResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/RangeResultObjectProvider.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"67594213d224012f0d5e586a09f6e5bf5d023a5c","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/ResultList.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/ResultList.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/ResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/ResultList.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"c0f2d16eecdf94fdbdecc17d8fbf0d9f56db3754","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/ResultListIterator.java","status":"added","additions":91,"deletions":0,"changes":91,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/ResultListIterator.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/ResultListIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/ResultListIterator.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"d8cdabe65b5ad9d1a621fb87e7e9c3bfc5de9ede","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/ResultObjectProvider.java","status":"added","additions":113,"deletions":0,"changes":113,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/ResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/ResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/ResultObjectProvider.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"885fb416272595122b79f11633cd774bcc51e933","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/ResultObjectProviderIterator.java","status":"added","additions":133,"deletions":0,"changes":133,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/ResultObjectProviderIterator.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/ResultObjectProviderIterator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/ResultObjectProviderIterator.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"807f73fd0de4c3548d7d18943ffac871707b0140","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/SimpleResultList.java","status":"added","additions":140,"deletions":0,"changes":140,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/SimpleResultList.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/SimpleResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/SimpleResultList.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"467091e09341c635dda604c359cc6b122bff7efc","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/SoftRandomAccessResultList.java","status":"added","additions":44,"deletions":0,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/SoftRandomAccessResultList.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/SoftRandomAccessResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/SoftRandomAccessResultList.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"844edf381059f1390ef96f747f1f37a9ca04022a","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/WindowResultList.java","status":"added","additions":214,"deletions":0,"changes":214,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/WindowResultList.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/WindowResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/WindowResultList.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"6695e49bd5d73afd9dd63bc3c72a3a251bd13c81","filename":"openjpa-lib/java/org/apache/openjpa/lib/rop/package.html","status":"added","additions":24,"deletions":0,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/package.html","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/rop/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/rop/package.html?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"ff75be85c74dea634950170e66ac27b08ed3d6dd","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/AbstractEventManager.java","status":"added","additions":166,"deletions":0,"changes":166,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/AbstractEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/AbstractEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/AbstractEventManager.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"0b67531da9c03893cc3b524ec983e1fbaa4d067f","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/Base16Encoder.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/Base16Encoder.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/Base16Encoder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/Base16Encoder.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"f66adedce27af2eed91ff4130ccc07e8cbc9b7e7","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/BytecodeWriter.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/BytecodeWriter.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/BytecodeWriter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/BytecodeWriter.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"89e6575b9b15c44c813eb16f671521a83ef8ebcf","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/Closeable.java","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/Closeable.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/Closeable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/Closeable.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"a2a89d3fd24d371959f84507cf4ee31c2ba00a49","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/CodeFormat.java","status":"added","additions":700,"deletions":0,"changes":700,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/CodeFormat.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/CodeFormat.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/CodeFormat.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"30e219f5fdfcf2fc7a0e0add132fba981b5fc805","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/ConcurrentHashMap.java","status":"added","additions":965,"deletions":0,"changes":965,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/ConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/ConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/ConcurrentHashMap.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"29331bc944e58292c3b6c0591253b7bc1d9a7fb5","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/EfficientEmptyReferenceMap.java","status":"added","additions":130,"deletions":0,"changes":130,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/EfficientEmptyReferenceMap.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/EfficientEmptyReferenceMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/EfficientEmptyReferenceMap.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"12913b146d78f485e075a924442cbadd72f669dc","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/ExpirationNotifyingReferenceMap.java","status":"added","additions":184,"deletions":0,"changes":184,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/ExpirationNotifyingReferenceMap.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/ExpirationNotifyingReferenceMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/ExpirationNotifyingReferenceMap.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"a39c403cb8ee827f7c3b45a4d7eb7a800493f640","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/Files.java","status":"added","additions":296,"deletions":0,"changes":296,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/Files.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/Files.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/Files.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"c6b2737a8513b79d4ab941881aa2f2d1c92b452f","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/FormatPreservingProperties.java","status":"added","additions":842,"deletions":0,"changes":842,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/FormatPreservingProperties.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/FormatPreservingProperties.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/FormatPreservingProperties.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"fcd0457ae4cd0275b83277b6cd7dc2fb49095ea5","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/JavaVersions.java","status":"added","additions":316,"deletions":0,"changes":316,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/JavaVersions.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/JavaVersions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/JavaVersions.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"d0a14abc8d4a9cd45bd1e36b547739e63d5fc92f","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/Localizer.java","status":"added","additions":275,"deletions":0,"changes":275,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/Localizer.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/Localizer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/Localizer.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"2a26e5f7201679c6e213ae580cb238a3b6f76279","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/MultiClassLoader.java","status":"added","additions":306,"deletions":0,"changes":306,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/MultiClassLoader.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/MultiClassLoader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/MultiClassLoader.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"8dd9d386b8bad2f39670ff7b1c4addc0bb42bc69","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/Options.java","status":"added","additions":691,"deletions":0,"changes":691,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/Options.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/Options.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/Options.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"3559c9a31fd245ac2dc01cc96ac1b6706b638e30","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/ParameterTemplate.java","status":"added","additions":298,"deletions":0,"changes":298,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/ParameterTemplate.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/ParameterTemplate.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/ParameterTemplate.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"461eb56701aef3418548580c18e343b676af304d","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/ParseException.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/ParseException.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/ParseException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/ParseException.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"2783376af08059dc462870dd44f3f7a4f751f2f6","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/ReferenceSet.java","status":"added","additions":164,"deletions":0,"changes":164,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/ReferenceSet.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/ReferenceSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/ReferenceSet.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"dd415944bbdb2ceab98480468c12b2b9b8d47c39","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/ResourceBundleProvider.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/ResourceBundleProvider.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/ResourceBundleProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/ResourceBundleProvider.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"2d912efd5b316ff4d3f93733a58597475c18c76b","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/Services.java","status":"added","additions":231,"deletions":0,"changes":231,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/Services.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/Services.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/Services.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"8c2903329dcbc129e98191fb34fb0cbf1571b205","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/SimpleRegex.java","status":"added","additions":150,"deletions":0,"changes":150,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/SimpleRegex.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/SimpleRegex.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/SimpleRegex.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"f943548a3d51cf063593a93f1991e82ccc07a3d6","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/SimpleResourceBundleProvider.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/SimpleResourceBundleProvider.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/SimpleResourceBundleProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/SimpleResourceBundleProvider.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"587ad3b96707ff5fc72bfa15ceb424406e082d1a","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/StreamResourceBundleProvider.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/StreamResourceBundleProvider.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/StreamResourceBundleProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/StreamResourceBundleProvider.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"81e4e64703e325cb5af6c22c200b39bcc1b44d5f","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/StringDistance.java","status":"added","additions":216,"deletions":0,"changes":216,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/StringDistance.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/StringDistance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/StringDistance.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"73a472e8b4c8558bd5b417fadbbf7f53ae5d2839","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/TemporaryClassLoader.java","status":"added","additions":110,"deletions":0,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/TemporaryClassLoader.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/TemporaryClassLoader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/TemporaryClassLoader.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"926f4fe4d0d2fcb7d9f6077149652cc058bd9eda","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/ThreadLock.java","status":"added","additions":152,"deletions":0,"changes":152,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/ThreadLock.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/ThreadLock.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/ThreadLock.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"aa7d72664ada4ba649fd5d7e8cf75743b785d06d","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/TypedProperties.java","status":"added","additions":391,"deletions":0,"changes":391,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/TypedProperties.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/TypedProperties.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/TypedProperties.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"ee650b7319a7b1973681b3b32bac7ad15b464576","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/ZipResourceBundleProvider.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/ZipResourceBundleProvider.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/ZipResourceBundleProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/ZipResourceBundleProvider.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"72480cf3c879e75c97ee88e5de46ac9bade34846","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/package.html","status":"added","additions":20,"deletions":0,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/package.html","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/util/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/package.html?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"c19f798830dbb37dac29e6e820f40f640d5b4853","filename":"openjpa-lib/java/org/apache/openjpa/lib/xml/Commentable.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/xml/Commentable.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/xml/Commentable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/xml/Commentable.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"890013bd54358c6967a481aacd0b045a08d1dfa4","filename":"openjpa-lib/java/org/apache/openjpa/lib/xml/DocTypeReader.java","status":"added","additions":328,"deletions":0,"changes":328,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/xml/DocTypeReader.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/xml/DocTypeReader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/xml/DocTypeReader.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"5acc0137e696678c42448289d3b0f0b088341402","filename":"openjpa-lib/java/org/apache/openjpa/lib/xml/Location.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/xml/Location.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/xml/Location.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/xml/Location.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"bb63f51e52e5cc7b65775e90b20436d10b30ffb5","filename":"openjpa-lib/java/org/apache/openjpa/lib/xml/ValidatingErrorHandler.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/xml/ValidatingErrorHandler.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/xml/ValidatingErrorHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/xml/ValidatingErrorHandler.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"47b7806376ff6bef133797be1b6e31ae257daed8","filename":"openjpa-lib/java/org/apache/openjpa/lib/xml/XMLFactory.java","status":"added","additions":250,"deletions":0,"changes":250,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/xml/XMLFactory.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/xml/XMLFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/xml/XMLFactory.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"5f64918f5faf9e8ae4792c8bf3036b6050c604cb","filename":"openjpa-lib/java/org/apache/openjpa/lib/xml/XMLWriter.java","status":"added","additions":158,"deletions":0,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/xml/XMLWriter.java","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/xml/XMLWriter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/xml/XMLWriter.java?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"bfc4097fcd8ea79ffa610bec327ffb069f2c5516","filename":"openjpa-lib/java/org/apache/openjpa/lib/xml/package.html","status":"added","additions":20,"deletions":0,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/xml/package.html","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/java/org/apache/openjpa/lib/xml/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/xml/package.html?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"f466f5d57136a5c1b603a004d403aafbd32e0a50","filename":"openjpa-lib/resources/org/apache/openjpa/lib/conf/localizer.properties","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/resources/org/apache/openjpa/lib/conf/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/resources/org/apache/openjpa/lib/conf/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/resources/org/apache/openjpa/lib/conf/localizer.properties?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"4d881c02a9d6fd5b06b85555ef31d9f4f440e4c7","filename":"openjpa-lib/resources/org/apache/openjpa/lib/jdbc/localizer.properties","status":"added","additions":19,"deletions":0,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/resources/org/apache/openjpa/lib/jdbc/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/resources/org/apache/openjpa/lib/jdbc/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/resources/org/apache/openjpa/lib/jdbc/localizer.properties?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"21ad9fff57b4f76c943a2c38d00b52011ac1ce0b","filename":"openjpa-lib/resources/org/apache/openjpa/lib/log/localizer.properties","status":"added","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/resources/org/apache/openjpa/lib/log/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/resources/org/apache/openjpa/lib/log/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/resources/org/apache/openjpa/lib/log/localizer.properties?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"1c8c62b655dadd4ac4968ceac1a4fc64a362e0e1","filename":"openjpa-lib/resources/org/apache/openjpa/lib/meta/localizer.properties","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/resources/org/apache/openjpa/lib/meta/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/resources/org/apache/openjpa/lib/meta/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/resources/org/apache/openjpa/lib/meta/localizer.properties?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"30ec42fa301b57d2aec35c2acf15e313b25b88c1","filename":"openjpa-lib/resources/org/apache/openjpa/lib/rop/localizer.properties","status":"added","additions":19,"deletions":0,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/resources/org/apache/openjpa/lib/rop/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/resources/org/apache/openjpa/lib/rop/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/resources/org/apache/openjpa/lib/rop/localizer.properties?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"17e1769e12722384cf979f238c7f3c568eb05fae","filename":"openjpa-lib/resources/org/apache/openjpa/lib/util/localizer.properties","status":"added","additions":19,"deletions":0,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/resources/org/apache/openjpa/lib/util/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/resources/org/apache/openjpa/lib/util/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/resources/org/apache/openjpa/lib/util/localizer.properties?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"},{"sha":"651a3e17c31cb524b66a09e16a021cc5f96315df","filename":"openjpa-lib/resources/org/apache/openjpa/lib/xml/localizer.properties","status":"added","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/apache/openjpa/blob/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/resources/org/apache/openjpa/lib/xml/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/c64c2ca062ea353fdce8197f45a6fcc7e1d98a38/openjpa-lib/resources/org/apache/openjpa/lib/xml/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/resources/org/apache/openjpa/lib/xml/localizer.properties?ref=c64c2ca062ea353fdce8197f45a6fcc7e1d98a38"}]}

