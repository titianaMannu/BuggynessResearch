{"sha":"c8d1003612cd9845c5e6df4f2c27c10d12c02dae","node_id":"MDY6Q29tbWl0MjA2MzY0OmM4ZDEwMDM2MTJjZDk4NDVjNWU2ZGY0ZjJjMjdjMTBkMTJjMDJkYWU=","commit":{"author":{"name":"Fay Wang","email":"faywang@apache.org","date":"2009-09-29T03:31:34Z"},"committer":{"name":"Fay Wang","email":"faywang@apache.org","date":"2009-09-29T03:31:34Z"},"message":"OPENJPA-1253: refactoring the checking of non-default mapping to AbstractFieldStrategy\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@819822 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"abde3225a123cae75c4b0624101363fe4e64f10e","url":"https://api.github.com/repos/apache/openjpa/git/trees/abde3225a123cae75c4b0624101363fe4e64f10e"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/c8d1003612cd9845c5e6df4f2c27c10d12c02dae","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/c8d1003612cd9845c5e6df4f2c27c10d12c02dae","html_url":"https://github.com/apache/openjpa/commit/c8d1003612cd9845c5e6df4f2c27c10d12c02dae","comments_url":"https://api.github.com/repos/apache/openjpa/commits/c8d1003612cd9845c5e6df4f2c27c10d12c02dae/comments","author":null,"committer":null,"parents":[{"sha":"7d6ccb108c5fdd31bf1a89441927ce8ff756a840","url":"https://api.github.com/repos/apache/openjpa/commits/7d6ccb108c5fdd31bf1a89441927ce8ff756a840","html_url":"https://github.com/apache/openjpa/commit/7d6ccb108c5fdd31bf1a89441927ce8ff756a840"}],"stats":{"total":254,"additions":139,"deletions":115},"files":[{"sha":"a7b3dd1528672df6ee06f5fa32aaa560b8349d3f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractFieldStrategy.java","status":"modified","additions":116,"deletions":0,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/c8d1003612cd9845c5e6df4f2c27c10d12c02dae/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/c8d1003612cd9845c5e6df4f2c27c10d12c02dae/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractFieldStrategy.java?ref=c8d1003612cd9845c5e6df4f2c27c10d12c02dae","patch":"@@ -20,10 +20,14 @@\n \n import java.sql.SQLException;\n \n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMappingInfo;\n import org.apache.openjpa.jdbc.meta.FieldStrategy;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.RowManager;\n@@ -32,6 +36,8 @@\n import org.apache.openjpa.jdbc.sql.SelectExecutor;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.util.MetaDataException;\n \n /**\n@@ -46,6 +52,13 @@\n     private static final Localizer _loc = Localizer.forPackage\n         (AbstractFieldStrategy.class);\n \n+    private Boolean _isNonDefaultMappingAllowed = null;\n+    private Boolean _isBi1ToMJT = null;\n+    private Boolean _isUni1ToMFK = null;\n+    private Integer _bi1ToMJT = null; //index of the field\n+    private ForeignKey _bi_1ToM_JoinFK = null;\n+    private ForeignKey _bi_1ToM_ElemFK = null;\n+    \n     /**\n      * The owning field mapping.\n      */\n@@ -181,4 +194,107 @@ public void where(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n         Object prevValue)\n         throws SQLException {\n     }\n+    \n+    private void isNonDefaultMapping() {\n+        FieldMapping mapped = field.getMappedByMapping();\n+        _isBi1ToMJT = false;\n+        _isUni1ToMFK = false;\n+        if (isNonDefaultMappingAllowed()) {\n+            if (field.getAssociationType() == FieldMetaData.ONE_TO_MANY ) {\n+                if (mapped == null) {\n+                    if (hasJoinTable())\n+                        return;\n+                    else if (hasJoinColumn()) {\n+                        _isUni1ToMFK = true;\n+                        return;\n+                    }\n+                } else {\n+                    if (hasJoinTable()) {\n+                        _isBi1ToMJT = true;\n+                        return;\n+                    } else if (hasJoinColumn()){\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    \n+    private boolean hasJoinColumn() {\n+        boolean hasJoinColumn = (field.getValueInfo().getColumns().size() > 0 ? true : false);\n+        return hasJoinColumn;\n+    }\n+    \n+    private boolean hasJoinTable() {\n+        boolean hasJoinTable = (field.getMappingInfo().getTableName() != null ? true : false);\n+        return hasJoinTable;\n+    }\n+\n+    public boolean isBi1ToMJT() {\n+        if (_isBi1ToMJT == null)\n+            isNonDefaultMapping();\n+        return _isBi1ToMJT;\n+    }\n+    \n+    public boolean isUni1ToMFK() {\n+        if (_isUni1ToMFK == null)\n+            isNonDefaultMapping();\n+        return _isUni1ToMFK;\n+    }\n+\n+    protected boolean isNonDefaultMappingAllowed() {\n+        if (_isNonDefaultMappingAllowed == null) {\n+            OpenJPAConfiguration conf = field.getRepository().getConfiguration();\n+            _isNonDefaultMappingAllowed = field.getRepository().\n+                getMetaDataFactory().getDefaults().isNonDefaultMappingAllowed(conf);\n+        }\n+        return _isNonDefaultMappingAllowed;\n+    }\n+\n+    protected void getBiOneToManyInfo() {\n+        _bi1ToMJT = -1;\n+        if (!isNonDefaultMappingAllowed())\n+            return;\n+        ClassMapping inverse = field.getValueMapping().getTypeMapping();\n+        FieldMapping[] fmds = inverse.getFieldMappings();\n+        for (int i = 0; i < fmds.length; i++) {\n+            if (field == fmds[i].getMappedByMapping()) {\n+                int typeCode = fmds[i].getDeclaredTypeCode(); \n+                if (typeCode == JavaTypes.ARRAY ||\n+                        typeCode == JavaTypes.COLLECTION ||\n+                        typeCode == JavaTypes.MAP) {\n+                    // this is a bi-directional oneToMany relation with\n+                    // @JoinTable annotation ==> join table strategy\n+                    // ==> should not mapped in the owner's table\n+                    FieldMappingInfo info = fmds[i].getMappingInfo();\n+                    if (info.getTableName() != null)\n+                        _bi1ToMJT = i;\n+                    _bi_1ToM_ElemFK = fmds[i].getElementMapping().getForeignKey();\n+                    _bi_1ToM_JoinFK = fmds[i].getJoinForeignKey();\n+                }\n+                break;\n+            } \n+        }\n+    }\n+\n+    protected int getFieldIndexBi1ToMJT() {\n+        if (_bi1ToMJT == null) {\n+            getBiOneToManyInfo();\n+        }\n+        return _bi1ToMJT;\n+    }\n+    \n+    protected ForeignKey getBi1ToMElemFK() {\n+        if (_bi1ToMJT == null) {\n+            getBiOneToManyInfo();\n+        }\n+        return _bi_1ToM_ElemFK;\n+    }\n+    \n+    protected ForeignKey getBi1ToMJoinFK() {\n+        if (_bi1ToMJT == null) {\n+            getBiOneToManyInfo();\n+        }\n+        return _bi_1ToM_JoinFK;\n+    }\n }"},{"sha":"bef7b6165a325678941800a20a90f22265ade526","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","status":"modified","additions":0,"deletions":50,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/c8d1003612cd9845c5e6df4f2c27c10d12c02dae/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/c8d1003612cd9845c5e6df4f2c27c10d12c02dae/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java?ref=c8d1003612cd9845c5e6df4f2c27c10d12c02dae","patch":"@@ -66,51 +66,10 @@\n     private static final Localizer _loc = Localizer.forPackage\n         (MapTableFieldStrategy.class);\n \n-    private Boolean _isNonDefaultMappingAllowed = null;\n-    private Boolean _isBi1ToMJT = null;\n-    private Boolean _isUni1ToMFK = null;\n-\n     public FieldMapping getFieldMapping() {\n         return field;\n     }\n \n-    private void isNonDefaultMapping() {\n-        FieldMapping mapped = field.getMappedByMapping();\n-        if (isNonDefaultMappingAllowed() && \n-            field.getAssociationType() == FieldMetaData.ONE_TO_MANY &&\n-            hasJoinColumnOrJoinTable()) {\n-            if (mapped != null) {\n-                _isBi1ToMJT = true;\n-                _isUni1ToMFK = false;\n-            } else {\n-                _isBi1ToMJT = false;\n-                _isUni1ToMFK = true;\n-            }\n-        } else {\n-            _isBi1ToMJT = false;\n-            _isUni1ToMFK = false;\n-        }\n-    }\n-    \n-    private boolean hasJoinColumnOrJoinTable() {\n-        boolean hasJoinColumn = (field.getValueInfo().getColumns().size() > 0 ? true : false);\n-        boolean hasJoinTable = (field.getMappingInfo().getTableName() != null ? true : false);\n-        return hasJoinColumn || hasJoinTable;\n-        \n-    }\n-    \n-    public boolean isBi1ToMJT() {\n-        if (_isBi1ToMJT == null)\n-            isNonDefaultMapping();\n-        return _isBi1ToMJT;\n-    }\n-    \n-    public boolean isUni1ToMFK() {\n-        if (_isUni1ToMFK == null)\n-            isNonDefaultMapping();\n-        return _isUni1ToMFK;\n-    }\n-\n     public ClassMapping[] getIndependentKeyMappings(boolean traverse) {\n         return (traverse) ? field.getKeyMapping().getIndependentTypeMappings()\n             : ClassMapping.EMPTY_MAPPINGS;\n@@ -161,15 +120,6 @@ public void map(boolean adapt) {\n         field.getValueInfo().assertNoSchemaComponents(field, !adapt);\n     }\n     \n-    protected boolean isNonDefaultMappingAllowed() {\n-        if (_isNonDefaultMappingAllowed == null) {\n-            OpenJPAConfiguration conf = field.getRepository().getConfiguration();\n-            _isNonDefaultMappingAllowed = field.getRepository().\n-                getMetaDataFactory().getDefaults().isNonDefaultMappingAllowed(conf);\n-        }\n-        return _isNonDefaultMappingAllowed;\n-    }\n-\n     public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n         throws SQLException {\n         Row row = rm.getAllRows(field.getTable(), Row.ACTION_DELETE);"},{"sha":"3eb4ef3055704d56335664384a8955b8e8003bab","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","status":"modified","additions":23,"deletions":65,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/c8d1003612cd9845c5e6df4f2c27c10d12c02dae/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/c8d1003612cd9845c5e6df4f2c27c10d12c02dae/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java?ref=c8d1003612cd9845c5e6df4f2c27c10d12c02dae","patch":"@@ -83,9 +83,6 @@\n         (RelationFieldStrategy.class);\n \n     private Boolean _fkOid = null;\n-    private int _biOneToManyJoinTable = -1;\n-    private ForeignKey _biOneToManyJoinFK = null;\n-    private ForeignKey _biOneToManyElemFK = null;\n     \n     public void map(boolean adapt) {\n         if (field.getTypeCode() != JavaTypes.PC || field.isEmbeddedPC())\n@@ -139,11 +136,7 @@ public void map(boolean adapt) {\n             field.setUseClassCriteria(criteria);\n             return;\n         } else { // this could be the owner in a bi-directional relation\n-            OpenJPAConfiguration conf = field.getRepository().getConfiguration();\n-            boolean isNonDefaultMappingAllowed = field.getRepository().\n-                getMetaDataFactory().getDefaults().isNonDefaultMappingAllowed(conf);\n-            if (isNonDefaultMappingAllowed)  \n-                getBiOneToManyInfo();\n+            getBiOneToManyInfo();\n         }\n \n         // this is necessary to support openjpa 3 mappings, which didn't\n@@ -168,7 +161,7 @@ public void map(boolean adapt) {\n             if (field.getMappedByIdValue() != null) \n                 setMappedByIdColumns();            \n              \n-            if (_biOneToManyJoinTable == -1) {\n+            if (getFieldIndexBi1ToMJT() == -1) {\n                 ForeignKey fk = vinfo.getTypeJoin(field, field.getName(), true,\n                     adapt);\n                 field.setForeignKey(fk);\n@@ -279,7 +272,7 @@ public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n             updateInverse(sm, rel, store, rm);\n         else {\n             Row row = field.getRow(sm, store, rm, Row.ACTION_INSERT);\n-            if (row != null && _biOneToManyJoinTable == -1) {\n+            if (row != null && getFieldIndexBi1ToMJT() == -1) {\n                 field.setForeignKey(row, rel);\n                 // this is for bi-directional maps, the key and value of the \n                 // map are stored in the table of the mapped-by entity  \n@@ -346,6 +339,12 @@ private Object getMapKeyObj(Map mapObj, Object value) {\n             if (mapObj.get(key) == value)\n                 return key;\n         }\n+        Set<Map.Entry> entries = mapObj.entrySet();\n+        for (Map.Entry entry : entries) {\n+            if (entry.getValue() == value)\n+                return entry.getKey();\n+        }\n+     \n         return null;\n     }\n \n@@ -365,29 +364,25 @@ public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n                     field.isBidirectionalJoinTableMappingNonOwner()) ?\n                     Row.ACTION_DELETE : Row.ACTION_UPDATE;\n             Row row = field.getRow(sm, store, rm, action);\n-            if (row != null && _biOneToManyJoinTable == -1) {\n+            if (row != null && getFieldIndexBi1ToMJT() == -1) {\n                 field.setForeignKey(row, rel);\n                 // this is for bi-directional maps, the key and value of the \n                 // map are stored in the table of the mapped-by entity  \n                 setMapKey(sm, rel, store, row);\n             }\n             \n-            if (_biOneToManyJoinTable != -1) { // also need to update the join table\n-                PersistenceCapable invPC = (PersistenceCapable)sm.fetchObject(_biOneToManyJoinTable);\n+            if (getFieldIndexBi1ToMJT() != -1) { // also need to update the join table\n+                PersistenceCapable invPC = (PersistenceCapable)sm.fetchObject(getFieldIndexBi1ToMJT());\n                 Row secondaryRow = null;\n                 if (invPC != null) {\n-                    secondaryRow = rm.getSecondaryRow(_biOneToManyJoinFK.getTable(),\n+                    secondaryRow = rm.getSecondaryRow(getBi1ToMJoinFK().getTable(),\n                         Row.ACTION_INSERT);\n-                    secondaryRow.setForeignKey(_biOneToManyElemFK, null, sm);\n-                    secondaryRow.setForeignKey(_biOneToManyJoinFK, null, \n+                    secondaryRow.setForeignKey(getBi1ToMElemFK(), null, sm);\n+                    secondaryRow.setForeignKey(getBi1ToMJoinFK(), null, \n                         RelationStrategies.getStateManager(invPC,\n                         store.getContext()));\n-                } else { \n-                    secondaryRow = rm.getSecondaryRow(_biOneToManyJoinFK.getTable(),\n-                            Row.ACTION_DELETE);\n-                    secondaryRow.setForeignKey(_biOneToManyElemFK, null, sm);\n+                    rm.flushSecondaryRow(secondaryRow);\n                 }\n-                rm.flushSecondaryRow(secondaryRow);\n             }\n         }\n     }\n@@ -561,7 +556,7 @@ public void select(Select sel, int idx) {\n      */\n     private void selectEagerParallel(Select sel, ClassMapping cls,\n         JDBCStore store, JDBCFetchConfiguration fetch, int eagerMode) {\n-        if (_biOneToManyJoinTable != -1)\n+        if (getFieldIndexBi1ToMJT() != -1)\n             return;\n         sel.selectPrimaryKey(field.getDefiningMapping());\n         // set a variable name that does not conflict with any in the query;\n@@ -576,7 +571,7 @@ private void selectEagerParallel(Select sel, ClassMapping cls,\n \n     public void selectEagerJoin(Select sel, OpenJPAStateManager sm,\n         JDBCStore store, JDBCFetchConfiguration fetch, int eagerMode) {\n-        if (_biOneToManyJoinTable != -1) \n+        if (getFieldIndexBi1ToMJT() != -1) \n             return;\n \n         // limit the eager mode to single on recursive eager fetching b/c\n@@ -681,7 +676,7 @@ private Map processEagerParallelResult(OpenJPAStateManager sm,\n     public void loadEagerJoin(OpenJPAStateManager sm, JDBCStore store,\n         JDBCFetchConfiguration fetch, Result res)\n         throws SQLException {\n-        if (_biOneToManyJoinTable != -1)\n+        if (getFieldIndexBi1ToMJT() != -1)\n             return;\n         ClassMapping cls = field.getIndependentTypeMappings()[0];\n \n@@ -730,7 +725,7 @@ public void load(OpenJPAStateManager sm, JDBCStore store,\n         // get the related object's oid\n         ClassMapping relMapping = field.getTypeMapping();\n         Object oid = null;\n-        if (relMapping.isMapped() && _biOneToManyJoinTable == -1) { \n+        if (relMapping.isMapped() && getFieldIndexBi1ToMJT() == -1) { \n             oid = relMapping.getObjectId(store, res, field.getForeignKey(),\n                     field.getPolymorphic() != ValueMapping.POLY_FALSE, null);\n         } else {\n@@ -796,16 +791,16 @@ public void select(Select sel, int idx) {\n                     sel.whereForeignKey(field.getForeignKey(rels[idx]),\n                         sm.getObjectId(), field.getDefiningMapping(), store);\n                 else {\n-                    if (_biOneToManyJoinTable == -1) {\n+                    if (getFieldIndexBi1ToMJT() == -1) {\n                         resJoins[idx] = sel.newJoins().joinRelation(field.getName(),\n                             field.getForeignKey(rels[idx]), rels[idx],\n                             field.getSelectSubclasses(), false, false);\n                         field.wherePrimaryKey(sel, sm, store);\n                     } else {\n                         resJoins[idx] = sel.newJoins().joinRelation(null,\n-                            getBiOneToManyJoinFK(), rels[idx],\n+                            getBi1ToMJoinFK(), rels[idx],\n                             field.getSelectSubclasses(), false, false);\n-                        sel.whereForeignKey(getBiOneToManyElemFK(), sm.getObjectId(), \n+                        sel.whereForeignKey(getBi1ToMElemFK(), sm.getObjectId(), \n                             field.getDefiningMapping(), store);\n                     }\n                 }\n@@ -826,43 +821,6 @@ public void select(Select sel, int idx) {\n         }\n     }\n \n-    private ForeignKey getBiOneToManyJoinFK() {\n-        if (_biOneToManyJoinFK == null) {\n-            getBiOneToManyInfo();\n-        }\n-        return _biOneToManyJoinFK;\n-    }\n-    \n-    private ForeignKey getBiOneToManyElemFK() {\n-        if (_biOneToManyElemFK == null) {\n-            getBiOneToManyInfo();\n-        }\n-        return _biOneToManyElemFK;\n-    }\n-\n-    private void getBiOneToManyInfo() {\n-        ClassMapping inverse = field.getValueMapping().getTypeMapping();\n-        FieldMapping[] fmds = inverse.getFieldMappings();\n-        for (int i = 0; i < fmds.length; i++) {\n-            if (field == fmds[i].getMappedByMapping()) {\n-                int typeCode = fmds[i].getDeclaredTypeCode(); \n-                if (typeCode == JavaTypes.ARRAY ||\n-                        typeCode == JavaTypes.COLLECTION ||\n-                        typeCode == JavaTypes.MAP) {\n-                    // this is a bi-directional oneToMany relation with\n-                    // @JoinTable annotation ==> join table strategy\n-                    // ==> should not mapped in the owner's table\n-                    FieldMappingInfo info = fmds[i].getMappingInfo();\n-                    if (info.getTableName() != null)\n-                        _biOneToManyJoinTable = i;\n-                    _biOneToManyElemFK = fmds[i].getElementMapping().getForeignKey();\n-                    _biOneToManyJoinFK = fmds[i].getJoinForeignKey();\n-                }\n-                break;\n-            }\n-        }\n-    }\n-    \n     public Object toDataStoreValue(Object val, JDBCStore store) {\n         return RelationStrategies.toDataStoreValue(field, val, store);\n     }"}]}

