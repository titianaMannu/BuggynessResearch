{"sha":"c9a86d9652993e9a34426b2eb67606aff190dd26","node_id":"MDY6Q29tbWl0MjA2MzY0OmM5YTg2ZDk2NTI5OTNlOWEzNDQyNmIyZWI2NzYwNmFmZjE5MGRkMjY=","commit":{"author":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2010-08-08T03:53:59Z"},"committer":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2010-08-08T03:53:59Z"},"message":"OPENJPA-1752: TestPessimisticLocks JUNIT test produced inconsistent behavior with various backends\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@983340 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ae1f43d11ef905c7a2d102dd3f2b5dd9ab428197","url":"https://api.github.com/repos/apache/openjpa/git/trees/ae1f43d11ef905c7a2d102dd3f2b5dd9ab428197"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/c9a86d9652993e9a34426b2eb67606aff190dd26","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/c9a86d9652993e9a34426b2eb67606aff190dd26","html_url":"https://github.com/apache/openjpa/commit/c9a86d9652993e9a34426b2eb67606aff190dd26","comments_url":"https://api.github.com/repos/apache/openjpa/commits/c9a86d9652993e9a34426b2eb67606aff190dd26/comments","author":null,"committer":null,"parents":[{"sha":"bcfadcff1beb2ce2723ab79b817b90c77c6cc6d3","url":"https://api.github.com/repos/apache/openjpa/commits/bcfadcff1beb2ce2723ab79b817b90c77c6cc6d3","html_url":"https://github.com/apache/openjpa/commit/bcfadcff1beb2ce2723ab79b817b90c77c6cc6d3"}],"stats":{"total":72,"additions":47,"deletions":25},"files":[{"sha":"0f19d0dc7246f7bd5ced03bc71df22108f3ce136","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestPessimisticLocks.java","status":"modified","additions":47,"deletions":25,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/c9a86d9652993e9a34426b2eb67606aff190dd26/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestPessimisticLocks.java","raw_url":"https://github.com/apache/openjpa/raw/c9a86d9652993e9a34426b2eb67606aff190dd26/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestPessimisticLocks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestPessimisticLocks.java?ref=c9a86d9652993e9a34426b2eb67606aff190dd26","patch":"@@ -45,6 +45,7 @@\n public class TestPessimisticLocks extends SQLListenerTestCase {\n \n     private DBDictionary dict = null;\n+    private int lockWaitTime = 2000;\n \n     public void setUp() {\n         // Disable tests for any DB that has supportsQueryTimeout==false, like Postgres\n@@ -53,7 +54,7 @@ public void setUp() {\n             tempEMF = createEMF();\n         }\n         assertNotNull(tempEMF);\n-        DBDictionary dict = ((JDBCConfiguration)tempEMF.getConfiguration()).getDBDictionaryInstance();\n+        dict = ((JDBCConfiguration)tempEMF.getConfiguration()).getDBDictionaryInstance();\n         assertNotNull(dict);\n         if (!dict.supportsQueryTimeout)\n             setTestsDisabled(true);\n@@ -111,22 +112,25 @@ public void testFindAfterQueryWithPessimisticLocks() {\n         // Lock all selected Employees, skip the first one, i.e should lock\n         // Employee(2)\n         query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        query.setHint(\"javax.persistence.query.timeout\", lockWaitTime);\n         List<Employee> employees = query.getResultList();\n         assertEquals(\"Expected 1 element with emplyee id=2\", employees.size(), 1);\n         assertTrue(\"Test Employee first name = 'first.2'\", employees.get(0).getFirstName().equals(\"first.1\")\n                 || employees.get(0).getFirstName().equals(\"first.2\"));\n \n         em2.getTransaction().begin();\n         Map<String, Object> hints = new HashMap<String, Object>();\n-        hints.put(\"javax.persistence.lock.timeout\", 2000);\n+        hints.put(\"javax.persistence.lock.timeout\", lockWaitTime);\n         // find Employee(2) with a lock, should block and expected a\n         // PessimisticLockException\n         try {\n             em2.find(Employee.class, 2, LockModeType.PESSIMISTIC_READ, hints);\n             fail(\"Unexcpected find succeeded. Should throw a PessimisticLockException.\");\n-        } catch (Throwable e) {\n-            assertError(e, PessimisticLockException.class);\n+        } catch (Throwable e) {            \n+            if (!dict.supportsLockingWithMultipleTables)\n+                assertError(e, PessimisticLockException.class);\n+            else \n+                assertError(e, LockTimeoutException.class);\n         } finally {\n             if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n@@ -140,15 +144,15 @@ public void testFindAfterQueryWithPessimisticLocks() {\n         // Lock all selected Departments, skip the first one, i.e should\n         // lock Department(20)\n         query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        query.setHint(\"javax.persistence.query.timeout\", lockWaitTime);\n         List<Department> depts = query2.getResultList();\n         assertEquals(\"Expected 1 element with department id=20\", depts.size(), 1);\n         assertTrue(\"Test department name = 'D20'\", depts.get(0).getName().equals(\"D10\")\n                 || depts.get(0).getName().equals(\"D20\"));\n \n         em2.getTransaction().begin();\n         Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(\"javax.persistence.lock.timeout\", 2000);\n+        map.put(\"javax.persistence.lock.timeout\", lockWaitTime);\n         // find Employee(2) with a lock, no block since only department was\n         // locked\n         try {\n@@ -178,21 +182,24 @@ public void testFindAfterQueryOrderByWithPessimisticLocks() {\n         // Lock all selected Employees, skip the first one, i.e should lock\n         // Employee(2)\n         query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        query.setHint(\"javax.persistence.query.timeout\", lockWaitTime);\n         List<Employee> q = query.getResultList();\n         assertEquals(\"Expected 1 element with emplyee id=2\", q.size(), 1);\n         assertEquals(\"Test Employee first name = 'first.2'\", q.get(0).getFirstName(), \"first.2\");\n \n         em2.getTransaction().begin();\n         Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(\"javax.persistence.lock.timeout\", 2000);\n+        map.put(\"javax.persistence.lock.timeout\", lockWaitTime);\n         // find Employee(2) with a lock, should block and expected a\n         // PessimisticLockException\n         try {\n             em2.find(Employee.class, 2, LockModeType.PESSIMISTIC_READ, map);\n             fail(\"Unexcpected find succeeded. Should throw a PessimisticLockException.\");\n         } catch (Exception e) {\n-            assertError(e, PessimisticLockException.class);\n+            if (!dict.supportsLockingWithMultipleTables)\n+                assertError(e, PessimisticLockException.class);\n+            else\n+                assertError(e, LockTimeoutException.class);\n         } finally {\n             if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n@@ -206,22 +213,25 @@ public void testFindAfterQueryOrderByWithPessimisticLocks() {\n         // Lock all selected Departments, skip the first one, i.e should\n         // lock Department(20)\n         query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        query.setHint(\"javax.persistence.query.timeout\", lockWaitTime);\n         List<Department> result = query.getResultList();\n         assertEquals(\"Expected 1 element with department id=20\", q.size(), 1);\n         assertEquals(\"Test department name = 'D20'\", result.get(0).getName(), \"D20\");\n \n         em2.getTransaction().begin();\n         map.clear();\n-        map.put(\"javax.persistence.lock.timeout\", 2000);\n+        map.put(\"javax.persistence.lock.timeout\", lockWaitTime);\n         // find Employee(2) with a lock, no block since only department was\n         // locked\n         try {\n             Employee emp = em2.find(Employee.class, 1, LockModeType.PESSIMISTIC_READ, map);\n             assertNotNull(\"Query locks department only, therefore should find Employee.\", emp);\n             assertEquals(\"Test Employee first name = 'first.1'\", emp.getFirstName(), \"first.1\");\n         } catch (Exception ex) {\n-            fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n+            if (!dict.supportsLockingWithOrderClause)\n+                fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n+            else \n+                assertError(ex, LockTimeoutException.class);\n         } finally {\n             if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n@@ -241,22 +251,25 @@ public void testQueryAfterFindWithPessimisticLocks() {\n         try {\n             em2.getTransaction().begin();\n             Map<String, Object> map = new HashMap<String, Object>();\n-            map.put(\"javax.persistence.lock.timeout\", 2000);\n+            map.put(\"javax.persistence.lock.timeout\", lockWaitTime);\n             // Lock Emplyee(1), no department should be locked\n             em2.find(Employee.class, 1, LockModeType.PESSIMISTIC_READ, map);\n \n             em1.getTransaction().begin();\n             Query query = em1.createQuery(\"select e.department from Employee e where e.id < 10\").setFirstResult(1);\n             query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-            query.setHint(\"javax.persistence.query.timeout\", 2000);\n+            query.setHint(\"javax.persistence.query.timeout\", lockWaitTime);\n             // Lock all selected Department but skip the first, i.e. lock\n             // Department(20), should query successfully.\n             List<Department> q = query.getResultList();\n             assertEquals(\"Expected 1 element with department id=20\", q.size(), 1);\n             assertTrue(\"Test department name = 'D20'\", q.get(0).getName().equals(\"D10\")\n                     || q.get(0).getName().equals(\"D20\"));\n         } catch (Exception ex) {\n-            fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n+            if (!dict.supportsLockingWithMultipleTables)\n+                fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n+            else\n+                assertError(ex, QueryTimeoutException.class);\n         } finally {\n             if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n@@ -267,7 +280,7 @@ public void testQueryAfterFindWithPessimisticLocks() {\n         em2.getTransaction().begin();\n \n         Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(\"javax.persistence.lock.timeout\", 2000);\n+        map.put(\"javax.persistence.lock.timeout\", lockWaitTime);\n         // Lock Emplyee(2), no department should be locked\n         em2.find(Employee.class, 2, LockModeType.PESSIMISTIC_READ, map);\n \n@@ -276,12 +289,15 @@ public void testQueryAfterFindWithPessimisticLocks() {\n         // Lock all selected Employees, skip the first one, i.e should lock\n         // Employee(2)\n         query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-        query.setHint(\"javax.persistence.query.timeout\", 1000);\n+        query.setHint(\"javax.persistence.query.timeout\", lockWaitTime);\n         try {\n             List<Employee> q = query.getResultList();\n             fail(\"Unexcpected find succeeded. Should throw a PessimisticLockException.\");\n         } catch (Exception e) {\n-            assertError(e, PessimisticLockException.class);\n+            if (!dict.supportsLockingWithMultipleTables)\n+                assertError(e, PessimisticLockException.class);\n+            else\n+                assertError(e, QueryTimeoutException.class);\n         } finally {\n             if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n@@ -300,23 +316,26 @@ public void testQueryOrderByAfterFindWithPessimisticLocks() {\n         EntityManager em2 = emf.createEntityManager();\n         em2.getTransaction().begin();\n         Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(\"javax.persistence.lock.timeout\", 2000);\n+        map.put(\"javax.persistence.lock.timeout\", lockWaitTime);\n         // Lock Emplyee(1), no department should be locked\n         em2.find(Employee.class, 1, LockModeType.PESSIMISTIC_READ, map);\n \n         em1.getTransaction().begin();\n         Query query = em1.createQuery(\"select e.department from Employee e where e.id < 10 order by e.department.id\")\n                 .setFirstResult(1);\n         query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        query.setHint(\"javax.persistence.query.timeout\", lockWaitTime);\n         // Lock all selected Department but skip the first, i.e. lock\n         // Department(20), should query successfully.\n         try {\n             List<Department> q = query.getResultList();\n             assertEquals(\"Expected 1 element with department id=20\", q.size(), 1);\n             assertEquals(\"Test department name = 'D20'\", q.get(0).getName(), \"D20\");\n         } catch (Exception ex) {\n-            fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n+            if (!dict.supportsLockingWithMultipleTables)\n+                fail(\"Caught unexpected \" + ex.getClass().getName() + \":\" + ex.getMessage());\n+            else \n+                assertError(ex, QueryTimeoutException.class);\n         } finally {\n             if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();\n@@ -327,7 +346,7 @@ public void testQueryOrderByAfterFindWithPessimisticLocks() {\n         em2.getTransaction().begin();\n \n         map.clear();\n-        map.put(\"javax.persistence.lock.timeout\", 2000);\n+        map.put(\"javax.persistence.lock.timeout\", lockWaitTime);\n         // Lock Emplyee(2), no department should be locked\n         em2.find(Employee.class, 2, LockModeType.PESSIMISTIC_READ, map);\n \n@@ -336,12 +355,15 @@ public void testQueryOrderByAfterFindWithPessimisticLocks() {\n         // Lock all selected Employees, skip the first one, i.e should lock\n         // Employee(2)\n         query.setLockMode(LockModeType.PESSIMISTIC_READ);\n-        query.setHint(\"javax.persistence.query.timeout\", 2000);\n+        query.setHint(\"javax.persistence.query.timeout\", lockWaitTime);\n         try {\n             List<?> q = query.getResultList();\n             fail(\"Unexcpected find succeeded. Should throw a PessimisticLockException.\");\n         } catch (Exception e) {\n-            assertError(e, PessimisticLockException.class);\n+            if (!dict.supportsLockingWithMultipleTables)\n+                assertError(e, PessimisticLockException.class);\n+            else \n+                assertError(e, QueryTimeoutException.class);\n         } finally {\n             if (em1.getTransaction().isActive())\n                 em1.getTransaction().rollback();"}]}

