{"sha":"c9fd7810079e9c53fa9600140b967f2a79342218","node_id":"MDY6Q29tbWl0MjA2MzY0OmM5ZmQ3ODEwMDc5ZTljNTNmYTk2MDAxNDBiOTY3ZjJhNzkzNDIyMTg=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2008-05-02T22:21:51Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2008-05-02T22:21:51Z"},"message":"Simplify algorithm in NullSafeConcurrentHashMap; change SizedConcurrentHashMap's algorithms to remove overflow before putting new records into cache instead of after to avoid removing the very instances that were put.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.1.x@652930 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a56d1031f3258055766036badc4c196ecf5ded5a","url":"https://api.github.com/repos/apache/openjpa/git/trees/a56d1031f3258055766036badc4c196ecf5ded5a"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/c9fd7810079e9c53fa9600140b967f2a79342218","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/c9fd7810079e9c53fa9600140b967f2a79342218","html_url":"https://github.com/apache/openjpa/commit/c9fd7810079e9c53fa9600140b967f2a79342218","comments_url":"https://api.github.com/repos/apache/openjpa/commits/c9fd7810079e9c53fa9600140b967f2a79342218/comments","author":null,"committer":null,"parents":[{"sha":"d8b82311f5269ea7f4543853e087a67a6982ab45","url":"https://api.github.com/repos/apache/openjpa/commits/d8b82311f5269ea7f4543853e087a67a6982ab45","html_url":"https://github.com/apache/openjpa/commit/d8b82311f5269ea7f4543853e087a67a6982ab45"}],"stats":{"total":51,"additions":31,"deletions":20},"files":[{"sha":"08c6c3cc7cb13f1a220be2176cc25026a2debef9","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","status":"modified","additions":13,"deletions":12,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/c9fd7810079e9c53fa9600140b967f2a79342218/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/c9fd7810079e9c53fa9600140b967f2a79342218/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java?ref=c9fd7810079e9c53fa9600140b967f2a79342218","patch":"@@ -83,20 +83,21 @@ public Entry removeRandom() {\n         // as other threads remove the same entries, whereas the random\r\n         // iterator may return values that have been removed.\r\n \r\n-        while (!isEmpty()) {\r\n-            while (!randomKeys.isEmpty()) {\r\n-                // randomKeys contains null-masked data\r\n-                Iterator iter = randomKeys.iterator();\r\n-                Object key = iter.next();\r\n-                if (key != null && randomKeys.remove(key)) {\r\n-                    Object val = super.remove(key);\r\n-                    if (val != null)\r\n-                        return new EntryImpl(unmaskNull(key), unmaskNull(val));\r\n-                }\r\n+        for (Iterator iter = randomKeys.iterator(); iter.hasNext(); ) {\r\n+            // randomKeys contains null-masked data\r\n+            Object key = iter.next();\r\n+            if (key != null && randomKeys.remove(key)) {\r\n+                Object val = super.remove(key);\r\n+                if (val != null)\r\n+                    return new EntryImpl(unmaskNull(key), unmaskNull(val));\r\n             }\r\n+        }\r\n \r\n-            // if randomKeys is empty, fall back to non-random behavior.\r\n-            Object key = super.keySet().iterator().next();\r\n+        // if randomKeys is empty, fall back to non-random behavior.\r\n+        for (Iterator iter = super.keySet().iterator(); iter.hasNext(); ) {\r\n+            Object key = iter.next();\r\n+            if (key == null)\r\n+                continue;\r\n             Object val = super.remove(key);\r\n             if (val != null)\r\n                 return new EntryImpl(unmaskNull(key), unmaskNull(val));\r"},{"sha":"c31e26ddcd1ec3546f8b101e744d4deab55d41ba","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","status":"modified","additions":18,"deletions":8,"changes":26,"blob_url":"https://github.com/apache/openjpa/blob/c9fd7810079e9c53fa9600140b967f2a79342218/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/c9fd7810079e9c53fa9600140b967f2a79342218/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java?ref=c9fd7810079e9c53fa9600140b967f2a79342218","patch":"@@ -56,18 +56,16 @@ public SizedConcurrentHashMap(int size, float load, int concurrencyLevel) {\n \r\n     @Override\r\n     public Object putIfAbsent(Object key, Object value) {\r\n-        Object o = super.putIfAbsent(key, value);\r\n         if (maxSize != Integer.MAX_VALUE)\r\n-            removeOverflow();\r\n-        return o;\r\n+            removeOverflow(true);\r\n+        return super.putIfAbsent(key, value);\r\n     }\r\n \r\n     @Override\r\n     public Object put(Object key, Object value) {\r\n-        Object o = super.put(key, value);\r\n         if (maxSize != Integer.MAX_VALUE)\r\n-            removeOverflow();\r\n-        return o;\r\n+            removeOverflow(true);\r\n+        return super.put(key, value);\r\n     }\r\n \r\n     public int getMaxSize() {\r\n@@ -79,11 +77,23 @@ public void setMaxSize(int max) {\n             throw new IllegalArgumentException(String.valueOf(max));\r\n         maxSize = max;\r\n \r\n-        removeOverflow();\r\n+        removeOverflow(false);\r\n     }\r\n \r\n+    /**\r\n+     * Equivalent to <code>removeOverflow(false)</code>.\r\n+     */\r\n     protected void removeOverflow() {\r\n-        while (size() > maxSize) {\r\n+        removeOverflow(false);\r\n+    }\r\n+\r\n+    /**\r\n+     * Removes overflow. If <code>forPut</code> is <code>true</code>, then\r\n+     * this uses <code>size() + 1</code> when computing size.\r\n+     */\r\n+    protected void removeOverflow(boolean forPut) {\r\n+        int sizeToCompareTo = forPut ? maxSize - 1 : maxSize;\r\n+        while (size() > sizeToCompareTo) {\r\n             Entry entry = removeRandom();\r\n             // if removeRandom() returns null, break out of the loop. Of course,\r\n             // since we're not locking, the size might not actually be null\r"}]}

