{"sha":"cd4c8839f87f750e2655a5b98f552e2ba4031a67","node_id":"MDY6Q29tbWl0MjA2MzY0OmNkNGM4ODM5Zjg3Zjc1MGUyNjU1YTViOThmNTUyZTJiYTQwMzFhNjc=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-08-26T01:24:57Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-08-26T01:24:57Z"},"message":"[maven-release-plugin]  copy for tag 1.0.4\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/tags/1.0.4@989420 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"1fe1e0ea43954a8604d7ed99abb0b88a0cc67a5e","url":"https://api.github.com/repos/apache/openjpa/git/trees/1fe1e0ea43954a8604d7ed99abb0b88a0cc67a5e"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/cd4c8839f87f750e2655a5b98f552e2ba4031a67","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/cd4c8839f87f750e2655a5b98f552e2ba4031a67","html_url":"https://github.com/apache/openjpa/commit/cd4c8839f87f750e2655a5b98f552e2ba4031a67","comments_url":"https://api.github.com/repos/apache/openjpa/commits/cd4c8839f87f750e2655a5b98f552e2ba4031a67/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"3c939144327d3b2be6994e919f5249fdfe030d77","url":"https://api.github.com/repos/apache/openjpa/commits/3c939144327d3b2be6994e919f5249fdfe030d77","html_url":"https://github.com/apache/openjpa/commit/3c939144327d3b2be6994e919f5249fdfe030d77"},{"sha":"a36edfc88c1781b4993010ed14cfa92fd59190bd","url":"https://api.github.com/repos/apache/openjpa/commits/a36edfc88c1781b4993010ed14cfa92fd59190bd","html_url":"https://github.com/apache/openjpa/commit/a36edfc88c1781b4993010ed14cfa92fd59190bd"}],"stats":{"total":55654,"additions":32829,"deletions":22825},"files":[{"sha":"319471629e60386304c42cc9b73dbd3288e1754a","filename":".gitignore","status":"added","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/.gitignore","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/.gitignore","contents_url":"https://api.github.com/repos/apache/openjpa/contents/.gitignore?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -0,0 +1,6 @@\n+.settings\n+.project\n+.classpath\n+target\n+velocity.log\n+derby.log"},{"sha":"df04f563a65048d8d48eb0544dd94ab7b46a04e1","filename":"openjpa-all/pom.xml","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-all/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-all/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-all/pom.xml?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -28,7 +28,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-parent</artifactId>\n-        <version>1.0.3</version>\n+        <version>1.0.4</version>\n     </parent>\n     <properties>\n         <scm.dir>svn.apache.org/repos/asf/openjpa/branches/1.0.x/openjpa-all</scm.dir>\n@@ -50,6 +50,7 @@\n                     multiple same-named files to each other (which is\n                     required for correctly aggregating services files).\n                 -->\n+                <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-antrun-plugin</artifactId>\n                 <executions>\n                     <execution>\n@@ -61,6 +62,8 @@\n                                     <fileset dir=\"${basedir}/..\">\n                                         <include name=\"*/target/openjpa-*.jar\" />\n                                         <exclude name=\"*/target/openjpa-examples-*.jar\" />\n+                                        <exclude name=\"**/*-sources.jar\" />\n+                                        <exclude name=\"**/*-javadoc.jar\" />\n                                     </fileset>\n                                 </unjar>\n "},{"sha":"f9f8dede2c664d539e212ae37dc83ca4836b6a9d","filename":"openjpa-examples/pom.xml","status":"modified","additions":1,"deletions":35,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-examples/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-examples/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-examples/pom.xml?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -31,7 +31,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-parent</artifactId>\n-        <version>1.0.3</version>\n+        <version>1.0.4</version>\n     </parent>\n     <dependencies>\n         <dependency>\n@@ -65,8 +65,6 @@\n                 <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-compiler-plugin</artifactId>\n                 <configuration>\n-                    <source>1.5</source>\n-                    <target>1.5</target>\n                     <!--\n                         need to skip reversemapping since it depends on\n                         classes that are generated by the build.xml file\n@@ -76,38 +74,6 @@\n                     </excludes>\n                 </configuration>\n             </plugin>\n-            <!-- ###\n-            <plugin>\n-                <artifactId>maven-antrun-plugin</artifactId>\n-                <executions>\n-                    <execution>\n-                        <phase>test-compile</phase>\n-                        <configuration>\n-                            <tasks>\n-                                <path id=\"cp\">\n-                                    <path refid=\"maven.test.classpath\" />\n-                                    <path refid=\"maven.compile.classpath\" />\n-                                    <path refid=\"maven.dependency.classpath\" />\n-                                </path>\n-\t\t\t\t\t\t\t\t<taskdef name=\"openjpac\" classname= \"org.apache.openjpa.ant.PCEnhancerTask\">\n-\t\t\t\t\t\t\t\t\t<classpath refid=\"cp\" />\n-\t\t\t\t\t\t\t\t</taskdef>\n-                                <fileset id=\"enhance.path.ref\" dir=\"${project.build.testOutputDirectory}\">\n-                                    <include name=\"**/*.class\" />\n-                                </fileset>\n-\t\t\t\t\t\t\t\t<openjpac>\n-\t\t\t\t\t\t\t\t\t<classpath refid=\"cp\" />\n-\t\t\t\t\t\t\t\t\t<fileset refid=\"enhance.path.ref\" />\n-\t\t\t\t\t\t\t\t</openjpac>\n-                            </tasks>\n-                        </configuration>\n-                        <goals>\n-                            <goal>run</goal>\n-                        </goals>\n-                    </execution>\n-                </executions>\n-            </plugin>\n-            -->\n         </plugins>\n     </build>\n </project>"},{"sha":"b91b261a9477114c5cfb940a24273c15ce8adce9","filename":"openjpa-integration/examples/pom.xml","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-integration/examples/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-integration/examples/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-integration/examples/pom.xml?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -36,7 +36,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-integration</artifactId>\n-        <version>1.0.3</version>\n+        <version>1.0.4</version>\n     </parent>\n \n     <profiles>\n@@ -45,6 +45,7 @@\n     <build>\n         <plugins>\n             <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-antrun-plugin</artifactId>\n                 <executions>\n                     <execution>"},{"sha":"5f28aaa7f2267ef56b9413151e235061c0826609","filename":"openjpa-integration/pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-integration/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-integration/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-integration/pom.xml?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -28,7 +28,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-parent</artifactId>\n-        <version>1.0.3</version>\n+        <version>1.0.4</version>\n     </parent>\n     <modules>\n         <module>examples</module>"},{"sha":"d6b0e1ff2b654fb20d38ef791d2f222f6e5034cf","filename":"openjpa-integration/tck/pom.xml","status":"modified","additions":6,"deletions":14,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-integration/tck/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-integration/tck/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-integration/tck/pom.xml?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -54,7 +54,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-integration</artifactId>\n-        <version>1.0.3</version>\n+        <version>1.0.4</version>\n     </parent>\n \n     <profiles>\n@@ -63,6 +63,7 @@\n     <build>\n         <plugins>\n             <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-antrun-plugin</artifactId>\n                 <executions>\n                     <execution>\n@@ -252,22 +253,13 @@ database.driver=${db.driver}\n     </profile>\n     </profiles>\n \n-    <repositories>\n-        <repository>\n-            <id>java.net</id>\n-            <name>Java.net Maven Repository</name>\n-            <url>https://maven-repository.dev.java.net/nonav/repository</url>\n-            <layout>legacy</layout>\n-        </repository>\n-    </repositories>\n-\n     <dependencies>\n         <!-- use the authoritative javax.persistence API for testing -->\n         <dependency>\n-            <groupId>javax.persistence</groupId>\n-            <artifactId>persistence-api</artifactId>\n-            <version>1.0b</version>\n-        </dependency>\n+            <groupId>org.apache.geronimo.specs</groupId>\n+            <artifactId>geronimo-jpa_3.0_spec</artifactId>\n+            <version>1.1.1</version>\n+        </dependency> \n         <dependency>\n             <groupId>org.apache.openjpa</groupId>\n             <artifactId>openjpa-kernel</artifactId>"},{"sha":"9a10c65305be4988541af0c998353cbd1a0dff8d","filename":"openjpa-jdbc-5/pom.xml","status":"modified","additions":1,"deletions":13,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc-5/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc-5/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc-5/pom.xml?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -31,7 +31,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-parent</artifactId>\n-        <version>1.0.3</version>\n+        <version>1.0.4</version>\n     </parent>\n     <dependencies>\n         <dependency>\n@@ -46,16 +46,4 @@\n \t\t    <version>2.0</version>\n \t    </dependency>\n     </dependencies>\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-compiler-plugin</artifactId>\n-                <configuration>\n-                    <source>1.5</source>\n-                    <target>1.5</target>\n-                </configuration>\n-            </plugin>\n-        </plugins>\n-    </build>\n </project>"},{"sha":"889b2f43db053b070ba79f6200566a9396ba8931","filename":"openjpa-jdbc/pom.xml","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/pom.xml?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -31,7 +31,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-parent</artifactId>\n-        <version>1.0.3</version>\n+        <version>1.0.4</version>\n     </parent>\n     <profiles>\n         <profile>\n@@ -41,6 +41,7 @@\n                 <pluginManagement>\n                     <plugins>\n                         <plugin>\n+                            <groupId>org.apache.maven.plugins</groupId>\n                             <artifactId>maven-compiler-plugin</artifactId>\n                             <configuration>\n                                 <compilerArguments>\n@@ -70,6 +71,7 @@\n     <build>\n         <plugins>\n             <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-compiler-plugin</artifactId>\n                 <configuration>\n                     <source>1.4</source>"},{"sha":"aad1d2ac765c668a3f2b8871e20ed6502077a2d2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -57,8 +57,9 @@ public void setType(int type) {\n     public Object next(StoreContext ctx, ClassMetaData meta) {\n         JDBCStore store = getStore(ctx);\n         try {\n-            current = nextInternal(store, (ClassMapping) meta);\n-            return current;\n+            Object currentLocal = nextInternal(store, (ClassMapping) meta);\n+            current = currentLocal;\n+            return currentLocal;\n         } catch (OpenJPAException ke) {\n             throw ke;\n         } catch (SQLException se) {"},{"sha":"3db3198dd04ab43f37ef467c5cf6283796d4d45f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","status":"modified","additions":545,"deletions":545,"changes":1090,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,546 +1,546 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import java.sql.Connection;\r\n-import java.sql.SQLException;\r\n-import java.util.Collection;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n-import org.apache.openjpa.jdbc.schema.Column;\r\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\r\n-import org.apache.openjpa.jdbc.schema.Table;\r\n-import org.apache.openjpa.jdbc.sql.PrimaryRow;\r\n-import org.apache.openjpa.jdbc.sql.Row;\r\n-import org.apache.openjpa.jdbc.sql.RowImpl;\r\n-import org.apache.openjpa.jdbc.sql.RowManager;\r\n-import org.apache.openjpa.jdbc.sql.RowManagerImpl;\r\n-import org.apache.openjpa.jdbc.sql.SQLExceptions;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.lib.graph.DepthFirstAnalysis;\r\n-import org.apache.openjpa.lib.graph.Edge;\r\n-import org.apache.openjpa.lib.graph.Graph;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.OpenJPAException;\r\n-import org.apache.openjpa.util.UserException;\r\n-\r\n-/**\r\n- * <p>Standard update manager, capable of foreign key constraint evaluation.</p>\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class ConstraintUpdateManager\r\n-    extends AbstractUpdateManager {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (ConstraintUpdateManager.class);\r\n-\r\n-    public boolean orderDirty() {\r\n-        return false;\r\n-    }\r\n-\r\n-    protected PreparedStatementManager newPreparedStatementManager\r\n-        (JDBCStore store, Connection conn) {\r\n-        return new PreparedStatementManagerImpl(store, conn);\r\n-    }\r\n-\r\n-    protected RowManager newRowManager() {\r\n-        return new RowManagerImpl(false);\r\n-    }\r\n-\r\n-    protected Collection flush(RowManager rowMgr,\r\n-        PreparedStatementManager psMgr, Collection exceps) {\r\n-        RowManagerImpl rmimpl = (RowManagerImpl) rowMgr;\r\n-\r\n-        // first take care of all secondary table deletes and 'all row' deletes\r\n-        // (which are probably secondary table deletes), since no foreign\r\n-        // keys ever rely on secondary table pks\r\n-        flush(rmimpl.getAllRowDeletes(), psMgr);\r\n-        flush(rmimpl.getSecondaryDeletes(), psMgr);\r\n-\r\n-        // now do any 'all row' updates\r\n-        flush(rmimpl.getAllRowUpdates(), psMgr);\r\n-\r\n-        // analyze foreign keys\r\n-        Collection inserts = rmimpl.getInserts();\r\n-        Collection updates = rmimpl.getUpdates();\r\n-        Collection deletes = rmimpl.getDeletes();\r\n-        Graph[] graphs = new Graph[2];    // insert graph, delete graph\r\n-        analyzeForeignKeys(inserts, updates, deletes, rmimpl, graphs);\r\n-\r\n-        // flush insert graph, if any\r\n-        boolean autoAssign = rmimpl.hasAutoAssignConstraints();\r\n-        try {\r\n-            flushGraph(graphs[0], psMgr, autoAssign);\r\n-        } catch (SQLException se) {\r\n-            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\r\n-        } catch (OpenJPAException ke) {\r\n-            exceps = addException(exceps, ke);\r\n-        }\r\n-\r\n-        // flush the rest of the inserts and updates; inserts before updates\r\n-        // because some update fks might reference pks that have to be inserted\r\n-        flush(inserts, psMgr);\r\n-        flush(updates, psMgr);\r\n-\r\n-        // flush the delete graph, if any\r\n-        try {\r\n-            flushGraph(graphs[1], psMgr, autoAssign);\r\n-        } catch (SQLException se) {\r\n-            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\r\n-        } catch (OpenJPAException ke) {\r\n-            exceps = addException(exceps, ke);\r\n-        }\r\n-\r\n-        // put the remainder of the deletes after updates because some updates\r\n-        // may be nulling fks to rows that are going to be deleted\r\n-        flush(deletes, psMgr);\r\n-\r\n-        // take care of all secondary table inserts and updates last, since\r\n-        // they may rely on previous inserts or updates, but nothing relies\r\n-        // on them\r\n-        flush(rmimpl.getSecondaryUpdates(), psMgr);\r\n-\r\n-        // flush any left over prepared statements\r\n-        psMgr.flush();\r\n-        return exceps;\r\n-    }\r\n-\r\n-    /**\r\n-     * Analyze foreign key dependencies on the given rows\r\n-     * and create an insert and a delete graph to execute.  The insert\r\n-     * graph will be flushed before all other rows, and the delete graph will\r\n-     * be flushed after them.\r\n-     */\r\n-    private void analyzeForeignKeys(Collection inserts, Collection updates,\r\n-        Collection deletes, RowManagerImpl rowMgr, Graph[] graphs) {\r\n-        // if there are any deletes, we have to map the insert objects on their\r\n-        // oids so we'll be able to detect delete-then-insert-same-pk cases\r\n-        Map insertMap = null;\r\n-        OpenJPAStateManager sm;\r\n-        if (!deletes.isEmpty() && !inserts.isEmpty()) {\r\n-            insertMap = new HashMap((int) (inserts.size() * 1.33 + 1));\r\n-            for (Iterator itr = inserts.iterator(); itr.hasNext();) {\r\n-                sm = ((Row) itr.next()).getPrimaryKey();\r\n-                if (sm != null && sm.getObjectId() != null)\r\n-                    insertMap.put(sm.getObjectId(), sm);\r\n-            }\r\n-        }\r\n-\r\n-        // first construct the graph for deletes; this may expand to include\r\n-        // inserts and updates as well if there are any inserts that rely on\r\n-        // deletes (delete-then-insert-same-pk cases)\r\n-        PrimaryRow row;\r\n-        Row row2;\r\n-        ForeignKey[] fks;\r\n-        OpenJPAStateManager fkVal;\r\n-        boolean ignoreUpdates = true;\r\n-        for (Iterator itr = deletes.iterator(); itr.hasNext();) {\r\n-            row = (PrimaryRow) itr.next();\r\n-            if (!row.isValid())\r\n-                continue;\r\n-\r\n-            row2 = getInsertRow(insertMap, rowMgr, row);\r\n-            if (row2 != null) {\r\n-                ignoreUpdates = false;\r\n-                graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row, null);\r\n-            }\r\n-\r\n-            // now check this row's fks against other deletes\r\n-            fks = row.getTable().getForeignKeys();\r\n-            for (int j = 0; j < fks.length; j++) {\r\n-                // when deleting ref fks they'll just set a where value, so\r\n-                // check both for fk updates (relation fks) and wheres (ref fks)\r\n-                fkVal = row.getForeignKeySet(fks[j]);\r\n-                if (fkVal == null)\r\n-                    fkVal = row.getForeignKeyWhere(fks[j]);\r\n-                if (fkVal == null)\r\n-                    continue;\r\n-\r\n-                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\r\n-                    Row.ACTION_DELETE, fkVal, false);\r\n-                if (row2 != null && row2.isValid() && row2 != row)\r\n-                    graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row,\r\n-                        fks[j]);\r\n-            }\r\n-        }\r\n-\r\n-        if (ignoreUpdates)\r\n-            graphs[0] = analyzeAgainstInserts(inserts, rowMgr, graphs[0]);\r\n-        else {\r\n-            // put inserts *and updates* in the delete graph; they all rely\r\n-            // on each other\r\n-            graphs[1] = analyzeAgainstInserts(updates, rowMgr, graphs[1]);\r\n-            graphs[1] = analyzeAgainstInserts(inserts, rowMgr, graphs[1]);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if there is an insert for for the same table and primary\r\n-     * key values as the given delete row.\r\n-     */\r\n-    private Row getInsertRow(Map insertMap, RowManagerImpl rowMgr, Row row) {\r\n-        if (insertMap == null)\r\n-            return null;\r\n-\r\n-        OpenJPAStateManager sm = row.getPrimaryKey();\r\n-        if (sm == null)\r\n-            return null;\r\n-\r\n-        // look for a new object whose insert id is the same as this delete one\r\n-        Object oid = sm.getObjectId();\r\n-        OpenJPAStateManager nsm = (OpenJPAStateManager) insertMap.get(oid);\r\n-        if (nsm == null)\r\n-            return null;\r\n-\r\n-        // found new object; get its row\r\n-        row = rowMgr.getRow(row.getTable(), Row.ACTION_INSERT, nsm, false);\r\n-        return (row == null || row.isValid()) ? row : null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Analyze the given rows against the inserts, placing dependencies\r\n-     * in the given graph.\r\n-     */\r\n-    private Graph analyzeAgainstInserts(Collection rows, RowManagerImpl rowMgr,\r\n-        Graph graph) {\r\n-        PrimaryRow row;\r\n-        Row row2;\r\n-        ForeignKey[] fks;\r\n-        Column[] cols;\r\n-        for (Iterator itr = rows.iterator(); itr.hasNext();) {\r\n-            row = (PrimaryRow) itr.next();\r\n-            if (!row.isValid())\r\n-                continue;\r\n-\r\n-            // check this row's fks against inserts; a logical fk to an auto-inc\r\n-            // column is treated just as actual database fk because the result\r\n-            // is the same: the pk row has to be inserted before the fk row\r\n-            fks = row.getTable().getForeignKeys();\r\n-            for (int j = 0; j < fks.length; j++) {\r\n-                if (row.getForeignKeySet(fks[j]) == null)\r\n-                    continue;\r\n-\r\n-                // see if this row is dependent on another.  if it's only\r\n-                // depenent on itself, see if the fk is logical or deferred, in\r\n-                // which case it must be an auto-inc because otherwise we\r\n-                // wouldn't have recorded it\r\n-                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\r\n-                    Row.ACTION_INSERT, row.getForeignKeySet(fks[j]), false);\r\n-                if (row2 != null && row2.isValid() && (row2 != row\r\n-                    || fks[j].isDeferred() || fks[j].isLogical()))\r\n-                    graph = addEdge(graph, row, (PrimaryRow) row2, fks[j]);\r\n-            }\r\n-\r\n-            // see if there are any relation id columns dependent on\r\n-            // auto-inc objects\r\n-            cols = row.getTable().getRelationIdColumns();\r\n-            for (int j = 0; j < cols.length; j++) {\r\n-                OpenJPAStateManager sm = row.getRelationIdSet(cols[j]);\r\n-                if (sm == null)\r\n-                    continue;\r\n-\r\n-                row2 = rowMgr.getRow(getBaseTable(sm), Row.ACTION_INSERT,\r\n-                    sm, false);\r\n-                if (row2 != null && row2.isValid())\r\n-                    graph = addEdge(graph, row, (PrimaryRow) row2, cols[j]);\r\n-            }\r\n-        }\r\n-        return graph;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the base table for the given instance.\r\n-     */\r\n-    private static Table getBaseTable(OpenJPAStateManager sm) {\r\n-        ClassMapping cls = (ClassMapping) sm.getMetaData();\r\n-        while (cls.getJoinablePCSuperclassMapping() != null)\r\n-            cls = cls.getJoinablePCSuperclassMapping();\r\n-        return cls.getTable();\r\n-    }\r\n-\r\n-    /**\r\n-     * Add an edge between the given rows in the given foreign key graph.\r\n-     */\r\n-    private Graph addEdge(Graph graph, PrimaryRow row1, PrimaryRow row2,\r\n-        Object fk) {\r\n-        // delay creation of the graph\r\n-        if (graph == null)\r\n-            graph = new Graph();\r\n-\r\n-        row1.setDependent(true);\r\n-        row2.setDependent(true);\r\n-        graph.addNode(row1);\r\n-        graph.addNode(row2);\r\n-\r\n-        // add an edge from row1 to row2, and set the fk causing the\r\n-        // dependency as the user object so we can retrieve it when resolving\r\n-        // circular constraints\r\n-        Edge edge = new Edge(row1, row2, true);\r\n-        edge.setUserObject(fk);\r\n-        graph.addEdge(edge);\r\n-\r\n-        return graph;\r\n-    }\r\n-\r\n-    /**\r\n-     * Flush the given graph of rows in the proper order.\r\n-     * @param graph The graph of statements to be walked\r\n-     * @param psMgr The prepared statement manager to use to issue the\r\n-     * statements\r\n-     * @param autoAssign Whether any of the rows in the graph have any\r\n-     * auto-assign constraints\r\n-     */\r\n-    protected void flushGraph(Graph graph, PreparedStatementManager psMgr,\r\n-        boolean autoAssign)\r\n-        throws SQLException {\r\n-        if (graph == null)\r\n-            return;\r\n-\r\n-        DepthFirstAnalysis dfa = newDepthFirstAnalysis(graph, autoAssign);\r\n-        Collection insertUpdates = new LinkedList();\r\n-        Collection deleteUpdates = new LinkedList();\r\n-        boolean recalculate;\r\n-\r\n-        // Handle circular constraints:\r\n-        // - if deleted row A has a ciricular fk to deleted row B, \r\n-        //   then use an update statement to null A's fk to B before flushing, \r\n-        //   and then flush\r\n-        // - if inserted row A has a circular fk to updated/inserted row B,\r\n-        //   then null the fk in the B row object, then flush,\r\n-        //   and after flushing, use an update to set the fk back to A\r\n-        // Depending on where circular dependencies are broken, the  \r\n-        // topological order of the graph nodes has to be re-calculated.\r\n-        recalculate = resolveCycles(graph, dfa.getEdges(Edge.TYPE_BACK),\r\n-                deleteUpdates, insertUpdates);\r\n-        recalculate |= resolveCycles(graph, dfa.getEdges(Edge.TYPE_FORWARD),\r\n-                deleteUpdates, insertUpdates);\r\n-\r\n-        if (recalculate) {\r\n-            dfa = recalculateDepthFirstAnalysis(graph, autoAssign);\r\n-        }\r\n-\r\n-        // flush delete updates to null fks, then all rows in order, then\r\n-        // the insert updates to set circular fk values\r\n-        flush(deleteUpdates, psMgr);\r\n-        Collection nodes = dfa.getSortedNodes();\r\n-        for (Iterator itr = nodes.iterator(); itr.hasNext();)\r\n-            psMgr.flush((RowImpl) itr.next());\r\n-        flush(insertUpdates, psMgr);\r\n-    }\r\n-\r\n-    /**\r\n-     * Break a circular dependency caused by delete operations.\r\n-     * If deleted row A has a ciricular fk to deleted row B, then use an update \r\n-     * statement to null A's fk to B before deleting B, then delete A.\r\n-     * @param edge Edge in the dependency graph corresponding to a foreign key\r\n-     * constraint. This dependency is broken by nullifying the foreign key.\r\n-     * @param deleteUpdates Collection of update statements that are executed\r\n-     * before the delete operations are flushed \r\n-     */\r\n-    private void addDeleteUpdate(Edge edge, Collection deleteUpdates)\r\n-        throws SQLException {\r\n-        PrimaryRow row;\r\n-        RowImpl update;\r\n-        ForeignKey fk;\r\n-\r\n-        // copy where conditions into new update that nulls the fk\r\n-        row = (PrimaryRow) edge.getTo();\r\n-        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\r\n-        row.copyInto(update, true);\r\n-        if (edge.getUserObject() instanceof ForeignKey) {\r\n-            fk = (ForeignKey) edge.getUserObject();\r\n-            update.setForeignKey(fk, row.getForeignKeyIO(fk), null);\r\n-        } else\r\n-            update.setNull((Column) edge.getUserObject());\r\n-\r\n-        deleteUpdates.add(update);\r\n-    }\r\n-\r\n-    /**\r\n-     * Break a circular dependency caused by insert operations.\r\n-     * If inserted row A has a circular fk to updated/inserted row B,\r\n-     * then null the fk in the B row object, then flush,\r\n-     * and after flushing, use an update to set the fk back to A.\r\n-     * @param row Row to be flushed\r\n-     * @param edge Edge in the dependency graph corresponding to a foreign key\r\n-     * constraint. This dependency is broken by nullifying the foreign key.\r\n-     * @param insertUpdates Collection of update statements that are executed\r\n-     * after the insert/update operations are flushed \r\n-     */\r\n-    private void addInsertUpdate(PrimaryRow row, Edge edge,\r\n-        Collection insertUpdates) throws SQLException {\r\n-        RowImpl update;\r\n-        ForeignKey fk;\r\n-        Column col;\r\n-\r\n-        // copy where conditions into new update that sets the fk\r\n-        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\r\n-        if (row.getAction() == Row.ACTION_INSERT) {\r\n-            if (row.getPrimaryKey() == null)\r\n-                throw new InternalException(_loc.get(\"ref-cycle\"));\r\n-            update.wherePrimaryKey(row.getPrimaryKey());\r\n-        } else {\r\n-            // Row.ACTION_UPDATE\r\n-            row.copyInto(update, true);\r\n-        }\r\n-        if (edge.getUserObject() instanceof ForeignKey) {\r\n-            fk = (ForeignKey) edge.getUserObject();\r\n-            update.setForeignKey(fk, row.getForeignKeyIO(fk),\r\n-                row.getForeignKeySet(fk));\r\n-            row.clearForeignKey(fk);\r\n-        } else {\r\n-            col = (Column) edge.getUserObject();\r\n-            update.setRelationId(col, row.getRelationIdSet(col),\r\n-                row.getRelationIdCallback(col));\r\n-            row.clearRelationId(col);\r\n-        }\r\n-\r\n-        insertUpdates.add(update);\r\n-    }\r\n-\r\n-    /**\r\n-     * Finds a nullable foreign key by walking the dependency cycle. \r\n-     * Circular dependencies can be broken at this point.\r\n-     * @param cycle Cycle in the dependency graph.\r\n-     * @return Edge corresponding to a nullable foreign key.\r\n-     */\r\n-    private Edge findBreakableLink(List cycle) {\r\n-        Edge breakableLink = null;\r\n-        for (Iterator iter = cycle.iterator(); iter.hasNext(); ) {\r\n-            Edge edge = (Edge) iter.next();\r\n-            Object userObject = edge.getUserObject();\r\n-            if (userObject instanceof ForeignKey) {\r\n-                 if (!((ForeignKey) userObject).hasNotNullColumns()) {\r\n-                     breakableLink = edge;\r\n-                     break;\r\n-                 }\r\n-            } else if (userObject instanceof Column) {\r\n-                if (!((Column) userObject).isNotNull()) {\r\n-                    breakableLink = edge;\r\n-                    break;\r\n-                }\r\n-            }\r\n-        }\r\n-        return breakableLink;\r\n-    }\r\n-\r\n-    /**\r\n-     * Re-calculates the DepthFirstSearch analysis of the graph \r\n-     * after some of the edges have been removed. Ensures\r\n-     * that the dependency graph is cycle free.\r\n-     * @param graph The graph of statements to be walked\r\n-     * @param autoAssign Whether any of the rows in the graph have any\r\n-     * auto-assign constraints\r\n-     */\r\n-    private DepthFirstAnalysis recalculateDepthFirstAnalysis(Graph graph,\r\n-        boolean autoAssign) {\r\n-        DepthFirstAnalysis dfa;\r\n-        // clear previous traversal data\r\n-        graph.clearTraversal();\r\n-        dfa = newDepthFirstAnalysis(graph, autoAssign);\r\n-        // make sure that the graph is non-cyclic now\r\n-        assert (dfa.hasNoCycles()): _loc.get(\"graph-not-cycle-free\");\r\n-        return dfa;\r\n-    }\r\n-\r\n-    /**\r\n-     * Resolve circular dependencies by identifying and breaking\r\n-     * a nullable foreign key.\r\n-     * @param graph Dependency graph.\r\n-     * @param edges Collection of edges. Each edge indicates a possible \r\n-     * circular dependency\r\n-     * @param deleteUpdates Collection of update operations (nullifying \r\n-     * foreign keys) to be filled. These updates will be executed before \r\n-     * the rows in the dependency graph are flushed\r\n-     * @param insertUpdates CCollection of update operations (nullifying \r\n-     * foreign keys) to be filled. These updates will be executed after \r\n-     * the rows in the dependency graph are flushed\r\n-     * @return Depending on where circular dependencies are broken, the  \r\n-     * topological order of the graph nodes has to be re-calculated.\r\n-     */\r\n-    private boolean resolveCycles(Graph graph, Collection edges,\r\n-        Collection deleteUpdates, Collection insertUpdates)\r\n-        throws SQLException {\r\n-        boolean recalculate = false;\r\n-        for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n-            Edge edge = (Edge) itr.next();\r\n-            List cycle = edge.getCycle();\r\n-\r\n-            if (cycle != null) {\r\n-                // find a nullable foreign key\r\n-                Edge breakableLink = findBreakableLink(cycle);\r\n-                if (breakableLink == null) {\r\n-                    throw new UserException(_loc.get(\"no-nullable-fk\"));\r\n-                }\r\n-\r\n-                // topologic node order must be re-calculated,  if the\r\n-                // breakable link is different from the edge where\r\n-                // the circular dependency was originally detected\r\n-                if (edge != breakableLink) {\r\n-                    recalculate = true;\r\n-                }\r\n-\r\n-                if (!breakableLink.isRemovedFromGraph()) {\r\n-\r\n-                    // use a primary row update to prevent setting pk and fk values\r\n-                    // until after flush, to get latest auto-increment values\r\n-                    PrimaryRow row = (PrimaryRow) breakableLink.getFrom();\r\n-                    if (row.getAction() == Row.ACTION_DELETE) {\r\n-                        addDeleteUpdate(breakableLink, deleteUpdates);\r\n-                    } else {\r\n-                        addInsertUpdate(row, breakableLink, insertUpdates);\r\n-                    }\r\n-                    graph.removeEdge(breakableLink);\r\n-                }\r\n-            }\r\n-        }\r\n-        return recalculate;\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new {@link DepthFirstAnalysis} suitable for the given graph\r\n-     * and auto-assign settings.\r\n-     */\r\n-    protected DepthFirstAnalysis newDepthFirstAnalysis(Graph graph,\r\n-        boolean autoAssign) {\r\n-        return new DepthFirstAnalysis(graph);\r\n-    }\r\n-\r\n-    /**\r\n-     * Flush the given collection of secondary rows.\r\n-     */\r\n-    protected void flush(Collection rows, PreparedStatementManager psMgr) {\r\n-        if (rows.size() == 0)\r\n-            return;\r\n-\r\n-        RowImpl row;\r\n-        for (Iterator itr = rows.iterator(); itr.hasNext(); ) {\r\n-            row = (RowImpl) itr.next();\r\n-            if (row.isValid() && !row.isDependent())\r\n-                psMgr.flush(row);\r\n-        }\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.sql.PrimaryRow;\n+import org.apache.openjpa.jdbc.sql.Row;\n+import org.apache.openjpa.jdbc.sql.RowImpl;\n+import org.apache.openjpa.jdbc.sql.RowManager;\n+import org.apache.openjpa.jdbc.sql.RowManagerImpl;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.lib.graph.DepthFirstAnalysis;\n+import org.apache.openjpa.lib.graph.Edge;\n+import org.apache.openjpa.lib.graph.Graph;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * <p>Standard update manager, capable of foreign key constraint evaluation.</p>\n+ *\n+ * @since 1.0.0\n+ */\n+public class ConstraintUpdateManager\n+    extends AbstractUpdateManager {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (ConstraintUpdateManager.class);\n+\n+    public boolean orderDirty() {\n+        return false;\n+    }\n+\n+    protected PreparedStatementManager newPreparedStatementManager\n+        (JDBCStore store, Connection conn) {\n+        return new PreparedStatementManagerImpl(store, conn);\n+    }\n+\n+    protected RowManager newRowManager() {\n+        return new RowManagerImpl(false);\n+    }\n+\n+    protected Collection flush(RowManager rowMgr,\n+        PreparedStatementManager psMgr, Collection exceps) {\n+        RowManagerImpl rmimpl = (RowManagerImpl) rowMgr;\n+\n+        // first take care of all secondary table deletes and 'all row' deletes\n+        // (which are probably secondary table deletes), since no foreign\n+        // keys ever rely on secondary table pks\n+        flush(rmimpl.getAllRowDeletes(), psMgr);\n+        flush(rmimpl.getSecondaryDeletes(), psMgr);\n+\n+        // now do any 'all row' updates\n+        flush(rmimpl.getAllRowUpdates(), psMgr);\n+\n+        // analyze foreign keys\n+        Collection inserts = rmimpl.getInserts();\n+        Collection updates = rmimpl.getUpdates();\n+        Collection deletes = rmimpl.getDeletes();\n+        Graph[] graphs = new Graph[2];    // insert graph, delete graph\n+        analyzeForeignKeys(inserts, updates, deletes, rmimpl, graphs);\n+\n+        // flush insert graph, if any\n+        boolean autoAssign = rmimpl.hasAutoAssignConstraints();\n+        try {\n+            flushGraph(graphs[0], psMgr, autoAssign);\n+        } catch (SQLException se) {\n+            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\n+        } catch (OpenJPAException ke) {\n+            exceps = addException(exceps, ke);\n+        }\n+\n+        // flush the rest of the inserts and updates; inserts before updates\n+        // because some update fks might reference pks that have to be inserted\n+        flush(inserts, psMgr);\n+        flush(updates, psMgr);\n+\n+        // flush the delete graph, if any\n+        try {\n+            flushGraph(graphs[1], psMgr, autoAssign);\n+        } catch (SQLException se) {\n+            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\n+        } catch (OpenJPAException ke) {\n+            exceps = addException(exceps, ke);\n+        }\n+\n+        // put the remainder of the deletes after updates because some updates\n+        // may be nulling fks to rows that are going to be deleted\n+        flush(deletes, psMgr);\n+\n+        // take care of all secondary table inserts and updates last, since\n+        // they may rely on previous inserts or updates, but nothing relies\n+        // on them\n+        flush(rmimpl.getSecondaryUpdates(), psMgr);\n+\n+        // flush any left over prepared statements\n+        psMgr.flush();\n+        return exceps;\n+    }\n+\n+    /**\n+     * Analyze foreign key dependencies on the given rows\n+     * and create an insert and a delete graph to execute.  The insert\n+     * graph will be flushed before all other rows, and the delete graph will\n+     * be flushed after them.\n+     */\n+    private void analyzeForeignKeys(Collection inserts, Collection updates,\n+        Collection deletes, RowManagerImpl rowMgr, Graph[] graphs) {\n+        // if there are any deletes, we have to map the insert objects on their\n+        // oids so we'll be able to detect delete-then-insert-same-pk cases\n+        Map insertMap = null;\n+        OpenJPAStateManager sm;\n+        if (!deletes.isEmpty() && !inserts.isEmpty()) {\n+            insertMap = new HashMap((int) (inserts.size() * 1.33 + 1));\n+            for (Iterator itr = inserts.iterator(); itr.hasNext();) {\n+                sm = ((Row) itr.next()).getPrimaryKey();\n+                if (sm != null && sm.getObjectId() != null)\n+                    insertMap.put(sm.getObjectId(), sm);\n+            }\n+        }\n+\n+        // first construct the graph for deletes; this may expand to include\n+        // inserts and updates as well if there are any inserts that rely on\n+        // deletes (delete-then-insert-same-pk cases)\n+        PrimaryRow row;\n+        Row row2;\n+        ForeignKey[] fks;\n+        OpenJPAStateManager fkVal;\n+        boolean ignoreUpdates = true;\n+        for (Iterator itr = deletes.iterator(); itr.hasNext();) {\n+            row = (PrimaryRow) itr.next();\n+            if (!row.isValid())\n+                continue;\n+\n+            row2 = getInsertRow(insertMap, rowMgr, row);\n+            if (row2 != null) {\n+                ignoreUpdates = false;\n+                graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row, null);\n+            }\n+\n+            // now check this row's fks against other deletes\n+            fks = row.getTable().getForeignKeys();\n+            for (int j = 0; j < fks.length; j++) {\n+                // when deleting ref fks they'll just set a where value, so\n+                // check both for fk updates (relation fks) and wheres (ref fks)\n+                fkVal = row.getForeignKeySet(fks[j]);\n+                if (fkVal == null)\n+                    fkVal = row.getForeignKeyWhere(fks[j]);\n+                if (fkVal == null)\n+                    continue;\n+\n+                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\n+                    Row.ACTION_DELETE, fkVal, false);\n+                if (row2 != null && row2.isValid() && row2 != row)\n+                    graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row,\n+                        fks[j]);\n+            }\n+        }\n+\n+        if (ignoreUpdates)\n+            graphs[0] = analyzeAgainstInserts(inserts, rowMgr, graphs[0]);\n+        else {\n+            // put inserts *and updates* in the delete graph; they all rely\n+            // on each other\n+            graphs[1] = analyzeAgainstInserts(updates, rowMgr, graphs[1]);\n+            graphs[1] = analyzeAgainstInserts(inserts, rowMgr, graphs[1]);\n+        }\n+    }\n+\n+    /**\n+     * Check to see if there is an insert for for the same table and primary\n+     * key values as the given delete row.\n+     */\n+    private Row getInsertRow(Map insertMap, RowManagerImpl rowMgr, Row row) {\n+        if (insertMap == null)\n+            return null;\n+\n+        OpenJPAStateManager sm = row.getPrimaryKey();\n+        if (sm == null)\n+            return null;\n+\n+        // look for a new object whose insert id is the same as this delete one\n+        Object oid = sm.getObjectId();\n+        OpenJPAStateManager nsm = (OpenJPAStateManager) insertMap.get(oid);\n+        if (nsm == null)\n+            return null;\n+\n+        // found new object; get its row\n+        row = rowMgr.getRow(row.getTable(), Row.ACTION_INSERT, nsm, false);\n+        return (row == null || row.isValid()) ? row : null;\n+    }\n+\n+    /**\n+     * Analyze the given rows against the inserts, placing dependencies\n+     * in the given graph.\n+     */\n+    private Graph analyzeAgainstInserts(Collection rows, RowManagerImpl rowMgr,\n+        Graph graph) {\n+        PrimaryRow row;\n+        Row row2;\n+        ForeignKey[] fks;\n+        Column[] cols;\n+        for (Iterator itr = rows.iterator(); itr.hasNext();) {\n+            row = (PrimaryRow) itr.next();\n+            if (!row.isValid())\n+                continue;\n+\n+            // check this row's fks against inserts; a logical fk to an auto-inc\n+            // column is treated just as actual database fk because the result\n+            // is the same: the pk row has to be inserted before the fk row\n+            fks = row.getTable().getForeignKeys();\n+            for (int j = 0; j < fks.length; j++) {\n+                if (row.getForeignKeySet(fks[j]) == null)\n+                    continue;\n+\n+                // see if this row is dependent on another.  if it's only\n+                // depenent on itself, see if the fk is logical or deferred, in\n+                // which case it must be an auto-inc because otherwise we\n+                // wouldn't have recorded it\n+                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\n+                    Row.ACTION_INSERT, row.getForeignKeySet(fks[j]), false);\n+                if (row2 != null && row2.isValid() && (row2 != row\n+                    || fks[j].isDeferred() || fks[j].isLogical()))\n+                    graph = addEdge(graph, row, (PrimaryRow) row2, fks[j]);\n+            }\n+\n+            // see if there are any relation id columns dependent on\n+            // auto-inc objects\n+            cols = row.getTable().getRelationIdColumns();\n+            for (int j = 0; j < cols.length; j++) {\n+                OpenJPAStateManager sm = row.getRelationIdSet(cols[j]);\n+                if (sm == null)\n+                    continue;\n+\n+                row2 = rowMgr.getRow(getBaseTable(sm), Row.ACTION_INSERT,\n+                    sm, false);\n+                if (row2 != null && row2.isValid())\n+                    graph = addEdge(graph, row, (PrimaryRow) row2, cols[j]);\n+            }\n+        }\n+        return graph;\n+    }\n+\n+    /**\n+     * Return the base table for the given instance.\n+     */\n+    private static Table getBaseTable(OpenJPAStateManager sm) {\n+        ClassMapping cls = (ClassMapping) sm.getMetaData();\n+        while (cls.getJoinablePCSuperclassMapping() != null)\n+            cls = cls.getJoinablePCSuperclassMapping();\n+        return cls.getTable();\n+    }\n+\n+    /**\n+     * Add an edge between the given rows in the given foreign key graph.\n+     */\n+    private Graph addEdge(Graph graph, PrimaryRow row1, PrimaryRow row2,\n+        Object fk) {\n+        // delay creation of the graph\n+        if (graph == null)\n+            graph = new Graph();\n+\n+        row1.setDependent(true);\n+        row2.setDependent(true);\n+        graph.addNode(row1);\n+        graph.addNode(row2);\n+\n+        // add an edge from row1 to row2, and set the fk causing the\n+        // dependency as the user object so we can retrieve it when resolving\n+        // circular constraints\n+        Edge edge = new Edge(row1, row2, true);\n+        edge.setUserObject(fk);\n+        graph.addEdge(edge);\n+\n+        return graph;\n+    }\n+\n+    /**\n+     * Flush the given graph of rows in the proper order.\n+     * @param graph The graph of statements to be walked\n+     * @param psMgr The prepared statement manager to use to issue the\n+     * statements\n+     * @param autoAssign Whether any of the rows in the graph have any\n+     * auto-assign constraints\n+     */\n+    protected void flushGraph(Graph graph, PreparedStatementManager psMgr,\n+        boolean autoAssign)\n+        throws SQLException {\n+        if (graph == null)\n+            return;\n+\n+        DepthFirstAnalysis dfa = newDepthFirstAnalysis(graph, autoAssign);\n+        Collection insertUpdates = new LinkedList();\n+        Collection deleteUpdates = new LinkedList();\n+        boolean recalculate;\n+\n+        // Handle circular constraints:\n+        // - if deleted row A has a ciricular fk to deleted row B, \n+        //   then use an update statement to null A's fk to B before flushing, \n+        //   and then flush\n+        // - if inserted row A has a circular fk to updated/inserted row B,\n+        //   then null the fk in the B row object, then flush,\n+        //   and after flushing, use an update to set the fk back to A\n+        // Depending on where circular dependencies are broken, the  \n+        // topological order of the graph nodes has to be re-calculated.\n+        recalculate = resolveCycles(graph, dfa.getEdges(Edge.TYPE_BACK),\n+                deleteUpdates, insertUpdates);\n+        recalculate |= resolveCycles(graph, dfa.getEdges(Edge.TYPE_FORWARD),\n+                deleteUpdates, insertUpdates);\n+\n+        if (recalculate) {\n+            dfa = recalculateDepthFirstAnalysis(graph, autoAssign);\n+        }\n+\n+        // flush delete updates to null fks, then all rows in order, then\n+        // the insert updates to set circular fk values\n+        flush(deleteUpdates, psMgr);\n+        Collection nodes = dfa.getSortedNodes();\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();)\n+            psMgr.flush((RowImpl) itr.next());\n+        flush(insertUpdates, psMgr);\n+    }\n+\n+    /**\n+     * Break a circular dependency caused by delete operations.\n+     * If deleted row A has a ciricular fk to deleted row B, then use an update \n+     * statement to null A's fk to B before deleting B, then delete A.\n+     * @param edge Edge in the dependency graph corresponding to a foreign key\n+     * constraint. This dependency is broken by nullifying the foreign key.\n+     * @param deleteUpdates Collection of update statements that are executed\n+     * before the delete operations are flushed \n+     */\n+    private void addDeleteUpdate(Edge edge, Collection deleteUpdates)\n+        throws SQLException {\n+        PrimaryRow row;\n+        RowImpl update;\n+        ForeignKey fk;\n+\n+        // copy where conditions into new update that nulls the fk\n+        row = (PrimaryRow) edge.getTo();\n+        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\n+        row.copyInto(update, true);\n+        if (edge.getUserObject() instanceof ForeignKey) {\n+            fk = (ForeignKey) edge.getUserObject();\n+            update.setForeignKey(fk, row.getForeignKeyIO(fk), null);\n+        } else\n+            update.setNull((Column) edge.getUserObject());\n+\n+        deleteUpdates.add(update);\n+    }\n+\n+    /**\n+     * Break a circular dependency caused by insert operations.\n+     * If inserted row A has a circular fk to updated/inserted row B,\n+     * then null the fk in the B row object, then flush,\n+     * and after flushing, use an update to set the fk back to A.\n+     * @param row Row to be flushed\n+     * @param edge Edge in the dependency graph corresponding to a foreign key\n+     * constraint. This dependency is broken by nullifying the foreign key.\n+     * @param insertUpdates Collection of update statements that are executed\n+     * after the insert/update operations are flushed \n+     */\n+    private void addInsertUpdate(PrimaryRow row, Edge edge,\n+        Collection insertUpdates) throws SQLException {\n+        RowImpl update;\n+        ForeignKey fk;\n+        Column col;\n+\n+        // copy where conditions into new update that sets the fk\n+        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\n+        if (row.getAction() == Row.ACTION_INSERT) {\n+            if (row.getPrimaryKey() == null)\n+                throw new InternalException(_loc.get(\"ref-cycle\"));\n+            update.wherePrimaryKey(row.getPrimaryKey());\n+        } else {\n+            // Row.ACTION_UPDATE\n+            row.copyInto(update, true);\n+        }\n+        if (edge.getUserObject() instanceof ForeignKey) {\n+            fk = (ForeignKey) edge.getUserObject();\n+            update.setForeignKey(fk, row.getForeignKeyIO(fk),\n+                row.getForeignKeySet(fk));\n+            row.clearForeignKey(fk);\n+        } else {\n+            col = (Column) edge.getUserObject();\n+            update.setRelationId(col, row.getRelationIdSet(col),\n+                row.getRelationIdCallback(col));\n+            row.clearRelationId(col);\n+        }\n+\n+        insertUpdates.add(update);\n+    }\n+\n+    /**\n+     * Finds a nullable foreign key by walking the dependency cycle. \n+     * Circular dependencies can be broken at this point.\n+     * @param cycle Cycle in the dependency graph.\n+     * @return Edge corresponding to a nullable foreign key.\n+     */\n+    private Edge findBreakableLink(List cycle) {\n+        Edge breakableLink = null;\n+        for (Iterator iter = cycle.iterator(); iter.hasNext(); ) {\n+            Edge edge = (Edge) iter.next();\n+            Object userObject = edge.getUserObject();\n+            if (userObject instanceof ForeignKey) {\n+                 if (!((ForeignKey) userObject).hasNotNullColumns()) {\n+                     breakableLink = edge;\n+                     break;\n+                 }\n+            } else if (userObject instanceof Column) {\n+                if (!((Column) userObject).isNotNull()) {\n+                    breakableLink = edge;\n+                    break;\n+                }\n+            }\n+        }\n+        return breakableLink;\n+    }\n+\n+    /**\n+     * Re-calculates the DepthFirstSearch analysis of the graph \n+     * after some of the edges have been removed. Ensures\n+     * that the dependency graph is cycle free.\n+     * @param graph The graph of statements to be walked\n+     * @param autoAssign Whether any of the rows in the graph have any\n+     * auto-assign constraints\n+     */\n+    private DepthFirstAnalysis recalculateDepthFirstAnalysis(Graph graph,\n+        boolean autoAssign) {\n+        DepthFirstAnalysis dfa;\n+        // clear previous traversal data\n+        graph.clearTraversal();\n+        dfa = newDepthFirstAnalysis(graph, autoAssign);\n+        // make sure that the graph is non-cyclic now\n+        assert (dfa.hasNoCycles()): _loc.get(\"graph-not-cycle-free\");\n+        return dfa;\n+    }\n+\n+    /**\n+     * Resolve circular dependencies by identifying and breaking\n+     * a nullable foreign key.\n+     * @param graph Dependency graph.\n+     * @param edges Collection of edges. Each edge indicates a possible \n+     * circular dependency\n+     * @param deleteUpdates Collection of update operations (nullifying \n+     * foreign keys) to be filled. These updates will be executed before \n+     * the rows in the dependency graph are flushed\n+     * @param insertUpdates CCollection of update operations (nullifying \n+     * foreign keys) to be filled. These updates will be executed after \n+     * the rows in the dependency graph are flushed\n+     * @return Depending on where circular dependencies are broken, the  \n+     * topological order of the graph nodes has to be re-calculated.\n+     */\n+    private boolean resolveCycles(Graph graph, Collection edges,\n+        Collection deleteUpdates, Collection insertUpdates)\n+        throws SQLException {\n+        boolean recalculate = false;\n+        for (Iterator itr = edges.iterator(); itr.hasNext();) {\n+            Edge edge = (Edge) itr.next();\n+            List cycle = edge.getCycle();\n+\n+            if (cycle != null) {\n+                // find a nullable foreign key\n+                Edge breakableLink = findBreakableLink(cycle);\n+                if (breakableLink == null) {\n+                    throw new UserException(_loc.get(\"no-nullable-fk\"));\n+                }\n+\n+                // topologic node order must be re-calculated,  if the\n+                // breakable link is different from the edge where\n+                // the circular dependency was originally detected\n+                if (edge != breakableLink) {\n+                    recalculate = true;\n+                }\n+\n+                if (!breakableLink.isRemovedFromGraph()) {\n+\n+                    // use a primary row update to prevent setting pk and fk values\n+                    // until after flush, to get latest auto-increment values\n+                    PrimaryRow row = (PrimaryRow) breakableLink.getFrom();\n+                    if (row.getAction() == Row.ACTION_DELETE) {\n+                        addDeleteUpdate(breakableLink, deleteUpdates);\n+                    } else {\n+                        addInsertUpdate(row, breakableLink, insertUpdates);\n+                    }\n+                    graph.removeEdge(breakableLink);\n+                }\n+            }\n+        }\n+        return recalculate;\n+    }\n+\n+    /**\n+     * Create a new {@link DepthFirstAnalysis} suitable for the given graph\n+     * and auto-assign settings.\n+     */\n+    protected DepthFirstAnalysis newDepthFirstAnalysis(Graph graph,\n+        boolean autoAssign) {\n+        return new DepthFirstAnalysis(graph);\n+    }\n+\n+    /**\n+     * Flush the given collection of secondary rows.\n+     */\n+    protected void flush(Collection rows, PreparedStatementManager psMgr) {\n+        if (rows.size() == 0)\n+            return;\n+\n+        RowImpl row;\n+        for (Iterator itr = rows.iterator(); itr.hasNext(); ) {\n+            row = (RowImpl) itr.next();\n+            if (row.isValid() && !row.isDependent())\n+                psMgr.flush(row);\n+        }\n+    }\n }\n\\ No newline at end of file"},{"sha":"8987a115694bfc84d24e525c903ada9249db05d5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -272,7 +272,9 @@ private long getSequence(Connection conn)\n         ResultSet rs = null;\n         try {\n             stmnt = conn.prepareStatement(_select);\n-            rs = stmnt.executeQuery();\n+            synchronized(this) {\n+                rs = stmnt.executeQuery();\n+            }\n             if (rs.next())\n                 return rs.getLong(1);\n "},{"sha":"484873ef1d9dfa05923750a4d0c750e056b4064c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","status":"modified","additions":14,"deletions":1,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -139,7 +139,20 @@ private void lockRow(OpenJPAStateManager sm, int timeout) {\n                     if (log.isWarnEnabled())\n                         log.warn(_loc.get(\"millis-query-timeout\"));\n                 }\n-                stmnt.setQueryTimeout(timeout / 1000);\n+                try { \n+                    stmnt.setQueryTimeout(timeout / 1000);\n+                }\n+                catch(SQLException e) { \n+                    if(! dict.ignoreSQLExceptionOnSetQueryTimeout) { \n+                        throw e;\n+                    }\n+                    else {\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(_loc.get(\"error-setting-query-timeout\",\n+                                new Integer(timeout), e.getMessage()), e);\n+                        }\n+                    }\n+                }\n             }\n             rs = stmnt.executeQuery();\n             if (!rs.next())"},{"sha":"e28c92b4477a5715b3454311166b1dfc7f534c4b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -327,7 +327,7 @@ protected Column addPrimaryKeyColumn(Table table) {\n     }\n \n     /**\n-     * Return the primary key value for the given class.\n+     * Return the primary key value for the sequence table for the given class.\n      */\n     protected Object getPrimaryKey(ClassMapping mapping) {\n         return Numbers.valueOf(0);"},{"sha":"b3cb27838141dabc042ded9fa363cd41ccd432ab","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Distinct.java","status":"modified","additions":15,"deletions":1,"changes":16,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Distinct.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Distinct.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Distinct.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -14,10 +14,11 @@\n  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  * KIND, either express or implied.  See the License for the\n  * specific language governing permissions and limitations\n- * under the License.    \n+ * under the License.\n  */\n package org.apache.openjpa.jdbc.kernel.exps;\n \n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.Select;\n \n /**\n@@ -40,4 +41,17 @@ public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n     protected String getOperator() {\n         return \"DISTINCT\";\n     }\n+\n+    public void appendTo(Select sel, ExpContext ctx, ExpState state,\n+        SQLBuffer sql, int index) {\n+        if (sel.getConfiguration().getDBDictionaryInstance().platform.indexOf(\n+            \"Informix\") > -1) {\n+            sql.append(getOperator());\n+            sql.append(\" \");\n+            getValue().appendTo(sel, ctx, state, sql, 0);\n+            sql.addCastForParam(getOperator(), getValue());\n+        }\n+        else\n+            super.appendTo(sel, ctx, state, sql, index);\n+    }\n }"},{"sha":"cc11ae6e1c246e197e4ee3dd1d406b0166c06d3e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -215,9 +215,12 @@ public Expression matches(Value v1, Value v2,\n         String single, String multi, String esc) {\n         if (!(v2 instanceof Const))\n             throw new UserException(_loc.get(\"const-only\", \"matches\"));\n-        return new MatchesExpression((Val) v1, (Const) v2, single, multi,\n-            esc != null ? esc : _type.getMappingRepository().\n-                getDBDictionary().searchStringEscape);\n+        if (esc == null && _type.getMappingRepository().\n+                getDBDictionary().requiresSearchStringEscapeForLike == true) { \n+            esc = _type.getMappingRepository().\n+                getDBDictionary().searchStringEscape;\n+        }        \n+        return new MatchesExpression((Val) v1, (Const) v2, single, multi, esc);\n     }\n \n     public Subquery newSubquery(ClassMetaData candidate, boolean subs,"},{"sha":"0f2bbb3e5ed1c1acf6638690bf314ba4fd695eb6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -43,7 +43,11 @@ public void appendTo(Select sel, ExpContext ctx, ExpState state,\n         DBDictionary dict = ctx.store.getDBDictionary();\n         String func = dict.toLowerCaseFunction;\n         dict.assertSupport(func != null, \"ToLowerCaseFunction\");\n-        func = dict.getCastFunction(getValue(), func);\n+        if (getValue() instanceof PCPath) {\n+            func = dict.getCastFunction(getValue(), func, ((PCPath) getValue()).getFieldMapping(state).getColumns()[0]);\n+        } else {\n+            func = dict.getCastFunction(getValue(), func);\n+        }\n \n         int idx = func.indexOf(\"{0}\");\n         buf.append(func.substring(0, idx));"},{"sha":"3719627ff28305854eefcf5b12d405eb2d628935","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -43,7 +43,11 @@ public void appendTo(Select sel, ExpContext ctx, ExpState state,\n         DBDictionary dict = ctx.store.getDBDictionary();\n         String func = dict.toUpperCaseFunction;\n         dict.assertSupport(func != null, \"ToUpperCaseFunction\");\n-        func = dict.getCastFunction(getValue(), func);\n+        if (getValue() instanceof PCPath) {\n+            func = dict.getCastFunction(getValue(), func, ((PCPath) getValue()).getFieldMapping(state).getColumns()[0]);\n+        } else {\n+            func = dict.getCastFunction(getValue(), func);\n+        }\n \n         int idx = func.indexOf(\"{0}\");\n         buf.append(func.substring(0, idx));"},{"sha":"3274461e86351ab1a3a4ad863bfacfcd6768e595","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","status":"modified","additions":8,"deletions":2,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -858,7 +858,13 @@ else if (relMapping.getIdentityType() == ClassMapping.ID_DATASTORE)\n \n         if (oid == null)\n             sm.storeObject(field.getIndex(), null);\n-        else\n-            sm.setIntermediate(field.getIndex(), oid);\n+        else {\n+            if (JavaTypes.maybePC(field.getValue()) &&\n+                !field.getValue().getDeclaredTypeMetaData().isEmbeddedOnly()) {\n+                Object obj = store.find(oid, field, fetch);\n+                sm.storeObject(field.getIndex(), obj);\n+            } else    \n+                sm.setIntermediate(field.getIndex(), oid);\n+        }\n     }\n }"},{"sha":"f7c0b40483f84333c9f32a4efad32ae7fc939a58","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -757,6 +757,9 @@ public void generateForeignKeys(String schemaName, String tableName,\n \n             // find pk table\n             pkSchemaName = fks[i].getPrimaryKeySchemaName();\n+            if(_dict.getTrimSchemaName()) {\n+                pkSchemaName= StringUtils.trimToNull(pkSchemaName);\n+            }\n             pkTableName = fks[i].getPrimaryKeyTableName();\n             if (_log.isTraceEnabled())\n                 _log.trace(_loc.get(\"gen-fk\", new Object[]{ name, table,"},{"sha":"fd974109ae9373aefbf6992cce8257afd634b908","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -986,6 +986,10 @@ public boolean dropSequence(Sequence seq)\n      */\n     public boolean createIndex(Index idx, Table table)\n         throws SQLException {\n+\n+        if (!_dict.needsToCreateIndex(idx,table))\n+            return false;\n+\n         int max = _dict.maxIndexesPerTable;\n \n         int len = table.getIndexes().length;"},{"sha":"042ec08ae977e481effe6921862ad01a0d9bbb00","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -36,8 +36,6 @@ public AbstractDB2Dictionary() {\n \n         // DB2-based databases have restrictions on having uncast parameters\n         // in string functions\n-        toUpperCaseFunction = \"UPPER(CAST({0} AS VARCHAR(1000)))\";\n-        toLowerCaseFunction = \"LOWER(CAST({0} AS VARCHAR(1000)))\";\n         stringLengthFunction = \"LENGTH({0})\";\n         concatenateFunction = \"(CAST({0} AS VARCHAR(1000)))||\"\n             + \"(CAST({1} AS VARCHAR(1000)))\";\n@@ -56,6 +54,7 @@ public AbstractDB2Dictionary() {\n         supportsLockingWithOuterJoin = false;\n         supportsLockingWithInnerJoin = false;\n         supportsLockingWithSelectRange = true;\n+        supportsCaseConversionForLob = true;\n \n         requiresAutoCommitForMetaData = true;\n         requiresAliasForSubselect = true;"},{"sha":"3a52c100287d6f351f077f32f283b8fd0167bc32","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","status":"modified","additions":797,"deletions":780,"changes":1577,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,780 +1,797 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.sql;\r\n-\r\n-import java.lang.reflect.Method;\r\n-import java.sql.Connection;\r\n-import java.sql.DatabaseMetaData;\r\n-import java.sql.SQLException;\r\n-import java.sql.Types;\r\n-import java.util.Arrays;\r\n-import java.util.StringTokenizer;\r\n-\r\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\r\n-import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\r\n-import org.apache.openjpa.jdbc.kernel.exps.Lit;\r\n-import org.apache.openjpa.jdbc.kernel.exps.Param;\r\n-import org.apache.openjpa.jdbc.kernel.exps.Val;\r\n-import org.apache.openjpa.jdbc.schema.Column;\r\n-import org.apache.openjpa.jdbc.schema.Index;\r\n-import org.apache.openjpa.jdbc.schema.Schema;\r\n-import org.apache.openjpa.jdbc.schema.Sequence;\r\n-import org.apache.openjpa.jdbc.schema.Table;\r\n-import org.apache.openjpa.kernel.Filters;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.util.OpenJPAException;\r\n-import org.apache.openjpa.util.UnsupportedException;\r\n-\r\n-import serp.util.Strings;\r\n-\r\n-/**\r\n- * Dictionary for IBM DB2 database.\r\n- */\r\n-public class DB2Dictionary\r\n-    extends AbstractDB2Dictionary {\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (DB2Dictionary.class);\r\n-\r\n-    public String optimizeClause = \"optimize for\";\r\n-    public String rowClause = \"row\";\r\n-    protected int db2ServerType = 0;\r\n-    public static final int db2ISeriesV5R3OrEarlier = 1;\r\n-    public static final int db2UDBV81OrEarlier = 2;\r\n-    public static final int db2ZOSV8xOrLater = 3;\r\n-    public static final int db2UDBV82OrLater = 4;\r\n-    public static final int db2ISeriesV5R4OrLater = 5;\r\n-\tprivate static final String forUpdate = \"FOR UPDATE\";\r\n-    private static final String withRSClause = \"WITH RS\";\r\n-    private static final String withRRClause = \"WITH RR\";\r\n-    private static final String useKeepUpdateLockClause\r\n-        = \"USE AND KEEP UPDATE LOCKS\";\r\n-    private static final String useKeepExclusiveLockClause\r\n-        = \"USE AND KEEP EXCLUSIVE LOCKS\";\r\n-    private static final String forReadOnlyClause = \"FOR READ ONLY\";\r\n-    protected String databaseProductName = \"\";\r\n-    protected String databaseProductVersion = \"\";\r\n-    protected int maj = 0;\r\n-    protected int min = 0;\r\n-\r\n-    public DB2Dictionary() {\r\n-        platform = \"DB2\";\r\n-        validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\r\n-            + \"SYSIBM.SYSTABLES\";\r\n-        supportsSelectEndIndex = true;\r\n-\r\n-        nextSequenceQuery = \"VALUES NEXTVAL FOR {0}\";\r\n-\r\n-        sequenceSQL = \"SELECT SEQSCHEMA AS SEQUENCE_SCHEMA, \"\r\n-            + \"SEQNAME AS SEQUENCE_NAME FROM SYSCAT.SEQUENCES\";\r\n-        sequenceSchemaSQL = \"SEQSCHEMA = ?\";\r\n-        sequenceNameSQL = \"SEQNAME = ?\";\r\n-        characterColumnSize = 254;\r\n-\r\n-        binaryTypeName = \"BLOB(1M)\";\r\n-        longVarbinaryTypeName = \"BLOB(1M)\";\r\n-        varbinaryTypeName = \"BLOB(1M)\";\r\n-        clobTypeName = \"CLOB(1M)\";\r\n-        longVarcharTypeName = \"LONG VARCHAR\";\r\n-        datePrecision = MICRO;\r\n-        storeCharsAsNumbers = false;\r\n-\r\n-        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\r\n-            \"LONG VARCHAR FOR BIT DATA\", \"LONG VARCHAR\", \"LONG VARGRAPHIC\",\r\n-        }));\r\n-        systemSchemas = new String(\r\n-                \"SYSCAT,SYSIBM,SYSSTAT,SYSIBMADM,SYSTOOLS\");\r\n-        maxConstraintNameLength = 18;\r\n-        maxIndexNameLength = 18;\r\n-        maxColumnNameLength = 30;\r\n-        supportsDeferredConstraints = false;\r\n-        supportsDefaultDeleteAction = false;\r\n-        supportsAlterTableWithDropColumn = false;\r\n-\r\n-        supportsNullTableForGetColumns = false;\r\n-        requiresCastForMathFunctions = true;\r\n-        requiresCastForComparisons = true;\r\n-\r\n-        reservedWordSet.addAll(Arrays.asList(new String[]{\r\n-            \"AFTER\", \"ALIAS\", \"ALLOW\", \"APPLICATION\", \"ASSOCIATE\", \"ASUTIME\",\r\n-            \"AUDIT\", \"AUX\", \"AUXILIARY\", \"BEFORE\", \"BINARY\", \"BUFFERPOOL\",\r\n-            \"CACHE\", \"CALL\", \"CALLED\", \"CAPTURE\", \"CARDINALITY\", \"CCSID\",\r\n-            \"CLUSTER\", \"COLLECTION\", \"COLLID\", \"COMMENT\", \"CONCAT\",\r\n-            \"CONDITION\", \"CONTAINS\", \"COUNT_BIG\", \"CURRENT_LC_CTYPE\",\r\n-            \"CURRENT_PATH\", \"CURRENT_SERVER\", \"CURRENT_TIMEZONE\", \"CYCLE\",\r\n-            \"DATA\", \"DATABASE\", \"DAYS\", \"DB2GENERAL\", \"DB2GENRL\", \"DB2SQL\",\r\n-            \"DBINFO\", \"DEFAULTS\", \"DEFINITION\", \"DETERMINISTIC\", \"DISALLOW\",\r\n-            \"DO\", \"DSNHATTR\", \"DSSIZE\", \"DYNAMIC\", \"EACH\", \"EDITPROC\", \"ELSEIF\",\r\n-            \"ENCODING\", \"END-EXEC1\", \"ERASE\", \"EXCLUDING\", \"EXIT\", \"FENCED\",\r\n-            \"FIELDPROC\", \"FILE\", \"FINAL\", \"FREE\", \"FUNCTION\", \"GENERAL\",\r\n-            \"GENERATED\", \"GRAPHIC\", \"HANDLER\", \"HOLD\", \"HOURS\", \"IF\",\r\n-            \"INCLUDING\", \"INCREMENT\", \"INDEX\", \"INHERIT\", \"INOUT\", \"INTEGRITY\",\r\n-            \"ISOBID\", \"ITERATE\", \"JAR\", \"JAVA\", \"LABEL\", \"LC_CTYPE\", \"LEAVE\",\r\n-            \"LINKTYPE\", \"LOCALE\", \"LOCATOR\", \"LOCATORS\", \"LOCK\", \"LOCKMAX\",\r\n-            \"LOCKSIZE\", \"LONG\", \"LOOP\", \"MAXVALUE\", \"MICROSECOND\",\r\n-            \"MICROSECONDS\", \"MINUTES\", \"MINVALUE\", \"MODE\", \"MODIFIES\", \"MONTHS\",\r\n-            \"NEW\", \"NEW_TABLE\", \"NOCACHE\", \"NOCYCLE\", \"NODENAME\", \"NODENUMBER\",\r\n-            \"NOMAXVALUE\", \"NOMINVALUE\", \"NOORDER\", \"NULLS\", \"NUMPARTS\", \"OBID\",\r\n-            \"OLD\", \"OLD_TABLE\", \"OPTIMIZATION\", \"OPTIMIZE\", \"OUT\", \"OVERRIDING\",\r\n-            \"PACKAGE\", \"PARAMETER\", \"PART\", \"PARTITION\", \"PATH\", \"PIECESIZE\",\r\n-            \"PLAN\", \"PRIQTY\", \"PROGRAM\", \"PSID\", \"QUERYNO\", \"READS\", \"RECOVERY\",\r\n-            \"REFERENCING\", \"RELEASE\", \"RENAME\", \"REPEAT\", \"RESET\", \"RESIGNAL\",\r\n-            \"RESTART\", \"RESULT\", \"RESULT_SET_LOCATOR\", \"RETURN\", \"RETURNS\",\r\n-            \"ROUTINE\", \"ROW\", \"RRN\", \"RUN\", \"SAVEPOINT\", \"SCRATCHPAD\",\r\n-            \"SECONDS\", \"SECQTY\", \"SECURITY\", \"SENSITIVE\", \"SIGNAL\", \"SIMPLE\",\r\n-            \"SOURCE\", \"SPECIFIC\", \"SQLID\", \"STANDARD\", \"START\", \"STATIC\",\r\n-            \"STAY\", \"STOGROUP\", \"STORES\", \"STYLE\", \"SUBPAGES\", \"SYNONYM\",\r\n-            \"SYSFUN\", \"SYSIBM\", \"SYSPROC\", \"SYSTEM\", \"TABLESPACE\", \"TRIGGER\",\r\n-            \"TYPE\", \"UNDO\", \"UNTIL\", \"VALIDPROC\", \"VARIABLE\", \"VARIANT\", \"VCAT\",\r\n-            \"VOLUMES\", \"WHILE\", \"WLM\", \"YEARS\",\r\n-        }));\r\n-        \r\n-        selectWordSet.add(\"WITH\");\r\n-    }\r\n-\r\n-    public boolean supportsRandomAccessResultSet(Select sel,\r\n-        boolean forUpdate) {\r\n-        return !forUpdate\r\n-            && super.supportsRandomAccessResultSet(sel, forUpdate);\r\n-    }\r\n-\r\n-    protected void appendSelectRange(SQLBuffer buf, long start, long end,\r\n-        boolean subselect) {\r\n-        // appends the literal range string, since DB2 is unable to handle\r\n-        // a bound parameter for it\r\n-        // do not generate FETCH FIRST clause for subselect\r\n-        if (!subselect)\r\n-            buf.append(\" FETCH FIRST \").append(Long.toString(end)).\r\n-                append(\" ROWS ONLY\");\r\n-    }\r\n-\r\n-    public String[] getCreateSequenceSQL(Sequence seq) {\r\n-        String[] sql = super.getCreateSequenceSQL(seq);\r\n-        if (seq.getAllocate() > 1)\r\n-            sql[0] += \" CACHE \" + seq.getAllocate();\r\n-        return sql;\r\n-    }\r\n-\r\n-    protected String getSequencesSQL(String schemaName, String sequenceName) {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        buf.append(sequenceSQL);\r\n-        if (schemaName != null || sequenceName != null)\r\n-            buf.append(\" WHERE \");\r\n-        if (schemaName != null) {\r\n-            buf.append(sequenceSchemaSQL);\r\n-            if (sequenceName != null)\r\n-                buf.append(\" AND \");\r\n-        }\r\n-        if (sequenceName != null)\r\n-            buf.append(sequenceNameSQL);\r\n-        return buf.toString();\r\n-    }\r\n-\r\n-    public Connection decorate(Connection conn)\r\n-        throws SQLException {\r\n-        // some versions of the DB2 driver seem to default to\r\n-        // READ_UNCOMMITTED, which will prevent locking from working\r\n-        // (multiple SELECT ... FOR UPDATE statements are allowed on\r\n-        // the same instance); if we have not overridden the\r\n-        // transaction isolation in the configuration, default to\r\n-        // TRANSACTION_READ_COMMITTED\r\n-        conn = super.decorate(conn);\r\n-\r\n-        if (conf.getTransactionIsolationConstant() == -1\r\n-            && conn.getTransactionIsolation() < conn.TRANSACTION_READ_COMMITTED)\r\n-            conn.setTransactionIsolation(conn.TRANSACTION_READ_COMMITTED);\r\n-\r\n-        return conn;\r\n-    }\r\n-\r\n-    private boolean isJDBC3(DatabaseMetaData meta) {\r\n-        try {\r\n-            // JDBC3-only method, so it might throw a AbstractMethodError\r\n-            return meta.getJDBCMajorVersion() >= 3;\r\n-        } catch (Throwable t) {\r\n-            return false;\r\n-        }\r\n-    }\r\n-\r\n-    public void connectedConfiguration(Connection conn) throws SQLException {\r\n-    \tsuper.connectedConfiguration(conn);\r\n-\r\n-    \tDatabaseMetaData metaData = conn.getMetaData();\r\n-        databaseProductName = nullSafe(metaData.getDatabaseProductName());\r\n-        databaseProductVersion = nullSafe(metaData.getDatabaseProductVersion());\r\n-        \r\n-        // Determine the type of DB2 database\r\n-        // First check for AS/400\r\n-        getProductVersionMajorMinorForISeries();\r\n-\r\n-        if (maj > 0) {\r\n-            if (isDB2ISeriesV5R3OrEarlier())\r\n-                db2ServerType = db2ISeriesV5R3OrEarlier;\r\n-            else if (isDB2ISeriesV5R4OrLater())\r\n-                db2ServerType = db2ISeriesV5R4OrLater;\r\n-        }\r\n-        \r\n-    \tif (db2ServerType == 0) {\r\n-    \t    if (isJDBC3(metaData)) {\r\n-    \t        maj = metaData.getDatabaseMajorVersion();\r\n-    \t        min = metaData.getDatabaseMinorVersion();\r\n-    \t    }\r\n-    \t    else\r\n-    \t        getProductVersionMajorMinor();\r\n-\r\n-    \t    // Determine the type of DB2 database for ZOS & UDB\r\n-    \t    if (isDB2UDBV81OrEarlier())\r\n-    \t        db2ServerType = db2UDBV81OrEarlier;\r\n-    \t    else if (isDB2ZOSV8xOrLater())\r\n-    \t        db2ServerType = db2ZOSV8xOrLater;\r\n-    \t    else if (isDB2UDBV82OrLater())\r\n-    \t        db2ServerType = db2UDBV82OrLater;\r\n-        }\r\n-\r\n-        // verify that databae product is supported\r\n-        if (db2ServerType == 0 || maj == 0)\r\n-            throw new UnsupportedException(_loc.get(\"db-not-supported\",\r\n-                new Object[] {databaseProductName, databaseProductVersion }));                    \r\n-\r\n-    \tif (maj >= 9 || (maj == 8 && min >= 2)) {\r\n-    \t    supportsLockingWithMultipleTables = true;\r\n-    \t    supportsLockingWithInnerJoin = true;\r\n-    \t    supportsLockingWithOuterJoin = true;\r\n-    \t    forUpdateClause = \"WITH RR USE AND KEEP UPDATE LOCKS\";\r\n-    \t    if (maj >=9)\r\n-    \t        supportsXMLColumn = true;\r\n-    \t}\r\n-\r\n-        // platform specific settings\r\n-        switch (db2ServerType) {\r\n-        case  db2ZOSV8xOrLater:\r\n-            // DB2 Z/OS \r\n-            characterColumnSize = 255;\r\n-            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            sequenceSQL = \"SELECT SCHEMA AS SEQUENCE_SCHEMA, \"\r\n-                + \"NAME AS SEQUENCE_NAME FROM SYSIBM.SYSSEQUENCES\";\r\n-            sequenceSchemaSQL = \"SCHEMA = ?\";\r\n-            sequenceNameSQL = \"NAME = ?\";\r\n-            if (maj == 8)\r\n-                // DB2 Z/OS Version 8: no bigint support, hence map Java\r\n-                // long to decimal\r\n-                bigintTypeName = \"DECIMAL(31,0)\";\r\n-            break;\r\n-        case db2ISeriesV5R3OrEarlier:\r\n-        case db2ISeriesV5R4OrLater:\r\n-            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\r\n-                + \"QSYS2.SYSTABLES\";\r\n-            sequenceSQL = \"SELECT SEQUENCE_SCHEMA, \"\r\n-                + \"SEQUENCE_NAME FROM QSYS2.SYSSEQUENCES\";\r\n-            sequenceSchemaSQL = \"SEQUENCE_SCHEMA = ?\";\r\n-            sequenceNameSQL = \"SEQUENCE_NAME = ?\";\r\n-            break;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Get the update clause for the query based on the\r\n-     * updateClause and isolationLevel hints\r\n-     */\r\n-    protected String getForUpdateClause(JDBCFetchConfiguration fetch,\r\n-        boolean isForUpdate, Select sel) {\r\n-        int isolationLevel;\r\n-        // For db2UDBV81OrEarlier and db2ISeriesV5R3OrEarlier:\r\n-        // \"optimize for\" clause appears before \"for update\" clause.\r\n-        StringBuffer forUpdateString = new StringBuffer(\r\n-            getOptimizeClause(sel));\r\n-        try {\r\n-            // Determine the isolationLevel; the fetch\r\n-            // configuration data overrides the persistence.xml value\r\n-            if (fetch != null && fetch.getIsolation() != -1)\r\n-                isolationLevel = fetch.getIsolation();\r\n-            else\r\n-                isolationLevel = conf.getTransactionIsolationConstant();\r\n-\r\n-            if (isForUpdate) {\r\n-                switch(db2ServerType) {\r\n-                case db2ISeriesV5R3OrEarlier:\r\n-                case db2UDBV81OrEarlier:\r\n-                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE)\r\n-                        forUpdateString.append(\" \").append(forUpdateClause);\r\n-                    else \r\n-                        forUpdateString.append(\" \").append(forUpdate)\r\n-                            .append(\" \").append(withRSClause);\r\n-                    break;\r\n-                case db2ZOSV8xOrLater:\r\n-                case db2UDBV82OrLater:\r\n-                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\r\n-                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                            .append(\" \").append(withRRClause)\r\n-                            .append(\" \").append(useKeepUpdateLockClause);   \r\n-                    } else {\r\n-                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                            .append(\" \").append(withRSClause)\r\n-                            .append(\" \").append(useKeepUpdateLockClause);                            \r\n-                    }\r\n-                    break;\r\n-                case db2ISeriesV5R4OrLater:\r\n-                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\r\n-                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                            .append(\" \").append(withRRClause)\r\n-                            .append(\" \").append(useKeepExclusiveLockClause);       \r\n-                    } else {\r\n-                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                            .append(\" \").append(withRSClause)\r\n-                            .append(\" \").append(useKeepExclusiveLockClause);\r\n-                    }\r\n-                    break;\r\n-                }\r\n-            }\r\n-        }\r\n-        catch (Exception e) {\r\n-            if (log.isTraceEnabled())\r\n-                log.error(e.toString(),e);\r\n-        }\r\n-        return forUpdateString.toString();\r\n-    }\r\n-\r\n-    public boolean isDB2UDBV82OrLater() {\r\n-        return (databaseProductVersion.indexOf(\"SQL\") != -1\r\n-             || databaseProductName.indexOf(\"DB2/\") != -1)\r\n-             && ((maj == 8 && min >= 2) || (maj >= 9));\r\n-    }\r\n-\r\n-    public boolean isDB2ZOSV8xOrLater() {\r\n-       return (databaseProductVersion.indexOf(\"DSN\") != -1\r\n-            || databaseProductName.indexOf(\"DB2/\") == -1)\r\n-            && maj >= 8;\r\n-           \r\n-    }\r\n-\r\n-    public boolean isDB2ISeriesV5R3OrEarlier() {\r\n-       return (databaseProductName.indexOf(\"AS\") != -1\r\n-           && ((maj == 5 && min <=3) || maj < 5));\r\n-    }\r\n-\r\n-    public boolean isDB2ISeriesV5R4OrLater() {\r\n-       return databaseProductName.indexOf(\"AS\") != -1\r\n-           && (maj >=6 || (maj == 5 && min >=4));\r\n-    }\r\n-\r\n-    public boolean isDB2UDBV81OrEarlier() {\r\n-        return (databaseProductVersion.indexOf(\"SQL\") != -1 \r\n-            || databaseProductName.indexOf(\"DB2/\") != -1) \r\n-            && ((maj == 8 && min <= 1) || maj < 8);\r\n-    }\r\n-\r\n-    /** Get the version Major/Minor for the ISeries\r\n-     */\r\n-    private void getProductVersionMajorMinorForISeries() {\r\n-        // ISeries    DBProdName                 DB2 UDB for AS/400\r\n-        //   (Toolbox)DBProdVersion              05.04.0000 V5R4m0\r\n-        // ISeries                               DB2 UDB for AS/400\r\n-        //   (Native)                            V5R4M0\r\n-        if (databaseProductName.indexOf(\"AS\") != -1) {\r\n-            // default to V5R4\r\n-            maj = 5;\r\n-            min = 4;\r\n-            int index = databaseProductVersion.indexOf('V');\r\n-            if (index != -1) {\r\n-            \tString s = databaseProductVersion.substring(index);\r\n-            \ts = s.toUpperCase();\r\n-\r\n-            \tStringTokenizer stringtokenizer = new StringTokenizer(s, \"VRM\"\r\n-            \t\t\t, false);\r\n-            \tif (stringtokenizer.countTokens() == 3) {\r\n-            \t\tString s1 = stringtokenizer.nextToken();\r\n-            \t\tmaj = Integer.parseInt(s1);\r\n-            \t\tString s2 =  stringtokenizer.nextToken();\r\n-            \t\tmin = Integer.parseInt(s2);\r\n-            \t}\r\n-            }\r\n-            else {\r\n-            \tindex = databaseProductVersion.indexOf('0');\r\n-            \tif (index != -1) {\r\n-            \t\tString s = databaseProductVersion.substring(index);\r\n-            \t\ts = s.toUpperCase();\r\n-           \t\t\tStringTokenizer stringtokenizer = new StringTokenizer(s, \"0\"\r\n-           \t\t\t\t\t, false);                    \r\n-           \t\t\tif (stringtokenizer.countTokens() == 2) {\r\n-           \t\t\t\tString s1 = stringtokenizer.nextToken();\r\n-           \t\t\t\tmaj = Integer.parseInt(s1);\r\n-           \t\t\t\tString s2 =  stringtokenizer.nextToken();\r\n-           \t\t\t\tmin = Integer.parseInt(s2);\r\n-           \t\t\t}\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    \r\n-    private void getProductVersionMajorMinor() {\r\n-        // Incase JDBC driver version is lower than 3\r\n-        // use following info to determine Major and Minor \r\n-        //                        CLI    vs      JCC\r\n-        // ZDBV8 DBProdName       DB2            DB2\r\n-        //       DBProdVersion    08.01.0005     DSN08015\r\n-        // ZDBV9                  DB2            DB2\r\n-        //                        09.01.0005     DSN09015\r\n-        // WinV9                  DB2/NT         DB2/NT\r\n-        //                        09.01.0000     SQL09010\r\n-        // SolarisV9                             DB2/SUN64\r\n-        //                                       SQL0901\r\n-        // Linux                  DB2/LINUX      DB2/LINUX\r\n-        //                        09.01.0000     SQL0901\r\n-        if (databaseProductVersion.indexOf(\"09\") != -1) {\r\n-            maj = 9;\r\n-            if (databaseProductVersion.indexOf(\"01\") != -1) {\r\n-                min = 1;\r\n-            }\r\n-        } else if (databaseProductVersion.indexOf(\"08\") != -1) {\r\n-            maj = 8;\r\n-            min = 2;\r\n-            if (databaseProductVersion.indexOf(\"01\") != -1) {\r\n-                min = 1;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    protected String getOptimizeClause(Select sel) {\r\n-        if (sel != null && sel.getExpectedResultCount() > 0) {\r\n-            StringBuffer buf = new StringBuffer();\r\n-            buf.append(\" \").append(optimizeClause).append(\" \")\r\n-                .append(String.valueOf(sel.getExpectedResultCount()))\r\n-                .append(\" \").append(rowClause);\r\n-            return buf.toString();\r\n-        }\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-    public OpenJPAException newStoreException(String msg, SQLException[] causes,\r\n-        Object failed) {\r\n-        if (causes != null && causes.length > 0)\r\n-            msg = appendExtendedExceptionMsg(msg, causes[0]);\r\n-        return super.newStoreException(msg, causes, failed);\r\n-    }\r\n-\r\n-    /**\r\n-     *  Append exception information from SQLCA to the exsisting\r\n-     *  exception meassage\r\n-     */\r\n-    private String appendExtendedExceptionMsg(String msg, SQLException sqle){\r\n-       final String GETSQLCA =\"getSqlca\";\r\n-       String exceptionMsg = new String();\r\n-       try {\r\n-            Method sqlcaM2 = sqle.getNextException().getClass()\r\n-                             .getMethod(GETSQLCA,null);\r\n-            Object sqlca = sqlcaM2.invoke(sqle.getNextException(),\r\n-                                          new Object[] {});\r\n-            Method  getSqlErrpMethd = sqlca.getClass().\r\n-            getMethod(\"getSqlErrp\", null);\r\n-            Method  getSqlWarnMethd = sqlca.getClass().\r\n-            getMethod(\"getSqlWarn\", null);\r\n-            Method  getSqlErrdMethd = sqlca.getClass().\r\n-            getMethod(\"getSqlErrd\", null);\r\n-            StringBuffer errdStr = new StringBuffer();\r\n-\r\n-            int[] errds = (int[]) getSqlErrdMethd.invoke(sqlca, new Object[]{});\r\n-            for (int i = 0; i < errds.length; i++)\r\n-                errdStr.append(errdStr.length() > 0 ? \", \" : \"\").\r\n-                    append(errds[i]);\r\n-            exceptionMsg = exceptionMsg.concat( \"SQLCA OUTPUT\" +\r\n-                    \"[Errp=\" + getSqlErrpMethd.invoke(sqlca, new Object[]{})\r\n-                    + \", Errd=\" + errdStr);\r\n-\r\n-            String Warn = new String((char[]) getSqlWarnMethd.\r\n-                    invoke(sqlca, new Object[]{}));\r\n-            if(Warn.trim().length() != 0)\r\n-                exceptionMsg = exceptionMsg.concat(\", Warn=\" +Warn + \"]\" );\r\n-            else\r\n-                exceptionMsg = exceptionMsg.concat( \"]\" );\r\n-            msg = msg.concat(exceptionMsg);\r\n-            return msg;\r\n-        } catch (Throwable t) {\r\n-            return sqle.getMessage();\r\n-        }\r\n-    }\r\n-\r\n-    public int getDb2ServerType() {\r\n-        return db2ServerType;\r\n-    }\r\n-    \r\n-    protected void appendLength(SQLBuffer buf, int type) {\r\n-        if (type == Types.VARCHAR)\r\n-            buf.append(\"(\").append(Integer.toString(characterColumnSize)).\r\n-                append(\")\");\r\n-    }\r\n-\r\n-    /**\r\n-     * If this dictionary supports XML type,\r\n-     * use this method to append xml predicate.\r\n-     * \r\n-     * @param buf the SQL buffer to write the comparison\r\n-     * @param op the comparison operation to perform\r\n-     * @param lhs the left hand side of the comparison\r\n-     * @param rhs the right hand side of the comparison\r\n-     * @param lhsxml indicates whether the left operand maps to xml\r\n-     * @param rhsxml indicates whether the right operand maps to xml\r\n-     */\r\n-    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\r\n-        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\r\n-        super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\r\n-        if (lhsxml && rhsxml)\r\n-            appendXmlComparison2(buf, op, lhs, rhs);\r\n-        else if (lhsxml)\r\n-            appendXmlComparison1(buf, op, lhs, rhs);\r\n-        else \r\n-            appendXmlComparison1(buf, op, rhs, lhs);\r\n-    }\r\n-\r\n-    /**\r\n-     * Append an xml comparison predicate.\r\n-     *\r\n-     * @param buf the SQL buffer to write the comparison\r\n-     * @param op the comparison operation to perform\r\n-     * @param lhs the left hand side of the comparison (maps to xml column)\r\n-     * @param rhs the right hand side of the comparison\r\n-     */\r\n-    private void appendXmlComparison1(SQLBuffer buf, String op, \r\n-            FilterValue lhs, FilterValue rhs) {\r\n-        boolean castrhs = false;\r\n-        Class rc = Filters.wrap(rhs.getType());\r\n-        int type = 0;\r\n-        if (rhs.isConstant()) {\r\n-            type = getJDBCType(JavaTypes.getTypeCode(rc), false);\r\n-            castrhs = true;\r\n-        }\r\n-        \r\n-        appendXmlExists(buf, lhs);\r\n-\r\n-        buf.append(\" \").append(op).append(\" \");\r\n-        \r\n-        buf.append(\"$\");\r\n-        if (castrhs)\r\n-            buf.append(\"Parm\");\r\n-        else\r\n-            rhs.appendTo(buf);\r\n-        \r\n-        buf.append(\"]' PASSING \");\r\n-        appendXmlVar(buf, lhs);\r\n-        buf.append(\", \");\r\n-        \r\n-        if (castrhs)\r\n-            appendCast(buf, rhs, type);\r\n-        else\r\n-            rhs.appendTo(buf);\r\n-        \r\n-        buf.append(\" AS \\\"\");\r\n-        if (castrhs)\r\n-            buf.append(\"Parm\");\r\n-        else\r\n-            rhs.appendTo(buf);\r\n-        buf.append(\"\\\")\");\r\n-    }\r\n-    \r\n-    /**\r\n-     * Append an xml comparison predicate. (both operands map to xml column)\r\n-     *\r\n-     * @param buf the SQL buffer to write the comparison\r\n-     * @param op the comparison operation to perform\r\n-     * @param lhs the left hand side of the comparison (maps to xml column)\r\n-     * @param rhs the right hand side of the comparison (maps to xml column)\r\n-     */\r\n-    private void appendXmlComparison2(SQLBuffer buf, String op, \r\n-            FilterValue lhs, FilterValue rhs) {\r\n-        appendXmlExists(buf, lhs);\r\n-        \r\n-        buf.append(\" \").append(op).append(\" \");\r\n-        \r\n-        buf.append(\"$\").append(rhs.getColumnAlias(\r\n-            rhs.getFieldMapping().getColumns()[0])).\r\n-            append(\"/*/\");\r\n-        rhs.appendTo(buf);\r\n-        \r\n-        buf.append(\"]' PASSING \");\r\n-        appendXmlVar(buf, lhs);\r\n-        buf.append(\", \");\r\n-        appendXmlVar(buf, rhs);\r\n-        buf.append(\")\");\r\n-    }\r\n-    \r\n-    private void appendXmlVar(SQLBuffer buf, FilterValue val) {\r\n-        buf.append(val.getColumnAlias(\r\n-            val.getFieldMapping().getColumns()[0])).\r\n-            append(\" AS \").\r\n-            append(\"\\\"\").append(val.getColumnAlias(\r\n-            val.getFieldMapping().getColumns()[0])).\r\n-            append(\"\\\"\");        \r\n-    }\r\n-    \r\n-    private void appendXmlExists(SQLBuffer buf, FilterValue val) {\r\n-        buf.append(\"XMLEXISTS('\");\r\n-        buf.append(\"$\").append(val.getColumnAlias(\r\n-            val.getFieldMapping().getColumns()[0])).\r\n-            append(\"/*[\");\r\n-        val.appendTo(buf);        \r\n-    }\r\n-    \r\n-    /**\r\n-     * add CAST for a scalar function where operand is a param\r\n-     * \r\n-     * @param func original string\r\n-     * @param target substring to look for\r\n-     * @param asString \r\n-     * @return updated string (func)\r\n-     */\r\n-    private String addCastAsString(String func, String target, \r\n-            String asString) {\r\n-        String fstring = func;\r\n-        if (func.indexOf(target) != -1)\r\n-            fstring = Strings.replace(\r\n-                func, target, \"CAST(\" + target + asString + \")\");\r\n-        return fstring;\r\n-    }\r\n-\r\n-    /**\r\n-     * add CAST for a function operator where operand is a param\r\n-     * \r\n-     * @param func function name\r\n-     * @param val type\r\n-     * @return updated string (func)\r\n-     */\r\n-    public String addCastAsType(String func, Val val) {\r\n-        String fstring = null;\r\n-        String type = getTypeName(getJDBCType(JavaTypes.getTypeCode(val\r\n-            .getType()), false));\r\n-        fstring = \"CAST(? AS \" + type + \")\";\r\n-        return fstring;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the correct CAST function syntax\r\n-     * \r\n-     * @param val operand of cast\r\n-     * @param func original string\r\n-     * @return a String with the correct CAST function syntax\r\n-     */\r\n-    public String getCastFunction(Val val, String func) {\r\n-        if (val instanceof Lit || val instanceof Param)\r\n-            if (func.indexOf(\"VARCHAR\") == -1)\r\n-                func = addCastAsString(func, \"{0}\", \" AS VARCHAR(1000)\");\r\n-        return func;\r\n-    }\r\n-\r\n-    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\r\n-            FilterValue start) {\r\n-        if (find.getValue() != null) { // non constants\r\n-            buf.append(\"(LOCATE(CAST((\");\r\n-            find.appendTo(buf);\r\n-            buf.append(\") AS VARCHAR(1000)), \");\r\n-        } else {\r\n-            // this is a constant\r\n-            buf.append(\"(LOCATE(\");\r\n-            find.appendTo(buf);\r\n-            buf.append(\", \");\r\n-        }\r\n-        if (str.getValue() != null) {\r\n-            buf.append(\"CAST((\");\r\n-            str.appendTo(buf);\r\n-            buf.append(\") AS VARCHAR(1000))\");\r\n-        } else {\r\n-            str.appendTo(buf);\r\n-        }\r\n-        if (start != null) {\r\n-            if (start.getValue() == null) {\r\n-                buf.append(\", CAST((\");\r\n-                start.appendTo(buf);\r\n-                buf.append(\") AS INTEGER) + 1\");\r\n-            } else {\r\n-                buf.append(\", \");\r\n-                start.appendTo(buf);\r\n-            }\r\n-        }\r\n-        buf.append(\") - 1)\");\r\n-    }\r\n-\r\n-    /** \r\n-     * Cast the specified value to the specified type.\r\n-     *\r\n-     * @param buf the buffer to append the cast to\r\n-     * @param val the value to cast\r\n-     * @param type the type of the case, e.g. {@link Types#NUMERIC}\r\n-     */\r\n-    public void appendCast(SQLBuffer buf, FilterValue val, int type) {\r\n-\r\n-        // Convert the cast function: \"CAST({0} AS {1})\"\r\n-        int firstParam = castFunction.indexOf(\"{0}\");\r\n-        String pre = castFunction.substring(0, firstParam); // \"CAST(\"\r\n-        String mid = castFunction.substring(firstParam + 3);\r\n-        int secondParam = mid.indexOf(\"{1}\");\r\n-        String post;\r\n-        if (secondParam > -1) {\r\n-            post = mid.substring(secondParam + 3); // \")\"\r\n-            mid = mid.substring(0, secondParam); // \" AS \"\r\n-        } else\r\n-            post = \"\";\r\n-\r\n-        // No need to add CAST if the value is a constant\r\n-        if (val instanceof Lit || val instanceof Param) {\r\n-            buf.append(pre);\r\n-            val.appendTo(buf);\r\n-            buf.append(mid);\r\n-            buf.append(getTypeName(type));\r\n-            appendLength(buf, type);\r\n-            buf.append(post);\r\n-        } else {\r\n-            val.appendTo(buf);\r\n-            String sqlString = buf.getSQL(false);\r\n-            if (sqlString.endsWith(\"?\")) {\r\n-                // case \"(?\" - convert to \"CAST(? AS type\"\r\n-                String typeName = getTypeName(type);\r\n-                if (String.class.equals(val.getType()))\r\n-                    typeName = typeName + \"(\" + characterColumnSize + \")\";\r\n-                String str = \"CAST(? AS \" + typeName + \")\";\r\n-                buf.replaceSqlString(sqlString.length() - 1,\r\n-                        sqlString.length(), str);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Create an index if necessary for some database tables\r\n-     */\r\n-    public void createIndexIfNecessary(Schema schema, String table,\r\n-            Column pkColumn) {\r\n-        if (isDB2ZOSV8xOrLater()) {\r\n-            // build the index for the sequence tables\r\n-            // the index name will the fully qualified table name + _IDX\r\n-            Table tab = schema.getTable(table);\r\n-            Index idx = tab.addIndex(tab.getFullName() + \"_IDX\");\r\n-            idx.setUnique(true);\r\n-            idx.addColumn(pkColumn);\r\n-        }\r\n-    }\r\n-    \r\n-    String nullSafe(String s) {\r\n-    \treturn s == null ? \"\" : s;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.lang.reflect.Method;\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.Arrays;\n+import java.util.StringTokenizer;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.jdbc.kernel.exps.Lit;\n+import org.apache.openjpa.jdbc.kernel.exps.Param;\n+import org.apache.openjpa.jdbc.kernel.exps.Val;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Index;\n+import org.apache.openjpa.jdbc.schema.Schema;\n+import org.apache.openjpa.jdbc.schema.Sequence;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.UnsupportedException;\n+\n+import serp.util.Strings;\n+\n+/**\n+ * Dictionary for IBM DB2 database.\n+ */\n+public class DB2Dictionary\n+    extends AbstractDB2Dictionary {\n+    private static final Localizer _loc = Localizer.forPackage\n+        (DB2Dictionary.class);\n+\n+    public String optimizeClause = \"optimize for\";\n+    public String rowClause = \"row\";\n+    protected int db2ServerType = 0;\n+    public static final int db2ISeriesV5R3OrEarlier = 1;\n+    public static final int db2UDBV81OrEarlier = 2;\n+    public static final int db2ZOSV8xOrLater = 3;\n+    public static final int db2UDBV82OrLater = 4;\n+    public static final int db2ISeriesV5R4OrLater = 5;\n+\tprivate static final String forUpdate = \"FOR UPDATE\";\n+    private static final String withRSClause = \"WITH RS\";\n+    private static final String withRRClause = \"WITH RR\";\n+    private static final String useKeepUpdateLockClause\n+        = \"USE AND KEEP UPDATE LOCKS\";\n+    private static final String useKeepExclusiveLockClause\n+        = \"USE AND KEEP EXCLUSIVE LOCKS\";\n+    private static final String forReadOnlyClause = \"FOR READ ONLY\";\n+    protected String databaseProductName = \"\";\n+    protected String databaseProductVersion = \"\";\n+    protected int maj = 0;\n+    protected int min = 0;\n+\n+    public DB2Dictionary() {\n+        platform = \"DB2\";\n+        validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\n+            + \"SYSIBM.SYSTABLES\";\n+        supportsSelectEndIndex = true;\n+\n+        nextSequenceQuery = \"VALUES NEXTVAL FOR {0}\";\n+\n+        sequenceSQL = \"SELECT SEQSCHEMA AS SEQUENCE_SCHEMA, \"\n+            + \"SEQNAME AS SEQUENCE_NAME FROM SYSCAT.SEQUENCES\";\n+        sequenceSchemaSQL = \"SEQSCHEMA = ?\";\n+        sequenceNameSQL = \"SEQNAME = ?\";\n+        characterColumnSize = 254;\n+\n+        binaryTypeName = \"BLOB(1M)\";\n+        longVarbinaryTypeName = \"BLOB(1M)\";\n+        varbinaryTypeName = \"BLOB(1M)\";\n+        clobTypeName = \"CLOB(1M)\";\n+        longVarcharTypeName = \"LONG VARCHAR\";\n+        datePrecision = MICRO;\n+        storeCharsAsNumbers = false;\n+\n+        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\n+            \"LONG VARCHAR FOR BIT DATA\", \"LONG VARCHAR\", \"LONG VARGRAPHIC\",\n+        }));\n+        systemSchemas = new String(\n+                \"SYSCAT,SYSIBM,SYSSTAT,SYSIBMADM,SYSTOOLS\");\n+        maxConstraintNameLength = 18;\n+        maxIndexNameLength = 18;\n+        maxColumnNameLength = 30;\n+        supportsDeferredConstraints = false;\n+        supportsDefaultDeleteAction = false;\n+        supportsAlterTableWithDropColumn = false;\n+\n+        supportsNullTableForGetColumns = false;\n+        requiresCastForMathFunctions = true;\n+        requiresCastForComparisons = true;\n+\n+        reservedWordSet.addAll(Arrays.asList(new String[]{\n+            \"AFTER\", \"ALIAS\", \"ALLOW\", \"APPLICATION\", \"ASSOCIATE\", \"ASUTIME\",\n+            \"AUDIT\", \"AUX\", \"AUXILIARY\", \"BEFORE\", \"BINARY\", \"BUFFERPOOL\",\n+            \"CACHE\", \"CALL\", \"CALLED\", \"CAPTURE\", \"CARDINALITY\", \"CCSID\",\n+            \"CLUSTER\", \"COLLECTION\", \"COLLID\", \"COMMENT\", \"CONCAT\",\n+            \"CONDITION\", \"CONTAINS\", \"COUNT_BIG\", \"CURRENT_LC_CTYPE\",\n+            \"CURRENT_PATH\", \"CURRENT_SERVER\", \"CURRENT_TIMEZONE\", \"CYCLE\",\n+            \"DATA\", \"DATABASE\", \"DAYS\", \"DB2GENERAL\", \"DB2GENRL\", \"DB2SQL\",\n+            \"DBINFO\", \"DEFAULTS\", \"DEFINITION\", \"DETERMINISTIC\", \"DISALLOW\",\n+            \"DO\", \"DSNHATTR\", \"DSSIZE\", \"DYNAMIC\", \"EACH\", \"EDITPROC\", \"ELSEIF\",\n+            \"ENCODING\", \"END-EXEC1\", \"ERASE\", \"EXCLUDING\", \"EXIT\", \"FENCED\",\n+            \"FIELDPROC\", \"FILE\", \"FINAL\", \"FREE\", \"FUNCTION\", \"GENERAL\",\n+            \"GENERATED\", \"GRAPHIC\", \"HANDLER\", \"HOLD\", \"HOURS\", \"IF\",\n+            \"INCLUDING\", \"INCREMENT\", \"INDEX\", \"INHERIT\", \"INOUT\", \"INTEGRITY\",\n+            \"ISOBID\", \"ITERATE\", \"JAR\", \"JAVA\", \"LABEL\", \"LC_CTYPE\", \"LEAVE\",\n+            \"LINKTYPE\", \"LOCALE\", \"LOCATOR\", \"LOCATORS\", \"LOCK\", \"LOCKMAX\",\n+            \"LOCKSIZE\", \"LONG\", \"LOOP\", \"MAXVALUE\", \"MICROSECOND\",\n+            \"MICROSECONDS\", \"MINUTES\", \"MINVALUE\", \"MODE\", \"MODIFIES\", \"MONTHS\",\n+            \"NEW\", \"NEW_TABLE\", \"NOCACHE\", \"NOCYCLE\", \"NODENAME\", \"NODENUMBER\",\n+            \"NOMAXVALUE\", \"NOMINVALUE\", \"NOORDER\", \"NULLS\", \"NUMPARTS\", \"OBID\",\n+            \"OLD\", \"OLD_TABLE\", \"OPTIMIZATION\", \"OPTIMIZE\", \"OUT\", \"OVERRIDING\",\n+            \"PACKAGE\", \"PARAMETER\", \"PART\", \"PARTITION\", \"PATH\", \"PIECESIZE\",\n+            \"PLAN\", \"PRIQTY\", \"PROGRAM\", \"PSID\", \"QUERYNO\", \"READS\", \"RECOVERY\",\n+            \"REFERENCING\", \"RELEASE\", \"RENAME\", \"REPEAT\", \"RESET\", \"RESIGNAL\",\n+            \"RESTART\", \"RESULT\", \"RESULT_SET_LOCATOR\", \"RETURN\", \"RETURNS\",\n+            \"ROUTINE\", \"ROW\", \"RRN\", \"RUN\", \"SAVEPOINT\", \"SCRATCHPAD\",\n+            \"SECONDS\", \"SECQTY\", \"SECURITY\", \"SENSITIVE\", \"SIGNAL\", \"SIMPLE\",\n+            \"SOURCE\", \"SPECIFIC\", \"SQLID\", \"STANDARD\", \"START\", \"STATIC\",\n+            \"STAY\", \"STOGROUP\", \"STORES\", \"STYLE\", \"SUBPAGES\", \"SYNONYM\",\n+            \"SYSFUN\", \"SYSIBM\", \"SYSPROC\", \"SYSTEM\", \"TABLESPACE\", \"TRIGGER\",\n+            \"TYPE\", \"UNDO\", \"UNTIL\", \"VALIDPROC\", \"VARIABLE\", \"VARIANT\", \"VCAT\",\n+            \"VOLUMES\", \"WHILE\", \"WLM\", \"YEARS\",\n+        }));\n+        \n+        selectWordSet.add(\"WITH\");\n+    }\n+\n+    public boolean supportsRandomAccessResultSet(Select sel,\n+        boolean forUpdate) {\n+        return !forUpdate\n+            && super.supportsRandomAccessResultSet(sel, forUpdate);\n+    }\n+\n+    protected void appendSelectRange(SQLBuffer buf, long start, long end,\n+        boolean subselect) {\n+        // appends the literal range string, since DB2 is unable to handle\n+        // a bound parameter for it\n+        // do not generate FETCH FIRST clause for subselect\n+        if (!subselect)\n+            buf.append(\" FETCH FIRST \").append(Long.toString(end)).\n+                append(\" ROWS ONLY\");\n+    }\n+\n+    public String[] getCreateSequenceSQL(Sequence seq) {\n+        String[] sql = super.getCreateSequenceSQL(seq);\n+        if (seq.getAllocate() > 1)\n+            sql[0] += \" CACHE \" + seq.getAllocate();\n+        return sql;\n+    }\n+\n+    protected String getSequencesSQL(String schemaName, String sequenceName) {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(sequenceSQL);\n+        if (schemaName != null || sequenceName != null)\n+            buf.append(\" WHERE \");\n+        if (schemaName != null) {\n+            buf.append(sequenceSchemaSQL);\n+            if (sequenceName != null)\n+                buf.append(\" AND \");\n+        }\n+        if (sequenceName != null)\n+            buf.append(sequenceNameSQL);\n+        return buf.toString();\n+    }\n+\n+    public Connection decorate(Connection conn)\n+        throws SQLException {\n+        // some versions of the DB2 driver seem to default to\n+        // READ_UNCOMMITTED, which will prevent locking from working\n+        // (multiple SELECT ... FOR UPDATE statements are allowed on\n+        // the same instance); if we have not overridden the\n+        // transaction isolation in the configuration, default to\n+        // TRANSACTION_READ_COMMITTED\n+        conn = super.decorate(conn);\n+\n+        if (conf.getTransactionIsolationConstant() == -1\n+            && conn.getTransactionIsolation() < conn.TRANSACTION_READ_COMMITTED)\n+            conn.setTransactionIsolation(conn.TRANSACTION_READ_COMMITTED);\n+\n+        return conn;\n+    }\n+\n+    public void connectedConfiguration(Connection conn) throws SQLException {\n+    \tsuper.connectedConfiguration(conn);\n+\n+    \tDatabaseMetaData metaData = conn.getMetaData();\n+        databaseProductName = nullSafe(metaData.getDatabaseProductName());\n+        databaseProductVersion = nullSafe(metaData.getDatabaseProductVersion());\n+        \n+        // Determine the type of DB2 database\n+        // First check for AS/400\n+        getProductVersionMajorMinorForISeries();\n+\n+        if (maj > 0) {\n+            if (isDB2ISeriesV5R3OrEarlier())\n+                db2ServerType = db2ISeriesV5R3OrEarlier;\n+            else if (isDB2ISeriesV5R4OrLater())\n+                db2ServerType = db2ISeriesV5R4OrLater;\n+        }\n+        \n+    \tif (db2ServerType == 0) {\n+    \t    if (isJDBC3) {\n+    \t        maj = metaData.getDatabaseMajorVersion();\n+    \t        min = metaData.getDatabaseMinorVersion();\n+    \t    }\n+    \t    else\n+    \t        getProductVersionMajorMinor();\n+\n+    \t    // Determine the type of DB2 database for ZOS & UDB\n+    \t    if (isDB2UDBV81OrEarlier())\n+    \t        db2ServerType = db2UDBV81OrEarlier;\n+    \t    else if (isDB2ZOSV8xOrLater())\n+    \t        db2ServerType = db2ZOSV8xOrLater;\n+    \t    else if (isDB2UDBV82OrLater())\n+    \t        db2ServerType = db2UDBV82OrLater;\n+        }\n+\n+        // verify that databae product is supported\n+        if (db2ServerType == 0 || maj == 0)\n+            throw new UnsupportedException(_loc.get(\"db-not-supported\",\n+                new Object[] {databaseProductName, databaseProductVersion }));                    \n+\n+    \tif (maj >= 9 || (maj == 8 && min >= 2)) {\n+    \t    supportsLockingWithMultipleTables = true;\n+    \t    supportsLockingWithInnerJoin = true;\n+    \t    supportsLockingWithOuterJoin = true;\n+    \t    forUpdateClause = \"WITH RR USE AND KEEP UPDATE LOCKS\";\n+    \t    if (maj >=9)\n+    \t        supportsXMLColumn = true;\n+    \t}\n+\n+        // platform specific settings\n+        switch (db2ServerType) {\n+        case  db2ZOSV8xOrLater:\n+            // DB2 Z/OS \n+            characterColumnSize = 255;\n+            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            sequenceSQL = \"SELECT SCHEMA AS SEQUENCE_SCHEMA, \"\n+                + \"NAME AS SEQUENCE_NAME FROM SYSIBM.SYSSEQUENCES\";\n+            sequenceSchemaSQL = \"SCHEMA = ?\";\n+            sequenceNameSQL = \"NAME = ?\";\n+            if (maj == 8) {\n+                // DB2 Z/OS Version 8: no bigint support, hence map Java\n+                // long to decimal\n+                bigintTypeName = \"DECIMAL(31,0)\";\n+            }\n+            ignoreSQLExceptionOnSetQueryTimeout = true; \n+            break;\n+        case db2ISeriesV5R3OrEarlier:\n+        case db2ISeriesV5R4OrLater:\n+            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\n+                + \"QSYS2.SYSTABLES\";\n+            sequenceSQL = \"SELECT SEQUENCE_SCHEMA, \"\n+                + \"SEQUENCE_NAME FROM QSYS2.SYSSEQUENCES\";\n+            sequenceSchemaSQL = \"SEQUENCE_SCHEMA = ?\";\n+            sequenceNameSQL = \"SEQUENCE_NAME = ?\";\n+            break;\n+        }\n+    }\n+\n+    /**\n+     * Get the update clause for the query based on the\n+     * updateClause and isolationLevel hints\n+     */\n+    protected String getForUpdateClause(JDBCFetchConfiguration fetch,\n+        boolean isForUpdate, Select sel) {\n+        int isolationLevel;\n+        // For db2UDBV81OrEarlier and db2ISeriesV5R3OrEarlier:\n+        // \"optimize for\" clause appears before \"for update\" clause.\n+        StringBuffer forUpdateString = new StringBuffer(\n+            getOptimizeClause(sel));\n+        try {\n+            // Determine the isolationLevel; the fetch\n+            // configuration data overrides the persistence.xml value\n+            if (fetch != null && fetch.getIsolation() != -1)\n+                isolationLevel = fetch.getIsolation();\n+            else\n+                isolationLevel = conf.getTransactionIsolationConstant();\n+\n+            if (isForUpdate) {\n+                switch(db2ServerType) {\n+                case db2ISeriesV5R3OrEarlier:\n+                case db2UDBV81OrEarlier:\n+                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE)\n+                        forUpdateString.append(\" \").append(forUpdateClause);\n+                    else \n+                        forUpdateString.append(\" \").append(forUpdate)\n+                            .append(\" \").append(withRSClause);\n+                    break;\n+                case db2ZOSV8xOrLater:\n+                case db2UDBV82OrLater:\n+                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\n+                            .append(\" \").append(withRRClause)\n+                            .append(\" \").append(useKeepUpdateLockClause);   \n+                    } else {\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\n+                            .append(\" \").append(withRSClause)\n+                            .append(\" \").append(useKeepUpdateLockClause);                            \n+                    }\n+                    break;\n+                case db2ISeriesV5R4OrLater:\n+                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\n+                            .append(\" \").append(withRRClause)\n+                            .append(\" \").append(useKeepExclusiveLockClause);       \n+                    } else {\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\n+                            .append(\" \").append(withRSClause)\n+                            .append(\" \").append(useKeepExclusiveLockClause);\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+        catch (Exception e) {\n+            if (log.isTraceEnabled())\n+                log.error(e.toString(),e);\n+        }\n+        return forUpdateString.toString();\n+    }\n+\n+    public boolean isDB2UDBV82OrLater() {\n+        return (databaseProductVersion.indexOf(\"SQL\") != -1\n+             || databaseProductName.indexOf(\"DB2/\") != -1)\n+             && ((maj == 8 && min >= 2) || (maj >= 9));\n+    }\n+\n+    public boolean isDB2ZOSV8xOrLater() {\n+       return (databaseProductVersion.indexOf(\"DSN\") != -1\n+            || databaseProductName.indexOf(\"DB2/\") == -1)\n+            && maj >= 8;\n+    }\n+\n+    public boolean isDB2ISeriesV5R3OrEarlier() {\n+       return (databaseProductName.indexOf(\"AS\") != -1\n+           && ((maj == 5 && min <=3) || maj < 5));\n+    }\n+\n+    public boolean isDB2ISeriesV5R4OrLater() {\n+       return databaseProductName.indexOf(\"AS\") != -1\n+           && (maj >=6 || (maj == 5 && min >=4));\n+    }\n+\n+    public boolean isDB2UDBV81OrEarlier() {\n+        return (databaseProductVersion.indexOf(\"SQL\") != -1 \n+            || databaseProductName.indexOf(\"DB2/\") != -1) \n+            && ((maj == 8 && min <= 1) || maj < 8);\n+    }\n+\n+    /** Get the version Major/Minor for the ISeries\n+     */\n+    private void getProductVersionMajorMinorForISeries() {\n+        // ISeries    DBProdName                 DB2 UDB for AS/400\n+        //   (Toolbox)DBProdVersion              05.04.0000 V5R4m0\n+        // ISeries                               DB2 UDB for AS/400\n+        //   (Native)                            V5R4M0\n+        if (databaseProductName.indexOf(\"AS\") != -1) {\n+            // default to V5R4\n+            maj = 5;\n+            min = 4;\n+            int index = databaseProductVersion.indexOf('V');\n+            if (index != -1) {\n+            \tString s = databaseProductVersion.substring(index);\n+            \ts = s.toUpperCase();\n+\n+            \tStringTokenizer stringtokenizer = new StringTokenizer(s, \"VRM\"\n+            \t\t\t, false);\n+            \tif (stringtokenizer.countTokens() == 3) {\n+            \t\tString s1 = stringtokenizer.nextToken();\n+            \t\tmaj = Integer.parseInt(s1);\n+            \t\tString s2 =  stringtokenizer.nextToken();\n+            \t\tmin = Integer.parseInt(s2);\n+            \t}\n+            }\n+            else {\n+            \tindex = databaseProductVersion.indexOf('0');\n+            \tif (index != -1) {\n+            \t\tString s = databaseProductVersion.substring(index);\n+            \t\ts = s.toUpperCase();\n+           \t\t\tStringTokenizer stringtokenizer = new StringTokenizer(s, \"0\"\n+           \t\t\t\t\t, false);                    \n+           \t\t\tif (stringtokenizer.countTokens() == 2) {\n+           \t\t\t\tString s1 = stringtokenizer.nextToken();\n+           \t\t\t\tmaj = Integer.parseInt(s1);\n+           \t\t\t\tString s2 =  stringtokenizer.nextToken();\n+           \t\t\t\tmin = Integer.parseInt(s2);\n+           \t\t\t}\n+                }\n+            }\n+        }\n+    }\n+    \n+    private void getProductVersionMajorMinor() {\n+        // Incase JDBC driver version is lower than 3\n+        // use following info to determine Major and Minor \n+        //                        CLI    vs      JCC\n+        // ZDBV8 DBProdName       DB2            DB2\n+        //       DBProdVersion    08.01.0005     DSN08015\n+        // ZDBV9                  DB2            DB2\n+        //                        09.01.0005     DSN09015\n+        // WinV9                  DB2/NT         DB2/NT\n+        //                        09.01.0000     SQL09010\n+        // SolarisV9                             DB2/SUN64\n+        //                                       SQL0901\n+        // Linux                  DB2/LINUX      DB2/LINUX\n+        //                        09.01.0000     SQL0901\n+        if (databaseProductVersion.indexOf(\"09\") != -1) {\n+            maj = 9;\n+            if (databaseProductVersion.indexOf(\"01\") != -1) {\n+                min = 1;\n+            }\n+        } else if (databaseProductVersion.indexOf(\"08\") != -1) {\n+            maj = 8;\n+            min = 2;\n+            if (databaseProductVersion.indexOf(\"01\") != -1) {\n+                min = 1;\n+            }\n+        }\n+    }\n+\n+    protected String getOptimizeClause(Select sel) {\n+        if (sel != null && sel.getExpectedResultCount() > 0) {\n+            StringBuffer buf = new StringBuffer();\n+            buf.append(\" \").append(optimizeClause).append(\" \")\n+                .append(String.valueOf(sel.getExpectedResultCount()))\n+                .append(\" \").append(rowClause);\n+            return buf.toString();\n+        }\n+\n+        return \"\";\n+    }\n+\n+    public OpenJPAException newStoreException(String msg, SQLException[] causes,\n+        Object failed) {\n+        if (causes != null && causes.length > 0)\n+            msg = appendExtendedExceptionMsg(msg, causes[0]);\n+        return super.newStoreException(msg, causes, failed);\n+    }\n+\n+    /**\n+     *  Append exception information from SQLCA to the exsisting\n+     *  exception meassage\n+     */\n+    private String appendExtendedExceptionMsg(String msg, SQLException sqle){\n+       final String GETSQLCA =\"getSqlca\";\n+       String exceptionMsg = new String();\n+       try {\n+            Method sqlcaM2 = sqle.getNextException().getClass()\n+                             .getMethod(GETSQLCA,null);\n+            Object sqlca = sqlcaM2.invoke(sqle.getNextException(),\n+                                          new Object[] {});\n+            Method  getSqlErrpMethd = sqlca.getClass().\n+            getMethod(\"getSqlErrp\", null);\n+            Method  getSqlWarnMethd = sqlca.getClass().\n+            getMethod(\"getSqlWarn\", null);\n+            Method  getSqlErrdMethd = sqlca.getClass().\n+            getMethod(\"getSqlErrd\", null);\n+            StringBuffer errdStr = new StringBuffer();\n+\n+            int[] errds = (int[]) getSqlErrdMethd.invoke(sqlca, new Object[]{});\n+            for (int i = 0; i < errds.length; i++)\n+                errdStr.append(errdStr.length() > 0 ? \", \" : \"\").\n+                    append(errds[i]);\n+            exceptionMsg = exceptionMsg.concat( \"SQLCA OUTPUT\" +\n+                    \"[Errp=\" + getSqlErrpMethd.invoke(sqlca, new Object[]{})\n+                    + \", Errd=\" + errdStr);\n+\n+            String Warn = new String((char[]) getSqlWarnMethd.\n+                    invoke(sqlca, new Object[]{}));\n+            if(Warn.trim().length() != 0)\n+                exceptionMsg = exceptionMsg.concat(\", Warn=\" +Warn + \"]\" );\n+            else\n+                exceptionMsg = exceptionMsg.concat( \"]\" );\n+            msg = msg.concat(exceptionMsg);\n+            return msg;\n+        } catch (Throwable t) {\n+            return sqle.getMessage();\n+        }\n+    }\n+\n+    public int getDb2ServerType() {\n+        return db2ServerType;\n+    }\n+    \n+    protected void appendLength(SQLBuffer buf, int type) {\n+        if (type == Types.VARCHAR)\n+            buf.append(\"(\").append(Integer.toString(characterColumnSize)).\n+                append(\")\");\n+    }\n+\n+    /**\n+     * If this dictionary supports XML type,\n+     * use this method to append xml predicate.\n+     * \n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison\n+     * @param rhs the right hand side of the comparison\n+     * @param lhsxml indicates whether the left operand maps to xml\n+     * @param rhsxml indicates whether the right operand maps to xml\n+     */\n+    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\n+        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\n+        super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\n+        if (lhsxml && rhsxml)\n+            appendXmlComparison2(buf, op, lhs, rhs);\n+        else if (lhsxml)\n+            appendXmlComparison1(buf, op, lhs, rhs);\n+        else \n+            appendXmlComparison1(buf, op, rhs, lhs);\n+    }\n+\n+    /**\n+     * Append an xml comparison predicate.\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison\n+     */\n+    private void appendXmlComparison1(SQLBuffer buf, String op, \n+            FilterValue lhs, FilterValue rhs) {\n+        boolean castrhs = false;\n+        Class rc = Filters.wrap(rhs.getType());\n+        int type = 0;\n+        if (rhs.isConstant()) {\n+            type = getJDBCType(JavaTypes.getTypeCode(rc), false);\n+            castrhs = true;\n+        }\n+        \n+        appendXmlExists(buf, lhs);\n+\n+        buf.append(\" \").append(op).append(\" \");\n+        \n+        buf.append(\"$\");\n+        if (castrhs)\n+            buf.append(\"Parm\");\n+        else\n+            rhs.appendTo(buf);\n+        \n+        buf.append(\"]' PASSING \");\n+        appendXmlVar(buf, lhs);\n+        buf.append(\", \");\n+        \n+        if (castrhs)\n+            appendCast(buf, rhs, type);\n+        else\n+            rhs.appendTo(buf);\n+        \n+        buf.append(\" AS \\\"\");\n+        if (castrhs)\n+            buf.append(\"Parm\");\n+        else\n+            rhs.appendTo(buf);\n+        buf.append(\"\\\")\");\n+    }\n+    \n+    /**\n+     * Append an xml comparison predicate. (both operands map to xml column)\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison (maps to xml column)\n+     */\n+    private void appendXmlComparison2(SQLBuffer buf, String op, \n+            FilterValue lhs, FilterValue rhs) {\n+        appendXmlExists(buf, lhs);\n+        \n+        buf.append(\" \").append(op).append(\" \");\n+        \n+        buf.append(\"$\").append(rhs.getColumnAlias(\n+            rhs.getFieldMapping().getColumns()[0])).\n+            append(\"/*/\");\n+        rhs.appendTo(buf);\n+        \n+        buf.append(\"]' PASSING \");\n+        appendXmlVar(buf, lhs);\n+        buf.append(\", \");\n+        appendXmlVar(buf, rhs);\n+        buf.append(\")\");\n+    }\n+    \n+    private void appendXmlVar(SQLBuffer buf, FilterValue val) {\n+        buf.append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\" AS \").\n+            append(\"\\\"\").append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\"\\\"\");        \n+    }\n+    \n+    private void appendXmlExists(SQLBuffer buf, FilterValue val) {\n+        buf.append(\"XMLEXISTS('\");\n+        buf.append(\"$\").append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\"/*[\");\n+        val.appendTo(buf);        \n+    }\n+    \n+    /**\n+     * add CAST for a scalar function where operand is a param\n+     * \n+     * @param func original string\n+     * @param target substring to look for\n+     * @param asString \n+     * @return updated string (func)\n+     */\n+    private String addCastAsString(String func, String target, \n+            String asString) {\n+        String fstring = func;\n+        if (func.indexOf(target) != -1)\n+            fstring = Strings.replace(\n+                func, target, \"CAST(\" + target + asString + \")\");\n+        return fstring;\n+    }\n+\n+    /**\n+     * add CAST for a function operator where operand is a param\n+     * \n+     * @param func function name\n+     * @param val type\n+     * @return updated string (func)\n+     */\n+    public String addCastAsType(String func, Val val) {\n+        String fstring = null;\n+        String type = getTypeName(getJDBCType(JavaTypes.getTypeCode(val\n+            .getType()), false));\n+        fstring = \"CAST(? AS \" + type + \")\";\n+        return fstring;\n+    }\n+\n+    /**\n+     * Return the correct CAST function syntax\n+     * \n+     * @param val operand of cast\n+     * @param func original string\n+     * @return a String with the correct CAST function syntax\n+     */\n+    public String getCastFunction(Val val, String func) {\n+        if (val instanceof Lit || val instanceof Param)\n+            if (func.indexOf(\"VARCHAR\") == -1)\n+                func = addCastAsString(func, \"{0}\", \" AS VARCHAR(1000)\");\n+        return func;\n+    }\n+\n+    /**\n+     * Return the correct CAST function syntax\n+     * \n+     * @param val operand of cast\n+     * @param func original string\n+     * @param col database column\n+     * @return a String with the correct CAST function syntax\n+     */\n+    public String getCastFunction(Val val, String func, Column col) {\n+        boolean doCast = false;\n+        if (val instanceof Lit || val instanceof Param) {\n+            doCast = true;\n+        }\n+        // cast anything not already a VARCHAR to VARCHAR\n+        if (col.getType() != Types.VARCHAR) {\n+            doCast = true;\n+        }\n+        if (doCast == true) {\n+            if (func.indexOf(\"VARCHAR\") == -1) {\n+                func = addCastAsString(func, \"{0}\", \" AS VARCHAR(1000)\");\n+            }\n+        }\n+        return func;\n+    }\n+\n+    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n+            FilterValue start) {\n+        if (find.getValue() != null) { // non constants\n+            buf.append(\"(LOCATE(CAST((\");\n+            find.appendTo(buf);\n+            buf.append(\") AS VARCHAR(1000)), \");\n+        } else {\n+            // this is a constant\n+            buf.append(\"(LOCATE(\");\n+            find.appendTo(buf);\n+            buf.append(\", \");\n+        }\n+        if (str.getValue() != null) {\n+            buf.append(\"CAST((\");\n+            str.appendTo(buf);\n+            buf.append(\") AS VARCHAR(1000))\");\n+        } else {\n+            str.appendTo(buf);\n+        }\n+        if (start != null) {\n+            if (start.getValue() == null) {\n+                buf.append(\", CAST((\");\n+                start.appendTo(buf);\n+                buf.append(\") AS INTEGER) + 1\");\n+            } else {\n+                buf.append(\", \");\n+                start.appendTo(buf);\n+            }\n+        }\n+        buf.append(\") - 1)\");\n+    }\n+\n+    /** \n+     * Cast the specified value to the specified type.\n+     *\n+     * @param buf the buffer to append the cast to\n+     * @param val the value to cast\n+     * @param type the type of the case, e.g. {@link Types#NUMERIC}\n+     */\n+    public void appendCast(SQLBuffer buf, FilterValue val, int type) {\n+\n+        // Convert the cast function: \"CAST({0} AS {1})\"\n+        int firstParam = castFunction.indexOf(\"{0}\");\n+        String pre = castFunction.substring(0, firstParam); // \"CAST(\"\n+        String mid = castFunction.substring(firstParam + 3);\n+        int secondParam = mid.indexOf(\"{1}\");\n+        String post;\n+        if (secondParam > -1) {\n+            post = mid.substring(secondParam + 3); // \")\"\n+            mid = mid.substring(0, secondParam); // \" AS \"\n+        } else\n+            post = \"\";\n+\n+        // No need to add CAST if the value is a constant\n+        if (val instanceof Lit || val instanceof Param) {\n+            buf.append(pre);\n+            val.appendTo(buf);\n+            buf.append(mid);\n+            buf.append(getTypeName(type));\n+            appendLength(buf, type);\n+            buf.append(post);\n+        } else {\n+            val.appendTo(buf);\n+            String sqlString = buf.getSQL(false);\n+            if (sqlString.endsWith(\"?\")) {\n+                // case \"(?\" - convert to \"CAST(? AS type\"\n+                String typeName = getTypeName(type);\n+                if (String.class.equals(val.getType()))\n+                    typeName = typeName + \"(\" + characterColumnSize + \")\";\n+                String str = \"CAST(? AS \" + typeName + \")\";\n+                buf.replaceSqlString(sqlString.length() - 1,\n+                        sqlString.length(), str);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Create an index if necessary for some database tables\n+     */\n+    public void createIndexIfNecessary(Schema schema, String table,\n+            Column pkColumn) {\n+        if (isDB2ZOSV8xOrLater()) {\n+            // build the index for the sequence tables\n+            // the index name will the fully qualified table name + _IDX\n+            Table tab = schema.getTable(table);\n+            Index idx = tab.addIndex(tab.getFullName() + \"_IDX\");\n+            idx.setUnique(true);\n+            idx.addColumn(pkColumn);\n+        }\n+    }\n+    \n+    String nullSafe(String s) {\n+    \treturn s == null ? \"\" : s;\n+    }\n+}"},{"sha":"447d7622c824d92a1d09204c97dccaa62b389318","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","status":"modified","additions":70,"deletions":14,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -143,7 +143,7 @@\n     private static final String ZERO_TIMESTAMP_STR =\n         \"'\" + new Timestamp(0) + \"'\";\n \n-    private static final Localizer _loc = Localizer.forPackage\n+    protected static final Localizer _loc = Localizer.forPackage\n         (DBDictionary.class);\n \n     // schema data\n@@ -158,7 +158,6 @@\n     public int maxIndexNameLength = 128;\n     public int maxIndexesPerTable = Integer.MAX_VALUE;\n     public boolean supportsForeignKeys = true;\n-    public boolean supportsTimestampNanos = true;\n     public boolean supportsUniqueConstraints = true;\n     public boolean supportsDeferredConstraints = true;\n     public boolean supportsRestrictDeleteAction = true;\n@@ -208,11 +207,18 @@\n     public boolean requiresAliasForSubselect = false;\n     public boolean allowsAliasInBulkClause = true;\n     public boolean supportsMultipleNontransactionalResultSets = true;\n+    public boolean requiresSearchStringEscapeForLike = true;\n     public String searchStringEscape = \"\\\\\";\n     public boolean requiresCastForMathFunctions = false;\n     public boolean requiresCastForComparisons = false;\n     public boolean supportsModOperator = false;\n     public boolean supportsXMLColumn = false;\n+    public boolean supportsCaseConversionForLob = false;\n+\n+    /**\n+     * Some Databases append whitespace after the schema name\n+     */\n+    public boolean trimSchemaName = false;\n \n     // functions\n     public String castFunction = \"CAST({0} AS {1})\";\n@@ -303,11 +309,24 @@\n     protected JDBCConfiguration conf = null;\n     protected Log log = null;\n     protected boolean connected = false;\n+    protected boolean isJDBC3 = false;\n     protected final Set reservedWordSet = new HashSet();\n     protected final Set systemSchemaSet = new HashSet();\n     protected final Set systemTableSet = new HashSet();\n     protected final Set fixedSizeTypeNameSet = new HashSet();\n-\n+    \n+    /**\n+     * Some JDBC drivers - ie DB2 type 2 on Z/OS throw exceptions on\n+     * setQueryTimeout when provided specific input values.\n+     * To remain consistent with earlier versions of the driver we should ignore\n+     * the exception.\n+     * \n+     * This variable will be removed in future releases when we can handle the\n+     * exception properly.\n+     * @deprecated\n+     */ \n+    public boolean ignoreSQLExceptionOnSetQueryTimeout = false; \n+    \n     /**\n      * If a native query begins with any of the values found here then it will\n      * be treated as a select statement.  \n@@ -342,15 +361,30 @@ public DBDictionary() {\n      */\n     public void connectedConfiguration(Connection conn)\n         throws SQLException {\n-        if (!connected) {\n+        DatabaseMetaData metaData = null;\n+        try {\n+            metaData = conn.getMetaData();\n+            // JDBC3-only method, so it might throw a\n+            // AbstractMethodError\n             try {\n-                if (log.isTraceEnabled())\n-                    log.trace(DBDictionaryFactory.toString\n-                        (conn.getMetaData()));\n-            } catch (Exception e) {\n-                log.trace(e.toString(), e);\n+                isJDBC3 = metaData.getJDBCMajorVersion() >= 3;\n+            } catch (Throwable t) {\n+                // ignore if not JDBC3\n             }\n+        } catch (Exception e) {\n+            if (log.isTraceEnabled())\n+                log.trace(e.toString(), e);\n+        }\n+        \n+        if (log.isTraceEnabled()) {\n+            log.trace(DBDictionaryFactory.toString(metaData));\n+            if (isJDBC3)\n+                log.trace(_loc.get(\"connection-defaults\", new Object[]{\n+                        new Boolean(conn.getAutoCommit()), \n+                        new Integer(conn.getHoldability()),\n+                        new Integer(conn.getTransactionIsolation())}));\n         }\n+        \n         connected = true;\n     }\n \n@@ -1063,10 +1097,7 @@ public void setTimestamp(PreparedStatement stmnt, int idx,\n             nanos = 0;\n         }\n \n-        if (supportsTimestampNanos)\n-            val.setNanos(nanos);\n-        else\n-            val.setNanos(0);\n+        val.setNanos(nanos);\n \n         if (cal == null)\n             stmnt.setTimestamp(idx, val);\n@@ -3995,7 +4026,20 @@ public String getVersionColumn(Column column, String tableAlias) {\n     public String getCastFunction(Val val, String func) {\n         return func;\n     }\n-    \n+\n+    /**\n+     * Return the correct CAST function syntax.  This should be overriden by subclasses\n+     * that need access to the Column information.\n+     * \n+     * @param val operand of cast\n+     * @param func original string\n+     * @param col database column\n+     * @return a String with the correct CAST function syntax\n+     */\n+    public String getCastFunction(Val val, String func, Column col) {\n+        return getCastFunction (val, func);\n+    }\n+\n     /**\n      * Create an index if necessary for some database tables\n      */\n@@ -4023,4 +4067,16 @@ public boolean isSelect(String sql) {\n         }\n         return false;\n     }\n+\n+    public boolean needsToCreateIndex(Index idx, Table table) {\n+        return true;\n+    }\n+\n+    public boolean getTrimSchemaName() {\n+        return trimSchemaName;\n+    }\n+\n+    public void setTrimSchemaName(boolean trimSchemaName) {\n+        this.trimSchemaName = trimSchemaName;\n+    }\n }"},{"sha":"bfc1418b8e3c4db3c3c127595faafc3ad83c4fc8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -40,6 +40,8 @@ public DerbyDictionary() {\n         validationSQL = \"VALUES(1)\";\n         stringLengthFunction = \"LENGTH({0})\";\n         substringFunctionName = \"SUBSTR\";\n+        toUpperCaseFunction = \"UPPER(CAST({0} AS VARCHAR(1000)))\";\n+        toLowerCaseFunction = \"LOWER(CAST({0} AS VARCHAR(1000)))\";\n \n         maxConstraintNameLength = 18;\n         maxIndexNameLength = 18;"},{"sha":"573da76a596087e0bc7ed4f1f775b196bd139644","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java","status":"modified","additions":43,"deletions":13,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -28,12 +28,14 @@\n import java.util.Arrays;\n import java.util.Collection;\n \n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n import org.apache.openjpa.jdbc.schema.Index;\n import org.apache.openjpa.jdbc.schema.PrimaryKey;\n import org.apache.openjpa.jdbc.schema.Table;\n import org.apache.openjpa.lib.util.ReferenceHashSet;\n+import org.apache.openjpa.util.UnsupportedException;\n \n /**\n  * Dictionary for Informix database. Notable features:\n@@ -91,14 +93,6 @@ public InformixDictionary() {\n         supportsDeferredConstraints = false;\n         constraintNameMode = CONS_NAME_AFTER;\n \n-        maxTableNameLength = 18;\n-        maxColumnNameLength = 18;\n-        maxIndexNameLength = 18;\n-        maxConstraintNameLength = 18;\n-\n-        // Informix uses a non-standard \":\" to separate schema and table names\n-        catalogSeparator = \":\";\n-\n         // informix supports \"CLOB\" type, but any attempt to insert\n         // into them raises: \"java.sql.SQLException: Can't convert fromnull\"\n         useGetStringForClobs = true;\n@@ -111,7 +105,8 @@ public InformixDictionary() {\n         blobTypeName = \"BYTE\";\n         doubleTypeName = \"NUMERIC(32,20)\";\n         dateTypeName = \"DATE\";\n-        timestampTypeName = \"DATE\";\n+        timeTypeName = \"DATETIME HOUR TO SECOND\";\n+        timestampTypeName = \"DATETIME YEAR TO FRACTION(3)\";\n         doubleTypeName = \"NUMERIC(32,20)\";\n         floatTypeName = \"REAL\";\n         bigintTypeName = \"NUMERIC(32,0)\";\n@@ -122,7 +117,6 @@ public InformixDictionary() {\n         }));\n \n         supportsQueryTimeout = false;\n-        supportsMultipleNontransactionalResultSets = false;\n         supportsLockingWithDistinctClause = false;\n         supportsLockingWithMultipleTables = false;\n         supportsLockingWithOrderClause = false;\n@@ -134,8 +128,22 @@ public InformixDictionary() {\n \n         // Informix doesn't support aliases in deletes if the table has an index\n         allowsAliasInBulkClause = false;\n-        \n-        supportsSubselect = false;\n+\n+        // Informix doesn't understand \"X CROSS JOIN Y\", but it does understand\n+        // the equivalent \"X JOIN Y ON 1 = 1\"\n+        crossJoinClause = \"JOIN\";\n+        requiresConditionForCrossJoin = true;\n+\n+        concatenateFunction = \"CONCAT({0},{1})\";\n+        nextSequenceQuery = \"SELECT {0}.NEXTVAL FROM SYSTABLES WHERE TABID=1\";\n+        supportsCorrelatedSubselect = false;\n+        swapSchemaAndCatalog = false;\n+\n+        // Informix does not support foreign key delete action NULL or DEFAULT\n+        supportsNullDeleteAction = false;\n+        supportsDefaultDeleteAction = false;\n+\n+        trimSchemaName = true;\n     }\n \n     public void connectedConfiguration(Connection conn)\n@@ -148,6 +156,14 @@ public void connectedConfiguration(Connection conn)\n             else\n                 driverVendor = VENDOR_OTHER;\n         }\n+        if (isJDBC3) {\n+            conn.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n+            if (log.isTraceEnabled())\n+                log.trace(_loc.get(\"connection-defaults\", new Object[]{\n+                        new Boolean(conn.getAutoCommit()), \n+                        new Integer(conn.getHoldability()),\n+                        new Integer(conn.getTransactionIsolation())}));\n+        }\n     }\n \n     public Column[] getColumns(DatabaseMetaData meta, String catalog,\n@@ -192,7 +208,7 @@ public void setBoolean(PreparedStatement stmnt, int idx, boolean val,\n         throws SQLException {\n         // informix actually requires that a boolean be set: it cannot\n         // handle a numeric argument\n-        stmnt.setBoolean(idx, val);\n+        stmnt.setString(idx, val ? \"t\" : \"f\");\n     }\n \n     public String[] getCreateTableSQL(Table table) {\n@@ -258,4 +274,18 @@ public Connection decorate(Connection conn)\n             }\n         return conn;\n     }\n+\n+    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n+            FilterValue start) {\n+        throw new UnsupportedException();\n+    }\n+\n+    public boolean needsToCreateIndex(Index idx, Table table) {\n+       // Informix will automatically create a unique index for the\n+       // primary key, so don't create another index again\n+       PrimaryKey pk = table.getPrimaryKey();\n+       if (pk != null && idx.columnsMatch(pk.getColumns()))\n+           return false;\n+       return true;\n+    }\n }"},{"sha":"0da1e5fb8aebbda5e97e4776be1a25ce7ea420a3","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -161,6 +161,7 @@ public OracleDictionary() {\n         }));\n         \n         selectWordSet.add(\"WITH\");\n+        requiresSearchStringEscapeForLike = false;\n     }\n \n     public void endConfiguration() {"},{"sha":"7f9a4bd4ec80d4b4c7340139c243d5540900acac","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","status":"modified","additions":55,"deletions":31,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -64,49 +64,73 @@ public SQLServerDictionary() {\n     public void connectedConfiguration(Connection conn)\n         throws SQLException {\n         super.connectedConfiguration(conn);\n-\n+        boolean requiresWarnings = true;\n         DatabaseMetaData meta = conn.getMetaData();\n         String driverName = meta.getDriverName();\n         String url = meta.getURL();\n         if (driverVendor == null) {\n-            if (\"NetDirect JSQLConnect\".equals(driverName))\n-                driverVendor = VENDOR_NETDIRECT;\n-            else if (driverName != null && driverName.startsWith(\"jTDS\"))\n-                driverVendor = VENDOR_JTDS;\n-            else if (\"SQLServer\".equals(driverName)) {\n-                if (url != null && url.startsWith(\"jdbc:microsoft:sqlserver:\"))\n-                    driverVendor = VENDOR_MICROSOFT;\n-                else if (url != null\n-                    && url.startsWith(\"jdbc:datadirect:sqlserver:\"))\n-                    driverVendor = VENDOR_DATADIRECT;\n-                else\n-                    driverVendor = VENDOR_OTHER;\n-            } else\n+            if (driverName != null) {\n+                if (driverName.startsWith(\"Microsoft SQL Server\")) {\n+                    // v1.1, 1.2 or 2.0 driver\n+                    driverVendor = VENDOR_MICROSOFT;                \n+                    // serverMajorVersion of 8==2000, 9==2005, 10==2008\n+                    if (meta.getDatabaseMajorVersion() >= 9)\n+                        supportsXMLColumn = true;\n+                    if (meta.getDriverMajorVersion() >= 2) {\n+                        // see http://blogs.msdn.com/jdbcteam/archive/2007/05/\\\n+                        // 02/what-is-adaptive-response-buffering-and-why-\\\n+                        // should-i-use-it.aspx\n+                        // 2.0 driver connectURL automatically includes \n+                        // responseBuffering=adaptive\n+                        // and disableStatementPooling=true\n+                        requiresWarnings = false;\n+                    }\n+                } else {\n+                    if (\"NetDirect JSQLConnect\".equals(driverName))\n+                        driverVendor = VENDOR_NETDIRECT;\n+                    else if (driverName.startsWith(\"jTDS\"))\n+                        driverVendor = VENDOR_JTDS;\n+                    else if (\"SQLServer\".equals(driverName)) {\n+                        if (url != null &&\n+                            url.startsWith(\"jdbc:microsoft:sqlserver:\"))\n+                            driverVendor = VENDOR_MICROSOFT;\n+                        else if (url != null\n+                            && url.startsWith(\"jdbc:datadirect:sqlserver:\"))\n+                            driverVendor = VENDOR_DATADIRECT;\n+                        else\n+                            driverVendor = VENDOR_OTHER;\n+                    }\n+                    // old way of determining xml support\n+                    if (driverName.indexOf(platform) != -1) {\n+                        String versionString = driverName.\n+                            substring(platform.length() + 1);\n+                        if (versionString.indexOf(\" \") != -1)\n+                            versionString = versionString.substring(0,\n+                                versionString.indexOf(\" \"));\n+                        int version = Integer.parseInt(versionString);\n+                        if (version >= 2005)\n+                            supportsXMLColumn = true;\n+                    }\n+                }\n+            } else {\n                 driverVendor = VENDOR_OTHER;\n-            if (driverName.indexOf(platform) != -1) {\n-                String versionString = driverName.\n-                    substring(platform.length() + 1);\n-                if (versionString.indexOf(\" \") != -1)\n-                    versionString = versionString.substring(0,\n-                        versionString.indexOf(\" \"));\n-                int version = Integer.parseInt(versionString);\n-                if (version >= 2005)\n-                    supportsXMLColumn = true;\n             }\n         }\n \n-        // warn about using cursors\n-        if ((VENDOR_MICROSOFT.equalsIgnoreCase(driverVendor)\n+        // warn about not using cursors for pre-2.0 MS driver\n+        // as connectURL includes selectMethod=direct\n+        if (((VENDOR_MICROSOFT.equalsIgnoreCase(driverVendor)\n+            && requiresWarnings) \n             || VENDOR_DATADIRECT.equalsIgnoreCase(driverVendor))\n-            && url.toLowerCase().indexOf(\"selectmethod=cursor\") == -1)\n+            && (url.toLowerCase().indexOf(\"selectmethod=cursor\") == -1))\n             log.warn(_loc.get(\"sqlserver-cursor\", url));\n \n-        // warn about prepared statement caching if using ms driver\n+        // warn about prepared statement caching if using pre-2.0 MS drivers\n+        // as connectURL includes responseBuffering=full\n         String props = conf.getConnectionFactoryProperties();\n-        if (props == null)\n-            props = \"\";\n-        if (VENDOR_MICROSOFT.equalsIgnoreCase(driverVendor)\n-            && props.toLowerCase().indexOf(\"maxcachedstatements=0\") == -1)\n+        if ((props != null) && \n+            VENDOR_MICROSOFT.equalsIgnoreCase(driverVendor) && requiresWarnings\n+            && (props.toLowerCase().indexOf(\"maxcachedstatements=0\") == -1))\n             log.warn(_loc.get(\"sqlserver-cachedstmnts\"));\n     }\n "},{"sha":"e745c4b8c3e8c5412f91486af4f59a0c158cc456","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","status":"modified","additions":57,"deletions":34,"changes":91,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -360,14 +360,27 @@ protected Result execute(StoreContext ctx, JDBCStore store,\n             // the configured query timeout, use the lock timeout\n             if (forUpdate && _dict.supportsQueryTimeout && fetch != null \n                 && fetch.getLockTimeout() > stmnt.getQueryTimeout() * 1000) {\n+                Log log = _conf.getLog(JDBCConfiguration.LOG_JDBC);\n                 int timeout = fetch.getLockTimeout();\n                 if (timeout < 1000) {\n                     timeout = 1000; \n-                    Log log = _conf.getLog(JDBCConfiguration.LOG_JDBC);\n                     if (log.isWarnEnabled())\n                         log.warn(_loc.get(\"millis-query-timeout\"));\n                 }\n-                stmnt.setQueryTimeout(fetch.getLockTimeout() / 1000);\n+                try { \n+                    stmnt.setQueryTimeout(fetch.getLockTimeout() / 1000);\n+                }\n+                catch(SQLException e) { \n+                    if(_dict.ignoreSQLExceptionOnSetQueryTimeout) { \n+                        if (log.isTraceEnabled()) {\n+                            log.trace(_loc.get(\"error-setting-query-timeout\",\n+                                new Integer(timeout), e.getMessage()), e);\n+                        }   \n+                    }\n+                    else { \n+                        throw e;\n+                    }\n+                }\n             }\n             rs = stmnt.executeQuery();\n         } catch (SQLException se) {\n@@ -474,45 +487,53 @@ public void setParent(Select parent, String path) {\n                 _joinSyntax = _parent._joinSyntax;\n         }\n         \n-        if (_parent.getAliases() == null || _subPath == null)\n+        if (_parent.getAliases() == null || _subPath == null) {\n             return;\n-        \n-        // resolve aliases for subselect from parent\n-        Set entries = _parent.getAliases().entrySet();\n-        Iterator it = entries.iterator();\n-        while (it.hasNext()) {\n-        \tMap.Entry entry = (Map.Entry) it.next();\n-            Object key = entry.getKey();\n-            Integer alias = (Integer) entry.getValue();\n-            if (key.toString().indexOf(_subPath) != -1 ||\n-                _parent.findTableAlias(alias) == false) {\n-                if (_aliases == null)\n-                    _aliases = new HashMap();\n-                _aliases.put(key, alias);\n-\n-                Object tableString = _parent.getTables().get(alias);\n-                if (_tables == null)\n-                    _tables = new TreeMap();\n-                _tables.put(alias, tableString);\n-                \n-                _removedAliasFromParent.set(alias.intValue());\n-            }\n         }\n         \n-        if (_aliases != null) {\n-            // aliases moved into subselect should be removed from parent\n-            entries = _aliases.entrySet();\n-            it = entries.iterator();\n+        if (_parent._aliases.size() <= 1) {\n+            return;\n+        }\n+\n+        // Do not remove aliases for databases that use SYNTAX_DATABASE (oracle)\n+        if(_parent._joinSyntax != JoinSyntaxes.SYNTAX_DATABASE) {\n+            // resolve aliases for subselect from parent\n+            Set entries = _parent.getAliases().entrySet();\n+            Iterator it = entries.iterator();\n             while (it.hasNext()) {\n-            \tMap.Entry entry = (Map.Entry) it.next();\n+                Map.Entry entry = (Map.Entry) it.next();\n                 Object key = entry.getKey();\n                 Integer alias = (Integer) entry.getValue();\n                 if (key.toString().indexOf(_subPath) != -1 ||\n-                    _parent.findTableAlias(alias) == false) {\n-                    _parent.removeAlias(key);\n+                        _parent.findTableAlias(alias) == false) {\n+                    if (_aliases == null)\n+                        _aliases = new HashMap();\n+                    _aliases.put(key, alias);\n \n                     Object tableString = _parent.getTables().get(alias);\n-                    _parent.removeTable(alias);\n+                    if (_tables == null)\n+                        _tables = new TreeMap();\n+                    _tables.put(alias, tableString);\n+\n+                    _removedAliasFromParent.set(alias.intValue());\n+                }\n+            }\n+\n+            if (_aliases != null) {\n+                // aliases moved into subselect should be removed from parent\n+                entries = _aliases.entrySet();\n+                it = entries.iterator();\n+                while (it.hasNext()) {\n+                    Map.Entry entry = (Map.Entry) it.next();\n+                    Object key = entry.getKey();\n+                    Integer alias = (Integer) entry.getValue();\n+                    if (key.toString().indexOf(_subPath) != -1 ||\n+                            _parent.findTableAlias(alias) == false) {\n+                        _parent.removeAlias(key);\n+\n+                        Object tableString = _parent.getTables().get(alias);\n+                        _parent.removeTable(alias);\n+                    }\n                 }\n             }\n         }\n@@ -522,8 +543,10 @@ private boolean findTableAlias(Integer alias) {\n         // if alias is defined and referenced, return true.\n         String value = \"t\" + alias.toString() + \".\";\n         if (_tableAliases != null)\n-            return _tableAliases.containsValue(value) &&\n-               _tables.containsKey(alias);\n+            if (_tableAliases.containsValue(value))\n+               return _tables.containsKey(alias);\n+           else\n+               return _joins != null;\n         else\n             return true;\n     }"},{"sha":"ad5bc94ccd137ee2bfd2a3224b95a5cb623f72ab","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -110,3 +110,8 @@ no-nullable-fk: No nullable foreign key found to resolve circular flush\\n\\\n \tis nullable (optional).\n graph-not-cycle-free: A circular flush dependency has been found after all \\\n     circular dependencies should have been resolved.\n+error-setting-query-timeout: A SQLException was thrown when trying to set the \\\n+\tqueryTimeout to {0}. We believe the exception is not fatal and will \\\n+    continue processing. If this is a benign error you may disable it entirely \\\n+\tby setting the supportsQueryTimeout attribute on the DBDictionary to false.\\\n+\tThe exception thrown was {1}.\n\\ No newline at end of file"},{"sha":"cab55e1bef5782aabf0393cddd2d999ea85c868b","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/localizer.properties","status":"modified","additions":153,"deletions":153,"changes":306,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/localizer.properties?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,153 +1,153 @@\n-# Licensed to the Apache Software Foundation (ASF) under one\r\n-# or more contributor license agreements.  See the NOTICE file\r\n-# distributed with this work for additional information\r\n-# regarding copyright ownership.  The ASF licenses this file\r\n-# to you under the Apache License, Version 2.0 (the\r\n-# \"License\"); you may not use this file except in compliance\r\n-# with the License.  You may obtain a copy of the License at\r\n-#\r\n-# http://www.apache.org/licenses/LICENSE-2.0\r\n-#\r\n-# Unless required by applicable law or agreed to in writing,\r\n-# software distributed under the License is distributed on an\r\n-# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n-# KIND, either express or implied.  See the License for the\r\n-# specific language governing permissions and limitations\r\n-# under the License.  \r\n-\r\n-bad-join: The following error was detected when creating a foreign key: \\\r\n-\t\"{0}\".  The foreign key is being ignored.\r\n-no-driver: A JDBC Driver or DataSource class name must be specified in the \\\r\n-\tConnectionDriverName property.\r\n-bad-driver: The specified driver \"{0}\" is neither a java.sql.Driver \\\r\n-\tnor a javax.sql.DataSource class name.\r\n-bad-sch-ref: The schema information table could not be created: {0}\r\n-bad-sch-read: Attempt to read the schema information table failed; continuing \\\r\n-\ton the assumption that the table has not been created yet, and there is \\\r\n-\tno data to read: {0}\r\n-bad-sch-write-1: First attempt to write to the schema information table \\\r\n-\tfailed; will attempt to create the table in case it has been dropped \\\r\n-\tbefore re-trying: {0}\r\n-bad-sch-write-2: Attempt to write the schema information table for the second \\\r\n-\ttime failed.  See previous log messages for possible reasons.\r\n-bad-seq-num: Bad numeric constant for attribute in sequence \"{0}\".\r\n-pk-resolve: The column \"{0}\" specified as a primary key for table \"{1}\" \\\r\n-\tdoes not exist in that table.\r\n-index-info: Unable to get index information for table \"{0}\": \"{1}\"\r\n-index-resolve: The column \"{1}\" specified as part of index \"{0}\" on table \\\r\n-\t\"{2}\" does not exist in that table.\r\n-unq-resolve: The column \"{1}\" specified as part of unique constraint \"{0}\" on \\\r\n-\ttable \"{2}\" does not exist in that table.\r\n-fk-totable: The foreign table \"{1}\" specified in foreign key \"{0}\" on \\\r\n-\ttable \"{2}\" does not exist or does not have a primary key.\r\n-fk-nocol: The column \"{1}\" specified by foreign key \"{0}\" on table \"{2}\" \\\r\n-\tdoes not exist in that table.\r\n-fk-nopkcol: The column \"{1}\" of table \"{2}\" joined to by foreign key \"{0}\" \\\r\n-\ton table \"{3}\" does not exist or is not a primary key column.\r\n-bad-name: You must supply a valid name for this schema component.\r\n-dup-col-name: The name \"{0}\" is already taken by a column in this table.\r\n-table-mismatch: You are attempting to add a column from table \"{0}\" to a \\\r\n-\tconstraint or index on table \"{1}\".\r\n-fk-mismatch: You are attempting to link to a primary key column in table \\\r\n-\t\"{0}\" in a foreign key that is already linked to primary key columns in \\\r\n-\ttable \"{1}\".\r\n-ser-schema: Writing schema \"{0}\".\r\n-tool-norepos: You cannot perform this action until you set the schema group \\\r\n-\tto act on.\r\n-tool-running: Schema tool will run on schema file \"{0}\".\r\n-tool-import-store: Storing imported schema data in schema factory.\r\n-tool-export-gen: Gathering schema information to export; this process \\\r\n-\tmay take some time.  Enable the org.apache.openjpa.jdbc.Schema logging category to see \\\r\n-\tmessages about the collection of schema data.\r\n-tool-action: Schema tool running action \"{0}\".  This process may take some \\\r\n-\ttime.  Enable the org.apache.openjpa.jdbc.Schema logging category to see messages about \\\r\n-\tthe collection of schema data, and the org.apache.openjpa.jdbc.SQL category to see \\\r\n-\tgenerated SQL commands.\r\n-tool-record: Recording schema changes.\r\n-tool-export-write: Writing schema data to XML.\r\n-tool-usage: Usage: java org.apache.openjpa.jdbc.schema.SchemaTool\\n\\\r\n-\t\\t[-properties/-p <properties file or resource>]\\n\\\r\n-\t\\t[-<property name> <property value>]*\\n\\\r\n-\t\\t[-file/-f <stdout | output file or resource>]\\n\\\r\n-\t\\t[-ignoreErrors/-i <true/t | false/f>]\\n\\\r\n-\t\\t[-dropTables/-dt <true/t | false/f>]\\n\\\r\n-\t\\t[-openjpaTables/-ot <true/t | false/f>]\\n\\\r\n-\t\\t[-dropSequences/-dsq <true/t | false/f>]\\n\\\r\n-\t\\t[-sequences/-sq <true/t | false/f>]\\n\\\r\n-\t\\t[-primaryKeys/-pk <true/t | false/f>]\\n\\\r\n-\t\\t[-foreignKeys/-fk <true/t | false/f>]\\n\\\r\n-\t\\t[-indexes/-ix <true/t | false/f>]\\n\\\r\n-\t\\t[-record/-r <true/t | false/f>]\\n\\\r\n-\t\\t[-action/-a <add | retain | drop | refresh | build | reflect\\n\\\r\n-\t\\t\\t| createDB | dropDB | import | export | deleteTableContents>]\\n\\\r\n-\t\\t<.schema file or resource>*\r\n-sch-reflect: Reflecting on schemas \"{0}\".  This process may take some time.  \\\r\n-\tEnable the org.apache.openjpa.jdbc.Schema logging category to see messages about the \\\r\n-\tcollection of schema data.\r\n-sch-reflect-write: Writing XML representation of schema.\r\n-drop-index: The index \"{0}\" was not dropped from table \"{1}\".\r\n-drop-fk: The foreign key \"{0}\" was not dropped from table \"{1}\".\r\n-drop-pk: The primary key \"{0}\" was not dropped from table \"{1}\".\r\n-drop-col: The column \"{0}\" was not dropped from table \"{1}\".\r\n-drop-table: The table \"{0}\" was not dropped.\r\n-drop-seq: The sequence \"{0}\" was not dropped.\r\n-add-col: The column \"{0}\" was not added to table \"{1}\".\r\n-add-index: The index \"{0}\" was not created on table \"{1}\".\r\n-too-many-indexes: The index \"{0}\" was not created on table \"{1}\", since it \\\r\n-\twould go beyond the maximum index limit of {2}.\r\n-add-pk: The primary key \"{0}\" was not added to table \"{1}\".\r\n-add-fk: The foreign key \"{0}\" was not added to table \"{1}\".\r\n-add-table: The table \"{0}\" was not created.\r\n-add-seq: The sequence \"{0}\" was not added to the database.\r\n-bad-col: Existing column \"{0}\" on table \"{1}\" is incompatible with the \\\r\n-\tsame column in the given schema definition. Existing column:\\n{2}\\\r\n-\tGiven column:\\n{3}\r\n-bad-pk: Existing primary key \"{0}\" on table \"{1}\" is incompatible with \\\r\n-\tthe same primary key in the given schema definition.\r\n-bad-index: Existing index \"{0}\" on table \"{1}\" is incompatible with the \\\r\n-\tsame index in the given schema definition.\r\n-bad-fk: Existing foreign key \"{0}\" on table \"{1}\" is incompatible with \\\r\n-\tthe same foreign key in the given schema definition.\r\n-bad-fk-action-hint: \"{1}\" is not a recognized foreign key action, though it \\\r\n-\tclosely resembles the standard action \"{2}\". Available actions are: {3}\r\n-bad-fk-action: \"{1}\" is not a recognized foreign key action.  Available \\\r\n-\tactions are: {2}\r\n-gen-pk: Found existing primary key \"{0}\" on table \"{1} ({2})\".\r\n-gen-index: Found existing index \"{0}\" on table \"{1} ({2})\".\r\n-gen-fk: Found existing foreign key \"{0}\" on table \"{1} ({2})\" linking to \\\r\n-\ttable \"{3} ({4})\".  Sequence: \"{5}\".\r\n-gen-nofktable: Table \"{0}\" has a foreign key to table \"{1}\" that has not been \\\r\n-\tgenerated.  You must run the schema generator on all inter-related tables \\\r\n-\tat once.\r\n-gen-tables: Reading table information for schema name \"{0}\", table name \"{1}\".\r\n-gen-pks: Reading primary keys for schema name \"{0}\", table name \"{1}\".\r\n-gen-indexes: Reading indexes for schema name \"{0}\", table name \"{1}\".\r\n-gen-fks: Reading foreign keys for schema name \"{0}\", table name \"{1}\".\r\n-col-table: Reading column information for table \"{0}\".\r\n-gen-column: Found existing column \"{0}\" on table \"{1}\".\r\n-gen-seqs: Reading sequence information for schema \"{0}\", sequence name \"{1}\".\r\n-no-idx-meta: Unable to get index metadata for table \"{0}\": {1}\r\n-make-sch-table: Creating table to hold schema information.\r\n-drop-sch-table: Dropping schema table.\r\n-sch-usage: Usage: java org.apache.openjpa.jdbc.schema.TableSchemaFactory\\n\\\r\n-\t\\t[-properties <properties file or resource>]\\n\\\r\n-\t\\t[-<property name> <property value>]\\n\\\r\n-\t\\t-action/-a <add | drop>\r\n-refresh-cancelled: Refresh operation cancelled.\r\n-generating-schemas: Reading schemas\r\n-generating-schema: Reading schema \"{0}\"\r\n-generating-all-primaries: Reading primary keys for schema \"{0}\"\r\n-generating-all-indexes: Reading indexes for schema \"{0}\"\r\n-generating-all-foreigns: Reading foreign keys for schema \"{0}\"\r\n-generating-columns: Reading columns for table \"{1}\"\r\n-generating-primary: Reading primary keys for table \"{1}\"\r\n-generating-indexes: Reading indexes for table \"{1}\"\r\n-generating-foreign: Reading foreign keys for table \"{1}\"\r\n-generating-sequences: Reading sequences for schema \"{0}\"\r\n-no-custom-ds: use a custom DataSource\r\n-delete-table-contents: An error occurred while attempting to delete all \\\r\n-    records from all mapped tables.\r\n-set-auto-commit: DataSource connection setAutoCommit to \"{0}\"\r\n-conn-failed: Failed to connect to DataSource. Verify Driver \"{0}\", URL \"{1}\" \\\r\n-\tand connection properties \"{2}\" are correct. See the nested exception for \\\r\n-\tfurther details.\r\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+# http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.  \n+\n+bad-join: The following error was detected when creating a foreign key: \\\n+\t\"{0}\".  The foreign key is being ignored.\n+no-driver: A JDBC Driver or DataSource class name must be specified in the \\\n+\tConnectionDriverName property.\n+bad-driver: The specified driver \"{0}\" is neither a java.sql.Driver \\\n+\tnor a javax.sql.DataSource class name.\n+bad-sch-ref: The schema information table could not be created: {0}\n+bad-sch-read: Attempt to read the schema information table failed; continuing \\\n+\ton the assumption that the table has not been created yet, and there is \\\n+\tno data to read: {0}\n+bad-sch-write-1: First attempt to write to the schema information table \\\n+\tfailed; will attempt to create the table in case it has been dropped \\\n+\tbefore re-trying: {0}\n+bad-sch-write-2: Attempt to write the schema information table for the second \\\n+\ttime failed.  See previous log messages for possible reasons.\n+bad-seq-num: Bad numeric constant for attribute in sequence \"{0}\".\n+pk-resolve: The column \"{0}\" specified as a primary key for table \"{1}\" \\\n+\tdoes not exist in that table.\n+index-info: Unable to get index information for table \"{0}\": \"{1}\"\n+index-resolve: The column \"{1}\" specified as part of index \"{0}\" on table \\\n+\t\"{2}\" does not exist in that table.\n+unq-resolve: The column \"{1}\" specified as part of unique constraint \"{0}\" on \\\n+\ttable \"{2}\" does not exist in that table.\n+fk-totable: The foreign table \"{1}\" specified in foreign key \"{0}\" on \\\n+\ttable \"{2}\" does not exist or does not have a primary key.\n+fk-nocol: The column \"{1}\" specified by foreign key \"{0}\" on table \"{2}\" \\\n+\tdoes not exist in that table.\n+fk-nopkcol: The column \"{1}\" of table \"{2}\" joined to by foreign key \"{0}\" \\\n+\ton table \"{3}\" does not exist or is not a primary key column.\n+bad-name: You must supply a valid name for this schema component.\n+dup-col-name: The name \"{0}\" is already taken by a column in this table.\n+table-mismatch: You are attempting to add a column from table \"{0}\" to a \\\n+\tconstraint or index on table \"{1}\".\n+fk-mismatch: You are attempting to link to a primary key column in table \\\n+\t\"{0}\" in a foreign key that is already linked to primary key columns in \\\n+\ttable \"{1}\".\n+ser-schema: Writing schema \"{0}\".\n+tool-norepos: You cannot perform this action until you set the schema group \\\n+\tto act on.\n+tool-running: Schema tool will run on schema file \"{0}\".\n+tool-import-store: Storing imported schema data in schema factory.\n+tool-export-gen: Gathering schema information to export; this process \\\n+\tmay take some time.  Enable the org.apache.openjpa.jdbc.Schema logging category to see \\\n+\tmessages about the collection of schema data.\n+tool-action: Schema tool running action \"{0}\".  This process may take some \\\n+\ttime.  Enable the org.apache.openjpa.jdbc.Schema logging category to see messages about \\\n+\tthe collection of schema data, and the org.apache.openjpa.jdbc.SQL category to see \\\n+\tgenerated SQL commands.\n+tool-record: Recording schema changes.\n+tool-export-write: Writing schema data to XML.\n+tool-usage: Usage: java org.apache.openjpa.jdbc.schema.SchemaTool\\n\\\n+\t\\t[-properties/-p <properties file or resource>]\\n\\\n+\t\\t[-<property name> <property value>]*\\n\\\n+\t\\t[-file/-f <stdout | output file or resource>]\\n\\\n+\t\\t[-ignoreErrors/-i <true/t | false/f>]\\n\\\n+\t\\t[-dropTables/-dt <true/t | false/f>]\\n\\\n+\t\\t[-openjpaTables/-ot <true/t | false/f>]\\n\\\n+\t\\t[-dropSequences/-dsq <true/t | false/f>]\\n\\\n+\t\\t[-sequences/-sq <true/t | false/f>]\\n\\\n+\t\\t[-primaryKeys/-pk <true/t | false/f>]\\n\\\n+\t\\t[-foreignKeys/-fk <true/t | false/f>]\\n\\\n+\t\\t[-indexes/-ix <true/t | false/f>]\\n\\\n+\t\\t[-record/-r <true/t | false/f>]\\n\\\n+\t\\t[-action/-a <add | retain | drop | refresh | build | reflect\\n\\\n+\t\\t\\t| createDB | dropDB | import | export | deleteTableContents>]\\n\\\n+\t\\t<.schema file or resource>*\n+sch-reflect: Reflecting on schemas \"{0}\".  This process may take some time.  \\\n+\tEnable the org.apache.openjpa.jdbc.Schema logging category to see messages about the \\\n+\tcollection of schema data.\n+sch-reflect-write: Writing XML representation of schema.\n+drop-index: The index \"{0}\" was not dropped from table \"{1}\".\n+drop-fk: The foreign key \"{0}\" was not dropped from table \"{1}\".\n+drop-pk: The primary key \"{0}\" was not dropped from table \"{1}\".\n+drop-col: The column \"{0}\" was not dropped from table \"{1}\".\n+drop-table: The table \"{0}\" was not dropped.\n+drop-seq: The sequence \"{0}\" was not dropped.\n+add-col: The column \"{0}\" was not added to table \"{1}\".\n+add-index: The index \"{0}\" was not created on table \"{1}\".\n+too-many-indexes: The index \"{0}\" was not created on table \"{1}\", since it \\\n+\twould go beyond the maximum index limit of {2}.\n+add-pk: The primary key \"{0}\" was not added to table \"{1}\".\n+add-fk: The foreign key \"{0}\" was not added to table \"{1}\".\n+add-table: The table \"{0}\" was not created.\n+add-seq: The sequence \"{0}\" was not added to the database.\n+bad-col: Existing column \"{0}\" on table \"{1}\" is incompatible with the \\\n+\tsame column in the given schema definition. Existing column:\\n{2}\\\n+\tGiven column:\\n{3}\n+bad-pk: Existing primary key \"{0}\" on table \"{1}\" is incompatible with \\\n+\tthe same primary key in the given schema definition.\n+bad-index: Existing index \"{0}\" on table \"{1}\" is incompatible with the \\\n+\tsame index in the given schema definition.\n+bad-fk: Existing foreign key \"{0}\" on table \"{1}\" is incompatible with \\\n+\tthe same foreign key in the given schema definition.\n+bad-fk-action-hint: \"{1}\" is not a recognized foreign key action, though it \\\n+\tclosely resembles the standard action \"{2}\". Available actions are: {3}\n+bad-fk-action: \"{1}\" is not a recognized foreign key action.  Available \\\n+\tactions are: {2}\n+gen-pk: Found existing primary key \"{0}\" on table \"{1} ({2})\".\n+gen-index: Found existing index \"{0}\" on table \"{1} ({2})\".\n+gen-fk: Found existing foreign key \"{0}\" on table \"{1} ({2})\" linking to \\\n+\ttable \"{3} ({4})\".  Sequence: \"{5}\".\n+gen-nofktable: Table \"{0}\" has a foreign key to table \"{1}\" that has not been \\\n+\tgenerated.  You must run the schema generator on all inter-related tables \\\n+\tat once.\n+gen-tables: Reading table information for schema name \"{0}\", table name \"{1}\".\n+gen-pks: Reading primary keys for schema name \"{0}\", table name \"{1}\".\n+gen-indexes: Reading indexes for schema name \"{0}\", table name \"{1}\".\n+gen-fks: Reading foreign keys for schema name \"{0}\", table name \"{1}\".\n+col-table: Reading column information for table \"{0}\".\n+gen-column: Found existing column \"{0}\" on table \"{1}\".\n+gen-seqs: Reading sequence information for schema \"{0}\", sequence name \"{1}\".\n+no-idx-meta: Unable to get index metadata for table \"{0}\": {1}\n+make-sch-table: Creating table to hold schema information.\n+drop-sch-table: Dropping schema table.\n+sch-usage: Usage: java org.apache.openjpa.jdbc.schema.TableSchemaFactory\\n\\\n+\t\\t[-properties <properties file or resource>]\\n\\\n+\t\\t[-<property name> <property value>]\\n\\\n+\t\\t-action/-a <add | drop>\n+refresh-cancelled: Refresh operation cancelled.\n+generating-schemas: Reading schemas\n+generating-schema: Reading schema \"{0}\"\n+generating-all-primaries: Reading primary keys for schema \"{0}\"\n+generating-all-indexes: Reading indexes for schema \"{0}\"\n+generating-all-foreigns: Reading foreign keys for schema \"{0}\"\n+generating-columns: Reading columns for table \"{1}\"\n+generating-primary: Reading primary keys for table \"{1}\"\n+generating-indexes: Reading indexes for table \"{1}\"\n+generating-foreign: Reading foreign keys for table \"{1}\"\n+generating-sequences: Reading sequences for schema \"{0}\"\n+no-custom-ds: use a custom DataSource\n+delete-table-contents: An error occurred while attempting to delete all \\\n+    records from all mapped tables.\n+set-auto-commit: DataSource connection setAutoCommit to \"{0}\"\n+conn-failed: Failed to connect to DataSource. Verify Driver \"{0}\", URL \"{1}\" \\\n+\tand connection properties \"{2}\" are correct. See the nested exception for \\\n+\tfurther details."},{"sha":"3c44f51b3c4e4637e818941600a01bafcb01a193","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","status":"modified","additions":7,"deletions":1,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -167,5 +167,11 @@ isolation-level-config-not-supported: This DBDictionary does not support \\\n     customization of isolation levels on a per-query basis. DBDictionary: {0}.\n millis-query-timeout: JDBC locking does not support millisecond-granularity \\\n     timeouts.  Use timeouts that are multiples of 1000 for even second values.\n-db-not-supported: The database product \"{0}\", version \"{1}\" is not officially supported.\n+db-not-supported: The database product \"{0}\", version \"{1}\" is not officially  \\\n+\tsupported.\n+error-setting-query-timeout: A SQLException was thrown when trying to set the \\\n+\tqueryTimeout to {0}. We believe the exception is not fatal and will \\\n+    continue processing. If this is a benign error you may disable it entirely \\\n+\tby setting the supportsQueryTimeout attribute on the DBDictionary to false.\\\n+\tThe exception thrown was {1}.\n     \n\\ No newline at end of file"},{"sha":"c3b158667048e27e18d5c6e9670d2ad78bcfa454","filename":"openjpa-kernel-5/pom.xml","status":"modified","additions":1,"deletions":13,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel-5/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel-5/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/pom.xml?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -31,7 +31,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-parent</artifactId>\n-        <version>1.0.3</version>\n+        <version>1.0.4</version>\n     </parent>\n     <dependencies>\n         <dependency>\n@@ -47,16 +47,4 @@\n             <scope>compile</scope>\n         </dependency>\n     </dependencies>\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-compiler-plugin</artifactId>\n-                <configuration>\n-                    <source>1.5</source>\n-                    <target>1.5</target>\n-                </configuration>\n-            </plugin>\n-        </plugins>\n-    </build>\n </project>"},{"sha":"66fa6057c6af1df883d1dd1b1114f7b6f974c7a4","filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","status":"modified","additions":151,"deletions":151,"changes":302,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,152 +1,152 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.lang.instrument.Instrumentation;\r\n-import java.lang.instrument.ClassFileTransformer;\r\n-import java.lang.instrument.ClassDefinition;\r\n-import java.lang.instrument.UnmodifiableClassException;\r\n-import java.lang.reflect.InvocationTargetException;\r\n-import java.lang.reflect.Method;\r\n-import java.security.ProtectionDomain;\r\n-import java.util.Map;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.ArrayList;\r\n-import java.io.IOException;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.util.JavaVersions;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.UserException;\r\n-\r\n-/**\r\n- * Redefines the method bodies of existing classes. Supports Java 5 VMs that\r\n- * have a javaagent installed on the command line as well as newer VMs without\r\n- * any javaagent flag.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class ClassRedefiner {\r\n-\r\n-    private static final Localizer _loc = \r\n-        Localizer.forPackage(ClassRedefiner.class);\r\n-\r\n-    private static Boolean _canRedefine = null;\r\n-\r\n-    /**\r\n-     * For each element in <code>classes</code>, this method will redefine\r\n-     * all the element's methods such that field accesses are intercepted\r\n-     * in-line. If {@link #canRedefineClasses()} returns <code>false</code>,\r\n-     * this method is a no-op.\r\n-     */\r\n-    public static void redefineClasses(OpenJPAConfiguration conf,\r\n-        final Map<Class,byte[]> classes) {\r\n-        if (classes == null || classes.size() == 0 || !canRedefineClasses())\r\n-            return;\r\n-\r\n-        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n-        Instrumentation inst = null;\r\n-        ClassFileTransformer t = null;\r\n-        try {\r\n-            inst = InstrumentationFactory.getInstrumentation();\r\n-\r\n-            Class[] array = classes.keySet().toArray(new Class[classes.size()]);\r\n-            if (JavaVersions.VERSION >= 6) {\r\n-                log.trace(_loc.get(\"retransform-types\", classes.keySet()));\r\n-\r\n-                t = new ClassFileTransformer() {\r\n-                    public byte[] transform(ClassLoader loader, String clsName,\r\n-                        Class<?> classBeingRedefined, ProtectionDomain pd,\r\n-                        byte[] classfileBuffer) {\r\n-                        return classes.get(classBeingRedefined);\r\n-                    }\r\n-                };\r\n-                \r\n-                // these are Java 6 methods, and we don't have a Java 6 build\r\n-                // module yet. The cost of reflection here is negligible\r\n-                // compared to the redefinition / enhancement costs in total,\r\n-                // so this should not be a big problem.\r\n-                Method meth = inst.getClass().getMethod(\"addTransformer\",\r\n-                    new Class[] { ClassFileTransformer.class, boolean.class });\r\n-                meth.invoke(inst, new Object[] { t, true });\r\n-                meth = inst.getClass().getMethod(\"retransformClasses\",\r\n-                    new Class[] { array.getClass() });\r\n-                meth.invoke(inst, new Object[] { array });\r\n-            } else {\r\n-                log.trace(_loc.get(\"redefine-types\", classes.keySet()));\r\n-                // in a Java 5 context, we can use class redefinition instead\r\n-                ClassDefinition[] defs = new ClassDefinition[array.length];\r\n-                for (int i = 0; i < defs.length; i++)\r\n-                    defs[i] = new ClassDefinition(array[i],\r\n-                        classes.get(array[i]));\r\n-                inst.redefineClasses(defs);\r\n-            }\r\n-        } catch (NoSuchMethodException e) {\r\n-            throw new InternalException(e);\r\n-        } catch (IllegalAccessException e) {\r\n-            throw new InternalException(e);\r\n-        } catch (InvocationTargetException e) {\r\n-            throw new UserException(e.getCause());\r\n-        } catch (IOException e) {\r\n-            throw new InternalException(e);\r\n-        } catch (ClassNotFoundException e) {\r\n-            throw new InternalException(e);\r\n-        } catch (UnmodifiableClassException e) {\r\n-            throw new InternalException(e);\r\n-        } finally {\r\n-            if (inst != null && t != null)\r\n-                inst.removeTransformer(t);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @return whether or not this VM has an instrumentation installed that\r\n-     * permits redefinition of classes. This assumes that all the arguments\r\n-     * will be modifiable classes according to\r\n-     * {@link java.lang.instrument.Instrumentation#isModifiableClass}, and\r\n-     * only checks whether or not an instrumentation is available and\r\n-     * if retransformation is possible.\r\n-     */\r\n-    public static boolean canRedefineClasses() {\r\n-        if (_canRedefine == null) {\r\n-            try {\r\n-                Instrumentation inst = InstrumentationFactory\r\n-                    .getInstrumentation();\r\n-                if (inst == null) {\r\n-                    _canRedefine = Boolean.FALSE;\r\n-                } else if (JavaVersions.VERSION == 5) {\r\n-                    // if inst is non-null and we're using Java 5,\r\n-                    // isRetransformClassesSupported isn't available,\r\n-                    // so we use the more basic class redefinition\r\n-                    // instead.\r\n-                    _canRedefine = Boolean.TRUE;\r\n-                } else {\r\n-                    _canRedefine = (Boolean) Instrumentation.class.getMethod(\r\n-                        \"isRetransformClassesSupported\").invoke(inst);\r\n-                }\r\n-            } catch (Exception e) {\r\n-                _canRedefine = Boolean.FALSE;\r\n-            }\r\n-        }\r\n-        return _canRedefine.booleanValue();\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.lang.instrument.Instrumentation;\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.ClassDefinition;\n+import java.lang.instrument.UnmodifiableClassException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.ArrayList;\n+import java.io.IOException;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.util.JavaVersions;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Redefines the method bodies of existing classes. Supports Java 5 VMs that\n+ * have a javaagent installed on the command line as well as newer VMs without\n+ * any javaagent flag.\n+ *\n+ * @since 1.0.0\n+ */\n+public class ClassRedefiner {\n+\n+    private static final Localizer _loc = \n+        Localizer.forPackage(ClassRedefiner.class);\n+\n+    private static Boolean _canRedefine = null;\n+\n+    /**\n+     * For each element in <code>classes</code>, this method will redefine\n+     * all the element's methods such that field accesses are intercepted\n+     * in-line. If {@link #canRedefineClasses()} returns <code>false</code>,\n+     * this method is a no-op.\n+     */\n+    public static void redefineClasses(OpenJPAConfiguration conf,\n+        final Map<Class,byte[]> classes) {\n+        if (classes == null || classes.size() == 0 || !canRedefineClasses())\n+            return;\n+\n+        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\n+        Instrumentation inst = null;\n+        ClassFileTransformer t = null;\n+        try {\n+            inst = InstrumentationFactory.getInstrumentation();\n+\n+            Class[] array = classes.keySet().toArray(new Class[classes.size()]);\n+            if (JavaVersions.VERSION >= 6) {\n+                log.trace(_loc.get(\"retransform-types\", classes.keySet()));\n+\n+                t = new ClassFileTransformer() {\n+                    public byte[] transform(ClassLoader loader, String clsName,\n+                        Class<?> classBeingRedefined, ProtectionDomain pd,\n+                        byte[] classfileBuffer) {\n+                        return classes.get(classBeingRedefined);\n+                    }\n+                };\n+                \n+                // these are Java 6 methods, and we don't have a Java 6 build\n+                // module yet. The cost of reflection here is negligible\n+                // compared to the redefinition / enhancement costs in total,\n+                // so this should not be a big problem.\n+                Method meth = inst.getClass().getMethod(\"addTransformer\",\n+                    new Class[] { ClassFileTransformer.class, boolean.class });\n+                meth.invoke(inst, new Object[] { t, true });\n+                meth = inst.getClass().getMethod(\"retransformClasses\",\n+                    new Class[] { array.getClass() });\n+                meth.invoke(inst, new Object[] { array });\n+            } else {\n+                log.trace(_loc.get(\"redefine-types\", classes.keySet()));\n+                // in a Java 5 context, we can use class redefinition instead\n+                ClassDefinition[] defs = new ClassDefinition[array.length];\n+                for (int i = 0; i < defs.length; i++)\n+                    defs[i] = new ClassDefinition(array[i],\n+                        classes.get(array[i]));\n+                inst.redefineClasses(defs);\n+            }\n+        } catch (NoSuchMethodException e) {\n+            throw new InternalException(e);\n+        } catch (IllegalAccessException e) {\n+            throw new InternalException(e);\n+        } catch (InvocationTargetException e) {\n+            throw new UserException(e.getCause());\n+        } catch (IOException e) {\n+            throw new InternalException(e);\n+        } catch (ClassNotFoundException e) {\n+            throw new InternalException(e);\n+        } catch (UnmodifiableClassException e) {\n+            throw new InternalException(e);\n+        } finally {\n+            if (inst != null && t != null)\n+                inst.removeTransformer(t);\n+        }\n+    }\n+\n+    /**\n+     * @return whether or not this VM has an instrumentation installed that\n+     * permits redefinition of classes. This assumes that all the arguments\n+     * will be modifiable classes according to\n+     * {@link java.lang.instrument.Instrumentation#isModifiableClass}, and\n+     * only checks whether or not an instrumentation is available and\n+     * if retransformation is possible.\n+     */\n+    public static boolean canRedefineClasses() {\n+        if (_canRedefine == null) {\n+            try {\n+                Instrumentation inst = InstrumentationFactory\n+                    .getInstrumentation();\n+                if (inst == null) {\n+                    _canRedefine = Boolean.FALSE;\n+                } else if (JavaVersions.VERSION == 5) {\n+                    // if inst is non-null and we're using Java 5,\n+                    // isRetransformClassesSupported isn't available,\n+                    // so we use the more basic class redefinition\n+                    // instead.\n+                    _canRedefine = Boolean.TRUE;\n+                } else {\n+                    _canRedefine = (Boolean) Instrumentation.class.getMethod(\n+                        \"isRetransformClassesSupported\").invoke(inst);\n+                }\n+            } catch (Exception e) {\n+                _canRedefine = Boolean.FALSE;\n+            }\n+        }\n+        return _canRedefine.booleanValue();\n+    }\n }\n\\ No newline at end of file"},{"sha":"1228778462a11d1f0f25075b69d3f1ddf04ecdd8","filename":"openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","status":"modified","additions":280,"deletions":280,"changes":560,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,280 +1,280 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.io.IOException;\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.HashMap;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.BytecodeWriter;\r\n-import org.apache.openjpa.lib.util.JavaVersions;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.Localizer.Message;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.util.GeneratedClasses;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.UserException;\r\n-import serp.bytecode.BCClass;\r\n-\r\n-/**\r\n- * Redefines the method bodies of existing unenhanced classes to make them\r\n- * notify state managers of mutations.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class ManagedClassSubclasser {\r\n-    private static final Localizer _loc = Localizer.forPackage(\r\n-        ManagedClassSubclasser.class);\r\n-\r\n-    /**\r\n-     * For each element in <code>classes</code>, creates and registers a\r\n-     * new subclass that implements {@link PersistenceCapable}, and prepares\r\n-     * OpenJPA to handle new instances of the unenhanced type. If this is\r\n-     * invoked in a Java 6 environment, this method will redefine the methods\r\n-     * for each class in the argument list such that field accesses are\r\n-     * intercepted in-line. If invoked in a Java 5 environment, this\r\n-     * redefinition is not possible; in these contexts, when using field\r\n-     * access, OpenJPA will need to do state comparisons to detect any change\r\n-     * to any instance at any time, and when using property access, OpenJPA\r\n-     * will need to do state comparisons to detect changes to newly inserted\r\n-     * instances after a flush has been called.\r\n-     *\r\n-     * @return the new subclasses, or <code>null</code> if <code>classes</code>\r\n-     * is <code>null</code>.\r\n-     * @throws UserException if <code>conf</code> requires build-time\r\n-     * enhancement and <code>classes</code> includes unenhanced types.\r\n-     *\r\n-     * @since 1.0.0\r\n-     */\r\n-    public static List<Class> prepareUnenhancedClasses(\r\n-        final OpenJPAConfiguration conf,\r\n-        final Collection<? extends Class> classes,\r\n-        final ClassLoader envLoader) {\r\n-        if (classes == null)\r\n-            return null;\r\n-        if (classes.size() == 0)\r\n-            return Collections.EMPTY_LIST;\r\n-\r\n-        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n-        if (conf.getRuntimeUnenhancedClassesConstant()\r\n-            != RuntimeUnenhancedClasssesModes.SUPPORTED) {\r\n-            Collection unenhanced = new ArrayList();\r\n-            for (Class cls : classes)\r\n-                if (!PersistenceCapable.class.isAssignableFrom(cls))\r\n-                    unenhanced.add(cls);\r\n-            if (unenhanced.size() > 0) {\r\n-                Message msg = _loc.get(\"runtime-optimization-disabled\",\r\n-                    unenhanced);\r\n-                if (conf.getRuntimeUnenhancedClassesConstant()\r\n-                    == RuntimeUnenhancedClasssesModes.WARN)\r\n-                    log.warn(msg);\r\n-                else\r\n-                    throw new UserException(msg);\r\n-            }\r\n-            return null;\r\n-        }\r\n-\r\n-        boolean redefine = ClassRedefiner.canRedefineClasses();\r\n-        if (redefine)\r\n-            log.info(_loc.get(\"enhance-and-subclass-and-redef-start\",\r\n-                classes));\r\n-        else\r\n-            log.info(_loc.get(\"enhance-and-subclass-no-redef-start\",\r\n-                classes));\r\n-\r\n-        final Map<Class, byte[]> map = new HashMap<Class, byte[]>();\r\n-        final List subs = new ArrayList(classes.size());\r\n-        final List ints = new ArrayList(classes.size());\r\n-        Set<Class> unspecified = null;\r\n-        for (Iterator iter = classes.iterator(); iter.hasNext(); ) {\r\n-            final Class cls = (Class) iter.next();\r\n-            final PCEnhancer enhancer = new PCEnhancer(conf, cls);\r\n-\r\n-            enhancer.setBytecodeWriter(new BytecodeWriter() {\r\n-                public void write(BCClass bc) throws IOException {\r\n-                    ManagedClassSubclasser.write(bc, enhancer, map,\r\n-                        cls, subs, ints);\r\n-                }\r\n-            });\r\n-            if (redefine)\r\n-                enhancer.setRedefine(true);\r\n-            enhancer.setCreateSubclass(true);\r\n-            enhancer.setAddDefaultConstructor(true);\r\n-\r\n-            // set this before enhancement as well as after since enhancement\r\n-            // uses a different metadata repository, and the metadata config\r\n-            // matters in the enhancement contract. Don't do any warning here,\r\n-            // since we'll issue warnings when we do the final metadata\r\n-            // reconfiguration at the end of this method.\r\n-            configureMetaData(enhancer.getMetaData(), conf, redefine, false);\r\n-\r\n-            unspecified = collectRelatedUnspecifiedTypes(enhancer.getMetaData(),\r\n-                classes, unspecified);\r\n-\r\n-            int runResult = enhancer.run();\r\n-            if (runResult == PCEnhancer.ENHANCE_PC) {\r\n-                try {\r\n-                    enhancer.record();\r\n-                } catch (IOException e) {\r\n-                    // our impl of BytecodeWriter doesn't throw IOException\r\n-                    throw new InternalException(e);\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        if (unspecified != null && !unspecified.isEmpty())\r\n-            throw new UserException(_loc.get(\"unspecified-unenhanced-types\",\r\n-                classes, unspecified));\r\n-\r\n-        ClassRedefiner.redefineClasses(conf, map);\r\n-        for (Class cls : map.keySet()) {\r\n-            setIntercepting(conf, envLoader, cls);\r\n-            configureMetaData(conf, envLoader, cls, redefine);\r\n-        }\r\n-        for (Class cls : (Collection<Class>) subs)\r\n-            configureMetaData(conf, envLoader, cls, redefine);\r\n-        for (Class cls : (Collection<Class>) ints)\r\n-            setIntercepting(conf, envLoader, cls);\r\n-\r\n-        return subs;\r\n-    }\r\n-\r\n-    private static Set<Class> collectRelatedUnspecifiedTypes(ClassMetaData meta,\r\n-        Collection<? extends Class> classes, Set<Class> unspecified) {\r\n-        unspecified = collectUnspecifiedType(meta.getPCSuperclass(), classes,\r\n-            unspecified);\r\n-\r\n-        for (FieldMetaData fmd : meta.getFields()) {\r\n-            if (fmd.isTransient())\r\n-                continue;\r\n-            if (fmd.isTypePC())\r\n-                unspecified = collectUnspecifiedType(fmd.getType(), classes,\r\n-                    unspecified);\r\n-            if (fmd.getElement() != null && fmd.getElement().isTypePC())\r\n-                unspecified = collectUnspecifiedType(fmd.getElement().getType(),\r\n-                    classes, unspecified);\r\n-            if (fmd.getKey() != null && fmd.getKey().isTypePC())\r\n-                unspecified = collectUnspecifiedType(fmd.getKey().getType(),\r\n-                    classes, unspecified);\r\n-            if (fmd.getValue() != null && fmd.getValue().isTypePC())\r\n-                unspecified = collectUnspecifiedType(fmd.getValue().getType(),\r\n-                    classes, unspecified);\r\n-        }\r\n-        return unspecified;\r\n-    }\r\n-\r\n-    private static Set<Class> collectUnspecifiedType(Class cls,\r\n-        Collection<? extends Class> classes, Set<Class> unspecified) {\r\n-        if (cls != null && !classes.contains(cls)\r\n-            && !ImplHelper.isManagedType(null, cls)) {\r\n-            if (unspecified == null)\r\n-                unspecified = new HashSet<Class>();\r\n-            unspecified.add(cls);\r\n-        }\r\n-        return unspecified;\r\n-    }\r\n-\r\n-    private static void configureMetaData(OpenJPAConfiguration conf,\r\n-        ClassLoader envLoader, Class cls, boolean redefineAvailable) {\r\n-        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\r\n-            .getMetaData(cls, envLoader, true);\r\n-        configureMetaData(meta, conf, redefineAvailable, true);\r\n-    }\r\n-\r\n-    private static void configureMetaData(ClassMetaData meta,\r\n-        OpenJPAConfiguration conf, boolean redefineAvailable, boolean warn) {\r\n-\r\n-        setDetachedState(meta);\r\n-\r\n-        if (warn && meta.getAccessType() == ClassMetaData.ACCESS_FIELD\r\n-            && !redefineAvailable) {\r\n-            // only warn about declared fields; superclass fields will be\r\n-            // warned about when the superclass is handled\r\n-            for (FieldMetaData fmd : meta.getDeclaredFields()) {\r\n-                switch (fmd.getTypeCode()) {\r\n-                    case JavaTypes.COLLECTION:\r\n-                    case JavaTypes.MAP:\r\n-                        // we can lazily load these, since we own the\r\n-                        // relationship container\r\n-                        break;\r\n-                    default:\r\n-                        if (!fmd.isInDefaultFetchGroup()\r\n-                            && !(fmd.isVersion() || fmd.isPrimaryKey())) {\r\n-                            Log log = conf.getLog(\r\n-                                OpenJPAConfiguration.LOG_ENHANCE);\r\n-                            log.warn(_loc.get(\"subclasser-fetch-group-override\",\r\n-                                meta.getDescribedType().getName(),\r\n-                                fmd.getName()));\r\n-                            fmd.setInDefaultFetchGroup(true);\r\n-                        }\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private static void write(BCClass bc, PCEnhancer enhancer,\r\n-        Map<Class, byte[]> map, Class cls, List subs, List ints)\r\n-        throws IOException {\r\n-\r\n-        if (bc == enhancer.getManagedTypeBytecode()) {\r\n-            // if it was already defined, don't put it in the map,\r\n-            // but do set the metadata accordingly.\r\n-            if (enhancer.isAlreadyRedefined())\r\n-                ints.add(bc.getType());\r\n-            else if (JavaVersions.VERSION >= 5)\r\n-                map.put(bc.getType(), bc.toByteArray());\r\n-        } else {\r\n-            if (!enhancer.isAlreadySubclassed()) {\r\n-                // this is the new subclass\r\n-                ClassLoader loader = GeneratedClasses.getMostDerivedLoader(\r\n-                    cls, PersistenceCapable.class);\r\n-                subs.add(GeneratedClasses.loadBCClass(bc, loader));\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private static void setIntercepting(OpenJPAConfiguration conf,\r\n-        ClassLoader envLoader, Class cls) {\r\n-        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\r\n-            .getMetaData(cls, envLoader, true);\r\n-        meta.setIntercepting(true);\r\n-    }\r\n-\r\n-    /**\r\n-     * If the metadata is configured to use a synthetic\r\n-     * detached state, reset it to not use a detached\r\n-     * state field, since we can't add fields when redefining.\r\n-     */\r\n-    private static void setDetachedState(ClassMetaData meta) {\r\n-        if (ClassMetaData.SYNTHETIC.equals(meta.getDetachedState()))\r\n-            meta.setDetachedState(null);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.BytecodeWriter;\n+import org.apache.openjpa.lib.util.JavaVersions;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Localizer.Message;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.GeneratedClasses;\n+import org.apache.openjpa.util.ImplHelper;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.UserException;\n+import serp.bytecode.BCClass;\n+\n+/**\n+ * Redefines the method bodies of existing unenhanced classes to make them\n+ * notify state managers of mutations.\n+ *\n+ * @since 1.0.0\n+ */\n+public class ManagedClassSubclasser {\n+    private static final Localizer _loc = Localizer.forPackage(\n+        ManagedClassSubclasser.class);\n+\n+    /**\n+     * For each element in <code>classes</code>, creates and registers a\n+     * new subclass that implements {@link PersistenceCapable}, and prepares\n+     * OpenJPA to handle new instances of the unenhanced type. If this is\n+     * invoked in a Java 6 environment, this method will redefine the methods\n+     * for each class in the argument list such that field accesses are\n+     * intercepted in-line. If invoked in a Java 5 environment, this\n+     * redefinition is not possible; in these contexts, when using field\n+     * access, OpenJPA will need to do state comparisons to detect any change\n+     * to any instance at any time, and when using property access, OpenJPA\n+     * will need to do state comparisons to detect changes to newly inserted\n+     * instances after a flush has been called.\n+     *\n+     * @return the new subclasses, or <code>null</code> if <code>classes</code>\n+     * is <code>null</code>.\n+     * @throws UserException if <code>conf</code> requires build-time\n+     * enhancement and <code>classes</code> includes unenhanced types.\n+     *\n+     * @since 1.0.0\n+     */\n+    public static List<Class> prepareUnenhancedClasses(\n+        final OpenJPAConfiguration conf,\n+        final Collection<? extends Class> classes,\n+        final ClassLoader envLoader) {\n+        if (classes == null)\n+            return null;\n+        if (classes.size() == 0)\n+            return Collections.EMPTY_LIST;\n+\n+        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\n+        if (conf.getRuntimeUnenhancedClassesConstant()\n+            != RuntimeUnenhancedClasssesModes.SUPPORTED) {\n+            Collection unenhanced = new ArrayList();\n+            for (Class cls : classes)\n+                if (!PersistenceCapable.class.isAssignableFrom(cls))\n+                    unenhanced.add(cls);\n+            if (unenhanced.size() > 0) {\n+                Message msg = _loc.get(\"runtime-optimization-disabled\",\n+                    unenhanced);\n+                if (conf.getRuntimeUnenhancedClassesConstant()\n+                    == RuntimeUnenhancedClasssesModes.WARN)\n+                    log.warn(msg);\n+                else\n+                    throw new UserException(msg);\n+            }\n+            return null;\n+        }\n+\n+        boolean redefine = ClassRedefiner.canRedefineClasses();\n+        if (redefine)\n+            log.info(_loc.get(\"enhance-and-subclass-and-redef-start\",\n+                classes));\n+        else\n+            log.info(_loc.get(\"enhance-and-subclass-no-redef-start\",\n+                classes));\n+\n+        final Map<Class, byte[]> map = new HashMap<Class, byte[]>();\n+        final List subs = new ArrayList(classes.size());\n+        final List ints = new ArrayList(classes.size());\n+        Set<Class> unspecified = null;\n+        for (Iterator iter = classes.iterator(); iter.hasNext(); ) {\n+            final Class cls = (Class) iter.next();\n+            final PCEnhancer enhancer = new PCEnhancer(conf, cls);\n+\n+            enhancer.setBytecodeWriter(new BytecodeWriter() {\n+                public void write(BCClass bc) throws IOException {\n+                    ManagedClassSubclasser.write(bc, enhancer, map,\n+                        cls, subs, ints);\n+                }\n+            });\n+            if (redefine)\n+                enhancer.setRedefine(true);\n+            enhancer.setCreateSubclass(true);\n+            enhancer.setAddDefaultConstructor(true);\n+\n+            // set this before enhancement as well as after since enhancement\n+            // uses a different metadata repository, and the metadata config\n+            // matters in the enhancement contract. Don't do any warning here,\n+            // since we'll issue warnings when we do the final metadata\n+            // reconfiguration at the end of this method.\n+            configureMetaData(enhancer.getMetaData(), conf, redefine, false);\n+\n+            unspecified = collectRelatedUnspecifiedTypes(enhancer.getMetaData(),\n+                classes, unspecified);\n+\n+            int runResult = enhancer.run();\n+            if (runResult == PCEnhancer.ENHANCE_PC) {\n+                try {\n+                    enhancer.record();\n+                } catch (IOException e) {\n+                    // our impl of BytecodeWriter doesn't throw IOException\n+                    throw new InternalException(e);\n+                }\n+            }\n+        }\n+\n+        if (unspecified != null && !unspecified.isEmpty())\n+            throw new UserException(_loc.get(\"unspecified-unenhanced-types\",\n+                classes, unspecified));\n+\n+        ClassRedefiner.redefineClasses(conf, map);\n+        for (Class cls : map.keySet()) {\n+            setIntercepting(conf, envLoader, cls);\n+            configureMetaData(conf, envLoader, cls, redefine);\n+        }\n+        for (Class cls : (Collection<Class>) subs)\n+            configureMetaData(conf, envLoader, cls, redefine);\n+        for (Class cls : (Collection<Class>) ints)\n+            setIntercepting(conf, envLoader, cls);\n+\n+        return subs;\n+    }\n+\n+    private static Set<Class> collectRelatedUnspecifiedTypes(ClassMetaData meta,\n+        Collection<? extends Class> classes, Set<Class> unspecified) {\n+        unspecified = collectUnspecifiedType(meta.getPCSuperclass(), classes,\n+            unspecified);\n+\n+        for (FieldMetaData fmd : meta.getFields()) {\n+            if (fmd.isTransient())\n+                continue;\n+            if (fmd.isTypePC())\n+                unspecified = collectUnspecifiedType(fmd.getType(), classes,\n+                    unspecified);\n+            if (fmd.getElement() != null && fmd.getElement().isTypePC())\n+                unspecified = collectUnspecifiedType(fmd.getElement().getType(),\n+                    classes, unspecified);\n+            if (fmd.getKey() != null && fmd.getKey().isTypePC())\n+                unspecified = collectUnspecifiedType(fmd.getKey().getType(),\n+                    classes, unspecified);\n+            if (fmd.getValue() != null && fmd.getValue().isTypePC())\n+                unspecified = collectUnspecifiedType(fmd.getValue().getType(),\n+                    classes, unspecified);\n+        }\n+        return unspecified;\n+    }\n+\n+    private static Set<Class> collectUnspecifiedType(Class cls,\n+        Collection<? extends Class> classes, Set<Class> unspecified) {\n+        if (cls != null && !classes.contains(cls)\n+            && !ImplHelper.isManagedType(null, cls)) {\n+            if (unspecified == null)\n+                unspecified = new HashSet<Class>();\n+            unspecified.add(cls);\n+        }\n+        return unspecified;\n+    }\n+\n+    private static void configureMetaData(OpenJPAConfiguration conf,\n+        ClassLoader envLoader, Class cls, boolean redefineAvailable) {\n+        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\n+            .getMetaData(cls, envLoader, true);\n+        configureMetaData(meta, conf, redefineAvailable, true);\n+    }\n+\n+    private static void configureMetaData(ClassMetaData meta,\n+        OpenJPAConfiguration conf, boolean redefineAvailable, boolean warn) {\n+\n+        setDetachedState(meta);\n+\n+        if (warn && meta.getAccessType() == ClassMetaData.ACCESS_FIELD\n+            && !redefineAvailable) {\n+            // only warn about declared fields; superclass fields will be\n+            // warned about when the superclass is handled\n+            for (FieldMetaData fmd : meta.getDeclaredFields()) {\n+                switch (fmd.getTypeCode()) {\n+                    case JavaTypes.COLLECTION:\n+                    case JavaTypes.MAP:\n+                        // we can lazily load these, since we own the\n+                        // relationship container\n+                        break;\n+                    default:\n+                        if (!fmd.isInDefaultFetchGroup()\n+                            && !(fmd.isVersion() || fmd.isPrimaryKey())) {\n+                            Log log = conf.getLog(\n+                                OpenJPAConfiguration.LOG_ENHANCE);\n+                            log.warn(_loc.get(\"subclasser-fetch-group-override\",\n+                                meta.getDescribedType().getName(),\n+                                fmd.getName()));\n+                            fmd.setInDefaultFetchGroup(true);\n+                        }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void write(BCClass bc, PCEnhancer enhancer,\n+        Map<Class, byte[]> map, Class cls, List subs, List ints)\n+        throws IOException {\n+\n+        if (bc == enhancer.getManagedTypeBytecode()) {\n+            // if it was already defined, don't put it in the map,\n+            // but do set the metadata accordingly.\n+            if (enhancer.isAlreadyRedefined())\n+                ints.add(bc.getType());\n+            else if (JavaVersions.VERSION >= 5)\n+                map.put(bc.getType(), bc.toByteArray());\n+        } else {\n+            if (!enhancer.isAlreadySubclassed()) {\n+                // this is the new subclass\n+                ClassLoader loader = GeneratedClasses.getMostDerivedLoader(\n+                    cls, PersistenceCapable.class);\n+                subs.add(GeneratedClasses.loadBCClass(bc, loader));\n+            }\n+        }\n+    }\n+\n+    private static void setIntercepting(OpenJPAConfiguration conf,\n+        ClassLoader envLoader, Class cls) {\n+        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\n+            .getMetaData(cls, envLoader, true);\n+        meta.setIntercepting(true);\n+    }\n+\n+    /**\n+     * If the metadata is configured to use a synthetic\n+     * detached state, reset it to not use a detached\n+     * state field, since we can't add fields when redefining.\n+     */\n+    private static void setDetachedState(ClassMetaData meta) {\n+        if (ClassMetaData.SYNTHETIC.equals(meta.getDetachedState()))\n+            meta.setDetachedState(null);\n+    }\n+}"},{"sha":"ce0958229f1aec56780e61974d3e32f908c1d0dd","filename":"openjpa-kernel-5/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","status":"modified","additions":93,"deletions":93,"changes":186,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel-5/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel-5/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel-5/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,93 +1,93 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.lang.reflect.Method;\r\n-import java.util.List;\r\n-import java.util.ArrayList;\r\n-\r\n-import junit.framework.TestCase;\r\n-\r\n-/**\r\n- * Tests that {@link Reflection#getDeclaredMethod(Class, String, Class)}\r\n- * returns the most-derived class's method when called from a type hierarchy.\r\n- * See OPENJPA-251.\r\n- */\r\n-public class TestGetDeclaredMethod extends TestCase {\r\n-\r\n-    public void testGetDeclaredMethod() {\r\n-        Method meth =\r\n-            Reflection.getDeclaredMethod(Impl.class, \"getObject\", null);\r\n-        assertEquals(Impl.class, meth.getDeclaringClass());\r\n-        assertEquals(String.class, meth.getReturnType());\r\n-    }\r\n-\r\n-    public void testMostDerived() throws NoSuchMethodException {\r\n-        Method impl = Impl.class.getDeclaredMethod(\"getObject\", null);\r\n-        Method iface = Iface.class.getDeclaredMethod(\"getObject\", null);\r\n-        Method other = Other.class.getDeclaredMethod(\"getObject\", null);\r\n-        assertEquals(Impl.class, Reflection.mostDerived(impl, iface)\r\n-            .getDeclaringClass());\r\n-        assertEquals(Impl.class, Reflection.mostDerived(iface, impl)\r\n-            .getDeclaringClass());\r\n-        try {\r\n-            Reflection.mostDerived(iface, other);\r\n-            fail(\"'iface' and 'other' are not from related types\");\r\n-        } catch (IllegalArgumentException e) {\r\n-            // expected\r\n-        }\r\n-    }\r\n-\r\n-    public void testGenerics() throws NoSuchMethodException {\r\n-        List<Method> meths = new ArrayList<Method>();\r\n-        for (Method meth : GenericsImpl.class.getDeclaredMethods()) {\r\n-            if (\"getObject\".equals(meth.getName()))\r\n-                meths.add(meth);\r\n-        }\r\n-        assertEquals(2, meths.size());\r\n-        assertEquals(String.class, Reflection.mostDerived(meths.get(0),\r\n-            meths.get(1)).getReturnType());\r\n-    }\r\n-    \r\n-    interface Iface {\r\n-        Object getObject();\r\n-    }\r\n-\r\n-    static class Impl implements Iface {\r\n-        public String getObject() {\r\n-            return \"string\";\r\n-        }\r\n-    }\r\n-\r\n-    static class Other {\r\n-        public String getObject() {\r\n-            return \"other\";\r\n-        }\r\n-    }\r\n-\r\n-    interface GenericsIface<T> {\r\n-        public T getObject();\r\n-    }\r\n-\r\n-    static class GenericsImpl implements GenericsIface {\r\n-        public String getObject() {\r\n-            return null;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests that {@link Reflection#getDeclaredMethod(Class, String, Class)}\n+ * returns the most-derived class's method when called from a type hierarchy.\n+ * See OPENJPA-251.\n+ */\n+public class TestGetDeclaredMethod extends TestCase {\n+\n+    public void testGetDeclaredMethod() {\n+        Method meth =\n+            Reflection.getDeclaredMethod(Impl.class, \"getObject\", null);\n+        assertEquals(Impl.class, meth.getDeclaringClass());\n+        assertEquals(String.class, meth.getReturnType());\n+    }\n+\n+    public void testMostDerived() throws NoSuchMethodException {\n+        Method impl = Impl.class.getDeclaredMethod(\"getObject\", null);\n+        Method iface = Iface.class.getDeclaredMethod(\"getObject\", null);\n+        Method other = Other.class.getDeclaredMethod(\"getObject\", null);\n+        assertEquals(Impl.class, Reflection.mostDerived(impl, iface)\n+            .getDeclaringClass());\n+        assertEquals(Impl.class, Reflection.mostDerived(iface, impl)\n+            .getDeclaringClass());\n+        try {\n+            Reflection.mostDerived(iface, other);\n+            fail(\"'iface' and 'other' are not from related types\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGenerics() throws NoSuchMethodException {\n+        List<Method> meths = new ArrayList<Method>();\n+        for (Method meth : GenericsImpl.class.getDeclaredMethods()) {\n+            if (\"getObject\".equals(meth.getName()))\n+                meths.add(meth);\n+        }\n+        assertEquals(2, meths.size());\n+        assertEquals(String.class, Reflection.mostDerived(meths.get(0),\n+            meths.get(1)).getReturnType());\n+    }\n+    \n+    interface Iface {\n+        Object getObject();\n+    }\n+\n+    static class Impl implements Iface {\n+        public String getObject() {\n+            return \"string\";\n+        }\n+    }\n+\n+    static class Other {\n+        public String getObject() {\n+            return \"other\";\n+        }\n+    }\n+\n+    interface GenericsIface<T> {\n+        public T getObject();\n+    }\n+\n+    static class GenericsImpl implements GenericsIface {\n+        public String getObject() {\n+            return null;\n+        }\n+    }\n+}"},{"sha":"27d02fdd6fccd359e35404ef3ec051d703a86b33","filename":"openjpa-kernel/pom.xml","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/pom.xml?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -31,7 +31,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-parent</artifactId>\n-        <version>1.0.3</version>\n+        <version>1.0.4</version>\n     </parent>\n     <profiles>\n         <profile>\n@@ -41,6 +41,7 @@\n                 <pluginManagement>\n                     <plugins>\n                         <plugin>\n+                            <groupId>org.apache.maven.plugins</groupId>\n                             <artifactId>maven-compiler-plugin</artifactId>\n                             <configuration>\n                                 <compilerArguments>\n@@ -82,6 +83,7 @@\n     <build>\n         <plugins>\n             <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-compiler-plugin</artifactId>\n                 <configuration>\n                     <source>1.4</source>\n@@ -123,6 +125,7 @@\n                 </executions>\n             </plugin>\n             <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-antrun-plugin</artifactId>\n                 <executions>\n                     <execution>"},{"sha":"a8e5bb124bc013c11c3e4a2172f39148dd737a23","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","status":"modified","additions":43,"deletions":43,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,43 +1,43 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import org.apache.openjpa.lib.conf.ProductDerivation;\r\n-import java.util.Map;\r\n-\r\n-/**\r\n- * Adds datastore based extension to ProductDerivation.  \r\n- *\r\n- * @since 0.4.1\r\n- * @author Pinaki Poddar\r\n- */\r\n-public interface OpenJPAProductDerivation extends ProductDerivation {\r\n-\r\n-    public static final int TYPE_SPEC = 0;\r\n-    public static final int TYPE_STORE = 200;\r\n-    public static final int TYPE_SPEC_STORE = 300;\r\n-    public static final int TYPE_PRODUCT_STORE = 400;\r\n-\r\n-    /**\r\n-     * Load default alias options into the given map.  Each entry maps an\r\n-     * alias to a broker factory class name.  Replace anything previously \r\n-     * under the desired keys.\r\n-     */\r\n-    public void putBrokerFactoryAliases(Map aliases);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.conf;\n+\n+import org.apache.openjpa.lib.conf.ProductDerivation;\n+import java.util.Map;\n+\n+/**\n+ * Adds datastore based extension to ProductDerivation.  \n+ *\n+ * @since 0.4.1\n+ * @author Pinaki Poddar\n+ */\n+public interface OpenJPAProductDerivation extends ProductDerivation {\n+\n+    public static final int TYPE_SPEC = 0;\n+    public static final int TYPE_STORE = 200;\n+    public static final int TYPE_SPEC_STORE = 300;\n+    public static final int TYPE_PRODUCT_STORE = 400;\n+\n+    /**\n+     * Load default alias options into the given map.  Each entry maps an\n+     * alias to a broker factory class name.  Replace anything previously \n+     * under the desired keys.\n+     */\n+    public void putBrokerFactoryAliases(Map aliases);\n+}"},{"sha":"1ba500fa71877e166aa92a9c9b5ba04ab94f107a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","status":"modified","additions":94,"deletions":94,"changes":188,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,94 +1,94 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.util.Collections;\r\n-import java.util.Hashtable;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.conf.PluginValue;\r\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentMap;\r\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\r\n-import org.apache.openjpa.lib.util.ParseException;\r\n-import org.apache.openjpa.util.CacheMap;\r\n-\r\n-/**\r\n- * A cache of compiled queries.\r\n- *\r\n- * @author Abe White\r\n- * @since 0.9.6 (also existed in prior versions of Kodo)\r\n- * @nojavadoc\r\n- */\r\n-public class QueryCompilationCacheValue\r\n-    extends PluginValue {\r\n-\r\n-    public static final String[] ALIASES = {\r\n-        \"true\", CacheMap.class.getName(),\r\n-        \"all\", ConcurrentHashMap.class.getName(),\r\n-        \"false\", null,\r\n-    };\r\n-\r\n-    public QueryCompilationCacheValue(String prop) {\r\n-        super(prop, true);\r\n-        setAliases(ALIASES);\r\n-        setDefault(ALIASES[0]);\r\n-        setClassName(ALIASES[1]);\r\n-    }\r\n-\r\n-    public Object newInstance(String clsName, Class type,\r\n-        Configuration conf, boolean fatal) {\r\n-        // make sure map handles concurrency\r\n-        Map map;\r\n-        \r\n-        try {\r\n-            map = (Map) super.newInstance(clsName, type, conf, fatal);\r\n-        } catch (ParseException pe) {\r\n-            // OPENJPA256: this class differs from most plugins in that\r\n-            // the plugin type is the standard java interface Map.class (rather\r\n-            // than an openjpa-specific interface), which means that the\r\n-            // ClassLoader used to load the implementation will be the system\r\n-            // class loader; this presents a problem if OpenJPA is not in the\r\n-            // system classpath, so work around the problem by catching\r\n-            // the ParseException (which is what we wrap the\r\n-            // ClassNotFoundException in) and try again, this time using\r\n-            // this class' ClassLoader.\r\n-            map = (Map) super.newInstance(clsName,\r\n-                QueryCompilationCacheValue.class, conf, fatal);\r\n-        } catch (IllegalArgumentException iae) {\r\n-            // OPENJPA256: this class differs from most plugins in that\r\n-            // the plugin type is the standard java interface Map.class (rather\r\n-            // than an openjpa-specific interface), which means that the\r\n-            // ClassLoader used to load the implementation will be the system\r\n-            // class loader; this presents a problem if OpenJPA is not in the\r\n-            // system classpath, so work around the problem by catching\r\n-            // the IllegalArgumentException (which is what we wrap the\r\n-            // ClassNotFoundException in) and try again, this time using\r\n-            // this class' ClassLoader.\r\n-            map = (Map) super.newInstance(clsName,\r\n-                QueryCompilationCacheValue.class, conf, fatal);\r\n-        }\r\n-\r\n-        if (map != null && !(map instanceof Hashtable)\r\n-            && !(map instanceof CacheMap)\r\n-            && !(map instanceof ConcurrentMap))\r\n-            map = Collections.synchronizedMap(map);\r\n-        return map;\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.util.Collections;\n+import java.util.Hashtable;\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentMap;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n+import org.apache.openjpa.lib.util.ParseException;\n+import org.apache.openjpa.util.CacheMap;\n+\n+/**\n+ * A cache of compiled queries.\n+ *\n+ * @author Abe White\n+ * @since 0.9.6 (also existed in prior versions of Kodo)\n+ * @nojavadoc\n+ */\n+public class QueryCompilationCacheValue\n+    extends PluginValue {\n+\n+    public static final String[] ALIASES = {\n+        \"true\", CacheMap.class.getName(),\n+        \"all\", ConcurrentHashMap.class.getName(),\n+        \"false\", null,\n+    };\n+\n+    public QueryCompilationCacheValue(String prop) {\n+        super(prop, true);\n+        setAliases(ALIASES);\n+        setDefault(ALIASES[0]);\n+        setClassName(ALIASES[1]);\n+    }\n+\n+    public Object newInstance(String clsName, Class type,\n+        Configuration conf, boolean fatal) {\n+        // make sure map handles concurrency\n+        Map map;\n+        \n+        try {\n+            map = (Map) super.newInstance(clsName, type, conf, fatal);\n+        } catch (ParseException pe) {\n+            // OPENJPA256: this class differs from most plugins in that\n+            // the plugin type is the standard java interface Map.class (rather\n+            // than an openjpa-specific interface), which means that the\n+            // ClassLoader used to load the implementation will be the system\n+            // class loader; this presents a problem if OpenJPA is not in the\n+            // system classpath, so work around the problem by catching\n+            // the ParseException (which is what we wrap the\n+            // ClassNotFoundException in) and try again, this time using\n+            // this class' ClassLoader.\n+            map = (Map) super.newInstance(clsName,\n+                QueryCompilationCacheValue.class, conf, fatal);\n+        } catch (IllegalArgumentException iae) {\n+            // OPENJPA256: this class differs from most plugins in that\n+            // the plugin type is the standard java interface Map.class (rather\n+            // than an openjpa-specific interface), which means that the\n+            // ClassLoader used to load the implementation will be the system\n+            // class loader; this presents a problem if OpenJPA is not in the\n+            // system classpath, so work around the problem by catching\n+            // the IllegalArgumentException (which is what we wrap the\n+            // ClassNotFoundException in) and try again, this time using\n+            // this class' ClassLoader.\n+            map = (Map) super.newInstance(clsName,\n+                QueryCompilationCacheValue.class, conf, fatal);\n+        }\n+\n+        if (map != null && !(map instanceof Hashtable)\n+            && !(map instanceof CacheMap)\n+            && !(map instanceof ConcurrentMap))\n+            map = Collections.synchronizedMap(map);\n+        return map;\n+\t}\n+}"},{"sha":"00d30264b636b43802f8bca285331d3ebb160ff6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","status":"modified","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -19,13 +19,17 @@\n package org.apache.openjpa.datacache;\n \n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.BitSet;\n import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n \n+import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.event.RemoteCommitEvent;\n import org.apache.openjpa.event.RemoteCommitListener;\n@@ -35,6 +39,8 @@\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\n \n+import serp.util.Strings;\n+\n /**\n  * Abstract {@link DataCache} implementation that provides various\n  * statistics, logging, and timeout functionality common across cache\n@@ -65,6 +71,9 @@\n     private String _name = null;\n     private boolean _closed = false;\n     private String _schedule = null;\n+    \n+    protected Set _includedTypes;\n+    protected Set _excludedTypes;\n \n     public String getName() {\n         return _name;\n@@ -452,4 +461,32 @@ public Map getAll(List keys) {\n             resultMap.put(keys.get(i), get(keys.get(i)));\n         return resultMap;\n     }\n+    \n+    public Set getTypes() {\n+        return _includedTypes;\n+    }\n+    \n+    public Set getExcludedTypes() {\n+        return _excludedTypes;\n+    }\n+\n+    public void setTypes(Set types) {\n+        _includedTypes = types;\n+    }\n+\n+    public void setTypes(String types) {\n+        _includedTypes =\n+            StringUtils.isEmpty(types) ? null : new HashSet(Arrays\n+                .asList(Strings.split(types, \";\", 0)));\n+    }\n+\n+    public void setExcludedTypes(Set types) {\n+        _excludedTypes = types;\n+    }\n+\n+    public void setExcludedTypes(String types) {\n+        _excludedTypes =\n+            StringUtils.isEmpty(types) ? null : new HashSet(Arrays\n+                .asList(Strings.split(types, \";\", 0)));\n+    }\n }"},{"sha":"3904232254b3c6af09c6ebad37e46f7795acdc6f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","status":"modified","additions":31,"deletions":31,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,31 +1,31 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Instances of this interface can convert a positional index for a\r\n- * {@link FieldMetaData} that uses property access into the underlying\r\n- * field name. Instances of {@link DynamicPersistenceCapable} for types\r\n- * that use property access will implement this interface.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface AttributeTranslator {\r\n-    public String pcAttributeIndexToFieldName(int i);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Instances of this interface can convert a positional index for a\n+ * {@link FieldMetaData} that uses property access into the underlying\n+ * field name. Instances of {@link DynamicPersistenceCapable} for types\n+ * that use property access will implement this interface.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface AttributeTranslator {\n+    public String pcAttributeIndexToFieldName(int i);\n+}"},{"sha":"945fa0a9dbc2371ab3e369ba543ce011cdfb498b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPCHelper.java","status":"modified","additions":30,"deletions":30,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPCHelper.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPCHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPCHelper.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,30 +1,30 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Helper methods for dynamically-redefined managed types.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class DynamicPCHelper {\r\n-    public static boolean isDetached(Object o) {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Helper methods for dynamically-redefined managed types.\n+ *\n+ * @since 1.0.0\n+ */\n+public class DynamicPCHelper {\n+    public static boolean isDetached(Object o) {\n+        throw new UnsupportedOperationException();\n+    }\n+}"},{"sha":"78614624c6c833d8ecaa23f13903ad1c11a50d5a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,28 +1,28 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Instances that implement this marker interface are dynamically-generated\r\n- * subtypes of managed types that were loaded before being enhanced.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface DynamicPersistenceCapable {\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Instances that implement this marker interface are dynamically-generated\n+ * subtypes of managed types that were loaded before being enhanced.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface DynamicPersistenceCapable {\n+}"},{"sha":"ebdd746c8638de5766fb5d0add78c927b6d4b0fc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,28 +1,28 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Instances of this interface can provide an underlying instance.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface ManagedInstanceProvider {\r\n-    public Object getManagedInstance();\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Instances of this interface can provide an underlying instance.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface ManagedInstanceProvider {\n+    public Object getManagedInstance();\n+}"},{"sha":"54bf484f8ca25d00c391ad9c7670d7e7ccb21d29","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","status":"modified","additions":33,"deletions":2,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1030,8 +1030,13 @@ private void addPCMethods()\n             addCopyKeyFieldsToObjectIdMethod(false);\n             addCopyKeyFieldsFromObjectIdMethod(true);\n             addCopyKeyFieldsFromObjectIdMethod(false);\n+            if (_meta.hasAbstractPKField() == true) {\n+            \taddGetIDOwningClass();\n+            }\n             addNewObjectIdInstanceMethod(true);\n             addNewObjectIdInstanceMethod(false);\n+        } else if (_meta.hasPKFieldsFromAbstractClass()) {\n+            addGetIDOwningClass();\n         }\n     }\n \n@@ -2413,14 +2418,28 @@ private void addNewObjectIdInstanceMethod(boolean obj)\n             // new ObjectId (cls, oid)\n             code.anew().setType(ObjectId.class);\n             code.dup();\n-            code.classconstant().setClass(getType(_meta));\n+            if (_meta.hasAbstractPKField() == false) {\n+                code.classconstant().setClass(getType(_meta));\n+            } else {\n+                code.aload().setThis();\n+                code.invokevirtual().setMethod(\n+                        PRE + \"GetIDOwningClass\", Class.class, null);\n+            }\n         }\n \n         // new <oid class> ();\n         code.anew().setType(oidType);\n         code.dup();\n         if (_meta.isOpenJPAIdentity() || (obj && usesClsString == Boolean.TRUE))\n-            code.classconstant().setClass(getType(_meta));\n+        {\n+        \tif (_meta.hasAbstractPKField() == false) {\n+        \t\tcode.classconstant().setClass(getType(_meta));\n+        \t} else {\n+        \t    code.aload().setThis();\n+        \t    code.invokevirtual().setMethod(\n+        \t            PRE + \"GetIDOwningClass\", Class.class, null);\n+        \t}\n+        }\n         if (obj) {\n             code.aload().setParam(0);\n             code.checkcast().setType(String.class);\n@@ -2452,7 +2471,19 @@ else if (_meta.getObjectIdType() == Date.class)\n         code.calculateMaxStack();\n         code.calculateMaxLocals();\n     }\n+   \n+    private void addGetIDOwningClass() throws NoSuchMethodException {\n+    \t BCMethod method = _pc.declareMethod(PRE + \"GetIDOwningClass\",\n+    \t\t\tClass.class, null);\n+        Code code = method.getCode(true);\n+        \n+        code.classconstant().setClass(getType(_meta));\n+        code.areturn();       \n \n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();       \n+    }\n+    \n     /**\n      * When communicating with the StateManager, many methods are used\n      * depending on the class of state being passed. This method,"},{"sha":"aef221a3223762557d2d3c570628c63e318767b3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","status":"modified","additions":272,"deletions":272,"changes":544,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,272 +1,272 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.lang.reflect.Modifier;\r\n-import java.lang.reflect.Constructor;\r\n-import java.lang.reflect.Method;\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.util.UserException;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.Localizer.Message;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import serp.bytecode.BCField;\r\n-import serp.bytecode.BCClass;\r\n-import serp.bytecode.BCMethod;\r\n-\r\n-/**\r\n- *\t<p>Validates that a given type meets the JPA contract, plus a few\r\n- *  OpenJPA-specific additions for subclassing / redefinition:\r\n- *\r\n- *\t<ul>\r\n- * \t\t<li>must have an accessible no-args constructor</li>\r\n- * \t\t<li>must be a public or protected class</li>\r\n- * \t\t<li>must not be final</li>\r\n- * \t\t<li>must not extend an enhanced class</li>\r\n- *\t\t<li>all persistent data represented by accessible setter/getter\r\n- * \t\t\tmethods (persistent properties)</li>\r\n- * \t\t<li>if versioning is to be used, exactly one persistent property for\r\n- * \t\t\tthe numeric version data</li> <!-- ##### is this true? -->\r\n- *\r\n- * \t\t<li>When using property access, the backing field for a persistent\r\n- *          property must be:\r\n- * \t\t\t<ul>\r\n- * \t\t\t\t<!-- ##### JPA validation of these needs to be tested -->\r\n- * \t\t\t\t<li>private</li>\r\n- * \t\t\t\t<li>set only in the designated setter,\r\n- * \t\t\t\t\tin the constructor, or in {@link Object#clone()},\r\n- * \t\t\t\t\t<code>readObject(ObjectInputStream)</code>, or\r\n- * \t\t\t\t\t{@link Externalizable#readExternal(ObjectInput)}.</li>\r\n- * \t\t\t\t<li>read only in the designated getter and the\r\n- * \t\t\t\t\tconstructor.</li>\r\n- *\t\t\t</ul>\r\n- * \t\t</li>\r\n- * \t</ul>\r\n- *\r\n- * \t<p>If you use this technique and use the <code>new</code> keyword instead of\r\n- * \ta OpenJPA-supplied construction routine, OpenJPA will need to do extra work\r\n- *  with persistent-new-flushed instances, since OpenJPA cannot in this case\r\n- *  track what happens to such an instance.</p>\r\n- *\r\n- * \t@since 1.0.0\r\n- */\r\n-public class PCSubclassValidator {\r\n-\r\n-    private static final Localizer loc =\r\n-        Localizer.forPackage(PCSubclassValidator.class);\r\n-\r\n-    private final ClassMetaData meta;\r\n-    private final BCClass pc;\r\n-    private final Log log;\r\n-    private final boolean failOnContractViolations;\r\n-\r\n-    private Collection errors;\r\n-    private Collection contractViolations;\r\n-\r\n-    public PCSubclassValidator(ClassMetaData meta, BCClass bc, Log log,\r\n-        boolean enforceContractViolations) {\r\n-        this.meta = meta;\r\n-        this.pc = bc;\r\n-        this.log = log;\r\n-        this.failOnContractViolations = enforceContractViolations;\r\n-    }\r\n-\r\n-    public void assertCanSubclass() {\r\n-        Class superclass = meta.getDescribedType();\r\n-        String name = superclass.getName();\r\n-        if (superclass.isInterface())\r\n-            addError(loc.get(\"subclasser-no-ifaces\", name), meta);\r\n-        if (Modifier.isFinal(superclass.getModifiers()))\r\n-            addError(loc.get(\"subclasser-no-final-classes\", name), meta);\r\n-        if (Modifier.isPrivate(superclass.getModifiers()))\r\n-            addError(loc.get(\"subclasser-no-private-classes\", name), meta);\r\n-        if (PersistenceCapable.class.isAssignableFrom(superclass))\r\n-            addError(loc.get(\"subclasser-super-already-pc\", name), meta);\r\n-\r\n-        try {\r\n-            Constructor c = superclass.getDeclaredConstructor(new Class[0]);\r\n-            if (!(Modifier.isProtected(c.getModifiers())\r\n-                || Modifier.isPublic(c.getModifiers())))\r\n-                addError(loc.get(\"subclasser-private-ctor\", name), meta);\r\n-        }\r\n-        catch (NoSuchMethodException e) {\r\n-            addError(loc.get(\"subclasser-no-void-ctor\", name),\r\n-                meta);\r\n-        }\r\n-\r\n-        // if the BCClass we loaded is already pc and the superclass is not,\r\n-        // then we should never get here, so let's make sure that the\r\n-        // calling context is caching correctly by throwing an exception.\r\n-        if (pc.isInstanceOf(PersistenceCapable.class) &&\r\n-            !PersistenceCapable.class.isAssignableFrom(superclass))\r\n-            throw new InternalException(\r\n-                loc.get(\"subclasser-class-already-pc\", name));\r\n-\r\n-        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY)\r\n-            checkPropertiesAreInterceptable();\r\n-\r\n-        if (errors != null && !errors.isEmpty())\r\n-            throw new UserException(errors.toString());\r\n-        else if (contractViolations != null &&\r\n-            !contractViolations.isEmpty() && log.isWarnEnabled())\r\n-            log.warn(contractViolations.toString());\r\n-    }\r\n-\r\n-    private void checkPropertiesAreInterceptable() {\r\n-        // just considers accessor methods for now.\r\n-        FieldMetaData[] fmds = meta.getFields();\r\n-        for (int i = 0; i < fmds.length; i++) {\r\n-            Method getter = (Method) fmds[i].getBackingMember();\r\n-            if (getter == null) {\r\n-                addError(loc.get(\"subclasser-no-getter\",\r\n-                    fmds[i].getName()), fmds[i]);\r\n-                continue;\r\n-            }\r\n-            BCField returnedField = checkGetterIsSubclassable(getter, fmds[i]);\r\n-\r\n-            Method setter = setterForField(fmds[i]);\r\n-            if (setter == null) {\r\n-                addError(loc.get(\"subclasser-no-setter\", fmds[i].getName()),\r\n-                    fmds[i]);\r\n-                continue;\r\n-            }\r\n-            BCField assignedField = checkSetterIsSubclassable(setter, fmds[i]);\r\n-            if (assignedField == null)\r\n-                continue;\r\n-\r\n-            if (assignedField != returnedField)\r\n-                addContractViolation(loc.get\r\n-                    (\"subclasser-setter-getter-field-mismatch\",\r\n-                        fmds[i].getName(), returnedField,assignedField),\r\n-                    fmds[i]);\r\n-\r\n-            // ### scan through all the rest of the class to make sure it\r\n-            // ### doesn't use the field.\r\n-        }\r\n-    }\r\n-\r\n-    private Method setterForField(FieldMetaData fmd) {\r\n-        try {\r\n-            return fmd.getDeclaringType().getDeclaredMethod(\r\n-                \"set\" + StringUtils.capitalize(fmd.getName()),\r\n-                new Class[]{ fmd.getDeclaredType() });\r\n-        }\r\n-        catch (NoSuchMethodException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @return the name of the field that is returned by <code>meth</code>, or\r\n-     *         <code>null</code> if something other than a single field is\r\n-     *         returned, or if it cannot be determined what is returned.\r\n-     */\r\n-    private BCField checkGetterIsSubclassable(Method meth, FieldMetaData fmd) {\r\n-        checkMethodIsSubclassable(meth, fmd);\r\n-        BCField field = PCEnhancer.getReturnedField(getBCMethod(meth));\r\n-        if (field == null) {\r\n-            addContractViolation(loc.get(\"subclasser-invalid-getter\",\r\n-                fmd.getName()), fmd);\r\n-            return null;\r\n-        } else {\r\n-            return field;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @return the field that is set in <code>meth</code>, or\r\n-     *         <code>null</code> if something other than a single field is\r\n-     *         set, or if it cannot be determined what is set.\r\n-     */\r\n-    private BCField checkSetterIsSubclassable(Method meth, FieldMetaData fmd) {\r\n-        checkMethodIsSubclassable(meth, fmd);\r\n-        BCField field = PCEnhancer.getAssignedField(getBCMethod(meth));\r\n-        if (field == null) {\r\n-            addContractViolation(loc.get(\"subclasser-invalid-setter\",\r\n-                fmd.getName()), fmd);\r\n-            return null;\r\n-        } else {\r\n-            return field;\r\n-        }\r\n-    }\r\n-\r\n-    private BCMethod getBCMethod(Method meth) {\r\n-        BCClass bc = pc.getProject().loadClass(meth.getDeclaringClass());\r\n-        return bc.getDeclaredMethod(meth.getName(), meth.getParameterTypes());\r\n-    }\r\n-\r\n-    private void checkMethodIsSubclassable(Method meth, FieldMetaData fmd) {\r\n-        String className = fmd.getDefiningMetaData().\r\n-            getDescribedType().getName();\r\n-        if (!(Modifier.isProtected(meth.getModifiers())\r\n-            || Modifier.isPublic(meth.getModifiers())))\r\n-            addError(loc.get(\"subclasser-private-accessors-unsupported\",\r\n-                className, meth.getName()), fmd);\r\n-        if (Modifier.isFinal(meth.getModifiers()))\r\n-            addError(loc.get(\"subclasser-final-methods-not-allowed\",\r\n-                className, meth.getName()), fmd);\r\n-        if (Modifier.isNative(meth.getModifiers()))\r\n-            addContractViolation(loc.get\r\n-                (\"subclasser-native-methods-not-allowed\", className,\r\n-                    meth.getName()),\r\n-                fmd);\r\n-        if (Modifier.isStatic(meth.getModifiers()))\r\n-            addError(loc.get(\"subclasser-static-methods-not-supported\",\r\n-                className, meth.getName()), fmd);\r\n-    }\r\n-\r\n-    private void addError(Message s, ClassMetaData cls) {\r\n-        if (errors == null)\r\n-            errors = new ArrayList();\r\n-\r\n-        errors.add(loc.get(\"subclasser-error-meta\", s,\r\n-            cls.getDescribedType().getName(),\r\n-            cls.getSourceFile()));\r\n-    }\r\n-\r\n-    private void addError(Message s, FieldMetaData fmd) {\r\n-        if (errors == null)\r\n-            errors = new ArrayList();\r\n-\r\n-        errors.add(loc.get(\"subclasser-error-field\", s,\r\n-            fmd.getFullName(),\r\n-            fmd.getDeclaringMetaData().getSourceFile()));\r\n-    }\r\n-\r\n-    private void addContractViolation(Message m, FieldMetaData fmd) {\r\n-        // add the violation as an error in case we're processing violations\r\n-        // as errors; this keeps them in the order that they were found rather\r\n-        // than just adding the violations to the end of the list.\r\n-        if (failOnContractViolations)\r\n-            addError(m, fmd);\r\n-\r\n-        if (contractViolations == null)\r\n-            contractViolations = new ArrayList();\r\n-\r\n-        contractViolations.add(loc.get\r\n-            (\"subclasser-contract-violation-field\", m.getMessage(),\r\n-                fmd.getFullName(), fmd.getDeclaringMetaData().getSourceFile()));\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.util.UserException;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Localizer.Message;\n+import org.apache.openjpa.lib.log.Log;\n+import serp.bytecode.BCField;\n+import serp.bytecode.BCClass;\n+import serp.bytecode.BCMethod;\n+\n+/**\n+ *\t<p>Validates that a given type meets the JPA contract, plus a few\n+ *  OpenJPA-specific additions for subclassing / redefinition:\n+ *\n+ *\t<ul>\n+ * \t\t<li>must have an accessible no-args constructor</li>\n+ * \t\t<li>must be a public or protected class</li>\n+ * \t\t<li>must not be final</li>\n+ * \t\t<li>must not extend an enhanced class</li>\n+ *\t\t<li>all persistent data represented by accessible setter/getter\n+ * \t\t\tmethods (persistent properties)</li>\n+ * \t\t<li>if versioning is to be used, exactly one persistent property for\n+ * \t\t\tthe numeric version data</li> <!-- ##### is this true? -->\n+ *\n+ * \t\t<li>When using property access, the backing field for a persistent\n+ *          property must be:\n+ * \t\t\t<ul>\n+ * \t\t\t\t<!-- ##### JPA validation of these needs to be tested -->\n+ * \t\t\t\t<li>private</li>\n+ * \t\t\t\t<li>set only in the designated setter,\n+ * \t\t\t\t\tin the constructor, or in {@link Object#clone()},\n+ * \t\t\t\t\t<code>readObject(ObjectInputStream)</code>, or\n+ * \t\t\t\t\t{@link Externalizable#readExternal(ObjectInput)}.</li>\n+ * \t\t\t\t<li>read only in the designated getter and the\n+ * \t\t\t\t\tconstructor.</li>\n+ *\t\t\t</ul>\n+ * \t\t</li>\n+ * \t</ul>\n+ *\n+ * \t<p>If you use this technique and use the <code>new</code> keyword instead of\n+ * \ta OpenJPA-supplied construction routine, OpenJPA will need to do extra work\n+ *  with persistent-new-flushed instances, since OpenJPA cannot in this case\n+ *  track what happens to such an instance.</p>\n+ *\n+ * \t@since 1.0.0\n+ */\n+public class PCSubclassValidator {\n+\n+    private static final Localizer loc =\n+        Localizer.forPackage(PCSubclassValidator.class);\n+\n+    private final ClassMetaData meta;\n+    private final BCClass pc;\n+    private final Log log;\n+    private final boolean failOnContractViolations;\n+\n+    private Collection errors;\n+    private Collection contractViolations;\n+\n+    public PCSubclassValidator(ClassMetaData meta, BCClass bc, Log log,\n+        boolean enforceContractViolations) {\n+        this.meta = meta;\n+        this.pc = bc;\n+        this.log = log;\n+        this.failOnContractViolations = enforceContractViolations;\n+    }\n+\n+    public void assertCanSubclass() {\n+        Class superclass = meta.getDescribedType();\n+        String name = superclass.getName();\n+        if (superclass.isInterface())\n+            addError(loc.get(\"subclasser-no-ifaces\", name), meta);\n+        if (Modifier.isFinal(superclass.getModifiers()))\n+            addError(loc.get(\"subclasser-no-final-classes\", name), meta);\n+        if (Modifier.isPrivate(superclass.getModifiers()))\n+            addError(loc.get(\"subclasser-no-private-classes\", name), meta);\n+        if (PersistenceCapable.class.isAssignableFrom(superclass))\n+            addError(loc.get(\"subclasser-super-already-pc\", name), meta);\n+\n+        try {\n+            Constructor c = superclass.getDeclaredConstructor(new Class[0]);\n+            if (!(Modifier.isProtected(c.getModifiers())\n+                || Modifier.isPublic(c.getModifiers())))\n+                addError(loc.get(\"subclasser-private-ctor\", name), meta);\n+        }\n+        catch (NoSuchMethodException e) {\n+            addError(loc.get(\"subclasser-no-void-ctor\", name),\n+                meta);\n+        }\n+\n+        // if the BCClass we loaded is already pc and the superclass is not,\n+        // then we should never get here, so let's make sure that the\n+        // calling context is caching correctly by throwing an exception.\n+        if (pc.isInstanceOf(PersistenceCapable.class) &&\n+            !PersistenceCapable.class.isAssignableFrom(superclass))\n+            throw new InternalException(\n+                loc.get(\"subclasser-class-already-pc\", name));\n+\n+        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY)\n+            checkPropertiesAreInterceptable();\n+\n+        if (errors != null && !errors.isEmpty())\n+            throw new UserException(errors.toString());\n+        else if (contractViolations != null &&\n+            !contractViolations.isEmpty() && log.isWarnEnabled())\n+            log.warn(contractViolations.toString());\n+    }\n+\n+    private void checkPropertiesAreInterceptable() {\n+        // just considers accessor methods for now.\n+        FieldMetaData[] fmds = meta.getFields();\n+        for (int i = 0; i < fmds.length; i++) {\n+            Method getter = (Method) fmds[i].getBackingMember();\n+            if (getter == null) {\n+                addError(loc.get(\"subclasser-no-getter\",\n+                    fmds[i].getName()), fmds[i]);\n+                continue;\n+            }\n+            BCField returnedField = checkGetterIsSubclassable(getter, fmds[i]);\n+\n+            Method setter = setterForField(fmds[i]);\n+            if (setter == null) {\n+                addError(loc.get(\"subclasser-no-setter\", fmds[i].getName()),\n+                    fmds[i]);\n+                continue;\n+            }\n+            BCField assignedField = checkSetterIsSubclassable(setter, fmds[i]);\n+            if (assignedField == null)\n+                continue;\n+\n+            if (assignedField != returnedField)\n+                addContractViolation(loc.get\n+                    (\"subclasser-setter-getter-field-mismatch\",\n+                        fmds[i].getName(), returnedField,assignedField),\n+                    fmds[i]);\n+\n+            // ### scan through all the rest of the class to make sure it\n+            // ### doesn't use the field.\n+        }\n+    }\n+\n+    private Method setterForField(FieldMetaData fmd) {\n+        try {\n+            return fmd.getDeclaringType().getDeclaredMethod(\n+                \"set\" + StringUtils.capitalize(fmd.getName()),\n+                new Class[]{ fmd.getDeclaredType() });\n+        }\n+        catch (NoSuchMethodException e) {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @return the name of the field that is returned by <code>meth</code>, or\n+     *         <code>null</code> if something other than a single field is\n+     *         returned, or if it cannot be determined what is returned.\n+     */\n+    private BCField checkGetterIsSubclassable(Method meth, FieldMetaData fmd) {\n+        checkMethodIsSubclassable(meth, fmd);\n+        BCField field = PCEnhancer.getReturnedField(getBCMethod(meth));\n+        if (field == null) {\n+            addContractViolation(loc.get(\"subclasser-invalid-getter\",\n+                fmd.getName()), fmd);\n+            return null;\n+        } else {\n+            return field;\n+        }\n+    }\n+\n+    /**\n+     * @return the field that is set in <code>meth</code>, or\n+     *         <code>null</code> if something other than a single field is\n+     *         set, or if it cannot be determined what is set.\n+     */\n+    private BCField checkSetterIsSubclassable(Method meth, FieldMetaData fmd) {\n+        checkMethodIsSubclassable(meth, fmd);\n+        BCField field = PCEnhancer.getAssignedField(getBCMethod(meth));\n+        if (field == null) {\n+            addContractViolation(loc.get(\"subclasser-invalid-setter\",\n+                fmd.getName()), fmd);\n+            return null;\n+        } else {\n+            return field;\n+        }\n+    }\n+\n+    private BCMethod getBCMethod(Method meth) {\n+        BCClass bc = pc.getProject().loadClass(meth.getDeclaringClass());\n+        return bc.getDeclaredMethod(meth.getName(), meth.getParameterTypes());\n+    }\n+\n+    private void checkMethodIsSubclassable(Method meth, FieldMetaData fmd) {\n+        String className = fmd.getDefiningMetaData().\n+            getDescribedType().getName();\n+        if (!(Modifier.isProtected(meth.getModifiers())\n+            || Modifier.isPublic(meth.getModifiers())))\n+            addError(loc.get(\"subclasser-private-accessors-unsupported\",\n+                className, meth.getName()), fmd);\n+        if (Modifier.isFinal(meth.getModifiers()))\n+            addError(loc.get(\"subclasser-final-methods-not-allowed\",\n+                className, meth.getName()), fmd);\n+        if (Modifier.isNative(meth.getModifiers()))\n+            addContractViolation(loc.get\n+                (\"subclasser-native-methods-not-allowed\", className,\n+                    meth.getName()),\n+                fmd);\n+        if (Modifier.isStatic(meth.getModifiers()))\n+            addError(loc.get(\"subclasser-static-methods-not-supported\",\n+                className, meth.getName()), fmd);\n+    }\n+\n+    private void addError(Message s, ClassMetaData cls) {\n+        if (errors == null)\n+            errors = new ArrayList();\n+\n+        errors.add(loc.get(\"subclasser-error-meta\", s,\n+            cls.getDescribedType().getName(),\n+            cls.getSourceFile()));\n+    }\n+\n+    private void addError(Message s, FieldMetaData fmd) {\n+        if (errors == null)\n+            errors = new ArrayList();\n+\n+        errors.add(loc.get(\"subclasser-error-field\", s,\n+            fmd.getFullName(),\n+            fmd.getDeclaringMetaData().getSourceFile()));\n+    }\n+\n+    private void addContractViolation(Message m, FieldMetaData fmd) {\n+        // add the violation as an error in case we're processing violations\n+        // as errors; this keeps them in the order that they were found rather\n+        // than just adding the violations to the end of the list.\n+        if (failOnContractViolations)\n+            addError(m, fmd);\n+\n+        if (contractViolations == null)\n+            contractViolations = new ArrayList();\n+\n+        contractViolations.add(loc.get\n+            (\"subclasser-contract-violation-field\", m.getMessage(),\n+                fmd.getFullName(), fmd.getDeclaringMetaData().getSourceFile()));\n+    }\n+}"},{"sha":"d155a1b530c1c2738b9b3de2b0b445f7f045dd77","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","status":"modified","additions":188,"deletions":188,"changes":376,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,188 +1,188 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.StateManagerImpl;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-\r\n-/**\r\n- * Helper methods for managed types that use method redefinition for field\r\n- * tracking.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class RedefinitionHelper {\r\n-\r\n-    /**\r\n-     * Call {@link StateManagerImpl#dirtyCheck} if the argument is a\r\n-     * {@link StateManagerImpl}.\r\n-     */\r\n-    public static void dirtyCheck(StateManager sm) {\r\n-        if (sm instanceof StateManagerImpl)\r\n-            ((StateManagerImpl) sm).dirtyCheck();\r\n-    }\r\n-\r\n-    /**\r\n-     * Notify the state manager for <code>o</code> (if any) that a field\r\n-     * is about to be accessed.\r\n-     */\r\n-    public static void accessingField(Object o, int absoluteIndex) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.accessingField(absoluteIndex);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, boolean cur,\r\n-        boolean next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingBooleanField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, char cur, char next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingCharField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, byte cur, byte next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingByteField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, short cur, short next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingShortField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, int cur, int next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingIntField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, long cur, long next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingLongField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, float cur, float next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingFloatField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, double cur,\r\n-        double next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingDoubleField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, String cur,\r\n-        String next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingStringField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-\r\n-    /**\r\n-     * Setting state callback.\r\n-     */\r\n-    public static void settingField(Object o, int idx, Object cur,\r\n-        Object next) {\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\r\n-        if (pc == null)\r\n-            return;\r\n-        StateManager sm = pc.pcGetStateManager();\r\n-        if (sm != null)\r\n-            sm.settingObjectField(pc, idx, cur, next,\r\n-                OpenJPAStateManager.SET_USER);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.StateManagerImpl;\n+import org.apache.openjpa.util.ImplHelper;\n+\n+/**\n+ * Helper methods for managed types that use method redefinition for field\n+ * tracking.\n+ *\n+ * @since 1.0.0\n+ */\n+public class RedefinitionHelper {\n+\n+    /**\n+     * Call {@link StateManagerImpl#dirtyCheck} if the argument is a\n+     * {@link StateManagerImpl}.\n+     */\n+    public static void dirtyCheck(StateManager sm) {\n+        if (sm instanceof StateManagerImpl)\n+            ((StateManagerImpl) sm).dirtyCheck();\n+    }\n+\n+    /**\n+     * Notify the state manager for <code>o</code> (if any) that a field\n+     * is about to be accessed.\n+     */\n+    public static void accessingField(Object o, int absoluteIndex) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.accessingField(absoluteIndex);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, boolean cur,\n+        boolean next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingBooleanField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, char cur, char next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingCharField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, byte cur, byte next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingByteField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, short cur, short next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingShortField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, int cur, int next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingIntField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, long cur, long next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingLongField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, float cur, float next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingFloatField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, double cur,\n+        double next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingDoubleField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, String cur,\n+        String next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingStringField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+\n+    /**\n+     * Setting state callback.\n+     */\n+    public static void settingField(Object o, int idx, Object cur,\n+        Object next) {\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(o, null);\n+        if (pc == null)\n+            return;\n+        StateManager sm = pc.pcGetStateManager();\n+        if (sm != null)\n+            sm.settingObjectField(pc, idx, cur, next,\n+                OpenJPAStateManager.SET_USER);\n+    }\n+}"},{"sha":"daf5d060d3c3d6d0d77c4717a8ce420fd9d58def","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","status":"modified","additions":353,"deletions":353,"changes":706,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,353 +1,353 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.lang.reflect.Field;\r\n-import java.lang.reflect.Method;\r\n-\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.util.ApplicationIds;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.ObjectId;\r\n-import org.apache.openjpa.kernel.StateManagerImpl;\r\n-\r\n-/**\r\n- * Implementation of the {@link PersistenceCapable} interface that can handle\r\n- * the persistence-capable contract for instances that were not enhanced\r\n- * before class load time.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class ReflectingPersistenceCapable\r\n-    implements PersistenceCapable, ManagedInstanceProvider {\r\n-\r\n-    private Object o;\r\n-    private StateManager sm;\r\n-    private PersistenceCapable pcSubclassInstance;\r\n-    private ClassMetaData meta;\r\n-\r\n-    public ReflectingPersistenceCapable(Object o, OpenJPAConfiguration conf) {\r\n-        this.o = o;\r\n-        Class type = o.getClass();\r\n-        pcSubclassInstance = PCRegistry.newInstance(type, null, false);\r\n-        meta = conf.getMetaDataRepositoryInstance()\r\n-            .getMetaData(type, null, true);\r\n-    }\r\n-\r\n-    public int pcGetEnhancementContractVersion() {\r\n-        return PCEnhancer.ENHANCER_VERSION;\r\n-    }\r\n-\r\n-    public Object pcGetGenericContext() {\r\n-        if (sm == null)\r\n-            return null;\r\n-        else\r\n-            return sm.getGenericContext();\r\n-    }\r\n-\r\n-    public StateManager pcGetStateManager() {\r\n-        return sm;\r\n-    }\r\n-\r\n-    public void pcReplaceStateManager(StateManager sm) {\r\n-        this.sm = sm;\r\n-    }\r\n-\r\n-    public void pcProvideField(int i) {\r\n-        switch (meta.getField(i).getTypeCode()) {\r\n-            case JavaTypes.BOOLEAN:\r\n-                sm.providedBooleanField(this, i,\r\n-                    ((Boolean) getValue(i, o)).booleanValue());\r\n-                break;\r\n-            case JavaTypes.BYTE:\r\n-                sm.providedByteField(this, i,\r\n-                    ((Byte) getValue(i, o)).byteValue());\r\n-                break;\r\n-            case JavaTypes.CHAR:\r\n-                sm.providedCharField(this, i,\r\n-                    ((Character) getValue(i, o)).charValue());\r\n-                break;\r\n-            case JavaTypes.DOUBLE:\r\n-                sm.providedDoubleField(this, i,\r\n-                    ((Double) getValue(i, o)).doubleValue());\r\n-                break;\r\n-            case JavaTypes.FLOAT:\r\n-                sm.providedFloatField(this, i,\r\n-                    ((Float) getValue(i, o)).floatValue());\r\n-                break;\r\n-            case JavaTypes.INT:\r\n-                sm.providedIntField(this, i,\r\n-                    ((Integer) getValue(i, o)).intValue());\r\n-                break;\r\n-            case JavaTypes.LONG:\r\n-                sm.providedLongField(this, i,\r\n-                    ((Long) getValue(i, o)).longValue());\r\n-                break;\r\n-            case JavaTypes.SHORT:\r\n-                sm.providedShortField(this, i,\r\n-                    ((Short) getValue(i, o)).shortValue());\r\n-                break;\r\n-            case JavaTypes.STRING:\r\n-                sm.providedStringField(this, i,\r\n-                    (String) getValue(i, o));\r\n-                break;\r\n-            default:\r\n-                sm.providedObjectField(this, i, getValue(i, o));\r\n-                break;\r\n-        }\r\n-    }\r\n-\r\n-    public void pcProvideFields(int[] fieldIndices) {\r\n-        for(int i = 0; i < fieldIndices.length; i++)\r\n-            pcProvideField(fieldIndices[i]);\r\n-    }\r\n-\r\n-    public void pcReplaceField(int i) {\r\n-        switch(meta.getField(i).getTypeCode()) {\r\n-            case JavaTypes.BOOLEAN:\r\n-                setValue(i, o, Boolean.valueOf(\r\n-                    sm.replaceBooleanField(this, i)));\r\n-                break;\r\n-            case JavaTypes.BYTE:\r\n-                setValue(i, o, new Byte(sm.replaceByteField(this, i)));\r\n-                break;\r\n-            case JavaTypes.CHAR:\r\n-                setValue(i, o, new Character(sm.replaceCharField(this, i)));\r\n-                break;\r\n-            case JavaTypes.DOUBLE:\r\n-                setValue(i, o, new Double(sm.replaceDoubleField(this, i)));\r\n-                break;\r\n-            case JavaTypes.FLOAT:\r\n-                setValue(i, o, new Float(sm.replaceFloatField(this, i)));\r\n-                break;\r\n-            case JavaTypes.INT:\r\n-                setValue(i, o, new Integer(sm.replaceIntField(this, i)));\r\n-                break;\r\n-            case JavaTypes.LONG:\r\n-                setValue(i, o, new Long(sm.replaceLongField(this, i)));\r\n-                break;\r\n-            case JavaTypes.SHORT:\r\n-                setValue(i, o, new Short(sm.replaceShortField(this, i)));\r\n-                break;\r\n-            case JavaTypes.STRING:\r\n-                setValue(i, o, sm.replaceStringField(this, i));\r\n-                break;\r\n-            default:\r\n-                setValue(i, o, sm.replaceObjectField(this, i));\r\n-                break;\r\n-        }\r\n-    }\r\n-\r\n-    public void pcReplaceFields(int[] fieldIndices) {\r\n-        for(int i = 0; i < fieldIndices.length; i++)\r\n-            pcReplaceField(fieldIndices[i]);\r\n-    }\r\n-\r\n-    public void pcCopyField(Object fromObject, int i) {\r\n-        // this doesn't need switch treatment because we're just\r\n-        // reflecting on both sides, bypassing field managers.\r\n-        setValue(i, o, getValue(i, fromObject));\r\n-    }\r\n-\r\n-    public void pcCopyFields(Object fromObject, int[] fieldIndices) {\r\n-        for(int i = 0; i < fieldIndices.length; i++)\r\n-            pcCopyField(fromObject, fieldIndices[i]);\r\n-    }\r\n-\r\n-    public void pcDirty(String fieldName) {\r\n-        if (sm != null)\r\n-            sm.dirty(fieldName);\r\n-    }\r\n-\r\n-    public Object pcFetchObjectId() {\r\n-        if (sm != null)\r\n-            return sm.fetchObjectId();\r\n-        else\r\n-            return null;\r\n-    }\r\n-\r\n-    public Object pcGetVersion() {\r\n-        if (sm == null)\r\n-            return null;\r\n-        else\r\n-            return sm.getVersion();\r\n-    }\r\n-\r\n-    public boolean pcIsDirty() {\r\n-        if (sm == null)\r\n-            return false;\r\n-        else {\r\n-            if (sm instanceof StateManagerImpl)\r\n-                ((StateManagerImpl) sm).dirtyCheck();\r\n-            return sm.isDirty();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean pcIsTransactional() {\r\n-        if (sm == null)\r\n-            return false;\r\n-        else\r\n-            return sm.isTransactional();\r\n-    }\r\n-\r\n-    public boolean pcIsPersistent() {\r\n-        if (sm == null)\r\n-            return false;\r\n-        else\r\n-            return sm.isPersistent();\r\n-    }\r\n-\r\n-    public boolean pcIsNew() {\r\n-        if (sm == null)\r\n-            return false;\r\n-        else\r\n-            return sm.isNew();\r\n-    }\r\n-\r\n-    public boolean pcIsDeleted() {\r\n-        if (sm == null)\r\n-            return false;\r\n-        else\r\n-            return sm.isDeleted();\r\n-    }\r\n-\r\n-    // null == unknown\r\n-    public Boolean pcIsDetached() {\r\n-        if (sm != null)\r\n-            return Boolean.valueOf(sm.isDetached());\r\n-\r\n-        // ##### we could do a lot more here if a detached state field\r\n-        // ##### was specified.\r\n-        return null;\r\n-    }\r\n-\r\n-    public PersistenceCapable pcNewInstance(StateManager sm, boolean clear) {\r\n-        return pcSubclassInstance.pcNewInstance(sm, clear);\r\n-    }\r\n-\r\n-    public PersistenceCapable pcNewInstance(StateManager sm, Object oid,\r\n-        boolean clear) {\r\n-        return pcSubclassInstance.pcNewInstance(sm, oid, clear);\r\n-    }\r\n-\r\n-    public Object pcNewObjectIdInstance() {\r\n-        FieldMetaData[] pkFields = meta.getPrimaryKeyFields();\r\n-        Object[] pks = new Object[pkFields.length];\r\n-        for (int i = 0; i < pkFields.length; i++)\r\n-            pks[i] = getValue(pkFields[i].getIndex(), o);\r\n-        return ApplicationIds.fromPKValues(pks, meta);\r\n-    }\r\n-    \r\n-    public Object pcNewObjectIdInstance(Object oid) {\r\n-        return pcSubclassInstance.pcNewObjectIdInstance(oid);\r\n-    }\r\n-\r\n-    public void pcCopyKeyFieldsToObjectId(Object oid) {\r\n-        Object target;\r\n-        if (oid instanceof ObjectId)\r\n-            target = ((ObjectId) oid).getId();\r\n-        else\r\n-            target = oid;\r\n-\r\n-        FieldMetaData[] pks = meta.getPrimaryKeyFields();\r\n-        for (int i = 0; i < pks.length; i++) {\r\n-            Object val = getValue(pks[i].getIndex(), o);\r\n-            Field f = Reflection.findField(target.getClass(), pks[i].getName(),\r\n-                true);\r\n-            Reflection.set(target, f, val);\r\n-        }\r\n-    }\r\n-\r\n-    public void pcCopyKeyFieldsToObjectId(FieldSupplier supplier, Object obj) {\r\n-        // This is only ever invoked against PCs in the PCRegistry. Such PCs\r\n-        // will always be enhanced types or subtypes of user types, and will\r\n-        // never be a ReflectingPersistenceCapable.\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public void pcCopyKeyFieldsFromObjectId(FieldConsumer consumer,\r\n-        Object obj) {\r\n-        // This is only ever invoked against PCs in the PCRegistry. Such PCs\r\n-        // will always be enhanced types or subtypes of user types, and will\r\n-        // never be a ReflectingPersistenceCapable.\r\n-        throw new InternalException();\r\n-    }\r\n-\r\n-    public Object pcGetDetachedState() {\r\n-        // ##### we can implement this if a state field has been set\r\n-        return null;\r\n-    }\r\n-\r\n-    public void pcSetDetachedState(Object state) {\r\n-        // StateManagerImpl will invoke this with null during instance\r\n-        // initialization\r\n-        if (state != null)\r\n-            throw new UnsupportedOperationException();\r\n-        // ##### we can implement this if a state field has been set\r\n-    }\r\n-\r\n-    public Object getManagedInstance() {\r\n-        return o;\r\n-    }\r\n-\r\n-    private Object getValue(int i, Object o) {\r\n-        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY) {\r\n-            if (!meta.isIntercepting()) {\r\n-                Method meth = Reflection.findGetter(meta.getDescribedType(),\r\n-                    meta.getField(i).getName(), true);\r\n-                return Reflection.get(o, meth);\r\n-            } else {\r\n-                Field field = Reflection.findField(meta.getDescribedType(),\r\n-                    toFieldName(i), true);\r\n-                return Reflection.get(o, field);\r\n-            }\r\n-        } else {\r\n-            Field field = (Field) meta.getField(i).getBackingMember();\r\n-            return Reflection.get(o, field);\r\n-        }\r\n-    }\r\n-\r\n-    private String toFieldName(int i) {\r\n-        if (pcSubclassInstance instanceof AttributeTranslator)\r\n-            return ((AttributeTranslator) pcSubclassInstance)\r\n-                .pcAttributeIndexToFieldName(i);\r\n-        else\r\n-            return meta.getField(i).getName();\r\n-    }\r\n-\r\n-    private void setValue(int i, Object o, Object val) {\r\n-        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY) {\r\n-            if (!meta.isIntercepting()) {\r\n-                Method meth = Reflection.findSetter(meta.getDescribedType(),\r\n-                    meta.getField(i).getName(), true);\r\n-                Reflection.set(o, meth, val);\r\n-            } else {\r\n-                Field field = Reflection.findField(meta.getDescribedType(),\r\n-                    toFieldName(i), true);\r\n-                Reflection.set(o, field, val);\r\n-            }\r\n-        } else {\r\n-            Field field = (Field) meta.getField(i).getBackingMember();\r\n-            Reflection.set(o, field, val);\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.util.ApplicationIds;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.ObjectId;\n+import org.apache.openjpa.kernel.StateManagerImpl;\n+\n+/**\n+ * Implementation of the {@link PersistenceCapable} interface that can handle\n+ * the persistence-capable contract for instances that were not enhanced\n+ * before class load time.\n+ *\n+ * @since 1.0.0\n+ */\n+public class ReflectingPersistenceCapable\n+    implements PersistenceCapable, ManagedInstanceProvider {\n+\n+    private Object o;\n+    private StateManager sm;\n+    private PersistenceCapable pcSubclassInstance;\n+    private ClassMetaData meta;\n+\n+    public ReflectingPersistenceCapable(Object o, OpenJPAConfiguration conf) {\n+        this.o = o;\n+        Class type = o.getClass();\n+        pcSubclassInstance = PCRegistry.newInstance(type, null, false);\n+        meta = conf.getMetaDataRepositoryInstance()\n+            .getMetaData(type, null, true);\n+    }\n+\n+    public int pcGetEnhancementContractVersion() {\n+        return PCEnhancer.ENHANCER_VERSION;\n+    }\n+\n+    public Object pcGetGenericContext() {\n+        if (sm == null)\n+            return null;\n+        else\n+            return sm.getGenericContext();\n+    }\n+\n+    public StateManager pcGetStateManager() {\n+        return sm;\n+    }\n+\n+    public void pcReplaceStateManager(StateManager sm) {\n+        this.sm = sm;\n+    }\n+\n+    public void pcProvideField(int i) {\n+        switch (meta.getField(i).getTypeCode()) {\n+            case JavaTypes.BOOLEAN:\n+                sm.providedBooleanField(this, i,\n+                    ((Boolean) getValue(i, o)).booleanValue());\n+                break;\n+            case JavaTypes.BYTE:\n+                sm.providedByteField(this, i,\n+                    ((Byte) getValue(i, o)).byteValue());\n+                break;\n+            case JavaTypes.CHAR:\n+                sm.providedCharField(this, i,\n+                    ((Character) getValue(i, o)).charValue());\n+                break;\n+            case JavaTypes.DOUBLE:\n+                sm.providedDoubleField(this, i,\n+                    ((Double) getValue(i, o)).doubleValue());\n+                break;\n+            case JavaTypes.FLOAT:\n+                sm.providedFloatField(this, i,\n+                    ((Float) getValue(i, o)).floatValue());\n+                break;\n+            case JavaTypes.INT:\n+                sm.providedIntField(this, i,\n+                    ((Integer) getValue(i, o)).intValue());\n+                break;\n+            case JavaTypes.LONG:\n+                sm.providedLongField(this, i,\n+                    ((Long) getValue(i, o)).longValue());\n+                break;\n+            case JavaTypes.SHORT:\n+                sm.providedShortField(this, i,\n+                    ((Short) getValue(i, o)).shortValue());\n+                break;\n+            case JavaTypes.STRING:\n+                sm.providedStringField(this, i,\n+                    (String) getValue(i, o));\n+                break;\n+            default:\n+                sm.providedObjectField(this, i, getValue(i, o));\n+                break;\n+        }\n+    }\n+\n+    public void pcProvideFields(int[] fieldIndices) {\n+        for(int i = 0; i < fieldIndices.length; i++)\n+            pcProvideField(fieldIndices[i]);\n+    }\n+\n+    public void pcReplaceField(int i) {\n+        switch(meta.getField(i).getTypeCode()) {\n+            case JavaTypes.BOOLEAN:\n+                setValue(i, o, Boolean.valueOf(\n+                    sm.replaceBooleanField(this, i)));\n+                break;\n+            case JavaTypes.BYTE:\n+                setValue(i, o, new Byte(sm.replaceByteField(this, i)));\n+                break;\n+            case JavaTypes.CHAR:\n+                setValue(i, o, new Character(sm.replaceCharField(this, i)));\n+                break;\n+            case JavaTypes.DOUBLE:\n+                setValue(i, o, new Double(sm.replaceDoubleField(this, i)));\n+                break;\n+            case JavaTypes.FLOAT:\n+                setValue(i, o, new Float(sm.replaceFloatField(this, i)));\n+                break;\n+            case JavaTypes.INT:\n+                setValue(i, o, new Integer(sm.replaceIntField(this, i)));\n+                break;\n+            case JavaTypes.LONG:\n+                setValue(i, o, new Long(sm.replaceLongField(this, i)));\n+                break;\n+            case JavaTypes.SHORT:\n+                setValue(i, o, new Short(sm.replaceShortField(this, i)));\n+                break;\n+            case JavaTypes.STRING:\n+                setValue(i, o, sm.replaceStringField(this, i));\n+                break;\n+            default:\n+                setValue(i, o, sm.replaceObjectField(this, i));\n+                break;\n+        }\n+    }\n+\n+    public void pcReplaceFields(int[] fieldIndices) {\n+        for(int i = 0; i < fieldIndices.length; i++)\n+            pcReplaceField(fieldIndices[i]);\n+    }\n+\n+    public void pcCopyField(Object fromObject, int i) {\n+        // this doesn't need switch treatment because we're just\n+        // reflecting on both sides, bypassing field managers.\n+        setValue(i, o, getValue(i, fromObject));\n+    }\n+\n+    public void pcCopyFields(Object fromObject, int[] fieldIndices) {\n+        for(int i = 0; i < fieldIndices.length; i++)\n+            pcCopyField(fromObject, fieldIndices[i]);\n+    }\n+\n+    public void pcDirty(String fieldName) {\n+        if (sm != null)\n+            sm.dirty(fieldName);\n+    }\n+\n+    public Object pcFetchObjectId() {\n+        if (sm != null)\n+            return sm.fetchObjectId();\n+        else\n+            return null;\n+    }\n+\n+    public Object pcGetVersion() {\n+        if (sm == null)\n+            return null;\n+        else\n+            return sm.getVersion();\n+    }\n+\n+    public boolean pcIsDirty() {\n+        if (sm == null)\n+            return false;\n+        else {\n+            if (sm instanceof StateManagerImpl)\n+                ((StateManagerImpl) sm).dirtyCheck();\n+            return sm.isDirty();\n+        }\n+    }\n+\n+    public boolean pcIsTransactional() {\n+        if (sm == null)\n+            return false;\n+        else\n+            return sm.isTransactional();\n+    }\n+\n+    public boolean pcIsPersistent() {\n+        if (sm == null)\n+            return false;\n+        else\n+            return sm.isPersistent();\n+    }\n+\n+    public boolean pcIsNew() {\n+        if (sm == null)\n+            return false;\n+        else\n+            return sm.isNew();\n+    }\n+\n+    public boolean pcIsDeleted() {\n+        if (sm == null)\n+            return false;\n+        else\n+            return sm.isDeleted();\n+    }\n+\n+    // null == unknown\n+    public Boolean pcIsDetached() {\n+        if (sm != null)\n+            return Boolean.valueOf(sm.isDetached());\n+\n+        // ##### we could do a lot more here if a detached state field\n+        // ##### was specified.\n+        return null;\n+    }\n+\n+    public PersistenceCapable pcNewInstance(StateManager sm, boolean clear) {\n+        return pcSubclassInstance.pcNewInstance(sm, clear);\n+    }\n+\n+    public PersistenceCapable pcNewInstance(StateManager sm, Object oid,\n+        boolean clear) {\n+        return pcSubclassInstance.pcNewInstance(sm, oid, clear);\n+    }\n+\n+    public Object pcNewObjectIdInstance() {\n+        FieldMetaData[] pkFields = meta.getPrimaryKeyFields();\n+        Object[] pks = new Object[pkFields.length];\n+        for (int i = 0; i < pkFields.length; i++)\n+            pks[i] = getValue(pkFields[i].getIndex(), o);\n+        return ApplicationIds.fromPKValues(pks, meta);\n+    }\n+    \n+    public Object pcNewObjectIdInstance(Object oid) {\n+        return pcSubclassInstance.pcNewObjectIdInstance(oid);\n+    }\n+\n+    public void pcCopyKeyFieldsToObjectId(Object oid) {\n+        Object target;\n+        if (oid instanceof ObjectId)\n+            target = ((ObjectId) oid).getId();\n+        else\n+            target = oid;\n+\n+        FieldMetaData[] pks = meta.getPrimaryKeyFields();\n+        for (int i = 0; i < pks.length; i++) {\n+            Object val = getValue(pks[i].getIndex(), o);\n+            Field f = Reflection.findField(target.getClass(), pks[i].getName(),\n+                true);\n+            Reflection.set(target, f, val);\n+        }\n+    }\n+\n+    public void pcCopyKeyFieldsToObjectId(FieldSupplier supplier, Object obj) {\n+        // This is only ever invoked against PCs in the PCRegistry. Such PCs\n+        // will always be enhanced types or subtypes of user types, and will\n+        // never be a ReflectingPersistenceCapable.\n+        throw new InternalException();\n+    }\n+\n+    public void pcCopyKeyFieldsFromObjectId(FieldConsumer consumer,\n+        Object obj) {\n+        // This is only ever invoked against PCs in the PCRegistry. Such PCs\n+        // will always be enhanced types or subtypes of user types, and will\n+        // never be a ReflectingPersistenceCapable.\n+        throw new InternalException();\n+    }\n+\n+    public Object pcGetDetachedState() {\n+        // ##### we can implement this if a state field has been set\n+        return null;\n+    }\n+\n+    public void pcSetDetachedState(Object state) {\n+        // StateManagerImpl will invoke this with null during instance\n+        // initialization\n+        if (state != null)\n+            throw new UnsupportedOperationException();\n+        // ##### we can implement this if a state field has been set\n+    }\n+\n+    public Object getManagedInstance() {\n+        return o;\n+    }\n+\n+    private Object getValue(int i, Object o) {\n+        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY) {\n+            if (!meta.isIntercepting()) {\n+                Method meth = Reflection.findGetter(meta.getDescribedType(),\n+                    meta.getField(i).getName(), true);\n+                return Reflection.get(o, meth);\n+            } else {\n+                Field field = Reflection.findField(meta.getDescribedType(),\n+                    toFieldName(i), true);\n+                return Reflection.get(o, field);\n+            }\n+        } else {\n+            Field field = (Field) meta.getField(i).getBackingMember();\n+            return Reflection.get(o, field);\n+        }\n+    }\n+\n+    private String toFieldName(int i) {\n+        if (pcSubclassInstance instanceof AttributeTranslator)\n+            return ((AttributeTranslator) pcSubclassInstance)\n+                .pcAttributeIndexToFieldName(i);\n+        else\n+            return meta.getField(i).getName();\n+    }\n+\n+    private void setValue(int i, Object o, Object val) {\n+        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY) {\n+            if (!meta.isIntercepting()) {\n+                Method meth = Reflection.findSetter(meta.getDescribedType(),\n+                    meta.getField(i).getName(), true);\n+                Reflection.set(o, meth, val);\n+            } else {\n+                Field field = Reflection.findField(meta.getDescribedType(),\n+                    toFieldName(i), true);\n+                Reflection.set(o, field, val);\n+            }\n+        } else {\n+            Field field = (Field) meta.getField(i).getBackingMember();\n+            Reflection.set(o, field, val);\n+        }\n+    }\n+}"},{"sha":"41848ae2942c0d72bac8123c2663ba6124caaa31","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","status":"modified","additions":31,"deletions":31,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,31 +1,31 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Possible values for the <code>openjpa.RuntimeUnenhancedClasses</code>\r\n- * configuration setting.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface RuntimeUnenhancedClasssesModes {\r\n-    public final static int SUPPORTED = 0;\r\n-    public final static int UNSUPPORTED = 1;\r\n-    public final static int WARN = 2;\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Possible values for the <code>openjpa.RuntimeUnenhancedClasses</code>\n+ * configuration setting.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface RuntimeUnenhancedClasssesModes {\n+    public final static int SUPPORTED = 0;\n+    public final static int UNSUPPORTED = 1;\n+    public final static int WARN = 2;\n+}"},{"sha":"4c2ba87e2c6a9ef03124fb598aae0218f6e25e95","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,56 +1,56 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.event;\r\n-\r\n-import java.util.EventObject;\r\n-\r\n-import org.apache.openjpa.kernel.BrokerFactory;\r\n-\r\n-/**\r\n- * Event fired when a {@link BrokerFactory} is created.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class BrokerFactoryEvent\r\n-    extends EventObject {\r\n-\r\n-    /**\r\n-     * Fired after a {@link BrokerFactory} has been fully created.\r\n-     * This happens after the factory has been made read-only.\r\n-     */\r\n-    public static final int BROKER_FACTORY_CREATED = 0;\r\n-\r\n-    private int eventType;\r\n-\r\n-    public BrokerFactoryEvent(BrokerFactory brokerFactory, int eventType) {\r\n-        super(brokerFactory);\r\n-        this.eventType = eventType;\r\n-    }\r\n-\r\n-    public BrokerFactory getBrokerFactory() {\r\n-        return (BrokerFactory) getSource();\r\n-    }\r\n-\r\n-    /**\r\n-     * @return one of the event type codes defined in this event class.\r\n-     */\r\n-    public int getEventType() {\r\n-        return eventType;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.event;\n+\n+import java.util.EventObject;\n+\n+import org.apache.openjpa.kernel.BrokerFactory;\n+\n+/**\n+ * Event fired when a {@link BrokerFactory} is created.\n+ *\n+ * @since 1.0.0\n+ */\n+public class BrokerFactoryEvent\n+    extends EventObject {\n+\n+    /**\n+     * Fired after a {@link BrokerFactory} has been fully created.\n+     * This happens after the factory has been made read-only.\n+     */\n+    public static final int BROKER_FACTORY_CREATED = 0;\n+\n+    private int eventType;\n+\n+    public BrokerFactoryEvent(BrokerFactory brokerFactory, int eventType) {\n+        super(brokerFactory);\n+        this.eventType = eventType;\n+    }\n+\n+    public BrokerFactory getBrokerFactory() {\n+        return (BrokerFactory) getSource();\n+    }\n+\n+    /**\n+     * @return one of the event type codes defined in this event class.\n+     */\n+    public int getEventType() {\n+        return eventType;\n+    }\n+}"},{"sha":"183e7ebf4084b11e2a3b6588a4bbe9abcccdeb35","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","status":"modified","additions":53,"deletions":53,"changes":106,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,53 +1,53 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.event;\r\n-\r\n-import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-\r\n-/**\r\n- * {@link EventManager} responsible for notifying listeners of\r\n- * {@link BrokerFactoryEvent}s.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class BrokerFactoryEventManager\r\n-    extends AbstractConcurrentEventManager {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage(\r\n-        BrokerFactoryEventManager.class);\r\n-\r\n-    private final Configuration _conf;\r\n-\r\n-    public BrokerFactoryEventManager(Configuration conf) {\r\n-        _conf = conf;\r\n-    }\r\n-\r\n-    protected void fireEvent(Object event, Object listener) {\r\n-        try {\r\n-            BrokerFactoryEvent e = (BrokerFactoryEvent) event;\r\n-            ((BrokerFactoryListener) listener).eventFired(e);\r\n-        } catch (Exception e) {\r\n-            _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME).warn(\r\n-                _loc.get(\"broker-factory-listener-exception\"), e);\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.event;\n+\n+import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+\n+/**\n+ * {@link EventManager} responsible for notifying listeners of\n+ * {@link BrokerFactoryEvent}s.\n+ *\n+ * @since 1.0.0\n+ */\n+public class BrokerFactoryEventManager\n+    extends AbstractConcurrentEventManager {\n+\n+    private static final Localizer _loc = Localizer.forPackage(\n+        BrokerFactoryEventManager.class);\n+\n+    private final Configuration _conf;\n+\n+    public BrokerFactoryEventManager(Configuration conf) {\n+        _conf = conf;\n+    }\n+\n+    protected void fireEvent(Object event, Object listener) {\n+        try {\n+            BrokerFactoryEvent e = (BrokerFactoryEvent) event;\n+            ((BrokerFactoryListener) listener).eventFired(e);\n+        } catch (Exception e) {\n+            _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME).warn(\n+                _loc.get(\"broker-factory-listener-exception\"), e);\n+        }\n+    }\n+}"},{"sha":"35f129c5d49ba00ddd51f06f3bfb309fe75488a8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","status":"modified","additions":35,"deletions":35,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,35 +1,35 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.event;\r\n-\r\n-/**\r\n- * Interface for listening to {@link BrokerFactoryEvent} objects. Should be\r\n- * registered with a {@link OpenJPAConfiguration}'s\r\n- * {@link BrokerFactoryEventManager}.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface BrokerFactoryListener {\r\n-\r\n-    /**\r\n-     * Invoked after a {@link BrokerFactory} has been fully created.\r\n-     * This happens after the factory has been made read-only.\r\n-     */\r\n-    public void eventFired(BrokerFactoryEvent event);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.event;\n+\n+/**\n+ * Interface for listening to {@link BrokerFactoryEvent} objects. Should be\n+ * registered with a {@link OpenJPAConfiguration}'s\n+ * {@link BrokerFactoryEventManager}.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface BrokerFactoryListener {\n+\n+    /**\n+     * Invoked after a {@link BrokerFactory} has been fully created.\n+     * This happens after the factory has been made read-only.\n+     */\n+    public void eventFired(BrokerFactoryEvent event);\n+}"},{"sha":"a0525a0537b3f5e769415a113612e75d39d3d540","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,33 +1,33 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.event;\r\n-\r\n-/**\r\n- * @since 1.1.0\r\n- */\r\n-public interface PostDeleteListener {\r\n-    \r\n-    /**\r\n-     * Receives notifications before an update is performed. Differs from\r\n-     * {@link DeleteListener#afterDelete(LifecycleEvent)} in that the latter\r\n-     * is called after the delete operation, whereas this is called after the\r\n-     * delete statements have been sent to the data store.\r\n-     */\r\n-    public void afterDeletePerformed(LifecycleEvent event);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.event;\n+\n+/**\n+ * @since 1.1.0\n+ */\n+public interface PostDeleteListener {\n+    \n+    /**\n+     * Receives notifications before an update is performed. Differs from\n+     * {@link DeleteListener#afterDelete(LifecycleEvent)} in that the latter\n+     * is called after the delete operation, whereas this is called after the\n+     * delete statements have been sent to the data store.\n+     */\n+    public void afterDeletePerformed(LifecycleEvent event);\n+}"},{"sha":"7af19bb90d32c6ac853a103a4fb374285a9a3383","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,33 +1,33 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.event;\r\n-\r\n-/**\r\n- * @since 1.1.0\r\n- */\r\n-public interface PostPersistListener {\r\n-\r\n-    /**\r\n-     * Receives notifications after a persist operation has been written to the\r\n-     * data store. Differs from {@link PersistListener#afterPersist} in that\r\n-     * the latter is called at the end of the persist() operation itself, not\r\n-     * after the flush.\r\n-     */\r\n-    public void afterPersistPerformed(LifecycleEvent event);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.event;\n+\n+/**\n+ * @since 1.1.0\n+ */\n+public interface PostPersistListener {\n+\n+    /**\n+     * Receives notifications after a persist operation has been written to the\n+     * data store. Differs from {@link PersistListener#afterPersist} in that\n+     * the latter is called at the end of the persist() operation itself, not\n+     * after the flush.\n+     */\n+    public void afterPersistPerformed(LifecycleEvent event);\n+}"},{"sha":"a9f24b061c04bc6b2fa11379e73d520eb16548ad","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,42 +1,42 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.event;\r\n-\r\n-/**\r\n- * @since 1.1.0\r\n- */\r\n-public interface UpdateListener {\r\n-\r\n-    /**\r\n-     * Receives notifications before an update is performed. Differs from\r\n-     * {@link StoreListener#beforeStore} in that the latter is called for\r\n-     * updated and new records, whereas this is only invoked for updated\r\n-     * records.\r\n-     */\r\n-    public void beforeUpdate(LifecycleEvent event);\r\n-\r\n-    /**\r\n-     * Receives notifications before an update is performed. Differs from\r\n-     * {@link StoreListener#afterStore} in that the latter is called for\r\n-     * updated and new records, whereas this is only invoked for updated\r\n-     * records, and that this is called after the record is actually flushed\r\n-     * to the store.\r\n-     */\r\n-    public void afterUpdatePerformed(LifecycleEvent event);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.event;\n+\n+/**\n+ * @since 1.1.0\n+ */\n+public interface UpdateListener {\n+\n+    /**\n+     * Receives notifications before an update is performed. Differs from\n+     * {@link StoreListener#beforeStore} in that the latter is called for\n+     * updated and new records, whereas this is only invoked for updated\n+     * records.\n+     */\n+    public void beforeUpdate(LifecycleEvent event);\n+\n+    /**\n+     * Receives notifications before an update is performed. Differs from\n+     * {@link StoreListener#afterStore} in that the latter is called for\n+     * updated and new records, whereas this is only invoked for updated\n+     * records, and that this is called after the record is actually flushed\n+     * to the store.\n+     */\n+    public void afterUpdatePerformed(LifecycleEvent event);\n+}"},{"sha":"17ad0a7cc696b0191fc734b910f1bacc62498dd3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCData.java","status":"modified","additions":13,"deletions":9,"changes":22,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCData.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCData.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -86,18 +86,22 @@ protected Object toField(OpenJPAStateManager sm, FieldMetaData fmd,\n             case JavaTypes.MAP:\n                 Map m = (Map) data;\n                 Map m2 = (Map) sm.newFieldProxy(fmd.getIndex());\n-                Collection keys = new ArrayList (m.size());\n+                Collection keys = new ArrayList(m.size());\n+                Collection values = new ArrayList(m.size());\n+                Map.Entry e;\n \n-                for (Iterator mi = m.entrySet().iterator(); mi.hasNext();)\n-                    keys.add(mi.next());\n+                Iterator itr = m.entrySet().iterator();\n+                while (itr.hasNext()) {\n+                    e = (Map.Entry) itr.next();\n+                    keys.add(e.getKey());\n+                    values.add(e.getValue());\n+                }\n \n                 Object[] keyArray = keys.toArray();\n-                Object[] values = toNestedFields(sm, fmd.getElement(),\n-                    keys, fetch, context).toArray();\n-                int idx = 0;\n-                for (Iterator mi = m.entrySet().iterator(); mi.hasNext(); idx++)\n-                    m2.put(keyArray[idx], values[idx]);\n-\n+                Object[] valueArray = toNestedFields(sm, fmd.getElement(), values, fetch, context).toArray();\n+                for (int idx = 0; idx < keyArray.length; idx++) {\n+                    m2.put(keyArray[idx], valueArray[idx]);\n+                }\n                 return m2;\n             case JavaTypes.ARRAY:\n                 int length = Array.getLength(data);"},{"sha":"a3963c54e2075d7ffb7ab629e747542dbbbb541b","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":17,"deletions":16,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -29,6 +29,7 @@\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Iterator;\n+import java.util.LinkedHashSet;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n@@ -1465,7 +1466,7 @@ public void setSavepoint(String name) {\n                 _savepoints = new LinkedMap();\n             } else {\n                 if (_savepointCache == null)\n-                    save.save(Collections.EMPTY_LIST);\n+                    save.save(Collections.EMPTY_SET);\n                 else {\n                     save.save(_savepointCache);\n                     _savepointCache.clear();\n@@ -2134,7 +2135,7 @@ protected void endTransaction(int status) {\n         if (hasTransactionalObjects())\n             transStates = _transCache;\n         else\n-            transStates = Collections.EMPTY_LIST;\n+            transStates = Collections.EMPTY_SET;\n \n         // fire after rollback/commit event\n         Collection mobjs = null;\n@@ -2209,7 +2210,7 @@ protected void endTransaction(int status) {\n \n         // now clear trans cache; keep cleared version rather than\n         // null to avoid having to re-create the set later; more efficient\n-        if (transStates != Collections.EMPTY_LIST) {\n+        if (transStates != Collections.EMPTY_SET) {\n             _transCache = (TransactionalCache) transStates;\n             _transCache.clear();\n         }\n@@ -3257,7 +3258,7 @@ public void transactionalAll(Collection objs, boolean updateVersion,\n             Object obj;\n             StateManagerImpl sm;\n             ClassMetaData meta;\n-            Collection sms = new ArrayList(objs.size());\n+            Collection sms = new LinkedHashSet(objs.size());\n             List exceps = null;\n             for (Iterator itr = objs.iterator(); itr.hasNext();) {\n                 obj = itr.next();\n@@ -3580,7 +3581,7 @@ public void lockAll(Collection objs, int level, int timeout,\n         try {\n             assertActiveTransaction();\n \n-            Collection sms = new ArrayList(objs.size());\n+            Collection sms = new LinkedHashSet(objs.size());\n             Object obj;\n             StateManagerImpl sm;\n             for (Iterator itr = objs.iterator(); itr.hasNext();) {\n@@ -3727,7 +3728,7 @@ protected Collection getManagedStates() {\n      */\n     protected Collection getTransactionalStates() {\n         if (!hasTransactionalObjects())\n-            return Collections.EMPTY_LIST;\n+            return Collections.EMPTY_SET;\n         return _transCache.copy();\n     }\n \n@@ -3746,7 +3747,7 @@ private boolean hasTransactionalObjects() {\n      */\n     protected Collection getDirtyStates() {\n         if (!hasTransactionalObjects())\n-            return Collections.EMPTY_LIST;\n+            return Collections.EMPTY_SET;\n \n         return _transCache.copyDirty();\n     }\n@@ -3757,8 +3758,8 @@ protected Collection getDirtyStates() {\n      */\n     protected Collection getPendingTransactionalStates() {\n         if (_pending == null)\n-            return Collections.EMPTY_LIST;\n-        return new ArrayList(_pending);\n+            return Collections.EMPTY_SET;\n+        return new LinkedHashSet(_pending);\n     }\n \n     /**\n@@ -3979,19 +3980,19 @@ public void dirtyType(Class cls) {\n \n     public Collection getPersistedTypes() {\n         if (_persistedClss == null || _persistedClss.isEmpty())\n-            return Collections.EMPTY_LIST;\n+            return Collections.EMPTY_SET;\n         return Collections.unmodifiableCollection(_persistedClss);\n     }\n \n     public Collection getUpdatedTypes() {\n         if (_updatedClss == null || _updatedClss.isEmpty())\n-            return Collections.EMPTY_LIST;\n+            return Collections.EMPTY_SET;\n         return Collections.unmodifiableCollection(_updatedClss);\n     }\n \n     public Collection getDeletedTypes() {\n         if (_deletedClss == null || _deletedClss.isEmpty())\n-            return Collections.EMPTY_LIST;\n+            return Collections.EMPTY_SET;\n         return Collections.unmodifiableCollection(_deletedClss);\n     }\n \n@@ -4641,12 +4642,12 @@ public TransactionalCache(boolean orderDirty) {\n          */\n         public Collection copy() {\n             if (isEmpty())\n-                return Collections.EMPTY_LIST;\n+                return Collections.EMPTY_SET;\n \n             // size may not be entirely accurate due to refs expiring, so\n             // manually copy each object; doesn't matter this way if size too\n             // big by some\n-            List copy = new ArrayList(size());\n+            Set copy = new LinkedHashSet(size());\n             if (_dirty != null)\n                 for (Iterator itr = _dirty.iterator(); itr.hasNext();)\n                     copy.add(itr.next());\n@@ -4661,8 +4662,8 @@ public Collection copy() {\n          */\n         public Collection copyDirty() {\n             if (_dirty == null || _dirty.isEmpty())\n-                return Collections.EMPTY_LIST;\n-            return new ArrayList(_dirty);\n+                return Collections.EMPTY_SET;\n+            return new LinkedHashSet(_dirty);\n         }\n \n         /**"},{"sha":"81f656391df70df010afa5fe2fe19b5d6f657433","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -756,8 +756,12 @@ private void preFlushPC(ValueMetaData vmd, Object obj, boolean logical,\n                     setFailedObject(obj);\n         } else {\n             sm = _broker.getStateManager(obj);\n-            if (sm == null || !sm.isProvisional())\n+            if (sm == null || !sm.isProvisional()) { \n                 sm = _broker.persist(obj, null, true, call);\n+                // ensure generated IDs get assigned properly\n+                if (!logical)\n+                    ((StateManagerImpl)sm).assignObjectId(false, true);\n+            }\n         }\n \n         if (sm != null) {"},{"sha":"4fbbda488acf23ed881736383b7f51aa98db4f10","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -494,7 +494,7 @@ public boolean assignObjectId(boolean flush) {\n      * Ask store manager to assign our oid, optionally flushing and\n      * optionally recaching on the new oid.\n      */\n-    private boolean assignObjectId(boolean flush, boolean preFlushing) {\n+    boolean assignObjectId(boolean flush, boolean preFlushing) {\n         if (_oid != null || isEmbedded() || !isPersistent())\n             return true;\n "},{"sha":"c7a3eaa29d5254d6b2bd0e2c7f38b9c551e89d66","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","status":"modified","additions":216,"deletions":4,"changes":220,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -45,6 +45,7 @@\n import org.apache.openjpa.lib.meta.SourceTracker;\n import org.apache.openjpa.lib.util.J2DoPrivHelper;\n import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Options;\n import org.apache.openjpa.lib.xml.Commentable;\n import org.apache.openjpa.util.BigDecimalId;\n import org.apache.openjpa.util.BigIntegerId;\n@@ -66,6 +67,8 @@\n import org.apache.openjpa.util.ImplHelper;\n import serp.util.Strings;\n \n+import org.apache.openjpa.lib.conf.Configurations;\n+\n /**\n  * Contains metadata about a persistent type.\n  * This metadata is available both at enhancement time and runtime.\n@@ -188,6 +191,11 @@\n     private FetchGroup[] _fgs = null;\n     private FetchGroup[] _customFGs = null;\n     private boolean _intercepting = false;\n+    private boolean _abstract = false;\n+    private Boolean _hasAbstractPKField = null;\n+    private Boolean _hasPKFieldsFromAbstractClass = null;\n+\n+    private Boolean _isCacheable = null; \n \n     /**\n      * Constructor. Supply described type and repository.\n@@ -1327,14 +1335,23 @@ private void resolveDefinedSuperclassFields() {\n     }\n \n     /**\n-     * The name of the datacache to use for this class, or null if none.\n+     * The name of the datacache to use for this class. If this class is not\n+     * eligible for caching based its annotation or the cache configuration\n+     * null will be returned.\n+     * \n+     * @return The cache name, or null if this type should not be cached.\n      */\n     public String getDataCacheName() {\n         if (DEFAULT_STRING.equals(_cacheName)) {\n-            if (_super != null)\n+            if (_super != null) {\n                 _cacheName = getPCSuperclassMetaData().getDataCacheName();\n-            else\n+            }\n+            else {\n                 _cacheName = DataCache.NAME_DEFAULT;\n+            }\n+            if(!isCacheable()) { \n+               _cacheName = null; \n+            }\n         }\n         return _cacheName;\n     }\n@@ -1864,10 +1881,13 @@ private void validateAppIdClass() {\n         if (_super != null) {\n             // concrete superclass oids must match or be parent of ours\n             ClassMetaData sup = getPCSuperclassMetaData();\n-            if (!sup.getObjectIdType().isAssignableFrom(_objectId))\n+            Class objectIdType = sup.getObjectIdType();\n+            if (objectIdType != null &&\n+                !objectIdType.isAssignableFrom(_objectId)) {\n                 throw new MetaDataException(_loc.get(\"id-classes\",\n                     new Object[]{ _type, _objectId, _super,\n                         sup.getObjectIdType() }));\n+            }\n \n             // validate that no other pks are declared if we have a\n             // concrete PC superclass\n@@ -2343,4 +2363,196 @@ public int compare(Object o1, Object o2) {\n \t\t\treturn f1.getListingIndex () - f2.getListingIndex ();\n \t\t}\n \t}\n+\n+    /**\n+     * Determine whether this Type should be included in the DataCache (if one\n+     * is provided) based on the DataCache's configuration.\n+     * \n+     * @return true if the DataCache will accept this type, otherwise false.\n+     */\n+    private boolean isCacheable() {\n+        if (_isCacheable != null) {\n+            return _isCacheable.booleanValue();\n+        }\n+        setIsCacheable(true, false);\n+        return _isCacheable.booleanValue();\n+    }\n+    \n+    /**\n+     * <p>\n+     * Set whether or not the class represented by this ClassMetaData object should be included in the datacache. The\n+     * arguments provided are *hints* as to whether the class should be included in the datacache, and can be overridden\n+     * by the configuration set in openjpa.Datacache.\n+     * </p>\n+     * \n+     * <p>\n+     * Rules for this determination are:\n+     * </p>\n+     * <ol>\n+     * <li>If the class shows up in the list of excluded types, it does not get cached, period.</li>\n+     * <li>If the class does not show up in the excluded types, but the included types field is set (ie, has at least\n+     * one class), then:\n+     * <ol>\n+     * <li>If the class is listed in the include list, then it gets cached</li>\n+     * <li>If the class is set as cacheable by the @Datacache annotation, it gets cached</li>\n+     * <li>If neither a or b are true, then the class does not get cached</li>\n+     * </ol>\n+     * </li>\n+     * <li>If neither the include or exclude lists are defined, then go along with the value passed into the argument,\n+     * which is either the default value (true) or whatever was set with the @Datacache annotation</li>\n+     * </ol>\n+     * \n+     * @param isCacheable\n+     *            Hint whether this class should be included in the datacache. Default behavior is yes, though the\n+     *            @Datacache annotation can specify if it should not be cached.\n+     * @param annotationOverride\n+     *            Whether this hint originated from the @Datacache annotation or whether this is the default \"yes\" hint.\n+     *            The origination of the hint influences the decision making process in rule #2b.\n+     * \n+     */\n+    public void setIsCacheable(boolean isCacheable, boolean annotationOverride) {\n+       Options dataCacheOptions = getDataCacheOptions();\n+       Set excludedTypes = extractDataCacheClassListing(dataCacheOptions.getProperty(\"ExcludedTypes\", null));\n+       Set types = extractDataCacheClassListing(dataCacheOptions.getProperty(\"Types\", null));\n+       \n+       String className = getDescribedType().getName();\n+       if (excludedTypes != null && excludedTypes.contains(className)) {\n+           // Rule #1\n+           _isCacheable = Boolean.FALSE;\n+       } else if (types != null) {\n+           // Rule #2\n+           if ((annotationOverride && isCacheable) || (types.contains(className))) {\n+               _isCacheable = Boolean.TRUE;\n+           } else {\n+               _isCacheable = Boolean.FALSE;\n+           }\n+       } else {\n+           // Rule #3\n+           _isCacheable = isCacheable ? Boolean.TRUE : Boolean.FALSE;\n+       }\n+    }\n+    \n+    /**\n+     * Extract all of the DataCache plugin options from the configuration\n+     * \n+     */\n+    private Options getDataCacheOptions() {\n+       String dataCacheConfig = getRepository().getConfiguration().getDataCache();\n+        Options dataCacheOptions = Configurations.parseProperties(Configurations.getProperties(dataCacheConfig));\n+        return dataCacheOptions;\n+    }\n+    \n+    /**\n+     * Tool to extract classes defined in the datacache include and exclude list into\n+     * individual entries in a Set.\n+     * \n+     */\n+    private final Set extractDataCacheClassListing(String classList) {\n+       if (classList == null || classList.length() == 0) {\n+           return null;\n+       }\n+       \n+       HashSet returnSet = new HashSet();\n+       String[] entries = classList.split(\";\");\n+       for (int index = 0; index < entries.length; index++) {\n+           returnSet.add(entries[index]);\n+       }\n+       return returnSet;\n+    }\n+    \n+    /**\n+     * Returns true if the pcType modeled by this ClassMetaData\n+     * object is abstract (ie, a MappedSuperclass in JPA terms.)\n+     * \n+     * @return\n+     */\n+    public boolean isAbstract() {\n+        return _abstract;\n+    }\n+\n+    /**\n+     * Sets the value determining if the pcType modeled by this\n+     * ClassMetaData object is abstract (ie, a MappedSuperclass in JPA terms.)\n+     * \n+     * @return\n+     */\n+    public void setAbstract(boolean flag) {\n+        _abstract = flag;\n+        _hasAbstractPKField = null;\n+    }\n+\n+    /**\n+     * Convenience method to determine if the pcType modeled by\n+     * this ClassMetaData object is both abstract and declares PKFields. This\n+     * method is used by the PCEnhancer to determine if special handling is\n+     * required.\n+     * \n+     * @return\n+     */\n+    public boolean hasAbstractPKField() {\n+        if (_hasAbstractPKField != null) {\n+            return _hasAbstractPKField.booleanValue();\n+        }\n+\n+        // Default to false, set to true only if this type is abstract and\n+        // declares a PKField.\n+        _hasAbstractPKField = Boolean.FALSE;\n+\n+        if (isAbstract() == true) {\n+            FieldMetaData[] declaredFields = getDeclaredFields();\n+            if (declaredFields != null && declaredFields.length != 0) {\n+                for(int i = 0 ; i < declaredFields.length; i ++) {\n+                    if (declaredFields[i].isPrimaryKey()) {\n+                        _hasAbstractPKField = Boolean.TRUE;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        return _hasAbstractPKField.booleanValue();\n+    }\n+\n+    /**\n+     * Convenience method to determine if this type is a direct\n+     * decendent of an abstract type declaring PKFields. Returns true if there\n+     * are no pcTypes mapped to a table between this type and an abstract pcType\n+     * declaring PKFields. Returns false if there no such abstract pcTypes in\n+     * the inheritance hierarchy or if there are any pcTypes mapped to tables in\n+     * between the type represented by this ClassMetaData object and the\n+     * abstract pcType declaring PKFields.\n+     * \n+     * @return\n+     */\n+    public boolean hasPKFieldsFromAbstractClass() {\n+        if (_hasPKFieldsFromAbstractClass != null) {\n+            return _hasPKFieldsFromAbstractClass.booleanValue();\n+        }\n+\n+        // Default to FALSE, until proven true.\n+        _hasPKFieldsFromAbstractClass = Boolean.FALSE;\n+\n+        FieldMetaData[] pkFields = getPrimaryKeyFields();\n+        FieldMetaData fmd; \n+        for(int i = 0 ; i < pkFields.length; i++) { \n+            fmd = pkFields[i];\n+            ClassMetaData fmdDMDA = fmd.getDeclaringMetaData();\n+            if (fmdDMDA.isAbstract()) {\n+                ClassMetaData cmd = getPCSuperclassMetaData();\n+                while (cmd != fmdDMDA) {\n+                    if (fmdDMDA.isAbstract()) {\n+                        cmd = cmd.getPCSuperclassMetaData();\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                if (cmd == fmdDMDA) {\n+                    _hasPKFieldsFromAbstractClass = Boolean.TRUE;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return _hasPKFieldsFromAbstractClass.booleanValue();\n+    }\n }"},{"sha":"d84345fea6d8e158bdf595d852c9611bf91d8920","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","status":"modified","additions":388,"deletions":388,"changes":776,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,388 +1,388 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.meta;\r\n-\r\n-import java.io.Serializable;\r\n-import java.util.ArrayList;\r\n-import java.util.Collections;\r\n-import java.util.HashMap;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.commons.lang.ObjectUtils;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.MetaDataException;\r\n-import serp.util.Numbers;\r\n-\r\n-/**\r\n- * Captures fetch group metadata.\r\n- */\r\n-public class FetchGroup \r\n-    implements Serializable {\r\n-\r\n-    /**\r\n-     * Name of the default fetch group.\r\n-     */\r\n-    public static final String NAME_DEFAULT = \"default\";\r\n-\r\n-    /**\r\n-     * Name of the \"all\" fetch group.\r\n-     */\r\n-    public static final String NAME_ALL = \"all\";\r\n-\r\n-    /**\r\n-     * Default field recursion depth.\r\n-     */\r\n-    public static final int RECURSION_DEPTH_DEFAULT = 1;\r\n-\r\n-    /**\r\n-     * Infinite depth.\r\n-     */\r\n-\tpublic static final int DEPTH_INFINITE = -1;\r\n-\r\n-    /**\r\n-     *  Standard default fetch group.\r\n-     */\r\n-    static final FetchGroup DEFAULT = new FetchGroup(NAME_DEFAULT, true);\r\n-\r\n-    /**\r\n-     *  Standard \"all\" fetch group.\r\n-     */\r\n-    static final FetchGroup ALL = new FetchGroup(NAME_ALL, false);\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (FetchGroup.class);\r\n-\r\n-    private final String _name;\r\n-    private final ClassMetaData _meta;\r\n-    private final boolean _readOnly;\r\n-    private List _includes;\r\n-    private Set  _containedBy;\r\n-    private Map _depths;\r\n-    private Boolean _postLoad;\r\n-\r\n-    /**\r\n-     * Constructor; supply immutable name.\r\n-     *\r\n-     * @param name must not by null or empty.\r\n-     */\r\n-    FetchGroup(ClassMetaData cm, String name) {\r\n-        _meta = cm;\r\n-        _name = name;\r\n-        _readOnly = false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Internal constructor for builtin fetch groups.\r\n-     */\r\n-    private FetchGroup(String name, boolean postLoad) {\r\n-        _meta = null;\r\n-        _name = name;\r\n-        _postLoad = (postLoad) ? Boolean.TRUE : Boolean.FALSE;\r\n-        _readOnly = true;\r\n-    }\r\n-\r\n-    /**\r\n-     * Copy state from the given fetch group.\r\n-     */\r\n-    void copy(FetchGroup fg) {\r\n-        if (fg._includes != null)\r\n-            for (Iterator itr = fg._includes.iterator(); itr.hasNext();)\r\n-                addDeclaredInclude((String) itr.next());\r\n-        if (fg._containedBy != null) \r\n-        \tthis._containedBy = new HashSet(fg._containedBy);\r\n-        \r\n-        if (fg._depths != null) {\r\n-            Map.Entry entry;\r\n-            for (Iterator itr = fg._depths.entrySet().iterator(); \r\n-                itr.hasNext();) {\r\n-                entry = (Map.Entry) itr.next();\r\n-                setRecursionDepth((FieldMetaData) entry.getKey(), ((Number) \r\n-                    entry.getValue()).intValue());\r\n-            }\r\n-        }\r\n-        if (fg._postLoad != null)\r\n-            _postLoad = fg._postLoad;\r\n-    }\r\n-\r\n-    /**\r\n-     * Fetch group name.\r\n-     */\r\n-    public String getName() {\r\n-        return _name;\r\n-    }\r\n-\r\n-    /**\r\n-     * Includes given fetch group within this receiver.\r\n-     */\r\n-    public void addDeclaredInclude(String fgName) {\r\n-        if (_readOnly)\r\n-            throw new UnsupportedOperationException();\r\n-        if (StringUtils.isEmpty(fgName))\r\n-            throw new MetaDataException(_loc.get(\"null-include-fg\", this));\r\n-        if (_includes == null)\r\n-            _includes = new ArrayList();\r\n-        if (!_includes.contains(fgName))\r\n-            _includes.add(fgName);\r\n-    }\r\n-\r\n-    /**\r\n-     * Affirms if given fetch group is included by this receiver.  Includes\r\n-     * superclass definition of fetch group and optionally other included \r\n-     * groups.\r\n-     *\r\n-     * @param recurse if true then recursively checks within the included\r\n-     * fecth groups\r\n-     */\r\n-    public boolean includes(String fgName, boolean recurse) {\r\n-        // check our includes\r\n-        if (_includes != null) {\r\n-            if (_includes.contains(fgName))\r\n-                return true;\r\n-            if (recurse && _meta!=null) {\r\n-                FetchGroup fg;\r\n-                for (Iterator i = _includes.iterator(); i.hasNext();) {\r\n-                    fg = _meta.getFetchGroup((String) i.next());\r\n-                    if (fg != null && fg.includes(fgName, true))\r\n-                        return true;\r\n-                }\r\n-            }\r\n-        }\r\n-        if (_meta != null) {\r\n-            // check superclass includes\r\n-            ClassMetaData sup = _meta.getPCSuperclassMetaData();\r\n-            if (sup != null) {\r\n-                FetchGroup supFG = sup.getFetchGroup(_name);\r\n-                if (supFG != null)\r\n-                    return supFG.includes(fgName, recurse);\r\n-            }\r\n-        }\r\n-        return false;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Adds this receiver as one of the included fetch groups of the given\r\n-     * parent. \r\n-     * The parent fecth group will include this receiver as a side-effect of\r\n-     * this call.\r\n-     * \r\n-     * @see #includes(String, boolean)\r\n-     * @see #addDeclaredInclude(String) \r\n-     * \r\n-     * @return true if given parent is a new addition. false othrwise.\r\n-     * @since 1.1.1   \r\n-     */\r\n-    public boolean addContainedBy(FetchGroup parent) {\r\n-    \tparent.addDeclaredInclude(this.getName());\r\n-    \tif (_containedBy==null)\r\n-    \t\t_containedBy = new HashSet();\r\n-    \treturn _containedBy.add(parent.getName());\r\n-    }\r\n-    \r\n-    /**\r\n-     * Gets the name of the fetch groups in which this receiver has been\r\n-     * included.\r\n-     * \r\n-     * @see #addContainedBy(FetchGroup)\r\n-     * @since 1.1.1   \r\n-     */\r\n-    public Set getContainedBy() {\r\n-    \treturn (_containedBy == null) ? Collections.EMPTY_SET :\r\n-            Collections.unmodifiableSet(_containedBy);\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the fetch group names declared included by this group.\r\n-     */\r\n-    public String[] getDeclaredIncludes() {\r\n-        // only used during serialization; no need to cache\r\n-        return (_includes == null) ? new String[0]\r\n-            : (String[]) _includes.toArray(new String[_includes.size()]);\r\n-    }\r\n-\r\n-    /**\r\n-     * Recursion depth for the given field.  This is the depth of relations of\r\n-     * the same class as this one we can fetch through the given field.\r\n-     */\r\n-    public void setRecursionDepth(FieldMetaData fm, int depth) {\r\n-        if (_readOnly)\r\n-            throw new UnsupportedOperationException();\r\n-        if (depth < -1)\r\n-            throw new MetaDataException(_loc.get(\"invalid-fg-depth\", _name, fm, \r\n-                Numbers.valueOf(depth)));\r\n-        if (_depths == null)\r\n-            _depths = new HashMap();\r\n-        _depths.put(fm, Numbers.valueOf(depth));\r\n-    }\r\n-\r\n-    /**\r\n-     * Recursion depth for the given field.  This is the depth of relations of\r\n-     * the same class as this one we can fetch through the given field.\r\n-     */\r\n-    public int getRecursionDepth(FieldMetaData fm) {\r\n-        Number depth = findRecursionDepth(fm);\r\n-        return (depth == null) ? RECURSION_DEPTH_DEFAULT : depth.intValue();\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the recursion depth declared for the given field, or \r\n-     * 0 if none.\r\n-     */\r\n-    public int getDeclaredRecursionDepth(FieldMetaData fm) {\r\n-        Number depth = (_depths == null) ? null : (Number) _depths.get(fm);\r\n-        return (depth == null) ? 0 : depth.intValue();\r\n-    }\r\n-\r\n-    /**\r\n-     * Helper to find recursion depth recursively in our includes.\r\n-     */\r\n-    private Number findRecursionDepth(FieldMetaData fm) { \r\n-        Number depth = (_depths == null) ? null : (Number) _depths.get(fm);\r\n-        if (depth != null)\r\n-            return depth;\r\n-\r\n-        // check for superclass declaration of depth\r\n-        Number max = null;\r\n-        if (_meta != null && fm.getDeclaringMetaData() != _meta) {\r\n-            ClassMetaData sup = _meta.getPCSuperclassMetaData();\r\n-            if (sup != null) {\r\n-                FetchGroup supFG = sup.getFetchGroup(_name);\r\n-                if (supFG != null)\r\n-                    max = supFG.findRecursionDepth(fm);\r\n-            }\r\n-        }\r\n-        if (_includes == null)\r\n-            return max;\r\n-\r\n-        // find largest included depth\r\n-        FetchGroup fg;\r\n-        for (Iterator itr = _includes.iterator(); itr.hasNext();) {\r\n-            fg = _meta.getFetchGroup((String) itr.next());\r\n-            depth = (fg == null) ? null : fg.findRecursionDepth(fm);\r\n-            if (depth != null && (max == null \r\n-                || depth.intValue() > max.intValue()))\r\n-                max = depth;\r\n-        }\r\n-        return max;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the fields with declared recursion depths in this group.\r\n-     */\r\n-    public FieldMetaData[] getDeclaredRecursionDepthFields() {\r\n-        // used in serialization only; no need to cache\r\n-        if (_depths == null)\r\n-            return new FieldMetaData[0];\r\n-         return (FieldMetaData[]) _depths.keySet().toArray\r\n-            (new FieldMetaData[_depths.size()]);\r\n-    } \r\n-\r\n-    /**\r\n-     * Whether loading this fetch group causes a post-load callback on the\r\n-     * loaded instance.\r\n-     */\r\n-    public void setPostLoad (boolean flag) {\r\n-        if (_readOnly && flag != isPostLoad())\r\n-            throw new UnsupportedOperationException();\r\n-    \t_postLoad = (flag) ? Boolean.TRUE : Boolean.FALSE;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether loading this fetch group causes a post-load callback on the\r\n-     * loaded instance.\r\n-     */\r\n-    public boolean isPostLoad () {\r\n-    \tif (_postLoad != null)\r\n-            return _postLoad.booleanValue();\r\n-\r\n-        if (_meta != null) {\r\n-            ClassMetaData sup = _meta.getPCSuperclassMetaData();\r\n-            if (sup != null) {\r\n-                FetchGroup supFG = sup.getFetchGroup(_name);\r\n-                if (supFG != null && supFG.isPostLoad())\r\n-                    return true;\r\n-            }\r\n-        }\r\n-\r\n-        if (_includes == null)\r\n-            return false;\r\n-        FetchGroup fg;\r\n-        for (Iterator itr = _includes.iterator(); itr.hasNext();) {\r\n-            fg = _meta.getFetchGroup((String) itr.next());\r\n-            if (fg != null && fg.isPostLoad())\r\n-                return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether the post-load value is declared for this group.  \r\n-     */\r\n-    public boolean isPostLoadExplicit() {\r\n-        return _postLoad != null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Resolve and validate fetch group metadata.\r\n-     */\r\n-    public void resolve() {\r\n-        if (_includes == null)\r\n-            return;\r\n-\r\n-        // validate includes\r\n-        String name;\r\n-        FetchGroup fg;\r\n-        for (Iterator itr = _includes.iterator(); itr.hasNext();) {\r\n-            name = (String) itr.next();\r\n-            if (name.equals(_name))\r\n-                throw new MetaDataException(_loc.get(\"cyclic-fg\", this, name));\r\n-            fg = _meta.getFetchGroup(name);\r\n-            if (fg == null)\r\n-                throw new MetaDataException(_loc.get(\"bad-fg-include\", this,\r\n-                    name));\r\n-            if (fg.includes(_name, true))\r\n-                throw new MetaDataException(_loc.get(\"cyclic-fg\", this, name));\r\n-        }\r\n-    }\r\n-    \r\n-    /**\r\n-     * Affirms equality if the other has the same name and declaring type.\r\n-     */\r\n-    public boolean equals(Object other) {\r\n-        if (other == this)\r\n-            return true;\r\n-        if (!(other instanceof FetchGroup))\r\n-            return false;\r\n-        FetchGroup that = (FetchGroup) other;\r\n-        return _name.equals(that._name)\r\n-            && ObjectUtils.equals(_meta, that._meta);\r\n-    }\r\n-\r\n-    public int hashCode() {\r\n-        return _name.hashCode() + ((_meta == null) ? 0 : _meta.hashCode());\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        return ((_meta == null) ? \"Builtin\" : _meta.toString ()) + \".\" + _name;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.lang.ObjectUtils;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.MetaDataException;\n+import serp.util.Numbers;\n+\n+/**\n+ * Captures fetch group metadata.\n+ */\n+public class FetchGroup \n+    implements Serializable {\n+\n+    /**\n+     * Name of the default fetch group.\n+     */\n+    public static final String NAME_DEFAULT = \"default\";\n+\n+    /**\n+     * Name of the \"all\" fetch group.\n+     */\n+    public static final String NAME_ALL = \"all\";\n+\n+    /**\n+     * Default field recursion depth.\n+     */\n+    public static final int RECURSION_DEPTH_DEFAULT = 1;\n+\n+    /**\n+     * Infinite depth.\n+     */\n+\tpublic static final int DEPTH_INFINITE = -1;\n+\n+    /**\n+     *  Standard default fetch group.\n+     */\n+    static final FetchGroup DEFAULT = new FetchGroup(NAME_DEFAULT, true);\n+\n+    /**\n+     *  Standard \"all\" fetch group.\n+     */\n+    static final FetchGroup ALL = new FetchGroup(NAME_ALL, false);\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (FetchGroup.class);\n+\n+    private final String _name;\n+    private final ClassMetaData _meta;\n+    private final boolean _readOnly;\n+    private List _includes;\n+    private Set  _containedBy;\n+    private Map _depths;\n+    private Boolean _postLoad;\n+\n+    /**\n+     * Constructor; supply immutable name.\n+     *\n+     * @param name must not by null or empty.\n+     */\n+    FetchGroup(ClassMetaData cm, String name) {\n+        _meta = cm;\n+        _name = name;\n+        _readOnly = false;\n+    }\n+\n+    /**\n+     * Internal constructor for builtin fetch groups.\n+     */\n+    private FetchGroup(String name, boolean postLoad) {\n+        _meta = null;\n+        _name = name;\n+        _postLoad = (postLoad) ? Boolean.TRUE : Boolean.FALSE;\n+        _readOnly = true;\n+    }\n+\n+    /**\n+     * Copy state from the given fetch group.\n+     */\n+    void copy(FetchGroup fg) {\n+        if (fg._includes != null)\n+            for (Iterator itr = fg._includes.iterator(); itr.hasNext();)\n+                addDeclaredInclude((String) itr.next());\n+        if (fg._containedBy != null) \n+        \tthis._containedBy = new HashSet(fg._containedBy);\n+        \n+        if (fg._depths != null) {\n+            Map.Entry entry;\n+            for (Iterator itr = fg._depths.entrySet().iterator(); \n+                itr.hasNext();) {\n+                entry = (Map.Entry) itr.next();\n+                setRecursionDepth((FieldMetaData) entry.getKey(), ((Number) \n+                    entry.getValue()).intValue());\n+            }\n+        }\n+        if (fg._postLoad != null)\n+            _postLoad = fg._postLoad;\n+    }\n+\n+    /**\n+     * Fetch group name.\n+     */\n+    public String getName() {\n+        return _name;\n+    }\n+\n+    /**\n+     * Includes given fetch group within this receiver.\n+     */\n+    public void addDeclaredInclude(String fgName) {\n+        if (_readOnly)\n+            throw new UnsupportedOperationException();\n+        if (StringUtils.isEmpty(fgName))\n+            throw new MetaDataException(_loc.get(\"null-include-fg\", this));\n+        if (_includes == null)\n+            _includes = new ArrayList();\n+        if (!_includes.contains(fgName))\n+            _includes.add(fgName);\n+    }\n+\n+    /**\n+     * Affirms if given fetch group is included by this receiver.  Includes\n+     * superclass definition of fetch group and optionally other included \n+     * groups.\n+     *\n+     * @param recurse if true then recursively checks within the included\n+     * fecth groups\n+     */\n+    public boolean includes(String fgName, boolean recurse) {\n+        // check our includes\n+        if (_includes != null) {\n+            if (_includes.contains(fgName))\n+                return true;\n+            if (recurse && _meta!=null) {\n+                FetchGroup fg;\n+                for (Iterator i = _includes.iterator(); i.hasNext();) {\n+                    fg = _meta.getFetchGroup((String) i.next());\n+                    if (fg != null && fg.includes(fgName, true))\n+                        return true;\n+                }\n+            }\n+        }\n+        if (_meta != null) {\n+            // check superclass includes\n+            ClassMetaData sup = _meta.getPCSuperclassMetaData();\n+            if (sup != null) {\n+                FetchGroup supFG = sup.getFetchGroup(_name);\n+                if (supFG != null)\n+                    return supFG.includes(fgName, recurse);\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * Adds this receiver as one of the included fetch groups of the given\n+     * parent. \n+     * The parent fecth group will include this receiver as a side-effect of\n+     * this call.\n+     * \n+     * @see #includes(String, boolean)\n+     * @see #addDeclaredInclude(String) \n+     * \n+     * @return true if given parent is a new addition. false othrwise.\n+     * @since 1.1.1   \n+     */\n+    public boolean addContainedBy(FetchGroup parent) {\n+    \tparent.addDeclaredInclude(this.getName());\n+    \tif (_containedBy==null)\n+    \t\t_containedBy = new HashSet();\n+    \treturn _containedBy.add(parent.getName());\n+    }\n+    \n+    /**\n+     * Gets the name of the fetch groups in which this receiver has been\n+     * included.\n+     * \n+     * @see #addContainedBy(FetchGroup)\n+     * @since 1.1.1   \n+     */\n+    public Set getContainedBy() {\n+    \treturn (_containedBy == null) ? Collections.EMPTY_SET :\n+            Collections.unmodifiableSet(_containedBy);\n+    }\n+\n+    /**\n+     * Return the fetch group names declared included by this group.\n+     */\n+    public String[] getDeclaredIncludes() {\n+        // only used during serialization; no need to cache\n+        return (_includes == null) ? new String[0]\n+            : (String[]) _includes.toArray(new String[_includes.size()]);\n+    }\n+\n+    /**\n+     * Recursion depth for the given field.  This is the depth of relations of\n+     * the same class as this one we can fetch through the given field.\n+     */\n+    public void setRecursionDepth(FieldMetaData fm, int depth) {\n+        if (_readOnly)\n+            throw new UnsupportedOperationException();\n+        if (depth < -1)\n+            throw new MetaDataException(_loc.get(\"invalid-fg-depth\", _name, fm, \n+                Numbers.valueOf(depth)));\n+        if (_depths == null)\n+            _depths = new HashMap();\n+        _depths.put(fm, Numbers.valueOf(depth));\n+    }\n+\n+    /**\n+     * Recursion depth for the given field.  This is the depth of relations of\n+     * the same class as this one we can fetch through the given field.\n+     */\n+    public int getRecursionDepth(FieldMetaData fm) {\n+        Number depth = findRecursionDepth(fm);\n+        return (depth == null) ? RECURSION_DEPTH_DEFAULT : depth.intValue();\n+    }\n+\n+    /**\n+     * Return the recursion depth declared for the given field, or \n+     * 0 if none.\n+     */\n+    public int getDeclaredRecursionDepth(FieldMetaData fm) {\n+        Number depth = (_depths == null) ? null : (Number) _depths.get(fm);\n+        return (depth == null) ? 0 : depth.intValue();\n+    }\n+\n+    /**\n+     * Helper to find recursion depth recursively in our includes.\n+     */\n+    private Number findRecursionDepth(FieldMetaData fm) { \n+        Number depth = (_depths == null) ? null : (Number) _depths.get(fm);\n+        if (depth != null)\n+            return depth;\n+\n+        // check for superclass declaration of depth\n+        Number max = null;\n+        if (_meta != null && fm.getDeclaringMetaData() != _meta) {\n+            ClassMetaData sup = _meta.getPCSuperclassMetaData();\n+            if (sup != null) {\n+                FetchGroup supFG = sup.getFetchGroup(_name);\n+                if (supFG != null)\n+                    max = supFG.findRecursionDepth(fm);\n+            }\n+        }\n+        if (_includes == null)\n+            return max;\n+\n+        // find largest included depth\n+        FetchGroup fg;\n+        for (Iterator itr = _includes.iterator(); itr.hasNext();) {\n+            fg = _meta.getFetchGroup((String) itr.next());\n+            depth = (fg == null) ? null : fg.findRecursionDepth(fm);\n+            if (depth != null && (max == null \n+                || depth.intValue() > max.intValue()))\n+                max = depth;\n+        }\n+        return max;\n+    }\n+\n+    /**\n+     * Return the fields with declared recursion depths in this group.\n+     */\n+    public FieldMetaData[] getDeclaredRecursionDepthFields() {\n+        // used in serialization only; no need to cache\n+        if (_depths == null)\n+            return new FieldMetaData[0];\n+         return (FieldMetaData[]) _depths.keySet().toArray\n+            (new FieldMetaData[_depths.size()]);\n+    } \n+\n+    /**\n+     * Whether loading this fetch group causes a post-load callback on the\n+     * loaded instance.\n+     */\n+    public void setPostLoad (boolean flag) {\n+        if (_readOnly && flag != isPostLoad())\n+            throw new UnsupportedOperationException();\n+    \t_postLoad = (flag) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    /**\n+     * Whether loading this fetch group causes a post-load callback on the\n+     * loaded instance.\n+     */\n+    public boolean isPostLoad () {\n+    \tif (_postLoad != null)\n+            return _postLoad.booleanValue();\n+\n+        if (_meta != null) {\n+            ClassMetaData sup = _meta.getPCSuperclassMetaData();\n+            if (sup != null) {\n+                FetchGroup supFG = sup.getFetchGroup(_name);\n+                if (supFG != null && supFG.isPostLoad())\n+                    return true;\n+            }\n+        }\n+\n+        if (_includes == null)\n+            return false;\n+        FetchGroup fg;\n+        for (Iterator itr = _includes.iterator(); itr.hasNext();) {\n+            fg = _meta.getFetchGroup((String) itr.next());\n+            if (fg != null && fg.isPostLoad())\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Whether the post-load value is declared for this group.  \n+     */\n+    public boolean isPostLoadExplicit() {\n+        return _postLoad != null;\n+    }\n+\n+    /**\n+     * Resolve and validate fetch group metadata.\n+     */\n+    public void resolve() {\n+        if (_includes == null)\n+            return;\n+\n+        // validate includes\n+        String name;\n+        FetchGroup fg;\n+        for (Iterator itr = _includes.iterator(); itr.hasNext();) {\n+            name = (String) itr.next();\n+            if (name.equals(_name))\n+                throw new MetaDataException(_loc.get(\"cyclic-fg\", this, name));\n+            fg = _meta.getFetchGroup(name);\n+            if (fg == null)\n+                throw new MetaDataException(_loc.get(\"bad-fg-include\", this,\n+                    name));\n+            if (fg.includes(_name, true))\n+                throw new MetaDataException(_loc.get(\"cyclic-fg\", this, name));\n+        }\n+    }\n+    \n+    /**\n+     * Affirms equality if the other has the same name and declaring type.\n+     */\n+    public boolean equals(Object other) {\n+        if (other == this)\n+            return true;\n+        if (!(other instanceof FetchGroup))\n+            return false;\n+        FetchGroup that = (FetchGroup) other;\n+        return _name.equals(that._name)\n+            && ObjectUtils.equals(_meta, that._meta);\n+    }\n+\n+    public int hashCode() {\n+        return _name.hashCode() + ((_meta == null) ? 0 : _meta.hashCode());\n+    }\n+\n+    public String toString() {\n+        return ((_meta == null) ? \"Builtin\" : _meta.toString ()) + \".\" + _name;\n+    }\n+}"},{"sha":"0b9231b879e86c3403d5025eeeb5cdd63da35f99","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceComparator.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceComparator.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceComparator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceComparator.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -30,7 +30,7 @@\n public class InheritanceComparator\n     implements Comparator, Serializable {\n \n-    private Class _base = null;\n+    private Class _base = Object.class;\n \n     /**\n      * Set the least-derived type possible; defaults to <code>null</code>.\n@@ -39,6 +39,10 @@ public void setBase(Class base) {\n         _base = base;\n     }\n \n+    public Class getBase() {\n+        return _base;\n+    }\n+\n     /**\n      * Subclasses can override this method to extract the class to compare\n      * on from the elements of the collection."},{"sha":"c67c9cd0b3e4225681ee153472d19cdc90b15ac1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceOrderedMetaDataList.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceOrderedMetaDataList.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceOrderedMetaDataList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/InheritanceOrderedMetaDataList.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.ListIterator;\n+import java.io.Serializable;\n+\n+public class InheritanceOrderedMetaDataList\n+    implements Serializable {\n+\n+    private MetaDataInheritanceComparator _comp\n+        = new MetaDataInheritanceComparator();\n+    private LinkedList buffer = new LinkedList();\n+\n+    public boolean add(ClassMetaData meta) {\n+        if (meta == null || buffer.contains(meta))\n+            return false;\n+        for (ListIterator itr = buffer.listIterator();\n+            itr.hasNext();) {\n+            int ord = _comp.compare(meta, (ClassMetaData) itr.next());\n+            if (ord > 0)\n+                continue;\n+            if (ord == 0)\n+                return false;\n+            itr.previous();\n+            itr.add(meta);\n+            return true;\n+        }\n+        buffer.add(meta);\n+        return true;\n+    }\n+\n+    public boolean remove(ClassMetaData meta) {\n+        return buffer.remove(meta);\n+    }\n+\n+    public ClassMetaData peek() {\n+        return (ClassMetaData) buffer.getFirst();\n+    }\n+    \n+    public int size() {\n+        return buffer.size();\n+    }\n+    \n+    public Iterator iterator() {\n+        return buffer.iterator();\n+    }\n+    \n+    public boolean isEmpty() {\n+        return buffer.isEmpty();\n+    }\n+    \n+    public void clear() {\n+        buffer.clear();\n+    }\n+}"},{"sha":"276d13fa699381611f74389848c73a900f42c2d8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","status":"modified","additions":51,"deletions":19,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -30,26 +30,26 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-import java.util.SortedSet;\n import java.util.TreeSet;\n \n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.enhance.DynamicPersistenceCapable;\n import org.apache.openjpa.enhance.PCRegistry;\n-import org.apache.openjpa.enhance.PCRegistry.RegisterClassListener;\n import org.apache.openjpa.enhance.PersistenceCapable;\n-import org.apache.openjpa.enhance.DynamicPersistenceCapable;\n+import org.apache.openjpa.enhance.PCRegistry.RegisterClassListener;\n import org.apache.openjpa.event.LifecycleEventManager;\n import org.apache.openjpa.lib.conf.Configurable;\n import org.apache.openjpa.lib.conf.Configuration;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.util.Closeable;\n import org.apache.openjpa.lib.util.J2DoPrivHelper;\n import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.ImplHelper;\n import org.apache.openjpa.util.InternalException;\n import org.apache.openjpa.util.MetaDataException;\n import org.apache.openjpa.util.OpenJPAId;\n-import org.apache.openjpa.util.ImplHelper;\n+\n import serp.util.Strings;\n \n /**\n@@ -132,13 +132,14 @@\n \n     // we buffer up any classes that register themselves to prevent\n     // reentrancy errors if classes register during a current parse (common)\n+    private boolean _registeredEmpty = true;\n     private final Collection _registered = new ArrayList();\n \n     // set of metadatas we're in the process of resolving\n-    private final SortedSet _resolving = new TreeSet\n-        (new MetaDataInheritanceComparator());\n-    private final SortedSet _mapping = new TreeSet\n-        (new MetaDataInheritanceComparator());\n+    private final InheritanceOrderedMetaDataList _resolving =\n+        new InheritanceOrderedMetaDataList();\n+    private final InheritanceOrderedMetaDataList _mapping =\n+        new InheritanceOrderedMetaDataList();\n     private final List _errs = new LinkedList();\n \n     // system listeners\n@@ -269,7 +270,7 @@ else if (on)\n             _sourceMode |= mode;\n         else\n             _sourceMode &= ~mode;\n-    }\n+    } \n \n     /**\n      * Return the metadata for the given class.\n@@ -655,7 +656,8 @@ private boolean resolveMapping(ClassMetaData meta) {\n     /**\n      * Process the given metadata and the associated buffer.\n      */\n-    private List processBuffer(ClassMetaData meta, SortedSet buffer, int mode) {\n+    private List processBuffer(ClassMetaData meta,\n+        InheritanceOrderedMetaDataList buffer, int mode) {\n         // if we're already processing a metadata, just buffer this one; when\n         // the initial metadata finishes processing, we traverse the buffer\n         // and process all the others that were introduced during reentrant\n@@ -670,7 +672,7 @@ private List processBuffer(ClassMetaData meta, SortedSet buffer, int mode) {\n         ClassMetaData buffered;\n         List processed = new ArrayList(5);\n         while (!buffer.isEmpty()) {\n-            buffered = (ClassMetaData) buffer.first();\n+            buffered = buffer.peek();\n             try {\n                 buffered.resolve(mode);\n                 processed.add(buffered);\n@@ -1297,6 +1299,7 @@ public void register(Class cls) {\n         // buffer registered classes until an oid metadata request is made,\n         // at which point we'll parse everything in the buffer\n         synchronized (_registered) {\n+            _registeredEmpty = false;\n             _registered.add(cls);\n         }\n     }\n@@ -1317,19 +1320,50 @@ private void loadRegisteredClassMetaData(ClassLoader envLoader) {\n     }\n \n     /**\n-     * Updates our datastructures with the latest registered classes.\n+     * Updates our datastructures with the latest registered classes. This method will only block\n+     * when there are class registrations waiting to be processed. \n+     * \n+     * @return the list of classes that was processed due to this method call.\n      */\n     Class[] processRegisteredClasses(ClassLoader envLoader) {\n+        Class[] res = EMPTY_CLASSES;\n+        if (_registeredEmpty == false) {\n+            // The reason that we're locking on this and _registered is that this\n+            // class has locking semantics such that we always need to lock 'this', then [x].\n+            // This method can result in processRegisteredClass(..) being called and if we didn't\n+            // lock on 'this' we could cause a deadlock. ie: One thread coming in on getSequenceMetaData(..) \n+            // and another on getMetaData(String , ClassLoader , boolean ) .\n+            synchronized(this){\n+                synchronized(_registered){\n+                    // Check again, it is possible another thread already processed.\n+                    if (_registeredEmpty == false) {\n+                        res = processRegisteredClassesInternal(envLoader);\n+                        if (_registered.size() == 0) {\n+                            // It is possible that we failed to register a class and it was added back into\n+                            // our _registered class list to try again later. @see\n+                            // OpenJPAConfiguration#getRetryClassRegistration\n+                            _registeredEmpty = true;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return res;\n+    }\n+         \n+    /**\n+     * Private worker method that processes the registered classes list. No locking is performed in this\n+     * method as the caller needs to hold a lock on _registered.\n+     */\n+    private Class[] processRegisteredClassesInternal(ClassLoader envLoader) {\n+        // Probably overkill\n         if (_registered.isEmpty())\n             return EMPTY_CLASSES;\n \n         // copy into new collection to avoid concurrent mod errors on reentrant\n         // registrations\n-        Class[] reg;\n-        synchronized (_registered) {\n-            reg = (Class[]) _registered.toArray(new Class[_registered.size()]);\n-            _registered.clear();\n-        }\n+        Class[] reg = (Class[]) _registered.toArray(new Class[_registered.size()]);\n+        _registered.clear();\n \n         Collection pcNames = getPersistentTypeNames(false, envLoader);\n         Collection failed = null;\n@@ -1355,9 +1389,7 @@ private void loadRegisteredClassMetaData(ClassLoader envLoader) {\n             }\n         }\n         if (failed != null) {\n-            synchronized (_registered) {\n                 _registered.addAll(failed);\n-            }\n         }\n         return reg;\n     }"},{"sha":"0974e89ff5051ae7f84ff33bd6722731fce4db64","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","status":"modified","additions":130,"deletions":130,"changes":260,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,130 +1,130 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.meta;\r\n-\r\n-import java.io.File;\r\n-import java.io.Serializable;\r\n-\r\n-import org.apache.openjpa.lib.meta.SourceTracker;\r\n-import org.apache.openjpa.lib.xml.Commentable;\r\n-\r\n-/**\r\n- * Metadata about a persistence-aware type.\r\n- *\r\n- * @author Pinaki Poddar\r\n- */\r\n-public class NonPersistentMetaData \r\n-\timplements Comparable, SourceTracker, Commentable, MetaDataContext,\r\n-        Serializable {\r\n-    public static final int TYPE_PERSISTENCE_AWARE = 1;\r\n-    public static final int TYPE_NON_MAPPED_INTERFACE = 2;\r\n-\r\n-    private final MetaDataRepository _repos;\r\n-\tprivate final Class _class;\r\n-    private final int _type;\r\n-\t\r\n-    private File _srcFile = null;\r\n-    private int _srcType = SRC_OTHER;\r\n-    private String[] _comments = null;\r\n-    private int _listIndex = -1;\r\n-\t\r\n-\tprotected NonPersistentMetaData(Class cls, MetaDataRepository repos, \r\n-        int type) {\r\n-\t\t_repos = repos;\r\n-\t\t_class = cls;\r\n-        _type = type;\r\n-\t}\r\n-\t\r\n-    /**\r\n-     * Owning repository.\r\n-     */\r\n-\tpublic MetaDataRepository getRepository() {\r\n-\t\treturn _repos;\r\n-\t}\r\n-\t\r\n-    /**\r\n-     * Persistence-aware type.\r\n-     */\r\n-\tpublic Class getDescribedType() {\r\n-\t\treturn _class;\r\n-\t}\r\n-\r\n-    /**\r\n-     * The type of metadata.\r\n-     */\r\n-    public int getType() {\r\n-        return _type;\r\n-    }\r\n-\t\r\n-    /**\r\n-     * The index in which this class was listed in the metadata. Defaults to\r\n-     * <code>-1</code> if this class was not listed in the metadata.\r\n-     */\r\n-    public int getListingIndex() {\r\n-        return _listIndex;\r\n-    }\r\n-\r\n-    /**\r\n-     * The index in which this field was listed in the metadata. Defaults to\r\n-     * <code>-1</code> if this class was not listed in the metadata.\r\n-     */\r\n-    public void setListingIndex(int index) {\r\n-        _listIndex = index;\r\n-    }\r\n-\r\n-    public File getSourceFile() {\r\n-        return _srcFile;\r\n-    }\r\n-\r\n-    public Object getSourceScope() {\r\n-        return null;\r\n-    }\r\n-\r\n-    public int getSourceType() {\r\n-        return _srcType;\r\n-    }\r\n-\r\n-    public void setSource(File file, int srcType) {\r\n-        _srcFile = file;\r\n-        _srcType = srcType;\r\n-    }\r\n-\r\n-    public String getResourceName() {\r\n-        return _class.getName();\r\n-    }\r\n-\r\n-    public String[] getComments() {\r\n-        return (_comments == null) ? ClassMetaData.EMPTY_COMMENTS : _comments;\r\n-    }\r\n-\r\n-    public void setComments(String[] comments) {\r\n-        _comments = comments;\r\n-    }\r\n-    \r\n-    public int compareTo(Object o) {\r\n-        if (o == this)\r\n-            return 0;\r\n-        if (!(o instanceof NonPersistentMetaData))\r\n-        \treturn 1;\r\n-        NonPersistentMetaData other = (NonPersistentMetaData) o;\r\n-        if (_type != other.getType())\r\n-            return _type - other.getType();\r\n-        return _class.getName().compareTo(other.getDescribedType().getName());\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.meta;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+\n+import org.apache.openjpa.lib.meta.SourceTracker;\n+import org.apache.openjpa.lib.xml.Commentable;\n+\n+/**\n+ * Metadata about a persistence-aware type.\n+ *\n+ * @author Pinaki Poddar\n+ */\n+public class NonPersistentMetaData \n+\timplements Comparable, SourceTracker, Commentable, MetaDataContext,\n+        Serializable {\n+    public static final int TYPE_PERSISTENCE_AWARE = 1;\n+    public static final int TYPE_NON_MAPPED_INTERFACE = 2;\n+\n+    private final MetaDataRepository _repos;\n+\tprivate final Class _class;\n+    private final int _type;\n+\t\n+    private File _srcFile = null;\n+    private int _srcType = SRC_OTHER;\n+    private String[] _comments = null;\n+    private int _listIndex = -1;\n+\t\n+\tprotected NonPersistentMetaData(Class cls, MetaDataRepository repos, \n+        int type) {\n+\t\t_repos = repos;\n+\t\t_class = cls;\n+        _type = type;\n+\t}\n+\t\n+    /**\n+     * Owning repository.\n+     */\n+\tpublic MetaDataRepository getRepository() {\n+\t\treturn _repos;\n+\t}\n+\t\n+    /**\n+     * Persistence-aware type.\n+     */\n+\tpublic Class getDescribedType() {\n+\t\treturn _class;\n+\t}\n+\n+    /**\n+     * The type of metadata.\n+     */\n+    public int getType() {\n+        return _type;\n+    }\n+\t\n+    /**\n+     * The index in which this class was listed in the metadata. Defaults to\n+     * <code>-1</code> if this class was not listed in the metadata.\n+     */\n+    public int getListingIndex() {\n+        return _listIndex;\n+    }\n+\n+    /**\n+     * The index in which this field was listed in the metadata. Defaults to\n+     * <code>-1</code> if this class was not listed in the metadata.\n+     */\n+    public void setListingIndex(int index) {\n+        _listIndex = index;\n+    }\n+\n+    public File getSourceFile() {\n+        return _srcFile;\n+    }\n+\n+    public Object getSourceScope() {\n+        return null;\n+    }\n+\n+    public int getSourceType() {\n+        return _srcType;\n+    }\n+\n+    public void setSource(File file, int srcType) {\n+        _srcFile = file;\n+        _srcType = srcType;\n+    }\n+\n+    public String getResourceName() {\n+        return _class.getName();\n+    }\n+\n+    public String[] getComments() {\n+        return (_comments == null) ? ClassMetaData.EMPTY_COMMENTS : _comments;\n+    }\n+\n+    public void setComments(String[] comments) {\n+        _comments = comments;\n+    }\n+    \n+    public int compareTo(Object o) {\n+        if (o == this)\n+            return 0;\n+        if (!(o instanceof NonPersistentMetaData))\n+        \treturn 1;\n+        NonPersistentMetaData other = (NonPersistentMetaData) o;\n+        if (_type != other.getType())\n+            return _type - other.getType();\n+        return _class.getName().compareTo(other.getDescribedType().getName());\n+    }\n+}"},{"sha":"9fe2390054558e6e27670c4c2c9739de0f846d3d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ProxySetupStateManager.java","status":"modified","additions":31,"deletions":9,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ProxySetupStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ProxySetupStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ProxySetupStateManager.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -25,6 +25,7 @@\n \n import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.enhance.StateManager;\n+import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.util.InternalException;\n \n /**\n@@ -37,6 +38,9 @@\n class ProxySetupStateManager\n     implements StateManager {\n \n+\tprivate static final Localizer _loc = Localizer\n+\t\t.forPackage(ProxySetupStateManager.class);\n+\n     private Object _object = null;\n \n     public void setProxyData(PersistenceCapable pc, ClassMetaData meta) {\n@@ -199,39 +203,57 @@ public void settingObjectField(PersistenceCapable pc, int i, Object o,\n     }\n \n     public void providedBooleanField(PersistenceCapable pc, int i, boolean b) {\n-        throw new InternalException();\n+        throw new InternalException(_loc.get(\n+\t\t\t\t\"unexpected_proxy_sm_attribute_type\", pc.getClass().getName(),\n+\t\t\t\t\"boolean\"));\n     }\n \n     public void providedCharField(PersistenceCapable pc, int i, char c) {\n-        throw new InternalException();\n+        throw new InternalException(_loc.get(\n+\t\t\t\t\"unexpected_proxy_sm_attribute_type\", pc.getClass().getName(),\n+\t\t\t\t\"char\"));\n     }\n \n     public void providedByteField(PersistenceCapable pc, int i, byte b) {\n-        throw new InternalException();\n+        throw new InternalException(_loc.get(\n+\t\t\t\t\"unexpected_proxy_sm_attribute_type\", pc.getClass().getName(),\n+\t\t\t\t\"byte\"));\n     }\n \n     public void providedShortField(PersistenceCapable pc, int i, short s) {\n-        throw new InternalException();\n+        throw new InternalException(_loc.get(\n+\t\t\t\t\"unexpected_proxy_sm_attribute_type\", pc.getClass().getName(),\n+\t\t\t\t\"short\"));\n     }\n \n     public void providedIntField(PersistenceCapable pc, int i, int i2) {\n-        throw new InternalException();\n+        throw new InternalException(_loc.get(\n+\t\t\t\t\"unexpected_proxy_sm_attribute_type\", pc.getClass().getName(),\n+\t\t\t\t\"int\"));\n     }\n \n     public void providedLongField(PersistenceCapable pc, int i, long l) {\n-        throw new InternalException();\n+        throw new InternalException(_loc.get(\n+\t\t\t\t\"unexpected_proxy_sm_attribute_type\", pc.getClass().getName(),\n+\t\t\t\t\"long\"));\n     }\n \n     public void providedFloatField(PersistenceCapable pc, int i, float f) {\n-        throw new InternalException();\n+        throw new InternalException(_loc.get(\n+\t\t\t\t\"unexpected_proxy_sm_attribute_type\", pc.getClass().getName(),\n+\t\t\t\t\"float\"));\n     }\n \n     public void providedDoubleField(PersistenceCapable pc, int i, double d) {\n-        throw new InternalException();\n+        throw new InternalException(_loc.get(\n+\t\t\t\t\"unexpected_proxy_sm_attribute_type\", pc.getClass().getName(),\n+\t\t\t\t\"double\"));\n     }\n \n     public void providedStringField(PersistenceCapable pc, int i, String s) {\n-        throw new InternalException();\n+        throw new InternalException(_loc.get(\n+\t\t\t\t\"unexpected_proxy_sm_attribute_type\", pc.getClass().getName(),\n+\t\t\t\t\"String\"));\n     }\n \n     public void providedObjectField(PersistenceCapable pc, int i, Object o) {"},{"sha":"b5aa972b4fb87ff1a09254f3aa2ec68300d48be2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","status":"modified","additions":74,"deletions":74,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,74 +1,74 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.math.BigDecimal;\r\n-\r\n-/**\r\n- * @author <a href=\"mailto:mnachev@gmail.com\">Miroslav Nachev</a>\r\n- * @since 1.1.0\r\n- */\r\n-public class BigDecimalId\r\n-    extends OpenJPAId {\r\n-\r\n-    private final BigDecimal key;\r\n-\r\n-    public BigDecimalId(Class cls, String key) {\r\n-        this(cls, (key == null) ? null : new BigDecimal(key));\r\n-    }\r\n-\r\n-    public BigDecimalId(Class cls, BigDecimal key) {\r\n-        super(cls);\r\n-        this.key = key;\r\n-    }\r\n-\r\n-    public BigDecimalId(Class cls, BigDecimal key, boolean subs) {\r\n-        super(cls, subs);\r\n-        this.key = key;\r\n-    }\r\n-\r\n-    public BigDecimal getId() {\r\n-        return key;\r\n-    }\r\n-\r\n-    public Object getIdObject() {\r\n-        return key;\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        if (key == null)\r\n-            return \"NULL\";\r\n-\r\n-        return key.toString();\r\n-    }\r\n-\r\n-    protected int idHash() {\r\n-        if (key != null)\r\n-            return key.hashCode();\r\n-\r\n-        return 0;\r\n-    }\r\n-\r\n-    protected boolean idEquals(OpenJPAId other) {\r\n-        if(key == null)\r\n-            return false;\r\n-\r\n-        return key.equals(other);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.util;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * @author <a href=\"mailto:mnachev@gmail.com\">Miroslav Nachev</a>\n+ * @since 1.1.0\n+ */\n+public class BigDecimalId\n+    extends OpenJPAId {\n+\n+    private final BigDecimal key;\n+\n+    public BigDecimalId(Class cls, String key) {\n+        this(cls, (key == null) ? null : new BigDecimal(key));\n+    }\n+\n+    public BigDecimalId(Class cls, BigDecimal key) {\n+        super(cls);\n+        this.key = key;\n+    }\n+\n+    public BigDecimalId(Class cls, BigDecimal key, boolean subs) {\n+        super(cls, subs);\n+        this.key = key;\n+    }\n+\n+    public BigDecimal getId() {\n+        return key;\n+    }\n+\n+    public Object getIdObject() {\n+        return key;\n+    }\n+\n+    public String toString() {\n+        if (key == null)\n+            return \"NULL\";\n+\n+        return key.toString();\n+    }\n+\n+    protected int idHash() {\n+        if (key != null)\n+            return key.hashCode();\n+\n+        return 0;\n+    }\n+\n+    protected boolean idEquals(OpenJPAId other) {\n+        if(key == null)\n+            return false;\n+\n+        return key.equals(other);\n+    }\n+}"},{"sha":"55a597610226c591557dba9cd68d6f1f66a83dd2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","status":"modified","additions":75,"deletions":75,"changes":150,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,75 +1,75 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.math.BigInteger;\r\n-\r\n-/**\r\n- * @author <a href=\"mailto:mnachev@gmail.com\">Miroslav Nachev</a>\r\n- * @since 1.1.0\r\n- */\r\n-public class BigIntegerId\r\n-    extends OpenJPAId {\r\n-\r\n-    private final BigInteger key;\r\n-\r\n-    public BigIntegerId(Class cls, String key) {\r\n-        this(cls, (key == null) ? null : new BigInteger(key));\r\n-    }\r\n-\r\n-    public BigIntegerId(Class cls, BigInteger key) {\r\n-        super(cls);\r\n-        this.key = key;\r\n-    }\r\n-\r\n-    public BigIntegerId(Class cls, BigInteger key, boolean subs) {\r\n-        super(cls, subs);\r\n-        this.key = key;\r\n-    }\r\n-\r\n-    public BigInteger getId() {\r\n-        return key;\r\n-    }\r\n-\r\n-    public Object getIdObject() {\r\n-        return key;\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        if (key == null)\r\n-            return \"NULL\";\r\n-\r\n-        return key.toString();\r\n-    }\r\n-\r\n-    protected int idHash() {\r\n-        if (key != null)\r\n-            return key.hashCode();\r\n-\r\n-        return 0;\r\n-    }\r\n-\r\n-    protected boolean idEquals(OpenJPAId other) {\r\n-        if (key == null)\r\n-            return false;\r\n-\r\n-        return key.equals(other);\r\n-    }\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.util;\n+\n+import java.math.BigInteger;\n+\n+/**\n+ * @author <a href=\"mailto:mnachev@gmail.com\">Miroslav Nachev</a>\n+ * @since 1.1.0\n+ */\n+public class BigIntegerId\n+    extends OpenJPAId {\n+\n+    private final BigInteger key;\n+\n+    public BigIntegerId(Class cls, String key) {\n+        this(cls, (key == null) ? null : new BigInteger(key));\n+    }\n+\n+    public BigIntegerId(Class cls, BigInteger key) {\n+        super(cls);\n+        this.key = key;\n+    }\n+\n+    public BigIntegerId(Class cls, BigInteger key, boolean subs) {\n+        super(cls, subs);\n+        this.key = key;\n+    }\n+\n+    public BigInteger getId() {\n+        return key;\n+    }\n+\n+    public Object getIdObject() {\n+        return key;\n+    }\n+\n+    public String toString() {\n+        if (key == null)\n+            return \"NULL\";\n+\n+        return key.toString();\n+    }\n+\n+    protected int idHash() {\n+        if (key != null)\n+            return key.hashCode();\n+\n+        return 0;\n+    }\n+\n+    protected boolean idEquals(OpenJPAId other) {\n+        if (key == null)\n+            return false;\n+\n+        return key.equals(other);\n+    }\n+\n+}"},{"sha":"16168945faa8b8f594bb874de7ee8cccf0e09631","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","status":"modified","additions":92,"deletions":92,"changes":184,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,92 +1,92 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.security.AccessController;\r\n-import java.security.PrivilegedActionException;\r\n-import java.lang.reflect.Constructor;\r\n-\r\n-import org.apache.openjpa.lib.util.J2DoPrivHelper;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import serp.bytecode.BCClass;\r\n-import serp.bytecode.BCClassLoader;\r\n-\r\n-/**\r\n- * Utility methods when generating classes, including at runtime.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class GeneratedClasses {\r\n-\r\n-    /**\r\n-     * Return the more derived loader of the class laoders for the given \r\n-     * classes.\r\n-     */\r\n-    public static ClassLoader getMostDerivedLoader(Class c1, Class c2) {\r\n-        ClassLoader l1 = (ClassLoader) AccessController.doPrivileged(\r\n-            J2DoPrivHelper.getClassLoaderAction(c1));\r\n-        ClassLoader l2 = (ClassLoader) AccessController.doPrivileged(\r\n-            J2DoPrivHelper.getClassLoaderAction(c2));\r\n-        if (l1 == l2)\r\n-            return l1;\r\n-        if (l1 == null)\r\n-            return l2;\r\n-        if (l2 == null)\r\n-            return l1;\r\n-\r\n-        if(canLoad(l1, c2)) {\r\n-            return l1;\r\n-        }\r\n-        return l2;\r\n-    }\r\n-\r\n-    /**\r\n-     * Load the class represented by the given bytecode.\r\n-     */\r\n-    public static Class loadBCClass(BCClass bc, ClassLoader loader) {\r\n-        BCClassLoader bcloader = (BCClassLoader) AccessController\r\n-                .doPrivileged(J2DoPrivHelper.newBCClassLoaderAction(bc\r\n-                        .getProject(), loader));\r\n-        try {\r\n-            Class c = Class.forName(bc.getName(), true, bcloader);\r\n-            bc.getProject().clear();\r\n-            return c;\r\n-        } catch (Throwable t) {\r\n-            throw new GeneralException(bc.getName()).setCause(t);\r\n-        }\r\n-    }\r\n-    \r\n-    /**\r\n-     * Return true if the given loader will load the same version of a given \r\n-     * class.  \r\n-     * \r\n-     * @param loader Classloader to use.\r\n-     * @param clazz  Expected class. \r\n-     * @return true if loader.load(clazz.getName()) == clazz. Otherwise false.\r\n-     */\r\n-    private static boolean canLoad(ClassLoader loader, Class clazz) {\r\n-        Class loaded = null;\r\n-        try {\r\n-            loaded = loader.loadClass(clazz.getName());\r\n-        } catch (ClassNotFoundException e) {\r\n-            // Rely on caller to handle return value = false.\r\n-        }\r\n-        return clazz == loaded;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.util;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.lang.reflect.Constructor;\n+\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\n+import org.apache.openjpa.lib.util.Localizer;\n+import serp.bytecode.BCClass;\n+import serp.bytecode.BCClassLoader;\n+\n+/**\n+ * Utility methods when generating classes, including at runtime.\n+ *\n+ * @since 1.0.0\n+ */\n+public class GeneratedClasses {\n+\n+    /**\n+     * Return the more derived loader of the class laoders for the given \n+     * classes.\n+     */\n+    public static ClassLoader getMostDerivedLoader(Class c1, Class c2) {\n+        ClassLoader l1 = (ClassLoader) AccessController.doPrivileged(\n+            J2DoPrivHelper.getClassLoaderAction(c1));\n+        ClassLoader l2 = (ClassLoader) AccessController.doPrivileged(\n+            J2DoPrivHelper.getClassLoaderAction(c2));\n+        if (l1 == l2)\n+            return l1;\n+        if (l1 == null)\n+            return l2;\n+        if (l2 == null)\n+            return l1;\n+\n+        if(canLoad(l1, c2)) {\n+            return l1;\n+        }\n+        return l2;\n+    }\n+\n+    /**\n+     * Load the class represented by the given bytecode.\n+     */\n+    public static Class loadBCClass(BCClass bc, ClassLoader loader) {\n+        BCClassLoader bcloader = (BCClassLoader) AccessController\n+                .doPrivileged(J2DoPrivHelper.newBCClassLoaderAction(bc\n+                        .getProject(), loader));\n+        try {\n+            Class c = Class.forName(bc.getName(), true, bcloader);\n+            bc.getProject().clear();\n+            return c;\n+        } catch (Throwable t) {\n+            throw new GeneralException(bc.getName()).setCause(t);\n+        }\n+    }\n+    \n+    /**\n+     * Return true if the given loader will load the same version of a given \n+     * class.  \n+     * \n+     * @param loader Classloader to use.\n+     * @param clazz  Expected class. \n+     * @return true if loader.load(clazz.getName()) == clazz. Otherwise false.\n+     */\n+    private static boolean canLoad(ClassLoader loader, Class clazz) {\n+        Class loaded = null;\n+        try {\n+            loaded = loader.loadClass(clazz.getName());\n+        } catch (ClassNotFoundException e) {\n+            // Rely on caller to handle return value = false.\n+        }\n+        return clazz == loaded;\n+    }\n+}"},{"sha":"d3ba1e8b12a90b6fb0c5077d30569105b1850cfb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","status":"modified","additions":115,"deletions":115,"changes":230,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,115 +1,115 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.util;\r\n-\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.kernel.StoreManager;\r\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\r\n-\r\n-/**\r\n- * Repository of store-specific facade classes. This is used by facade \r\n- * implementations to wrap store-specific components without knowing \r\n- * about all possible back-ends.\r\n- */\r\n-public class StoreFacadeTypeRegistry {\r\n-\r\n-    private Map _impls = new ConcurrentHashMap();\r\n-\r\n-    /**\r\n-     * Register a facade implementation.\r\n-     *\r\n-     * @param facadeType the facade interface\r\n-     * @param storeType the store's \r\n-     * {@link org.apache.openjpa.kernel.StoreManager} type, or null for generic\r\n-     * @param implType the class implementing the facade\r\n-     */\r\n-    public void registerImplementation(Class facadeType, Class storeType, \r\n-        Class implType) {\r\n-        Object key = (storeType == null) ? (Object) facadeType \r\n-            : new Key(facadeType, storeType);\r\n-        _impls.put(key, implType);\r\n-    }\r\n-    \r\n-    /**\r\n-     * Return the implementation for the given facade and store.\r\n-     *\r\n-     * @param facadeType the facade interface\r\n-     * @param storeType the store's \r\n-     * {@link org.apache.openjpa.kernel.StoreManager} type, or null for generic\r\n-     * @param implType the registered implementor\r\n-     */\r\n-    public Class getImplementation(Class facadeType, Class storeType) {\r\n-        // traverse store type hierarchy to store manager to find most specific\r\n-        // store avaialble\r\n-        Class impl;\r\n-        for (; storeType != null && storeType != StoreManager.class; \r\n-            storeType = storeType.getSuperclass()) {\r\n-            impl = (Class) _impls.get(new Key(facadeType, storeType));\r\n-            if (impl != null)\r\n-                return impl; \r\n-        }    \r\n-        return (Class) _impls.get(facadeType);\r\n-    }\r\n-    \r\n-    /**\r\n-     * Return the implementation for the given facade and store. If no \r\n-     * registered implementation is found then returns the given default type\r\n-     * provided it the facade type is assignable from the deafult type.\r\n-     *\r\n-     * @param facadeType the facade interface\r\n-     * @param storeType the store's \r\n-     * {@link org.apache.openjpa.kernel.StoreManager} type, or null for generic\r\n-     * @param implType the registered implementor\r\n-     * @param defaultType class if no registered implementation is available.\r\n-     */\r\n-    public Class getImplementation(Class facadeType, Class storeType, \r\n-    \tClass defaultType) {\r\n-    \tClass result = getImplementation(facadeType, storeType);\r\n-    \tif (result == null)\r\n-    \t\tresult = defaultType;\r\n-    \tif (facadeType == null || !facadeType.isAssignableFrom(result))\r\n-    \t\tthrow new InternalException();\r\n-    \treturn result;\r\n-    }\r\n-\r\n-    /**\r\n-     * Lookup key for facade+store hash.\r\n-     */\r\n-    private static class Key {\r\n-        public final Class _facadeType;\r\n-        public final Class _storeType;\r\n-\r\n-        public Key(Class facadeType, Class storeType) {\r\n-            _facadeType = facadeType;\r\n-            _storeType = storeType;\r\n-        }\r\n-\r\n-        public int hashCode() {\r\n-            return _facadeType.hashCode() ^ _storeType.hashCode();\r\n-        }\r\n-\r\n-        public boolean equals(Object other) {\r\n-            if (other == this)\r\n-                return true;\r\n-            Key k = (Key) other;\r\n-            return _facadeType == k._facadeType && _storeType == k._storeType;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.util;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.kernel.StoreManager;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Repository of store-specific facade classes. This is used by facade \n+ * implementations to wrap store-specific components without knowing \n+ * about all possible back-ends.\n+ */\n+public class StoreFacadeTypeRegistry {\n+\n+    private Map _impls = new ConcurrentHashMap();\n+\n+    /**\n+     * Register a facade implementation.\n+     *\n+     * @param facadeType the facade interface\n+     * @param storeType the store's \n+     * {@link org.apache.openjpa.kernel.StoreManager} type, or null for generic\n+     * @param implType the class implementing the facade\n+     */\n+    public void registerImplementation(Class facadeType, Class storeType, \n+        Class implType) {\n+        Object key = (storeType == null) ? (Object) facadeType \n+            : new Key(facadeType, storeType);\n+        _impls.put(key, implType);\n+    }\n+    \n+    /**\n+     * Return the implementation for the given facade and store.\n+     *\n+     * @param facadeType the facade interface\n+     * @param storeType the store's \n+     * {@link org.apache.openjpa.kernel.StoreManager} type, or null for generic\n+     * @param implType the registered implementor\n+     */\n+    public Class getImplementation(Class facadeType, Class storeType) {\n+        // traverse store type hierarchy to store manager to find most specific\n+        // store avaialble\n+        Class impl;\n+        for (; storeType != null && storeType != StoreManager.class; \n+            storeType = storeType.getSuperclass()) {\n+            impl = (Class) _impls.get(new Key(facadeType, storeType));\n+            if (impl != null)\n+                return impl; \n+        }    \n+        return (Class) _impls.get(facadeType);\n+    }\n+    \n+    /**\n+     * Return the implementation for the given facade and store. If no \n+     * registered implementation is found then returns the given default type\n+     * provided it the facade type is assignable from the deafult type.\n+     *\n+     * @param facadeType the facade interface\n+     * @param storeType the store's \n+     * {@link org.apache.openjpa.kernel.StoreManager} type, or null for generic\n+     * @param implType the registered implementor\n+     * @param defaultType class if no registered implementation is available.\n+     */\n+    public Class getImplementation(Class facadeType, Class storeType, \n+    \tClass defaultType) {\n+    \tClass result = getImplementation(facadeType, storeType);\n+    \tif (result == null)\n+    \t\tresult = defaultType;\n+    \tif (facadeType == null || !facadeType.isAssignableFrom(result))\n+    \t\tthrow new InternalException();\n+    \treturn result;\n+    }\n+\n+    /**\n+     * Lookup key for facade+store hash.\n+     */\n+    private static class Key {\n+        public final Class _facadeType;\n+        public final Class _storeType;\n+\n+        public Key(Class facadeType, Class storeType) {\n+            _facadeType = facadeType;\n+            _storeType = storeType;\n+        }\n+\n+        public int hashCode() {\n+            return _facadeType.hashCode() ^ _storeType.hashCode();\n+        }\n+\n+        public boolean equals(Object other) {\n+            if (other == this)\n+                return true;\n+            Key k = (Key) other;\n+            return _facadeType == k._facadeType && _storeType == k._storeType;\n+        }\n+    }\n+}"},{"sha":"c79531050bb4520060f13a3048b13dcd45e12015","filename":"openjpa-kernel/src/main/jjtree/org/apache/openjpa/kernel/jpql/JPQL.jjt","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/jjtree/org/apache/openjpa/kernel/jpql/JPQL.jjt","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/jjtree/org/apache/openjpa/kernel/jpql/JPQL.jjt","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/jjtree/org/apache/openjpa/kernel/jpql/JPQL.jjt?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1224,7 +1224,7 @@ void positional_input_parameter() #POSITIONALINPUTPARAMETER :\n \n void pattern_value() #PATTERNVALUE : { }\n {\n-\tinput_parameter() | string_literal()\n+\t(input_parameter() | string_literal())\n \t[(<ESCAPE> escape_character() #ESCAPECHARACTER)]\n }\n "},{"sha":"b361c7b6852d23719fde23e93e71c706f43b49ee","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/ee/localizer.properties","status":"modified","additions":36,"deletions":36,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/resources/org/apache/openjpa/ee/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/resources/org/apache/openjpa/ee/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/ee/localizer.properties?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,36 +1,36 @@\n-# Licensed to the Apache Software Foundation (ASF) under one\r\n-# or more contributor license agreements.  See the NOTICE file\r\n-# distributed with this work for additional information\r\n-# regarding copyright ownership.  The ASF licenses this file\r\n-# to you under the Apache License, Version 2.0 (the\r\n-# \"License\"); you may not use this file except in compliance\r\n-# with the License.  You may obtain a copy of the License at\r\n-#\r\n-# http://www.apache.org/licenses/LICENSE-2.0\r\n-#\r\n-# Unless required by applicable law or agreed to in writing,\r\n-# software distributed under the License is distributed on an\r\n-# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n-# KIND, either express or implied.  See the License for the\r\n-# specific language governing permissions and limitations\r\n-# under the License.  \r\n-\r\n-tm-not-found: Could not perform automatic lookup of EJB container''s \\\r\n-\tjavax.transaction.TransactionManager implementation. Please ensure that \\\r\n-\tyou are running the application from within an EJB 1.1 compliant EJB \\\r\n-\tcontainer, and then set the org.apache.openjpa.ManagedRuntime property to the \\\r\n-\tappropriate value to obtain the TransactionManager.\r\n-expected-reference: Expected object to be of type Reference, but instead was \\\r\n-\t\"{0}\".\r\n-not-supported: This operation is not supported.\r\n-was-unsupported-op: Unable to execute {0} on a WebSphere managed transaction. \\\r\n-\tWebSphere does not support direct manipulation of managed transactions.\r\n-was-transaction-id-exception: Unable to determine identity of the current WebSphere \\\r\n-\tmanaged transaction. Please ensure that your are running the application from \\\r\n-\twithin WebSphere Application Server (version 5.0.2 or newer).\r\n-was-reflection-exception: An error occured reflecting WebSphere proprietary \\\r\n-\tinterfaces. Please ensure that you are running the application from within \\\r\n-\tWebSphere Application Server (version 5.0.2 or newer).\r\n-was-lookup-error: An error occurred looking up the WebSphere extended JTA \\\r\n-\tservice. Please ensure that you are running the application from within WebSphere \\\r\n-\tApplication Server (version 5.0.2 or newer).\r\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+# http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.  \n+\n+tm-not-found: Could not perform automatic lookup of EJB container''s \\\n+\tjavax.transaction.TransactionManager implementation. Please ensure that \\\n+\tyou are running the application from within an EJB 1.1 compliant EJB \\\n+\tcontainer, and then set the org.apache.openjpa.ManagedRuntime property to the \\\n+\tappropriate value to obtain the TransactionManager.\n+expected-reference: Expected object to be of type Reference, but instead was \\\n+\t\"{0}\".\n+not-supported: This operation is not supported.\n+was-unsupported-op: Unable to execute {0} on a WebSphere managed transaction. \\\n+\tWebSphere does not support direct manipulation of managed transactions.\n+was-transaction-id-exception: Unable to determine identity of the current WebSphere \\\n+\tmanaged transaction. Please ensure that your are running the application from \\\n+\twithin WebSphere Application Server (version 5.0.2 or newer).\n+was-reflection-exception: An error occured reflecting WebSphere proprietary \\\n+\tinterfaces. Please ensure that you are running the application from within \\\n+\tWebSphere Application Server (version 5.0.2 or newer).\n+was-lookup-error: An error occurred looking up the WebSphere extended JTA \\\n+\tservice. Please ensure that you are running the application from within WebSphere \\\n+\tApplication Server (version 5.0.2 or newer)."},{"sha":"2caacb7c544f09c233ef934d392d814baa83119e","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","status":"modified","additions":8,"deletions":3,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -171,7 +171,7 @@ invalid-id: The id class specified by type \"{0}\" does not match the \\\n \tprimary key fields of the class.  Make sure your identity class has the \\\n \tsame primary keys as your persistent type, including pk field types. \\\n     Mismatched property: \"{1}\"\n-null-cons: The id class specified by type \"{0}\" does not have public a \\\n+null-cons: The id class specified by type \"{0}\" does not have a public \\\n \tno-args constructor.\n hc-method: The identity class specified by type \"{0}\" is not valid, as the \\\n \thashCode method is not overridden. Implement hashCode so that two \\\n@@ -301,8 +301,13 @@ scan-found-names: Scan of \"{1}\" found persistent types {0}.\n parse-found-names: parsePersistentTypeNames() found {0}.\n interface-load: Dynamic implementation of managed \"{0}\" can not be defined \\\n \tusing classloader \"{1}\". See nested exception for details.\n-interface-load2: Enhanced dynamic implementaion of managed \"{0}\" can not be \\\n+interface-load2: Enhanced dynamic implementation of managed \"{0}\" can not be \\\n \tdefined using classloader \"{1}\". See nested exception for details.\n-interface-badenhance: Dynamic implementaion of \"{0}\" can not be enhanced.\n+interface-badenhance: Dynamic implementation of \"{0}\" can not be enhanced.\n bad-externalized-value: Value \"{0}\" was not found in the list of \\\n \tExternalValues for field \"{2}\". Valid values are {1}\n+unexpected_proxy_sm_attribute_type: Unexpected attribute type \"{1}\" for \\\n+\tpersistence-capable class \"{0}\" is detected. If the entity is packaged in \\\n+    a jar file, this may be caused by one or more inherited class of the \\\n+    entity not being packaged in the same jar file. Please check all \\\n+    inherited class(es) are packaged in the same jar file."},{"sha":"e83a9aa3ea0ab2af91e8a01b31f5697e30aeb62d","filename":"openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","status":"modified","additions":57,"deletions":57,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,57 +1,57 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.ee;\r\n-\r\n-import junit.framework.TestCase;\r\n-\r\n-import serp.util.Strings;\r\n-\r\n-/**\r\n- * Test class for build transformation performed by WASManagedRuntime.\r\n- *\r\n- */\r\n-public class TestWASManagedRuntime extends TestCase {\r\n-\r\n-    /**\r\n-     * This test will verify that the WASManagedRuntime$WASSynchronization\r\n-     * class was properly modified by the maven build process (reference\r\n-     * the top level pom.xml).  This testcase will not execute properly\r\n-     * within Eclipse since the Eclipse target directory (probably) hasn't\r\n-     * been modified via the maven build.\r\n-     *\r\n-     * @throws ClassNotFoundException\r\n-     * @author Michael Dick\r\n-     */\r\n-    public void testInterfaceAdded() throws ClassNotFoundException {\r\n-\r\n-        String msg = null;\r\n-\r\n-        try {\r\n-            Class.forName(WASManagedRuntime.CLASS);\r\n-            fail(\"expected an exception to be thrown\");\r\n-        } catch (NoClassDefFoundError e) {\r\n-            msg = e.getMessage();\r\n-        }\r\n-        String interfaceName = Strings.\r\n-            getClassName(WASManagedRuntime.INTERFACE);\r\n-        assertTrue(\"message should have contained \"\r\n-            + interfaceName + \", but was '\" + msg + \"'\",\r\n-            msg.indexOf(interfaceName) != -1);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.ee;\n+\n+import junit.framework.TestCase;\n+\n+import serp.util.Strings;\n+\n+/**\n+ * Test class for build transformation performed by WASManagedRuntime.\n+ *\n+ */\n+public class TestWASManagedRuntime extends TestCase {\n+\n+    /**\n+     * This test will verify that the WASManagedRuntime$WASSynchronization\n+     * class was properly modified by the maven build process (reference\n+     * the top level pom.xml).  This testcase will not execute properly\n+     * within Eclipse since the Eclipse target directory (probably) hasn't\n+     * been modified via the maven build.\n+     *\n+     * @throws ClassNotFoundException\n+     * @author Michael Dick\n+     */\n+    public void testInterfaceAdded() throws ClassNotFoundException {\n+\n+        String msg = null;\n+\n+        try {\n+            Class.forName(WASManagedRuntime.CLASS);\n+            fail(\"expected an exception to be thrown\");\n+        } catch (NoClassDefFoundError e) {\n+            msg = e.getMessage();\n+        }\n+        String interfaceName = Strings.\n+            getClassName(WASManagedRuntime.INTERFACE);\n+        assertTrue(\"message should have contained \"\n+            + interfaceName + \", but was '\" + msg + \"'\",\n+            msg.indexOf(interfaceName) != -1);\n+    }\n+}"},{"sha":"e51bbb5d81fcd36c0193892c4c9054e285035d2d","filename":"openjpa-lib-5/pom.xml","status":"modified","additions":1,"deletions":13,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib-5/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib-5/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib-5/pom.xml?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -31,7 +31,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-parent</artifactId>\n-        <version>1.0.3</version>\n+        <version>1.0.4</version>\n     </parent>\n     <dependencies>\n         <dependency>\n@@ -41,16 +41,4 @@\n             <scope>compile</scope>\n         </dependency>\n     </dependencies>\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins</groupId>\n-                <artifactId>maven-compiler-plugin</artifactId>\n-                <configuration>\n-                    <source>1.5</source>\n-                    <target>1.5</target>\n-                </configuration>\n-            </plugin>\n-        </plugins>\n-    </build>\n </project>"},{"sha":"82a3edcf6f3963bc8dd2b1f6e8ba431593b76e2c","filename":"openjpa-lib-5/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java","status":"modified","additions":92,"deletions":92,"changes":184,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib-5/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib-5/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib-5/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,92 +1,92 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.util;\r\n-\r\n-import java.lang.reflect.AnnotatedElement;\r\n-import java.security.PrivilegedAction;\r\n-\r\n-/**\r\n- * Helper class to obtain the Privilege(Exception)Action object to perform\r\n- * Java 2 doPrivilege security sensitive function call in the following\r\n- * methods:\r\n- * <ul>\r\n- * <li>AnnotatedElement.getAnnotations\r\n- * <li>AnnotatedElement.getDeclaredAnnotations\r\n- * <li>AnnotatedElement.isAnnotationPresent\r\n- * </ul>\r\n- *\r\n- * @author Albert Lee\r\n- */\r\n-\r\n-public abstract class J2DoPriv5Helper extends J2DoPrivHelper {\r\n-\r\n-    /**\r\n-     * Return a PrivilegeAction object for AnnotatedElement.getAnnotations().\r\n-     *\r\n-     * Requires security policy:\r\n-     *   'permission java.lang.RuntimePermission \"accessDeclaredMembers\";'\r\n-     *\r\n-     * @return Annotation[]\r\n-     */\r\n-    public static final PrivilegedAction getAnnotationsAction(\r\n-        final AnnotatedElement element) {\r\n-        return new PrivilegedAction() {\r\n-            public Object run() {\r\n-                return element.getAnnotations();\r\n-            }\r\n-        };\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a PrivilegeAction object for\r\n-     *   AnnotatedElement.getDeclaredAnnotations().\r\n-     *\r\n-     * Requires security policy:\r\n-     *   'permission java.lang.RuntimePermission \"accessDeclaredMembers\";'\r\n-     *\r\n-     * @return Annotation[]\r\n-     */\r\n-    public static final PrivilegedAction getDeclaredAnnotationsAction(\r\n-        final AnnotatedElement element) {\r\n-        return new PrivilegedAction() {\r\n-            public Object run() {\r\n-                return element.getDeclaredAnnotations();\r\n-            }\r\n-        };\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a PrivilegeAction object for\r\n-     *   AnnotatedElement.isAnnotationPresent().\r\n-     *\r\n-     * Requires security policy:\r\n-     *   'permission java.lang.RuntimePermission \"accessDeclaredMembers\";'\r\n-     *\r\n-     * @return Boolean\r\n-     */\r\n-    public static final PrivilegedAction isAnnotationPresentAction(\r\n-        final AnnotatedElement element, final Class annotationClazz) {\r\n-        return new PrivilegedAction() {\r\n-            public Object run() {\r\n-                return element.isAnnotationPresent(annotationClazz)\r\n-                    ? Boolean.TRUE : Boolean.FALSE;\r\n-            }\r\n-        };\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.util;\n+\n+import java.lang.reflect.AnnotatedElement;\n+import java.security.PrivilegedAction;\n+\n+/**\n+ * Helper class to obtain the Privilege(Exception)Action object to perform\n+ * Java 2 doPrivilege security sensitive function call in the following\n+ * methods:\n+ * <ul>\n+ * <li>AnnotatedElement.getAnnotations\n+ * <li>AnnotatedElement.getDeclaredAnnotations\n+ * <li>AnnotatedElement.isAnnotationPresent\n+ * </ul>\n+ *\n+ * @author Albert Lee\n+ */\n+\n+public abstract class J2DoPriv5Helper extends J2DoPrivHelper {\n+\n+    /**\n+     * Return a PrivilegeAction object for AnnotatedElement.getAnnotations().\n+     *\n+     * Requires security policy:\n+     *   'permission java.lang.RuntimePermission \"accessDeclaredMembers\";'\n+     *\n+     * @return Annotation[]\n+     */\n+    public static final PrivilegedAction getAnnotationsAction(\n+        final AnnotatedElement element) {\n+        return new PrivilegedAction() {\n+            public Object run() {\n+                return element.getAnnotations();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Return a PrivilegeAction object for\n+     *   AnnotatedElement.getDeclaredAnnotations().\n+     *\n+     * Requires security policy:\n+     *   'permission java.lang.RuntimePermission \"accessDeclaredMembers\";'\n+     *\n+     * @return Annotation[]\n+     */\n+    public static final PrivilegedAction getDeclaredAnnotationsAction(\n+        final AnnotatedElement element) {\n+        return new PrivilegedAction() {\n+            public Object run() {\n+                return element.getDeclaredAnnotations();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Return a PrivilegeAction object for\n+     *   AnnotatedElement.isAnnotationPresent().\n+     *\n+     * Requires security policy:\n+     *   'permission java.lang.RuntimePermission \"accessDeclaredMembers\";'\n+     *\n+     * @return Boolean\n+     */\n+    public static final PrivilegedAction isAnnotationPresentAction(\n+        final AnnotatedElement element, final Class annotationClazz) {\n+        return new PrivilegedAction() {\n+            public Object run() {\n+                return element.isAnnotationPresent(annotationClazz)\n+                    ? Boolean.TRUE : Boolean.FALSE;\n+            }\n+        };\n+    }\n+}"},{"sha":"60b0b04d0070c498207869fa82ded01bf2f5ff3b","filename":"openjpa-lib/pom.xml","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/pom.xml?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -31,7 +31,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-parent</artifactId>\n-        <version>1.0.3</version>\n+        <version>1.0.4</version>\n     </parent>\n     <profiles>\n         <profile>\n@@ -41,6 +41,7 @@\n                 <pluginManagement>\n                     <plugins>\n                         <plugin>\n+                            <groupId>org.apache.maven.plugins</groupId>\n                             <artifactId>maven-compiler-plugin</artifactId>\n                             <configuration>\n                                 <compilerArguments>\n@@ -100,6 +101,7 @@\n     <build>\n         <plugins>\n             <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-compiler-plugin</artifactId>\n                 <configuration>\n                     <source>1.4</source>\n@@ -113,6 +115,7 @@\n                 zip (when there is no .svn/ metadata)\n             -->\n             <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-antrun-plugin</artifactId>\n                 <executions>\n                     <!--"},{"sha":"94b98bf8e5253d78219852b530e1777a6be16662","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","status":"modified","additions":55,"deletions":55,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,55 +1,55 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.lib.conf;\r\n-/**\r\n- * Exception recognized by {@link ProductDerivations bootstrap} framework.\r\n- * \r\n- * @author Pinaki Poddar\r\n- * @since 0.4.1.4\r\n- *\r\n- */\r\n-public class BootstrapException extends RuntimeException {\r\n-\r\n-\tprivate boolean _fatal = false;\r\n-\t\r\n-\tpublic BootstrapException() {\r\n-\t\tsuper();\r\n-\t}\r\n-\r\n-\tpublic BootstrapException(String message) {\r\n-\t\tsuper(message);\r\n-\t}\r\n-\r\n-\tpublic BootstrapException(Throwable cause) {\r\n-\t\tsuper(cause);\r\n-\t}\r\n-\r\n-\tpublic BootstrapException(String message, Throwable cause) {\r\n-\t\tsuper(message, cause);\r\n-\t}\r\n-\t\r\n-\tpublic BootstrapException setFatal(boolean fatal) {\r\n-\t\t_fatal = fatal;\r\n-\t\treturn this;\r\n-\t}\r\n-\t\r\n-\tpublic boolean isFatal() {\r\n-\t\treturn _fatal;\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.conf;\n+/**\n+ * Exception recognized by {@link ProductDerivations bootstrap} framework.\n+ * \n+ * @author Pinaki Poddar\n+ * @since 0.4.1.4\n+ *\n+ */\n+public class BootstrapException extends RuntimeException {\n+\n+\tprivate boolean _fatal = false;\n+\t\n+\tpublic BootstrapException() {\n+\t\tsuper();\n+\t}\n+\n+\tpublic BootstrapException(String message) {\n+\t\tsuper(message);\n+\t}\n+\n+\tpublic BootstrapException(Throwable cause) {\n+\t\tsuper(cause);\n+\t}\n+\n+\tpublic BootstrapException(String message, Throwable cause) {\n+\t\tsuper(message, cause);\n+\t}\n+\t\n+\tpublic BootstrapException setFatal(boolean fatal) {\n+\t\t_fatal = fatal;\n+\t\treturn this;\n+\t}\n+\t\n+\tpublic boolean isFatal() {\n+\t\treturn _fatal;\n+\t}\n+}"},{"sha":"e40e160910ef01d40326a0b10f353465a76c7eb5","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","status":"modified","additions":145,"deletions":145,"changes":290,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,145 +1,145 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.graph;\r\n-\r\n-import java.util.Collection;\r\n-import java.util.HashMap;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-\r\n-/**\r\n- * <p>Performs a breadth-first walk of a given {@link Graph},\r\n- * notifying visitors as it sees each node.  See the BFS algorithm\r\n- * in the book 'Introduction to Algorithms' by Cormen, Leiserson, and\r\n- * Rivest.</p>\r\n- * <p/>\r\n- * <p>Each {@link GraphVisitor} will be notified when a node\r\n- * is colored black (nodeVisited), edge seen (edgeVisited),\r\n- * and a node is seen for the first time, i.e. colored gray (nodeSeen).</p>\r\n- *\r\n- * @author Steve Kim\r\n- * @since 1.0.0\r\n- * @nojavadoc\r\n- */\r\n-public class BreadthFirstWalk {\r\n-\r\n-    private final Graph _graph;\r\n-    private final Set _visitors = new HashSet();\r\n-    private final List _queue = new LinkedList();\r\n-    private final Map _nodeInfo = new HashMap();\r\n-\r\n-    public BreadthFirstWalk(Graph graph) {\r\n-        _graph = graph;\r\n-    }\r\n-\r\n-    /**\r\n-     * Begins the breadth first traversal.\r\n-     */\r\n-    public void walk() {\r\n-        _queue.clear();\r\n-        _nodeInfo.clear();\r\n-\r\n-        Collection nodes = _graph.getNodes();\r\n-        for (Iterator itr = nodes.iterator(); itr.hasNext();)\r\n-            _nodeInfo.put(itr.next(), new NodeInfo());\r\n-\r\n-        Object node;\r\n-        NodeInfo info;\r\n-        for (Iterator itr = nodes.iterator(); itr.hasNext();) {\r\n-            node = itr.next();\r\n-            info = (NodeInfo) _nodeInfo.get(node);\r\n-            if (info.color == NodeInfo.COLOR_WHITE)\r\n-                enqueue(node, info);\r\n-            processQueue();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Process the queue to see what data needs to be obtained.\r\n-     */\r\n-    private void processQueue() {\r\n-        Object node;\r\n-        Object other;\r\n-        NodeInfo info;\r\n-        NodeInfo otherInfo;\r\n-        Collection edges;\r\n-        Edge edge;\r\n-        while (_queue.size() > 0) {\r\n-            node = _queue.remove(0);\r\n-            info = (NodeInfo) _nodeInfo.get(node);\r\n-            visit(node, info);\r\n-\r\n-            edges = _graph.getEdgesFrom(node);\r\n-            for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n-                edge = (Edge) itr.next();\r\n-                edgeVisited(edge);\r\n-                other = edge.getOther(node);\r\n-                otherInfo = (NodeInfo) _nodeInfo.get(other);\r\n-                if (otherInfo.color == NodeInfo.COLOR_WHITE)\r\n-                    enqueue(other, otherInfo);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Push the given node onto the queue to be processed.\r\n-     * Notify visitors.\r\n-     */\r\n-    protected void enqueue(Object node, NodeInfo info) {\r\n-        _queue.add(node);\r\n-        info.color = NodeInfo.COLOR_GRAY;\r\n-        for (Iterator i = _visitors.iterator(); i.hasNext();)\r\n-            ((GraphVisitor) i.next()).nodeSeen(node);\r\n-    }\r\n-\r\n-    /**\r\n-     * Visit the node.  Mark the node black and notify visitors.\r\n-     */\r\n-    protected void visit(Object node, NodeInfo info) {\r\n-        info.color = NodeInfo.COLOR_BLACK;\r\n-        for (Iterator i = _visitors.iterator(); i.hasNext();)\r\n-            ((GraphVisitor) i.next()).nodeVisited(node);\r\n-    }\r\n-\r\n-    /**\r\n-     * An edge is seen.  Notify visitors.\r\n-     */\r\n-    protected void edgeVisited(Edge edge) {\r\n-        for (Iterator i = _visitors.iterator(); i.hasNext();)\r\n-            ((GraphVisitor) i.next()).edgeVisited(edge);\r\n-    }\r\n-\r\n-    /**\r\n-     * add a {@link GraphVisitor} to be notified during breadth first search.\r\n-     */\r\n-    public void addGraphVisitor(GraphVisitor visitor) {\r\n-        _visitors.add(visitor);\r\n-    }\r\n-\r\n-    /**\r\n-     * remove a given {@link GraphVisitor} from the listener set.\r\n-     */\r\n-    public void removeGraphVisitor(GraphVisitor visitor) {\r\n-        _visitors.remove(visitor);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.graph;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * <p>Performs a breadth-first walk of a given {@link Graph},\n+ * notifying visitors as it sees each node.  See the BFS algorithm\n+ * in the book 'Introduction to Algorithms' by Cormen, Leiserson, and\n+ * Rivest.</p>\n+ * <p/>\n+ * <p>Each {@link GraphVisitor} will be notified when a node\n+ * is colored black (nodeVisited), edge seen (edgeVisited),\n+ * and a node is seen for the first time, i.e. colored gray (nodeSeen).</p>\n+ *\n+ * @author Steve Kim\n+ * @since 1.0.0\n+ * @nojavadoc\n+ */\n+public class BreadthFirstWalk {\n+\n+    private final Graph _graph;\n+    private final Set _visitors = new HashSet();\n+    private final List _queue = new LinkedList();\n+    private final Map _nodeInfo = new HashMap();\n+\n+    public BreadthFirstWalk(Graph graph) {\n+        _graph = graph;\n+    }\n+\n+    /**\n+     * Begins the breadth first traversal.\n+     */\n+    public void walk() {\n+        _queue.clear();\n+        _nodeInfo.clear();\n+\n+        Collection nodes = _graph.getNodes();\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();)\n+            _nodeInfo.put(itr.next(), new NodeInfo());\n+\n+        Object node;\n+        NodeInfo info;\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();) {\n+            node = itr.next();\n+            info = (NodeInfo) _nodeInfo.get(node);\n+            if (info.color == NodeInfo.COLOR_WHITE)\n+                enqueue(node, info);\n+            processQueue();\n+        }\n+    }\n+\n+    /**\n+     * Process the queue to see what data needs to be obtained.\n+     */\n+    private void processQueue() {\n+        Object node;\n+        Object other;\n+        NodeInfo info;\n+        NodeInfo otherInfo;\n+        Collection edges;\n+        Edge edge;\n+        while (_queue.size() > 0) {\n+            node = _queue.remove(0);\n+            info = (NodeInfo) _nodeInfo.get(node);\n+            visit(node, info);\n+\n+            edges = _graph.getEdgesFrom(node);\n+            for (Iterator itr = edges.iterator(); itr.hasNext();) {\n+                edge = (Edge) itr.next();\n+                edgeVisited(edge);\n+                other = edge.getOther(node);\n+                otherInfo = (NodeInfo) _nodeInfo.get(other);\n+                if (otherInfo.color == NodeInfo.COLOR_WHITE)\n+                    enqueue(other, otherInfo);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Push the given node onto the queue to be processed.\n+     * Notify visitors.\n+     */\n+    protected void enqueue(Object node, NodeInfo info) {\n+        _queue.add(node);\n+        info.color = NodeInfo.COLOR_GRAY;\n+        for (Iterator i = _visitors.iterator(); i.hasNext();)\n+            ((GraphVisitor) i.next()).nodeSeen(node);\n+    }\n+\n+    /**\n+     * Visit the node.  Mark the node black and notify visitors.\n+     */\n+    protected void visit(Object node, NodeInfo info) {\n+        info.color = NodeInfo.COLOR_BLACK;\n+        for (Iterator i = _visitors.iterator(); i.hasNext();)\n+            ((GraphVisitor) i.next()).nodeVisited(node);\n+    }\n+\n+    /**\n+     * An edge is seen.  Notify visitors.\n+     */\n+    protected void edgeVisited(Edge edge) {\n+        for (Iterator i = _visitors.iterator(); i.hasNext();)\n+            ((GraphVisitor) i.next()).edgeVisited(edge);\n+    }\n+\n+    /**\n+     * add a {@link GraphVisitor} to be notified during breadth first search.\n+     */\n+    public void addGraphVisitor(GraphVisitor visitor) {\n+        _visitors.add(visitor);\n+    }\n+\n+    /**\n+     * remove a given {@link GraphVisitor} from the listener set.\n+     */\n+    public void removeGraphVisitor(GraphVisitor visitor) {\n+        _visitors.remove(visitor);\n+    }\n+}"},{"sha":"f1f5001cf0da8c0c7d9a01cd62bb96df94a7f054","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","status":"modified","additions":358,"deletions":358,"changes":716,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,358 +1,358 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.graph;\r\n-\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-\r\n-import java.util.AbstractList;\r\n-import java.util.ArrayList;\r\n-import java.util.Arrays;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.Comparator;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-/**\r\n- * <p>Performs a depth-first analysis of a given {@link Graph}, caching\r\n- * information about the graph's nodes and edges.  See the DFS algorithm\r\n- * in the book 'Introduction to Algorithms' by Cormen, Leiserson, and\r\n- * Rivest.  The algorithm has been modified to group sibling nodes without\r\n- * connections together during the topological sort.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 1.0.0\r\n- * @nojavadoc\r\n- */\r\n-public class DepthFirstAnalysis {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (DepthFirstAnalysis.class);\r\n-\r\n-    private final Graph _graph;\r\n-    private final Map _nodeInfo = new HashMap();\r\n-    private Comparator _comp;\r\n-\r\n-    /**\r\n-     * Constructor.  Performs the analysis on the given graph and caches\r\n-     * the resulting information.\r\n-     */\r\n-    public DepthFirstAnalysis(Graph graph) {\r\n-        _graph = graph;\r\n-\r\n-        // initialize node infos\r\n-        Collection nodes = graph.getNodes();\r\n-        for (Iterator itr = nodes.iterator(); itr.hasNext();)\r\n-            _nodeInfo.put(itr.next(), new NodeInfo());\r\n-\r\n-        // visit all nodes -- see intro to algo's book\r\n-        NodeInfo info;\r\n-        Object node;\r\n-        for (Iterator itr = nodes.iterator(); itr.hasNext();) {\r\n-            node = itr.next();\r\n-            info = (NodeInfo) _nodeInfo.get(node);\r\n-            if (info.color == NodeInfo.COLOR_WHITE)\r\n-                visit(graph, node, info, 0, new LinkedList());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Visit a node.  See Introduction to Algorithms book for details.\r\n-     */\r\n-    private int visit(Graph graph, Object node, NodeInfo info, int time, \r\n-        List path) {\r\n-        // discover node\r\n-        info.color = NodeInfo.COLOR_GRAY;\r\n-\r\n-        // explore all vertices from that node depth first\r\n-        Collection edges = graph.getEdgesFrom(node);\r\n-        Edge edge;\r\n-        Object other;\r\n-        NodeInfo otherInfo;\r\n-        int maxChildTime = time - 1;\r\n-        int childTime;\r\n-        for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n-            edge = (Edge) itr.next();\r\n-            other = edge.getOther(node);\r\n-            otherInfo = (NodeInfo) _nodeInfo.get(other);\r\n-            if (otherInfo.color == NodeInfo.COLOR_WHITE) {\r\n-                // undiscovered node; recurse into it\r\n-                path.add(edge);\r\n-                childTime = visit(graph, other, otherInfo, time, path);\r\n-                path.remove(edge);\r\n-                edge.setType(Edge.TYPE_TREE);\r\n-            } else if (otherInfo.color == NodeInfo.COLOR_GRAY) {\r\n-                childTime = -1;\r\n-                edge.setType(Edge.TYPE_BACK);\r\n-                // calculate the cycle including this edge\r\n-                edge.setCycle(cycleForBackEdge(edge, path));\r\n-            } else {\r\n-                childTime = otherInfo.finished;\r\n-                edge.setType(Edge.TYPE_FORWARD);\r\n-                // find the cycle including this edge\r\n-                List cycle = new LinkedList();\r\n-                cycle.add(edge);\r\n-                if (cycleForForwardEdge(graph, other, node, cycle)) {\r\n-                    edge.setCycle(cycle);\r\n-                }\r\n-            }\r\n-            maxChildTime = Math.max(maxChildTime, childTime);\r\n-        }\r\n-\r\n-        // finished with node\r\n-        info.color = NodeInfo.COLOR_BLACK;\r\n-        info.finished = maxChildTime + 1;\r\n-        return info.finished;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set the comparator that should be used for ordering groups of nodes\r\n-     * with the same dependencies.\r\n-     */\r\n-    public void setNodeComparator(Comparator comp) {\r\n-        _comp = comp;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the nodes in topologically-sorted order.  This is often used\r\n-     * to order dependencies.  If each graph edge (u, v) represents a\r\n-     * dependency of v on u, then this method will return the nodes in the\r\n-     * order that they should be evaluated to satisfy all dependencies.  Of\r\n-     * course, if the graph is cyclic (has back edges), then no such ordering\r\n-     * is possible, though this method will still return the correct order\r\n-     * as if edges creating the cycles did not exist.\r\n-     */\r\n-    public List getSortedNodes() {\r\n-        Map.Entry[] entries = (Map.Entry[]) _nodeInfo.entrySet().\r\n-            toArray(new Map.Entry[_nodeInfo.size()]);\r\n-        Arrays.sort(entries, new NodeInfoComparator(_comp));\r\n-        return new NodeList(entries);\r\n-    }\r\n-\r\n-    /**\r\n-     * Return all edges of the given type.  This method can be used to\r\n-     * discover all edges that cause cycles in the graph by passing it\r\n-     * the {@link Edge#TYPE_BACK} or {@link Edge#TYPE_FORWARD} edge type.\r\n-     */\r\n-    public Collection getEdges(int type) {\r\n-        Collection typed = null;\r\n-        Edge edge;\r\n-        Object node;\r\n-        for (Iterator nodes = _graph.getNodes().iterator(); nodes.hasNext();) {\r\n-            node = nodes.next();\r\n-            for (Iterator itr = _graph.getEdgesFrom(node).iterator();\r\n-                itr.hasNext();) {\r\n-                edge = (Edge) itr.next();\r\n-                if (edge.getType() == type) {\r\n-                    if (typed == null)\r\n-                        typed = new ArrayList();\r\n-                    typed.add(edge);\r\n-                }\r\n-            }\r\n-        }\r\n-        return (typed == null) ? Collections.EMPTY_LIST : typed;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the logical time that the given node was finished in\r\n-     * the graph walk, or -1 if the node is not part of the graph.\r\n-     */\r\n-    public int getFinishedTime(Object node) {\r\n-        NodeInfo info = (NodeInfo) _nodeInfo.get(node);\r\n-        if (info == null)\r\n-            return -1;\r\n-        return info.finished;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns a list of graph edges forming a cycle. The cycle begins \r\n-     * with a type {@link Edge#TYPE_BACK} edge.\r\n-     * @param backEdge \"Starting\" edge of the cycle\r\n-     * @param path Continuous list of graph edges, may be null\r\n-     * @param pos Index of the first edge in path continuing the cycle\r\n-     * @return Cycle starting with a type {@link Edge#TYPE_BACK} edge\r\n-     */\r\n-    private List buildCycle(Edge backEdge, List path, int pos) {\r\n-        int length = path != null ? path.size() - pos : 0;\r\n-        List cycle = new ArrayList(length + 1);\r\n-        cycle.add(0, backEdge);\r\n-        for (int i = 0; i < length; i++) {\r\n-            cycle.add(i + 1, path.get(pos + i));\r\n-        }\r\n-        return cycle;\r\n-    }\r\n-\r\n-    /**\r\n-     * Computes the list of edges forming a cycle. The cycle always exists for\r\n-     * a type {@link Edge#TYPE_BACK} edge. This method should only be called \r\n-     * for type {@link Edge#TYPE_BACK} edges. \r\n-     * @param edge Edge where the cycle was detected\r\n-     * @param path Path consisting of edges to the edge's starting node\r\n-     * @return Cycle starting with a type {@link Edge#TYPE_BACK} edge\r\n-     */\r\n-    private List cycleForBackEdge(Edge edge, List path) {\r\n-        if (edge.getType() != Edge.TYPE_BACK) {\r\n-            return null;\r\n-        }\r\n-        \r\n-        List cycle;\r\n-        int pos = 0;\r\n-        if (path != null && !edge.getFrom().equals(edge.getTo())) {\r\n-            // Not a single edge loop\r\n-            pos = findNodeInPath(edge.getTo(), path);\r\n-            assert (pos >= 0): _loc.get(\"node-not-on-path\", edge, edge.getTo()); \r\n-        } else {\r\n-            assert (edge.getFrom().equals(edge.getTo())): \r\n-                _loc.get(\"edge-no-loop\", edge).getMessage();\r\n-            path = null;\r\n-        }\r\n-        cycle = buildCycle(edge, path, pos); \r\n-        assert (cycle != null): _loc.get(\"cycle-null\", edge).getMessage();\r\n-        return cycle;\r\n-    }\r\n-\r\n-    /**\r\n-     * Computes the cycle of edges including node cycleTo. The cycle must not \r\n-     * necessarily exist. This method should only be called for type \r\n-     * {@link Edge#TYPE_FORWARD} edges.\r\n-     * @param graph Graph\r\n-     * @param node Current node\r\n-     * @param cycleTo End node for loop\r\n-     * @param path Path from loop end node to current node\r\n-     * @return True if a cycle has been found. The cycle will be contained in\r\n-     * the <code>path</code> parameter.\r\n-     */\r\n-    private boolean cycleForForwardEdge(Graph graph, Object node,\r\n-        Object cycleTo, List path) {                   \r\n-        boolean found = false;\r\n-        Collection edges = graph.getEdgesFrom(node);\r\n-        for (Iterator itr = edges.iterator(); !found && itr.hasNext();) {\r\n-            Edge edge = (Edge) itr.next();\r\n-            Object other = edge.getOther(node);\r\n-            // Single edge loops are ignored\r\n-            if (!node.equals(other)) {\r\n-                if (other.equals(cycleTo)) {\r\n-                    // Cycle complete\r\n-                    path.add(edge);\r\n-                    found = true;\r\n-                } else if (!path.contains(edge)){\r\n-                    // Walk this edge\r\n-                    path.add(edge);\r\n-                    found = cycleForForwardEdge(graph, other, cycleTo, path);\r\n-                    if (!found) {\r\n-                        // Remove edge again\r\n-                        path.remove(edge);                    \r\n-                    }\r\n-                }\r\n-            }\r\n-        }\r\n-        return found;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Finds the position of the edge starting from a particular node in the \r\n-     * continuous list of edges.\r\n-     * @param node Node on the cycle.\r\n-     * @param path Continuous list of graph edges.\r\n-     * @return Edge index if found, -1 otherwise.\r\n-     */\r\n-    private int findNodeInPath(Object node, List path) {\r\n-        int pos = -1;\r\n-        if (path != null) {\r\n-            for (int i = 0; i < path.size(); i++) {\r\n-                if (((Edge)path.get(i)).getFrom().equals(node)) {\r\n-                    pos = i;\r\n-                }\r\n-            }\r\n-        }\r\n-        return pos;\r\n-    }\r\n-\r\n-    /**\r\n-     * Test, if the analysis didn't find cycles.\r\n-     */\r\n-    public boolean hasNoCycles() {\r\n-        // a) there must not be any back edges\r\n-        if (!getEdges(Edge.TYPE_BACK).isEmpty()) {\r\n-            return false;\r\n-        }\r\n-        // b) there might be forward edges\r\n-        // make sure these don't indicate cycles\r\n-        Collection edges = getEdges(Edge.TYPE_FORWARD);\r\n-        if (!edges.isEmpty()) {\r\n-            for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n-                Edge edge = (Edge) itr.next();\r\n-                if (edge.getCycle() != null)  {\r\n-                    return false;\r\n-                }\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-    \r\n-    /**\r\n-     * Comparator for toplogically sorting entries in the node info map.\r\n-     */\r\n-    private static class NodeInfoComparator\r\n-        implements Comparator {\r\n-\r\n-        private final Comparator _subComp;\r\n-\r\n-        public NodeInfoComparator(Comparator subComp) {\r\n-            _subComp = subComp;\r\n-        }\r\n-\r\n-        public int compare(Object o1, Object o2) {\r\n-            Map.Entry e1 = (Map.Entry) o1;\r\n-            Map.Entry e2 = (Map.Entry) o2;\r\n-            NodeInfo n1 = (NodeInfo) e1.getValue();\r\n-            NodeInfo n2 = (NodeInfo) e2.getValue();\r\n-\r\n-            // sort by finished order\r\n-            int ret = n1.finished - n2.finished;\r\n-            if (ret == 0 && _subComp != null)\r\n-                ret = _subComp.compare(e1.getKey(), e2.getKey());\r\n-            return ret;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     *\tList of node-to-nodeinfo entries that exposes just the nodes.\r\n-     */\r\n-    private static class NodeList\r\n-        extends AbstractList {\r\n-\r\n-        private final Map.Entry[] _entries;\r\n-\r\n-        public NodeList(Map.Entry[] entries) {\r\n-            _entries = entries;\r\n-        }\r\n-\r\n-        public Object get(int idx) {\r\n-            return _entries[idx].getKey();\r\n-        }\r\n-\r\n-        public int size() {\r\n-            return _entries.length;\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.graph;\n+\n+import org.apache.openjpa.lib.util.Localizer;\n+\n+import java.util.AbstractList;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * <p>Performs a depth-first analysis of a given {@link Graph}, caching\n+ * information about the graph's nodes and edges.  See the DFS algorithm\n+ * in the book 'Introduction to Algorithms' by Cormen, Leiserson, and\n+ * Rivest.  The algorithm has been modified to group sibling nodes without\n+ * connections together during the topological sort.</p>\n+ *\n+ * @author Abe White\n+ * @since 1.0.0\n+ * @nojavadoc\n+ */\n+public class DepthFirstAnalysis {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (DepthFirstAnalysis.class);\n+\n+    private final Graph _graph;\n+    private final Map _nodeInfo = new HashMap();\n+    private Comparator _comp;\n+\n+    /**\n+     * Constructor.  Performs the analysis on the given graph and caches\n+     * the resulting information.\n+     */\n+    public DepthFirstAnalysis(Graph graph) {\n+        _graph = graph;\n+\n+        // initialize node infos\n+        Collection nodes = graph.getNodes();\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();)\n+            _nodeInfo.put(itr.next(), new NodeInfo());\n+\n+        // visit all nodes -- see intro to algo's book\n+        NodeInfo info;\n+        Object node;\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();) {\n+            node = itr.next();\n+            info = (NodeInfo) _nodeInfo.get(node);\n+            if (info.color == NodeInfo.COLOR_WHITE)\n+                visit(graph, node, info, 0, new LinkedList());\n+        }\n+    }\n+\n+    /**\n+     * Visit a node.  See Introduction to Algorithms book for details.\n+     */\n+    private int visit(Graph graph, Object node, NodeInfo info, int time, \n+        List path) {\n+        // discover node\n+        info.color = NodeInfo.COLOR_GRAY;\n+\n+        // explore all vertices from that node depth first\n+        Collection edges = graph.getEdgesFrom(node);\n+        Edge edge;\n+        Object other;\n+        NodeInfo otherInfo;\n+        int maxChildTime = time - 1;\n+        int childTime;\n+        for (Iterator itr = edges.iterator(); itr.hasNext();) {\n+            edge = (Edge) itr.next();\n+            other = edge.getOther(node);\n+            otherInfo = (NodeInfo) _nodeInfo.get(other);\n+            if (otherInfo.color == NodeInfo.COLOR_WHITE) {\n+                // undiscovered node; recurse into it\n+                path.add(edge);\n+                childTime = visit(graph, other, otherInfo, time, path);\n+                path.remove(edge);\n+                edge.setType(Edge.TYPE_TREE);\n+            } else if (otherInfo.color == NodeInfo.COLOR_GRAY) {\n+                childTime = -1;\n+                edge.setType(Edge.TYPE_BACK);\n+                // calculate the cycle including this edge\n+                edge.setCycle(cycleForBackEdge(edge, path));\n+            } else {\n+                childTime = otherInfo.finished;\n+                edge.setType(Edge.TYPE_FORWARD);\n+                // find the cycle including this edge\n+                List cycle = new LinkedList();\n+                cycle.add(edge);\n+                if (cycleForForwardEdge(graph, other, node, cycle)) {\n+                    edge.setCycle(cycle);\n+                }\n+            }\n+            maxChildTime = Math.max(maxChildTime, childTime);\n+        }\n+\n+        // finished with node\n+        info.color = NodeInfo.COLOR_BLACK;\n+        info.finished = maxChildTime + 1;\n+        return info.finished;\n+    }\n+\n+    /**\n+     * Set the comparator that should be used for ordering groups of nodes\n+     * with the same dependencies.\n+     */\n+    public void setNodeComparator(Comparator comp) {\n+        _comp = comp;\n+    }\n+\n+    /**\n+     * Return the nodes in topologically-sorted order.  This is often used\n+     * to order dependencies.  If each graph edge (u, v) represents a\n+     * dependency of v on u, then this method will return the nodes in the\n+     * order that they should be evaluated to satisfy all dependencies.  Of\n+     * course, if the graph is cyclic (has back edges), then no such ordering\n+     * is possible, though this method will still return the correct order\n+     * as if edges creating the cycles did not exist.\n+     */\n+    public List getSortedNodes() {\n+        Map.Entry[] entries = (Map.Entry[]) _nodeInfo.entrySet().\n+            toArray(new Map.Entry[_nodeInfo.size()]);\n+        Arrays.sort(entries, new NodeInfoComparator(_comp));\n+        return new NodeList(entries);\n+    }\n+\n+    /**\n+     * Return all edges of the given type.  This method can be used to\n+     * discover all edges that cause cycles in the graph by passing it\n+     * the {@link Edge#TYPE_BACK} or {@link Edge#TYPE_FORWARD} edge type.\n+     */\n+    public Collection getEdges(int type) {\n+        Collection typed = null;\n+        Edge edge;\n+        Object node;\n+        for (Iterator nodes = _graph.getNodes().iterator(); nodes.hasNext();) {\n+            node = nodes.next();\n+            for (Iterator itr = _graph.getEdgesFrom(node).iterator();\n+                itr.hasNext();) {\n+                edge = (Edge) itr.next();\n+                if (edge.getType() == type) {\n+                    if (typed == null)\n+                        typed = new ArrayList();\n+                    typed.add(edge);\n+                }\n+            }\n+        }\n+        return (typed == null) ? Collections.EMPTY_LIST : typed;\n+    }\n+\n+    /**\n+     * Return the logical time that the given node was finished in\n+     * the graph walk, or -1 if the node is not part of the graph.\n+     */\n+    public int getFinishedTime(Object node) {\n+        NodeInfo info = (NodeInfo) _nodeInfo.get(node);\n+        if (info == null)\n+            return -1;\n+        return info.finished;\n+    }\n+\n+    /**\n+     * Returns a list of graph edges forming a cycle. The cycle begins \n+     * with a type {@link Edge#TYPE_BACK} edge.\n+     * @param backEdge \"Starting\" edge of the cycle\n+     * @param path Continuous list of graph edges, may be null\n+     * @param pos Index of the first edge in path continuing the cycle\n+     * @return Cycle starting with a type {@link Edge#TYPE_BACK} edge\n+     */\n+    private List buildCycle(Edge backEdge, List path, int pos) {\n+        int length = path != null ? path.size() - pos : 0;\n+        List cycle = new ArrayList(length + 1);\n+        cycle.add(0, backEdge);\n+        for (int i = 0; i < length; i++) {\n+            cycle.add(i + 1, path.get(pos + i));\n+        }\n+        return cycle;\n+    }\n+\n+    /**\n+     * Computes the list of edges forming a cycle. The cycle always exists for\n+     * a type {@link Edge#TYPE_BACK} edge. This method should only be called \n+     * for type {@link Edge#TYPE_BACK} edges. \n+     * @param edge Edge where the cycle was detected\n+     * @param path Path consisting of edges to the edge's starting node\n+     * @return Cycle starting with a type {@link Edge#TYPE_BACK} edge\n+     */\n+    private List cycleForBackEdge(Edge edge, List path) {\n+        if (edge.getType() != Edge.TYPE_BACK) {\n+            return null;\n+        }\n+        \n+        List cycle;\n+        int pos = 0;\n+        if (path != null && !edge.getFrom().equals(edge.getTo())) {\n+            // Not a single edge loop\n+            pos = findNodeInPath(edge.getTo(), path);\n+            assert (pos >= 0): _loc.get(\"node-not-on-path\", edge, edge.getTo()); \n+        } else {\n+            assert (edge.getFrom().equals(edge.getTo())): \n+                _loc.get(\"edge-no-loop\", edge).getMessage();\n+            path = null;\n+        }\n+        cycle = buildCycle(edge, path, pos); \n+        assert (cycle != null): _loc.get(\"cycle-null\", edge).getMessage();\n+        return cycle;\n+    }\n+\n+    /**\n+     * Computes the cycle of edges including node cycleTo. The cycle must not \n+     * necessarily exist. This method should only be called for type \n+     * {@link Edge#TYPE_FORWARD} edges.\n+     * @param graph Graph\n+     * @param node Current node\n+     * @param cycleTo End node for loop\n+     * @param path Path from loop end node to current node\n+     * @return True if a cycle has been found. The cycle will be contained in\n+     * the <code>path</code> parameter.\n+     */\n+    private boolean cycleForForwardEdge(Graph graph, Object node,\n+        Object cycleTo, List path) {                   \n+        boolean found = false;\n+        Collection edges = graph.getEdgesFrom(node);\n+        for (Iterator itr = edges.iterator(); !found && itr.hasNext();) {\n+            Edge edge = (Edge) itr.next();\n+            Object other = edge.getOther(node);\n+            // Single edge loops are ignored\n+            if (!node.equals(other)) {\n+                if (other.equals(cycleTo)) {\n+                    // Cycle complete\n+                    path.add(edge);\n+                    found = true;\n+                } else if (!path.contains(edge)){\n+                    // Walk this edge\n+                    path.add(edge);\n+                    found = cycleForForwardEdge(graph, other, cycleTo, path);\n+                    if (!found) {\n+                        // Remove edge again\n+                        path.remove(edge);                    \n+                    }\n+                }\n+            }\n+        }\n+        return found;\n+    }\n+    \n+    /**\n+     * Finds the position of the edge starting from a particular node in the \n+     * continuous list of edges.\n+     * @param node Node on the cycle.\n+     * @param path Continuous list of graph edges.\n+     * @return Edge index if found, -1 otherwise.\n+     */\n+    private int findNodeInPath(Object node, List path) {\n+        int pos = -1;\n+        if (path != null) {\n+            for (int i = 0; i < path.size(); i++) {\n+                if (((Edge)path.get(i)).getFrom().equals(node)) {\n+                    pos = i;\n+                }\n+            }\n+        }\n+        return pos;\n+    }\n+\n+    /**\n+     * Test, if the analysis didn't find cycles.\n+     */\n+    public boolean hasNoCycles() {\n+        // a) there must not be any back edges\n+        if (!getEdges(Edge.TYPE_BACK).isEmpty()) {\n+            return false;\n+        }\n+        // b) there might be forward edges\n+        // make sure these don't indicate cycles\n+        Collection edges = getEdges(Edge.TYPE_FORWARD);\n+        if (!edges.isEmpty()) {\n+            for (Iterator itr = edges.iterator(); itr.hasNext();) {\n+                Edge edge = (Edge) itr.next();\n+                if (edge.getCycle() != null)  {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Comparator for toplogically sorting entries in the node info map.\n+     */\n+    private static class NodeInfoComparator\n+        implements Comparator {\n+\n+        private final Comparator _subComp;\n+\n+        public NodeInfoComparator(Comparator subComp) {\n+            _subComp = subComp;\n+        }\n+\n+        public int compare(Object o1, Object o2) {\n+            Map.Entry e1 = (Map.Entry) o1;\n+            Map.Entry e2 = (Map.Entry) o2;\n+            NodeInfo n1 = (NodeInfo) e1.getValue();\n+            NodeInfo n2 = (NodeInfo) e2.getValue();\n+\n+            // sort by finished order\n+            int ret = n1.finished - n2.finished;\n+            if (ret == 0 && _subComp != null)\n+                ret = _subComp.compare(e1.getKey(), e2.getKey());\n+            return ret;\n+        }\n+    }\n+\n+    /**\n+     *\tList of node-to-nodeinfo entries that exposes just the nodes.\n+     */\n+    private static class NodeList\n+        extends AbstractList {\n+\n+        private final Map.Entry[] _entries;\n+\n+        public NodeList(Map.Entry[] entries) {\n+            _entries = entries;\n+        }\n+\n+        public Object get(int idx) {\n+            return _entries[idx].getKey();\n+        }\n+\n+        public int size() {\n+            return _entries.length;\n+\t\t}\n+\t}\n+}"},{"sha":"aa57109b62f5fcfde616c78983d9928b955271b3","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","status":"modified","additions":222,"deletions":222,"changes":444,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,222 +1,222 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.graph;\r\n-\r\n-import java.util.List;\r\n-\r\n-/**\r\n- * <p>A graph edge.  Includes the from and to nodes, an arbitrary user object,\r\n- * and a weight.  Edges can be either directed or undirected.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 1.0.0\r\n- * @nojavadoc\r\n- */\r\n-public class Edge {\r\n-\r\n-    /**\r\n-     * An edge (u, v) is a tree edge if node v was first discovered by\r\n-     * traversing the edge.\r\n-     */\r\n-    public static final int TYPE_TREE = 1;\r\n-\r\n-    /**\r\n-     * An edge (u, v) is a back edge if it creates a cycle back to an\r\n-     * ancestor in the graph.\r\n-     */\r\n-    public static final int TYPE_BACK = 2;\r\n-\r\n-    /**\r\n-     * An edge (u, v) is a forward edge if it is not a tree or back edge.\r\n-     */\r\n-    public static final int TYPE_FORWARD = 3;\r\n-\r\n-    private final Object _from;\r\n-    private final Object _to;\r\n-    private final boolean _directed;\r\n-\r\n-    private int _type = 0;\r\n-    private double _weight = 0;\r\n-    private Object _userObj = null;\r\n-    private List _cycle = null;\r\n-    private boolean _removedFromGraph = false;\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param    from        the node the edge comes from\r\n-     * @param    to            the node the edge goes to\r\n-     * @param    directed    whether the edge is directed\r\n-     */\r\n-    public Edge(Object from, Object to, boolean directed) {\r\n-        if (from == null)\r\n-            throw new NullPointerException(\"from == null\");\r\n-        if (to == null)\r\n-            throw new NullPointerException(\"to == null\");\r\n-        _from = from;\r\n-        _to = to;\r\n-        _directed = directed;\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructor.\r\n-     *\r\n-     * @param    from        the node the edge comes from\r\n-     * @param    to            the node the edge goes to\r\n-     * @param    directed    whether the edge is directed\r\n-     * @param    userObject    an associated object\r\n-     */\r\n-    public Edge(Object from, Object to, boolean directed, Object userObject) {\r\n-        this(from, to, directed);\r\n-        _userObj = userObject;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the node the edge links from.\r\n-     */\r\n-    public Object getFrom() {\r\n-        return _from;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the node the edge links to.\r\n-     */\r\n-    public Object getTo() {\r\n-        return _to;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the node on the opposite end of the given one, or null if the\r\n-     * given node is not part of this edge.\r\n-     */\r\n-    public Object getOther(Object node) {\r\n-        if (_to.equals(node))\r\n-            return _from;\r\n-        if (_from.equals(node))\r\n-            return _to;\r\n-        return null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return true if this edge links to the given node.  For undirected edges,\r\n-     * this method returns true if either side is equal to the given node.\r\n-     */\r\n-    public boolean isTo(Object node) {\r\n-        return _to.equals(node) || (!_directed && _from.equals(node));\r\n-    }\r\n-\r\n-    /**\r\n-     * Return true if this edge links from the given node.  For undirected\r\n-     * edges, this method returns true if either side is equal to the given\r\n-     * node.\r\n-     */\r\n-    public boolean isFrom(Object node) {\r\n-        return _from.equals(node) || (!_directed && _to.equals(node));\r\n-    }\r\n-\r\n-    /**\r\n-     * Return whether the edge is directed.\r\n-     */\r\n-    public boolean isDirected() {\r\n-        return _directed;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the weight of the edge.\r\n-     */\r\n-    public double getWeight() {\r\n-        return _weight;\r\n-    }\r\n-\r\n-    /**\r\n-     * Set the weight of the edge.\r\n-     */\r\n-    public void setWeight(double weight) {\r\n-        _weight = weight;\r\n-    }\r\n-\r\n-    /**\r\n-     * Arbitrary user object associated with the edge.\r\n-     */\r\n-    public Object getUserObject() {\r\n-        return _userObj;\r\n-    }\r\n-\r\n-    /**\r\n-     * Arbitrary user object associated with the edge.\r\n-     */\r\n-    public void setUserObject(Object obj) {\r\n-        _userObj = obj;\r\n-    }\r\n-\r\n-    /**\r\n-     * Traversal bookkeeping info.\r\n-     */\r\n-    public int getType() {\r\n-        return _type;\r\n-    }\r\n-\r\n-    /**\r\n-     * Traversal bookkeeping info.\r\n-     */\r\n-    public void setType(int type) {\r\n-        _type = type;\r\n-    }\r\n-\r\n-    /**\r\n-     * List of edges forming a cycle. Only set for TYPE_BACK and TYPE_FORWARD edges.\r\n-     */\r\n-    public List getCycle() {\r\n-        return _cycle;\r\n-    }\r\n-    \r\n-    /**\r\n-     * List of edges forming a cycle. Only set for TYPE_BACK and TYPE_FORWARD edges.\r\n-     */\r\n-    public void setCycle(List cycle) {\r\n-        _cycle = cycle;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns if this edge is (still) part of the graph.\r\n-     */\r\n-    public boolean isRemovedFromGraph() {\r\n-        return _removedFromGraph;\r\n-    }\r\n-\r\n-    /**\r\n-     * Mark this edge as removed from the graph.\r\n-     */\r\n-    public void setRemovedFromGraph() {\r\n-        this._removedFromGraph = true;\r\n-    }\r\n-\r\n-    /**\r\n-     * Clear traversal info.\r\n-     */\r\n-    public void clearTraversal() {\r\n-        _type = 0;\r\n-        _cycle = null;\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        return super.toString() + \"[from=\" + getFrom() + \";to=\" + getTo()\r\n-            + \";directed=\" + isDirected () + \";weight=\" + getWeight () + \"]\";\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.graph;\n+\n+import java.util.List;\n+\n+/**\n+ * <p>A graph edge.  Includes the from and to nodes, an arbitrary user object,\n+ * and a weight.  Edges can be either directed or undirected.</p>\n+ *\n+ * @author Abe White\n+ * @since 1.0.0\n+ * @nojavadoc\n+ */\n+public class Edge {\n+\n+    /**\n+     * An edge (u, v) is a tree edge if node v was first discovered by\n+     * traversing the edge.\n+     */\n+    public static final int TYPE_TREE = 1;\n+\n+    /**\n+     * An edge (u, v) is a back edge if it creates a cycle back to an\n+     * ancestor in the graph.\n+     */\n+    public static final int TYPE_BACK = 2;\n+\n+    /**\n+     * An edge (u, v) is a forward edge if it is not a tree or back edge.\n+     */\n+    public static final int TYPE_FORWARD = 3;\n+\n+    private final Object _from;\n+    private final Object _to;\n+    private final boolean _directed;\n+\n+    private int _type = 0;\n+    private double _weight = 0;\n+    private Object _userObj = null;\n+    private List _cycle = null;\n+    private boolean _removedFromGraph = false;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param    from        the node the edge comes from\n+     * @param    to            the node the edge goes to\n+     * @param    directed    whether the edge is directed\n+     */\n+    public Edge(Object from, Object to, boolean directed) {\n+        if (from == null)\n+            throw new NullPointerException(\"from == null\");\n+        if (to == null)\n+            throw new NullPointerException(\"to == null\");\n+        _from = from;\n+        _to = to;\n+        _directed = directed;\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param    from        the node the edge comes from\n+     * @param    to            the node the edge goes to\n+     * @param    directed    whether the edge is directed\n+     * @param    userObject    an associated object\n+     */\n+    public Edge(Object from, Object to, boolean directed, Object userObject) {\n+        this(from, to, directed);\n+        _userObj = userObject;\n+    }\n+\n+    /**\n+     * Return the node the edge links from.\n+     */\n+    public Object getFrom() {\n+        return _from;\n+    }\n+\n+    /**\n+     * Return the node the edge links to.\n+     */\n+    public Object getTo() {\n+        return _to;\n+    }\n+\n+    /**\n+     * Return the node on the opposite end of the given one, or null if the\n+     * given node is not part of this edge.\n+     */\n+    public Object getOther(Object node) {\n+        if (_to.equals(node))\n+            return _from;\n+        if (_from.equals(node))\n+            return _to;\n+        return null;\n+    }\n+\n+    /**\n+     * Return true if this edge links to the given node.  For undirected edges,\n+     * this method returns true if either side is equal to the given node.\n+     */\n+    public boolean isTo(Object node) {\n+        return _to.equals(node) || (!_directed && _from.equals(node));\n+    }\n+\n+    /**\n+     * Return true if this edge links from the given node.  For undirected\n+     * edges, this method returns true if either side is equal to the given\n+     * node.\n+     */\n+    public boolean isFrom(Object node) {\n+        return _from.equals(node) || (!_directed && _to.equals(node));\n+    }\n+\n+    /**\n+     * Return whether the edge is directed.\n+     */\n+    public boolean isDirected() {\n+        return _directed;\n+    }\n+\n+    /**\n+     * Return the weight of the edge.\n+     */\n+    public double getWeight() {\n+        return _weight;\n+    }\n+\n+    /**\n+     * Set the weight of the edge.\n+     */\n+    public void setWeight(double weight) {\n+        _weight = weight;\n+    }\n+\n+    /**\n+     * Arbitrary user object associated with the edge.\n+     */\n+    public Object getUserObject() {\n+        return _userObj;\n+    }\n+\n+    /**\n+     * Arbitrary user object associated with the edge.\n+     */\n+    public void setUserObject(Object obj) {\n+        _userObj = obj;\n+    }\n+\n+    /**\n+     * Traversal bookkeeping info.\n+     */\n+    public int getType() {\n+        return _type;\n+    }\n+\n+    /**\n+     * Traversal bookkeeping info.\n+     */\n+    public void setType(int type) {\n+        _type = type;\n+    }\n+\n+    /**\n+     * List of edges forming a cycle. Only set for TYPE_BACK and TYPE_FORWARD edges.\n+     */\n+    public List getCycle() {\n+        return _cycle;\n+    }\n+    \n+    /**\n+     * List of edges forming a cycle. Only set for TYPE_BACK and TYPE_FORWARD edges.\n+     */\n+    public void setCycle(List cycle) {\n+        _cycle = cycle;\n+    }\n+\n+    /**\n+     * Returns if this edge is (still) part of the graph.\n+     */\n+    public boolean isRemovedFromGraph() {\n+        return _removedFromGraph;\n+    }\n+\n+    /**\n+     * Mark this edge as removed from the graph.\n+     */\n+    public void setRemovedFromGraph() {\n+        this._removedFromGraph = true;\n+    }\n+\n+    /**\n+     * Clear traversal info.\n+     */\n+    public void clearTraversal() {\n+        _type = 0;\n+        _cycle = null;\n+    }\n+\n+    public String toString() {\n+        return super.toString() + \"[from=\" + getFrom() + \";to=\" + getTo()\n+            + \";directed=\" + isDirected () + \";weight=\" + getWeight () + \"]\";\n+\t}\n+}"},{"sha":"77f9d74ead100310ffe8136d3f3039c8b5b5d95f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","status":"modified","additions":202,"deletions":202,"changes":404,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,202 +1,202 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.graph;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedHashMap;\r\n-import java.util.Map;\r\n-\r\n-/**\r\n- * <p>Graph representation using the adjacency list form.  See the book\r\n- * 'Introduction to Algorithms' by Cormen, Leiserson, and Rivest.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 1.0.0\r\n- * @nojavadoc\r\n- */\r\n-public class Graph {\r\n-\r\n-    /**\r\n-     * Map each node to list of edges from that node.\r\n-     * Using a LinkedHashMap to ensure order of iterator processing.\r\n-     */ \r\n-    private final Map _nodes = new LinkedHashMap();\r\n-\r\n-    /**\r\n-     * Clear the graph.\r\n-     */\r\n-    public void clear() {\r\n-        _nodes.clear();\r\n-    }\r\n-\r\n-    /**\r\n-     * Return true if the graph contains the given node.\r\n-     */\r\n-    public boolean containsNode(Object node) {\r\n-        return _nodes.containsKey(node);\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a view of all nodes in the graph.\r\n-     */\r\n-    public Collection getNodes() {\r\n-        return _nodes.keySet();\r\n-    }\r\n-\r\n-    /**\r\n-     * Add a node to the graph.  Adding a node a second time has no effect.\r\n-     */\r\n-    public void addNode(Object node) {\r\n-        if (node == null)\r\n-            throw new NullPointerException(\"node = null\");\r\n-        if (!containsNode(node))\r\n-            _nodes.put(node, null);\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove a node from the graph.  All edges to and from the node\r\n-     * will be cleared.\r\n-     *\r\n-     * @return true if the node was removed, false otherwise\r\n-     */\r\n-    public boolean removeNode(Object node) {\r\n-        boolean rem = containsNode(node);\r\n-        if (rem) {\r\n-            Collection edges = getEdgesTo(node);\r\n-            for (Iterator itr = edges.iterator(); itr.hasNext();)\r\n-                removeEdge((Edge) itr.next());\r\n-            _nodes.remove(node);\r\n-        }\r\n-        return rem;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return all edges in the graph.\r\n-     */\r\n-    public Collection getEdges() {\r\n-        Collection all = new HashSet();\r\n-        Collection edges;\r\n-        for (Iterator itr = _nodes.values().iterator(); itr.hasNext();) {\r\n-            edges = (Collection) itr.next();\r\n-            if (edges != null)\r\n-                all.addAll(edges);\r\n-        }\r\n-        return all;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return all the edges from a particular node.\r\n-     */\r\n-    public Collection getEdgesFrom(Object node) {\r\n-        Collection edges = (Collection) _nodes.get(node);\r\n-        return (edges == null) ? Collections.EMPTY_LIST : edges;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return all the edges to a particular node.\r\n-     */\r\n-    public Collection getEdgesTo(Object node) {\r\n-        Collection edges = getEdges();\r\n-        Collection to = new ArrayList();\r\n-        Edge edge;\r\n-        for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n-            edge = (Edge) itr.next();\r\n-            if (edge.isTo(node))\r\n-                to.add(edge);\r\n-        }\r\n-        return to;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return all the edges from one node to another.\r\n-     */\r\n-    public Collection getEdges(Object from, Object to) {\r\n-        Collection edges = getEdgesFrom(from);\r\n-        Collection matches = new ArrayList(edges.size());\r\n-        Edge edge;\r\n-        for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n-            edge = (Edge) itr.next();\r\n-            if (edge.isTo(to))\r\n-                matches.add(edge);\r\n-        }\r\n-        return matches;\r\n-    }\r\n-\r\n-    /**\r\n-     * Add an edge to the graph.\r\n-     */\r\n-    public void addEdge(Edge edge) {\r\n-        if (!containsNode(edge.getTo()))\r\n-            throw new IllegalArgumentException(edge.getTo().toString());\r\n-        if (!containsNode(edge.getFrom()))\r\n-            throw new IllegalArgumentException(edge.getFrom().toString());\r\n-\r\n-        Collection from = (Collection) _nodes.get(edge.getFrom());\r\n-        if (from == null) {\r\n-            from = new ArrayList(3);\r\n-            _nodes.put(edge.getFrom(), from);\r\n-        }\r\n-        from.add(edge);\r\n-\r\n-        if (!edge.isDirected() && !edge.getFrom().equals(edge.getTo())) {\r\n-            Collection to = (Collection) _nodes.get(edge.getTo());\r\n-            if (to == null) {\r\n-                to = new ArrayList(3);\r\n-                _nodes.put(edge.getTo(), to);\r\n-            }\r\n-            to.add(edge);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove an edge from the graph.\r\n-     *\r\n-     * @return true if the edge was removed, false if not in the graph\r\n-     */\r\n-    public boolean removeEdge(Edge edge) {\r\n-        Collection edges = (Collection) _nodes.get(edge.getFrom());\r\n-        if (edges == null)\r\n-            return false;\r\n-        boolean rem = edges.remove(edge);\r\n-        if (rem && !edge.isDirected()) {\r\n-            edges = (Collection) _nodes.get(edge.getTo());\r\n-            if (edges != null)\r\n-                edges.remove(edge);\r\n-        }\r\n-        return rem;\r\n-    }\r\n-\r\n-    /**\r\n-     *\tClear all nodes and edges of the bookkeeping information from their\r\n-     *\tlast traversal.\r\n-     */\r\n-    public void clearTraversal() {\r\n-        Collection edges;\r\n-        for (Iterator vals = _nodes.values().iterator(); vals.hasNext();) {\r\n-            edges = (Collection) vals.next();\r\n-            if (edges != null)\r\n-                for (Iterator ed = edges.iterator(); ed.hasNext();)\r\n-                    ((Edge) ed.next()).clearTraversal ();\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.graph;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * <p>Graph representation using the adjacency list form.  See the book\n+ * 'Introduction to Algorithms' by Cormen, Leiserson, and Rivest.</p>\n+ *\n+ * @author Abe White\n+ * @since 1.0.0\n+ * @nojavadoc\n+ */\n+public class Graph {\n+\n+    /**\n+     * Map each node to list of edges from that node.\n+     * Using a LinkedHashMap to ensure order of iterator processing.\n+     */ \n+    private final Map _nodes = new LinkedHashMap();\n+\n+    /**\n+     * Clear the graph.\n+     */\n+    public void clear() {\n+        _nodes.clear();\n+    }\n+\n+    /**\n+     * Return true if the graph contains the given node.\n+     */\n+    public boolean containsNode(Object node) {\n+        return _nodes.containsKey(node);\n+    }\n+\n+    /**\n+     * Return a view of all nodes in the graph.\n+     */\n+    public Collection getNodes() {\n+        return _nodes.keySet();\n+    }\n+\n+    /**\n+     * Add a node to the graph.  Adding a node a second time has no effect.\n+     */\n+    public void addNode(Object node) {\n+        if (node == null)\n+            throw new NullPointerException(\"node = null\");\n+        if (!containsNode(node))\n+            _nodes.put(node, null);\n+    }\n+\n+    /**\n+     * Remove a node from the graph.  All edges to and from the node\n+     * will be cleared.\n+     *\n+     * @return true if the node was removed, false otherwise\n+     */\n+    public boolean removeNode(Object node) {\n+        boolean rem = containsNode(node);\n+        if (rem) {\n+            Collection edges = getEdgesTo(node);\n+            for (Iterator itr = edges.iterator(); itr.hasNext();)\n+                removeEdge((Edge) itr.next());\n+            _nodes.remove(node);\n+        }\n+        return rem;\n+    }\n+\n+    /**\n+     * Return all edges in the graph.\n+     */\n+    public Collection getEdges() {\n+        Collection all = new HashSet();\n+        Collection edges;\n+        for (Iterator itr = _nodes.values().iterator(); itr.hasNext();) {\n+            edges = (Collection) itr.next();\n+            if (edges != null)\n+                all.addAll(edges);\n+        }\n+        return all;\n+    }\n+\n+    /**\n+     * Return all the edges from a particular node.\n+     */\n+    public Collection getEdgesFrom(Object node) {\n+        Collection edges = (Collection) _nodes.get(node);\n+        return (edges == null) ? Collections.EMPTY_LIST : edges;\n+    }\n+\n+    /**\n+     * Return all the edges to a particular node.\n+     */\n+    public Collection getEdgesTo(Object node) {\n+        Collection edges = getEdges();\n+        Collection to = new ArrayList();\n+        Edge edge;\n+        for (Iterator itr = edges.iterator(); itr.hasNext();) {\n+            edge = (Edge) itr.next();\n+            if (edge.isTo(node))\n+                to.add(edge);\n+        }\n+        return to;\n+    }\n+\n+    /**\n+     * Return all the edges from one node to another.\n+     */\n+    public Collection getEdges(Object from, Object to) {\n+        Collection edges = getEdgesFrom(from);\n+        Collection matches = new ArrayList(edges.size());\n+        Edge edge;\n+        for (Iterator itr = edges.iterator(); itr.hasNext();) {\n+            edge = (Edge) itr.next();\n+            if (edge.isTo(to))\n+                matches.add(edge);\n+        }\n+        return matches;\n+    }\n+\n+    /**\n+     * Add an edge to the graph.\n+     */\n+    public void addEdge(Edge edge) {\n+        if (!containsNode(edge.getTo()))\n+            throw new IllegalArgumentException(edge.getTo().toString());\n+        if (!containsNode(edge.getFrom()))\n+            throw new IllegalArgumentException(edge.getFrom().toString());\n+\n+        Collection from = (Collection) _nodes.get(edge.getFrom());\n+        if (from == null) {\n+            from = new ArrayList(3);\n+            _nodes.put(edge.getFrom(), from);\n+        }\n+        from.add(edge);\n+\n+        if (!edge.isDirected() && !edge.getFrom().equals(edge.getTo())) {\n+            Collection to = (Collection) _nodes.get(edge.getTo());\n+            if (to == null) {\n+                to = new ArrayList(3);\n+                _nodes.put(edge.getTo(), to);\n+            }\n+            to.add(edge);\n+        }\n+    }\n+\n+    /**\n+     * Remove an edge from the graph.\n+     *\n+     * @return true if the edge was removed, false if not in the graph\n+     */\n+    public boolean removeEdge(Edge edge) {\n+        Collection edges = (Collection) _nodes.get(edge.getFrom());\n+        if (edges == null)\n+            return false;\n+        boolean rem = edges.remove(edge);\n+        if (rem && !edge.isDirected()) {\n+            edges = (Collection) _nodes.get(edge.getTo());\n+            if (edges != null)\n+                edges.remove(edge);\n+        }\n+        return rem;\n+    }\n+\n+    /**\n+     *\tClear all nodes and edges of the bookkeeping information from their\n+     *\tlast traversal.\n+     */\n+    public void clearTraversal() {\n+        Collection edges;\n+        for (Iterator vals = _nodes.values().iterator(); vals.hasNext();) {\n+            edges = (Collection) vals.next();\n+            if (edges != null)\n+                for (Iterator ed = edges.iterator(); ed.hasNext();)\n+                    ((Edge) ed.next()).clearTraversal ();\n+\t\t}\n+\t}\n+}"},{"sha":"b9c67ff6daef47f8283e81ae68d4682c458c69ca","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","status":"modified","additions":47,"deletions":47,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,47 +1,47 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.graph;\r\n-\r\n-/**\r\n- * <p>A helper interface that allows third parties to be notified of\r\n- * graph events during graph traversals</p>\r\n- *\r\n- * @author Steve Kim\r\n- * @since 1.0.0\r\n- * @nojavadoc\r\n- */\r\n-public interface GraphVisitor {\r\n-\r\n-    /**\r\n-     * May not be called.  The meaning of this method is dependent\r\n-     * on the traversal being used.  See each appropriate graph\r\n-     * walker for details.\r\n-     */\r\n-    public void nodeSeen(Object node);\r\n-\r\n-    /**\r\n-     * will only be called once per node\r\n-     */\r\n-    public void nodeVisited(Object node);\r\n-\r\n-    /**\r\n-     * may visit the node twice (both sides)\r\n-     */\r\n-    public void edgeVisited(Edge edge);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.graph;\n+\n+/**\n+ * <p>A helper interface that allows third parties to be notified of\n+ * graph events during graph traversals</p>\n+ *\n+ * @author Steve Kim\n+ * @since 1.0.0\n+ * @nojavadoc\n+ */\n+public interface GraphVisitor {\n+\n+    /**\n+     * May not be called.  The meaning of this method is dependent\n+     * on the traversal being used.  See each appropriate graph\n+     * walker for details.\n+     */\n+    public void nodeSeen(Object node);\n+\n+    /**\n+     * will only be called once per node\n+     */\n+    public void nodeVisited(Object node);\n+\n+    /**\n+     * may visit the node twice (both sides)\n+     */\n+    public void edgeVisited(Edge edge);\n+}"},{"sha":"9ece659a36b83abf2776a321fac1b2178f77d51d","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","status":"modified","additions":35,"deletions":35,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,35 +1,35 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.graph;\r\n-\r\n-/**\r\n- * <p>Struct used to track graph node information during traversal.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 1.0.0\r\n- */\r\n-class NodeInfo {\r\n-\r\n-    public static final int COLOR_WHITE = 0;\r\n-    public static final int COLOR_GRAY = 1;\r\n-    public static final int COLOR_BLACK = 2;\r\n-\r\n-    public int finished = 0;\r\n-    public int color = COLOR_WHITE;\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.graph;\n+\n+/**\n+ * <p>Struct used to track graph node information during traversal.</p>\n+ *\n+ * @author Abe White\n+ * @since 1.0.0\n+ */\n+class NodeInfo {\n+\n+    public static final int COLOR_WHITE = 0;\n+    public static final int COLOR_GRAY = 1;\n+    public static final int COLOR_BLACK = 2;\n+\n+    public int finished = 0;\n+    public int color = COLOR_WHITE;\n+}"},{"sha":"6f3b4e03facbf8a58630a4147c9e9ea6792e37dd","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","status":"modified","additions":773,"deletions":773,"changes":1546,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,773 +1,773 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.lib.jdbc;\r\n-\r\n-import java.sql.Connection;\r\n-import java.sql.DatabaseMetaData;\r\n-import java.sql.ResultSet;\r\n-import java.sql.SQLException;\r\n-\r\n-/**\r\n- * Wrapper around a DatabaseMetadata instance.\r\n- *\r\n- * @author Marc Prud'hommeaux\r\n- */\r\n-public class DelegatingDatabaseMetaData implements DatabaseMetaData {\r\n-\r\n-    private final DatabaseMetaData _metaData;\r\n-    private final Connection _conn;\r\n-\r\n-    public DelegatingDatabaseMetaData(DatabaseMetaData metaData,\r\n-        Connection conn) {\r\n-        _conn = conn;\r\n-        _metaData = metaData;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the base underlying database metadata.\r\n-     */\r\n-    public DatabaseMetaData getInnermostDelegate() {\r\n-        return _metaData instanceof DelegatingDatabaseMetaData ?\r\n-            ((DelegatingDatabaseMetaData) _metaData).getInnermostDelegate()\r\n-            : _metaData;\r\n-    }\r\n-\r\n-    public int hashCode() {\r\n-        return getInnermostDelegate().hashCode();\r\n-    }\r\n-\r\n-    public boolean equals(Object other) {\r\n-        if (other == this)\r\n-            return true;\r\n-        if (other instanceof DelegatingDatabaseMetaData)\r\n-            other = ((DelegatingDatabaseMetaData) other)\r\n-                .getInnermostDelegate();\r\n-        return getInnermostDelegate().equals(other);\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        StringBuffer buf = new StringBuffer(\"metadata \").append(hashCode());\r\n-        buf.append(\"[\").append(_metaData.toString()).append(\"]\");\r\n-        return buf.toString();\r\n-    }\r\n-\r\n-    public boolean allProceduresAreCallable() throws SQLException {\r\n-        return _metaData.allProceduresAreCallable();\r\n-    }\r\n-\r\n-    public boolean allTablesAreSelectable() throws SQLException {\r\n-        return _metaData.allTablesAreSelectable();\r\n-    }\r\n-\r\n-    public boolean dataDefinitionCausesTransactionCommit() throws SQLException {\r\n-        return _metaData.dataDefinitionCausesTransactionCommit();\r\n-    }\r\n-\r\n-    public boolean dataDefinitionIgnoredInTransactions() throws SQLException {\r\n-        return _metaData.dataDefinitionIgnoredInTransactions();\r\n-    }\r\n-\r\n-    public boolean deletesAreDetected(int type) throws SQLException {\r\n-        return _metaData.deletesAreDetected(type);\r\n-    }\r\n-\r\n-    public boolean doesMaxRowSizeIncludeBlobs() throws SQLException {\r\n-        return _metaData.doesMaxRowSizeIncludeBlobs();\r\n-    }\r\n-\r\n-    public ResultSet getBestRowIdentifier(String catalog,\r\n-        String schema, String table, int scope, boolean nullable)\r\n-        throws SQLException {\r\n-        return _metaData.getBestRowIdentifier(catalog, schema,\r\n-            table, scope, nullable);\r\n-    }\r\n-\r\n-    public ResultSet getCatalogs() throws SQLException {\r\n-        return _metaData.getCatalogs();\r\n-    }\r\n-\r\n-    public String getCatalogSeparator() throws SQLException {\r\n-        return _metaData.getCatalogSeparator();\r\n-    }\r\n-\r\n-    public String getCatalogTerm() throws SQLException {\r\n-        return _metaData.getCatalogTerm();\r\n-    }\r\n-\r\n-    public ResultSet getColumnPrivileges(String catalog, String schema,\r\n-        String table, String columnNamePattern) throws SQLException {\r\n-        return _metaData.getColumnPrivileges(catalog, schema,\r\n-            table, columnNamePattern);\r\n-    }\r\n-\r\n-    public ResultSet getColumns(String catalog, String schemaPattern,\r\n-        String tableNamePattern, String columnNamePattern) throws SQLException {\r\n-        return _metaData.getColumns(catalog, schemaPattern,\r\n-            tableNamePattern, columnNamePattern);\r\n-    }\r\n-\r\n-    public Connection getConnection() throws SQLException {\r\n-        return _conn;\r\n-    }\r\n-\r\n-    public ResultSet getCrossReference(String primaryCatalog,\r\n-        String primarySchema, String primaryTable, String foreignCatalog,\r\n-        String foreignSchema, String foreignTable) throws SQLException {\r\n-        return _metaData.getCrossReference(primaryCatalog, primarySchema,\r\n-            primaryTable, foreignCatalog, foreignSchema, foreignTable);\r\n-    }\r\n-\r\n-    public String getDatabaseProductName() throws SQLException {\r\n-        return _metaData.getDatabaseProductName();\r\n-    }\r\n-\r\n-    public String getDatabaseProductVersion() throws SQLException {\r\n-        return _metaData.getDatabaseProductVersion();\r\n-    }\r\n-\r\n-    public int getDefaultTransactionIsolation() throws SQLException {\r\n-        return _metaData.getDefaultTransactionIsolation();\r\n-    }\r\n-\r\n-    public int getDriverMajorVersion() {\r\n-        return _metaData.getDriverMajorVersion();\r\n-    }\r\n-\r\n-    public int getDriverMinorVersion() {\r\n-        return _metaData.getDriverMinorVersion();\r\n-    }\r\n-\r\n-    public String getDriverName() throws SQLException {\r\n-        return _metaData.getDriverName();\r\n-    }\r\n-\r\n-    public String getDriverVersion() throws SQLException {\r\n-        return _metaData.getDriverVersion();\r\n-    }\r\n-\r\n-    public ResultSet getExportedKeys(String catalog, String schema,\r\n-        String table) throws SQLException {\r\n-        return _metaData.getExportedKeys(catalog, schema, table);\r\n-    }\r\n-\r\n-    public String getExtraNameCharacters() throws SQLException {\r\n-        return _metaData.getExtraNameCharacters();\r\n-    }\r\n-\r\n-    public String getIdentifierQuoteString() throws SQLException {\r\n-        return _metaData.getIdentifierQuoteString();\r\n-    }\r\n-\r\n-    public ResultSet getImportedKeys(String catalog, String schema,\r\n-        String table) throws SQLException {\r\n-        return _metaData.getImportedKeys(catalog, schema, table);\r\n-    }\r\n-\r\n-    public ResultSet getIndexInfo(String catalog, String schema,\r\n-        String table, boolean unique, boolean approximate) throws SQLException {\r\n-        return _metaData.getIndexInfo(catalog, schema, table, unique,\r\n-            approximate);\r\n-    }\r\n-\r\n-    public int getMaxBinaryLiteralLength() throws SQLException {\r\n-        return _metaData.getMaxBinaryLiteralLength();\r\n-    }\r\n-\r\n-    public int getMaxCatalogNameLength() throws SQLException {\r\n-        return _metaData.getMaxCatalogNameLength();\r\n-    }\r\n-\r\n-    public int getMaxCharLiteralLength() throws SQLException {\r\n-        return _metaData.getMaxCharLiteralLength();\r\n-    }\r\n-\r\n-    public int getMaxColumnNameLength() throws SQLException {\r\n-        return _metaData.getMaxColumnNameLength();\r\n-    }\r\n-\r\n-    public int getMaxColumnsInGroupBy() throws SQLException {\r\n-        return _metaData.getMaxColumnsInGroupBy();\r\n-    }\r\n-\r\n-    public int getMaxColumnsInIndex() throws SQLException {\r\n-        return _metaData.getMaxColumnsInIndex();\r\n-    }\r\n-\r\n-    public int getMaxColumnsInOrderBy() throws SQLException {\r\n-        return _metaData.getMaxColumnsInOrderBy();\r\n-    }\r\n-\r\n-    public int getMaxColumnsInSelect() throws SQLException {\r\n-        return _metaData.getMaxColumnsInSelect();\r\n-    }\r\n-\r\n-    public int getMaxColumnsInTable() throws SQLException {\r\n-        return _metaData.getMaxColumnsInTable();\r\n-    }\r\n-\r\n-    public int getMaxConnections() throws SQLException {\r\n-        return _metaData.getMaxConnections();\r\n-    }\r\n-\r\n-    public int getMaxCursorNameLength() throws SQLException {\r\n-        return _metaData.getMaxCursorNameLength();\r\n-    }\r\n-\r\n-    public int getMaxIndexLength() throws SQLException {\r\n-        return _metaData.getMaxIndexLength();\r\n-    }\r\n-\r\n-    public int getMaxProcedureNameLength() throws SQLException {\r\n-        return _metaData.getMaxProcedureNameLength();\r\n-    }\r\n-\r\n-    public int getMaxRowSize() throws SQLException {\r\n-        return _metaData.getMaxRowSize();\r\n-    }\r\n-\r\n-    public int getMaxSchemaNameLength() throws SQLException {\r\n-        return _metaData.getMaxSchemaNameLength();\r\n-    }\r\n-\r\n-    public int getMaxStatementLength() throws SQLException {\r\n-        return _metaData.getMaxStatementLength();\r\n-    }\r\n-\r\n-    public int getMaxStatements() throws SQLException {\r\n-        return _metaData.getMaxStatements();\r\n-    }\r\n-\r\n-    public int getMaxTableNameLength() throws SQLException {\r\n-        return _metaData.getMaxTableNameLength();\r\n-    }\r\n-\r\n-    public int getMaxTablesInSelect() throws SQLException {\r\n-        return _metaData.getMaxTablesInSelect();\r\n-    }\r\n-\r\n-    public int getMaxUserNameLength() throws SQLException {\r\n-        return _metaData.getMaxUserNameLength();\r\n-    }\r\n-\r\n-    public String getNumericFunctions() throws SQLException {\r\n-        return _metaData.getNumericFunctions();\r\n-    }\r\n-\r\n-    public ResultSet getPrimaryKeys(String catalog, String schema, String table)\r\n-        throws SQLException {\r\n-        return _metaData.getPrimaryKeys(catalog, schema, table);\r\n-    }\r\n-\r\n-    public ResultSet getProcedureColumns(String catalog, String schemaPattern,\r\n-        String procedureNamePattern, String columnNamePattern)\r\n-        throws SQLException {\r\n-        return _metaData.getProcedureColumns(catalog, schemaPattern,\r\n-            procedureNamePattern, columnNamePattern);\r\n-    }\r\n-\r\n-    public ResultSet getProcedures(String catalog, String schemaPattern,\r\n-        String procedureNamePattern) throws SQLException {\r\n-        return _metaData.getProcedures(catalog, schemaPattern,\r\n-            procedureNamePattern);\r\n-    }\r\n-\r\n-    public String getProcedureTerm() throws SQLException {\r\n-        return _metaData.getProcedureTerm();\r\n-    }\r\n-\r\n-    public ResultSet getSchemas() throws SQLException {\r\n-        return _metaData.getSchemas();\r\n-    }\r\n-\r\n-    public String getSchemaTerm() throws SQLException {\r\n-        return _metaData.getSchemaTerm();\r\n-    }\r\n-\r\n-    public String getSearchStringEscape() throws SQLException {\r\n-        return _metaData.getSearchStringEscape();\r\n-    }\r\n-\r\n-    public String getSQLKeywords() throws SQLException {\r\n-        return _metaData.getSQLKeywords();\r\n-    }\r\n-\r\n-    public String getStringFunctions() throws SQLException {\r\n-        return _metaData.getStringFunctions();\r\n-    }\r\n-\r\n-    public String getSystemFunctions() throws SQLException {\r\n-        return _metaData.getSystemFunctions();\r\n-    }\r\n-\r\n-    public ResultSet getTablePrivileges(String catalog,\r\n-        String schemaPattern, String tableNamePattern) throws SQLException {\r\n-        return _metaData.getTablePrivileges(catalog, schemaPattern,\r\n-            tableNamePattern);\r\n-    }\r\n-\r\n-    public ResultSet getTables(String catalog, String schemaPattern,\r\n-        String tableNamePattern, String[] types) throws SQLException {\r\n-        return _metaData.getTables(catalog, schemaPattern,\r\n-            tableNamePattern, types);\r\n-    }\r\n-\r\n-    public ResultSet getTableTypes() throws SQLException {\r\n-        return _metaData.getTableTypes();\r\n-    }\r\n-\r\n-    public String getTimeDateFunctions() throws SQLException {\r\n-        return _metaData.getTimeDateFunctions();\r\n-    }\r\n-\r\n-    public ResultSet getTypeInfo() throws SQLException {\r\n-        return _metaData.getTypeInfo();\r\n-    }\r\n-\r\n-    public ResultSet getUDTs(String catalog, String schemaPattern,\r\n-        String typeNamePattern, int[] types) throws SQLException {\r\n-        return _metaData.getUDTs(catalog, schemaPattern,\r\n-            typeNamePattern, types);\r\n-    }\r\n-\r\n-    public String getURL() throws SQLException {\r\n-        return _metaData.getURL();\r\n-    }\r\n-\r\n-    public String getUserName() throws SQLException {\r\n-        return _metaData.getUserName();\r\n-    }\r\n-\r\n-    public ResultSet getVersionColumns(String catalog,\r\n-        String schema, String table) throws SQLException {\r\n-        return _metaData.getVersionColumns(catalog, schema, table);\r\n-    }\r\n-\r\n-    public boolean insertsAreDetected(int type) throws SQLException {\r\n-        return _metaData.insertsAreDetected(type);\r\n-    }\r\n-\r\n-    public boolean isCatalogAtStart() throws SQLException {\r\n-        return _metaData.isCatalogAtStart();\r\n-    }\r\n-\r\n-    public boolean isReadOnly() throws SQLException {\r\n-        return _metaData.isReadOnly();\r\n-    }\r\n-\r\n-    public boolean nullPlusNonNullIsNull() throws SQLException {\r\n-        return _metaData.nullPlusNonNullIsNull();\r\n-    }\r\n-\r\n-    public boolean nullsAreSortedAtEnd() throws SQLException {\r\n-        return _metaData.nullsAreSortedAtEnd();\r\n-    }\r\n-\r\n-    public boolean nullsAreSortedAtStart() throws SQLException {\r\n-        return _metaData.nullsAreSortedAtStart();\r\n-    }\r\n-\r\n-    public boolean nullsAreSortedHigh() throws SQLException {\r\n-        return _metaData.nullsAreSortedHigh();\r\n-    }\r\n-\r\n-    public boolean nullsAreSortedLow() throws SQLException {\r\n-        return _metaData.nullsAreSortedLow();\r\n-    }\r\n-\r\n-    public boolean othersDeletesAreVisible(int type) throws SQLException {\r\n-        return _metaData.othersDeletesAreVisible(type);\r\n-    }\r\n-\r\n-    public boolean othersInsertsAreVisible(int type) throws SQLException {\r\n-        return _metaData.othersInsertsAreVisible(type);\r\n-    }\r\n-\r\n-    public boolean othersUpdatesAreVisible(int type) throws SQLException {\r\n-        return _metaData.othersUpdatesAreVisible(type);\r\n-    }\r\n-\r\n-    public boolean ownDeletesAreVisible(int type) throws SQLException {\r\n-        return _metaData.ownDeletesAreVisible(type);\r\n-    }\r\n-\r\n-    public boolean ownInsertsAreVisible(int type) throws SQLException {\r\n-        return _metaData.ownInsertsAreVisible(type);\r\n-    }\r\n-\r\n-    public boolean ownUpdatesAreVisible(int type) throws SQLException {\r\n-        return _metaData.ownUpdatesAreVisible(type);\r\n-    }\r\n-\r\n-    public boolean storesLowerCaseIdentifiers() throws SQLException {\r\n-        return _metaData.storesLowerCaseIdentifiers();\r\n-    }\r\n-\r\n-    public boolean storesLowerCaseQuotedIdentifiers() throws SQLException {\r\n-        return _metaData.storesLowerCaseQuotedIdentifiers();\r\n-    }\r\n-\r\n-    public boolean storesMixedCaseIdentifiers() throws SQLException {\r\n-        return _metaData.storesMixedCaseIdentifiers();\r\n-    }\r\n-\r\n-    public boolean storesMixedCaseQuotedIdentifiers() throws SQLException {\r\n-        return _metaData.storesMixedCaseQuotedIdentifiers();\r\n-    }\r\n-\r\n-    public boolean storesUpperCaseIdentifiers() throws SQLException {\r\n-        return _metaData.storesUpperCaseIdentifiers();\r\n-    }\r\n-\r\n-    public boolean storesUpperCaseQuotedIdentifiers() throws SQLException {\r\n-        return _metaData.storesUpperCaseQuotedIdentifiers();\r\n-    }\r\n-\r\n-    public boolean supportsAlterTableWithAddColumn() throws SQLException {\r\n-        return _metaData.supportsAlterTableWithAddColumn();\r\n-    }\r\n-\r\n-    public boolean supportsAlterTableWithDropColumn() throws SQLException {\r\n-        return _metaData.supportsAlterTableWithDropColumn();\r\n-    }\r\n-\r\n-    public boolean supportsANSI92EntryLevelSQL() throws SQLException {\r\n-        return _metaData.supportsANSI92EntryLevelSQL();\r\n-    }\r\n-\r\n-    public boolean supportsANSI92FullSQL() throws SQLException {\r\n-        return _metaData.supportsANSI92FullSQL();\r\n-    }\r\n-\r\n-    public boolean supportsANSI92IntermediateSQL() throws SQLException {\r\n-        return _metaData.supportsANSI92IntermediateSQL();\r\n-    }\r\n-\r\n-    public boolean supportsBatchUpdates() throws SQLException {\r\n-        return _metaData.supportsBatchUpdates();\r\n-    }\r\n-\r\n-    public boolean supportsCatalogsInDataManipulation() throws SQLException {\r\n-        return _metaData.supportsCatalogsInDataManipulation();\r\n-    }\r\n-\r\n-    public boolean supportsCatalogsInIndexDefinitions() throws SQLException {\r\n-        return _metaData.supportsCatalogsInIndexDefinitions();\r\n-    }\r\n-\r\n-    public boolean supportsCatalogsInPrivilegeDefinitions()\r\n-        throws SQLException {\r\n-        return _metaData.supportsCatalogsInPrivilegeDefinitions();\r\n-    }\r\n-\r\n-    public boolean supportsCatalogsInProcedureCalls() throws SQLException {\r\n-        return _metaData.supportsCatalogsInProcedureCalls();\r\n-    }\r\n-\r\n-    public boolean supportsCatalogsInTableDefinitions() throws SQLException {\r\n-        return _metaData.supportsCatalogsInTableDefinitions();\r\n-    }\r\n-\r\n-    public boolean supportsColumnAliasing() throws SQLException {\r\n-        return _metaData.supportsColumnAliasing();\r\n-    }\r\n-\r\n-    public boolean supportsConvert() throws SQLException {\r\n-        return _metaData.supportsConvert();\r\n-    }\r\n-\r\n-    public boolean supportsConvert(int fromType, int toType)\r\n-        throws SQLException {\r\n-        return _metaData.supportsConvert(fromType, toType);\r\n-    }\r\n-\r\n-    public boolean supportsCoreSQLGrammar() throws SQLException {\r\n-        return _metaData.supportsCoreSQLGrammar();\r\n-    }\r\n-\r\n-    public boolean supportsCorrelatedSubqueries() throws SQLException {\r\n-        return _metaData.supportsCorrelatedSubqueries();\r\n-    }\r\n-\r\n-    public boolean supportsDataDefinitionAndDataManipulationTransactions()\r\n-        throws SQLException {\r\n-        return _metaData\r\n-            .supportsDataDefinitionAndDataManipulationTransactions();\r\n-    }\r\n-\r\n-    public boolean supportsDataManipulationTransactionsOnly()\r\n-        throws SQLException {\r\n-        return _metaData.supportsDataManipulationTransactionsOnly();\r\n-    }\r\n-\r\n-    public boolean supportsDifferentTableCorrelationNames()\r\n-        throws SQLException {\r\n-        return _metaData.supportsDifferentTableCorrelationNames();\r\n-    }\r\n-\r\n-    public boolean supportsExpressionsInOrderBy() throws SQLException {\r\n-        return _metaData.supportsExpressionsInOrderBy();\r\n-    }\r\n-\r\n-    public boolean supportsExtendedSQLGrammar() throws SQLException {\r\n-        return _metaData.supportsExtendedSQLGrammar();\r\n-    }\r\n-\r\n-    public boolean supportsFullOuterJoins() throws SQLException {\r\n-        return _metaData.supportsFullOuterJoins();\r\n-    }\r\n-\r\n-    public boolean supportsGroupBy() throws SQLException {\r\n-        return _metaData.supportsGroupBy();\r\n-    }\r\n-\r\n-    public boolean supportsGroupByBeyondSelect() throws SQLException {\r\n-        return _metaData.supportsGroupByBeyondSelect();\r\n-    }\r\n-\r\n-    public boolean supportsGroupByUnrelated() throws SQLException {\r\n-        return _metaData.supportsGroupByUnrelated();\r\n-    }\r\n-\r\n-    public boolean supportsIntegrityEnhancementFacility() throws SQLException {\r\n-        return _metaData.supportsIntegrityEnhancementFacility();\r\n-    }\r\n-\r\n-    public boolean supportsLikeEscapeClause() throws SQLException {\r\n-        return _metaData.supportsLikeEscapeClause();\r\n-    }\r\n-\r\n-    public boolean supportsLimitedOuterJoins() throws SQLException {\r\n-        return _metaData.supportsLimitedOuterJoins();\r\n-    }\r\n-\r\n-    public boolean supportsMinimumSQLGrammar() throws SQLException {\r\n-        return _metaData.supportsMinimumSQLGrammar();\r\n-    }\r\n-\r\n-    public boolean supportsMixedCaseIdentifiers() throws SQLException {\r\n-        return _metaData.supportsMixedCaseIdentifiers();\r\n-    }\r\n-\r\n-    public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {\r\n-        return _metaData.supportsMixedCaseQuotedIdentifiers();\r\n-    }\r\n-\r\n-    public boolean supportsMultipleResultSets() throws SQLException {\r\n-        return _metaData.supportsMultipleResultSets();\r\n-    }\r\n-\r\n-    public boolean supportsMultipleTransactions() throws SQLException {\r\n-        return _metaData.supportsMultipleTransactions();\r\n-    }\r\n-\r\n-    public boolean supportsNonNullableColumns() throws SQLException {\r\n-        return _metaData.supportsNonNullableColumns();\r\n-    }\r\n-\r\n-    public boolean supportsOpenCursorsAcrossCommit() throws SQLException {\r\n-        return _metaData.supportsOpenCursorsAcrossCommit();\r\n-    }\r\n-\r\n-    public boolean supportsOpenCursorsAcrossRollback() throws SQLException {\r\n-        return _metaData.supportsOpenCursorsAcrossRollback();\r\n-    }\r\n-\r\n-    public boolean supportsOpenStatementsAcrossCommit() throws SQLException {\r\n-        return _metaData.supportsOpenStatementsAcrossCommit();\r\n-    }\r\n-\r\n-    public boolean supportsOpenStatementsAcrossRollback() throws SQLException {\r\n-        return _metaData.supportsOpenStatementsAcrossRollback();\r\n-    }\r\n-\r\n-    public boolean supportsOrderByUnrelated() throws SQLException {\r\n-        return _metaData.supportsOrderByUnrelated();\r\n-    }\r\n-\r\n-    public boolean supportsOuterJoins() throws SQLException {\r\n-        return _metaData.supportsOuterJoins();\r\n-    }\r\n-\r\n-    public boolean supportsPositionedDelete() throws SQLException {\r\n-        return _metaData.supportsPositionedDelete();\r\n-    }\r\n-\r\n-    public boolean supportsPositionedUpdate() throws SQLException {\r\n-        return _metaData.supportsPositionedUpdate();\r\n-    }\r\n-\r\n-    public boolean supportsResultSetConcurrency(int type, int concurrency)\r\n-        throws SQLException {\r\n-        return _metaData.supportsResultSetConcurrency(type, concurrency);\r\n-    }\r\n-\r\n-    public boolean supportsResultSetType(int type) throws SQLException {\r\n-        return _metaData.supportsResultSetType(type);\r\n-    }\r\n-\r\n-    public boolean supportsSchemasInDataManipulation() throws SQLException {\r\n-        return _metaData.supportsSchemasInDataManipulation();\r\n-    }\r\n-\r\n-    public boolean supportsSchemasInIndexDefinitions() throws SQLException {\r\n-        return _metaData.supportsSchemasInIndexDefinitions();\r\n-    }\r\n-\r\n-    public boolean supportsSchemasInPrivilegeDefinitions() throws SQLException {\r\n-        return _metaData.supportsSchemasInPrivilegeDefinitions();\r\n-    }\r\n-\r\n-    public boolean supportsSchemasInProcedureCalls() throws SQLException {\r\n-        return _metaData.supportsSchemasInProcedureCalls();\r\n-    }\r\n-\r\n-    public boolean supportsSchemasInTableDefinitions() throws SQLException {\r\n-        return _metaData.supportsSchemasInTableDefinitions();\r\n-    }\r\n-\r\n-    public boolean supportsSelectForUpdate() throws SQLException {\r\n-        return _metaData.supportsSelectForUpdate();\r\n-    }\r\n-\r\n-    public boolean supportsStoredProcedures() throws SQLException {\r\n-        return _metaData.supportsStoredProcedures();\r\n-    }\r\n-\r\n-    public boolean supportsSubqueriesInComparisons() throws SQLException {\r\n-        return _metaData.supportsSubqueriesInComparisons();\r\n-    }\r\n-\r\n-    public boolean supportsSubqueriesInExists() throws SQLException {\r\n-        return _metaData.supportsSubqueriesInExists();\r\n-    }\r\n-\r\n-    public boolean supportsSubqueriesInIns() throws SQLException {\r\n-        return _metaData.supportsSubqueriesInIns();\r\n-    }\r\n-\r\n-    public boolean supportsSubqueriesInQuantifieds() throws SQLException {\r\n-        return _metaData.supportsSubqueriesInQuantifieds();\r\n-    }\r\n-\r\n-    public boolean supportsTableCorrelationNames() throws SQLException {\r\n-        return _metaData.supportsTableCorrelationNames();\r\n-    }\r\n-\r\n-    public boolean supportsTransactionIsolationLevel(int level)\r\n-        throws SQLException {\r\n-        return _metaData.supportsTransactionIsolationLevel(level);\r\n-    }\r\n-\r\n-    public boolean supportsTransactions() throws SQLException {\r\n-        return _metaData.supportsTransactions();\r\n-    }\r\n-\r\n-    public boolean supportsUnion() throws SQLException {\r\n-        return _metaData.supportsUnion();\r\n-    }\r\n-\r\n-    public boolean supportsUnionAll() throws SQLException {\r\n-        return _metaData.supportsUnionAll();\r\n-    }\r\n-\r\n-    public boolean updatesAreDetected(int type) throws SQLException {\r\n-        return _metaData.updatesAreDetected(type);\r\n-    }\r\n-\r\n-    public boolean usesLocalFilePerTable() throws SQLException {\r\n-        return _metaData.usesLocalFilePerTable();\r\n-    }\r\n-\r\n-    public boolean usesLocalFiles() throws SQLException {\r\n-        return _metaData.usesLocalFiles();\r\n-    }\r\n-\r\n-    // JDBC 3.0 methods(unsupported) follow; these are required to be able to\r\n-    // compile against JDK 1.4\r\n-\r\n-    public boolean supportsSavepoints() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public boolean supportsNamedParameters() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public boolean supportsMultipleOpenResults() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public boolean supportsGetGeneratedKeys() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public ResultSet getSuperTypes(String catalog, String schemaPatter,\r\n-        String typeNamePattern) throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public ResultSet getSuperTables(String catalog, String schemaPatter,\r\n-        String tableNamePattern) throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public ResultSet getAttributes(String catalog, String schemaPatter,\r\n-        String typeNamePattern, String attributeNamePattern)\r\n-        throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public boolean supportsResultSetHoldability(int holdability)\r\n-        throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public int getResultSetHoldability() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public int getDatabaseMajorVersion() throws SQLException {\r\n-        return _metaData.getDatabaseMajorVersion();\r\n-    }\r\n-\r\n-    public int getDatabaseMinorVersion() throws SQLException {\r\n-        return _metaData.getDatabaseMinorVersion();\r\n-    }\r\n-\r\n-    public int getJDBCMajorVersion() throws SQLException {\r\n-        return _metaData.getJDBCMajorVersion();\r\n-    }\r\n-\r\n-    public int getJDBCMinorVersion() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public int getSQLStateType() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public boolean locatorsUpdateCopy() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public boolean supportsStatementPooling() throws SQLException {\r\n-        throw new UnsupportedOperationException();\r\n-    }\r\n-}\r\n-\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+\n+/**\n+ * Wrapper around a DatabaseMetadata instance.\n+ *\n+ * @author Marc Prud'hommeaux\n+ */\n+public class DelegatingDatabaseMetaData implements DatabaseMetaData {\n+\n+    private final DatabaseMetaData _metaData;\n+    private final Connection _conn;\n+\n+    public DelegatingDatabaseMetaData(DatabaseMetaData metaData,\n+        Connection conn) {\n+        _conn = conn;\n+        _metaData = metaData;\n+    }\n+\n+    /**\n+     * Return the base underlying database metadata.\n+     */\n+    public DatabaseMetaData getInnermostDelegate() {\n+        return _metaData instanceof DelegatingDatabaseMetaData ?\n+            ((DelegatingDatabaseMetaData) _metaData).getInnermostDelegate()\n+            : _metaData;\n+    }\n+\n+    public int hashCode() {\n+        return getInnermostDelegate().hashCode();\n+    }\n+\n+    public boolean equals(Object other) {\n+        if (other == this)\n+            return true;\n+        if (other instanceof DelegatingDatabaseMetaData)\n+            other = ((DelegatingDatabaseMetaData) other)\n+                .getInnermostDelegate();\n+        return getInnermostDelegate().equals(other);\n+    }\n+\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer(\"metadata \").append(hashCode());\n+        buf.append(\"[\").append(_metaData.toString()).append(\"]\");\n+        return buf.toString();\n+    }\n+\n+    public boolean allProceduresAreCallable() throws SQLException {\n+        return _metaData.allProceduresAreCallable();\n+    }\n+\n+    public boolean allTablesAreSelectable() throws SQLException {\n+        return _metaData.allTablesAreSelectable();\n+    }\n+\n+    public boolean dataDefinitionCausesTransactionCommit() throws SQLException {\n+        return _metaData.dataDefinitionCausesTransactionCommit();\n+    }\n+\n+    public boolean dataDefinitionIgnoredInTransactions() throws SQLException {\n+        return _metaData.dataDefinitionIgnoredInTransactions();\n+    }\n+\n+    public boolean deletesAreDetected(int type) throws SQLException {\n+        return _metaData.deletesAreDetected(type);\n+    }\n+\n+    public boolean doesMaxRowSizeIncludeBlobs() throws SQLException {\n+        return _metaData.doesMaxRowSizeIncludeBlobs();\n+    }\n+\n+    public ResultSet getBestRowIdentifier(String catalog,\n+        String schema, String table, int scope, boolean nullable)\n+        throws SQLException {\n+        return _metaData.getBestRowIdentifier(catalog, schema,\n+            table, scope, nullable);\n+    }\n+\n+    public ResultSet getCatalogs() throws SQLException {\n+        return _metaData.getCatalogs();\n+    }\n+\n+    public String getCatalogSeparator() throws SQLException {\n+        return _metaData.getCatalogSeparator();\n+    }\n+\n+    public String getCatalogTerm() throws SQLException {\n+        return _metaData.getCatalogTerm();\n+    }\n+\n+    public ResultSet getColumnPrivileges(String catalog, String schema,\n+        String table, String columnNamePattern) throws SQLException {\n+        return _metaData.getColumnPrivileges(catalog, schema,\n+            table, columnNamePattern);\n+    }\n+\n+    public ResultSet getColumns(String catalog, String schemaPattern,\n+        String tableNamePattern, String columnNamePattern) throws SQLException {\n+        return _metaData.getColumns(catalog, schemaPattern,\n+            tableNamePattern, columnNamePattern);\n+    }\n+\n+    public Connection getConnection() throws SQLException {\n+        return _conn;\n+    }\n+\n+    public ResultSet getCrossReference(String primaryCatalog,\n+        String primarySchema, String primaryTable, String foreignCatalog,\n+        String foreignSchema, String foreignTable) throws SQLException {\n+        return _metaData.getCrossReference(primaryCatalog, primarySchema,\n+            primaryTable, foreignCatalog, foreignSchema, foreignTable);\n+    }\n+\n+    public String getDatabaseProductName() throws SQLException {\n+        return _metaData.getDatabaseProductName();\n+    }\n+\n+    public String getDatabaseProductVersion() throws SQLException {\n+        return _metaData.getDatabaseProductVersion();\n+    }\n+\n+    public int getDefaultTransactionIsolation() throws SQLException {\n+        return _metaData.getDefaultTransactionIsolation();\n+    }\n+\n+    public int getDriverMajorVersion() {\n+        return _metaData.getDriverMajorVersion();\n+    }\n+\n+    public int getDriverMinorVersion() {\n+        return _metaData.getDriverMinorVersion();\n+    }\n+\n+    public String getDriverName() throws SQLException {\n+        return _metaData.getDriverName();\n+    }\n+\n+    public String getDriverVersion() throws SQLException {\n+        return _metaData.getDriverVersion();\n+    }\n+\n+    public ResultSet getExportedKeys(String catalog, String schema,\n+        String table) throws SQLException {\n+        return _metaData.getExportedKeys(catalog, schema, table);\n+    }\n+\n+    public String getExtraNameCharacters() throws SQLException {\n+        return _metaData.getExtraNameCharacters();\n+    }\n+\n+    public String getIdentifierQuoteString() throws SQLException {\n+        return _metaData.getIdentifierQuoteString();\n+    }\n+\n+    public ResultSet getImportedKeys(String catalog, String schema,\n+        String table) throws SQLException {\n+        return _metaData.getImportedKeys(catalog, schema, table);\n+    }\n+\n+    public ResultSet getIndexInfo(String catalog, String schema,\n+        String table, boolean unique, boolean approximate) throws SQLException {\n+        return _metaData.getIndexInfo(catalog, schema, table, unique,\n+            approximate);\n+    }\n+\n+    public int getMaxBinaryLiteralLength() throws SQLException {\n+        return _metaData.getMaxBinaryLiteralLength();\n+    }\n+\n+    public int getMaxCatalogNameLength() throws SQLException {\n+        return _metaData.getMaxCatalogNameLength();\n+    }\n+\n+    public int getMaxCharLiteralLength() throws SQLException {\n+        return _metaData.getMaxCharLiteralLength();\n+    }\n+\n+    public int getMaxColumnNameLength() throws SQLException {\n+        return _metaData.getMaxColumnNameLength();\n+    }\n+\n+    public int getMaxColumnsInGroupBy() throws SQLException {\n+        return _metaData.getMaxColumnsInGroupBy();\n+    }\n+\n+    public int getMaxColumnsInIndex() throws SQLException {\n+        return _metaData.getMaxColumnsInIndex();\n+    }\n+\n+    public int getMaxColumnsInOrderBy() throws SQLException {\n+        return _metaData.getMaxColumnsInOrderBy();\n+    }\n+\n+    public int getMaxColumnsInSelect() throws SQLException {\n+        return _metaData.getMaxColumnsInSelect();\n+    }\n+\n+    public int getMaxColumnsInTable() throws SQLException {\n+        return _metaData.getMaxColumnsInTable();\n+    }\n+\n+    public int getMaxConnections() throws SQLException {\n+        return _metaData.getMaxConnections();\n+    }\n+\n+    public int getMaxCursorNameLength() throws SQLException {\n+        return _metaData.getMaxCursorNameLength();\n+    }\n+\n+    public int getMaxIndexLength() throws SQLException {\n+        return _metaData.getMaxIndexLength();\n+    }\n+\n+    public int getMaxProcedureNameLength() throws SQLException {\n+        return _metaData.getMaxProcedureNameLength();\n+    }\n+\n+    public int getMaxRowSize() throws SQLException {\n+        return _metaData.getMaxRowSize();\n+    }\n+\n+    public int getMaxSchemaNameLength() throws SQLException {\n+        return _metaData.getMaxSchemaNameLength();\n+    }\n+\n+    public int getMaxStatementLength() throws SQLException {\n+        return _metaData.getMaxStatementLength();\n+    }\n+\n+    public int getMaxStatements() throws SQLException {\n+        return _metaData.getMaxStatements();\n+    }\n+\n+    public int getMaxTableNameLength() throws SQLException {\n+        return _metaData.getMaxTableNameLength();\n+    }\n+\n+    public int getMaxTablesInSelect() throws SQLException {\n+        return _metaData.getMaxTablesInSelect();\n+    }\n+\n+    public int getMaxUserNameLength() throws SQLException {\n+        return _metaData.getMaxUserNameLength();\n+    }\n+\n+    public String getNumericFunctions() throws SQLException {\n+        return _metaData.getNumericFunctions();\n+    }\n+\n+    public ResultSet getPrimaryKeys(String catalog, String schema, String table)\n+        throws SQLException {\n+        return _metaData.getPrimaryKeys(catalog, schema, table);\n+    }\n+\n+    public ResultSet getProcedureColumns(String catalog, String schemaPattern,\n+        String procedureNamePattern, String columnNamePattern)\n+        throws SQLException {\n+        return _metaData.getProcedureColumns(catalog, schemaPattern,\n+            procedureNamePattern, columnNamePattern);\n+    }\n+\n+    public ResultSet getProcedures(String catalog, String schemaPattern,\n+        String procedureNamePattern) throws SQLException {\n+        return _metaData.getProcedures(catalog, schemaPattern,\n+            procedureNamePattern);\n+    }\n+\n+    public String getProcedureTerm() throws SQLException {\n+        return _metaData.getProcedureTerm();\n+    }\n+\n+    public ResultSet getSchemas() throws SQLException {\n+        return _metaData.getSchemas();\n+    }\n+\n+    public String getSchemaTerm() throws SQLException {\n+        return _metaData.getSchemaTerm();\n+    }\n+\n+    public String getSearchStringEscape() throws SQLException {\n+        return _metaData.getSearchStringEscape();\n+    }\n+\n+    public String getSQLKeywords() throws SQLException {\n+        return _metaData.getSQLKeywords();\n+    }\n+\n+    public String getStringFunctions() throws SQLException {\n+        return _metaData.getStringFunctions();\n+    }\n+\n+    public String getSystemFunctions() throws SQLException {\n+        return _metaData.getSystemFunctions();\n+    }\n+\n+    public ResultSet getTablePrivileges(String catalog,\n+        String schemaPattern, String tableNamePattern) throws SQLException {\n+        return _metaData.getTablePrivileges(catalog, schemaPattern,\n+            tableNamePattern);\n+    }\n+\n+    public ResultSet getTables(String catalog, String schemaPattern,\n+        String tableNamePattern, String[] types) throws SQLException {\n+        return _metaData.getTables(catalog, schemaPattern,\n+            tableNamePattern, types);\n+    }\n+\n+    public ResultSet getTableTypes() throws SQLException {\n+        return _metaData.getTableTypes();\n+    }\n+\n+    public String getTimeDateFunctions() throws SQLException {\n+        return _metaData.getTimeDateFunctions();\n+    }\n+\n+    public ResultSet getTypeInfo() throws SQLException {\n+        return _metaData.getTypeInfo();\n+    }\n+\n+    public ResultSet getUDTs(String catalog, String schemaPattern,\n+        String typeNamePattern, int[] types) throws SQLException {\n+        return _metaData.getUDTs(catalog, schemaPattern,\n+            typeNamePattern, types);\n+    }\n+\n+    public String getURL() throws SQLException {\n+        return _metaData.getURL();\n+    }\n+\n+    public String getUserName() throws SQLException {\n+        return _metaData.getUserName();\n+    }\n+\n+    public ResultSet getVersionColumns(String catalog,\n+        String schema, String table) throws SQLException {\n+        return _metaData.getVersionColumns(catalog, schema, table);\n+    }\n+\n+    public boolean insertsAreDetected(int type) throws SQLException {\n+        return _metaData.insertsAreDetected(type);\n+    }\n+\n+    public boolean isCatalogAtStart() throws SQLException {\n+        return _metaData.isCatalogAtStart();\n+    }\n+\n+    public boolean isReadOnly() throws SQLException {\n+        return _metaData.isReadOnly();\n+    }\n+\n+    public boolean nullPlusNonNullIsNull() throws SQLException {\n+        return _metaData.nullPlusNonNullIsNull();\n+    }\n+\n+    public boolean nullsAreSortedAtEnd() throws SQLException {\n+        return _metaData.nullsAreSortedAtEnd();\n+    }\n+\n+    public boolean nullsAreSortedAtStart() throws SQLException {\n+        return _metaData.nullsAreSortedAtStart();\n+    }\n+\n+    public boolean nullsAreSortedHigh() throws SQLException {\n+        return _metaData.nullsAreSortedHigh();\n+    }\n+\n+    public boolean nullsAreSortedLow() throws SQLException {\n+        return _metaData.nullsAreSortedLow();\n+    }\n+\n+    public boolean othersDeletesAreVisible(int type) throws SQLException {\n+        return _metaData.othersDeletesAreVisible(type);\n+    }\n+\n+    public boolean othersInsertsAreVisible(int type) throws SQLException {\n+        return _metaData.othersInsertsAreVisible(type);\n+    }\n+\n+    public boolean othersUpdatesAreVisible(int type) throws SQLException {\n+        return _metaData.othersUpdatesAreVisible(type);\n+    }\n+\n+    public boolean ownDeletesAreVisible(int type) throws SQLException {\n+        return _metaData.ownDeletesAreVisible(type);\n+    }\n+\n+    public boolean ownInsertsAreVisible(int type) throws SQLException {\n+        return _metaData.ownInsertsAreVisible(type);\n+    }\n+\n+    public boolean ownUpdatesAreVisible(int type) throws SQLException {\n+        return _metaData.ownUpdatesAreVisible(type);\n+    }\n+\n+    public boolean storesLowerCaseIdentifiers() throws SQLException {\n+        return _metaData.storesLowerCaseIdentifiers();\n+    }\n+\n+    public boolean storesLowerCaseQuotedIdentifiers() throws SQLException {\n+        return _metaData.storesLowerCaseQuotedIdentifiers();\n+    }\n+\n+    public boolean storesMixedCaseIdentifiers() throws SQLException {\n+        return _metaData.storesMixedCaseIdentifiers();\n+    }\n+\n+    public boolean storesMixedCaseQuotedIdentifiers() throws SQLException {\n+        return _metaData.storesMixedCaseQuotedIdentifiers();\n+    }\n+\n+    public boolean storesUpperCaseIdentifiers() throws SQLException {\n+        return _metaData.storesUpperCaseIdentifiers();\n+    }\n+\n+    public boolean storesUpperCaseQuotedIdentifiers() throws SQLException {\n+        return _metaData.storesUpperCaseQuotedIdentifiers();\n+    }\n+\n+    public boolean supportsAlterTableWithAddColumn() throws SQLException {\n+        return _metaData.supportsAlterTableWithAddColumn();\n+    }\n+\n+    public boolean supportsAlterTableWithDropColumn() throws SQLException {\n+        return _metaData.supportsAlterTableWithDropColumn();\n+    }\n+\n+    public boolean supportsANSI92EntryLevelSQL() throws SQLException {\n+        return _metaData.supportsANSI92EntryLevelSQL();\n+    }\n+\n+    public boolean supportsANSI92FullSQL() throws SQLException {\n+        return _metaData.supportsANSI92FullSQL();\n+    }\n+\n+    public boolean supportsANSI92IntermediateSQL() throws SQLException {\n+        return _metaData.supportsANSI92IntermediateSQL();\n+    }\n+\n+    public boolean supportsBatchUpdates() throws SQLException {\n+        return _metaData.supportsBatchUpdates();\n+    }\n+\n+    public boolean supportsCatalogsInDataManipulation() throws SQLException {\n+        return _metaData.supportsCatalogsInDataManipulation();\n+    }\n+\n+    public boolean supportsCatalogsInIndexDefinitions() throws SQLException {\n+        return _metaData.supportsCatalogsInIndexDefinitions();\n+    }\n+\n+    public boolean supportsCatalogsInPrivilegeDefinitions()\n+        throws SQLException {\n+        return _metaData.supportsCatalogsInPrivilegeDefinitions();\n+    }\n+\n+    public boolean supportsCatalogsInProcedureCalls() throws SQLException {\n+        return _metaData.supportsCatalogsInProcedureCalls();\n+    }\n+\n+    public boolean supportsCatalogsInTableDefinitions() throws SQLException {\n+        return _metaData.supportsCatalogsInTableDefinitions();\n+    }\n+\n+    public boolean supportsColumnAliasing() throws SQLException {\n+        return _metaData.supportsColumnAliasing();\n+    }\n+\n+    public boolean supportsConvert() throws SQLException {\n+        return _metaData.supportsConvert();\n+    }\n+\n+    public boolean supportsConvert(int fromType, int toType)\n+        throws SQLException {\n+        return _metaData.supportsConvert(fromType, toType);\n+    }\n+\n+    public boolean supportsCoreSQLGrammar() throws SQLException {\n+        return _metaData.supportsCoreSQLGrammar();\n+    }\n+\n+    public boolean supportsCorrelatedSubqueries() throws SQLException {\n+        return _metaData.supportsCorrelatedSubqueries();\n+    }\n+\n+    public boolean supportsDataDefinitionAndDataManipulationTransactions()\n+        throws SQLException {\n+        return _metaData\n+            .supportsDataDefinitionAndDataManipulationTransactions();\n+    }\n+\n+    public boolean supportsDataManipulationTransactionsOnly()\n+        throws SQLException {\n+        return _metaData.supportsDataManipulationTransactionsOnly();\n+    }\n+\n+    public boolean supportsDifferentTableCorrelationNames()\n+        throws SQLException {\n+        return _metaData.supportsDifferentTableCorrelationNames();\n+    }\n+\n+    public boolean supportsExpressionsInOrderBy() throws SQLException {\n+        return _metaData.supportsExpressionsInOrderBy();\n+    }\n+\n+    public boolean supportsExtendedSQLGrammar() throws SQLException {\n+        return _metaData.supportsExtendedSQLGrammar();\n+    }\n+\n+    public boolean supportsFullOuterJoins() throws SQLException {\n+        return _metaData.supportsFullOuterJoins();\n+    }\n+\n+    public boolean supportsGroupBy() throws SQLException {\n+        return _metaData.supportsGroupBy();\n+    }\n+\n+    public boolean supportsGroupByBeyondSelect() throws SQLException {\n+        return _metaData.supportsGroupByBeyondSelect();\n+    }\n+\n+    public boolean supportsGroupByUnrelated() throws SQLException {\n+        return _metaData.supportsGroupByUnrelated();\n+    }\n+\n+    public boolean supportsIntegrityEnhancementFacility() throws SQLException {\n+        return _metaData.supportsIntegrityEnhancementFacility();\n+    }\n+\n+    public boolean supportsLikeEscapeClause() throws SQLException {\n+        return _metaData.supportsLikeEscapeClause();\n+    }\n+\n+    public boolean supportsLimitedOuterJoins() throws SQLException {\n+        return _metaData.supportsLimitedOuterJoins();\n+    }\n+\n+    public boolean supportsMinimumSQLGrammar() throws SQLException {\n+        return _metaData.supportsMinimumSQLGrammar();\n+    }\n+\n+    public boolean supportsMixedCaseIdentifiers() throws SQLException {\n+        return _metaData.supportsMixedCaseIdentifiers();\n+    }\n+\n+    public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {\n+        return _metaData.supportsMixedCaseQuotedIdentifiers();\n+    }\n+\n+    public boolean supportsMultipleResultSets() throws SQLException {\n+        return _metaData.supportsMultipleResultSets();\n+    }\n+\n+    public boolean supportsMultipleTransactions() throws SQLException {\n+        return _metaData.supportsMultipleTransactions();\n+    }\n+\n+    public boolean supportsNonNullableColumns() throws SQLException {\n+        return _metaData.supportsNonNullableColumns();\n+    }\n+\n+    public boolean supportsOpenCursorsAcrossCommit() throws SQLException {\n+        return _metaData.supportsOpenCursorsAcrossCommit();\n+    }\n+\n+    public boolean supportsOpenCursorsAcrossRollback() throws SQLException {\n+        return _metaData.supportsOpenCursorsAcrossRollback();\n+    }\n+\n+    public boolean supportsOpenStatementsAcrossCommit() throws SQLException {\n+        return _metaData.supportsOpenStatementsAcrossCommit();\n+    }\n+\n+    public boolean supportsOpenStatementsAcrossRollback() throws SQLException {\n+        return _metaData.supportsOpenStatementsAcrossRollback();\n+    }\n+\n+    public boolean supportsOrderByUnrelated() throws SQLException {\n+        return _metaData.supportsOrderByUnrelated();\n+    }\n+\n+    public boolean supportsOuterJoins() throws SQLException {\n+        return _metaData.supportsOuterJoins();\n+    }\n+\n+    public boolean supportsPositionedDelete() throws SQLException {\n+        return _metaData.supportsPositionedDelete();\n+    }\n+\n+    public boolean supportsPositionedUpdate() throws SQLException {\n+        return _metaData.supportsPositionedUpdate();\n+    }\n+\n+    public boolean supportsResultSetConcurrency(int type, int concurrency)\n+        throws SQLException {\n+        return _metaData.supportsResultSetConcurrency(type, concurrency);\n+    }\n+\n+    public boolean supportsResultSetType(int type) throws SQLException {\n+        return _metaData.supportsResultSetType(type);\n+    }\n+\n+    public boolean supportsSchemasInDataManipulation() throws SQLException {\n+        return _metaData.supportsSchemasInDataManipulation();\n+    }\n+\n+    public boolean supportsSchemasInIndexDefinitions() throws SQLException {\n+        return _metaData.supportsSchemasInIndexDefinitions();\n+    }\n+\n+    public boolean supportsSchemasInPrivilegeDefinitions() throws SQLException {\n+        return _metaData.supportsSchemasInPrivilegeDefinitions();\n+    }\n+\n+    public boolean supportsSchemasInProcedureCalls() throws SQLException {\n+        return _metaData.supportsSchemasInProcedureCalls();\n+    }\n+\n+    public boolean supportsSchemasInTableDefinitions() throws SQLException {\n+        return _metaData.supportsSchemasInTableDefinitions();\n+    }\n+\n+    public boolean supportsSelectForUpdate() throws SQLException {\n+        return _metaData.supportsSelectForUpdate();\n+    }\n+\n+    public boolean supportsStoredProcedures() throws SQLException {\n+        return _metaData.supportsStoredProcedures();\n+    }\n+\n+    public boolean supportsSubqueriesInComparisons() throws SQLException {\n+        return _metaData.supportsSubqueriesInComparisons();\n+    }\n+\n+    public boolean supportsSubqueriesInExists() throws SQLException {\n+        return _metaData.supportsSubqueriesInExists();\n+    }\n+\n+    public boolean supportsSubqueriesInIns() throws SQLException {\n+        return _metaData.supportsSubqueriesInIns();\n+    }\n+\n+    public boolean supportsSubqueriesInQuantifieds() throws SQLException {\n+        return _metaData.supportsSubqueriesInQuantifieds();\n+    }\n+\n+    public boolean supportsTableCorrelationNames() throws SQLException {\n+        return _metaData.supportsTableCorrelationNames();\n+    }\n+\n+    public boolean supportsTransactionIsolationLevel(int level)\n+        throws SQLException {\n+        return _metaData.supportsTransactionIsolationLevel(level);\n+    }\n+\n+    public boolean supportsTransactions() throws SQLException {\n+        return _metaData.supportsTransactions();\n+    }\n+\n+    public boolean supportsUnion() throws SQLException {\n+        return _metaData.supportsUnion();\n+    }\n+\n+    public boolean supportsUnionAll() throws SQLException {\n+        return _metaData.supportsUnionAll();\n+    }\n+\n+    public boolean updatesAreDetected(int type) throws SQLException {\n+        return _metaData.updatesAreDetected(type);\n+    }\n+\n+    public boolean usesLocalFilePerTable() throws SQLException {\n+        return _metaData.usesLocalFilePerTable();\n+    }\n+\n+    public boolean usesLocalFiles() throws SQLException {\n+        return _metaData.usesLocalFiles();\n+    }\n+\n+    // JDBC 3.0 methods(unsupported) follow; these are required to be able to\n+    // compile against JDK 1.4\n+\n+    public boolean supportsSavepoints() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean supportsNamedParameters() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean supportsMultipleOpenResults() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean supportsGetGeneratedKeys() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public ResultSet getSuperTypes(String catalog, String schemaPatter,\n+        String typeNamePattern) throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public ResultSet getSuperTables(String catalog, String schemaPatter,\n+        String tableNamePattern) throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public ResultSet getAttributes(String catalog, String schemaPatter,\n+        String typeNamePattern, String attributeNamePattern)\n+        throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean supportsResultSetHoldability(int holdability)\n+        throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public int getResultSetHoldability() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public int getDatabaseMajorVersion() throws SQLException {\n+        return _metaData.getDatabaseMajorVersion();\n+    }\n+\n+    public int getDatabaseMinorVersion() throws SQLException {\n+        return _metaData.getDatabaseMinorVersion();\n+    }\n+\n+    public int getJDBCMajorVersion() throws SQLException {\n+        return _metaData.getJDBCMajorVersion();\n+    }\n+\n+    public int getJDBCMinorVersion() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public int getSQLStateType() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean locatorsUpdateCopy() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean supportsStatementPooling() throws SQLException {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n+"},{"sha":"42d08d0e1ba505812e1f9199dcd7954f915b47ef","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","status":"modified","additions":22,"deletions":1,"changes":23,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/LoggingConnectionDecorator.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -84,6 +84,7 @@\n     private int _warningAction = WARN_IGNORE;\n     private SQLWarningHandler _warningHandler;\n     private boolean _trackParameters = true;\n+    private boolean _printParameters = false;\n \n     /**\n      * If set to <code>true</code>, pretty-print SQL by running it\n@@ -141,6 +142,21 @@ public boolean getTrackParameters() {\n         return _trackParameters;\n     }\n \n+    /**\n+     * <p>\n+     * Whether parameter values will be printed in exception messages or in trace. This is different from\n+     * trackParameters which controls whether OpenJPA will track parameters internally (visible while debugging and used\n+     * in batching).\n+     * </p>\n+     */\n+    public boolean getPrintParameters() {\n+        return _printParameters;\n+    }\n+\n+    public void setPrintParameters(boolean printParameters) {\n+        _printParameters = printParameters;\n+    }\n+\n     /**\n      * What to do with SQL warnings.\n      */\n@@ -1129,7 +1145,12 @@ protected void appendInfo(StringBuffer buf) {\n                 if (_params != null && !_params.isEmpty()) {\n                     paramBuf = new StringBuffer();\n                     for (Iterator itr = _params.iterator(); itr.hasNext();) {\n-                        paramBuf.append(itr.next());\n+                        if(_printParameters) { \n+                            paramBuf.append(itr.next());\n+                        } else {\n+                            paramBuf.append(\"?\");\n+                            itr.next();\n+                        }\n                         if (itr.hasNext())\n                             paramBuf.append(\", \");\n                     }"},{"sha":"9acd5d656285426d5b7c25d72f1799054a71b654","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractNonSequentialResultList.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractNonSequentialResultList.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractNonSequentialResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractNonSequentialResultList.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -22,6 +22,7 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.ListIterator;\n import java.util.NoSuchElementException;\n \n@@ -145,6 +146,10 @@ public ListIterator listIterator(int index) {\n         return list.toArray(a);\n     }\n \n+    public List subList(int fromIndex, int toIndex) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n     private class Itr extends AbstractListIterator {\n \n         private int _idx = 0;"},{"sha":"f3a84b9559652279ff4b28b7d95516fdfea29ba8","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/LazyForwardResultList.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/LazyForwardResultList.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/LazyForwardResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/LazyForwardResultList.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -152,6 +152,11 @@ public boolean equals(Object other) {\n         return other == this;\n     }\n \n+    public List subList(int fromIndex, int toIndex) {\n+        assertOpen();\n+        return _list.subList(fromIndex, toIndex);\n+    }\n+\n     private class Itr extends AbstractListIterator {\n \n         private int _idx = 0;"},{"sha":"145c164482d6682bdedc3106d244285ece9d773d","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ListResultList.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ListResultList.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ListResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ListResultList.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -120,4 +120,9 @@ public ListIterator listIterator(int index) {\n     public Object writeReplace() {\n         return _list;\n     }\n+\n+    public List subList(int fromIndex, int toIndex) {\n+        assertOpen();\n+        return _list.subList(fromIndex, toIndex);\n+    }\n }"},{"sha":"9eebc566c3e3ad02e0a90637e22163f10eda369b","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","status":"modified","additions":167,"deletions":167,"changes":334,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,167 +1,167 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.lib.util;\r\n-\r\n-/**\r\n- * This class came from the Apache Commons Id sandbox project in support\r\n- * of the UUIDGenerator implementation.\r\n- *\r\n- * <p>Static methods for managing byte arrays (all methods follow Big\r\n- * Endian order where most significant bits are in front).</p>\r\n- */\r\n-public final class Bytes {\r\n-\r\n-    /**\r\n-     * <p>Hide constructor in utility class.</p>\r\n-     */\r\n-    private Bytes() {\r\n-    }\r\n-\r\n-    /**\r\n-     * Appends two bytes array into one.\r\n-     *\r\n-     * @param a A byte[].\r\n-     * @param b A byte[].\r\n-     * @return A byte[].\r\n-     */\r\n-    public static byte[] append(byte[] a, byte[] b) {\r\n-        byte[] z = new byte[a.length + b.length];\r\n-        System.arraycopy(a, 0, z, 0, a.length);\r\n-        System.arraycopy(b, 0, z, a.length, b.length);\r\n-        return z;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns a 8-byte array built from a long.\r\n-     *\r\n-     * @param n The number to convert.\r\n-     * @return A byte[].\r\n-     */\r\n-    public static byte[] toBytes(long n) {\r\n-        return toBytes(n, new byte[8]);\r\n-    }\r\n-\r\n-    /**\r\n-     * Build a 8-byte array from a long.  No check is performed on the\r\n-     * array length.\r\n-     *\r\n-     * @param n The number to convert.\r\n-     * @param b The array to fill.\r\n-     * @return A byte[].\r\n-     */\r\n-    public static byte[] toBytes(long n, byte[] b) {\r\n-        b[7] = (byte) (n);\r\n-        n >>>= 8;\r\n-        b[6] = (byte) (n);\r\n-        n >>>= 8;\r\n-        b[5] = (byte) (n);\r\n-        n >>>= 8;\r\n-        b[4] = (byte) (n);\r\n-        n >>>= 8;\r\n-        b[3] = (byte) (n);\r\n-        n >>>= 8;\r\n-        b[2] = (byte) (n);\r\n-        n >>>= 8;\r\n-        b[1] = (byte) (n);\r\n-        n >>>= 8;\r\n-        b[0] = (byte) (n);\r\n-\r\n-        return b;\r\n-    }\r\n-\r\n-    /**\r\n-     * Build a long from first 8 bytes of the array.\r\n-     *\r\n-     * @param b The byte[] to convert.\r\n-     * @return A long.\r\n-     */\r\n-    public static long toLong(byte[] b) {\r\n-        return ((((long) b[7]) & 0xFF)\r\n-                + ((((long) b[6]) & 0xFF) << 8)\r\n-                + ((((long) b[5]) & 0xFF) << 16)\r\n-                + ((((long) b[4]) & 0xFF) << 24)\r\n-                + ((((long) b[3]) & 0xFF) << 32)\r\n-                + ((((long) b[2]) & 0xFF) << 40)\r\n-                + ((((long) b[1]) & 0xFF) << 48)\r\n-                + ((((long) b[0]) & 0xFF) << 56));\r\n-    }\r\n-\r\n-    /**\r\n-    * Compares two byte arrays for equality.\r\n-    *\r\n-    * @param a A byte[].\r\n-    * @param b A byte[].\r\n-    * @return True if the arrays have identical contents.\r\n-    */\r\n-    public static boolean areEqual(byte[] a, byte[] b) {\r\n-        int aLength = a.length;\r\n-        if (aLength != b.length) {\r\n-            return false;\r\n-        }\r\n-\r\n-        for (int i = 0; i < aLength; i++) {\r\n-            if (a[i] != b[i]) {\r\n-                return false;\r\n-            }\r\n-        }\r\n-        return true;\r\n-    }\r\n-\r\n-    /**\r\n-     * <p>Compares two byte arrays as specified by <code>Comparable</code>.\r\n-     *\r\n-     * @param lhs - left hand value in the comparison operation.\r\n-     * @param rhs - right hand value in the comparison operation.\r\n-     * @return  a negative integer, zero, or a positive integer as \r\n-     * <code>lhs</code> is less than, equal to, or greater than \r\n-     * <code>rhs</code>.\r\n-     */\r\n-    public static int compareTo(byte[] lhs, byte[] rhs) {\r\n-        if (lhs == rhs) {\r\n-            return 0;\r\n-        }\r\n-        if (lhs == null) {\r\n-            return -1;\r\n-        }\r\n-        if (rhs == null) {\r\n-            return +1;\r\n-        }\r\n-        if (lhs.length != rhs.length) {\r\n-            return ((lhs.length < rhs.length) ? -1 : +1);\r\n-        }\r\n-        for (int i = 0; i < lhs.length; i++) {\r\n-            if (lhs[i] < rhs[i]) {\r\n-                return -1;\r\n-            } else if (lhs[i] > rhs[i]) {\r\n-                return 1;\r\n-            }\r\n-        }\r\n-        return 0;\r\n-    }\r\n-\r\n-    /**\r\n-     * Build a short from first 2 bytes of the array.\r\n-     *\r\n-     * @param b The byte[] to convert.\r\n-     * @return A short.\r\n-     */\r\n-    public static short toShort(byte[] b) {\r\n-        return  (short) ((b[1] & 0xFF) + ((b[0] & 0xFF) << 8));\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.util;\n+\n+/**\n+ * This class came from the Apache Commons Id sandbox project in support\n+ * of the UUIDGenerator implementation.\n+ *\n+ * <p>Static methods for managing byte arrays (all methods follow Big\n+ * Endian order where most significant bits are in front).</p>\n+ */\n+public final class Bytes {\n+\n+    /**\n+     * <p>Hide constructor in utility class.</p>\n+     */\n+    private Bytes() {\n+    }\n+\n+    /**\n+     * Appends two bytes array into one.\n+     *\n+     * @param a A byte[].\n+     * @param b A byte[].\n+     * @return A byte[].\n+     */\n+    public static byte[] append(byte[] a, byte[] b) {\n+        byte[] z = new byte[a.length + b.length];\n+        System.arraycopy(a, 0, z, 0, a.length);\n+        System.arraycopy(b, 0, z, a.length, b.length);\n+        return z;\n+    }\n+\n+    /**\n+     * Returns a 8-byte array built from a long.\n+     *\n+     * @param n The number to convert.\n+     * @return A byte[].\n+     */\n+    public static byte[] toBytes(long n) {\n+        return toBytes(n, new byte[8]);\n+    }\n+\n+    /**\n+     * Build a 8-byte array from a long.  No check is performed on the\n+     * array length.\n+     *\n+     * @param n The number to convert.\n+     * @param b The array to fill.\n+     * @return A byte[].\n+     */\n+    public static byte[] toBytes(long n, byte[] b) {\n+        b[7] = (byte) (n);\n+        n >>>= 8;\n+        b[6] = (byte) (n);\n+        n >>>= 8;\n+        b[5] = (byte) (n);\n+        n >>>= 8;\n+        b[4] = (byte) (n);\n+        n >>>= 8;\n+        b[3] = (byte) (n);\n+        n >>>= 8;\n+        b[2] = (byte) (n);\n+        n >>>= 8;\n+        b[1] = (byte) (n);\n+        n >>>= 8;\n+        b[0] = (byte) (n);\n+\n+        return b;\n+    }\n+\n+    /**\n+     * Build a long from first 8 bytes of the array.\n+     *\n+     * @param b The byte[] to convert.\n+     * @return A long.\n+     */\n+    public static long toLong(byte[] b) {\n+        return ((((long) b[7]) & 0xFF)\n+                + ((((long) b[6]) & 0xFF) << 8)\n+                + ((((long) b[5]) & 0xFF) << 16)\n+                + ((((long) b[4]) & 0xFF) << 24)\n+                + ((((long) b[3]) & 0xFF) << 32)\n+                + ((((long) b[2]) & 0xFF) << 40)\n+                + ((((long) b[1]) & 0xFF) << 48)\n+                + ((((long) b[0]) & 0xFF) << 56));\n+    }\n+\n+    /**\n+    * Compares two byte arrays for equality.\n+    *\n+    * @param a A byte[].\n+    * @param b A byte[].\n+    * @return True if the arrays have identical contents.\n+    */\n+    public static boolean areEqual(byte[] a, byte[] b) {\n+        int aLength = a.length;\n+        if (aLength != b.length) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < aLength; i++) {\n+            if (a[i] != b[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Compares two byte arrays as specified by <code>Comparable</code>.\n+     *\n+     * @param lhs - left hand value in the comparison operation.\n+     * @param rhs - right hand value in the comparison operation.\n+     * @return  a negative integer, zero, or a positive integer as \n+     * <code>lhs</code> is less than, equal to, or greater than \n+     * <code>rhs</code>.\n+     */\n+    public static int compareTo(byte[] lhs, byte[] rhs) {\n+        if (lhs == rhs) {\n+            return 0;\n+        }\n+        if (lhs == null) {\n+            return -1;\n+        }\n+        if (rhs == null) {\n+            return +1;\n+        }\n+        if (lhs.length != rhs.length) {\n+            return ((lhs.length < rhs.length) ? -1 : +1);\n+        }\n+        for (int i = 0; i < lhs.length; i++) {\n+            if (lhs[i] < rhs[i]) {\n+                return -1;\n+            } else if (lhs[i] > rhs[i]) {\n+                return 1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Build a short from first 2 bytes of the array.\n+     *\n+     * @param b The byte[] to convert.\n+     * @return A short.\n+     */\n+    public static short toShort(byte[] b) {\n+        return  (short) ((b[1] & 0xFF) + ((b[0] & 0xFF) << 8));\n+    }\n+}"},{"sha":"fcea58dd616124f857324a3784039d3b59f9c6fd","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java","status":"modified","additions":63,"deletions":63,"changes":126,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,63 +1,63 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.lib.conf;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.File;\r\n-import java.io.FileReader;\r\n-import java.io.IOException;\r\n-\r\n-import junit.framework.TestCase;\r\n-\r\n-\r\n-public class TestXMLCaseConversions extends TestCase {\r\n-\r\n-    public void testToXMLName() {\r\n-        assertEquals(\"easy-xml-conversion\", \r\n-            ConfigurationImpl.toXMLName(\"easyXmlConversion\"));\r\n-        assertEquals(\"initial-caps\", \r\n-            ConfigurationImpl.toXMLName(\"InitialCaps\"));\r\n-        assertEquals(\"nodash\", \r\n-            ConfigurationImpl.toXMLName(\"nodash\"));\r\n-        assertEquals(\"anothernodash\", \r\n-            ConfigurationImpl.toXMLName(\"Anothernodash\"));\r\n-        assertEquals(\"multiple-caps\", \r\n-            ConfigurationImpl.toXMLName(\"MUltipleCaps\"));\r\n-        assertEquals(\"trailing-multi-caps\", \r\n-            ConfigurationImpl.toXMLName(\"TrailingMultiCAPS\"));\r\n-        assertEquals(\"two-i-nner-caps\", \r\n-            ConfigurationImpl.toXMLName(\"TwoINnerCaps\"));\r\n-        assertEquals(\"four-inn-er-caps\", \r\n-            ConfigurationImpl.toXMLName(\"FourINNErCaps\"));\r\n-        assertEquals(\"inner-3-number\", \r\n-            ConfigurationImpl.toXMLName(\"Inner3Number\"));\r\n-        assertEquals(\"inner-03-number\", \r\n-            ConfigurationImpl.toXMLName(\"Inner03Number\"));\r\n-    }\r\n-    \r\n-    public static void main(String[] args) throws IOException {\r\n-        BufferedReader r = new BufferedReader (new FileReader(new File(args[0])));\r\n-        while (true) {\r\n-            String s = r.readLine();\r\n-            if (s == null)\r\n-                break;\r\n-            System.out.println(s + \": \" + ConfigurationImpl.toXMLName(s));\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.conf;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+\n+import junit.framework.TestCase;\n+\n+\n+public class TestXMLCaseConversions extends TestCase {\n+\n+    public void testToXMLName() {\n+        assertEquals(\"easy-xml-conversion\", \n+            ConfigurationImpl.toXMLName(\"easyXmlConversion\"));\n+        assertEquals(\"initial-caps\", \n+            ConfigurationImpl.toXMLName(\"InitialCaps\"));\n+        assertEquals(\"nodash\", \n+            ConfigurationImpl.toXMLName(\"nodash\"));\n+        assertEquals(\"anothernodash\", \n+            ConfigurationImpl.toXMLName(\"Anothernodash\"));\n+        assertEquals(\"multiple-caps\", \n+            ConfigurationImpl.toXMLName(\"MUltipleCaps\"));\n+        assertEquals(\"trailing-multi-caps\", \n+            ConfigurationImpl.toXMLName(\"TrailingMultiCAPS\"));\n+        assertEquals(\"two-i-nner-caps\", \n+            ConfigurationImpl.toXMLName(\"TwoINnerCaps\"));\n+        assertEquals(\"four-inn-er-caps\", \n+            ConfigurationImpl.toXMLName(\"FourINNErCaps\"));\n+        assertEquals(\"inner-3-number\", \n+            ConfigurationImpl.toXMLName(\"Inner3Number\"));\n+        assertEquals(\"inner-03-number\", \n+            ConfigurationImpl.toXMLName(\"Inner03Number\"));\n+    }\n+    \n+    public static void main(String[] args) throws IOException {\n+        BufferedReader r = new BufferedReader (new FileReader(new File(args[0])));\n+        while (true) {\n+            String s = r.readLine();\n+            if (s == null)\n+                break;\n+            System.out.println(s + \": \" + ConfigurationImpl.toXMLName(s));\n+        }\n+    }\n+}"},{"sha":"e06648dc6642844a5e502df682eb7213b41f2abc","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java","status":"modified","additions":109,"deletions":109,"changes":218,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,109 +1,109 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.lib.conf.test;\r\n-\r\n-import java.io.InputStream;\r\n-import java.io.IOException;\r\n-import java.net.URL;\r\n-import java.util.MissingResourceException;\r\n-import java.util.Properties;\r\n-\r\n-import org.apache.openjpa.lib.conf.AbstractProductDerivation;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.conf.ConfigurationProvider;\r\n-import org.apache.openjpa.lib.conf.MapConfigurationProvider;\r\n-import org.apache.openjpa.lib.conf.ProductDerivation;\r\n-\r\n-/**\r\n- * A Product Derivation to test loading of global and default configuration with\r\n- * System settings.  Reads its global from a file specified by \r\n- * <code>\"openjpatest.properties\"</code> system property.\r\n- *\r\n- * @author Pinaki Poddar\r\n- * @author Abe White\r\n- */\r\n-public class ConfigurationTestProductDerivation \r\n-    extends AbstractProductDerivation {\r\n-    \r\n-    public static boolean closed = false;\r\n-\r\n-    public int getType() {\r\n-        return ProductDerivation.TYPE_PRODUCT;\r\n-    }\r\n-    \r\n-    public void beforeConfigurationClose(Configuration conf) {\r\n-        closed = true;\r\n-    }\r\n-\r\n-    public ConfigurationProvider loadGlobals(ClassLoader loader)\r\n-        throws IOException {\r\n-        return load(null, loader);\r\n-    }\r\n-\r\n-    public ConfigurationProvider load(String rsrc, ClassLoader loader)\r\n-        throws IOException {\r\n-        if (rsrc == null)\r\n-            rsrc = System.getProperty(\"openjpatest.properties\");\r\n-        if (rsrc == null || !rsrc.endsWith(\".properties\"))\r\n-            return null;\r\n-\r\n-        URL url = findResource(rsrc, loader);\r\n-        if (url == null)\r\n-            throw new MissingResourceException(rsrc, getClass().getName(), \r\n-                rsrc);\r\n-\r\n-        InputStream in = url.openStream();\r\n-        Properties props = new Properties();\r\n-        if (in != null) {\r\n-            try {\r\n-                props.load(in);\r\n-                return new MapConfigurationProvider(props);\r\n-            } finally {\r\n-                try { in.close(); } catch (Exception e) {}\r\n-            }\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Locate the given resource.\r\n-     */\r\n-    private URL findResource(String rsrc, ClassLoader loader)\r\n-        throws IOException {\r\n-        if (loader != null)\r\n-            return loader.getResource(rsrc);\r\n-\r\n-        // in jbuilder the classloader can be null\r\n-        URL url = null;\r\n-        loader = getClass().getClassLoader();\r\n-        if (loader != null)\r\n-            url = loader.getResource(rsrc);\r\n-        if (url == null) {\r\n-            loader = Thread.currentThread().getContextClassLoader();\r\n-            if (loader != null)\r\n-                url = loader.getResource(rsrc);\r\n-        }\r\n-        if (url == null) {\r\n-            loader = ClassLoader.getSystemClassLoader();\r\n-            if (loader != null)\r\n-                url = loader.getResource(rsrc);\r\n-        }\r\n-        return url;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.conf.test;\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.MissingResourceException;\n+import java.util.Properties;\n+\n+import org.apache.openjpa.lib.conf.AbstractProductDerivation;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\n+import org.apache.openjpa.lib.conf.MapConfigurationProvider;\n+import org.apache.openjpa.lib.conf.ProductDerivation;\n+\n+/**\n+ * A Product Derivation to test loading of global and default configuration with\n+ * System settings.  Reads its global from a file specified by \n+ * <code>\"openjpatest.properties\"</code> system property.\n+ *\n+ * @author Pinaki Poddar\n+ * @author Abe White\n+ */\n+public class ConfigurationTestProductDerivation \n+    extends AbstractProductDerivation {\n+    \n+    public static boolean closed = false;\n+\n+    public int getType() {\n+        return ProductDerivation.TYPE_PRODUCT;\n+    }\n+    \n+    public void beforeConfigurationClose(Configuration conf) {\n+        closed = true;\n+    }\n+\n+    public ConfigurationProvider loadGlobals(ClassLoader loader)\n+        throws IOException {\n+        return load(null, loader);\n+    }\n+\n+    public ConfigurationProvider load(String rsrc, ClassLoader loader)\n+        throws IOException {\n+        if (rsrc == null)\n+            rsrc = System.getProperty(\"openjpatest.properties\");\n+        if (rsrc == null || !rsrc.endsWith(\".properties\"))\n+            return null;\n+\n+        URL url = findResource(rsrc, loader);\n+        if (url == null)\n+            throw new MissingResourceException(rsrc, getClass().getName(), \n+                rsrc);\n+\n+        InputStream in = url.openStream();\n+        Properties props = new Properties();\n+        if (in != null) {\n+            try {\n+                props.load(in);\n+                return new MapConfigurationProvider(props);\n+            } finally {\n+                try { in.close(); } catch (Exception e) {}\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Locate the given resource.\n+     */\n+    private URL findResource(String rsrc, ClassLoader loader)\n+        throws IOException {\n+        if (loader != null)\n+            return loader.getResource(rsrc);\n+\n+        // in jbuilder the classloader can be null\n+        URL url = null;\n+        loader = getClass().getClassLoader();\n+        if (loader != null)\n+            url = loader.getResource(rsrc);\n+        if (url == null) {\n+            loader = Thread.currentThread().getContextClassLoader();\n+            if (loader != null)\n+                url = loader.getResource(rsrc);\n+        }\n+        if (url == null) {\n+            loader = ClassLoader.getSystemClassLoader();\n+            if (loader != null)\n+                url = loader.getResource(rsrc);\n+        }\n+        return url;\n+    }\n+}"},{"sha":"1df285153bb30953b5a7799b6be28fdd79b236bb","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","status":"modified","additions":152,"deletions":152,"changes":304,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,152 +1,152 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.graph;\r\n-\r\n-import java.util.Collection;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-\r\n-import org.apache.openjpa.lib.test.AbstractTestCase;\r\n-\r\n-/**\r\n- * <p>Tests the {@link DepthFirstAnalysis} type.</p>\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public class TestDepthFirstAnalysis\r\n-    extends AbstractTestCase {\r\n-\r\n-    private DepthFirstAnalysis _dfa = null;\r\n-\r\n-    public void setUp() {\r\n-        setUpGraph1();   \r\n-    }\r\n-    \r\n-    public void setUpGraph1() {\r\n-        Graph graph = new Graph();\r\n-        Object node1 = new Object();\r\n-        Object node2 = new Object();\r\n-        Object node3 = new Object();\r\n-        Object node4 = new Object();\r\n-        graph.addNode(node1);\r\n-        graph.addNode(node2);\r\n-        graph.addNode(node3);\r\n-        graph.addNode(node4);\r\n-        graph.addEdge(new Edge(node1, node2, true));\r\n-        graph.addEdge(new Edge(node2, node3, true));\r\n-        graph.addEdge(new Edge(node3, node1, true));\r\n-        graph.addEdge(new Edge(node3, node4, true));\r\n-        graph.addEdge(new Edge(node2, node2, true));\r\n-        _dfa = new DepthFirstAnalysis(graph);\r\n-    }\r\n-\r\n-    public void setUpGraph2() {\r\n-        Graph graph = new Graph();\r\n-        Integer node1 = new Integer(1);\r\n-        Integer node2 = new Integer(2);\r\n-        Integer node3 = new Integer(3);\r\n-        Integer node4 = new Integer(4);\r\n-        Integer node5 = new Integer(5);\r\n-        graph.addNode(node2);  // has to be first node for testcase\r\n-        graph.addNode(node5);\r\n-        graph.addNode(node4);\r\n-        graph.addNode(node3);\r\n-        graph.addNode(node1);\r\n-        graph.addEdge(new Edge(node5, node4, true));\r\n-        graph.addEdge(new Edge(node4, node3, true));\r\n-        graph.addEdge(new Edge(node3, node3, true));\r\n-        graph.addEdge(new Edge(node3, node2, true));\r\n-        graph.addEdge(new Edge(node2, node5, true));\r\n-        graph.addEdge(new Edge(node2, node4, true));\r\n-        graph.addEdge(new Edge(node1, node4, true));\r\n-        _dfa = new DepthFirstAnalysis(graph);\r\n-    }\r\n-\r\n-    public void testNodeSorting() {\r\n-        Collection nodes = _dfa.getSortedNodes();\r\n-        assertEquals(4, nodes.size());\r\n-\r\n-        int time = 0;\r\n-        Object node;\r\n-        for (Iterator itr = nodes.iterator(); itr.hasNext();) {\r\n-            node = itr.next();\r\n-            assertTrue(time <= _dfa.getFinishedTime(node));\r\n-            time = _dfa.getFinishedTime(node);\r\n-        }\r\n-    }\r\n-\r\n-    public void testEdgeTyping() {\r\n-        Collection edges = _dfa.getEdges(Edge.TYPE_BACK);\r\n-        assertEquals(2, edges.size());\r\n-        Iterator itr = edges.iterator();\r\n-        Edge edge0 = (Edge) itr.next();\r\n-        Edge edge1 = (Edge) itr.next();\r\n-        assertTrue((edge0.getTo().equals(edge0.getFrom()))\r\n-                || edge1.getTo().equals(edge1.getFrom()));\r\n-    }\r\n-\r\n-    public void testBackEdges() {\r\n-        setUpGraph2();\r\n-        Collection edges = _dfa.getEdges(Edge.TYPE_BACK);\r\n-        assertEquals(2, edges.size());\r\n-        Iterator itr = edges.iterator();\r\n-        Edge edge0 = (Edge) itr.next();\r\n-        Edge edge1 = (Edge) itr.next();\r\n-        if (edge0.getTo().equals(edge0.getFrom())) {\r\n-            assertTrue(edge0.getCycle() != null && edge0.getCycle().size() == 1);\r\n-            List cycle = edge1.getCycle();\r\n-            assertTrue(cycle != null && cycle.size() == 4);\r\n-            assertTrue(((Edge)cycle.get(0)).getFrom().equals(((Edge)cycle.get(3)).getTo()));\r\n-        } else if (edge1.getTo().equals(edge1.getFrom())) {\r\n-            assertTrue(edge1.getCycle() != null && edge1.getCycle().size() == 1);            \r\n-            assertTrue(edge1 == edge1.getCycle());\r\n-            List cycle = edge0.getCycle();\r\n-            assertTrue(cycle != null && cycle.size() == 4);\r\n-            assertTrue(((Edge)cycle.get(0)).getFrom().equals(((Edge)cycle.get(3)).getTo()));\r\n-        } else {\r\n-            // should not happen\r\n-            assertFalse(true);\r\n-        }\r\n-    }\r\n-    \r\n-    public void testForwardEdges() {\r\n-        setUpGraph2();\r\n-        Collection edges = _dfa.getEdges(Edge.TYPE_FORWARD);\r\n-        assertEquals(2, edges.size());\r\n-        Iterator itr = edges.iterator();\r\n-        Edge edge0 = (Edge) itr.next();\r\n-        Edge edge1 = (Edge) itr.next();\r\n-        if (edge0.getCycle() == null) {\r\n-            List cycle = edge1.getCycle();\r\n-            assertTrue(cycle != null && cycle.size() == 3);\r\n-            assertTrue(((Edge)cycle.get(0)).getFrom().equals(((Edge)cycle.get(2)).getTo()));\r\n-        } else if (edge1.getCycle() == null) {\r\n-            List cycle = edge0.getCycle();\r\n-            assertTrue(cycle != null && cycle.size() == 3);\r\n-            assertTrue(((Edge)cycle.get(0)).getFrom().equals(((Edge)cycle.get(2)).getTo()));\r\n-        } else {\r\n-            // should not happen\r\n-            assertFalse(true);\r\n-        }\r\n-    }\r\n-    \r\n-    public static void main(String[] args) {\r\n-        main(TestDepthFirstAnalysis.class);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.graph;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.openjpa.lib.test.AbstractTestCase;\n+\n+/**\n+ * <p>Tests the {@link DepthFirstAnalysis} type.</p>\n+ *\n+ * @author Abe White\n+ */\n+public class TestDepthFirstAnalysis\n+    extends AbstractTestCase {\n+\n+    private DepthFirstAnalysis _dfa = null;\n+\n+    public void setUp() {\n+        setUpGraph1();   \n+    }\n+    \n+    public void setUpGraph1() {\n+        Graph graph = new Graph();\n+        Object node1 = new Object();\n+        Object node2 = new Object();\n+        Object node3 = new Object();\n+        Object node4 = new Object();\n+        graph.addNode(node1);\n+        graph.addNode(node2);\n+        graph.addNode(node3);\n+        graph.addNode(node4);\n+        graph.addEdge(new Edge(node1, node2, true));\n+        graph.addEdge(new Edge(node2, node3, true));\n+        graph.addEdge(new Edge(node3, node1, true));\n+        graph.addEdge(new Edge(node3, node4, true));\n+        graph.addEdge(new Edge(node2, node2, true));\n+        _dfa = new DepthFirstAnalysis(graph);\n+    }\n+\n+    public void setUpGraph2() {\n+        Graph graph = new Graph();\n+        Integer node1 = new Integer(1);\n+        Integer node2 = new Integer(2);\n+        Integer node3 = new Integer(3);\n+        Integer node4 = new Integer(4);\n+        Integer node5 = new Integer(5);\n+        graph.addNode(node2);  // has to be first node for testcase\n+        graph.addNode(node5);\n+        graph.addNode(node4);\n+        graph.addNode(node3);\n+        graph.addNode(node1);\n+        graph.addEdge(new Edge(node5, node4, true));\n+        graph.addEdge(new Edge(node4, node3, true));\n+        graph.addEdge(new Edge(node3, node3, true));\n+        graph.addEdge(new Edge(node3, node2, true));\n+        graph.addEdge(new Edge(node2, node5, true));\n+        graph.addEdge(new Edge(node2, node4, true));\n+        graph.addEdge(new Edge(node1, node4, true));\n+        _dfa = new DepthFirstAnalysis(graph);\n+    }\n+\n+    public void testNodeSorting() {\n+        Collection nodes = _dfa.getSortedNodes();\n+        assertEquals(4, nodes.size());\n+\n+        int time = 0;\n+        Object node;\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();) {\n+            node = itr.next();\n+            assertTrue(time <= _dfa.getFinishedTime(node));\n+            time = _dfa.getFinishedTime(node);\n+        }\n+    }\n+\n+    public void testEdgeTyping() {\n+        Collection edges = _dfa.getEdges(Edge.TYPE_BACK);\n+        assertEquals(2, edges.size());\n+        Iterator itr = edges.iterator();\n+        Edge edge0 = (Edge) itr.next();\n+        Edge edge1 = (Edge) itr.next();\n+        assertTrue((edge0.getTo().equals(edge0.getFrom()))\n+                || edge1.getTo().equals(edge1.getFrom()));\n+    }\n+\n+    public void testBackEdges() {\n+        setUpGraph2();\n+        Collection edges = _dfa.getEdges(Edge.TYPE_BACK);\n+        assertEquals(2, edges.size());\n+        Iterator itr = edges.iterator();\n+        Edge edge0 = (Edge) itr.next();\n+        Edge edge1 = (Edge) itr.next();\n+        if (edge0.getTo().equals(edge0.getFrom())) {\n+            assertTrue(edge0.getCycle() != null && edge0.getCycle().size() == 1);\n+            List cycle = edge1.getCycle();\n+            assertTrue(cycle != null && cycle.size() == 4);\n+            assertTrue(((Edge)cycle.get(0)).getFrom().equals(((Edge)cycle.get(3)).getTo()));\n+        } else if (edge1.getTo().equals(edge1.getFrom())) {\n+            assertTrue(edge1.getCycle() != null && edge1.getCycle().size() == 1);            \n+            assertTrue(edge1 == edge1.getCycle());\n+            List cycle = edge0.getCycle();\n+            assertTrue(cycle != null && cycle.size() == 4);\n+            assertTrue(((Edge)cycle.get(0)).getFrom().equals(((Edge)cycle.get(3)).getTo()));\n+        } else {\n+            // should not happen\n+            assertFalse(true);\n+        }\n+    }\n+    \n+    public void testForwardEdges() {\n+        setUpGraph2();\n+        Collection edges = _dfa.getEdges(Edge.TYPE_FORWARD);\n+        assertEquals(2, edges.size());\n+        Iterator itr = edges.iterator();\n+        Edge edge0 = (Edge) itr.next();\n+        Edge edge1 = (Edge) itr.next();\n+        if (edge0.getCycle() == null) {\n+            List cycle = edge1.getCycle();\n+            assertTrue(cycle != null && cycle.size() == 3);\n+            assertTrue(((Edge)cycle.get(0)).getFrom().equals(((Edge)cycle.get(2)).getTo()));\n+        } else if (edge1.getCycle() == null) {\n+            List cycle = edge0.getCycle();\n+            assertTrue(cycle != null && cycle.size() == 3);\n+            assertTrue(((Edge)cycle.get(0)).getFrom().equals(((Edge)cycle.get(2)).getTo()));\n+        } else {\n+            // should not happen\n+            assertFalse(true);\n+        }\n+    }\n+    \n+    public static void main(String[] args) {\n+        main(TestDepthFirstAnalysis.class);\n+    }\n+}"},{"sha":"3b21530ffeb82b4c131a042d4b88c688da26bc08","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","status":"modified","additions":148,"deletions":148,"changes":296,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,148 +1,148 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.lib.graph;\r\n-\r\n-import java.util.Collection;\r\n-import java.util.Iterator;\r\n-\r\n-import org.apache.openjpa.lib.test.AbstractTestCase;\r\n-\r\n-/**\r\n- * <p>Tests the {@link Graph} type, and in so doing implicitly tests the\r\n- * {@link Edge} as well.</p>\r\n- *\r\n- * @author Abe White\r\n- */\r\n-public class TestGraph\r\n-    extends AbstractTestCase {\r\n-\r\n-    private Graph _graph = new Graph();\r\n-    private Object _node1 = new Object();\r\n-    private Object _node2 = new Object();\r\n-    private Object _node3 = new Object();\r\n-    private Edge _edge1 = new Edge(_node1, _node2, true);\r\n-    private Edge _edge2 = new Edge(_node2, _node3, true);\r\n-    private Edge _edge3 = new Edge(_node1, _node3, false);\r\n-    private Edge _edge4 = new Edge(_node2, _node2, false);\r\n-\r\n-    public void setUp() {\r\n-        _graph.addNode(_node1);\r\n-        _graph.addNode(_node2);\r\n-        _graph.addNode(_node3);\r\n-        _graph.addEdge(_edge1);\r\n-        _graph.addEdge(_edge2);\r\n-        _graph.addEdge(_edge3);\r\n-        _graph.addEdge(_edge4);\r\n-    }\r\n-\r\n-    /**\r\n-     * Tests adding and retrieving nodes and edges.\r\n-     */\r\n-    public void testAddRetrieve() {\r\n-        assertEquals(3, _graph.getNodes().size());\r\n-        assertEquals(4, _graph.getEdges().size());\r\n-\r\n-        Collection edges = _graph.getEdgesFrom(_node1);\r\n-        assertEquals(2, edges.size());\r\n-        Iterator itr = edges.iterator();\r\n-        Edge edge0 = (Edge) itr.next();\r\n-        Edge edge1 = (Edge) itr.next();\r\n-        assertTrue((edge0 == _edge1 && edge1 == _edge3)\r\n-            || (edge0 == _edge3 && edge1 == _edge1));\r\n-\r\n-        edges = _graph.getEdgesTo(_node1);\r\n-        assertEquals(1, edges.size());\r\n-        assertEquals(_edge3, edges.iterator().next());\r\n-\r\n-        edges = _graph.getEdges(_node1, _node3);\r\n-        assertEquals(1, edges.size());\r\n-        assertEquals(_edge3, edges.iterator().next());\r\n-        edges = _graph.getEdges(_node3, _node1);\r\n-        assertEquals(1, edges.size());\r\n-        assertEquals(_edge3, edges.iterator().next());\r\n-\r\n-        edges = _graph.getEdgesFrom(_node2);\r\n-        assertEquals(2, edges.size());\r\n-        itr = edges.iterator();\r\n-        edge0 = (Edge) itr.next();\r\n-        edge1 = (Edge) itr.next();\r\n-        assertTrue((edge0 == _edge2 && edge1 == _edge4)\r\n-            || (edge0 == _edge4 && edge1 == _edge2));\r\n-\r\n-        edges = _graph.getEdgesTo(_node2);\r\n-        assertEquals(2, edges.size());\r\n-        itr = edges.iterator();\r\n-        edge0 = (Edge) itr.next();\r\n-        edge1 = (Edge) itr.next();\r\n-        assertTrue((edge0 == _edge1 && edge1 == _edge4)\r\n-            || (edge0 == _edge4 && edge1 == _edge1));\r\n-\r\n-        edges = _graph.getEdges(_node2, _node2);\r\n-        assertEquals(1, edges.size());\r\n-        assertEquals(_edge4, edges.iterator().next());\r\n-\r\n-        edges = _graph.getEdgesFrom(_node3);\r\n-        assertEquals(1, edges.size());\r\n-        assertEquals(_edge3, edges.iterator().next());\r\n-    }\r\n-\r\n-    /**\r\n-     * Test removing edges.\r\n-     */\r\n-    public void testRemoveEdges() {\r\n-        assertTrue(_graph.removeEdge(_edge2));\r\n-        Collection edges = _graph.getEdgesFrom(_node2);\r\n-        assertEquals(1, edges.size());\r\n-        assertEquals(_edge4, edges.iterator().next());\r\n-\r\n-        assertTrue(_graph.removeEdge(_edge3));\r\n-        edges = _graph.getEdgesFrom(_node1);\r\n-        assertEquals(1, edges.size());\r\n-        assertEquals(_edge1, edges.iterator().next());\r\n-        edges = _graph.getEdgesTo(_node1);\r\n-        assertEquals(0, edges.size());\r\n-        edges = _graph.getEdgesTo(_node3);\r\n-        assertEquals(0, edges.size());\r\n-        edges = _graph.getEdgesFrom(_node3);\r\n-        assertEquals(0, edges.size());\r\n-    }\r\n-\r\n-    /**\r\n-     * Test removing nodes.\r\n-     */\r\n-    public void testRemoveNodes() {\r\n-        assertTrue(_graph.removeNode(_node3));\r\n-        Collection edges = _graph.getEdges();\r\n-        assertEquals(2, edges.size());\r\n-        Iterator itr = edges.iterator();\r\n-        Edge edge0 = (Edge) itr.next();\r\n-        Edge edge1 = (Edge) itr.next();\r\n-        assertTrue((edge0 == _edge1 && edge1 == _edge4)\r\n-            || (edge0 == _edge4 && edge1 == _edge1));\r\n-        edges = _graph.getEdgesFrom(_node1);\r\n-        assertEquals(1, edges.size());\r\n-        assertEquals(_edge1, edges.iterator().next());\r\n-        edges = _graph.getEdgesTo(_node1);\r\n-        assertEquals(0, edges.size());\r\n-    }\r\n-\r\n-    public static void main(String[] args) {\r\n-        main(TestGraph.class);\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.lib.graph;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.openjpa.lib.test.AbstractTestCase;\n+\n+/**\n+ * <p>Tests the {@link Graph} type, and in so doing implicitly tests the\n+ * {@link Edge} as well.</p>\n+ *\n+ * @author Abe White\n+ */\n+public class TestGraph\n+    extends AbstractTestCase {\n+\n+    private Graph _graph = new Graph();\n+    private Object _node1 = new Object();\n+    private Object _node2 = new Object();\n+    private Object _node3 = new Object();\n+    private Edge _edge1 = new Edge(_node1, _node2, true);\n+    private Edge _edge2 = new Edge(_node2, _node3, true);\n+    private Edge _edge3 = new Edge(_node1, _node3, false);\n+    private Edge _edge4 = new Edge(_node2, _node2, false);\n+\n+    public void setUp() {\n+        _graph.addNode(_node1);\n+        _graph.addNode(_node2);\n+        _graph.addNode(_node3);\n+        _graph.addEdge(_edge1);\n+        _graph.addEdge(_edge2);\n+        _graph.addEdge(_edge3);\n+        _graph.addEdge(_edge4);\n+    }\n+\n+    /**\n+     * Tests adding and retrieving nodes and edges.\n+     */\n+    public void testAddRetrieve() {\n+        assertEquals(3, _graph.getNodes().size());\n+        assertEquals(4, _graph.getEdges().size());\n+\n+        Collection edges = _graph.getEdgesFrom(_node1);\n+        assertEquals(2, edges.size());\n+        Iterator itr = edges.iterator();\n+        Edge edge0 = (Edge) itr.next();\n+        Edge edge1 = (Edge) itr.next();\n+        assertTrue((edge0 == _edge1 && edge1 == _edge3)\n+            || (edge0 == _edge3 && edge1 == _edge1));\n+\n+        edges = _graph.getEdgesTo(_node1);\n+        assertEquals(1, edges.size());\n+        assertEquals(_edge3, edges.iterator().next());\n+\n+        edges = _graph.getEdges(_node1, _node3);\n+        assertEquals(1, edges.size());\n+        assertEquals(_edge3, edges.iterator().next());\n+        edges = _graph.getEdges(_node3, _node1);\n+        assertEquals(1, edges.size());\n+        assertEquals(_edge3, edges.iterator().next());\n+\n+        edges = _graph.getEdgesFrom(_node2);\n+        assertEquals(2, edges.size());\n+        itr = edges.iterator();\n+        edge0 = (Edge) itr.next();\n+        edge1 = (Edge) itr.next();\n+        assertTrue((edge0 == _edge2 && edge1 == _edge4)\n+            || (edge0 == _edge4 && edge1 == _edge2));\n+\n+        edges = _graph.getEdgesTo(_node2);\n+        assertEquals(2, edges.size());\n+        itr = edges.iterator();\n+        edge0 = (Edge) itr.next();\n+        edge1 = (Edge) itr.next();\n+        assertTrue((edge0 == _edge1 && edge1 == _edge4)\n+            || (edge0 == _edge4 && edge1 == _edge1));\n+\n+        edges = _graph.getEdges(_node2, _node2);\n+        assertEquals(1, edges.size());\n+        assertEquals(_edge4, edges.iterator().next());\n+\n+        edges = _graph.getEdgesFrom(_node3);\n+        assertEquals(1, edges.size());\n+        assertEquals(_edge3, edges.iterator().next());\n+    }\n+\n+    /**\n+     * Test removing edges.\n+     */\n+    public void testRemoveEdges() {\n+        assertTrue(_graph.removeEdge(_edge2));\n+        Collection edges = _graph.getEdgesFrom(_node2);\n+        assertEquals(1, edges.size());\n+        assertEquals(_edge4, edges.iterator().next());\n+\n+        assertTrue(_graph.removeEdge(_edge3));\n+        edges = _graph.getEdgesFrom(_node1);\n+        assertEquals(1, edges.size());\n+        assertEquals(_edge1, edges.iterator().next());\n+        edges = _graph.getEdgesTo(_node1);\n+        assertEquals(0, edges.size());\n+        edges = _graph.getEdgesTo(_node3);\n+        assertEquals(0, edges.size());\n+        edges = _graph.getEdgesFrom(_node3);\n+        assertEquals(0, edges.size());\n+    }\n+\n+    /**\n+     * Test removing nodes.\n+     */\n+    public void testRemoveNodes() {\n+        assertTrue(_graph.removeNode(_node3));\n+        Collection edges = _graph.getEdges();\n+        assertEquals(2, edges.size());\n+        Iterator itr = edges.iterator();\n+        Edge edge0 = (Edge) itr.next();\n+        Edge edge1 = (Edge) itr.next();\n+        assertTrue((edge0 == _edge1 && edge1 == _edge4)\n+            || (edge0 == _edge4 && edge1 == _edge1));\n+        edges = _graph.getEdgesFrom(_node1);\n+        assertEquals(1, edges.size());\n+        assertEquals(_edge1, edges.iterator().next());\n+        edges = _graph.getEdgesTo(_node1);\n+        assertEquals(0, edges.size());\n+    }\n+\n+    public static void main(String[] args) {\n+        main(TestGraph.class);\n+\t}\n+}"},{"sha":"915580982cc4ee4541b8212d33d8f51c2dc50ee5","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/ResultListTest.java","status":"modified","additions":23,"deletions":0,"changes":23,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/ResultListTest.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/ResultListTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/ResultListTest.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -37,9 +37,16 @@\n \n     private ResultList[] _lists = null;\n \n+    protected boolean subListSupported = false;\n+    \n     public ResultListTest(String test) {\n         super(test);\n     }\n+    \n+    public ResultListTest(String test, boolean supportSubList) {\n+        super(test);\n+        subListSupported = supportSubList;\n+    }\n \n     /**\n      * Return a result list to use with the given provider.\n@@ -269,4 +276,20 @@ public void testEmpty() {\n             assertTrue(list.isEmpty());\n         }\n     }\n+\n+    public void testSubList() {\n+        ResultObjectProvider[] rops = getResultObjectProviders\n+            (Collections.EMPTY_LIST);\n+        for (int i = 0; i < rops.length; i++) {\n+            ResultList list = getResultList(rops[i]);\n+            try {\n+                List subList = list.subList(0, 0);\n+                if (subListSupported == false)\n+                    fail(\"Should not support subList.\");\n+            } catch (UnsupportedOperationException e) {\n+                if (subListSupported == true)\n+                    fail(\"Should support subList.\");\n+            }\n+        }\n+    }\n }"},{"sha":"6e4e22262401ae2aa18c3b69908ddb0416947e71","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestEagerResultList.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestEagerResultList.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestEagerResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestEagerResultList.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -26,7 +26,7 @@\n public class TestEagerResultList extends ResultListTest {\n \n     public TestEagerResultList(String test) {\n-        super(test);\n+        super(test, true);\n     }\n \n     protected ResultList getResultList(ResultObjectProvider provider) {"},{"sha":"3eb648417cccb91befee06426985b1f0904872f6","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestLazyForwardResultList.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestLazyForwardResultList.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestLazyForwardResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestLazyForwardResultList.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -26,7 +26,7 @@\n public class TestLazyForwardResultList extends ResultListTest {\n \n     public TestLazyForwardResultList(String test) {\n-        super(test);\n+        super(test, true);\n     }\n \n     protected ResultList getResultList(ResultObjectProvider provider) {"},{"sha":"41e4de4d671d11f19537f5f617eab1e12f8e8cc5","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestListResultList.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestListResultList.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestListResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestListResultList.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -26,7 +26,7 @@\n public class TestListResultList extends ResultListTest {\n \n     public TestListResultList(String test) {\n-        super(test);\n+        super(test, true);\n     }\n \n     protected ResultList getResultList(ResultObjectProvider provider) {"},{"sha":"fb440e74af504743de2b0c79803d7c32fe8659e6","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","status":"modified","additions":1562,"deletions":1562,"changes":3124,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"6110d8e41c3e69050541117f7e8875b1b8f9e1f1","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","status":"modified","additions":400,"deletions":400,"changes":800,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,400 +1,400 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.lib.util;\r\n-\r\n-import java.io.BufferedInputStream;\r\n-import java.io.BufferedReader;\r\n-import java.io.ByteArrayInputStream;\r\n-import java.io.ByteArrayOutputStream;\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.InputStreamReader;\r\n-import java.io.ObjectInputStream;\r\n-import java.io.ObjectOutputStream;\r\n-import java.io.StringBufferInputStream;\r\n-import java.util.ArrayList;\r\n-import java.util.Arrays;\r\n-import java.util.List;\r\n-import java.util.Properties;\r\n-\r\n-import junit.framework.TestCase;\r\n-import org.apache.openjpa.lib.util.FormatPreservingProperties.DuplicateKeyException;\r\n-\r\n-// things to test:\r\n-// - delimiters in keys\r\n-// - escape chars, including \\:, \\= in files(as generated by Properties)\r\n-// - unicode\r\n-// - non-String keys / vals\r\n-// - list() method behavior\r\n-\r\n-public class TestPropertiesParser extends TestCase {\r\n-\r\n-    private static final String LS = System.getProperty( \"line.separator\" );\r\n-\r\n-    public void testSimpleProperties() throws IOException {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        buf.append(\"key: value\" + LS);\r\n-        buf.append(\"key2: value2\"); // no EOL -- this is intentional\r\n-        Properties p = toProperties(buf.toString());\r\n-        assertProperties(new String[][]{\r\n-            { \"key\", \"value\" }, { \"key2\", \"value2\" } }, p);\r\n-    }\r\n-\r\n-    public void testComments() throws IOException {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        buf.append(\"# this is a comment\" + LS);\r\n-        buf.append(\" # another one, with leading whitespace\t\" + LS);\r\n-        buf.append(\" \t# \tand more with interesting whitespace\t\" + LS);\r\n-        buf.append(\"! and with a ! delimiter\" + LS);\r\n-        buf.append(\"! and with escape \\t chars\" + LS);\r\n-        buf.append(\"#and a comment with no whitespace\" + LS);\r\n-        Properties p = toProperties(buf.toString());\r\n-        assertEquals(0, p.size());\r\n-    }\r\n-\r\n-    public void testMixedContent() throws IOException {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        buf.append(\"# this is a comment\" + LS);\r\n-        buf.append(\" # another one, with leading whitespace\t\" + LS);\r\n-        buf.append(\"foo: bar#baz\" + LS);\r\n-        buf.append(\"! and with a ! delimiter\" + LS);\r\n-        buf.append(\"! and with escape \\t chars\" + LS);\r\n-        Properties p = toProperties(buf.toString());\r\n-        assertProperties(new String[][]{ { \"foo\", \"bar#baz\" } }, p);\r\n-    }\r\n-\r\n-    public void testMultiLineInput() throws IOException {\r\n-        String s = \"foo: bar\\\\\" + LS + \"more line goes here\";\r\n-        Properties p = toProperties(s);\r\n-        assertProperties(\r\n-            new String[][]{ { \"foo\", \"barmore line goes here\" } }, p);\r\n-    }\r\n-\r\n-    public void testEmptyLines() throws IOException {\r\n-        Properties p = toProperties(LS + \"foo: bar\" + LS + LS + \"baz: val\");\r\n-        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\r\n-            p);\r\n-    }\r\n-\r\n-    public void testAddProperties() throws IOException {\r\n-        // intentionally left out the trailing end line\r\n-        String s = \"foo: bar\" + LS + \"baz: val\";\r\n-        Properties p = toProperties(s);\r\n-        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\r\n-            p);\r\n-\r\n-        p.put(\"new-key\", \"val1\");\r\n-        p.put(\"new-key-2\", \"val2\");\r\n-        p.put(\"another-new-key\", \"val3\");\r\n-        assertRoundTrip(s + LS + \"new-key: val1\" + LS + \"new-key-2: val2\" + LS +\r\n-            \"another-new-key: val3\" + LS, p);\r\n-    }\r\n-\r\n-    public void testAddAndMutateProperties() throws IOException {\r\n-        // intentionally left out the trailing end line\r\n-        Properties p = toProperties(\"foo: bar\" + LS + \"baz: val\");\r\n-        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\r\n-            p);\r\n-\r\n-        p.put(\"new-key\", \"new value\");\r\n-        p.put(\"foo\", \"barbar\");\r\n-        assertRoundTrip(\"foo: barbar\" + LS + \"baz: val\" + LS \r\n-            + \"new-key: new value\" + LS, p);\r\n-    }\r\n-\r\n-    public void testEscapedEquals() throws IOException {\r\n-        Properties p = toProperties(\"foo=bar\\\\=WARN,baz\\\\=TRACE\");\r\n-        assertProperties(new String[][]{ { \"foo\", \"bar=WARN,baz=TRACE\" } }, p);\r\n-    }\r\n-\r\n-    public void testLineTypes() throws IOException {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        buf.append(\"   !comment\" + LS + \" \\t  \" + LS + \"name = no\" + LS + \"    \"\r\n-            + \"#morec\\tomm\\\\\" + LS + \"ents\" + LS + LS + \"  dog=no\\\\cat   \" + LS \r\n-            + \"burps    :\" + LS + \"test=\" + LS + \"date today\" + LS + LS + LS \r\n-            + \"long\\\\\" + LS + \"   value=tryin \\\\\" + LS + \" \"\r\n-            + \"gto\" + LS + \"4:vier\" + LS + \"vier     :4\");\r\n-        Properties p = toProperties(buf.toString());\r\n-        assertProperties(new String[][]{\r\n-            { \"name\", \"no\" }, { \"ents\", \"\" }, { \"dog\", \"nocat   \" },\r\n-            { \"burps\", \"\" }, { \"test\", \"\" }, { \"date\", \"today\" },\r\n-            { \"longvalue\", \"tryin gto\" }, { \"4\", \"vier\" }, { \"vier\", \"4\" },\r\n-        }, p);\r\n-    }\r\n-\r\n-    public void testSpecialChars() throws Throwable {\r\n-        testSpecialChars(false, true);\r\n-        testSpecialChars(true, true);\r\n-        testSpecialChars(false, false);\r\n-        testSpecialChars(true, false);\r\n-    }\r\n-\r\n-    /**\r\n-     * Test that special characters work.\r\n-     *\r\n-     * @param formattingProps if true, test against the\r\n-     * FormatPreservingProperties, otherwise test\r\n-     * against a normal Properties instance(for validation of the test case).\r\n-     * @param value whether to test the key or the value\r\n-     */\r\n-    public void testSpecialChars(boolean formattingProps, boolean value)\r\n-        throws Throwable {\r\n-        List valueList = new ArrayList(Arrays.asList(new String[]{\r\n-            \"xxyy\", \"xx\\\\yy\", \"xx\" + LS + \"yy\", \"xx\\\\nyy\", \"xx\\tyy\", \"xx\\\\tyy\",\r\n-            \"xx\\ryy\", \"xx\\\\ryy\", \"xx\\fyy\", \"xx\\\\fyy\", \"xx\\r\" + LS + \"\\\\\\t\\r\\t\" \r\n-            + LS + \"yy\",\r\n-            \"xx\\\\r\" + LS + \"\\\\\\t\\\\r\\t\\\\nyy\",\r\n-            \"xx\\r\" + LS + \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\t\\r\\t\" + LS + \"yy\",\r\n-            \"C:\\\\Program Files\\\\Some Application\\\\OpenJPA\\\\My File.dat\", }));\r\n-\r\n-        // also store every individual character\r\n-        for (char c = 'a'; c < 'Z'; c++) {\r\n-            valueList.add(new String(new char[]{ c }));\r\n-            valueList.add(new String(new char[]{ c, '\\\\', c }));\r\n-            valueList.add(new String(new char[]{ '\\\\', c }));\r\n-        }\r\n-\r\n-        String[] values = (String[]) valueList.toArray(new String[0]);\r\n-\r\n-        final String dummy = \"XXX\";\r\n-\r\n-        for (int i = 0; i < values.length; i++) {\r\n-            // test special characters in either keys or values\r\n-            String val = value ? values[i] : dummy;\r\n-            String key = value ? dummy : values[i];\r\n-\r\n-            Properties p = formattingProps ?\r\n-                new FormatPreservingProperties() : new Properties();\r\n-            if (p instanceof FormatPreservingProperties) {\r\n-                // set these properties so we behave the same way as\r\n-                // java.util.Properties\r\n-                ((FormatPreservingProperties) p).setDefaultEntryDelimiter('=');\r\n-                ((FormatPreservingProperties) p).\r\n-                    setAddWhitespaceAfterDelimiter(false);\r\n-            }\r\n-\r\n-            p.setProperty(key, val);\r\n-            ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n-            p.store(out, null);\r\n-\r\n-            Properties copy = new Properties();\r\n-            copy.setProperty(key, val);\r\n-            ByteArrayOutputStream copyOut = new ByteArrayOutputStream();\r\n-            copy.store(copyOut, null);\r\n-\r\n-            p = formattingProps ?\r\n-                new FormatPreservingProperties() : new Properties();\r\n-\r\n-            InputStream in = new BufferedInputStream\r\n-                (new ByteArrayInputStream(out.toByteArray()));\r\n-\r\n-            try {\r\n-                // make sure that the 2 properties serialized are the same\r\n-                String copyOutString = stripComments(copyOut.toByteArray());\r\n-                String outString = stripComments(out.toByteArray());\r\n-                assertEquals(copyOutString, outString);\r\n-\r\n-                p.load(in);\r\n-\r\n-                assertNotNull(\"Property \\\"\" + key + \"\\\" was null\",\r\n-                    p.getProperty(key));\r\n-                assertEquals(val.trim(), p.getProperty(key).trim());\r\n-            } catch (Throwable ioe) {\r\n-                if (!formattingProps)\r\n-                    throw ioe;\r\n-\r\n-                // bug(1211, ioe,\r\n-                // \"Cannot store backslash in FormatPreservingProperties\");\r\n-                throw ioe;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    static Character randomChar() {\r\n-        char [] TEST_CHAR_ARRAY = new char []{\r\n-            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\r\n-            'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\r\n-            's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '1',\r\n-            '2', '3', '4', '5', '6', '7', '8', '9' };\r\n-\r\n-        return new Character(TEST_CHAR_ARRAY[\r\n-            (int) (Math.random() * TEST_CHAR_ARRAY.length)]);\r\n-    }\r\n-\r\n-    static String randomString(int len) {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        for (int i = 0; i < (int) (Math.random() * len) + 1; i++)\r\n-            buf.append(randomChar());\r\n-        return buf.toString();\r\n-    }\r\n-\r\n-    public void testEquivalentStore() throws IOException {\r\n-        Properties p1 = new Properties();\r\n-        FormatPreservingProperties p2 = new FormatPreservingProperties();\r\n-\r\n-        ((FormatPreservingProperties) p2).setDefaultEntryDelimiter('=');\r\n-        ((FormatPreservingProperties) p2).setAddWhitespaceAfterDelimiter(false);\r\n-\r\n-        String[] values =\r\n-            new String[] { \r\n-                \"x\", \r\n-                \"x\" + LS + \"y\", \r\n-                \"x\\\\ny\", \r\n-                \"x\\ty\", \r\n-                \"x\\\\ty\",\r\n-                \"x\\fy\", \r\n-                \"x\\\\fy\", \r\n-                \"x\\ry\", \r\n-                \"x\\\\ry\", \r\n-                \"C:\\\\Foo Bar\\\\Baz\",\r\n-                randomString(5).replace('a', '\\\\'),\r\n-                randomString(500).replace('a', '\\\\'),\r\n-                randomString(5000).replace('a', '\\\\'), \r\n-                };\r\n-\r\n-        for (int i = 0; i < values.length; i++) {\r\n-            p1.clear();\r\n-            p2.clear();\r\n-\r\n-            p1.setProperty(\"xxx\", values[i]);\r\n-            p2.setProperty(\"xxx\", values[i]);\r\n-\r\n-            ByteArrayOutputStream out1 = new ByteArrayOutputStream();\r\n-            ByteArrayOutputStream out2 = new ByteArrayOutputStream();\r\n-\r\n-            p1.store(out1, null);\r\n-            p2.store(out2, null);\r\n-\r\n-            String s1 = new String(out1.toByteArray());\r\n-            String s2 = new String(out2.toByteArray());\r\n-\r\n-            assertTrue(\"Expected <\" + s1 + \"> but was <\" + s2 + \">\",\r\n-                s1.indexOf(s2) != -1);\r\n-        }\r\n-    }\r\n-\r\n-    static String stripComments(byte[] bytes) throws IOException {\r\n-        BufferedReader reader = new BufferedReader(new InputStreamReader\r\n-            (new ByteArrayInputStream(bytes)));\r\n-        StringBuffer sbuf = new StringBuffer();\r\n-        String line;\r\n-        while ((line = reader.readLine()) != null) {\r\n-            // skip comments\r\n-            if (line.trim().startsWith(\"#\"))\r\n-                continue;\r\n-\r\n-            sbuf.append(line);\r\n-            sbuf.append(LS);\r\n-        }\r\n-\r\n-        return sbuf.toString();\r\n-    }\r\n-\r\n-    public void testDuplicateProperties() throws IOException {\r\n-        FormatPreservingProperties p = new FormatPreservingProperties();\r\n-        try {\r\n-            toProperties(\"foo=bar\" + LS + \"foo=baz\", p);\r\n-            fail(\"expected duplicate keys to cause exception\");\r\n-        } catch (DuplicateKeyException e) {\r\n-            // expected\r\n-        }\r\n-\r\n-        // now test the expected behavior when duplicates are allowed.\r\n-        p = new FormatPreservingProperties();\r\n-        p.setAllowDuplicates(true);\r\n-        toProperties(\"foo=bar\" + LS + \"foo=baz\", p);\r\n-        assertProperties(new String[][]{ { \"foo\", \"baz\" } }, p);\r\n-    }\r\n-\r\n-    public void testMultipleLoads() throws IOException {\r\n-        String props = \"foo=bar\" + LS + \"baz=quux\";\r\n-        String props2 = \"a=b\" + LS + \"c=d\";\r\n-        Properties vanilla = new Properties();\r\n-        vanilla.load(new BufferedInputStream\r\n-            (new StringBufferInputStream(props)));\r\n-        vanilla.load(new BufferedInputStream\r\n-            (new StringBufferInputStream(props2)));\r\n-\r\n-        Properties p = new FormatPreservingProperties();\r\n-        p.load(new BufferedInputStream(new StringBufferInputStream(props)));\r\n-        p.load(new BufferedInputStream(new StringBufferInputStream(props2)));\r\n-        assertPropertiesSame(vanilla, p);\r\n-    }\r\n-\r\n-    protected FormatPreservingProperties toProperties(String s)\r\n-        throws IOException {\r\n-        return toProperties(s, new FormatPreservingProperties());\r\n-    }\r\n-\r\n-    protected FormatPreservingProperties toProperties(String s,\r\n-        FormatPreservingProperties p) throws IOException {\r\n-        Properties vanilla = new Properties();\r\n-        vanilla.load(new StringBufferInputStream(s));\r\n-\r\n-        p.load(new StringBufferInputStream(s));\r\n-        assertRoundTrip(s, p);\r\n-\r\n-        assertPropertiesSame(vanilla, p);\r\n-\r\n-        return p;\r\n-    }\r\n-\r\n-    private void assertRoundTrip(String s, Properties p) throws IOException {\r\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n-        p.store(out, null);\r\n-        assertEquals(s, out.toString());\r\n-\r\n-        // also check serializable\r\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\r\n-        new ObjectOutputStream(bout).writeObject(p);\r\n-\r\n-        try {\r\n-            FormatPreservingProperties deserialized =\r\n-                (FormatPreservingProperties) new ObjectInputStream\r\n-                    (new ByteArrayInputStream(bout.toByteArray())).\r\n-                    readObject();\r\n-            assertEquals(p, deserialized);\r\n-\r\n-            out = new ByteArrayOutputStream();\r\n-            deserialized.store(out, null);\r\n-            assertEquals(s, out.toString());\r\n-        } catch (ClassNotFoundException cnfe) {\r\n-            fail(cnfe + \"\");\r\n-        }\r\n-    }\r\n-\r\n-    public static void assertEquals(String expected, String actual) {\r\n-        if (expected == actual)\r\n-            return;\r\n-\r\n-        if (expected == null || !expected.equals(actual))\r\n-            fail(\"Expected <\" + expected + \"> but was <\" + actual + \">\");\r\n-    }\r\n-\r\n-    private void assertPropertiesSame(Properties vanilla, Properties p) {\r\n-        assertEquals(vanilla, p);\r\n-    }\r\n-\r\n-    protected void assertProperties(String[][] strings, Properties p) {\r\n-        for (int i = 0; i < strings.length; i++)\r\n-            assertEquals(strings[i][1], p.get(strings[i][0]));\r\n-\r\n-        assertEquals(strings.length, p.size());\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.lib.util;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.StringBufferInputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import junit.framework.TestCase;\n+import org.apache.openjpa.lib.util.FormatPreservingProperties.DuplicateKeyException;\n+\n+// things to test:\n+// - delimiters in keys\n+// - escape chars, including \\:, \\= in files(as generated by Properties)\n+// - unicode\n+// - non-String keys / vals\n+// - list() method behavior\n+\n+public class TestPropertiesParser extends TestCase {\n+\n+    private static final String LS = System.getProperty( \"line.separator\" );\n+\n+    public void testSimpleProperties() throws IOException {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"key: value\" + LS);\n+        buf.append(\"key2: value2\"); // no EOL -- this is intentional\n+        Properties p = toProperties(buf.toString());\n+        assertProperties(new String[][]{\n+            { \"key\", \"value\" }, { \"key2\", \"value2\" } }, p);\n+    }\n+\n+    public void testComments() throws IOException {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"# this is a comment\" + LS);\n+        buf.append(\" # another one, with leading whitespace\t\" + LS);\n+        buf.append(\" \t# \tand more with interesting whitespace\t\" + LS);\n+        buf.append(\"! and with a ! delimiter\" + LS);\n+        buf.append(\"! and with escape \\t chars\" + LS);\n+        buf.append(\"#and a comment with no whitespace\" + LS);\n+        Properties p = toProperties(buf.toString());\n+        assertEquals(0, p.size());\n+    }\n+\n+    public void testMixedContent() throws IOException {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"# this is a comment\" + LS);\n+        buf.append(\" # another one, with leading whitespace\t\" + LS);\n+        buf.append(\"foo: bar#baz\" + LS);\n+        buf.append(\"! and with a ! delimiter\" + LS);\n+        buf.append(\"! and with escape \\t chars\" + LS);\n+        Properties p = toProperties(buf.toString());\n+        assertProperties(new String[][]{ { \"foo\", \"bar#baz\" } }, p);\n+    }\n+\n+    public void testMultiLineInput() throws IOException {\n+        String s = \"foo: bar\\\\\" + LS + \"more line goes here\";\n+        Properties p = toProperties(s);\n+        assertProperties(\n+            new String[][]{ { \"foo\", \"barmore line goes here\" } }, p);\n+    }\n+\n+    public void testEmptyLines() throws IOException {\n+        Properties p = toProperties(LS + \"foo: bar\" + LS + LS + \"baz: val\");\n+        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\n+            p);\n+    }\n+\n+    public void testAddProperties() throws IOException {\n+        // intentionally left out the trailing end line\n+        String s = \"foo: bar\" + LS + \"baz: val\";\n+        Properties p = toProperties(s);\n+        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\n+            p);\n+\n+        p.put(\"new-key\", \"val1\");\n+        p.put(\"new-key-2\", \"val2\");\n+        p.put(\"another-new-key\", \"val3\");\n+        assertRoundTrip(s + LS + \"new-key: val1\" + LS + \"new-key-2: val2\" + LS +\n+            \"another-new-key: val3\" + LS, p);\n+    }\n+\n+    public void testAddAndMutateProperties() throws IOException {\n+        // intentionally left out the trailing end line\n+        Properties p = toProperties(\"foo: bar\" + LS + \"baz: val\");\n+        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\n+            p);\n+\n+        p.put(\"new-key\", \"new value\");\n+        p.put(\"foo\", \"barbar\");\n+        assertRoundTrip(\"foo: barbar\" + LS + \"baz: val\" + LS \n+            + \"new-key: new value\" + LS, p);\n+    }\n+\n+    public void testEscapedEquals() throws IOException {\n+        Properties p = toProperties(\"foo=bar\\\\=WARN,baz\\\\=TRACE\");\n+        assertProperties(new String[][]{ { \"foo\", \"bar=WARN,baz=TRACE\" } }, p);\n+    }\n+\n+    public void testLineTypes() throws IOException {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"   !comment\" + LS + \" \\t  \" + LS + \"name = no\" + LS + \"    \"\n+            + \"#morec\\tomm\\\\\" + LS + \"ents\" + LS + LS + \"  dog=no\\\\cat   \" + LS \n+            + \"burps    :\" + LS + \"test=\" + LS + \"date today\" + LS + LS + LS \n+            + \"long\\\\\" + LS + \"   value=tryin \\\\\" + LS + \" \"\n+            + \"gto\" + LS + \"4:vier\" + LS + \"vier     :4\");\n+        Properties p = toProperties(buf.toString());\n+        assertProperties(new String[][]{\n+            { \"name\", \"no\" }, { \"ents\", \"\" }, { \"dog\", \"nocat   \" },\n+            { \"burps\", \"\" }, { \"test\", \"\" }, { \"date\", \"today\" },\n+            { \"longvalue\", \"tryin gto\" }, { \"4\", \"vier\" }, { \"vier\", \"4\" },\n+        }, p);\n+    }\n+\n+    public void testSpecialChars() throws Throwable {\n+        testSpecialChars(false, true);\n+        testSpecialChars(true, true);\n+        testSpecialChars(false, false);\n+        testSpecialChars(true, false);\n+    }\n+\n+    /**\n+     * Test that special characters work.\n+     *\n+     * @param formattingProps if true, test against the\n+     * FormatPreservingProperties, otherwise test\n+     * against a normal Properties instance(for validation of the test case).\n+     * @param value whether to test the key or the value\n+     */\n+    public void testSpecialChars(boolean formattingProps, boolean value)\n+        throws Throwable {\n+        List valueList = new ArrayList(Arrays.asList(new String[]{\n+            \"xxyy\", \"xx\\\\yy\", \"xx\" + LS + \"yy\", \"xx\\\\nyy\", \"xx\\tyy\", \"xx\\\\tyy\",\n+            \"xx\\ryy\", \"xx\\\\ryy\", \"xx\\fyy\", \"xx\\\\fyy\", \"xx\\r\" + LS + \"\\\\\\t\\r\\t\" \n+            + LS + \"yy\",\n+            \"xx\\\\r\" + LS + \"\\\\\\t\\\\r\\t\\\\nyy\",\n+            \"xx\\r\" + LS + \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\t\\r\\t\" + LS + \"yy\",\n+            \"C:\\\\Program Files\\\\Some Application\\\\OpenJPA\\\\My File.dat\", }));\n+\n+        // also store every individual character\n+        for (char c = 'a'; c < 'Z'; c++) {\n+            valueList.add(new String(new char[]{ c }));\n+            valueList.add(new String(new char[]{ c, '\\\\', c }));\n+            valueList.add(new String(new char[]{ '\\\\', c }));\n+        }\n+\n+        String[] values = (String[]) valueList.toArray(new String[0]);\n+\n+        final String dummy = \"XXX\";\n+\n+        for (int i = 0; i < values.length; i++) {\n+            // test special characters in either keys or values\n+            String val = value ? values[i] : dummy;\n+            String key = value ? dummy : values[i];\n+\n+            Properties p = formattingProps ?\n+                new FormatPreservingProperties() : new Properties();\n+            if (p instanceof FormatPreservingProperties) {\n+                // set these properties so we behave the same way as\n+                // java.util.Properties\n+                ((FormatPreservingProperties) p).setDefaultEntryDelimiter('=');\n+                ((FormatPreservingProperties) p).\n+                    setAddWhitespaceAfterDelimiter(false);\n+            }\n+\n+            p.setProperty(key, val);\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            p.store(out, null);\n+\n+            Properties copy = new Properties();\n+            copy.setProperty(key, val);\n+            ByteArrayOutputStream copyOut = new ByteArrayOutputStream();\n+            copy.store(copyOut, null);\n+\n+            p = formattingProps ?\n+                new FormatPreservingProperties() : new Properties();\n+\n+            InputStream in = new BufferedInputStream\n+                (new ByteArrayInputStream(out.toByteArray()));\n+\n+            try {\n+                // make sure that the 2 properties serialized are the same\n+                String copyOutString = stripComments(copyOut.toByteArray());\n+                String outString = stripComments(out.toByteArray());\n+                assertEquals(copyOutString, outString);\n+\n+                p.load(in);\n+\n+                assertNotNull(\"Property \\\"\" + key + \"\\\" was null\",\n+                    p.getProperty(key));\n+                assertEquals(val.trim(), p.getProperty(key).trim());\n+            } catch (Throwable ioe) {\n+                if (!formattingProps)\n+                    throw ioe;\n+\n+                // bug(1211, ioe,\n+                // \"Cannot store backslash in FormatPreservingProperties\");\n+                throw ioe;\n+            }\n+        }\n+    }\n+\n+    static Character randomChar() {\n+        char [] TEST_CHAR_ARRAY = new char []{\n+            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\n+            'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\n+            's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '1',\n+            '2', '3', '4', '5', '6', '7', '8', '9' };\n+\n+        return new Character(TEST_CHAR_ARRAY[\n+            (int) (Math.random() * TEST_CHAR_ARRAY.length)]);\n+    }\n+\n+    static String randomString(int len) {\n+        StringBuffer buf = new StringBuffer();\n+        for (int i = 0; i < (int) (Math.random() * len) + 1; i++)\n+            buf.append(randomChar());\n+        return buf.toString();\n+    }\n+\n+    public void testEquivalentStore() throws IOException {\n+        Properties p1 = new Properties();\n+        FormatPreservingProperties p2 = new FormatPreservingProperties();\n+\n+        ((FormatPreservingProperties) p2).setDefaultEntryDelimiter('=');\n+        ((FormatPreservingProperties) p2).setAddWhitespaceAfterDelimiter(false);\n+\n+        String[] values =\n+            new String[] { \n+                \"x\", \n+                \"x\" + LS + \"y\", \n+                \"x\\\\ny\", \n+                \"x\\ty\", \n+                \"x\\\\ty\",\n+                \"x\\fy\", \n+                \"x\\\\fy\", \n+                \"x\\ry\", \n+                \"x\\\\ry\", \n+                \"C:\\\\Foo Bar\\\\Baz\",\n+                randomString(5).replace('a', '\\\\'),\n+                randomString(500).replace('a', '\\\\'),\n+                randomString(5000).replace('a', '\\\\'), \n+                };\n+\n+        for (int i = 0; i < values.length; i++) {\n+            p1.clear();\n+            p2.clear();\n+\n+            p1.setProperty(\"xxx\", values[i]);\n+            p2.setProperty(\"xxx\", values[i]);\n+\n+            ByteArrayOutputStream out1 = new ByteArrayOutputStream();\n+            ByteArrayOutputStream out2 = new ByteArrayOutputStream();\n+\n+            p1.store(out1, null);\n+            p2.store(out2, null);\n+\n+            String s1 = new String(out1.toByteArray());\n+            String s2 = new String(out2.toByteArray());\n+\n+            assertTrue(\"Expected <\" + s1 + \"> but was <\" + s2 + \">\",\n+                s1.indexOf(s2) != -1);\n+        }\n+    }\n+\n+    static String stripComments(byte[] bytes) throws IOException {\n+        BufferedReader reader = new BufferedReader(new InputStreamReader\n+            (new ByteArrayInputStream(bytes)));\n+        StringBuffer sbuf = new StringBuffer();\n+        String line;\n+        while ((line = reader.readLine()) != null) {\n+            // skip comments\n+            if (line.trim().startsWith(\"#\"))\n+                continue;\n+\n+            sbuf.append(line);\n+            sbuf.append(LS);\n+        }\n+\n+        return sbuf.toString();\n+    }\n+\n+    public void testDuplicateProperties() throws IOException {\n+        FormatPreservingProperties p = new FormatPreservingProperties();\n+        try {\n+            toProperties(\"foo=bar\" + LS + \"foo=baz\", p);\n+            fail(\"expected duplicate keys to cause exception\");\n+        } catch (DuplicateKeyException e) {\n+            // expected\n+        }\n+\n+        // now test the expected behavior when duplicates are allowed.\n+        p = new FormatPreservingProperties();\n+        p.setAllowDuplicates(true);\n+        toProperties(\"foo=bar\" + LS + \"foo=baz\", p);\n+        assertProperties(new String[][]{ { \"foo\", \"baz\" } }, p);\n+    }\n+\n+    public void testMultipleLoads() throws IOException {\n+        String props = \"foo=bar\" + LS + \"baz=quux\";\n+        String props2 = \"a=b\" + LS + \"c=d\";\n+        Properties vanilla = new Properties();\n+        vanilla.load(new BufferedInputStream\n+            (new StringBufferInputStream(props)));\n+        vanilla.load(new BufferedInputStream\n+            (new StringBufferInputStream(props2)));\n+\n+        Properties p = new FormatPreservingProperties();\n+        p.load(new BufferedInputStream(new StringBufferInputStream(props)));\n+        p.load(new BufferedInputStream(new StringBufferInputStream(props2)));\n+        assertPropertiesSame(vanilla, p);\n+    }\n+\n+    protected FormatPreservingProperties toProperties(String s)\n+        throws IOException {\n+        return toProperties(s, new FormatPreservingProperties());\n+    }\n+\n+    protected FormatPreservingProperties toProperties(String s,\n+        FormatPreservingProperties p) throws IOException {\n+        Properties vanilla = new Properties();\n+        vanilla.load(new StringBufferInputStream(s));\n+\n+        p.load(new StringBufferInputStream(s));\n+        assertRoundTrip(s, p);\n+\n+        assertPropertiesSame(vanilla, p);\n+\n+        return p;\n+    }\n+\n+    private void assertRoundTrip(String s, Properties p) throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        p.store(out, null);\n+        assertEquals(s, out.toString());\n+\n+        // also check serializable\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        new ObjectOutputStream(bout).writeObject(p);\n+\n+        try {\n+            FormatPreservingProperties deserialized =\n+                (FormatPreservingProperties) new ObjectInputStream\n+                    (new ByteArrayInputStream(bout.toByteArray())).\n+                    readObject();\n+            assertEquals(p, deserialized);\n+\n+            out = new ByteArrayOutputStream();\n+            deserialized.store(out, null);\n+            assertEquals(s, out.toString());\n+        } catch (ClassNotFoundException cnfe) {\n+            fail(cnfe + \"\");\n+        }\n+    }\n+\n+    public static void assertEquals(String expected, String actual) {\n+        if (expected == actual)\n+            return;\n+\n+        if (expected == null || !expected.equals(actual))\n+            fail(\"Expected <\" + expected + \"> but was <\" + actual + \">\");\n+    }\n+\n+    private void assertPropertiesSame(Properties vanilla, Properties p) {\n+        assertEquals(vanilla, p);\n+    }\n+\n+    protected void assertProperties(String[][] strings, Properties p) {\n+        for (int i = 0; i < strings.length; i++)\n+            assertEquals(strings[i][1], p.get(strings[i][0]));\n+\n+        assertEquals(strings.length, p.size());\n+    }\n+}"},{"sha":"bfdd95b5e02499e1f83b67d4f95a35b6061bfae5","filename":"openjpa-persistence-jdbc/pom.xml","status":"modified","additions":266,"deletions":206,"changes":472,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/pom.xml?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -31,10 +31,21 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-parent</artifactId>\n-        <version>1.0.3</version>\n+        <version>1.0.4</version>\n     </parent>\n     <properties>\n-        <openjpa.loglevel>INFO</openjpa.loglevel>\n+        <openjpa.Log>DefaultLevel=INFO</openjpa.Log>\n+        <!-- to set debug arguments, you might set the following at the command line:\n+            -Dtest.jvm.arguments=\"-Xmx500m -agentlib:jdwp=transport=dt_socket,server=y,address=8000\"\n+        -->\n+        <test.jvm.arguments>-Xmx500m</test.jvm.arguments>\n+        <dbcp.maxActive>10</dbcp.maxActive>\n+        <dbcp.maxIdle>5</dbcp.maxIdle>\n+        <dbcp.minIdle>2</dbcp.minIdle>\n+        <dbcp.maxWait>10000</dbcp.maxWait>\n+        <dbcp.args>MaxActive=${dbcp.maxActive},MaxIdle=${dbcp.maxIdle},MinIdle=${dbcp.minIdle},MaxWait=${dbcp.maxWait}</dbcp.args>\n+        <derby.locks.waitTimeout>6</derby.locks.waitTimeout>        \n+        <derby.locks.deadlockTimeout>5</derby.locks.deadlockTimeout>\n     </properties>\n     <profiles>\n \n@@ -49,45 +60,18 @@\n                 <dependency>\n                     <groupId>org.apache.derby</groupId>\n                     <artifactId>derby</artifactId>\n-                    <version>10.2.2.0</version>\n                     <scope>test</scope>\n+                    <version>10.2.2.0</version>\n                 </dependency>\n             </dependencies>\n-\n-            <build>\n-                <pluginManagement>\n-                    <plugins>\n-                        <plugin>\n-                            <groupId>org.apache.maven.plugins</groupId>\n-                            <artifactId>maven-surefire-plugin</artifactId>\n-                            <configuration>\n-                                <argLine>-Xmx500m</argLine>\n-                                <systemProperties>\n-                                    <property>\n-                                        <name>openjpa.Log</name>\n-                                        <value>DefaultLevel=${openjpa.loglevel}</value>\n-                                    </property>\n-                                    <property>\n-                                        <name>openjpa.ConnectionDriverName</name>\n-                                        <value>org.apache.commons.dbcp.BasicDataSource</value>\n-                                    </property>\n-                                    <property>\n-                                        <name>derby.stream.error.file</name>\n-                                        <value>target/derby.log</value>\n-                                    </property>\n-                                    <property>\n-                                        <name>openjpa.ConnectionProperties</name>\n-                                        <value>DriverClassName=org.apache.derby.jdbc.EmbeddedDriver,Url=jdbc:derby:target/database/openjpa-derby-database;create=true,MaxActive=100,MaxIdle=0,MaxWait=10000,TestOnBorrow=true</value>\n-                                    </property>\n-                                </systemProperties>\n-                            </configuration>\n-                        </plugin>\n-                    </plugins>\n-                </pluginManagement>\n-            </build>\n+            <properties>\n+                <connection.driver.name>org.apache.derby.jdbc.EmbeddedDriver</connection.driver.name>\n+                <connection.url>jdbc:derby:target/database/openjpa-derby-database;create=true</connection.url>\n+                <connection.username />\n+                <connection.password />\n+            </properties>\n         </profile>\n \n-\n         <!-- Profile for testing with HSQL DB -->\n         <profile>\n             <id>test-hsqldb</id>\n@@ -100,35 +84,14 @@\n                     <scope>test</scope>\n                 </dependency>\n             </dependencies>\n-            <build>\n-                <pluginManagement>\n-                    <plugins>\n-                        <plugin>\n-                            <groupId>org.apache.maven.plugins</groupId>\n-                            <artifactId>maven-surefire-plugin</artifactId>\n-                            <configuration>\n-                                <systemProperties>\n-                                    <property>\n-                                        <name>openjpa.Log</name>\n-                                        <value>DefaultLevel=${openjpa.loglevel}</value>\n-                                    </property>\n-                                    <property>\n-                                        <name>openjpa.ConnectionDriverName</name>\n-                                        <value>org.apache.commons.dbcp.BasicDataSource</value>\n-                                    </property>\n-                                    <property>\n-                                        <name>openjpa.ConnectionProperties</name>\n-                                        <value>DriverClassName=org.hsqldb.jdbcDriver,Url=jdbc:hsqldb:target/database/openjpa-hsqldb-database;create=true,MaxActive=100,MaxWait=10000,TestOnBorrow=true</value>\n-                                    </property>\n-                                </systemProperties>\n-                            </configuration>\n-                        </plugin>\n-                    </plugins>\n-                </pluginManagement>\n-            </build>\n+             <properties>\n+                <connection.driver.name>org.hsqldb.jdbcDriver</connection.driver.name>\n+                <connection.url>jdbc:hsqldb:target/database/openjpa-hsqldb-database;create=true</connection.url>\n+                <connection.username>sa</connection.username>\n+                <connection.password />\n+            </properties>\n         </profile>\n \n-\n         <!-- Profile for testing with MySQL DB -->\n         <profile>\n             <id>test-mysql</id>\n@@ -137,39 +100,18 @@\n                 <dependency>\n                     <groupId>mysql</groupId>\n                     <artifactId>mysql-connector-java</artifactId>\n-                    <version>5.0.4</version>\n+                    <version>5.1.6</version>\n                     <scope>test</scope>\n                 </dependency>\n             </dependencies>\n-            <build>\n-                <pluginManagement>\n-                    <plugins>\n-                        <plugin>\n-                            <groupId>org.apache.maven.plugins</groupId>\n-                            <artifactId>maven-surefire-plugin</artifactId>\n-                            <configuration>\n-                                <systemProperties>\n-                                    <property>\n-                                        <name>openjpa.Log</name>\n-                                        <value>DefaultLevel=${openjpa.loglevel}</value>\n-                                    </property>\n-                                    <property>\n-                                        <name>openjpa.ConnectionDriverName</name>\n-                                        <value>org.apache.commons.dbcp.BasicDataSource</value>\n-                                    </property>\n-                                    <property>\n-                                        <name>openjpa.ConnectionProperties</name>\n-                                        <value>DriverClassName=com.mysql.jdbc.Driver,Url=${openjpa.mysql.url},MaxActive=100,MaxWait=10000,TestOnBorrow=true,Username=${openjpa.mysql.username},Password=${openjpa.mysql.password}</value>\n-                                    </property>\n-                                </systemProperties>\n-                            </configuration>\n-                        </plugin>\n-                    </plugins>\n-                </pluginManagement>\n-            </build>\n+            <properties>\n+                <connection.driver.name>com.mysql.jdbc.Driver</connection.driver.name>\n+                <connection.url>${openjpa.mysql.url}</connection.url>\n+                <connection.username>${openjpa.mysql.username}</connection.username>\n+                <connection.password>${openjpa.mysql.password}</connection.password>\n+            </properties>\n         </profile>\n \n-\n         <!-- Profile for testing with PostgreSQL DB -->\n         <profile>\n             <id>test-postgresql</id>\n@@ -182,35 +124,14 @@\n                     <scope>test</scope>\n                 </dependency>\n             </dependencies>\n-            <build>\n-                <pluginManagement>\n-                    <plugins>\n-                        <plugin>\n-                            <groupId>org.apache.maven.plugins</groupId>\n-                            <artifactId>maven-surefire-plugin</artifactId>\n-                            <configuration>\n-                                <systemProperties>\n-                                    <property>\n-                                        <name>openjpa.Log</name>\n-                                        <value>DefaultLevel=${openjpa.loglevel}</value>\n-                                    </property>\n-                                    <property>\n-                                        <name>openjpa.ConnectionDriverName</name>\n-                                        <value>org.apache.commons.dbcp.BasicDataSource</value>\n-                                    </property>\n-                                    <property>\n-                                        <name>openjpa.ConnectionProperties</name>\n-                                        <value>DriverClassName=org.postgresql.Driver,Url=${openjpa.postgresql.url},MaxActive=100,MaxWait=10000,TestOnBorrow=true,Username=${openjpa.postgresql.username},Password=${openjpa.postgresql.password}</value>\n-                                    </property>\n-                                </systemProperties>\n-                            </configuration>\n-                        </plugin>\n-                    </plugins>\n-                </pluginManagement>\n-            </build>\n+            <properties>\n+                <connection.driver.name>org.postgresql.Driver</connection.driver.name>\n+                <connection.url>${openjpa.postgresql.url}</connection.url>\n+                <connection.username>${openjpa.postgresql.username}</connection.username>\n+                <connection.password>${openjpa.postgresql.password}</connection.password>\n+            </properties>\n         </profile>\n \n-\n         <!-- Profile for testing with SQLServer DB using the jTDS driver -->\n         <profile>\n             <id>test-sqlserver</id>\n@@ -223,35 +144,14 @@\n                     <scope>test</scope>\n                 </dependency>\n             </dependencies>\n-            <build>\n-                <pluginManagement>\n-                    <plugins>\n-                        <plugin>\n-                            <groupId>org.apache.maven.plugins</groupId>\n-                            <artifactId>maven-surefire-plugin</artifactId>\n-                            <configuration>\n-                                <systemProperties>\n-                                    <property>\n-                                        <name>openjpa.Log</name>\n-                                        <value>DefaultLevel=${openjpa.loglevel}</value>\n-                                    </property>\n-                                    <property>\n-                                        <name>openjpa.ConnectionDriverName</name>\n-                                        <value>org.apache.commons.dbcp.BasicDataSource</value>\n-                                    </property>\n-                                    <property>\n-                                        <name>openjpa.ConnectionProperties</name>\n-                                        <value>DriverClassName=net.sourceforge.jtds.jdbc.Driver,Url=${openjpa.sqlserver.url},MaxActive=100,MaxWait=10000,TestOnBorrow=true,Username=${openjpa.sqlserver.username},Password=${openjpa.sqlserver.password}</value>\n-                                    </property>\n-                                </systemProperties>\n-                            </configuration>\n-                        </plugin>\n-                    </plugins>\n-                </pluginManagement>\n-            </build>\n+            <properties>\n+                <connection.driver.name>net.sourceforge.jtds.jdbc.Driver</connection.driver.name>\n+                <connection.url>${openjpa.sqlserver.url}</connection.url>\n+                <connection.username>${openjpa.sqlserver.username}</connection.username>\n+                <connection.password>${openjpa.sqlserver.password}</connection.password>\n+            </properties>\n         </profile>\n \n-\n         <!-- Profile for testing with Sybase DB using the jTDS driver -->\n         <profile>\n             <id>test-sybase</id>\n@@ -264,32 +164,12 @@\n                     <scope>test</scope>\n                 </dependency>\n             </dependencies>\n-            <build>\n-                <pluginManagement>\n-                    <plugins>\n-                        <plugin>\n-                            <groupId>org.apache.maven.plugins</groupId>\n-                            <artifactId>maven-surefire-plugin</artifactId>\n-                            <configuration>\n-                                <systemProperties>\n-                                    <property>\n-                                        <name>openjpa.Log</name>\n-                                        <value>DefaultLevel=${openjpa.loglevel}</value>\n-                                    </property>\n-                                    <property>\n-                                        <name>openjpa.ConnectionDriverName</name>\n-                                        <value>org.apache.commons.dbcp.BasicDataSource</value>\n-                                    </property>\n-                                    <property>\n-                                        <name>openjpa.ConnectionProperties</name>\n-                                        <value>DriverClassName=net.sourceforge.jtds.jdbc.Driver,Url=${openjpa.sybase.url},MaxActive=100,MaxWait=10000,TestOnBorrow=true,Username=${openjpa.sybase.username},Password=${openjpa.sybase.password}</value>\n-                                    </property>\n-                                </systemProperties>\n-                            </configuration>\n-                        </plugin>\n-                    </plugins>\n-                </pluginManagement>\n-            </build>\n+            <properties>\n+                <connection.driver.name>net.sourceforge.jtds.jdbc.Driver</connection.driver.name>\n+                <connection.url>${openjpa.sybase.url}</connection.url>\n+                <connection.username>${openjpa.sybase.username}</connection.username>\n+                <connection.password>${openjpa.sybase.password}</connection.password>\n+            </properties>\n         </profile>\n \n         <!-- Profile for testing with a custom DB using a system jar -->\n@@ -314,37 +194,190 @@\n                     <systemPath>${openjpa.custom.driverjar}</systemPath>\n                 </dependency>\n             </dependencies>\n-            <build>\n-                <pluginManagement>\n-                    <plugins>\n-                        <plugin>\n-                            <groupId>org.apache.maven.plugins</groupId>\n-                            <artifactId>maven-surefire-plugin</artifactId>\n-                            <configuration>\n-                                <systemProperties>\n-                                    <property>\n-                                        <name>openjpa.Log</name>\n-                                        <value>DefaultLevel=${openjpa.loglevel}</value>\n-                                    </property>\n-                                    <property>\n-                                        <name>openjpa.ConnectionDriverName</name>\n-                                        <value>org.apache.commons.dbcp.BasicDataSource</value>\n-                                    </property>\n-                                    <property>\n-                                        <name>openjpa.ConnectionProperties</name>\n-                                        <value>DriverClassName=${openjpa.custom.driverclass},Url=${openjpa.custom.url},MaxActive=100,MaxWait=10000,TestOnBorrow=true,Username=${openjpa.custom.username},Password=${openjpa.custom.password}</value>\n-                                    </property>\n-                                </systemProperties>\n-                            </configuration>\n-                        </plugin>\n-                    </plugins>\n-                </pluginManagement>\n-            </build>\n+            <properties>\n+                <connection.driver.name>${openjpa.custom.driverclass}</connection.driver.name>\n+                <connection.url>${openjpa.custom.url}</connection.url>\n+                <connection.username>${openjpa.custom.username}</connection.username>\n+                <connection.password>${openjpa.custom.password}</connection.password>\n+            </properties>\n         </profile>\n \n-    </profiles>\n+        <!-- Profile for testing with a custom DB using two system jars.\n+             Some databases (DB2) use more than one jar for their JDBC provider.\n+             Functionally this is identical to the previous profile, with a\n+             second system dependency added.\n+          -->\n+        <!--\n+            For example, to test with DB2, you might run:\n+        mvn test -Dtest=TestPersistence -Ptest-custom2 \\\n+          -Dopenjpa.custom.driverjar1=$(pwd)/drivers/db2jcc.jar \\\n+          -Dopenjpa.custom.driverjar2=$(pwd)/drviers/db2jcc_license_cu.jar \\\n+          -Dopenjpa.custom.driverclass=com.ibm.db2.jcc.DB2Driver \\\n+          -Dopenjpa.custom.url=jdbc:db2://HOST:PORT/DBNAME \\\n+          -Dopenjpa.custom.username=USERNAME \\\n+          -Dopenjpa.custom.password=PASSWORD\n+        -->\n+        <profile>\n+            <id>test-custom2</id>\n+            <activation><property><name>test-custom2</name></property></activation>\n+            <dependencies>\n+                <dependency>\n+                    <groupId>openjpa.customdriver1</groupId>\n+                    <artifactId>openjpa.customdriver1</artifactId>\n+                    <version>1.0</version>\n+                    <scope>system</scope>\n+                    <systemPath>${openjpa.custom.driverjar1}</systemPath>\n+                </dependency>\n+                <dependency>\n+                    <groupId>openjpa.customdriver2</groupId>\n+                    <artifactId>openjpa.customdriver2</artifactId>\n+                    <version>1.0</version>\n+                    <scope>system</scope>\n+                    <systemPath>${openjpa.custom.driverjar2}</systemPath>\n+                </dependency>\n+            </dependencies>\n+            <properties>\n+                <connection.driver.name>${openjpa.custom.driverclass}</connection.driver.name>\n+                <connection.url>${openjpa.custom.url}</connection.url>\n+                <connection.username>${openjpa.custom.username}</connection.username>\n+                <connection.password>${openjpa.custom.password}</connection.password>\n+            </properties>\n+        </profile>\n+        \n+        <!--  \n+            The test-custom2 profile does not work very well when used with a \n+            continuous build system. As a convenience I've added profiles for \n+            some of the proprietary databases to make testing easier. \n+          -->\n+        <profile>\n+            <!-- \n+                Example db2 profile. You can use this profile if you:\n+                1) have the DB2 artifacts installed in a local repo and supply\n+                the URL:\n+                   -Ddb2.maven.repo=http://my.local.repo\n+                2) have a copy of the DB2 JCC driver and run the following\n+                commands :\n+                    mvn install:install-file -Dfile=${path to db2jcc.jar} \\\n+                                             -DgroupId=com.ibm.db2 \\\n+                                             -DartifactId=jcc-driver \\ \n+                                             -Dversion=9.5 \\\n+                                             -Dpackaging=jar\n+                                         \n+                    mvn install:install-file -Dfile=${path to db2jcc_license.jar} \\\n+                                             -DgroupId=com.ibm.db2 \\\n+                                             -DartifactId=jcc-license \\ \n+                                             -Dversion=9.5 \\\n+                                             -Dpackaging=jar\n \n+                You must also set the following properties:\n+                    -Dopenjpa.db2.url=jdbc:db2://<HOST>:<PORT>/<DBNAME>\n+                    -Dopenjpa.db2.username=<db2_uid>\n+                    -Dopenjpa.db2.password=<db2_pwd>\n \n+                Optionally, you can override the default DB2 groupId and version\n+                by also supplying the following properties:\n+                    -Ddb2.groupid=com.ibm.db2\n+                    -Ddb2.version=9.5\n+            -->\n+            <id>test-db2-jcc</id>\n+            <dependencies>\n+                <dependency>\n+                    <groupId>${db2.groupid}</groupId>\n+                    <artifactId>jcc-driver</artifactId>\n+                    <version>${db2.version}</version>\n+                    <scope>test</scope>\n+                </dependency>\n+                <dependency>\n+                    <groupId>${db2.groupid}</groupId>\n+                    <artifactId>jcc-license</artifactId>\n+                    <version>${db2.version}</version>\n+                    <scope>test</scope>\n+                </dependency>\n+            </dependencies>\n+            <properties>\n+                <db2.maven.repo>http://not.a.real.repository</db2.maven.repo>\n+                <db2.groupid>com.ibm.db2</db2.groupid>\n+                <db2.version>9.5</db2.version>\n+                <connection.driver.name>com.ibm.db2.jcc.DB2Driver</connection.driver.name>\n+                <connection.url>${openjpa.db2.url}</connection.url>\n+                <connection.username>${openjpa.db2.username}</connection.username>\n+                <connection.password>${openjpa.db2.password}</connection.password>\n+            </properties>\n+            <repositories>\n+                <repository>\n+                    <id>db2.repository</id>\n+                    <name>DB2 Repository</name>\n+                    <url>${db2.maven.repo}</url>\n+                    <layout>default</layout>\n+                    <snapshots>\n+                        <enabled>false</enabled>\n+                    </snapshots>\n+                    <releases>\n+                        <enabled>true</enabled>\n+                        <checksumPolicy>ignore</checksumPolicy>\n+                    </releases>\n+                </repository>\n+            </repositories>\n+        </profile>          \n+        <profile>\n+            <!-- \n+                Example oracle profile. You can use this profile if you:\n+                1) have the Oracle artifacts installed in a local repo and\n+                supply the URL:\n+                    -Doracle.maven.repo=http://my.local.repo\n+                2) have a copy of the Oracle driver and run the following\n+                command:\n+                    mvn install:install-file -Dfile=${path to ojdbc.jar} \\\n+                                             -DgroupId=com.oracle \\\n+                                             -DartifactId=jdbc-driver \\ \n+                                             -Dversion=10g \\\n+                                             -Dpackaging=jar\n+                                         \n+                You must also set the following properties:\n+                    -Dopenjpa.oracle.url\n+                    -Dopenjpa.oracle.username\n+                    -Dopenjpa.oracle.password\n+\n+                Optionally, you can override the default Oracle groupId and\n+                version by also supplying the following properties:\n+                    -Doracle.groupid=com.oracle\n+                    -Doracle.version=10g\n+            -->\n+            <id>test-oracle</id>\n+            <dependencies>\n+                <dependency>\n+                    <groupId>${oracle.groupid}</groupId>\n+                    <artifactId>jdbc-driver</artifactId>\n+                    <version>${oracle.version}</version>\n+                    <scope>test</scope>\n+                </dependency>\n+            </dependencies>\n+            <properties>\n+                <oracle.maven.repo>http://not.a.real.repository</oracle.maven.repo>\n+                <oracle.groupid>com.oracle</oracle.groupid>\n+                <oracle.version>10g</oracle.version>\n+                <connection.driver.name>oracle.jdbc.driver.OracleDriver</connection.driver.name>\n+                <connection.url>${openjpa.oracle.url}</connection.url>\n+                <connection.username>${openjpa.oracle.username}</connection.username>\n+                <connection.password>${openjpa.oracle.password}</connection.password>\n+            </properties>\n+            <repositories>\n+                <repository>\n+                    <id>oracle.repository</id>\n+                    <name>Oracle Repository</name>\n+                    <url>${oracle.maven.repo}</url>\n+                    <layout>default</layout>\n+                    <snapshots>\n+                        <enabled>false</enabled>\n+                    </snapshots>\n+                    <releases>\n+                        <enabled>true</enabled>\n+                        <checksumPolicy>ignore</checksumPolicy>\n+                    </releases>\n+                </repository>\n+            </repositories>\n+        </profile>  \n+    </profiles>\n \n     <dependencies>\n         <dependency>\n@@ -375,13 +408,7 @@\n     <build>\n         <plugins>\n             <plugin>\n-                <artifactId>maven-compiler-plugin</artifactId>\n-                <configuration>\n-                    <source>1.5</source>\n-                    <target>1.5</target>\n-                </configuration>\n-            </plugin>\n-            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n                 <artifactId>maven-antrun-plugin</artifactId>\n                 <executions>\n                     <execution>\n@@ -397,7 +424,7 @@\n                                     <property name=\"test\" value=\"${test}\" />\n                                     <property name=\"outdir\" value=\"${project.build.outputDirectory}\" />\n                                     <property name=\"project.build.testOutputDirectory\" value=\"${project.build.testOutputDirectory}\" />\n-                                    <property name=\"openjpa.loglevel\" value=\"${openjpa.loglevel}\" />\n+                                    <property name=\"openjpa.Log\" value=\"${openjpa.Log}\" /> \n                                 </ant>\n                             </tasks>\n                         </configuration>\n@@ -407,6 +434,39 @@\n                     </execution>\n                 </executions>\n             </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <argLine>${test.jvm.arguments}</argLine>\n+                    <systemProperties>\n+                        <property>\n+                            <name>openjpa.Log</name>\n+                            <value>${openjpa.Log}</value>\n+                        </property>\n+                        <property>\n+                            <name>openjpa.ConnectionDriverName</name>\n+                            <value>org.apache.commons.dbcp.BasicDataSource</value>\n+                        </property>\n+                        <property>\n+                            <name>derby.stream.error.file</name>\n+                            <value>target/derby.log</value>\n+                        </property>\n+                        <property>\n+                            <name>derby.locks.deadlockTimeout</name>\n+                            <value>${derby.locks.deadlockTimeout}</value>\n+                        </property>\n+                        <property>\n+                            <name>derby.locks.waitTimeout</name>\n+                            <value>${derby.locks.waitTimeout}</value>\n+                        </property>\n+                        <property>\n+                            <name>openjpa.ConnectionProperties</name>\n+                            <value>DriverClassName=${connection.driver.name},Url=${connection.url},Username=${connection.username},Password=${connection.password},${dbcp.args}</value>\n+                        </property>\n+                    </systemProperties>\n+                </configuration>\n+            </plugin>\n         </plugins>\n     </build>\n </project>"},{"sha":"92a798b60107ace236d801d58537a5e8fc556457","filename":"openjpa-persistence-jdbc/src/main/ant/enhancer.xml","status":"modified","additions":3,"deletions":5,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/main/ant/enhancer.xml","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/main/ant/enhancer.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/ant/enhancer.xml?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -59,8 +59,6 @@\n           -->\n         <path id=\"cp\">\n             <path refid=\"maven.test.classpath\" />\n-            <path refid=\"maven.compile.classpath\" />\n-            <path refid=\"maven.dependency.classpath\" />\n         </path>\n \n         <taskdef name=\"openjpac\"\n@@ -80,7 +78,7 @@\n         <openjpac>\n             <classpath refid=\"cp\" />\n             <fileset refid=\"enhance.path.ref\" />\n-            <config log=\"DefaultLevel=${openjpa.loglevel}\" />\n+            <config log=\"${openjpa.Log}\" />\n         </openjpac>\n         <!--  Set detach state for serialization tests -->\n         <openjpac>\n@@ -92,8 +90,8 @@\n                 <include name=\"**/xml/*.class\" />\n                 <exclude name=\"**/Test*.class\" />\n             </fileset>\n-            <config log=\"DefaultLevel=${openjpa.loglevel}\" />\n+            <config log=\"${openjpa.Log}\" />\n         </openjpac>\n \n     </target>\n-</project>\n\\ No newline at end of file\n+</project>"},{"sha":"26bf2ee59116dcd7461b3f105061b05dfe67f99e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java","status":"modified","additions":109,"deletions":109,"changes":218,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,109 +1,109 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import org.apache.openjpa.lib.conf.Value;\r\n-import org.apache.openjpa.persistence.OpenJPAEntityManagerFactory;\r\n-import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\r\n-import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n-\r\n-/**\r\n- * Tests dynamic modification of configuration property.\r\n- * \r\n- * @author Pinaki Poddar\r\n- *\r\n- */\r\n-public class TestDynamicConfiguration extends SingleEMFTestCase {\r\n-\r\n-    public void testConfigurationIsEqualByValueAndHashCode() {\r\n-\t\tOpenJPAEntityManagerFactorySPI emf1 = createEMF();\r\n-\t\tassertNotNull(emf1);\r\n-\t\tOpenJPAConfiguration conf1 = emf1.getConfiguration();\r\n-\t\t\r\n-\t\tOpenJPAEntityManagerFactorySPI emf2 = createEMF();\r\n-\t\tassertNotNull(emf2);\r\n-\t\tOpenJPAConfiguration conf2 = emf2.getConfiguration();\r\n-\t\t\r\n-\t\tassertFalse(emf1==emf2);\r\n-\t\tassertFalse(emf1.equals(emf2));\r\n-\t\tassertFalse(conf1==conf2);\r\n-\t\tassertEquals(conf1, conf2);\r\n-\t\tassertEquals(conf1.hashCode(), conf2.hashCode());\r\n-\t\tassertEquals(conf1.toProperties(false), conf2.toProperties(false));\r\n-\t}\r\n-\t\r\n-\tpublic void testConfigurationIsReadOnlyAfterFirstConstruction() {\r\n-\t\tOpenJPAConfiguration conf = emf.getConfiguration();\r\n-\t\tassertFalse(conf.isReadOnly());\r\n-\t\temf.createEntityManager();\r\n-\t\tassertTrue(conf.isReadOnly());\r\n-\t}\r\n-\t\r\n-\tpublic void testDynamicValuesCanNotBeChangedDirectly() {\r\n-\t\temf.createEntityManager();\r\n-\t\tOpenJPAConfiguration conf = emf.getConfiguration();\r\n-\t\t\r\n-\t\tValue[] dynamicValues = conf.getDynamicValues();\r\n-\t\tassertTrue(dynamicValues.length>0);\r\n-\t\tassertTrue(conf.isDynamic(\"LockTimeout\"));\r\n-\r\n-\t\tint oldValue = conf.getLockTimeout();\r\n-\t\tint newValue = oldValue + 10;\r\n-\t\ttry {\r\n-\t\t\tconf.setLockTimeout(newValue);\r\n-\t\t\tfail(\"Expected exception to modify configuration directly\");\r\n-\t\t} catch (Exception ex) { // good\r\n-\t\t\tassertEquals(oldValue, conf.getLockTimeout());\r\n-\t\t}\r\n-\t}\r\n-\t\r\n-\tpublic void testDynamicValuesCanBeChanged() {\r\n-\t\tOpenJPAConfiguration conf = emf.getConfiguration();\r\n-\t\t\r\n-\t\tValue[] dynamicValues = conf.getDynamicValues();\r\n-\t\tassertTrue(dynamicValues.length>0);\r\n-\t\tassertTrue(conf.isDynamic(\"LockTimeout\"));\r\n-\r\n-\t\tint oldValue = conf.getLockTimeout();\r\n-\t\tint newValue = oldValue + 10;\r\n-\t\t\r\n-\t\tconf.modifyDynamic(\"LockTimeout\", newValue);\r\n-\t\tassertEquals(newValue, conf.getLockTimeout());\r\n-\t}\r\n-\r\n-\tpublic void testDynamicValuesAreCorrectlySet() {\r\n-\t\tOpenJPAConfiguration conf = emf.getConfiguration();\r\n-\t\t\r\n-\t\tValue[] dynamicValues = conf.getDynamicValues();\r\n-\t\tassertTrue(dynamicValues.length>0);\r\n-\t\tassertTrue(conf.isDynamic(\"LockTimeout\"));\r\n-\t}\r\n-\t\r\n-\tpublic void testDynamicChangeDoesNotChangeHashCode() {\r\n-\t\tOpenJPAConfiguration conf1 = emf.getConfiguration();\r\n-\t\t\r\n-\t\tint oldValue = conf1.getLockTimeout();\r\n-\t\tint newValue = oldValue+10;\r\n-\t\tint oldHash = conf1.hashCode();\r\n-\t\tconf1.modifyDynamic(\"LockTimeout\", newValue);\r\n-\t\tint newHash = conf1.hashCode();\r\n-\t\t\r\n-\t\tassertEquals(oldHash, newHash);\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.conf;\n+\n+import org.apache.openjpa.lib.conf.Value;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactory;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+\n+/**\n+ * Tests dynamic modification of configuration property.\n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+public class TestDynamicConfiguration extends SingleEMFTestCase {\n+\n+    public void testConfigurationIsEqualByValueAndHashCode() {\n+\t\tOpenJPAEntityManagerFactorySPI emf1 = createEMF();\n+\t\tassertNotNull(emf1);\n+\t\tOpenJPAConfiguration conf1 = emf1.getConfiguration();\n+\t\t\n+\t\tOpenJPAEntityManagerFactorySPI emf2 = createEMF();\n+\t\tassertNotNull(emf2);\n+\t\tOpenJPAConfiguration conf2 = emf2.getConfiguration();\n+\t\t\n+\t\tassertFalse(emf1==emf2);\n+\t\tassertFalse(emf1.equals(emf2));\n+\t\tassertFalse(conf1==conf2);\n+\t\tassertEquals(conf1, conf2);\n+\t\tassertEquals(conf1.hashCode(), conf2.hashCode());\n+\t\tassertEquals(conf1.toProperties(false), conf2.toProperties(false));\n+\t}\n+\t\n+\tpublic void testConfigurationIsReadOnlyAfterFirstConstruction() {\n+\t\tOpenJPAConfiguration conf = emf.getConfiguration();\n+\t\tassertFalse(conf.isReadOnly());\n+\t\temf.createEntityManager();\n+\t\tassertTrue(conf.isReadOnly());\n+\t}\n+\t\n+\tpublic void testDynamicValuesCanNotBeChangedDirectly() {\n+\t\temf.createEntityManager();\n+\t\tOpenJPAConfiguration conf = emf.getConfiguration();\n+\t\t\n+\t\tValue[] dynamicValues = conf.getDynamicValues();\n+\t\tassertTrue(dynamicValues.length>0);\n+\t\tassertTrue(conf.isDynamic(\"LockTimeout\"));\n+\n+\t\tint oldValue = conf.getLockTimeout();\n+\t\tint newValue = oldValue + 10;\n+\t\ttry {\n+\t\t\tconf.setLockTimeout(newValue);\n+\t\t\tfail(\"Expected exception to modify configuration directly\");\n+\t\t} catch (Exception ex) { // good\n+\t\t\tassertEquals(oldValue, conf.getLockTimeout());\n+\t\t}\n+\t}\n+\t\n+\tpublic void testDynamicValuesCanBeChanged() {\n+\t\tOpenJPAConfiguration conf = emf.getConfiguration();\n+\t\t\n+\t\tValue[] dynamicValues = conf.getDynamicValues();\n+\t\tassertTrue(dynamicValues.length>0);\n+\t\tassertTrue(conf.isDynamic(\"LockTimeout\"));\n+\n+\t\tint oldValue = conf.getLockTimeout();\n+\t\tint newValue = oldValue + 10;\n+\t\t\n+\t\tconf.modifyDynamic(\"LockTimeout\", newValue);\n+\t\tassertEquals(newValue, conf.getLockTimeout());\n+\t}\n+\n+\tpublic void testDynamicValuesAreCorrectlySet() {\n+\t\tOpenJPAConfiguration conf = emf.getConfiguration();\n+\t\t\n+\t\tValue[] dynamicValues = conf.getDynamicValues();\n+\t\tassertTrue(dynamicValues.length>0);\n+\t\tassertTrue(conf.isDynamic(\"LockTimeout\"));\n+\t}\n+\t\n+\tpublic void testDynamicChangeDoesNotChangeHashCode() {\n+\t\tOpenJPAConfiguration conf1 = emf.getConfiguration();\n+\t\t\n+\t\tint oldValue = conf1.getLockTimeout();\n+\t\tint newValue = oldValue+10;\n+\t\tint oldHash = conf1.hashCode();\n+\t\tconf1.modifyDynamic(\"LockTimeout\", newValue);\n+\t\tint newHash = conf1.hashCode();\n+\t\t\n+\t\tassertEquals(oldHash, newHash);\n+\t}\n+}"},{"sha":"fac8bfb92a46e8ba8edf1f18dc75499919f808bb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","status":"modified","additions":595,"deletions":595,"changes":1190,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,596 +1,596 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.ByteArrayOutputStream;\r\n-import java.io.ObjectOutputStream;\r\n-import java.io.ObjectInputStream;\r\n-import java.io.ByteArrayInputStream;\r\n-import java.util.List;\r\n-import java.util.Collections;\r\n-import java.lang.reflect.Field;\r\n-\r\n-import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n-import org.apache.openjpa.persistence.OpenJPAEntityManager;\r\n-import org.apache.openjpa.persistence.JPAFacadeHelper;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-import org.apache.openjpa.event.AbstractLifecycleListener;\r\n-import org.apache.openjpa.event.LifecycleEvent;\r\n-\r\n-public abstract class AbstractUnenhancedClassTest\r\n-    extends SingleEMFTestCase {\r\n-\r\n-    // ##### To do:\r\n-    // - clearing in pnew property-access without redefinition\r\n-    // - figure out how to auto-test the redefinition code, either in Java 5\r\n-    //   or in Java 6\r\n-    // - run CTS in the following combinations:\r\n-    //   * Java 6\r\n-    //   * Java 5 with javaagent\r\n-    //   * Java 5 without javaagent\r\n-\r\n-    public void setUp() {\r\n-        setUp(getUnenhancedClass(), getUnenhancedSubclass(), CLEAR_TABLES);\r\n-        // trigger class redefinition\r\n-        emf.createEntityManager().close();\r\n-    }\r\n-\r\n-    protected abstract Class<? extends UnenhancedType> getUnenhancedClass();\r\n-\r\n-    protected abstract UnenhancedType newUnenhancedInstance();\r\n-\r\n-    protected abstract Class<? extends UnenhancedSubtype> getUnenhancedSubclass();\r\n-\r\n-    protected abstract UnenhancedSubtype newUnenhancedSubclassInstance();\r\n-\r\n-    private UnenhancedType newInstance(boolean sub) {\r\n-        return sub ? newUnenhancedSubclassInstance()\r\n-            : newUnenhancedInstance();\r\n-    }\r\n-\r\n-    public void testMetaData() {\r\n-        ClassMetaData meta = JPAFacadeHelper.getMetaData(emf,\r\n-            getUnenhancedClass());\r\n-        assertEquals(ClassRedefiner.canRedefineClasses(),\r\n-            meta.isIntercepting());\r\n-    }\r\n-\r\n-    public void testImplHelperCalls() {\r\n-        assertTrue(ImplHelper.isManagedType(null, getUnenhancedClass()));\r\n-\r\n-        UnenhancedType un = newUnenhancedInstance();\r\n-        assertFalse(un instanceof PersistenceCapable);\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(un,\r\n-            emf.getConfiguration());\r\n-        assertNotNull(pc);\r\n-        assertTrue(ImplHelper.isManageable(un));\r\n-    }\r\n-\r\n-    public void testBasicPersistenceCapableBehavior() {\r\n-        UnenhancedType un = newUnenhancedInstance();\r\n-        un.setStringField(\"bar\");\r\n-        PersistenceCapable pc = ImplHelper.toPersistenceCapable(un,\r\n-            emf.getConfiguration());\r\n-        assertFalse(pc.pcIsDeleted());\r\n-        assertFalse(pc.pcIsDirty());\r\n-        assertFalse(pc.pcIsNew());\r\n-        assertFalse(pc.pcIsPersistent());\r\n-        assertFalse(pc.pcIsTransactional());\r\n-    }\r\n-\r\n-    public void testPCRegistry() {\r\n-        assertTrue(PCRegistry.isRegistered(getUnenhancedClass()));\r\n-        PersistenceCapable pc = PCRegistry.newInstance(\r\n-            getUnenhancedClass(), null, false);\r\n-        assertNotNull(pc);\r\n-    }\r\n-\r\n-    public void testClearingOnSubtypeInstance() {\r\n-        // the boolean at the end of newInstance will cause clear to be invoked\r\n-        UnenhancedType un = (UnenhancedType)\r\n-            PCRegistry.newInstance(getUnenhancedClass(), null, true);\r\n-        assertEquals(null, un.getStringField());\r\n-    }\r\n-\r\n-    public void testGetObjectIdOnOpenJPAType() {\r\n-        getObjectIdHelper(true, false);\r\n-    }\r\n-\r\n-    public void testGetObjectIdOnOpenJPATypeSubclass() {\r\n-        getObjectIdHelper(false, false);\r\n-    }\r\n-\r\n-    public void testGetObjectIdOnUserDefined() {\r\n-        getObjectIdHelper(true, true);\r\n-    }\r\n-\r\n-    public void testGetObjectIdOnUserDefinedSubclass() {\r\n-        getObjectIdHelper(false, true);\r\n-    }\r\n-\r\n-    private void getObjectIdHelper(boolean sub, boolean userDefined) {\r\n-        OpenJPAEntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        UnenhancedType un = newInstance(sub);\r\n-        em.persist(un);\r\n-        em.getTransaction().commit();\r\n-\r\n-        if (!userDefined) {\r\n-            em.close();\r\n-            em = emf.createEntityManager();\r\n-            un = em.find(getUnenhancedClass(), un.getId());\r\n-        }\r\n-\r\n-        assertNotNull(em.getObjectId(un));\r\n-    }\r\n-\r\n-    public void testOperationsOnUserDefined() {\r\n-        opsHelper(false, true);\r\n-    }\r\n-\r\n-    public void testSubclassOperationsOnUserDefined() {\r\n-        opsHelper(true, true);\r\n-    }\r\n-\r\n-    public void testOperationsOnOpenJPADefined() {\r\n-        opsHelper(false, false);\r\n-    }\r\n-\r\n-    public void testSubclassOperationsOnOpenJPADefined() {\r\n-        opsHelper(true, false);\r\n-    }\r\n-\r\n-    private void opsHelper(boolean sub, boolean userDefined) {\r\n-        OpenJPAEntityManager em = null;\r\n-        try {\r\n-            UnenhancedType un = newInstance(sub);\r\n-            em = emf.createEntityManager();\r\n-\r\n-            em.getTransaction().begin();\r\n-            em.persist(un);\r\n-            un.setStringField(\"bar\");\r\n-            assertEquals(\"bar\", un.getStringField());\r\n-            assertPersistenceContext(em, un, true, true, sub);\r\n-            em.flush();\r\n-            assertPersistenceContext(em, un, true, true, sub);\r\n-            assertTrue(un.getId() != 0);\r\n-            UnenhancedType un2 = em.find(getUnenhancedClass(), un.getId());\r\n-            assertSame(un, un2);\r\n-            em.getTransaction().commit();\r\n-            assertPersistenceContext(em, un, false, false, sub);\r\n-            un2 = em.find(getUnenhancedClass(), un.getId());\r\n-            assertSame(un, un2);\r\n-\r\n-            if (!userDefined) {\r\n-                em.close();\r\n-                em = emf.createEntityManager();\r\n-            }\r\n-\r\n-            un = em.find(getUnenhancedClass(), un.getId());\r\n-            assertNotNull(un);\r\n-            if (!userDefined)\r\n-                assertTrue(un instanceof PersistenceCapable);\r\n-            assertEquals(\"bar\", un.getStringField());\r\n-            em.getTransaction().begin();\r\n-            un.setStringField(\"baz\");\r\n-            assertPersistenceContext(em, un, true, true, sub);\r\n-            assertEquals(\"baz\", un.getStringField());\r\n-\r\n-            if (sub)\r\n-                ((UnenhancedSubtype) un).setIntField(17);\r\n-\r\n-            assertTrue(em.isDirty(un));\r\n-            \r\n-            em.getTransaction().commit();\r\n-\r\n-            // make sure that the values are still up-to-date after\r\n-            // the commit happens\r\n-            assertEquals(\"baz\", un.getStringField());\r\n-            \r\n-            em.close();\r\n-\r\n-            em = emf.createEntityManager();\r\n-            un = em.find(getUnenhancedClass(), un.getId());\r\n-            assertNotNull(un);\r\n-            assertTrue(un instanceof PersistenceCapable);\r\n-            assertEquals(\"baz\", un.getStringField());\r\n-            if (sub)\r\n-                assertEquals(17, ((UnenhancedSubtype) un).getIntField());\r\n-            em.close();\r\n-        } finally {\r\n-            if (em != null && em.getTransaction().isActive())\r\n-                em.getTransaction().rollback();\r\n-            if (em != null && em.isOpen())\r\n-                em.close();\r\n-        }\r\n-    }\r\n-\r\n-    private void assertPersistenceContext(OpenJPAEntityManager em,\r\n-        UnenhancedType un, boolean transactional, boolean dirty, boolean sub) {\r\n-        assertEquals(transactional, em.getTransactionalObjects().contains(un));\r\n-        assertEquals(dirty, em.getDirtyObjects().contains(un));\r\n-        if (dirty) {\r\n-            Class cls = sub ? getUnenhancedSubclass() : getUnenhancedClass();\r\n-            assertTrue(em.getUpdatedClasses().contains(cls)\r\n-                || em.getPersistedClasses().contains(cls));\r\n-        }\r\n-    }\r\n-\r\n-    public void testRelations() {\r\n-        OpenJPAEntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        UnenhancedSubtype un = newUnenhancedSubclassInstance();\r\n-        em.persist(un);\r\n-        un.setStringField(\"aoeu\");\r\n-        UnenhancedSubtype related = newUnenhancedSubclassInstance();\r\n-        un.setRelated(related);\r\n-        related.setStringField(\"snth\");\r\n-        em.getTransaction().commit();\r\n-        em.close();\r\n-\r\n-        em = emf.createEntityManager();\r\n-        un = (UnenhancedSubtype) em.find(getUnenhancedClass(), un.getId());\r\n-        assertEquals(\"aoeu\", un.getStringField());\r\n-        assertNotNull(un.getRelated());\r\n-        assertEquals(\"snth\", un.getRelated().getStringField());\r\n-        em.close();\r\n-    }\r\n-\r\n-    public void testEnhancer() throws IOException {\r\n-        List<Class> subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\r\n-            emf.getConfiguration(),\r\n-            Collections.singleton(getUnenhancedClass()), null);\r\n-        Class sub = subs.get(0);\r\n-        assertNotNull(sub);\r\n-        assertEquals(\"org.apache.openjpa.enhance.\"\r\n-            + getUnenhancedClass().getName().replace('.', '$') + \"$pcsubclass\",\r\n-            sub.getName());\r\n-        assertTrue(PersistenceCapable.class.isAssignableFrom(sub));\r\n-        assertTrue(getUnenhancedClass().isAssignableFrom(sub));\r\n-    }\r\n-\r\n-    public void testPCSubclassName() {\r\n-        assertEquals(\"org.apache.openjpa.enhance.\"\r\n-            + getUnenhancedClass().getName().replace('.', '$') + \"$pcsubclass\",\r\n-            PCEnhancer.toPCSubclassName(getUnenhancedClass()));\r\n-    }\r\n-\r\n-    public void testEvictionInUserCreatedInstance()\r\n-        throws NoSuchFieldException, IllegalAccessException {\r\n-        evictionHelper(true);\r\n-    }\r\n-\r\n-    public void testEvictionInOpenJPACreatedInstance()\r\n-        throws NoSuchFieldException, IllegalAccessException {\r\n-        evictionHelper(false);\r\n-    }\r\n-\r\n-    private void evictionHelper(boolean userDefined)\r\n-        throws NoSuchFieldException, IllegalAccessException {\r\n-        OpenJPAEntityManager em = emf.createEntityManager();\r\n-        UnenhancedType un = newUnenhancedInstance();\r\n-        em.getTransaction().begin();\r\n-        em.persist(un);\r\n-        em.getTransaction().commit();\r\n-\r\n-        if (!userDefined) {\r\n-            em.close();\r\n-            em = emf.createEntityManager();\r\n-            un = em.find(getUnenhancedClass(), un.getId());\r\n-            assertTrue(getUnenhancedClass() != un.getClass());\r\n-        }\r\n-\r\n-        em.evict(un);\r\n-        OpenJPAStateManager sm = (OpenJPAStateManager)\r\n-            ImplHelper.toPersistenceCapable(un, null).pcGetStateManager();\r\n-\r\n-        // we only expect lazy loading to work when we can redefine classes\r\n-        // or when accessing a property-access record that OpenJPA created.\r\n-        if (ClassRedefiner.canRedefineClasses()\r\n-            || (!userDefined && sm.getMetaData().getAccessType()\r\n-                != ClassMetaData.ACCESS_FIELD)) {\r\n-\r\n-            assertFalse(sm.getLoaded()\r\n-                .get(sm.getMetaData().getField(\"stringField\").getIndex()));\r\n-\r\n-            // make sure that the value was cleared...\r\n-            Field field = getUnenhancedClass().getDeclaredField(\r\n-                isFieldAccessTest() ? \"stringField\" : \"sf\");\r\n-            field.setAccessible(true);\r\n-            assertEquals(null, field.get(un));\r\n-\r\n-            // ... and that it gets reloaded properly\r\n-            assertEquals(\"foo\", un.getStringField());\r\n-            assertTrue(sm.getLoaded()\r\n-                .get(sm.getMetaData().getField(\"stringField\").getIndex()));\r\n-        } else {\r\n-            // unredefined properties with user-defined instance, or any\r\n-            // unredefined field access\r\n-            assertTrue(sm.getLoaded()\r\n-                .get(sm.getMetaData().getField(\"stringField\").getIndex()));\r\n-\r\n-            // make sure that the value was not cleared\r\n-            Field field = getUnenhancedClass().getDeclaredField(\r\n-                isFieldAccessTest() ? \"stringField\" : \"sf\");\r\n-            field.setAccessible(true);\r\n-            assertEquals(\"foo\", field.get(un));\r\n-        }\r\n-\r\n-        em.close();\r\n-    }\r\n-\r\n-    protected abstract boolean isFieldAccessTest();\r\n-\r\n-    public void testLazyLoading()\r\n-        throws NoSuchFieldException, IllegalAccessException {\r\n-        OpenJPAEntityManager em = emf.createEntityManager();\r\n-        UnenhancedType un = newUnenhancedInstance();\r\n-        em.getTransaction().begin();\r\n-        em.persist(un);\r\n-        em.getTransaction().commit();\r\n-        em.close();\r\n-\r\n-        em = emf.createEntityManager();\r\n-        un = em.find(getUnenhancedClass(), un.getId());\r\n-        assertTrue(getUnenhancedClass() != un.getClass());\r\n-        OpenJPAStateManager sm = (OpenJPAStateManager)\r\n-            ImplHelper.toPersistenceCapable(un, null).pcGetStateManager();\r\n-\r\n-        // we only expect lazy loading to work when we can redefine classes\r\n-        // or when accessing a property-access record that OpenJPA created.\r\n-        if (ClassRedefiner.canRedefineClasses()\r\n-            || (sm.getMetaData().getAccessType() != ClassMetaData.ACCESS_FIELD))\r\n-        {\r\n-            assertFalse(sm.getLoaded()\r\n-                .get(sm.getMetaData().getField(\"lazyField\").getIndex()));\r\n-\r\n-            // make sure that the value was cleared\r\n-            Field field = getUnenhancedClass().getDeclaredField(\"lazyField\");\r\n-            field.setAccessible(true);\r\n-            assertEquals(null, field.get(un));\r\n-        } else {\r\n-            // unredefined field access\r\n-            assertTrue(sm.getLoaded()\r\n-                .get(sm.getMetaData().getField(\"lazyField\").getIndex()));\r\n-\r\n-            // make sure that the value was loaded already\r\n-            Field field = getUnenhancedClass().getDeclaredField(\"lazyField\");\r\n-            field.setAccessible(true);\r\n-            assertEquals(\"lazy\", field.get(un));\r\n-        }\r\n-\r\n-        // make sure that the value is available, one way or another\r\n-        assertEquals(\"lazy\", un.getLazyField());\r\n-        assertTrue(sm.getLoaded()\r\n-            .get(sm.getMetaData().getField(\"lazyField\").getIndex()));\r\n-\r\n-        em.close();\r\n-    }\r\n-\r\n-    public void testSerializationOfUserDefinedInstance()\r\n-        throws IOException, ClassNotFoundException {\r\n-        serializationHelper(true, false);\r\n-    }\r\n-\r\n-    public void testSerializationOfUserDefinedSubclassInstance()\r\n-        throws IOException, ClassNotFoundException {\r\n-        serializationHelper(true, true);\r\n-    }\r\n-\r\n-    public void testSerializationOfOpenJPADefinedInstance()\r\n-        throws IOException, ClassNotFoundException {\r\n-        serializationHelper(false, false);\r\n-    }\r\n-\r\n-    public void testSerializationOfOpenJPADefinedSubclassInstance()\r\n-        throws IOException, ClassNotFoundException {\r\n-        serializationHelper(false, true);\r\n-    }\r\n-\r\n-    private void serializationHelper(boolean userDefined, boolean sub)\r\n-        throws IOException, ClassNotFoundException {\r\n-        OpenJPAEntityManager em = emf.createEntityManager();\r\n-        UnenhancedType un = newInstance(sub);\r\n-        em.getTransaction().begin();\r\n-        em.persist(un);\r\n-\r\n-        if (sub) {\r\n-            UnenhancedType related = newInstance(false);\r\n-            related.setStringField(\"related\");\r\n-            ((UnenhancedSubtype) un).setRelated(related);\r\n-        }\r\n-\r\n-        em.getTransaction().commit();\r\n-\r\n-        if (!userDefined) {\r\n-            em.close();\r\n-            em = emf.createEntityManager();\r\n-        }\r\n-\r\n-        un = em.find(getUnenhancedClass(), un.getId());\r\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n-        ObjectOutputStream oout = new ObjectOutputStream(out);\r\n-        oout.writeObject(un);\r\n-        oout.flush();\r\n-        byte[] bytes = out.toByteArray();\r\n-\r\n-        ObjectInputStream oin = new ObjectInputStream(\r\n-            new ByteArrayInputStream(bytes));\r\n-        UnenhancedType deserialized = (UnenhancedType) oin.readObject();\r\n-\r\n-        copiedInstanceHelper(sub, em, un, deserialized, false);\r\n-        em.close();\r\n-    }\r\n-\r\n-    public void testCloningOfUserDefinedInstance()\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        cloneHelper(true, false);\r\n-    }\r\n-\r\n-    public void testCloningOfUserDefinedSubclassInstance()\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        cloneHelper(true, true);\r\n-    }\r\n-\r\n-    public void testCloningOfOpenJPADefinedInstance()\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        cloneHelper(false, false);\r\n-    }\r\n-\r\n-    public void testCloningOfOpenJPADefinedSubclassInstance()\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        cloneHelper(false, true);\r\n-    }\r\n-\r\n-    private void cloneHelper(boolean userDefined, boolean sub)\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        OpenJPAEntityManager em = emf.createEntityManager();\r\n-        UnenhancedType un = newInstance(sub);\r\n-        em.getTransaction().begin();\r\n-        em.persist(un);\r\n-\r\n-        if (sub) {\r\n-            UnenhancedType related = newInstance(false);\r\n-            related.setStringField(\"related\");\r\n-            ((UnenhancedSubtype) un).setRelated(related);\r\n-        }\r\n-\r\n-        em.getTransaction().commit();\r\n-\r\n-        if (!userDefined) {\r\n-            em.close();\r\n-            em = emf.createEntityManager();\r\n-        }\r\n-\r\n-        un = em.find(getUnenhancedClass(), un.getId());\r\n-        UnenhancedType cloned = (UnenhancedType) un.clone();\r\n-\r\n-        copiedInstanceHelper(sub, em, un, cloned, true);\r\n-        em.close();\r\n-    }\r\n-\r\n-    private void copiedInstanceHelper(boolean sub, OpenJPAEntityManager em,\r\n-        UnenhancedType un, UnenhancedType copy, boolean viaClone) {\r\n-        assertNotSame(un, copy);\r\n-        if (!viaClone)\r\n-            assertEquals(sub ? getUnenhancedSubclass() : getUnenhancedClass(),\r\n-                copy.getClass());\r\n-        assertEquals(un.getId(), copy.getId());\r\n-        assertEquals(un.getStringField(), copy.getStringField());\r\n-        if (sub) {\r\n-            assertEquals(\r\n-                ((UnenhancedSubtype) un).getIntField(),\r\n-                ((UnenhancedSubtype) copy).getIntField());\r\n-            assertNotSame(\r\n-                ((UnenhancedSubtype) un).getRelated(),\r\n-                ((UnenhancedSubtype) copy).getRelated());\r\n-            assertEquals(\r\n-                ((UnenhancedSubtype) un).getRelated().getId(),\r\n-                ((UnenhancedSubtype) copy).getRelated().getId());\r\n-        }\r\n-\r\n-        assertFalse(em.isDetached(un));\r\n-        assertTrue(em.isDetached(copy));\r\n-        copy.setStringField(\"offline update\");\r\n-\r\n-        em.getTransaction().begin();\r\n-        assertSame(un, em.merge(copy));\r\n-        assertTrue(em.isDirty(un));\r\n-        assertEquals(\"offline update\", un.getStringField());\r\n-        em.getTransaction().commit();\r\n-    }\r\n-\r\n-    public void testListenersOnUserDefinedInstance()\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        listenerHelper(true, false);\r\n-    }\r\n-\r\n-    public void testListenersOnUserDefinedSubclassInstance()\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        listenerHelper(true, true);\r\n-    }\r\n-\r\n-    public void testListenersOnOpenJPADefinedInstance()\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        listenerHelper(false, false);\r\n-    }\r\n-\r\n-    public void testListenersOnOpenJPADefinedSubclassInstance()\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        listenerHelper(false, true);\r\n-    }\r\n-\r\n-    private void listenerHelper(boolean userDefined, boolean sub)\r\n-        throws IOException, ClassNotFoundException, CloneNotSupportedException {\r\n-        ListenerImpl listener = new ListenerImpl();\r\n-        emf.addLifecycleListener(listener, (Class[]) null);\r\n-        OpenJPAEntityManager em = emf.createEntityManager();\r\n-        UnenhancedType un = newInstance(sub);\r\n-        em.getTransaction().begin();\r\n-        em.persist(un);\r\n-        em.getTransaction().commit();\r\n-\r\n-        if (!userDefined) {\r\n-            em.close();\r\n-            em = emf.createEntityManager();\r\n-        }\r\n-\r\n-        listener.invoked = false;\r\n-\r\n-        un = em.find(getUnenhancedClass(), un.getId());\r\n-        em.getTransaction().begin();\r\n-        un.setStringField(\"updated\");\r\n-        em.getTransaction().commit();\r\n-        assertTrue(listener.invoked);\r\n-        em.close();\r\n-\r\n-        assertEquals(\"updated\", listener.stringField);\r\n-    }\r\n-\r\n-    public void testGetMetaDataOfSubtype() {\r\n-        ClassMetaData meta = JPAFacadeHelper.getMetaData(emf,\r\n-            getUnenhancedClass());\r\n-        List<Class> subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\r\n-            emf.getConfiguration(),\r\n-            Collections.singleton(getUnenhancedClass()), null);\r\n-        assertSame(meta, JPAFacadeHelper.getMetaData(emf, subs.get(0)));\r\n-\r\n-        meta = JPAFacadeHelper.getMetaData(emf, getUnenhancedSubclass());\r\n-        subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\r\n-            emf.getConfiguration(),\r\n-            Collections.singleton(getUnenhancedSubclass()), null);\r\n-        assertSame(meta, JPAFacadeHelper.getMetaData(emf, subs.get(0)));\r\n-    }\r\n-\r\n-    private class ListenerImpl\r\n-        extends AbstractLifecycleListener {\r\n-\r\n-        String stringField;\r\n-        boolean invoked;\r\n-\r\n-        @Override\r\n-        public void afterStore(LifecycleEvent event) {\r\n-            invoked = true;\r\n-            stringField = ((UnenhancedType) event.getSource()).getStringField();\r\n-        }\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.io.IOException;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ByteArrayInputStream;\n+import java.util.List;\n+import java.util.Collections;\n+import java.lang.reflect.Field;\n+\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\n+import org.apache.openjpa.persistence.JPAFacadeHelper;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.util.ImplHelper;\n+import org.apache.openjpa.event.AbstractLifecycleListener;\n+import org.apache.openjpa.event.LifecycleEvent;\n+\n+public abstract class AbstractUnenhancedClassTest\n+    extends SingleEMFTestCase {\n+\n+    // ##### To do:\n+    // - clearing in pnew property-access without redefinition\n+    // - figure out how to auto-test the redefinition code, either in Java 5\n+    //   or in Java 6\n+    // - run CTS in the following combinations:\n+    //   * Java 6\n+    //   * Java 5 with javaagent\n+    //   * Java 5 without javaagent\n+\n+    public void setUp() {\n+        setUp(getUnenhancedClass(), getUnenhancedSubclass(), CLEAR_TABLES);\n+        // trigger class redefinition\n+        emf.createEntityManager().close();\n+    }\n+\n+    protected abstract Class<? extends UnenhancedType> getUnenhancedClass();\n+\n+    protected abstract UnenhancedType newUnenhancedInstance();\n+\n+    protected abstract Class<? extends UnenhancedSubtype> getUnenhancedSubclass();\n+\n+    protected abstract UnenhancedSubtype newUnenhancedSubclassInstance();\n+\n+    private UnenhancedType newInstance(boolean sub) {\n+        return sub ? newUnenhancedSubclassInstance()\n+            : newUnenhancedInstance();\n+    }\n+\n+    public void testMetaData() {\n+        ClassMetaData meta = JPAFacadeHelper.getMetaData(emf,\n+            getUnenhancedClass());\n+        assertEquals(ClassRedefiner.canRedefineClasses(),\n+            meta.isIntercepting());\n+    }\n+\n+    public void testImplHelperCalls() {\n+        assertTrue(ImplHelper.isManagedType(null, getUnenhancedClass()));\n+\n+        UnenhancedType un = newUnenhancedInstance();\n+        assertFalse(un instanceof PersistenceCapable);\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(un,\n+            emf.getConfiguration());\n+        assertNotNull(pc);\n+        assertTrue(ImplHelper.isManageable(un));\n+    }\n+\n+    public void testBasicPersistenceCapableBehavior() {\n+        UnenhancedType un = newUnenhancedInstance();\n+        un.setStringField(\"bar\");\n+        PersistenceCapable pc = ImplHelper.toPersistenceCapable(un,\n+            emf.getConfiguration());\n+        assertFalse(pc.pcIsDeleted());\n+        assertFalse(pc.pcIsDirty());\n+        assertFalse(pc.pcIsNew());\n+        assertFalse(pc.pcIsPersistent());\n+        assertFalse(pc.pcIsTransactional());\n+    }\n+\n+    public void testPCRegistry() {\n+        assertTrue(PCRegistry.isRegistered(getUnenhancedClass()));\n+        PersistenceCapable pc = PCRegistry.newInstance(\n+            getUnenhancedClass(), null, false);\n+        assertNotNull(pc);\n+    }\n+\n+    public void testClearingOnSubtypeInstance() {\n+        // the boolean at the end of newInstance will cause clear to be invoked\n+        UnenhancedType un = (UnenhancedType)\n+            PCRegistry.newInstance(getUnenhancedClass(), null, true);\n+        assertEquals(null, un.getStringField());\n+    }\n+\n+    public void testGetObjectIdOnOpenJPAType() {\n+        getObjectIdHelper(true, false);\n+    }\n+\n+    public void testGetObjectIdOnOpenJPATypeSubclass() {\n+        getObjectIdHelper(false, false);\n+    }\n+\n+    public void testGetObjectIdOnUserDefined() {\n+        getObjectIdHelper(true, true);\n+    }\n+\n+    public void testGetObjectIdOnUserDefinedSubclass() {\n+        getObjectIdHelper(false, true);\n+    }\n+\n+    private void getObjectIdHelper(boolean sub, boolean userDefined) {\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        UnenhancedType un = newInstance(sub);\n+        em.persist(un);\n+        em.getTransaction().commit();\n+\n+        if (!userDefined) {\n+            em.close();\n+            em = emf.createEntityManager();\n+            un = em.find(getUnenhancedClass(), un.getId());\n+        }\n+\n+        assertNotNull(em.getObjectId(un));\n+    }\n+\n+    public void testOperationsOnUserDefined() {\n+        opsHelper(false, true);\n+    }\n+\n+    public void testSubclassOperationsOnUserDefined() {\n+        opsHelper(true, true);\n+    }\n+\n+    public void testOperationsOnOpenJPADefined() {\n+        opsHelper(false, false);\n+    }\n+\n+    public void testSubclassOperationsOnOpenJPADefined() {\n+        opsHelper(true, false);\n+    }\n+\n+    private void opsHelper(boolean sub, boolean userDefined) {\n+        OpenJPAEntityManager em = null;\n+        try {\n+            UnenhancedType un = newInstance(sub);\n+            em = emf.createEntityManager();\n+\n+            em.getTransaction().begin();\n+            em.persist(un);\n+            un.setStringField(\"bar\");\n+            assertEquals(\"bar\", un.getStringField());\n+            assertPersistenceContext(em, un, true, true, sub);\n+            em.flush();\n+            assertPersistenceContext(em, un, true, true, sub);\n+            assertTrue(un.getId() != 0);\n+            UnenhancedType un2 = em.find(getUnenhancedClass(), un.getId());\n+            assertSame(un, un2);\n+            em.getTransaction().commit();\n+            assertPersistenceContext(em, un, false, false, sub);\n+            un2 = em.find(getUnenhancedClass(), un.getId());\n+            assertSame(un, un2);\n+\n+            if (!userDefined) {\n+                em.close();\n+                em = emf.createEntityManager();\n+            }\n+\n+            un = em.find(getUnenhancedClass(), un.getId());\n+            assertNotNull(un);\n+            if (!userDefined)\n+                assertTrue(un instanceof PersistenceCapable);\n+            assertEquals(\"bar\", un.getStringField());\n+            em.getTransaction().begin();\n+            un.setStringField(\"baz\");\n+            assertPersistenceContext(em, un, true, true, sub);\n+            assertEquals(\"baz\", un.getStringField());\n+\n+            if (sub)\n+                ((UnenhancedSubtype) un).setIntField(17);\n+\n+            assertTrue(em.isDirty(un));\n+            \n+            em.getTransaction().commit();\n+\n+            // make sure that the values are still up-to-date after\n+            // the commit happens\n+            assertEquals(\"baz\", un.getStringField());\n+            \n+            em.close();\n+\n+            em = emf.createEntityManager();\n+            un = em.find(getUnenhancedClass(), un.getId());\n+            assertNotNull(un);\n+            assertTrue(un instanceof PersistenceCapable);\n+            assertEquals(\"baz\", un.getStringField());\n+            if (sub)\n+                assertEquals(17, ((UnenhancedSubtype) un).getIntField());\n+            em.close();\n+        } finally {\n+            if (em != null && em.getTransaction().isActive())\n+                em.getTransaction().rollback();\n+            if (em != null && em.isOpen())\n+                em.close();\n+        }\n+    }\n+\n+    private void assertPersistenceContext(OpenJPAEntityManager em,\n+        UnenhancedType un, boolean transactional, boolean dirty, boolean sub) {\n+        assertEquals(transactional, em.getTransactionalObjects().contains(un));\n+        assertEquals(dirty, em.getDirtyObjects().contains(un));\n+        if (dirty) {\n+            Class cls = sub ? getUnenhancedSubclass() : getUnenhancedClass();\n+            assertTrue(em.getUpdatedClasses().contains(cls)\n+                || em.getPersistedClasses().contains(cls));\n+        }\n+    }\n+\n+    public void testRelations() {\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        UnenhancedSubtype un = newUnenhancedSubclassInstance();\n+        em.persist(un);\n+        un.setStringField(\"aoeu\");\n+        UnenhancedSubtype related = newUnenhancedSubclassInstance();\n+        un.setRelated(related);\n+        related.setStringField(\"snth\");\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        em = emf.createEntityManager();\n+        un = (UnenhancedSubtype) em.find(getUnenhancedClass(), un.getId());\n+        assertEquals(\"aoeu\", un.getStringField());\n+        assertNotNull(un.getRelated());\n+        assertEquals(\"snth\", un.getRelated().getStringField());\n+        em.close();\n+    }\n+\n+    public void testEnhancer() throws IOException {\n+        List<Class> subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\n+            emf.getConfiguration(),\n+            Collections.singleton(getUnenhancedClass()), null);\n+        Class sub = subs.get(0);\n+        assertNotNull(sub);\n+        assertEquals(\"org.apache.openjpa.enhance.\"\n+            + getUnenhancedClass().getName().replace('.', '$') + \"$pcsubclass\",\n+            sub.getName());\n+        assertTrue(PersistenceCapable.class.isAssignableFrom(sub));\n+        assertTrue(getUnenhancedClass().isAssignableFrom(sub));\n+    }\n+\n+    public void testPCSubclassName() {\n+        assertEquals(\"org.apache.openjpa.enhance.\"\n+            + getUnenhancedClass().getName().replace('.', '$') + \"$pcsubclass\",\n+            PCEnhancer.toPCSubclassName(getUnenhancedClass()));\n+    }\n+\n+    public void testEvictionInUserCreatedInstance()\n+        throws NoSuchFieldException, IllegalAccessException {\n+        evictionHelper(true);\n+    }\n+\n+    public void testEvictionInOpenJPACreatedInstance()\n+        throws NoSuchFieldException, IllegalAccessException {\n+        evictionHelper(false);\n+    }\n+\n+    private void evictionHelper(boolean userDefined)\n+        throws NoSuchFieldException, IllegalAccessException {\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        UnenhancedType un = newUnenhancedInstance();\n+        em.getTransaction().begin();\n+        em.persist(un);\n+        em.getTransaction().commit();\n+\n+        if (!userDefined) {\n+            em.close();\n+            em = emf.createEntityManager();\n+            un = em.find(getUnenhancedClass(), un.getId());\n+            assertTrue(getUnenhancedClass() != un.getClass());\n+        }\n+\n+        em.evict(un);\n+        OpenJPAStateManager sm = (OpenJPAStateManager)\n+            ImplHelper.toPersistenceCapable(un, null).pcGetStateManager();\n+\n+        // we only expect lazy loading to work when we can redefine classes\n+        // or when accessing a property-access record that OpenJPA created.\n+        if (ClassRedefiner.canRedefineClasses()\n+            || (!userDefined && sm.getMetaData().getAccessType()\n+                != ClassMetaData.ACCESS_FIELD)) {\n+\n+            assertFalse(sm.getLoaded()\n+                .get(sm.getMetaData().getField(\"stringField\").getIndex()));\n+\n+            // make sure that the value was cleared...\n+            Field field = getUnenhancedClass().getDeclaredField(\n+                isFieldAccessTest() ? \"stringField\" : \"sf\");\n+            field.setAccessible(true);\n+            assertEquals(null, field.get(un));\n+\n+            // ... and that it gets reloaded properly\n+            assertEquals(\"foo\", un.getStringField());\n+            assertTrue(sm.getLoaded()\n+                .get(sm.getMetaData().getField(\"stringField\").getIndex()));\n+        } else {\n+            // unredefined properties with user-defined instance, or any\n+            // unredefined field access\n+            assertTrue(sm.getLoaded()\n+                .get(sm.getMetaData().getField(\"stringField\").getIndex()));\n+\n+            // make sure that the value was not cleared\n+            Field field = getUnenhancedClass().getDeclaredField(\n+                isFieldAccessTest() ? \"stringField\" : \"sf\");\n+            field.setAccessible(true);\n+            assertEquals(\"foo\", field.get(un));\n+        }\n+\n+        em.close();\n+    }\n+\n+    protected abstract boolean isFieldAccessTest();\n+\n+    public void testLazyLoading()\n+        throws NoSuchFieldException, IllegalAccessException {\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        UnenhancedType un = newUnenhancedInstance();\n+        em.getTransaction().begin();\n+        em.persist(un);\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        em = emf.createEntityManager();\n+        un = em.find(getUnenhancedClass(), un.getId());\n+        assertTrue(getUnenhancedClass() != un.getClass());\n+        OpenJPAStateManager sm = (OpenJPAStateManager)\n+            ImplHelper.toPersistenceCapable(un, null).pcGetStateManager();\n+\n+        // we only expect lazy loading to work when we can redefine classes\n+        // or when accessing a property-access record that OpenJPA created.\n+        if (ClassRedefiner.canRedefineClasses()\n+            || (sm.getMetaData().getAccessType() != ClassMetaData.ACCESS_FIELD))\n+        {\n+            assertFalse(sm.getLoaded()\n+                .get(sm.getMetaData().getField(\"lazyField\").getIndex()));\n+\n+            // make sure that the value was cleared\n+            Field field = getUnenhancedClass().getDeclaredField(\"lazyField\");\n+            field.setAccessible(true);\n+            assertEquals(null, field.get(un));\n+        } else {\n+            // unredefined field access\n+            assertTrue(sm.getLoaded()\n+                .get(sm.getMetaData().getField(\"lazyField\").getIndex()));\n+\n+            // make sure that the value was loaded already\n+            Field field = getUnenhancedClass().getDeclaredField(\"lazyField\");\n+            field.setAccessible(true);\n+            assertEquals(\"lazy\", field.get(un));\n+        }\n+\n+        // make sure that the value is available, one way or another\n+        assertEquals(\"lazy\", un.getLazyField());\n+        assertTrue(sm.getLoaded()\n+            .get(sm.getMetaData().getField(\"lazyField\").getIndex()));\n+\n+        em.close();\n+    }\n+\n+    public void testSerializationOfUserDefinedInstance()\n+        throws IOException, ClassNotFoundException {\n+        serializationHelper(true, false);\n+    }\n+\n+    public void testSerializationOfUserDefinedSubclassInstance()\n+        throws IOException, ClassNotFoundException {\n+        serializationHelper(true, true);\n+    }\n+\n+    public void testSerializationOfOpenJPADefinedInstance()\n+        throws IOException, ClassNotFoundException {\n+        serializationHelper(false, false);\n+    }\n+\n+    public void testSerializationOfOpenJPADefinedSubclassInstance()\n+        throws IOException, ClassNotFoundException {\n+        serializationHelper(false, true);\n+    }\n+\n+    private void serializationHelper(boolean userDefined, boolean sub)\n+        throws IOException, ClassNotFoundException {\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        UnenhancedType un = newInstance(sub);\n+        em.getTransaction().begin();\n+        em.persist(un);\n+\n+        if (sub) {\n+            UnenhancedType related = newInstance(false);\n+            related.setStringField(\"related\");\n+            ((UnenhancedSubtype) un).setRelated(related);\n+        }\n+\n+        em.getTransaction().commit();\n+\n+        if (!userDefined) {\n+            em.close();\n+            em = emf.createEntityManager();\n+        }\n+\n+        un = em.find(getUnenhancedClass(), un.getId());\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        ObjectOutputStream oout = new ObjectOutputStream(out);\n+        oout.writeObject(un);\n+        oout.flush();\n+        byte[] bytes = out.toByteArray();\n+\n+        ObjectInputStream oin = new ObjectInputStream(\n+            new ByteArrayInputStream(bytes));\n+        UnenhancedType deserialized = (UnenhancedType) oin.readObject();\n+\n+        copiedInstanceHelper(sub, em, un, deserialized, false);\n+        em.close();\n+    }\n+\n+    public void testCloningOfUserDefinedInstance()\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        cloneHelper(true, false);\n+    }\n+\n+    public void testCloningOfUserDefinedSubclassInstance()\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        cloneHelper(true, true);\n+    }\n+\n+    public void testCloningOfOpenJPADefinedInstance()\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        cloneHelper(false, false);\n+    }\n+\n+    public void testCloningOfOpenJPADefinedSubclassInstance()\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        cloneHelper(false, true);\n+    }\n+\n+    private void cloneHelper(boolean userDefined, boolean sub)\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        UnenhancedType un = newInstance(sub);\n+        em.getTransaction().begin();\n+        em.persist(un);\n+\n+        if (sub) {\n+            UnenhancedType related = newInstance(false);\n+            related.setStringField(\"related\");\n+            ((UnenhancedSubtype) un).setRelated(related);\n+        }\n+\n+        em.getTransaction().commit();\n+\n+        if (!userDefined) {\n+            em.close();\n+            em = emf.createEntityManager();\n+        }\n+\n+        un = em.find(getUnenhancedClass(), un.getId());\n+        UnenhancedType cloned = (UnenhancedType) un.clone();\n+\n+        copiedInstanceHelper(sub, em, un, cloned, true);\n+        em.close();\n+    }\n+\n+    private void copiedInstanceHelper(boolean sub, OpenJPAEntityManager em,\n+        UnenhancedType un, UnenhancedType copy, boolean viaClone) {\n+        assertNotSame(un, copy);\n+        if (!viaClone)\n+            assertEquals(sub ? getUnenhancedSubclass() : getUnenhancedClass(),\n+                copy.getClass());\n+        assertEquals(un.getId(), copy.getId());\n+        assertEquals(un.getStringField(), copy.getStringField());\n+        if (sub) {\n+            assertEquals(\n+                ((UnenhancedSubtype) un).getIntField(),\n+                ((UnenhancedSubtype) copy).getIntField());\n+            assertNotSame(\n+                ((UnenhancedSubtype) un).getRelated(),\n+                ((UnenhancedSubtype) copy).getRelated());\n+            assertEquals(\n+                ((UnenhancedSubtype) un).getRelated().getId(),\n+                ((UnenhancedSubtype) copy).getRelated().getId());\n+        }\n+\n+        assertFalse(em.isDetached(un));\n+        assertTrue(em.isDetached(copy));\n+        copy.setStringField(\"offline update\");\n+\n+        em.getTransaction().begin();\n+        assertSame(un, em.merge(copy));\n+        assertTrue(em.isDirty(un));\n+        assertEquals(\"offline update\", un.getStringField());\n+        em.getTransaction().commit();\n+    }\n+\n+    public void testListenersOnUserDefinedInstance()\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        listenerHelper(true, false);\n+    }\n+\n+    public void testListenersOnUserDefinedSubclassInstance()\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        listenerHelper(true, true);\n+    }\n+\n+    public void testListenersOnOpenJPADefinedInstance()\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        listenerHelper(false, false);\n+    }\n+\n+    public void testListenersOnOpenJPADefinedSubclassInstance()\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        listenerHelper(false, true);\n+    }\n+\n+    private void listenerHelper(boolean userDefined, boolean sub)\n+        throws IOException, ClassNotFoundException, CloneNotSupportedException {\n+        ListenerImpl listener = new ListenerImpl();\n+        emf.addLifecycleListener(listener, (Class[]) null);\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        UnenhancedType un = newInstance(sub);\n+        em.getTransaction().begin();\n+        em.persist(un);\n+        em.getTransaction().commit();\n+\n+        if (!userDefined) {\n+            em.close();\n+            em = emf.createEntityManager();\n+        }\n+\n+        listener.invoked = false;\n+\n+        un = em.find(getUnenhancedClass(), un.getId());\n+        em.getTransaction().begin();\n+        un.setStringField(\"updated\");\n+        em.getTransaction().commit();\n+        assertTrue(listener.invoked);\n+        em.close();\n+\n+        assertEquals(\"updated\", listener.stringField);\n+    }\n+\n+    public void testGetMetaDataOfSubtype() {\n+        ClassMetaData meta = JPAFacadeHelper.getMetaData(emf,\n+            getUnenhancedClass());\n+        List<Class> subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\n+            emf.getConfiguration(),\n+            Collections.singleton(getUnenhancedClass()), null);\n+        assertSame(meta, JPAFacadeHelper.getMetaData(emf, subs.get(0)));\n+\n+        meta = JPAFacadeHelper.getMetaData(emf, getUnenhancedSubclass());\n+        subs =  ManagedClassSubclasser.prepareUnenhancedClasses(\n+            emf.getConfiguration(),\n+            Collections.singleton(getUnenhancedSubclass()), null);\n+        assertSame(meta, JPAFacadeHelper.getMetaData(emf, subs.get(0)));\n+    }\n+\n+    private class ListenerImpl\n+        extends AbstractLifecycleListener {\n+\n+        String stringField;\n+        boolean invoked;\n+\n+        @Override\n+        public void afterStore(LifecycleEvent event) {\n+            invoked = true;\n+            stringField = ((UnenhancedType) event.getSource()).getStringField();\n+        }\n+    }\n }\n\\ No newline at end of file"},{"sha":"c3ab5d217aed21ba58efb48c0555c60f8e5d360b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java","status":"modified","additions":54,"deletions":54,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,55 +1,55 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.util.List;\r\n-import javax.persistence.EntityManager;\r\n-\r\n-import org.apache.openjpa.persistence.OpenJPAEntityManager;\r\n-import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n-\r\n-public class TestDataCachingAndUnenhancedPropertyAccess\r\n-    extends SingleEMFTestCase {\r\n-\r\n-    @Override\r\n-    public void setUp() {\r\n-        setUp(UnenhancedIdentityIdPropertyAccess.class, CLEAR_TABLES,\r\n-            \"openjpa.DataCache\", \"true\",\r\n-            \"openjpa.RemoteCommitProvider\", \"sjvm\");\r\n-    }\r\n-\r\n-    public void testSimpleDataCacheOperation() {\r\n-        EntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        em.persist(new UnenhancedIdentityIdPropertyAccess());\r\n-        em.getTransaction().commit();\r\n-        em.close();\r\n-    }\r\n-\r\n-    public void testAccessIdBeforeCommit() {\r\n-        OpenJPAEntityManager em = emf.createEntityManager();\r\n-        em.getTransaction().begin();\r\n-        UnenhancedIdentityIdPropertyAccess o =\r\n-            new UnenhancedIdentityIdPropertyAccess();\r\n-        em.persist(o);\r\n-        em.getObjectId(o);\r\n-        em.getTransaction().commit();\r\n-        em.close();\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.util.List;\n+import javax.persistence.EntityManager;\n+\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+\n+public class TestDataCachingAndUnenhancedPropertyAccess\n+    extends SingleEMFTestCase {\n+\n+    @Override\n+    public void setUp() {\n+        setUp(UnenhancedIdentityIdPropertyAccess.class, CLEAR_TABLES,\n+            \"openjpa.DataCache\", \"true\",\n+            \"openjpa.RemoteCommitProvider\", \"sjvm\");\n+    }\n+\n+    public void testSimpleDataCacheOperation() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        em.persist(new UnenhancedIdentityIdPropertyAccess());\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    public void testAccessIdBeforeCommit() {\n+        OpenJPAEntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        UnenhancedIdentityIdPropertyAccess o =\n+            new UnenhancedIdentityIdPropertyAccess();\n+        em.persist(o);\n+        em.getObjectId(o);\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n }\n\\ No newline at end of file"},{"sha":"4348b23b976d9c8a7f360eb57a57167c8add4f8c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java","status":"modified","additions":44,"deletions":44,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,45 +1,45 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import javax.persistence.EntityManager;\r\n-\r\n-import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-\r\n-public class TestEnhancementConfiguration\r\n-    extends SingleEMFTestCase {\r\n-\r\n-    public void testEnhancementConfiguration() {\r\n-        try {\r\n-            emf = createEMF(\r\n-                \"openjpa.RuntimeUnenhancedClasses\", \"unsupported\",\r\n-                UnenhancedFieldAccess.class, CLEAR_TABLES);\r\n-            assertFalse(ImplHelper.isManagedType(emf.getConfiguration(),\r\n-                UnenhancedFieldAccess.class));\r\n-            emf.createEntityManager().close();\r\n-            fail(\"should not be possible to fully-initialize a system \" +\r\n-                \"that depends on unenhanced types but disables runtime\" +\r\n-                \"redefinition.\");\r\n-        } catch (Exception e) {\r\n-            assertTrue(e.getMessage().contains(\r\n-                \"This configuration disallows runtime optimization\"));\r\n-        }\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import javax.persistence.EntityManager;\n+\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+import org.apache.openjpa.util.ImplHelper;\n+\n+public class TestEnhancementConfiguration\n+    extends SingleEMFTestCase {\n+\n+    public void testEnhancementConfiguration() {\n+        try {\n+            emf = createEMF(\n+                \"openjpa.RuntimeUnenhancedClasses\", \"unsupported\",\n+                UnenhancedFieldAccess.class, CLEAR_TABLES);\n+            assertFalse(ImplHelper.isManagedType(emf.getConfiguration(),\n+                UnenhancedFieldAccess.class));\n+            emf.createEntityManager().close();\n+            fail(\"should not be possible to fully-initialize a system \" +\n+                \"that depends on unenhanced types but disables runtime\" +\n+                \"redefinition.\");\n+        } catch (Exception e) {\n+            assertTrue(e.getMessage().contains(\n+                \"This configuration disallows runtime optimization\"));\n+        }\n+    }\n }\n\\ No newline at end of file"},{"sha":"44077384fc3daa7e93cb4052d0648cdaf87e143e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java","status":"modified","additions":46,"deletions":46,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,46 +1,46 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import junit.framework.TestCase;\r\n-import serp.bytecode.BCClass;\r\n-import serp.bytecode.BCField;\r\n-import serp.bytecode.BCMethod;\r\n-import serp.bytecode.Project;\r\n-\r\n-public class TestPCEnhancerFindField\r\n-    extends TestCase {\r\n-\r\n-    private String field;\r\n-\r\n-    public String myMethod() {\r\n-        if (Math.abs(1) == 1)\r\n-            return field;\r\n-        else\r\n-            return field;\r\n-    }\r\n-\r\n-    public void testPCEnhancerFindField() {\r\n-        Project proj = new Project();\r\n-        BCClass bc = proj.loadClass(getClass());\r\n-        BCMethod meth = bc.getMethods(\"myMethod\")[0];\r\n-        BCField field = PCEnhancer.getReturnedField(meth);\r\n-        assertEquals(\"field\", field.getName());\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import junit.framework.TestCase;\n+import serp.bytecode.BCClass;\n+import serp.bytecode.BCField;\n+import serp.bytecode.BCMethod;\n+import serp.bytecode.Project;\n+\n+public class TestPCEnhancerFindField\n+    extends TestCase {\n+\n+    private String field;\n+\n+    public String myMethod() {\n+        if (Math.abs(1) == 1)\n+            return field;\n+        else\n+            return field;\n+    }\n+\n+    public void testPCEnhancerFindField() {\n+        Project proj = new Project();\n+        BCClass bc = proj.loadClass(getClass());\n+        BCMethod meth = bc.getMethods(\"myMethod\")[0];\n+        BCField field = PCEnhancer.getReturnedField(meth);\n+        assertEquals(\"field\", field.getName());\n+    }\n+}"},{"sha":"677d1d81481dca64b2498baf20bdcf2f53dd8f7e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java","status":"modified","additions":37,"deletions":37,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,38 +1,38 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n-\r\n-public class TestRelationToUnlistedClass\r\n-    extends SingleEMFTestCase {\r\n-\r\n-    public void setUp() {\r\n-        setUp(UnenhancedUnlistedReferer.class, CLEAR_TABLES);\r\n-    }\r\n-\r\n-    public void testRelationToUnlistedClass() {\r\n-        try {\r\n-            emf.createEntityManager().close();\r\n-            fail(\"should not be able to initialize system\");\r\n-        } catch (Exception e) {\r\n-            assertTrue(e.getMessage().startsWith(\"One or more of the types\"));\r\n-        }\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+\n+public class TestRelationToUnlistedClass\n+    extends SingleEMFTestCase {\n+\n+    public void setUp() {\n+        setUp(UnenhancedUnlistedReferer.class, CLEAR_TABLES);\n+    }\n+\n+    public void testRelationToUnlistedClass() {\n+        try {\n+            emf.createEntityManager().close();\n+            fail(\"should not be able to initialize system\");\n+        } catch (Exception e) {\n+            assertTrue(e.getMessage().startsWith(\"One or more of the types\"));\n+        }\n+    }\n }\n\\ No newline at end of file"},{"sha":"36f3949ec4b1728119b9caaee47252435180e149","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","status":"modified","additions":74,"deletions":74,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,75 +1,75 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import org.apache.openjpa.persistence.test.SingleEMTestCase;\r\n-\r\n-public class TestUnenhancedCompoundPK\r\n-    extends SingleEMTestCase {\r\n-\r\n-    public void setUp() {\r\n-        setUp(UnenhancedCompoundPKFieldAccess.class,\r\n-            UnenhancedCompoundPKPropertyAccess.class, CLEAR_TABLES);\r\n-    }\r\n-\r\n-    public void testCompoundPKFieldAccessUserDefined() {\r\n-        UnenhancedCompoundPKFieldAccess un\r\n-            = new UnenhancedCompoundPKFieldAccess(17, 31);\r\n-        UnenhancedCompoundPKFieldAccess.PK oid\r\n-            = new UnenhancedCompoundPKFieldAccess.PK(17, 31);\r\n-        compoundPKHelper(un, oid, true);\r\n-    }\r\n-\r\n-    public void testCompoundPKFieldAccessOpenJPADefined() {\r\n-        UnenhancedCompoundPKFieldAccess un\r\n-            = new UnenhancedCompoundPKFieldAccess(17, 31);\r\n-        UnenhancedCompoundPKFieldAccess.PK oid\r\n-            = new UnenhancedCompoundPKFieldAccess.PK(17, 31);\r\n-        compoundPKHelper(un, oid, false);\r\n-    }\r\n-\r\n-    public void testCompoundPKPropertyAccessUserDefined() {\r\n-        UnenhancedCompoundPKPropertyAccess un\r\n-            = new UnenhancedCompoundPKPropertyAccess(17, 31);\r\n-        UnenhancedCompoundPKPropertyAccess.PK oid\r\n-            = new UnenhancedCompoundPKPropertyAccess.PK(17, 31);\r\n-        compoundPKHelper(un, oid, true);\r\n-    }\r\n-\r\n-    public void testCompoundPKPropertyAccessOpenJPADefined() {\r\n-        UnenhancedCompoundPKPropertyAccess un\r\n-            = new UnenhancedCompoundPKPropertyAccess(17, 31);\r\n-        UnenhancedCompoundPKPropertyAccess.PK oid\r\n-            = new UnenhancedCompoundPKPropertyAccess.PK(17, 31);\r\n-        compoundPKHelper(un, oid, false);\r\n-    }\r\n-\r\n-    private void compoundPKHelper(Object o, Object oid, boolean userDefined) {\r\n-        em.getTransaction().begin();\r\n-        em.persist(o);\r\n-        em.getTransaction().commit();\r\n-\r\n-        if (!userDefined) {\r\n-            em.close();\r\n-            em = emf.createEntityManager();\r\n-        }\r\n-\r\n-        em.find(o.getClass(), oid);\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import org.apache.openjpa.persistence.test.SingleEMTestCase;\n+\n+public class TestUnenhancedCompoundPK\n+    extends SingleEMTestCase {\n+\n+    public void setUp() {\n+        setUp(UnenhancedCompoundPKFieldAccess.class,\n+            UnenhancedCompoundPKPropertyAccess.class, CLEAR_TABLES);\n+    }\n+\n+    public void testCompoundPKFieldAccessUserDefined() {\n+        UnenhancedCompoundPKFieldAccess un\n+            = new UnenhancedCompoundPKFieldAccess(17, 31);\n+        UnenhancedCompoundPKFieldAccess.PK oid\n+            = new UnenhancedCompoundPKFieldAccess.PK(17, 31);\n+        compoundPKHelper(un, oid, true);\n+    }\n+\n+    public void testCompoundPKFieldAccessOpenJPADefined() {\n+        UnenhancedCompoundPKFieldAccess un\n+            = new UnenhancedCompoundPKFieldAccess(17, 31);\n+        UnenhancedCompoundPKFieldAccess.PK oid\n+            = new UnenhancedCompoundPKFieldAccess.PK(17, 31);\n+        compoundPKHelper(un, oid, false);\n+    }\n+\n+    public void testCompoundPKPropertyAccessUserDefined() {\n+        UnenhancedCompoundPKPropertyAccess un\n+            = new UnenhancedCompoundPKPropertyAccess(17, 31);\n+        UnenhancedCompoundPKPropertyAccess.PK oid\n+            = new UnenhancedCompoundPKPropertyAccess.PK(17, 31);\n+        compoundPKHelper(un, oid, true);\n+    }\n+\n+    public void testCompoundPKPropertyAccessOpenJPADefined() {\n+        UnenhancedCompoundPKPropertyAccess un\n+            = new UnenhancedCompoundPKPropertyAccess(17, 31);\n+        UnenhancedCompoundPKPropertyAccess.PK oid\n+            = new UnenhancedCompoundPKPropertyAccess.PK(17, 31);\n+        compoundPKHelper(un, oid, false);\n+    }\n+\n+    private void compoundPKHelper(Object o, Object oid, boolean userDefined) {\n+        em.getTransaction().begin();\n+        em.persist(o);\n+        em.getTransaction().commit();\n+\n+        if (!userDefined) {\n+            em.close();\n+            em = emf.createEntityManager();\n+        }\n+\n+        em.find(o.getClass(), oid);\n+    }\n }\n\\ No newline at end of file"},{"sha":"866bbc5bee6c06761bd90ff06e72babfc23f3f20","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java","status":"modified","additions":57,"deletions":57,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,57 +1,57 @@\n-/**\r\n- *\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *     http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- *  See the License for the specific language governing permissions and\r\n- *  limitations under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import org.apache.openjpa.persistence.test.SingleEMTestCase;\r\n-\r\n-public class TestUnenhancedCompoundPKSubclass extends SingleEMTestCase {\r\n-\r\n-    public void setUp() {\r\n-        setUp(UnenhancedCompoundPKFieldAccessSuperclass.class,\r\n-            UnenhancedCompoundPKFieldAccessSubclass.class, CLEAR_TABLES);\r\n-    }\r\n-\r\n-    public void testCompoundPKFieldAccessUserDefined() {\r\n-        UnenhancedCompoundPKFieldAccessSuperclass un =\r\n-            new UnenhancedCompoundPKFieldAccessSubclass(17, 31);\r\n-        UnenhancedCompoundPKFieldAccessSuperclass.PK oid =\r\n-            new UnenhancedCompoundPKFieldAccessSuperclass.PK(17, 31);\r\n-        compoundPKHelper(un, oid, true);\r\n-    }\r\n-\r\n-    public void testCompoundPKFieldAccessOpenJPADefined() {\r\n-        UnenhancedCompoundPKFieldAccessSuperclass un =\r\n-            new UnenhancedCompoundPKFieldAccessSubclass(17, 31);\r\n-        UnenhancedCompoundPKFieldAccessSuperclass.PK oid =\r\n-            new UnenhancedCompoundPKFieldAccessSuperclass.PK(17, 31);\r\n-        compoundPKHelper(un, oid, false);\r\n-    }\r\n-\r\n-    private void compoundPKHelper(Object o, Object oid, boolean userDefined) {\r\n-        em.getTransaction().begin();\r\n-        em.persist(o);\r\n-        em.getTransaction().commit();\r\n-\r\n-        if (!userDefined) {\r\n-            em.close();\r\n-            em = emf.createEntityManager();\r\n-        }\r\n-\r\n-        em.find(o.getClass(), oid);\r\n-    }\r\n-}\r\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import org.apache.openjpa.persistence.test.SingleEMTestCase;\n+\n+public class TestUnenhancedCompoundPKSubclass extends SingleEMTestCase {\n+\n+    public void setUp() {\n+        setUp(UnenhancedCompoundPKFieldAccessSuperclass.class,\n+            UnenhancedCompoundPKFieldAccessSubclass.class, CLEAR_TABLES);\n+    }\n+\n+    public void testCompoundPKFieldAccessUserDefined() {\n+        UnenhancedCompoundPKFieldAccessSuperclass un =\n+            new UnenhancedCompoundPKFieldAccessSubclass(17, 31);\n+        UnenhancedCompoundPKFieldAccessSuperclass.PK oid =\n+            new UnenhancedCompoundPKFieldAccessSuperclass.PK(17, 31);\n+        compoundPKHelper(un, oid, true);\n+    }\n+\n+    public void testCompoundPKFieldAccessOpenJPADefined() {\n+        UnenhancedCompoundPKFieldAccessSuperclass un =\n+            new UnenhancedCompoundPKFieldAccessSubclass(17, 31);\n+        UnenhancedCompoundPKFieldAccessSuperclass.PK oid =\n+            new UnenhancedCompoundPKFieldAccessSuperclass.PK(17, 31);\n+        compoundPKHelper(un, oid, false);\n+    }\n+\n+    private void compoundPKHelper(Object o, Object oid, boolean userDefined) {\n+        em.getTransaction().begin();\n+        em.persist(o);\n+        em.getTransaction().commit();\n+\n+        if (!userDefined) {\n+            em.close();\n+            em = emf.createEntityManager();\n+        }\n+\n+        em.find(o.getClass(), oid);\n+    }\n+}"},{"sha":"1e69bf9170405d7cfe5dcc6cf5bcfdbaf565cc25","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","status":"modified","additions":43,"deletions":43,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,43 +1,43 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-public class TestUnenhancedFieldAccess\r\n-    extends AbstractUnenhancedClassTest {\r\n-\r\n-    protected Class<? extends UnenhancedType> getUnenhancedClass() {\r\n-        return UnenhancedFieldAccess.class;\r\n-    }\r\n-\r\n-    protected UnenhancedType newUnenhancedInstance() {\r\n-        return new UnenhancedFieldAccess();\r\n-    }\r\n-\r\n-    protected Class<? extends UnenhancedSubtype> getUnenhancedSubclass() {\r\n-        return UnenhancedFieldAccessSubclass.class;\r\n-    }\r\n-\r\n-    protected UnenhancedSubtype newUnenhancedSubclassInstance() {\r\n-        return new UnenhancedFieldAccessSubclass();\r\n-    }\r\n-\r\n-    protected boolean isFieldAccessTest() {\r\n-        return true;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+public class TestUnenhancedFieldAccess\n+    extends AbstractUnenhancedClassTest {\n+\n+    protected Class<? extends UnenhancedType> getUnenhancedClass() {\n+        return UnenhancedFieldAccess.class;\n+    }\n+\n+    protected UnenhancedType newUnenhancedInstance() {\n+        return new UnenhancedFieldAccess();\n+    }\n+\n+    protected Class<? extends UnenhancedSubtype> getUnenhancedSubclass() {\n+        return UnenhancedFieldAccessSubclass.class;\n+    }\n+\n+    protected UnenhancedSubtype newUnenhancedSubclassInstance() {\n+        return new UnenhancedFieldAccessSubclass();\n+    }\n+\n+    protected boolean isFieldAccessTest() {\n+        return true;\n+    }\n+}"},{"sha":"01b3294f53a3e05549e31cc2eb14f66c63943caf","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,42 +1,42 @@\n-/**\r\n- *\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *     http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- *  See the License for the specific language governing permissions and\r\n- *  limitations under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-public class TestUnenhancedFieldAccessPrimitiveWrapper\r\n-    extends AbstractUnenhancedClassTest {\r\n-\r\n-    protected Class<? extends UnenhancedType> getUnenhancedClass() {\r\n-        return UnenhancedFieldAccessPrimitiveWrapper.class;\r\n-    }\r\n-\r\n-    protected UnenhancedType newUnenhancedInstance() {\r\n-        return new UnenhancedFieldAccessPrimitiveWrapper();\r\n-    }\r\n-\r\n-    protected Class<? extends UnenhancedSubtype> getUnenhancedSubclass() {\r\n-        return UnenhancedFieldAccessPrimitiveWrapperSubclass.class;\r\n-    }\r\n-\r\n-    protected UnenhancedSubtype newUnenhancedSubclassInstance() {\r\n-        return new UnenhancedFieldAccessPrimitiveWrapperSubclass();\r\n-    }\r\n-\r\n-    protected boolean isFieldAccessTest() {\r\n-        return true;\r\n-    }\r\n-}\r\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+public class TestUnenhancedFieldAccessPrimitiveWrapper\n+    extends AbstractUnenhancedClassTest {\n+\n+    protected Class<? extends UnenhancedType> getUnenhancedClass() {\n+        return UnenhancedFieldAccessPrimitiveWrapper.class;\n+    }\n+\n+    protected UnenhancedType newUnenhancedInstance() {\n+        return new UnenhancedFieldAccessPrimitiveWrapper();\n+    }\n+\n+    protected Class<? extends UnenhancedSubtype> getUnenhancedSubclass() {\n+        return UnenhancedFieldAccessPrimitiveWrapperSubclass.class;\n+    }\n+\n+    protected UnenhancedSubtype newUnenhancedSubclassInstance() {\n+        return new UnenhancedFieldAccessPrimitiveWrapperSubclass();\n+    }\n+\n+    protected boolean isFieldAccessTest() {\n+        return true;\n+    }\n+}"},{"sha":"638018e5ac44a2effc583b577274faedc43e25dd","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","status":"modified","additions":42,"deletions":42,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,43 +1,43 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-public class TestUnenhancedPropertyAccess\r\n-    extends AbstractUnenhancedClassTest {\r\n-\r\n-    protected Class<? extends UnenhancedType> getUnenhancedClass() {\r\n-        return UnenhancedPropertyAccess.class;\r\n-    }\r\n-\r\n-    protected UnenhancedType newUnenhancedInstance() {\r\n-        return new UnenhancedPropertyAccess();\r\n-    }\r\n-\r\n-    protected Class<? extends UnenhancedSubtype> getUnenhancedSubclass() {\r\n-        return UnenhancedPropertyAccessSubclass.class;\r\n-    }\r\n-\r\n-    protected UnenhancedSubtype newUnenhancedSubclassInstance() {\r\n-        return new UnenhancedPropertyAccessSubclass();\r\n-    }\r\n-\r\n-    protected boolean isFieldAccessTest() {\r\n-        return false;\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+public class TestUnenhancedPropertyAccess\n+    extends AbstractUnenhancedClassTest {\n+\n+    protected Class<? extends UnenhancedType> getUnenhancedClass() {\n+        return UnenhancedPropertyAccess.class;\n+    }\n+\n+    protected UnenhancedType newUnenhancedInstance() {\n+        return new UnenhancedPropertyAccess();\n+    }\n+\n+    protected Class<? extends UnenhancedSubtype> getUnenhancedSubclass() {\n+        return UnenhancedPropertyAccessSubclass.class;\n+    }\n+\n+    protected UnenhancedSubtype newUnenhancedSubclassInstance() {\n+        return new UnenhancedPropertyAccessSubclass();\n+    }\n+\n+    protected boolean isFieldAccessTest() {\n+        return false;\n+    }\n }\n\\ No newline at end of file"},{"sha":"33298a5cf356431f08bd4f939007db1f2b045389","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","status":"modified","additions":87,"deletions":87,"changes":174,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,87 +1,87 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.IdClass;\r\n-import javax.persistence.Id;\r\n-\r\n-import org.apache.openjpa.enhance.UnenhancedCompoundPKFieldAccess.PK;\r\n-\r\n-@Entity\r\n-@IdClass(PK.class)\r\n-public class UnenhancedCompoundPKFieldAccess {\r\n-\r\n-    @Id private int id0;\r\n-    @Id private int id1;\r\n-\r\n-    protected UnenhancedCompoundPKFieldAccess() {\r\n-    }\r\n-\r\n-    public UnenhancedCompoundPKFieldAccess(\r\n-        int i0, int i1) {\r\n-        id0 = i0;\r\n-        id1 = i1;\r\n-    }\r\n-\r\n-    public static class PK {\r\n-        static {\r\n-            // register persistent class in JVM\r\n-            try {\r\n-                Class.forName(UnenhancedCompoundPKFieldAccess.class.getName());\r\n-            } catch (Exception e) {\r\n-                // ignore\r\n-            }\r\n-        }\r\n-\r\n-        public int id0;\r\n-        public int id1;\r\n-\r\n-        public PK() {\r\n-        }\r\n-\r\n-        public PK(int i0, int i1) {\r\n-            id0 = i0;\r\n-            id1 = i1;\r\n-        }\r\n-\r\n-        public String toString() {\r\n-            return String.valueOf(id0)\r\n-                + \"::\" + String.valueOf(id1);\r\n-        }\r\n-\r\n-        public int hashCode() {\r\n-            int rs = 17;\r\n-            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\r\n-            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\r\n-            return rs;\r\n-        }\r\n-\r\n-        public boolean equals(Object obj) {\r\n-            if(this == obj)\r\n-                return true;\r\n-            if(obj == null || obj.getClass() != getClass())\r\n-                return false;\r\n-\r\n-            PK other = (PK) obj;\r\n-            return (id0 == other.id0)\r\n-                && (id1 == other.id1);\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.IdClass;\n+import javax.persistence.Id;\n+\n+import org.apache.openjpa.enhance.UnenhancedCompoundPKFieldAccess.PK;\n+\n+@Entity\n+@IdClass(PK.class)\n+public class UnenhancedCompoundPKFieldAccess {\n+\n+    @Id private int id0;\n+    @Id private int id1;\n+\n+    protected UnenhancedCompoundPKFieldAccess() {\n+    }\n+\n+    public UnenhancedCompoundPKFieldAccess(\n+        int i0, int i1) {\n+        id0 = i0;\n+        id1 = i1;\n+    }\n+\n+    public static class PK {\n+        static {\n+            // register persistent class in JVM\n+            try {\n+                Class.forName(UnenhancedCompoundPKFieldAccess.class.getName());\n+            } catch (Exception e) {\n+                // ignore\n+            }\n+        }\n+\n+        public int id0;\n+        public int id1;\n+\n+        public PK() {\n+        }\n+\n+        public PK(int i0, int i1) {\n+            id0 = i0;\n+            id1 = i1;\n+        }\n+\n+        public String toString() {\n+            return String.valueOf(id0)\n+                + \"::\" + String.valueOf(id1);\n+        }\n+\n+        public int hashCode() {\n+            int rs = 17;\n+            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\n+            rs = rs * 37 + (int) (id0 ^ (id1 >>> 32));\n+            return rs;\n+        }\n+\n+        public boolean equals(Object obj) {\n+            if(this == obj)\n+                return true;\n+            if(obj == null || obj.getClass() != getClass())\n+                return false;\n+\n+            PK other = (PK) obj;\n+            return (id0 == other.id0)\n+                && (id1 == other.id1);\n+        }\n+    }\n+}"},{"sha":"f79a4c9b6e48486661631c90007b1a794cd5cedb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java","status":"modified","additions":34,"deletions":34,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67","patch":"@@ -1,34 +1,34 @@\n-/**\r\n- *\r\n- * Licensed to the Apache Software Foundation (ASF) under one or more\r\n- * contributor license agreements.  See the NOTICE file distributed with\r\n- * this work for additional information regarding copyright ownership.\r\n- * The ASF licenses this file to You under the Apache License, Version 2.0\r\n- * (the \"License\"); you may not use this file except in compliance with\r\n- * the License.  You may obtain a copy of the License at\r\n- *\r\n- *     http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- *  Unless required by applicable law or agreed to in writing, software\r\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- *  See the License for the specific language governing permissions and\r\n- *  limitations under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import javax.persistence.Entity;\r\n-import javax.persistence.IdClass;\r\n-\r\n-@Entity\r\n-@IdClass(UnenhancedCompoundPKFieldAccessSubclass.PK.class)\r\n-public class UnenhancedCompoundPKFieldAccessSubclass\r\n-    extends UnenhancedCompoundPKFieldAccessSuperclass {\r\n-\r\n-    public UnenhancedCompoundPKFieldAccessSubclass() {\r\n-    }\r\n-\r\n-    public UnenhancedCompoundPKFieldAccessSubclass(int i0, int i1) {\r\n-        super(i0, i1);\r\n-    }\r\n-}\r\n+/**\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.IdClass;\n+\n+@Entity\n+@IdClass(UnenhancedCompoundPKFieldAccessSubclass.PK.class)\n+public class UnenhancedCompoundPKFieldAccessSubclass\n+    extends UnenhancedCompoundPKFieldAccessSuperclass {\n+\n+    public UnenhancedCompoundPKFieldAccessSubclass() {\n+    }\n+\n+    public UnenhancedCompoundPKFieldAccessSubclass(int i0, int i1) {\n+        super(i0, i1);\n+    }\n+}"},{"sha":"0b101412e10ad756e28c4daf13e566277a434856","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"03e33912f6de6f6a27ba78fc31a9cd86f2c2b3ca","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","status":"modified","additions":122,"deletions":122,"changes":244,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"acfbaa2c3928a3f7646aa6f60d22acb2b42c6c51","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","status":"modified","additions":81,"deletions":81,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"31c009a84689d904afc140ea1f9bb69bf7af8cda","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java","status":"modified","additions":81,"deletions":81,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"d8780d021fbbfe217ff4712a3530da767e9728c9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java","status":"modified","additions":55,"deletions":55,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"ac928a6c7adaf9207f13a4dd18d4cb216a4cdd8e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"1044e0f3c99938d343149dab394caa6080d1362c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java","status":"modified","additions":55,"deletions":55,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"22efc08eed127653ccf7d9f0babf4c140e24a931","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","status":"modified","additions":96,"deletions":96,"changes":192,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"de4cfa30a848eba647d418771a08575506bceac7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","status":"modified","additions":60,"deletions":60,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"79331c7248bf9c206d7d10f68299054c65a06776","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","status":"modified","additions":31,"deletions":31,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"ef19b8f1ef93b8b12e96c6edee65fcab5c2e1789","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","status":"modified","additions":34,"deletions":34,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"5bca64e0d83fac455829c82d17728c7d79f9c039","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"b44ff2fedb2a7d4cdc7312509682e7c788748b82","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java","status":"modified","additions":32,"deletions":32,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"26f684183541e3b1f98b051f0cd1e291892b2dd5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java","status":"modified","additions":58,"deletions":58,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"d9172f21616f9858b8c256dda7bb474ab54be5ca","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java","status":"modified","additions":86,"deletions":86,"changes":172,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"77ed7187289d221aa425477eb377e373002a997d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java","status":"modified","additions":79,"deletions":79,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"0c9f8697b41b87115e18f0e3e912811f2669d46d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","status":"modified","additions":79,"deletions":79,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"36e7328d2d8d100873b8a268e01b1168bf1c1cbe","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","status":"modified","additions":81,"deletions":81,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"7239aace49a18303b4adaa5bcdb79aff82f39258","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","status":"modified","additions":90,"deletions":90,"changes":180,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"2ca371885c908f1027dcafafb364c7777cc1bda5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","status":"modified","additions":157,"deletions":157,"changes":314,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"f240d27db0a753ecef0458f3dd56a0579fddf673","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java","status":"modified","additions":54,"deletions":54,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"63dc8813a393366d422650aab0ce1188a5af5fd6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java","status":"modified","additions":76,"deletions":76,"changes":152,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"f6b9a378d1cd0db051afa7bfa5e9567ec445d715","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"6c680f396d953f78380404fb7c53026040fed2a4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java","status":"modified","additions":41,"deletions":41,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"ff573eff5db794e1a128e4f7209978da5c23005b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Artist.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Artist.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Artist.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Artist.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"8beb7ab736ea24ff0f777abb321cb8a5b19792d2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java","status":"modified","additions":51,"deletions":51,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"08c5920215ae8121adaee83d21602274327d6cdc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java","status":"modified","additions":103,"deletions":103,"changes":206,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"e1c413cf1ca7a42ed395e7f747ca2f6b13e87cca","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Item.java","status":"added","additions":110,"deletions":0,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Item.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Item.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Item.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"6326fb12e05103be11935ee00ac1efd00382db6d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Painter.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Painter.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Painter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Painter.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"fe7f17ea3e95b774098448eef593afe8be488e96","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Person.java","status":"added","additions":78,"deletions":0,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Person.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Person.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Person.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"cb95ab4434db06d54d6633f9f79e01598d94ab54","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestGetMetaData.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestGetMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestGetMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestGetMetaData.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"b78fe8d34b60149ceba969d635985fd299593a58","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java","status":"modified","additions":86,"deletions":94,"changes":180,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"7e2ff40fdb477b3e74c26720371599adaee92f95","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EmbedB.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EmbedB.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EmbedB.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EmbedB.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"704969aed3fc1c5ea26b7592f0a1b6f38374cedb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EntityA.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EntityA.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EntityA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EntityA.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"1b8c39bddc6218f755bb5c7e3edd3d9f298d825f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EntityA1.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EntityA1.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EntityA1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EntityA1.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"1ccf0f0fd41e1dafcfd27246edabae5545cbfc8a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EntityB.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EntityB.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EntityB.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EntityB.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"ca309bcaf83e6cd6faf82707eb20ea24db321977","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EntityC.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EntityC.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EntityC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/PColl_EntityC.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"ac0da4bbc9dbd9e55d70412c8af1acea1ab0fe16","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestPersistentCollection.java","status":"added","additions":117,"deletions":0,"changes":117,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestPersistentCollection.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestPersistentCollection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestPersistentCollection.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"05ed3493fdc58c53daa645febc953b936b41d33c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/EntityListenerEntity.java","status":"modified","additions":49,"deletions":49,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/EntityListenerEntity.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/EntityListenerEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/EntityListenerEntity.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"2b13764fba949b3424a444de42a01302ff964f61","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/GlobalListenerEntity.java","status":"modified","additions":49,"deletions":49,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/GlobalListenerEntity.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/GlobalListenerEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/GlobalListenerEntity.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"39ef5ea8a20dc9cb3f99473fa076cb127f478357","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerImpl.java","status":"modified","additions":73,"deletions":73,"changes":146,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerImpl.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"7d009a87d32d1172de6c9ff85930bc296bc81b12","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerTestEntity.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerTestEntity.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerTestEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ListenerTestEntity.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"e5151b9ab3e822cdfadd896209decc8cab86a109","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/Message.java","status":"added","additions":114,"deletions":0,"changes":114,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/Message.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/Message.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/Message.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"9141e1e71db3b8462b39608148726874eaf86313","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/MessageListenerImpl.java","status":"added","additions":102,"deletions":0,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/MessageListenerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/MessageListenerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/MessageListenerImpl.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"621180768fcf366cdd8521186941159331987896","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestEntityListeners.java","status":"modified","additions":114,"deletions":114,"changes":228,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestEntityListeners.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestEntityListeners.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestEntityListeners.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"7651622167fe903dfd85440b04e1baba2bcb516e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestMessageListeners.java","status":"added","additions":190,"deletions":0,"changes":190,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestMessageListeners.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestMessageListeners.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestMessageListeners.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"0f0561e29f72f26d59b04ada0437bf201260ef0b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/CompUser.java","status":"added","additions":112,"deletions":0,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/CompUser.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/CompUser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/common/apps/CompUser.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"5fa00056b2ed4b6af11592f9402bdaf1a3bd9a92","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/IdentityIdClass.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/IdentityIdClass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/IdentityIdClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/IdentityIdClass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"0c96a738d17013e3267c7222623365dc92b5134d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/Item.java","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/Item.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/Item.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/Item.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"48dfc2fe7009288899dba539b59b84abdae8e208","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/OptimisticLockInstance.java","status":"modified","additions":58,"deletions":58,"changes":116,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/OptimisticLockInstance.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/OptimisticLockInstance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/OptimisticLockInstance.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"8ef925649005c695d449ed399ab9d6242a47808b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/Order.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/Order.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/Order.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/Order.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"a028de59083985516fa2117d48fb530d95c0c216","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/Purchase.java","status":"added","additions":68,"deletions":0,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/Purchase.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/Purchase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/Purchase.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"becb017e968756a45cebaef05d610831e39f1bb5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestAutoIncrementAndDataCaching.java","status":"modified","additions":52,"deletions":52,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestAutoIncrementAndDataCaching.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestAutoIncrementAndDataCaching.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestAutoIncrementAndDataCaching.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"57e9fdfb3b940207b94ec8d605f7797cb5946392","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestBulkUpdatesAndVersionColumn.java","status":"modified","additions":108,"deletions":101,"changes":209,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestBulkUpdatesAndVersionColumn.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestBulkUpdatesAndVersionColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestBulkUpdatesAndVersionColumn.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"d47d99fd668175fea8e5f7055233328cfe94f110","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestCacheExclusions.java","status":"added","additions":233,"deletions":0,"changes":233,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestCacheExclusions.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestCacheExclusions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestCacheExclusions.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"d800ec33b215895d0d4ebbbcaa9da3e93bd64e56","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheOptimisticLockRecovery.java","status":"modified","additions":175,"deletions":175,"changes":350,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheOptimisticLockRecovery.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheOptimisticLockRecovery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestDataCacheOptimisticLockRecovery.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"1f4b77ba67bd8f5a74d25f8d8e8be4334437464e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestM2MInDataCache.java","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestM2MInDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestM2MInDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/TestM2MInDataCache.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"51a67304e6411540b0ec2603f0a6ee3fb807c0f5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/common/apps/M2MEntityE.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/common/apps/M2MEntityE.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/common/apps/M2MEntityE.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/common/apps/M2MEntityE.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"052bf790c90c9f6af28bc2462ad3462132dc420b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/common/apps/M2MEntityF.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/common/apps/M2MEntityF.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/common/apps/M2MEntityF.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/datacache/common/apps/M2MEntityF.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"2aea112c2ecd6542c97f915f0272fdccd00c4b3b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/DetachmentOneManyChild.java","status":"modified","additions":66,"deletions":66,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/DetachmentOneManyChild.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/DetachmentOneManyChild.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/DetachmentOneManyChild.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"7ba8a6ed5beeddc81bf5e37adfe1f89e45630dee","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/DetachmentOneManyParent.java","status":"modified","additions":63,"deletions":63,"changes":126,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/DetachmentOneManyParent.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/DetachmentOneManyParent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/DetachmentOneManyParent.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"f3cf4e3d4e1877a08b4011e473f4c930faf9fee2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/discriminator/TestDiscriminatorTypes.java","status":"modified","additions":30,"deletions":26,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/discriminator/TestDiscriminatorTypes.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/discriminator/TestDiscriminatorTypes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/discriminator/TestDiscriminatorTypes.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"01ce72aefe5fdd32148bd048ad8687bb315470d7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/exception/PObject.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/exception/PObject.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/exception/PObject.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/exception/PObject.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"9267d7d3b9b4030d0ba60e3458ff3610350bd74c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/exception/TestParameterLogging.java","status":"added","additions":110,"deletions":0,"changes":110,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/exception/TestParameterLogging.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/exception/TestParameterLogging.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/exception/TestParameterLogging.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"f24944b3d0a6127ee6f02e26fee4146076bf5b72","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGAddress.java","status":"modified","additions":105,"deletions":105,"changes":210,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGAddress.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGAddress.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGAddress.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"fdb7a2156b2bce5114cb97f7036fe9602ca40ff6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGDepartment.java","status":"modified","additions":60,"deletions":60,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGDepartment.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGDepartment.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGDepartment.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"242a09c3227a33a56618aa1fb7805f7bad80c0d1","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGEmployee.java","status":"modified","additions":174,"deletions":174,"changes":348,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGEmployee.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGEmployee.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGEmployee.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"ec2f5062db30b71118905e1ab508f71c3532f726","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGManager.java","status":"modified","additions":72,"deletions":72,"changes":144,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGManager.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fetchgroups/FGManager.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"080327c1385fbfdaf00a638246dfeccd0ba02921","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/EnumFieldType.java","status":"modified","additions":52,"deletions":52,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/EnumFieldType.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/EnumFieldType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/EnumFieldType.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"8b1bc084abfaded0295fa5e5ec6f27e84801e1a6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/EnumSetOwner.java","status":"modified","additions":75,"deletions":75,"changes":150,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/EnumSetOwner.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/EnumSetOwner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/EnumSetOwner.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"ead3fb0f9dabaa7f9e786d902d5c8ab9307b14b7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/NonstandardMappingEntity.java","status":"modified","additions":38,"deletions":38,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/NonstandardMappingEntity.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/NonstandardMappingEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/NonstandardMappingEntity.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"5912f6ffbbcf9ea384e2be1cab978d06e6a8306d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/SampleEnum.java","status":"modified","additions":23,"deletions":23,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/SampleEnum.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/SampleEnum.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/SampleEnum.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"d0a1fe951da85603d2a1a4de939c2513e1cd2bae","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestEnumQueryConstructor.java","status":"modified","additions":49,"deletions":49,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestEnumQueryConstructor.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestEnumQueryConstructor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestEnumQueryConstructor.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"aec9b9c6e60c6fe87469ec985d65532543fb8f69","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestEnumSets.java","status":"modified","additions":47,"deletions":47,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestEnumSets.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestEnumSets.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestEnumSets.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"e4cb7fd95b21cc956413c8cfbd4ab244f68453cc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestPersistentMapTableConfiguration.java","status":"modified","additions":56,"deletions":56,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestPersistentMapTableConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestPersistentMapTableConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/fields/TestPersistentMapTableConfiguration.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"7f3f5b8cfbd6fe10f6cc7e74de2506ce188e8b11","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/GeneratedValues.java","status":"modified","additions":60,"deletions":60,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/GeneratedValues.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/GeneratedValues.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/GeneratedValues.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"d25787b8dd3308a4b4e380b25040f23b8413b932","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestGeneratedValues.java","status":"modified","additions":112,"deletions":112,"changes":224,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestGeneratedValues.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestGeneratedValues.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestGeneratedValues.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"34206343fe2836980652bb85342f2aa129123c28","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestMultipleSchemaNames.java","status":"modified","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestMultipleSchemaNames.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestMultipleSchemaNames.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestMultipleSchemaNames.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"4a58be28ea33356a0e0d4df24c98abfa08dfd2d2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigDecimalIdEntity.java","status":"modified","additions":50,"deletions":50,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigDecimalIdEntity.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigDecimalIdEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigDecimalIdEntity.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"1b56f4ef92f2499081d5ea0b548d3b642aac3ee0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigIntegerIdEntity.java","status":"modified","additions":50,"deletions":50,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigIntegerIdEntity.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigIntegerIdEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/SQLBigIntegerIdEntity.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"22b248f17cac08f9dbcc1735a722ad64bd61c7ed","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigDecimalId.java","status":"modified","additions":61,"deletions":61,"changes":122,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigDecimalId.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigDecimalId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigDecimalId.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"c972c3d5b9da04aed29b5dae303fc5bb8cc39bb4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigIntegerId.java","status":"modified","additions":62,"deletions":62,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigIntegerId.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigIntegerId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/identity/TestSQLBigIntegerId.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"b442917faa976369d559923627fa99a787072bec","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/NoGenEntityL3Sibling.java","status":"modified","additions":37,"deletions":37,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/NoGenEntityL3Sibling.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/NoGenEntityL3Sibling.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/NoGenEntityL3Sibling.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"80029c78830cd47b5ceb616664952143b17166c0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestInheritanceWithMSCID.java","status":"added","additions":283,"deletions":0,"changes":283,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestInheritanceWithMSCID.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestInheritanceWithMSCID.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestInheritanceWithMSCID.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"6e5df22afc9e6d1586aa11b5eac93717b6738468","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestMappedSuperclass.java","status":"added","additions":108,"deletions":0,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestMappedSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestMappedSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestMappedSuperclass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"b7ad1369f2d8c9391f60823b6c3268b23964db6b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestSharedUnqualifiedClassNames.java","status":"modified","additions":62,"deletions":62,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestSharedUnqualifiedClassNames.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestSharedUnqualifiedClassNames.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestSharedUnqualifiedClassNames.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"886f1236a6326994802e96317d11c89681864572","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/embeddable/SharedName2.java","status":"modified","additions":30,"deletions":30,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/embeddable/SharedName2.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/embeddable/SharedName2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/embeddable/SharedName2.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"e9648472acb526dc27a06d49db15dc38891c0d9a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/EntityMapping.java","status":"added","additions":521,"deletions":0,"changes":521,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/EntityMapping.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/EntityMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/EntityMapping.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"81f445db3d51b070ce78f67c6d26045306a3c9f1","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/PrimitiveIDMappedSuperclass.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/PrimitiveIDMappedSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/PrimitiveIDMappedSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/PrimitiveIDMappedSuperclass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"1ec5c9d67567c467c65568c97e577b75aa614289","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCEntityB.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCEntityB.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCEntityB.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCEntityB.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"6802f7f3784aa65898c46c5b6e9536d1546286fb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCEntityD.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCEntityD.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCEntityD.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCEntityD.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"934f35d501f9019892f3837399d1fa95f1c280b8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafA.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafA.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafA.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"721d57247eb172d3885d80902626f0fc5e9511b5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafB1.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafB1.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafB1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafB1.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"295c31bdf12f35d3784b3b75e02a45d0e4945abb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafB2.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafB2.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafB2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafB2.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"5e585819c92852f14d870ad3b6278c6107ced35b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafC.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafC.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafC.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"29a82b4115ab569204dddbf148e3df86ef42f53d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafD1.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafD1.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafD1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafD1.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"f627048604e117c167a168a5ac4b0b4d54d5ef7b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafD2.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafD2.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafD2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCLeafD2.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"da360c3dd398e927e5c103db70944be860cb711d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCMappedSuperclass.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCMappedSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCMappedSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCMappedSuperclass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"a1e46830f84fa913a1558fb650f0b94059ed6319","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCRootEntity.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCRootEntity.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCRootEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/chardiscriminator/PIdJTCDMSCRootEntity.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"509a6258b58eb05715aba949319caf4ea06be89c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCEntityB.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCEntityB.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCEntityB.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCEntityB.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"4203e4d69ded0ef1d1a52185cd08d97dd41e0507","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCEntityD.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCEntityD.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCEntityD.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCEntityD.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"765248de96a038a7a31066447f4faa888e79f058","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafA.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafA.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafA.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"5390dee5f7ddcfa668484521fd93b4e5abbd442c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafB1.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafB1.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafB1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafB1.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"ef639c29d4cbbe4f0a92c99e504ebba9c390334c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafB2.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafB2.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafB2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafB2.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"785510909def45b4a4381cb6a6c076bc4c86193b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafC.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafC.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafC.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"43f35bba12ed9c07dc843bb009b1b7a4549e289a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafD1.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafD1.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafD1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafD1.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"6d593056f3695a531b21a831a5363e7eb9cb0d7e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafD2.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafD2.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafD2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCLeafD2.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"1f1de94a5a03a5408da49f4ff05c415a07eab43d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCMappedSuperclass.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCMappedSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCMappedSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCMappedSuperclass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"8e23055ecdd05113421c4937ad3ac1bdf378e511","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCRootEntity.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCRootEntity.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCRootEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/intdiscriminator/PIdJTIDMSCRootEntity.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"490d6f9408d410e1308d11f102bda137cf9ede5b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCEntityB.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCEntityB.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCEntityB.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCEntityB.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"2fff6ad472dc703771aeb6fc61fdf2d77fed5955","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCEntityD.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCEntityD.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCEntityD.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCEntityD.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"6e6569abbb6bd4e69116014c6260b1de4e906826","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafA.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafA.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafA.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"7dab5e23b1375a9de7d743630fa982d61b5f7980","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafB1.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafB1.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafB1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafB1.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"0e16123a0bf7bdf7d568223a666a8e7020654e1f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafB2.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafB2.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafB2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafB2.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"ea501105e7212cb4e91a821f5cc018c92a7db44e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafC.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafC.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafC.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"3967a50255db47f3a5592d1c566ff1f5e3ff9413","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafD1.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafD1.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafD1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafD1.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"96ea1ad8df0483402d7d97f993771f5b8a45340d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafD2.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafD2.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafD2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCLeafD2.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"77bd5dc7eae537da4d092deb362cd61ce416c1de","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCMappedSuperclass.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCMappedSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCMappedSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCMappedSuperclass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"9ec792ba56eb62b988af5db8a69c417d86527b9d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCRootEntity.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCRootEntity.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCRootEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/jointable/stringdiscriminator/PIdJTSDMSCRootEntity.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"93bdad7c1fd16d5d66e0db753032ace6796d2dba","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCEntityB.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCEntityB.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCEntityB.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCEntityB.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"5cf87a65989e78d5c785576b0132b77503779385","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCEntityD.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCEntityD.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCEntityD.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCEntityD.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"aad51427581c5281e3763a64603b0e05f9a7a626","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafA.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafA.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafA.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"10e70d9f5d4b0dd6af22b48fae3d51e0b4999c47","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafB1.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafB1.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafB1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafB1.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"6736a8aa466dd9c001dd6c5f92054166775b6720","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafB2.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafB2.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafB2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafB2.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"4f2473597b5fe11677964e242296ccf605dde4f2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafC.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafC.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafC.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"0b103b1cba539578079f4dfaa798426e19e394b9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafD1.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafD1.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafD1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafD1.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"bce03befbdf91fda7061b26a878738b1811c3eff","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafD2.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafD2.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafD2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCLeafD2.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"366b20825aa1a15d9a8133063b55b54e305637f6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCMappedSuperclass.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCMappedSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCMappedSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCMappedSuperclass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"1aa152f0ec268d0b19e552615b8449805a7879e7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCRootEntity.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCRootEntity.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCRootEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/chardiscriminator/PIdSTCDMSCRootEntity.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"a52f94028d34cfd8bf8b04cefd2a876517f879a5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCEntityB.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCEntityB.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCEntityB.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCEntityB.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"80d6fef9ff9392abc8972fc43b35f6db2bfb7735","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCEntityD.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCEntityD.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCEntityD.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCEntityD.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"2a5555cd3a3c6fa7a70706c73b26a7261852c7ac","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafA.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafA.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafA.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"f0621d10dd7e10e92b9c8abcd2273d9bb7edee4a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafB1.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafB1.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafB1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafB1.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"e620f40d899158bff17ef981ff14411748163140","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafB2.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafB2.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafB2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafB2.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"18d1e151ef202594f6a9856ecfd1f6cdd991ac12","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafC.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafC.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafC.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"f7e84b48ede27ad08a63300a86f9ff386a141810","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafD1.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafD1.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafD1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafD1.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"b3ba753dfe54ade38627b45b4a46e282ead09455","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafD2.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafD2.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafD2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCLeafD2.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"602bf8151ca2b7ca77e0663cfd4348b6c4c9b853","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCMappedSuperclass.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCMappedSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCMappedSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCMappedSuperclass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"27782a98c3357413c647855696ff60a413369a41","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCRootEntity.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCRootEntity.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCRootEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/intdiscriminator/PIdSTIDMSCRootEntity.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"657ec15fa4d6409dadb6aa9a7862a188cad0f488","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCEntityB.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCEntityB.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCEntityB.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCEntityB.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"1961c91f5ffbef03328cd718db4ddc2edcd8dc72","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCEntityD.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCEntityD.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCEntityD.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCEntityD.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"4597c430f293b6404ac160d3d6ce5d5af48187d0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafA.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafA.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafA.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"103ac0e2270e83faf353d5f19feed067da8abdf9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafB1.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafB1.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafB1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafB1.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"e12e77e27ebe660d75a9f4755a4872c15f230abd","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafB2.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafB2.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafB2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafB2.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"9f7e52a50b1e764edc16a6e8a5177301ff64042e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafC.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafC.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafC.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"5b220e3168d2e41342ba619e1ac6b0ce854ccb6b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafD1.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafD1.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafD1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafD1.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"8c8275f3e786f87130979ff80e8c2360b84fa4a2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafD2.java","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafD2.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafD2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCLeafD2.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"88d3f36767ee1296089138df2cdd697536f9ca30","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCMappedSuperclass.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCMappedSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCMappedSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCMappedSuperclass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"0b766c0004e9460c8cc5ef36f5e714313215d1cc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCRootEntity.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCRootEntity.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCRootEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/singletable/stringdiscriminator/PIdSTSDMSCRootEntity.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"5dcb57e5fb7b9119ee0ee5e6c67294caeb416f25","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/EntityB.java","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/EntityB.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/EntityB.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/EntityB.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"f3a5e4e18d98a392b78ed599ed69baf4241a9ce6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/EntityD.java","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/EntityD.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/EntityD.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/EntityD.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"4f8e3268708cd5968bb392f57baeec545b84e549","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafA.java","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafA.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafA.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"4d41bbeec2bb6332383ab30f9afc727aa7886c69","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafB1.java","status":"added","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafB1.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafB1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafB1.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"8e16582f0c162c99f3489a1141a7524dfbf03053","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafB2.java","status":"added","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafB2.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafB2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafB2.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"8cf612480e6e437aa1becf77f2e51b0ce7d9f69a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafC.java","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafC.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafC.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"8072af4d2bf6a71e5cf492e5130a5742548e819c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafD1.java","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafD1.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafD1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafD1.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"3218e05d208b495a8607ac5ce7ef643566fec9c0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafD2.java","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafD2.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafD2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafD2.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"a49c07cba04ec63db305d9eb951b366e5270392a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/MSC.java","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/MSC.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/MSC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/MSC.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"22801d784d060958982677057a83d4c759252da4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/RootEntity.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/RootEntity.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/RootEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/RootEntity.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"e89862fe749acd5c2fefacf13ecee986ba5fe5b3","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/BaseClass.java","status":"added","additions":68,"deletions":0,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/BaseClass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/BaseClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/BaseClass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"3cd30dfdf2626ae3c4d840e653a512d34b0d9ed6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/MappedSuper.java","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/MappedSuper.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/MappedSuper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/MappedSuper.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"ff6857bbb787807c462040ff0c354c4577579378","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SharedName1.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SharedName1.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SharedName1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SharedName1.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"58947ed002d2e50b3eb133edc20c854ac620d4c2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SharedName2.java","status":"modified","additions":33,"deletions":33,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SharedName2.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SharedName2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SharedName2.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"ce7425489113b529eee892b5a96c56df8dfea1d7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SubclassC.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SubclassC.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SubclassC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SubclassC.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"7ac96510a8d435b87925249508ac71ad175f8217","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SubclassD.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SubclassD.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SubclassD.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entity/SubclassD.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"63499c417d931a6282be372010a704c50dba9818","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/BaseEntity.java","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/BaseEntity.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/BaseEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/BaseEntity.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"97663e7934f65121579a33459cfbf578df4b318e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/CashBaseEntity.java","status":"added","additions":89,"deletions":0,"changes":89,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/CashBaseEntity.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/CashBaseEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/CashBaseEntity.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"ae0534c85816e4ae786993a2072aad3ccae3ec30","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/SharedName1.java","status":"modified","additions":30,"deletions":30,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/SharedName1.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/SharedName1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/SharedName1.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"2988f9ad21445b613f0602bc9ddc5f5c8adeb565","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/SituationDA.java","status":"added","additions":92,"deletions":0,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/SituationDA.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/SituationDA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/SituationDA.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"c0c2fe9e01d60e2825de8a336d6098f9dd869d4b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/TestMappedSuperClass.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/TestMappedSuperClass.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/TestMappedSuperClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/TestMappedSuperClass.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"7e0eac1e92310c84c27d1573e26183c596d8d273","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/ValuableItemDA.java","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/ValuableItemDA.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/ValuableItemDA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/mappedsuperclass/ValuableItemDA.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"34b3f97224196e516e1912e398221f1d14ca3bb2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestJDBCEnumToKernelConstantMappings.java","status":"modified","additions":165,"deletions":165,"changes":330,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestJDBCEnumToKernelConstantMappings.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestJDBCEnumToKernelConstantMappings.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestJDBCEnumToKernelConstantMappings.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"50cb00df18f3cb100c085e8f9a8abe48c66fc220","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestOptimizeForClause.java","status":"modified","additions":104,"deletions":104,"changes":208,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestOptimizeForClause.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestOptimizeForClause.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/TestOptimizeForClause.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"636f14afd0129814b50f991b78e1edc4dbd3ec02","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/TestNativeQueryProcedures.java","status":"added","additions":168,"deletions":0,"changes":168,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/TestNativeQueryProcedures.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/TestNativeQueryProcedures.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/TestNativeQueryProcedures.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"54d266f0582b068389bc3f49e834b444faf11cd6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/Applicant.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/Applicant.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/Applicant.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/domain/Applicant.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"d3ad3c153f673864cdb77f788cf50c35242bfafc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/procedure/DerbyProcedureList.java","status":"added","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/procedure/DerbyProcedureList.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/procedure/DerbyProcedureList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/procedure/DerbyProcedureList.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"e23b64816e5143bbf3a7e830a2f4eedae5da869c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/procedure/ProcedureList.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/procedure/ProcedureList.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/procedure/ProcedureList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/query/procedure/ProcedureList.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"70c55856cfb32b1deb7c4b2c433a45ab10d90a2c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jpql/functions/TestEJBQLFunction.java","status":"added","additions":185,"deletions":0,"changes":185,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jpql/functions/TestEJBQLFunction.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jpql/functions/TestEJBQLFunction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jpql/functions/TestEJBQLFunction.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"3cae4a0e768a33817cc12b18640c982f4ef98679","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/MdrTestEntity.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/MdrTestEntity.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/MdrTestEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/MdrTestEntity.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"197acac4154327cabf39d64d8a66555a06527d6f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/TestMetaDataRepository.java","status":"added","additions":117,"deletions":0,"changes":117,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/TestMetaDataRepository.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/TestMetaDataRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/TestMetaDataRepository.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"1db629079481e39c547e71e502f83364ac447772","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/UnloadedEntity.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/UnloadedEntity.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/UnloadedEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/meta/UnloadedEntity.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"b28a80492610d297c227c28c9eb779089ef06dc2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/models/company/CompanyModelTest.java","status":"modified","additions":47,"deletions":23,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/models/company/CompanyModelTest.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/models/company/CompanyModelTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/models/company/CompanyModelTest.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"b465a61170b7ea6b3cfb596360c456a094709d4a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/Dependent.java","status":"added","additions":76,"deletions":0,"changes":76,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/Dependent.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/Dependent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/Dependent.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"24c0a7ec5f64df1c3d3e5999b09c7b048bbbf27e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/DependentId.java","status":"added","additions":88,"deletions":0,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/DependentId.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/DependentId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/DependentId.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"0e3b55e619fbf0decaf80b8d08bf73c75c0f096a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/Employee.java","status":"added","additions":78,"deletions":0,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/Employee.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/Employee.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/Employee.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"},{"sha":"664bae729d13c43f77c8dac2200d878b8fa31a44","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/Magazine.java","status":"added","additions":89,"deletions":0,"changes":89,"blob_url":"https://github.com/apache/openjpa/blob/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/Magazine.java","raw_url":"https://github.com/apache/openjpa/raw/cd4c8839f87f750e2655a5b98f552e2ba4031a67/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/Magazine.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/Magazine.java?ref=cd4c8839f87f750e2655a5b98f552e2ba4031a67"}]}

