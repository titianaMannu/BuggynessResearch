{"sha":"cf752cbc09cf5e09160ff18648f4c25b2735aac8","node_id":"MDY6Q29tbWl0MjA2MzY0OmNmNzUyY2JjMDljZjVlMDkxNjBmZjE4NjQ4ZjRjMjViMjczNWFhYzg=","commit":{"author":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2010-04-08T20:34:17Z"},"committer":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2010-04-08T20:34:17Z"},"message":"OPENJPA-1604: Override default lock level for NamedQueries when using the pessimistic lock manager. Code contributed by Pinaki Poddar and Rick Curtis\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/2.0.x@932095 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"89ead371b32031918cf9b9b2cb32d1a31d4e289f","url":"https://api.github.com/repos/apache/openjpa/git/trees/89ead371b32031918cf9b9b2cb32d1a31d4e289f"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/cf752cbc09cf5e09160ff18648f4c25b2735aac8","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/cf752cbc09cf5e09160ff18648f4c25b2735aac8","html_url":"https://github.com/apache/openjpa/commit/cf752cbc09cf5e09160ff18648f4c25b2735aac8","comments_url":"https://api.github.com/repos/apache/openjpa/commits/cf752cbc09cf5e09160ff18648f4c25b2735aac8/comments","author":null,"committer":null,"parents":[{"sha":"a0e342833b93eda1c06965eb7dc206a215071e15","url":"https://api.github.com/repos/apache/openjpa/commits/a0e342833b93eda1c06965eb7dc206a215071e15","html_url":"https://github.com/apache/openjpa/commit/a0e342833b93eda1c06965eb7dc206a215071e15"}],"stats":{"total":235,"additions":223,"deletions":12},"files":[{"sha":"15ea35a802a6e61b8ff3faa521e764c270a3415c","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/LockEmployee.java","status":"modified","additions":9,"deletions":4,"changes":13,"blob_url":"https://github.com/apache/openjpa/blob/cf752cbc09cf5e09160ff18648f4c25b2735aac8/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/LockEmployee.java","raw_url":"https://github.com/apache/openjpa/raw/cf752cbc09cf5e09160ff18648f4c25b2735aac8/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/LockEmployee.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/LockEmployee.java?ref=cf752cbc09cf5e09160ff18648f4c25b2735aac8","patch":"@@ -25,14 +25,19 @@\n \n import javax.persistence.Entity;\n import javax.persistence.Id;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NamedQueries;\n import javax.persistence.NamedQuery;\n import javax.persistence.Version;\n \n-@NamedQuery(\n-        name=\"findEmployeeById\"\n-        , query=\"SELECT c FROM LockEmployee c WHERE c.id = :id\"\n-        )\n \n+@NamedQueries( {\n+    @NamedQuery(name = \"findEmployeeById\", \n+        query = \"SELECT c FROM LockEmployee c WHERE c.id = :id\"),\n+    @NamedQuery(name = \"findEmployeeByIdWithLock\", \n+        query = \"SELECT c FROM LockEmployee c WHERE c.id = :id\", lockMode = LockModeType.PESSIMISTIC_READ),\n+    @NamedQuery(name = \"findEmployeeByIdWithNoLock\", \n+        query = \"SELECT c FROM LockEmployee c WHERE c.id = :id\", lockMode = LockModeType.NONE) })\n @Entity\n public class LockEmployee implements Externalizable {\n "},{"sha":"c108abaccc4680246df4a22a336e00373aa0a076","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestNamedQueryLockMode.java","status":"added","additions":102,"deletions":0,"changes":102,"blob_url":"https://github.com/apache/openjpa/blob/cf752cbc09cf5e09160ff18648f4c25b2735aac8/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestNamedQueryLockMode.java","raw_url":"https://github.com/apache/openjpa/raw/cf752cbc09cf5e09160ff18648f4c25b2735aac8/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestNamedQueryLockMode.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lockmgr/TestNamedQueryLockMode.java?ref=cf752cbc09cf5e09160ff18648f4c25b2735aac8","patch":"@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.lockmgr;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.Query;\n+\n+import org.apache.openjpa.persistence.TransactionRequiredException;\n+import org.apache.openjpa.persistence.test.AllowFailure;\n+import org.apache.openjpa.persistence.test.SQLListenerTestCase;\n+\n+/**\n+ * Tests the lock mode on named query emits a FOR UPDATE clause in target SQL\n+ * query.\n+ * \n+ * \n+ */\n+public class TestNamedQueryLockMode extends SQLListenerTestCase {\n+    public void setUp() {\n+        super.setUp(CLEAR_TABLES, LockEmployee.class, \n+            \"openjpa.LockManager\", \"pessimistic\", \n+            \"openjpa.Optimistic\", \"false\"\n+            );\n+    }\n+\n+    public void testForUpdateClausePresentInNamedQueryWithLockMode() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        assertClausePresentInSQL(\"FOR UPDATE\", em.createNamedQuery(\"findEmployeeByIdWithLock\").setParameter(\"id\", 0));\n+        em.getTransaction().rollback();\n+        em.getTransaction().begin();\n+        assertClausePresentInSQL(\"FOR UPDATE\", em.createNamedQuery(\"findEmployeeByIdWithLock\").setParameter(\"id\", 0));\n+        em.getTransaction().rollback();\n+        em.getTransaction().begin();\n+        assertClausePresentInSQL(\"FOR UPDATE\", em.createNamedQuery(\"findEmployeeByIdWithLock\").setParameter(\"id\", 0));\n+        em.getTransaction().rollback();\n+    }\n+\n+    @AllowFailure\n+    public void testNamedQueryWithLockModeMustExecuteInTransaction() {\n+        EntityManager em = emf.createEntityManager();\n+        // execute without a transaction\n+         try {\n+         em.createNamedQuery(\"findEmployeeByIdWithLock\").setParameter(\"id\",\n+         0).getResultList();\n+         fail(\"Expected \" + TransactionRequiredException.class.getName());\n+         } catch (TransactionRequiredException e) {\n+         // Expected\n+         }\n+    }\n+\n+    public void testForUpdateClausePresentInQueryWithDefault() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        assertClausePresentInSQL(\"FOR UPDATE\", em.createNamedQuery(\"findEmployeeById\").setParameter(\"id\", 0));\n+        assertClausePresentInSQL(\"FOR UPDATE\", em.createNamedQuery(\"findEmployeeById\").setParameter(\"id\", 0));\n+        em.getTransaction().commit();\n+    }\n+\n+    @AllowFailure\n+    public void testForUpdateClauseAbsentInQueryWithExplictNoLock() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        assertClauseAbsentInSQL(\"FOR UPDATE\", em.createNamedQuery(\"findEmployeeByIdWithNoLock\").setParameter(\"id\", 0));\n+        assertClauseAbsentInSQL(\"FOR UPDATE\", em.createNamedQuery(\"findEmployeeByIdWithNoLock\").setParameter(\"id\", 0));\n+        em.getTransaction().commit();\n+    }\n+\n+    String getLastSQL() {\n+        String last = sql.get(getSQLCount() - 1);\n+        assertNotNull(\"No last sql found\", last);\n+        return last;\n+    }\n+\n+    void assertClausePresentInSQL(String clause, Query q) {\n+        q.getResultList();\n+        String last = getLastSQL();\n+        assertTrue(clause + \" is not present in \" + last, last.toUpperCase().indexOf(clause) != -1);\n+    }\n+\n+    void assertClauseAbsentInSQL(String clause, Query q) {\n+        q.getResultList();\n+        String last = getLastSQL();\n+        assertTrue(clause + \" is not absent in \" + last, last.toUpperCase().indexOf(clause) == -1);\n+    }\n+}"},{"sha":"8ffc4024c213e038cd634ded2cd33596b5610a15","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","status":"modified","additions":78,"deletions":5,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/cf752cbc09cf5e09160ff18648f4c25b2735aac8/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/cf752cbc09cf5e09160ff18648f4c25b2735aac8/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java?ref=cf752cbc09cf5e09160ff18648f4c25b2735aac8","patch":"@@ -19,7 +19,53 @@\n package org.apache.openjpa.persistence;\n \n import static javax.persistence.GenerationType.AUTO;\n-import static org.apache.openjpa.persistence.MetaDataTag.*;\n+import static org.apache.openjpa.persistence.MetaDataTag.ACCESS;\n+import static org.apache.openjpa.persistence.MetaDataTag.CACHEABLE;\n+import static org.apache.openjpa.persistence.MetaDataTag.DATASTORE_ID;\n+import static org.apache.openjpa.persistence.MetaDataTag.DATA_CACHE;\n+import static org.apache.openjpa.persistence.MetaDataTag.DEPENDENT;\n+import static org.apache.openjpa.persistence.MetaDataTag.DETACHED_STATE;\n+import static org.apache.openjpa.persistence.MetaDataTag.ELEM_DEPENDENT;\n+import static org.apache.openjpa.persistence.MetaDataTag.ELEM_TYPE;\n+import static org.apache.openjpa.persistence.MetaDataTag.EMBEDDED_ID;\n+import static org.apache.openjpa.persistence.MetaDataTag.ENTITY_LISTENERS;\n+import static org.apache.openjpa.persistence.MetaDataTag.EXCLUDE_DEFAULT_LISTENERS;\n+import static org.apache.openjpa.persistence.MetaDataTag.EXCLUDE_SUPERCLASS_LISTENERS;\n+import static org.apache.openjpa.persistence.MetaDataTag.EXTERNALIZER;\n+import static org.apache.openjpa.persistence.MetaDataTag.EXTERNAL_VALS;\n+import static org.apache.openjpa.persistence.MetaDataTag.FACTORY;\n+import static org.apache.openjpa.persistence.MetaDataTag.FETCH_GROUP;\n+import static org.apache.openjpa.persistence.MetaDataTag.FETCH_GROUPS;\n+import static org.apache.openjpa.persistence.MetaDataTag.FLUSH_MODE;\n+import static org.apache.openjpa.persistence.MetaDataTag.GENERATED_VALUE;\n+import static org.apache.openjpa.persistence.MetaDataTag.ID;\n+import static org.apache.openjpa.persistence.MetaDataTag.ID_CLASS;\n+import static org.apache.openjpa.persistence.MetaDataTag.INVERSE_LOGICAL;\n+import static org.apache.openjpa.persistence.MetaDataTag.KEY_DEPENDENT;\n+import static org.apache.openjpa.persistence.MetaDataTag.KEY_TYPE;\n+import static org.apache.openjpa.persistence.MetaDataTag.LOAD_FETCH_GROUP;\n+import static org.apache.openjpa.persistence.MetaDataTag.LRS;\n+import static org.apache.openjpa.persistence.MetaDataTag.MANAGED_INTERFACE;\n+import static org.apache.openjpa.persistence.MetaDataTag.MAPPED_BY_ID;\n+import static org.apache.openjpa.persistence.MetaDataTag.MAP_KEY;\n+import static org.apache.openjpa.persistence.MetaDataTag.MAP_KEY_CLASS;\n+import static org.apache.openjpa.persistence.MetaDataTag.NATIVE_QUERIES;\n+import static org.apache.openjpa.persistence.MetaDataTag.NATIVE_QUERY;\n+import static org.apache.openjpa.persistence.MetaDataTag.ORDER_BY;\n+import static org.apache.openjpa.persistence.MetaDataTag.POST_LOAD;\n+import static org.apache.openjpa.persistence.MetaDataTag.POST_PERSIST;\n+import static org.apache.openjpa.persistence.MetaDataTag.POST_REMOVE;\n+import static org.apache.openjpa.persistence.MetaDataTag.POST_UPDATE;\n+import static org.apache.openjpa.persistence.MetaDataTag.PRE_PERSIST;\n+import static org.apache.openjpa.persistence.MetaDataTag.PRE_REMOVE;\n+import static org.apache.openjpa.persistence.MetaDataTag.PRE_UPDATE;\n+import static org.apache.openjpa.persistence.MetaDataTag.QUERIES;\n+import static org.apache.openjpa.persistence.MetaDataTag.QUERY;\n+import static org.apache.openjpa.persistence.MetaDataTag.READ_ONLY;\n+import static org.apache.openjpa.persistence.MetaDataTag.REPLICATED;\n+import static org.apache.openjpa.persistence.MetaDataTag.SEQ_GENERATOR;\n+import static org.apache.openjpa.persistence.MetaDataTag.TYPE;\n+import static org.apache.openjpa.persistence.MetaDataTag.VERSION;\n \n import java.io.File;\n import java.io.Serializable;\n@@ -60,16 +106,16 @@\n import javax.persistence.FlushModeType;\n import javax.persistence.GeneratedValue;\n import javax.persistence.GenerationType;\n-\n import javax.persistence.Id;\n import javax.persistence.IdClass;\n import javax.persistence.Lob;\n+import javax.persistence.LockModeType;\n import javax.persistence.ManyToMany;\n import javax.persistence.ManyToOne;\n import javax.persistence.MapKey;\n import javax.persistence.MapKeyClass;\n-import javax.persistence.MapsId;\n import javax.persistence.MappedSuperclass;\n+import javax.persistence.MapsId;\n import javax.persistence.NamedNativeQueries;\n import javax.persistence.NamedNativeQuery;\n import javax.persistence.NamedQueries;\n@@ -1777,9 +1823,11 @@ private void parseNamedQueries(AnnotatedElement el, NamedQuery... queries) {\n             meta.setLanguage(JPQLParser.LANG_JPQL);\n             for (QueryHint hint : query.hints())\n                 meta.addHint(hint.name(), hint.value());\n-            if (query.lockMode() != null) {\n-                meta.addHint(\"openjpa.FetchPlan.ReadLockMode\", query.lockMode());\n+            LockModeType lmt = processNamedQueryLockModeType(query);\n+            if (lmt != null) {\n+                meta.addHint(\"openjpa.FetchPlan.ReadLockMode\", lmt);\n             }\n+\n             meta.setSource(getSourceFile(), (el instanceof Class) ? el : null,\n                 SourceTracker.SRC_ANNOTATIONS);\n             if (isMetaDataMode())\n@@ -1791,6 +1839,31 @@ else if (isMappingMode())\n         }\n     }\n \n+    /**\n+     * A private worker method that calculates the lock mode for an individual NamedQuery. If the NamedQuery is \n+     * configured to use the NONE lock mode(explicit or implicit), this method will promote the lock to a READ\n+     * level lock. This was done to allow for JPA1 apps to function properly under a 2.0 runtime. \n+     */\n+    private LockModeType processNamedQueryLockModeType(NamedQuery query) {\n+        LockModeType lmt = query.lockMode();\n+        if (query.lockMode() != null) {\n+            String lm = _conf.getLockManager();\n+            if (lm != null) {\n+                lm = lm.toLowerCase();\n+                if (lm.contains(\"pessimistic\")) {\n+                    if (lmt == LockModeType.NONE) {\n+                        if (_log.isWarnEnabled() == true) {\n+                            _log.warn(_loc.get(\"override-named-query-lock-mode\", new String[] { \"annotation\",\n+                                query.name(), _cls.getName() }));\n+                        }\n+                        lmt = LockModeType.READ;\n+                    }\n+                }\n+            }\n+        }\n+        return lmt;\n+    }\n+\n     /**\n      * Parse @NamedNativeQuery.\n      */"},{"sha":"b1cecccfcd87bd6748bbdc732cc5bd3d99f005d3","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","status":"modified","additions":31,"deletions":2,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/cf752cbc09cf5e09160ff18648f4c25b2735aac8/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/cf752cbc09cf5e09160ff18648f4c25b2735aac8/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java?ref=cf752cbc09cf5e09160ff18648f4c25b2735aac8","patch":"@@ -35,6 +35,7 @@\n import javax.persistence.CascadeType;\n import javax.persistence.GenerationType;\n import javax.persistence.LockModeType;\n+import javax.persistence.NamedQuery;\n \n import static javax.persistence.CascadeType.*;\n \n@@ -1673,8 +1674,9 @@ protected boolean startNamedQuery(Attributes attrs)\n         meta.setQueryString(attrs.getValue(\"query\"));\n         meta.setLanguage(JPQLParser.LANG_JPQL);\n         String lockModeStr = attrs.getValue(\"lock-mode\");\n-        if (lockModeStr != null) {\n-            meta.addHint(\"openjpa.FetchPlan.ReadLockMode\", LockModeType.valueOf(lockModeStr));\n+        LockModeType lmt = processNamedQueryLockModeType(log, lockModeStr, name);\n+        if (lmt != null) {\n+            meta.addHint(\"openjpa.FetchPlan.ReadLockMode\", lmt);\n         }\n         Locator locator = getLocation().getLocator();\n         if (locator != null) {\n@@ -1694,6 +1696,33 @@ else if (isMappingMode())\n         pushElement(meta);\n         return true;\n     }\n+    \n+    /**\n+     * A private worker method that calculates the lock mode for an individual NamedQuery. If the NamedQuery is \n+     * configured to use the NONE lock mode(explicit or implicit), this method will promote the lock to a READ\n+     * level lock. This was done to allow for JPA1 apps to function properly under a 2.0 runtime. \n+     */\n+    private LockModeType processNamedQueryLockModeType(Log log, String lockModeString, String queryName) {\n+        if (lockModeString == null) {\n+            return null;\n+        }\n+        LockModeType lmt = LockModeType.valueOf(lockModeString);\n+        String lm = _conf.getLockManager();\n+        if (lm != null) {\n+            lm = lm.toLowerCase();\n+            if (lm.contains(\"pessimistic\")) {\n+                if (lmt == LockModeType.NONE) {\n+                    if (log != null && log.isWarnEnabled() == true) {\n+                        log.warn(_loc.get(\"override-named-query-lock-mode\", new String[] { \"xml\", queryName,\n+                            _cls.getName() }));\n+                    }\n+                    lmt = LockModeType.READ;\n+                }\n+            }\n+        }\n+\n+        return lmt;\n+    }\n \n     protected void endNamedQuery()\n         throws SAXException {"},{"sha":"b1bc10c3ecab71abf396f17bea9d2f982e8b98b6","filename":"openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/cf752cbc09cf5e09160ff18648f4c25b2735aac8/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/cf752cbc09cf5e09160ff18648f4c25b2735aac8/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/resources/org/apache/openjpa/persistence/localizer.properties?ref=cf752cbc09cf5e09160ff18648f4c25b2735aac8","patch":"@@ -229,4 +229,6 @@ create-emf-depend-error: Failed to create a provider for \"{0}\" because a \\\n invalid-version-attribute: Persistence version attribute value \"{0}\" is not valid.  Using version \"{1}\" by default.\n not-jpql-or-criteria-query: Query is neither a JPQL SELECT nor a Criteria API query.\n cache-retrieve-override: The setting of CacheRetrieveMode.USE is ignored and set to BYPASS for refresh operation.  \n-null-detach: Can not detach null entity\n\\ No newline at end of file\n+null-detach: Can not detach null entity\n+override-named-query-lock-mode: Encountered a read lock level less than LockModeType.READ when processing the \\\n+NamedQuery {0} \"{1}\" in class \"{2}\". Setting query lock level to LockModeType.READ."}]}

