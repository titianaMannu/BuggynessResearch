{"sha":"d6dbadaa3cc643b201ca478885e3bde9d77543ed","node_id":"MDY6Q29tbWl0MjA2MzY0OmQ2ZGJhZGFhM2NjNjQzYjIwMWNhNDc4ODg1ZTNiZGU5ZDc3NTQzZWQ=","commit":{"author":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-12-13T20:14:26Z"},"committer":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-12-13T20:14:26Z"},"message":"Option to create proxies for standard java.util types at build time.  These\nproxies can be serialized as proxies for use with detached state managers,\nwhereas runtime-generated proxies have to serialize themselves as a copied \ninstance of their corresponding java.util type in case they are transferred to \na different classloading environment.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@486825 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"5ac73a5a45ac89eb7b6b141af573e6fb99e8b5b3","url":"https://api.github.com/repos/apache/openjpa/git/trees/5ac73a5a45ac89eb7b6b141af573e6fb99e8b5b3"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/d6dbadaa3cc643b201ca478885e3bde9d77543ed","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/d6dbadaa3cc643b201ca478885e3bde9d77543ed","html_url":"https://github.com/apache/openjpa/commit/d6dbadaa3cc643b201ca478885e3bde9d77543ed","comments_url":"https://api.github.com/repos/apache/openjpa/commits/d6dbadaa3cc643b201ca478885e3bde9d77543ed/comments","author":null,"committer":null,"parents":[{"sha":"dfca20d46580f52ae2c4f75f450e1c30d96e0cb4","url":"https://api.github.com/repos/apache/openjpa/commits/dfca20d46580f52ae2c4f75f450e1c30d96e0cb4","html_url":"https://github.com/apache/openjpa/commit/dfca20d46580f52ae2c4f75f450e1c30d96e0cb4"}],"stats":{"total":235,"additions":156,"deletions":79},"files":[{"sha":"e940a51dd98b3090c13b4677485d0d20b6563ad2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxies.java","status":"modified","additions":3,"deletions":6,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/d6dbadaa3cc643b201ca478885e3bde9d77543ed/openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxies.java","raw_url":"https://github.com/apache/openjpa/raw/d6dbadaa3cc643b201ca478885e3bde9d77543ed/openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxies.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/Proxies.java?ref=d6dbadaa3cc643b201ca478885e3bde9d77543ed","patch":"@@ -78,13 +78,10 @@ public static void removed(Proxy proxy, Object removed, boolean key) {\n     /**\n      * Used by proxy types to serialize non-proxy versions.\n      */\n-    public static Object writeReplace(Proxy proxy) {\n-        // we can't send dynamically-created classes to another JVM\n-        /*\n-        if (proxy == null || proxy.getOwner() == null \n-            || proxy.getOwner().isDetached())\n+    public static Object writeReplace(Proxy proxy, boolean detachable) {\n+        if (detachable && (proxy == null || proxy.getOwner() == null \n+            || proxy.getOwner().isDetached()))\n             return proxy;\n-        */\n         return proxy.copy(proxy);\n     }\n }"},{"sha":"429e11d1bbf7fcb3aff796c680d146492be6c944","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","status":"modified","additions":152,"deletions":72,"changes":224,"blob_url":"https://github.com/apache/openjpa/blob/d6dbadaa3cc643b201ca478885e3bde9d77543ed/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/d6dbadaa3cc643b201ca478885e3bde9d77543ed/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java?ref=d6dbadaa3cc643b201ca478885e3bde9d77543ed","patch":"@@ -24,6 +24,7 @@\n import java.lang.reflect.Modifier;\n import java.sql.Timestamp;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Calendar;\n import java.util.Collection;\n import java.util.Comparator;\n@@ -46,6 +47,7 @@\n import org.apache.openjpa.lib.util.Files;\n import org.apache.openjpa.lib.util.JavaVersions;\n import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Options;\n import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n import serp.bytecode.BCClass;\n import serp.bytecode.BCClassLoader;\n@@ -331,9 +333,11 @@ private ProxyCollection getFactoryProxyCollection(Class type) {\n         // we don't lock here; ok if two proxies get generated for same type\n         ProxyCollection proxy = (ProxyCollection) _proxies.get(type);\n         if (proxy == null) {\n-            proxy = (ProxyCollection) instantiateProxy\n-                (generateProxyCollectionBytecode(type), type, \n-                ProxyCollection.class, null, null);\n+            ClassLoader l = getMostDerivedLoader(type, ProxyCollection.class);\n+            Class pcls = loadBuildTimeProxy(type, l);\n+            if (pcls == null)\n+                pcls = loadProxy(generateProxyCollectionBytecode(type, true),l);\n+            proxy = (ProxyCollection) instantiateProxy(pcls, null, null);\n             _proxies.put(type, proxy);\n         }\n         return proxy;\n@@ -346,8 +350,11 @@ private ProxyMap getFactoryProxyMap(Class type) {\n         // we don't lock here; ok if two proxies get generated for same type\n         ProxyMap proxy = (ProxyMap) _proxies.get(type);\n         if (proxy == null) {\n-            proxy = (ProxyMap) instantiateProxy(generateProxyMapBytecode(type), \n-                type, ProxyMap.class, null, null);\n+            ClassLoader l = getMostDerivedLoader(type, ProxyMap.class);\n+            Class pcls = loadBuildTimeProxy(type, l);\n+            if (pcls == null)\n+                pcls = loadProxy(generateProxyMapBytecode(type, true), l);\n+            proxy = (ProxyMap) instantiateProxy(pcls, null, null);\n             _proxies.put(type, proxy);\n         }\n         return proxy;\n@@ -360,9 +367,11 @@ private ProxyDate getFactoryProxyDate(Class type) {\n         // we don't lock here; ok if two proxies get generated for same type\n         ProxyDate proxy = (ProxyDate) _proxies.get(type);\n         if (proxy == null) {\n-            proxy = (ProxyDate) instantiateProxy\n-                (generateProxyDateBytecode(type), type, ProxyDate.class, null, \n-                null);\n+            ClassLoader l = getMostDerivedLoader(type, ProxyDate.class);\n+            Class pcls = loadBuildTimeProxy(type, l);\n+            if (pcls == null)\n+                pcls = loadProxy(generateProxyDateBytecode(type, true), l);\n+            proxy = (ProxyDate) instantiateProxy(pcls, null, null);\n             _proxies.put(type, proxy);\n         }\n         return proxy;\n@@ -375,9 +384,11 @@ private ProxyCalendar getFactoryProxyCalendar(Class type) {\n         // we don't lock here; ok if two proxies get generated for same type\n         ProxyCalendar proxy = (ProxyCalendar) _proxies.get(type);\n         if (proxy == null) {\n-            proxy = (ProxyCalendar) instantiateProxy\n-                (generateProxyCalendarBytecode(type), type, ProxyCalendar.class,\n-                null, null);\n+            ClassLoader l = getMostDerivedLoader(type, ProxyCalendar.class);\n+            Class pcls = loadBuildTimeProxy(type, l);\n+            if (pcls == null)\n+                pcls = loadProxy(generateProxyCalendarBytecode(type, true), l);\n+            proxy = (ProxyCalendar) instantiateProxy(pcls, null, null);\n             _proxies.put(type, proxy);\n         }\n         return proxy;\n@@ -388,48 +399,70 @@ private ProxyCalendar getFactoryProxyCalendar(Class type) {\n      */\n     private ProxyBean getFactoryProxyBean(Object orig) {\n         // we don't lock here; ok if two proxies get generated for same type\n-        ProxyBean proxy = (ProxyBean) _proxies.get(orig.getClass());\n-        if (proxy == null && !_proxies.containsKey(orig.getClass())) {\n-            BCClass bc = generateProxyBeanBytecode(orig.getClass());\n-            if (bc == null)\n-                _proxies.put(orig.getClass(), null);\n-            else {\n-                BCMethod m = bc.getDeclaredMethod(\"<init>\", (Class[]) null);\n-                proxy = (ProxyBean) instantiateProxy(bc, orig.getClass(), \n-                    ProxyBean.class, findCopyConstructor(orig.getClass()), \n-                    new Object[] {orig});\n-                _proxies.put(orig.getClass(), proxy);\n+        Class type = orig.getClass();\n+        ProxyBean proxy = (ProxyBean) _proxies.get(type);\n+        if (proxy == null && !_proxies.containsKey(type)) {\n+            ClassLoader l = getMostDerivedLoader(type, ProxyBean.class);\n+            Class pcls = loadBuildTimeProxy(type, l);\n+            if (pcls == null) {\n+                BCClass bc = generateProxyBeanBytecode(type, true);\n+                if (bc != null)\n+                    pcls = loadProxy(bc, l);\n             }\n+            if (pcls != null)\n+                proxy = (ProxyBean) instantiateProxy(pcls, \n+                    findCopyConstructor(type), new Object[] {orig});\n+            _proxies.put(type, proxy);\n         }\n         return proxy;\n     }\n \n     /**\n-     * Instantiate the given proxy bytecode.\n+     * Load the proxy class generated at build time for the given type,\n+     * returning null if none exists.\n+     */\n+    private static Class loadBuildTimeProxy(Class type, ClassLoader loader) {\n+        try {\n+            return Class.forName(getProxyClassName(type, false), true, loader);\n+        } catch (Throwable t) {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Load the proxy class represented by the given bytecode.\n+     */\n+    private Class loadProxy(BCClass bc, ClassLoader loader) {\n+        BCClassLoader bcloader = new BCClassLoader(bc.getProject(), loader);\n+        try {\n+            return Class.forName(bc.getName(), true, bcloader);\n+        } catch (Throwable t) {\n+            throw new GeneralException(bc.getName()).setCause(t);\n+        }\n+    }\n+\n+    /**\n+     * Instantiate the given proxy class.\n      */\n-    private Proxy instantiateProxy(BCClass bc, Class type, Class proxy, \n-        Constructor cons, Object[] args) {\n-        BCClassLoader loader = new BCClassLoader(bc.getProject(),\n-            getMostDerivedClassLoader(type, proxy));\n+    private Proxy instantiateProxy(Class cls, Constructor cons, Object[] args) {\n         try {\n-            Class cls = Class.forName(bc.getName(), true, loader);\n             if (cons != null)\n                 return (Proxy) cls.getConstructor(cons.getParameterTypes()).\n                     newInstance(args);\n             return (Proxy) cls.newInstance();\n         } catch (InstantiationException ie) {\n-            throw new UnsupportedException(_loc.get(\"cant-classforname\", \n-                bc.getSuperclassName()));\n+            throw new UnsupportedException(_loc.get(\"cant-newinstance\", \n+                cls.getSuperclass().getName()));\n         } catch (Throwable t) {\n-            throw new GeneralException(t);\n+            throw new GeneralException(cls.getName()).setCause(t);\n         }\n     }\n \n     /**\n      * Return the more derived loader of the class laoders for the given \n      * classes.\n      */\n-    private static ClassLoader getMostDerivedClassLoader(Class c1, Class c2) {\n+    private static ClassLoader getMostDerivedLoader(Class c1, Class c2) {\n         ClassLoader l1 = c1.getClassLoader();\n         ClassLoader l2 = c2.getClassLoader();\n         if (l1 == l2)\n@@ -448,12 +481,11 @@ private static ClassLoader getMostDerivedClassLoader(Class c1, Class c2) {\n     /**\n      * Generate the bytecode for a collection proxy for the given type.\n      */\n-    protected BCClass generateProxyCollectionBytecode(Class type) {\n+    protected BCClass generateProxyCollectionBytecode(Class type, \n+        boolean runtime) {\n         assertNotFinal(type);\n         Project project = new Project(); \n-        BCClass bc = project.loadClass(Strings.getPackageName\n-            (ProxyManagerImpl.class) + \".\" + type.getName().replace('.', '$')\n-            + \"$\" + nextProxyId() + PROXY_SUFFIX);\n+        BCClass bc = project.loadClass(getProxyClassName(type, runtime));\n         bc.setSuperclass(type);\n         bc.declareInterface(ProxyCollection.class);\n  \n@@ -463,10 +495,19 @@ protected BCClass generateProxyCollectionBytecode(Class type) {\n         proxyRecognizedMethods(bc, type, ProxyCollections.class, \n             ProxyCollection.class);\n         proxySetters(bc, type);\n-        addWriteReplaceMethod(bc);\n+        addWriteReplaceMethod(bc, runtime);\n         return bc;\n     }\n \n+    /**\n+     * Return the name of the proxy class to generate for the given type.   \n+     */\n+    private static String getProxyClassName(Class type, boolean runtime) {\n+        String id = (runtime) ? \"$\" + nextProxyId() : \"\";\n+        return Strings.getPackageName(ProxyManagerImpl.class) + \".\" \n+            + type.getName().replace('.', '$') + id + PROXY_SUFFIX;\n+    }\n+\n     /**\n      * Throw appropriate exception if the given type is final.\n      */\n@@ -478,12 +519,10 @@ private static void assertNotFinal(Class type) {\n     /**\n      * Generate the bytecode for a map proxy for the given type.\n      */\n-    protected BCClass generateProxyMapBytecode(Class type) {\n+    protected BCClass generateProxyMapBytecode(Class type, boolean runtime) {\n         assertNotFinal(type);\n         Project project = new Project(); \n-        BCClass bc = project.loadClass(Strings.getPackageName\n-            (ProxyManagerImpl.class) + \".\" + type.getName().replace('.', '$')\n-            + \"$\" + nextProxyId() + PROXY_SUFFIX);\n+        BCClass bc = project.loadClass(getProxyClassName(type, runtime));\n         bc.setSuperclass(type);\n         bc.declareInterface(ProxyMap.class);\n  \n@@ -492,54 +531,51 @@ protected BCClass generateProxyMapBytecode(Class type) {\n         addProxyMapMethods(bc, type);\n         proxyRecognizedMethods(bc, type, ProxyMaps.class, ProxyMap.class);\n         proxySetters(bc, type);\n-        addWriteReplaceMethod(bc);\n+        addWriteReplaceMethod(bc, runtime);\n         return bc;\n     }\n \n     /**\n      * Generate the bytecode for a date proxy for the given type.\n      */\n-    protected BCClass generateProxyDateBytecode(Class type) {\n+    protected BCClass generateProxyDateBytecode(Class type, boolean runtime) {\n         assertNotFinal(type);\n         Project project = new Project(); \n-        BCClass bc = project.loadClass(Strings.getPackageName\n-            (ProxyManagerImpl.class) + \".\" + type.getName().replace('.', '$')\n-            + \"$\" + nextProxyId() + PROXY_SUFFIX);\n+        BCClass bc = project.loadClass(getProxyClassName(type, runtime));\n         bc.setSuperclass(type);\n         bc.declareInterface(ProxyDate.class);\n  \n         delegateConstructors(bc, type);\n         addProxyMethods(bc, type, true);\n         addProxyDateMethods(bc, type);\n         proxySetters(bc, type);\n-        addWriteReplaceMethod(bc);\n+        addWriteReplaceMethod(bc, runtime);\n         return bc;\n     }\n \n     /**\n      * Generate the bytecode for a calendar proxy for the given type.\n      */\n-    protected BCClass generateProxyCalendarBytecode(Class type) {\n+    protected BCClass generateProxyCalendarBytecode(Class type, \n+        boolean runtime) {\n         assertNotFinal(type);\n         Project project = new Project(); \n-        BCClass bc = project.loadClass(Strings.getPackageName\n-            (ProxyManagerImpl.class) + \".\" + type.getName().replace('.', '$')\n-            + \"$\" + nextProxyId() + PROXY_SUFFIX);\n+        BCClass bc = project.loadClass(getProxyClassName(type, runtime));\n         bc.setSuperclass(type);\n         bc.declareInterface(ProxyCalendar.class);\n  \n         delegateConstructors(bc, type);\n         addProxyMethods(bc, type, true);\n         addProxyCalendarMethods(bc, type);\n         proxySetters(bc, type);\n-        addWriteReplaceMethod(bc);\n+        addWriteReplaceMethod(bc, runtime);\n         return bc;\n     }\n \n     /**\n      * Generate the bytecode for a bean proxy for the given type.\n      */\n-    protected BCClass generateProxyBeanBytecode(Class type) {\n+    protected BCClass generateProxyBeanBytecode(Class type, boolean runtime) {\n         if (Modifier.isFinal(type.getModifiers()))\n             return null;\n         if (ImplHelper.isManagedType(type))\n@@ -558,9 +594,7 @@ protected BCClass generateProxyBeanBytecode(Class type) {\n         }\n \n         Project project = new Project(); \n-        BCClass bc = project.loadClass(Strings.getPackageName\n-            (ProxyManagerImpl.class) + \".\" + type.getName().replace('.', '$')\n-            + \"$\" + nextProxyId() + PROXY_SUFFIX);\n+        BCClass bc = project.loadClass(getProxyClassName(type, runtime));\n         bc.setSuperclass(type);\n         bc.declareInterface(ProxyBean.class);\n  \n@@ -569,7 +603,7 @@ protected BCClass generateProxyBeanBytecode(Class type) {\n         addProxyBeanMethods(bc, type, cons);\n         if (!proxySetters(bc, type))\n             return null;\n-        addWriteReplaceMethod(bc);\n+        addWriteReplaceMethod(bc, runtime);\n         return bc;\n     }\n \n@@ -1409,16 +1443,17 @@ private void proxySetter(BCClass bc, Class type, Method meth) {\n \n     /**\n      * Add a writeReplace implementation that serializes to a non-proxy type\n-     * unless detached.\n+     * unless detached and this is a build-time generated class.\n      */\n-    private void addWriteReplaceMethod(BCClass bc) {\n+    private void addWriteReplaceMethod(BCClass bc, boolean runtime) {\n         BCMethod m = bc.declareMethod(\"writeReplace\", Object.class, null);\n         m.makeProtected();\n         m.getExceptions(true).addException(ObjectStreamException.class);\n         Code code = m.getCode(true);\n         code.aload().setThis();\n+        code.constant().setValue(!runtime);\n         code.invokestatic().setMethod(Proxies.class, \"writeReplace\", \n-            Object.class, new Class[] { Proxy.class });\n+            Object.class, new Class[] { Proxy.class, boolean.class });\n         code.areturn();\n         code.calculateMaxLocals();\n         code.calculateMaxStack();\n@@ -1474,35 +1509,80 @@ private static Constructor findComparatorConstructor(Class cls) {\n     }\n \n     /**\n-     * Usage: java org.apache.openjpa.util.proxy.ProxyManagerImpl\n-     * &lt;class name&gt;+\n+     * Usage: java org.apache.openjpa.util.proxy.ProxyManagerImpl [option]*\n+     * &lt;class name&gt;+<br />\n+     * Where the following options are recognized:\n+     * <ul> \n+     * <li><i>-utils/-u &lt;number&gt;</i>: Generate proxies for the standard\n+     * java.util collection, map, date, and calendar classes of the given Java\n+     * version.  Use 4 for Java 1.4, 5 for Java 5, etc.</li>\n+     * </ul>\n      *\n      * The main method generates .class files for the proxies to the classes    \n-     * given on the command line.  The .class files are placed in the same\n-     * package as this class, or the current directory if the directory for this\n-     * class cannot be accessed.\n+     * given on the command line.  It writes the generated classes to beside the\n+     * ProxyManagerImpl.class file if possible; otherwise it writes to the \n+     * current directory.  The proxy manager looks for these classes \n+     * before generating its own proxies at runtime.\n      */\n     public static void main(String[] args) \n         throws ClassNotFoundException, IOException {\n         File dir = Files.getClassFile(ProxyManagerImpl.class);\n         dir = (dir == null) ? new File(System.getProperty(\"user.dir\"))\n             : dir.getParentFile();\n \n+        Options opts = new Options();\n+        args = opts.setFromCmdLine(args);\n+\n+        List types = new ArrayList();\n+        types.addAll(Arrays.asList(args));\n+        int utils = opts.removeIntProperty(\"utils\", \"u\", 0);\n+        if (utils >= 4) {\n+            types.addAll(Arrays.asList(new String[] {\n+                java.sql.Date.class.getName(),\n+                java.sql.Time.class.getName(),\n+                java.sql.Timestamp.class.getName(),\n+                java.util.ArrayList.class.getName(),\n+                java.util.Date.class.getName(),\n+                java.util.GregorianCalendar.class.getName(),\n+                java.util.HashMap.class.getName(),\n+                java.util.HashSet.class.getName(),\n+                java.util.Hashtable.class.getName(),\n+                java.util.LinkedList.class.getName(),\n+                java.util.Properties.class.getName(),\n+                java.util.TreeMap.class.getName(),\n+                java.util.TreeSet.class.getName(),\n+                java.util.Vector.class.getName(),\n+            })); \n+        }\n+        if (utils >= 5) {\n+            types.addAll(Arrays.asList(new String[] {\n+                \"java.util.EnumMap\",\n+                \"java.util.IdentityHashMap\",\n+                \"java.util.LinkedHashMap\",\n+                \"java.util.LinkedHashSet\",\n+                \"java.util.PriorityQueue\",\n+            })); \n+        }\n+\n         ProxyManagerImpl mgr = new ProxyManagerImpl();\n         Class cls;\n         BCClass bc;\n-        for (int i = 0; i < args.length; i++) {\n-            cls = Class.forName(args[i]);\n+        for (int i = 0; i < types.size(); i++) {\n+            cls = Class.forName((String) types.get(i));\n+            if (loadBuildTimeProxy(cls, getMostDerivedLoader(cls, Proxy.class))\n+                != null)\n+                continue;\n+\n             if (Collection.class.isAssignableFrom(cls))\n-                bc = mgr.generateProxyCollectionBytecode(cls);         \n+                bc = mgr.generateProxyCollectionBytecode(cls, false);         \n             else if (Map.class.isAssignableFrom(cls))\n-                bc = mgr.generateProxyMapBytecode(cls);         \n+                bc = mgr.generateProxyMapBytecode(cls, false);         \n             else if (Date.class.isAssignableFrom(cls))\n-                bc = mgr.generateProxyDateBytecode(cls);\n+                bc = mgr.generateProxyDateBytecode(cls, false);\n             else if (Calendar.class.isAssignableFrom(cls))\n-                bc = mgr.generateProxyCalendarBytecode(cls);\n+                bc = mgr.generateProxyCalendarBytecode(cls, false);\n             else\n-                bc = mgr.generateProxyBeanBytecode(cls);\n+                bc = mgr.generateProxyBeanBytecode(cls, false);\n \n             System.out.println(bc.getName());\n             bc.write(new File(dir, bc.getClassName() + \".class\"));"},{"sha":"f3a4ab8b2eefa60773ccdf87f7f21da6a4c30842","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/util/localizer.properties","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/d6dbadaa3cc643b201ca478885e3bde9d77543ed/openjpa-kernel/src/main/resources/org/apache/openjpa/util/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/d6dbadaa3cc643b201ca478885e3bde9d77543ed/openjpa-kernel/src/main/resources/org/apache/openjpa/util/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/util/localizer.properties?ref=d6dbadaa3cc643b201ca478885e3bde9d77543ed","patch":"@@ -49,7 +49,7 @@ no-proxy-intf: Unable to create a second class object proxy for interface \\\n     \"{0}\".  No corresponding concrete types are known.\n no-proxy-abstract: Unable to create a second class object proxy for abstract \\\n     type \"{0}\".  You must use a concrete type or a recognized interface.\n-cant-classforname: Unable to instantiate proxy for type \"{0}\".  Make sure the \\\n+cant-newinstance: Unable to instantiate proxy for type \"{0}\".  Make sure the \\\n     class has a default constructor.\n no-date-cons: Custom date type \"{0}\" needs a default constructor or a \\\n     millisecond constructor."}]}

