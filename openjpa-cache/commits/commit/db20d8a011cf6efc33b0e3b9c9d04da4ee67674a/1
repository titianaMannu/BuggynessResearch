{"sha":"db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","node_id":"MDY6Q29tbWl0MjA2MzY0OmRiMjBkOGEwMTFjZjZlZmMzM2IwZTNiOWM5ZDA0ZGE0ZWU2NzY3NGE=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2010-01-15T05:25:25Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2010-01-15T05:25:25Z"},"message":"OPENJPA-900: Reduce reflection cost. Enumerate hint keys. \n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@899530 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"7601cababb69940b613c3e8a7e781afc460b9326","url":"https://api.github.com/repos/apache/openjpa/git/trees/7601cababb69940b613c3e8a7e781afc460b9326"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","html_url":"https://github.com/apache/openjpa/commit/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","comments_url":"https://api.github.com/repos/apache/openjpa/commits/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/comments","author":null,"committer":null,"parents":[{"sha":"b5a412fd426ca91d06d2a8a10c45b60070dd2674","url":"https://api.github.com/repos/apache/openjpa/commits/b5a412fd426ca91d06d2a8a10c45b60070dd2674","html_url":"https://github.com/apache/openjpa/commit/b5a412fd426ca91d06d2a8a10c45b60070dd2674"}],"stats":{"total":1201,"additions":672,"deletions":529},"files":[{"sha":"9156db645b809c15ebbfdace494eda4d682f34a1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchConfiguration.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchConfiguration.java?ref=db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","patch":"@@ -119,7 +119,7 @@\n      *\n      * @since 0.4.0.0\n      */\n-    public Set getJoins();\n+    public Set<String> getJoins();\n \n     /**\n      * Return true if the given fully-qualified join has been added.\n@@ -144,7 +144,7 @@\n      *\n      * @since 0.4.0.0\n      */\n-    public JDBCFetchConfiguration addJoins(Collection fields);\n+    public JDBCFetchConfiguration addJoins(Collection<String> fields);\n \n     /**\n      * Removes <code>field</code> to the set of fully-qualified field names to\n@@ -160,7 +160,7 @@\n      *\n      * @since 0.4.0.0\n      */\n-    public JDBCFetchConfiguration removeJoins(Collection fields);\n+    public JDBCFetchConfiguration removeJoins(Collection<String> fields);\n \n     /**\n      * Clears the set of field names to join when loading data.\n@@ -215,7 +215,7 @@\n      *\n      * @since 1.0.3\n      */\n-    public Set getFetchInnerJoins();\n+    public Set<String> getFetchInnerJoins();\n \n     /**\n      * Return true if the given fully-qualified inner fetch join has been added.\n@@ -240,5 +240,5 @@\n      *\n      * @since 1.0.3\n      */\n-    public JDBCFetchConfiguration addFetchInnerJoins(Collection fields);\n+    public JDBCFetchConfiguration addFetchInnerJoins(Collection<String> fields);\n }"},{"sha":"4df87296921216260cf021c1fce3125b27495a53","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchConfigurationImpl.java","status":"modified","additions":42,"deletions":19,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCFetchConfigurationImpl.java?ref=db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","patch":"@@ -52,12 +52,32 @@\n  * @author Abe White\n  * @nojavadoc\n  */\n+@SuppressWarnings(\"serial\")\n public class JDBCFetchConfigurationImpl\n     extends FetchConfigurationImpl\n     implements JDBCFetchConfiguration {\n \n-    private static final Localizer _loc = Localizer.forPackage\n-        (JDBCFetchConfigurationImpl.class);\n+    private static final Localizer _loc = Localizer.forPackage(JDBCFetchConfigurationImpl.class);\n+    \n+    /**\n+     * Hint keys that correspond to a mutable bean-style setter in this receiver.\n+     * These keys are registered with both <code>openjpa.FetchPlan</code> and <code>openjpa.jdbc</code> as prefix.\n+     * <br>\n+     * A hint without a setter method is also recognized by this receiver.\n+     */\n+    static {\n+        String[] prefixes = {\"openjpa.FetchPlan\", \"openjpa.jdbc\"};\n+        Class<?> target = JDBCFetchConfiguration.class;\n+        populateHintSetter(target, \"EagerFetchMode\", int.class, prefixes);\n+        populateHintSetter(target, \"FetchDirection\", int.class, prefixes);\n+        populateHintSetter(target, \"Isolation\", int.class, prefixes);\n+        populateHintSetter(target, \"setIsolation\", \"TransactionIsolation\", int.class, \"openjpa.jdbc\");\n+        populateHintSetter(target, \"JoinSyntax\", int.class, prefixes);\n+        populateHintSetter(target, \"SubclassFetchMode\", int.class, prefixes);\n+        populateHintSetter(target, \"LRSSize\", int.class, prefixes);\n+        populateHintSetter(target, \"setLRSSize\", \"LRSSizeAlgorithm\", int.class, prefixes);\n+        populateHintSetter(target, \"ResultSetType\", int.class, prefixes);\n+    }\n \n     /**\n      * Configurable JDBC state shared throughout a traversal chain.\n@@ -69,8 +89,8 @@\n         public int direction = 0;\n         public int size = 0;\n         public int syntax = 0;\n-        public Set joins = null;\n-        public Set fetchInnerJoins = null;\n+        public Set<String> joins = null;\n+        public Set<String> fetchInnerJoins = null;\n         public int isolationLevel = -1;\n     }\n \n@@ -138,7 +158,7 @@ public JDBCFetchConfiguration setEagerFetchMode(int mode) {\n             _state.eagerMode = mode;\n         return this;\n     }\n-\n+    \n     public int getSubclassFetchMode() {\n         return _state.subclassMode;\n     }\n@@ -254,7 +274,7 @@ public JDBCFetchConfiguration setJoinSyntax(int syntax) {\n         return this;\n     }\n \n-    public ResultList newResultList(ResultObjectProvider rop) {\n+    public ResultList<?> newResultList(ResultObjectProvider rop) {\n         // if built around a list, just use a simple wrapper\n         if (rop instanceof ListResultObjectProvider)\n             return new SimpleResultList(rop);\n@@ -286,8 +306,10 @@ public ResultList newResultList(ResultObjectProvider rop) {\n         return new SimpleResultList(rop);\n     }\n \n-    public Set getJoins() {\n-        return (_state.joins == null) ? Collections.EMPTY_SET : _state.joins;\n+    public Set<String> getJoins() {\n+        if (_state.joins == null) \n+            return Collections.emptySet();\n+        return _state.joins;\n     }\n \n     public boolean hasJoin(String field) {\n@@ -301,19 +323,19 @@ public JDBCFetchConfiguration addJoin(String join) {\n         lock();\n         try {\n             if (_state.joins == null)\n-                _state.joins = new HashSet();\n+                _state.joins = new HashSet<String>();\n             _state.joins.add(join);\n         } finally {\n             unlock();\n         }\n         return this;\n     }\n \n-    public JDBCFetchConfiguration addJoins(Collection joins) {\n+    public JDBCFetchConfiguration addJoins(Collection<String> joins) {\n         if (joins == null || joins.isEmpty())\n             return this;\n-        for (Iterator itr = joins.iterator(); itr.hasNext();)\n-            addJoin((String) itr.next());\n+        for (Iterator<String> itr = joins.iterator(); itr.hasNext();)\n+            addJoin(itr.next());\n         return this;\n     }\n \n@@ -328,7 +350,7 @@ public JDBCFetchConfiguration removeJoin(String field) {\n         return this;\n     }\n \n-    public JDBCFetchConfiguration removeJoins(Collection joins) {\n+    public JDBCFetchConfiguration removeJoins(Collection<String> joins) {\n         lock();\n         try {\n             if (_state.joins != null)\n@@ -390,9 +412,10 @@ private JDBCConfiguration getJDBCConfiguration() {\n         return (JDBCConfiguration) conf;\n     }\n \n-    public Set getFetchInnerJoins() {\n-        return (_state.fetchInnerJoins == null) ? Collections.EMPTY_SET\n-            : _state.fetchInnerJoins;\n+    public Set<String> getFetchInnerJoins() {\n+        if (_state.fetchInnerJoins == null) \n+            return Collections.emptySet();\n+        return _state.fetchInnerJoins;\n     }\n \n     public boolean hasFetchInnerJoin(String field) {\n@@ -407,18 +430,18 @@ public JDBCFetchConfiguration addFetchInnerJoin(String join) {\n         lock();\n         try {\n             if (_state.fetchInnerJoins == null)\n-                _state.fetchInnerJoins = new HashSet();\n+                _state.fetchInnerJoins = new HashSet<String>();\n             _state.fetchInnerJoins.add(join);\n         } finally {\n             unlock();\n         }\n         return this;\n     }\n \n-    public JDBCFetchConfiguration addFetchInnerJoins(Collection joins) {\n+    public JDBCFetchConfiguration addFetchInnerJoins(Collection<String> joins) {\n         if (joins == null || joins.isEmpty())\n             return this;\n-        for (Iterator itr = joins.iterator(); itr.hasNext();)\n+        for (Iterator<String> itr = joins.iterator(); itr.hasNext();)\n             addFetchInnerJoin((String) itr.next());\n         return this;\n     }"},{"sha":"a8781b85ed936c21b108b40d6afda82f0762f476","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractHintHandler.java","status":"removed","additions":0,"deletions":121,"changes":121,"blob_url":"https://github.com/apache/openjpa/blob/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractHintHandler.java","raw_url":"https://github.com/apache/openjpa/raw/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractHintHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractHintHandler.java?ref=b5a412fd426ca91d06d2a8a10c45b60070dd2674","patch":"@@ -1,121 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.kernel;\n-\n-import java.io.Serializable;\n-import java.lang.reflect.Method;\n-\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\n-import org.apache.openjpa.enhance.Reflection;\n-import org.apache.openjpa.lib.util.Localizer;\n-\n-/**\n- * Default hint handler abstract base class.\n- *\n- * @since 2.0.0\n- * @nojavadoc\n- */\n-public abstract class AbstractHintHandler implements Serializable {\n-\n-    private static final Localizer _loc = Localizer\n-        .forPackage(AbstractHintHandler.class);\n-\n-    protected static final String DOT = \".\";\n-    protected static final String BLANK = \"\";\n-\n-    protected static final String PREFIX_OPENJPA = \"openjpa.\";\n-    protected static final String PREFIX_JDBC = PREFIX_OPENJPA + \"jdbc.\";\n-\n-    protected FetchConfiguration _fConfig;\n-\n-    /**\n-     * Constructor; supply delegate.\n-     */\n-    public AbstractHintHandler(FetchConfiguration fConfig) {\n-        _fConfig = fConfig;\n-    }\n-\n-    protected abstract boolean setHintInternal(String hintName, Object value,\n-        boolean validateThrowException);\n-\n-    public boolean setHint(String hintName, Object value, boolean validateThrowException) {\n-        String key = hintToKey(hintName);\n-        boolean valueSet = !hintName.equals(key);\n-        if (hasPrecedent(hintName)) {\n-            try {\n-                valueSet |= setHintInternal(key, value, validateThrowException);\n-            } catch (RuntimeException rte) {\n-                if (validateThrowException) {\n-                    if (rte instanceof IllegalArgumentException)\n-                        throw rte;\n-                    else if (rte instanceof ClassCastException)\n-                        throw new IllegalArgumentException(_loc.get(\"bad-hint-value\", key, value, rte.getMessage())\n-                            .getMessage());\n-                    else {\n-                        handleException(rte);\n-                    }\n-                } else\n-                    _fConfig.getContext().getConfiguration().getConfigurationLog().warn(\n-                            _loc.get(\"bad-hint-value\", key, value, rte.getMessage()));\n-            }\n-        } else {\n-            valueSet = true;\n-        }\n-        return valueSet;\n-    }\n-    \n-    protected String hintToKey(String key) {\n-        return key;\n-    }\n-    \n-    protected boolean hasPrecedent(String key) {\n-        return true;\n-    }\n-\n-    protected void handleException(RuntimeException e) {\n-        throw e;\n-    }\n-    \n-    protected final boolean hintToSetter(Object target, String k, \n-        Object value) {\n-        if (target == null || k == null)\n-            return false;\n-        // remove key prefix as the source of property name\n-        k = getSuffixOf(k);\n-        Method setter = Reflection.findSetter(target.getClass(), k, true);\n-        Class paramType = setter.getParameterTypes()[0];\n-        if (Enum.class.isAssignableFrom(paramType) && value instanceof String) {\n-            // to accomodate alias name input in relationship with enum values \n-            String strValue = ((String) value).toUpperCase().replace('-', '_');\n-            value = Enum.valueOf(paramType, strValue);\n-        }\n-        Filters.hintToSetter(target, k, value);\n-        return true;\n-    }\n-\n-    protected static String getPrefixOf(String key) {\n-        int firstDot = key == null ? -1 : key.indexOf(DOT);\n-        return (firstDot != -1) ? key.substring(0, firstDot) : key;\n-    }\n-\n-    protected static String getSuffixOf(String key) {\n-        int lastDot = key == null ? -1 : key.lastIndexOf(DOT);\n-        return (lastDot != -1) ? key.substring(lastDot + 1) : key;\n-    }\n-}"},{"sha":"a1f01cbb44d340aa8b1e6220086663eb49d48572","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","status":"modified","additions":32,"deletions":23,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java?ref=db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","patch":"@@ -361,49 +361,58 @@\n     public ResultList<?> newResultList(ResultObjectProvider rop);\n \n     /**\n-     * Sets an arbitrary query hint that may be utilized during\n-     * execution. The hint may be datastore-specific.\n+     * Sets an arbitrary query hint that may be utilized during execution. \n+     * The hint may be specific to a particular database. A hint, if known \n+     * to this receiver, may have a corresponding setter method, then the hint sets the value.\n+     * Otherwise the hint is stored opaquely by the receiver.\n      *\n      * @param name the name of the hint\n-     * @param value the value of the hint\n-     * @since 0.4.0\n+     * @param value the value of the hint. If the hint has a corresponding setter, then\n+     * the type of value must be same as the setter argument. \n+     * @param original the value of the hint as specified by the user. \n+     * \n+     * @since 2.0.0\n      */\n-    public void setHint(String name, Object value);\n-\n+    public void setHint(String name, Object value, Object original);\n+    \n     /**\n-     * Sets an arbitrary query hint that may be utilized during\n-     * execution. The hint may be datastore-specific.\n+     * Sets an arbitrary query hint that may be utilized during execution. \n+     * The hint may be specific to a particular database. A hint, if known \n+     * to this receiver, may have a corresponding setter method, then the hint sets the value.\n+     * Otherwise the hint is stored opaquely by the receiver.\n+     * <br>\n+     * This is same as calling {@linkplain #setHint(String, Object, Object)} with the third\n+     * argument being the same as the second.\n      *\n      * @param name the name of the hint\n-     * @param value the value of the hint\n+     * @param value the value of the hint. If the hint has a corresponding setter, then\n+     * the type of value must be same as the setter argument. \n+     * \n      * @since 2.0.0\n      */\n-    public void setHint(String name, Object value, boolean validate);\n+    public void setHint(String key, Object value);\n \n     /**\n-     * Returns the hint for the specific key, or null if the hint\n-     * is not specified.\n+     * Get the hint value for the specific key as originally set by the caller, or null if the hint is not specified.\n      *\n \t * @param name the hint name\n \t * @since 0.4.0\n \t */\n-\tpublic Object getHint (String name);\n+\tpublic Object getHint (String key);\n \t\n-    /**\n-     * Adds the hint and the associated value to the list.\n-     *\n-     * @param name the name of the hint\n-     * @param value the value of the hint\n-     * @since 2.0.0\n-     */\n-    public void addHint(String name, Object value);\n-\n \t/**\n-     * Returns an immutable view of the currently active hints and their values.\n+     * Get an immutable view of the currently active hints and their values.\n+\t * The values are as specified by the user.\n \t * \n \t * @since 2.0.0\n \t */\n \tpublic Map<String, Object> getHints();\n+\t\n+\t/**\n+\t * Affirm if the given hint has been set in this receiver.\n+\t * \n+\t */\n+\tpublic boolean isHintSet(String key);\n \n     /**\n      * Root classes for recursive operations. This set is not thread safe."},{"sha":"54b7c6018918bee05883d5b5eaf40ef753182d8c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationHintHandler.java","status":"removed","additions":0,"deletions":65,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationHintHandler.java","raw_url":"https://github.com/apache/openjpa/raw/b5a412fd426ca91d06d2a8a10c45b60070dd2674/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationHintHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationHintHandler.java?ref=b5a412fd426ca91d06d2a8a10c45b60070dd2674","patch":"@@ -1,65 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.openjpa.kernel;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-/**\n- * Fetch configuration hint handler. Handles openjpa.* and openjpa.jdbc.* hints.\n- *\n- * @since 2.0.0\n- * @nojavadoc\n- */\n-@SuppressWarnings(\"serial\")\n-public class FetchConfigurationHintHandler extends AbstractHintHandler {\n-\n-    protected static final Map<String, String> hintsMap = new HashMap<String, String>();\n-\n-    static {\n-        // Initialize hint to property name mapping.\n-        hintsMap.put(PREFIX_JDBC + \"TransactionIsolation\", \"Isolation\");\n-    }\n-\n-    /**\n-     * Constructor; supply delegate.\n-     */\n-    public FetchConfigurationHintHandler(FetchConfigurationImpl fConfig) {\n-        super(fConfig);\n-    }\n-\n-    public boolean setHintInternal(String hintName, Object value, boolean validateThrowException) {\n-        boolean valueSet = false;\n-        String longPrefix = hintName.substring(0, hintName.lastIndexOf(DOT) + 1);\n-        if ((longPrefix.equals(PREFIX_JDBC) || longPrefix.equals(PREFIX_OPENJPA))) {\n-            valueSet = hintToSetter(_fConfig, hintToPropName(hintName), value);\n-        } else {\n-            valueSet = true;\n-        }\n-        return valueSet;\n-    }\n-\n-    private String hintToPropName(String hintName) {\n-        String propName = hintsMap.get(hintName);\n-        if (propName == null) {\n-            propName = hintName;\n-        }\n-        return propName;\n-    }\n-}"},{"sha":"657bd57fce64fe560cdf83cd84a6403a5ea2faa7","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","status":"modified","additions":149,"deletions":45,"changes":194,"blob_url":"https://github.com/apache/openjpa/blob/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java?ref=db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","patch":"@@ -19,6 +19,7 @@\n package org.apache.openjpa.kernel;\n \n import java.io.Serializable;\n+import java.lang.reflect.Method;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n@@ -29,7 +30,6 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-import java.util.TreeMap;\n \n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n@@ -62,8 +62,65 @@\n public class FetchConfigurationImpl\n     implements FetchConfiguration, Cloneable {\n \n-    private static final Localizer _loc = Localizer.forPackage\n-        (FetchConfigurationImpl.class);\n+    private static final Localizer _loc = Localizer.forPackage(FetchConfigurationImpl.class);\n+    private static Map<String, Method> _hintSetters = new HashMap<String, Method>();\n+    \n+    /** \n+     * Registers hint keys that have a corresponding setter method.\n+     * The hint keys are registered in <code>openjpa.FetchPlan</code> and <code>openjpa</code> as prefix.\n+     * Also some keys are registered in <code>javax.persistence</code> namespace.\n+     */\n+    static {\n+            String[] prefixes = {\"openjpa.FetchPlan\", \"openjpa\"};\n+            Class<?> target = FetchConfiguration.class;\n+            populateHintSetter(target, \"ExtendedPathLookup\", boolean.class, prefixes);\n+            populateHintSetter(target, \"FetchBatchSize\", int.class, prefixes);\n+            populateHintSetter(target, \"FlushBeforeQueries\", int.class, prefixes);\n+            populateHintSetter(target, \"LockScope\", int.class, prefixes);\n+            populateHintSetter(target, \"LockTimeout\", int.class, prefixes);\n+            populateHintSetter(target, \"setLockTimeout\", \"timeout\", int.class, \"javax.persistence.lock\");\n+            populateHintSetter(target, \"MaxFetchDepth\", int.class, prefixes);\n+            populateHintSetter(target, \"QueryTimeout\", int.class, prefixes);\n+            populateHintSetter(target, \"setQueryTimeout\", \"timeout\", int.class, \"javax.persistence.query\");\n+            populateHintSetter(target, \"ReadLockLevel\", int.class, prefixes);\n+            populateHintSetter(target, \"setReadLockLevel\", \"ReadLockMode\", int.class, prefixes);\n+            populateHintSetter(target, \"WriteLockLevel\", int.class, prefixes);\n+            populateHintSetter(target, \"setWriteLockLevel\", \"WriteLockMode\", int.class, prefixes);\n+    }\n+    \n+    /**\n+     * Populate static registry of hints.\n+     *  \n+     * @param target The name of the target class that will receive this hint. \n+     * @param hint the simple name of the hint without a prefix. \n+     * @param type the value argument type of the target setter method. \n+     * @param prefixes the prefixes will be added to the simple hint name. \n+     */\n+    protected static void populateHintSetter(Class<?> target, String hint, Class<?> type, String...prefixes) {\n+        populateHintSetter(target, \"set\" + hint, hint, type, prefixes);\n+    }\n+    \n+    /**\n+     * Populate static registry of hints.\n+     *  \n+     * @param target The name of the target class that will receive this hint. \n+     * @param method The name of the method in the target class that will receive this hint. \n+     * @param hint the simple name of the hint without a prefix. \n+     * @param type the value argument type of the target setter method. \n+     * @param prefixes the prefixes will be added to the simple hint name. \n+     */\n+    protected static void populateHintSetter(Class<?> target, String method, String hint, Class<?> type, \n+            String...prefixes) {\n+        try {\n+            Method setter = target.getMethod(method, type);\n+            for (String prefix : prefixes) {\n+                _hintSetters.put(prefix + \".\" + hint, setter);\n+            }\n+        } catch (Exception e) {\n+            // should not reach\n+            throw new InternalException(\"setter for \" + hint + \" with argument \" + type + \" does not exist\");\n+        }\n+    }\n \n     /**\n      * Configurable state shared throughout a traversal chain.\n@@ -90,7 +147,7 @@\n         public boolean fetchGroupContainsAll = false;\n         public boolean extendedPathLookup = false;\n         public DataCacheRetrieveMode cacheRetrieveMode;\n-        public DataCacheStoreMode cacheStoreMode;\n+        public DataCacheStoreMode cacheStoreMode;        \n     }\n \n     private final ConfigurationState _state;\n@@ -101,7 +158,6 @@\n     private boolean _load = true;\n     private int _availableRecursion;\n     private int _availableDepth;\n-    private FetchConfigurationHintHandler _hintHandler;\n \n     public FetchConfigurationImpl() {\n         this(null);\n@@ -110,7 +166,6 @@ public FetchConfigurationImpl() {\n     protected FetchConfigurationImpl(ConfigurationState state) {\n         _state = (state == null) ? new ConfigurationState() : state;\n         _availableDepth = _state.maxFetchDepth;\n-        _hintHandler = new FetchConfigurationHintHandler(this);\n     } \n \n     public StoreContext getContext() {\n@@ -501,16 +556,6 @@ public FetchConfiguration setLockScope(int scope) {\n     }\n \n     public int getReadLockLevel() {\n-        String lockModeKey = \"openjpa.FetchPlan.ReadLockMode\";\n-        String deferLockModeKey = lockModeKey + \".Defer\";\n-        Integer value = (Integer)getHint(deferLockModeKey);\n-        if (value != null) {\n-            if (isActiveTransaction()) {\n-                removeHint(deferLockModeKey);\n-                setReadLockLevel(value);\n-            } else\n-                return value;\n-        }\n         return _state.readLockLevel;\n     }\n \n@@ -546,16 +591,6 @@ public FetchConfiguration setReadLockLevel(int level) {\n     }\n \n     public int getWriteLockLevel() {\n-        String lockModeKey = \"openjpa.FetchPlan.WriteLockMode\";\n-        String deferLockModeKey = lockModeKey + \".Defer\";\n-        Integer value = (Integer)getHint(deferLockModeKey);\n-        if (value != null) {\n-            if (isActiveTransaction()) {\n-                removeHint(deferLockModeKey);\n-                setWriteLockLevel(value);\n-            } else\n-                return value;\n-        }\n         return _state.writeLockLevel;\n     }\n \n@@ -610,17 +645,93 @@ private void assertActiveTransaction() {\n     private boolean isActiveTransaction() {\n         return (_state.ctx != null && _state.ctx.isActive());\n     }\n-\n-    public void setHint(String name, Object value) {\n-        setHint(name, value, false);\n+    \n+    /**\n+     * Gets the current hints set on this receiver. \n+     * The values designate the actual value specified by the caller and not the values\n+     * that may have been actually set on the state variables of this receiver.\n+     * \n+     */\n+    public Map<String,Object> getHints() {\n+        if (_state.hints == null)\n+            return Collections.emptyMap();\n+        return Collections.unmodifiableMap(_state.hints);\n     }\n-\n-    public void setHint(String name, Object value, boolean validThrowException) {\n-        if (_hintHandler.setHint(name, value, validThrowException))\n-            addHint(name, value);\n+    \n+    /**\n+     * Affirms if the given key is set as a hint.\n+     */\n+    public boolean isHintSet(String key) {\n+        return _state.hints != null && _state.hints.containsKey(key);\n     }\n-\n-    public void addHint(String name, Object value) {\n+    \n+    /**\n+     * Removes the given keys and their hint value.\n+     */\n+    public void removeHint(String...keys) {\n+        if (keys == null || _state.hints == null )\n+            return;\n+        for (String key : keys) {\n+            _state.hints.remove(key);\n+        }\n+    }\n+    \n+    public Collection<String> getSupportedHints() {\n+        return _hintSetters.keySet();\n+    }\n+    \n+    /**\n+     * Same as <code>setHint(key, value, value)</code>.\n+     * \n+     * @see #setHint(String, Object, Object)\n+     */\n+    public void setHint(String key, Object value) {\n+        setHint(key, value, value);\n+    }\n+    \n+    /**\n+     * Sets the hint to the given value.\n+     * If the key corresponds to a known key, then that value is set via the setter method.\n+     * Otherwise it is put into opaque hints map.  \n+     * <br>\n+     * In either case, the original value is put in the hints map.\n+     * So essential difference between setting a value directly by a setter and via a hint is the memory\n+     * of this original value.\n+     * <br>\n+     * The other important difference is setting lock levels. Setting of lock level via setter method needs\n+     * active transaction. But setting via hint does not. \n+     * @param key a hint key. If it is one of the statically registered hint key then the setter is called.\n+     * @param value to be set. The given value type must match the argument type of the setter, if one exists.\n+     * @param original value as specified by the caller. This value is put in the hints map.\n+     * \n+     * @exception IllegalArgumentException if the given value is not acceptable by the setter method, if one\n+     * exists corresponds the given hint key.\n+     */\n+    public void setHint(String key, Object value, Object original) {\n+        if (key == null)\n+            return;\n+        if (_hintSetters.containsKey(key)) {\n+            Method setter = _hintSetters.get(key);\n+            String methodName = setter.getName();\n+            try {\n+                if (\"setReadLockLevel\".equals(methodName) && !isActiveTransaction()) {\n+                    _state.readLockLevel = (Integer)value;\n+                } else if (\"setWriteLockLevel\".equals(methodName) && !isActiveTransaction()) {\n+                    _state.writeLockLevel = (Integer)value;\n+                } else {\n+                    setter.invoke(this, value);\n+                }\n+            } catch (Exception e) {\n+                if (e instanceof IllegalArgumentException)\n+                    throw (IllegalArgumentException)e;\n+                throw new IllegalArgumentException(_loc.get(\"bad-hint-value\", key, toString(value), \n+                        toString(original)).getMessage(), e);\n+            }\n+        }\n+        addHint(key, original);\n+    }\n+    \n+    private void addHint(String name, Object value) {\n         lock();\n         try {\n             if (_state.hints == null)\n@@ -639,16 +750,6 @@ public Object removeHint(String name) {\n         return (_state.hints == null) ? null : _state.hints.remove(name);\n     }\n     \n-    public Map<String, Object> getHints() {\n-        if (_state.hints == null)\n-            return Collections.emptyMap();\n-        Map<String, Object> result = new TreeMap<String, Object>();\n-        for (Object key : _state.hints.keySet()) {\n-            result.put(key.toString(), _state.hints.get(key));\n-        }\n-        return result;\n-    }\n-\n     public Set<Class<?>> getRootClasses() {\n         if (_state.rootClasses == null) return Collections.emptySet(); \n         return _state.rootClasses;\n@@ -926,4 +1027,7 @@ private String getPathString() {\n         return buf.toString();\n     }\n \n+    protected String toString(Object o) {\n+        return o == null ? \"null\" : o.toString() + \"[\" + o.getClass().getName() + \"]\";\n+    }\n }"},{"sha":"873c9eb70dd2a833a323c5cafa9cb0c7dc3e798e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryHints.java","status":"modified","additions":10,"deletions":2,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryHints.java","raw_url":"https://github.com/apache/openjpa/raw/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryHints.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryHints.java?ref=db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","patch":"@@ -22,12 +22,20 @@\n  * Standard query hint keys.\n  */\n public interface QueryHints {\n+    // These keys are directly handled in {@link QueryImpl} class.\n+    // Declaring a public static final String variable in this class will \n+    // make it register as a supported hint key\n+    // if you do not want that then annotate as {@link Reflectable(false)}.\n+    public static final String HINT_SUBCLASSES          = \"openjpa.Subclasses\";\n+    public static final String HINT_FILTER_LISTENER     = \"openjpa.FilterListener\";\n+    public static final String HINT_FILTER_LISTENERS    = \"openjpa.FilterListeners\";\n+    public static final String HINT_AGGREGATE_LISTENER  = \"openjpa.AggregateListener\";\n+    public static final String HINT_AGGREGATE_LISTENERS = \"openjpa.AggregateListeners\";\n     \n     /** \n      * Hint to specify the number of rows to optimize for.\n      */\n-    public static final String HINT_RESULT_COUNT =\n-        \"openjpa.hint.OptimizeResultCount\";\n+    public static final String HINT_RESULT_COUNT = \"openjpa.hint.OptimizeResultCount\";\n     \n     /**\n      * Hints to signal that the JPQL/SQL query string contains a parameter"},{"sha":"23a80824f81f714be50910451ccf888cd34deca2","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties?ref=db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","patch":"@@ -412,7 +412,7 @@ query-execution-error: Failed to execute query \"{0}\". Check the query syntax \\\n \tfor correctness. See nested exception for details.\n invalid-timeout: An invalid timeout of {0} milliseconds was ignored.  \\\n     Expected a value that is greater than or equal to -1.\n-bad-hint-value: \"{1}\" is not a valid value for hint \"{0}\" caused by: {2}.\n+bad-hint-value: Hint \"{0}\" can not be set to {1}. The original value was {2}. See nested exception for details.\n bad-flush-before-queries: Invalid flush before queries type. Valid values are \\\n \t\"true\"(0), \"false\"(1) or \"with-connection\"(2). Specified value: {0}.\n bad-lock-level: Invalid lock mode/level. Valid values are \\"},{"sha":"b6e2119a33fc431f8d3c533b585ba81d9d659e7b","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/IsolationLevel.java","status":"modified","additions":38,"deletions":8,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/IsolationLevel.java","raw_url":"https://github.com/apache/openjpa/raw/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/IsolationLevel.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/IsolationLevel.java?ref=db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","patch":"@@ -21,25 +21,28 @@\n import java.sql.Connection;\n \n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.persistence.OpenJPAEnum;\n \n /**\n  * Isolation levels for use in {@link JDBCFetchPlan#setIsolation}.\n  *\n  * @since 0.9.7\n  * @published\n  */\n-public enum IsolationLevel {\n-    DEFAULT(-1),\n-    NONE(Connection.TRANSACTION_NONE),\n-    READ_UNCOMMITTED(Connection.TRANSACTION_READ_UNCOMMITTED),\n-    READ_COMMITTED(Connection.TRANSACTION_READ_COMMITTED),\n-    REPEATABLE_READ(Connection.TRANSACTION_REPEATABLE_READ),\n-    SERIALIZABLE(Connection.TRANSACTION_SERIALIZABLE);\n+public enum IsolationLevel implements OpenJPAEnum<IsolationLevel>{\n+    DEFAULT(-1, \"default\"),\n+    NONE(Connection.TRANSACTION_NONE, \"none\"),\n+    READ_UNCOMMITTED(Connection.TRANSACTION_READ_UNCOMMITTED, \"read-uncommitted\", \"READ_UNCOMMITTED\"),\n+    READ_COMMITTED(Connection.TRANSACTION_READ_COMMITTED, \"read-committed\", \"READ_COMMITTED\"),\n+    REPEATABLE_READ(Connection.TRANSACTION_REPEATABLE_READ, \"repeatable-read\", \"REPEATABLE_READ\"),\n+    SERIALIZABLE(Connection.TRANSACTION_SERIALIZABLE, \"serializable\");\n \n     private final int _connectionConstant;\n+    private final String[] _names;\n \n-    private IsolationLevel(int connectionConstant) {\n+    private IsolationLevel(int connectionConstant, String... names) {\n         _connectionConstant = connectionConstant;\n+        _names = names;\n     }\n \n     public int getConnectionConstant() {\n@@ -72,4 +75,31 @@ public static IsolationLevel fromConnectionConstant(int constant) {\n                     Integer.valueOf(constant).toString());\n         }\n     }\n+\n+    public IsolationLevel fromKernelConstant(int i) {\n+        return IsolationLevel.fromConnectionConstant(i);\n+    }\n+\n+    public int toKernelConstant() {\n+        return getConnectionConstant();\n+    }\n+    \n+    public static int toKernelConstantFromString(String s) {\n+        for (IsolationLevel level : IsolationLevel.values()) {\n+            for (String name : level._names) {\n+                if (name.equalsIgnoreCase(s) || String.valueOf(level.toKernelConstant()).equals(s))\n+                    return level.toKernelConstant();\n+            }\n+        }\n+        throw new IllegalArgumentException(s + \" is not a valid name for \" + IsolationLevel.class.getName());\n+    }\n+    \n+    public int convertToKernelConstant(String s) {\n+        return IsolationLevel.toKernelConstantFromString(s);\n+    }\n+    \n+    public int convertToKernelConstant(int i) {\n+        return IsolationLevel.fromConnectionConstant(i).toKernelConstant();\n+    }\n+\n }"},{"sha":"b7ea755d2497ec0f69dd5ca132f21cd95b01fbd0","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCPersistenceProductDerivation.java","status":"modified","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCPersistenceProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCPersistenceProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/JDBCPersistenceProductDerivation.java?ref=db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","patch":"@@ -19,13 +19,18 @@\n package org.apache.openjpa.persistence.jdbc;\n \n import java.security.AccessController;\n+import java.util.Collections;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Set;\n \n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.conf.OpenJPAProductDerivation;\n import org.apache.openjpa.conf.Specification;\n import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n import org.apache.openjpa.jdbc.kernel.JDBCStoreManager;\n+import org.apache.openjpa.jdbc.sql.MySQLDictionary;\n+import org.apache.openjpa.jdbc.sql.OracleDictionary;\n import org.apache.openjpa.lib.conf.AbstractProductDerivation;\n import org.apache.openjpa.lib.conf.Configuration;\n import org.apache.openjpa.lib.util.J2DoPrivHelper;\n@@ -42,6 +47,7 @@\n     extends AbstractProductDerivation \n     implements OpenJPAProductDerivation {\n     \n+    \n     public void putBrokerFactoryAliases(Map m) {\n     }\n \n@@ -100,5 +106,31 @@ public boolean afterSpecificationSet(Configuration c) {\n         conf.mappingDefaultsPlugin.setDefault(jpa.getName());\n         conf.mappingDefaultsPlugin.setString(jpa.getName());\n         return true;\n+    } \n+    \n+    /**\n+     * Hint keys correspond to some (not all) bean-style mutable property name in JDBCFetchConfiguration.\n+     * The fully qualified key is prefixed with <code>openjpa.jdbc</code>.\n+     */\n+    private static Set<String> _hints = new HashSet<String>();\n+    static {\n+        _hints.add(\"openjpa.FetchPlan.EagerFetchMode\");\n+        _hints.add(\"openjpa.FetchPlan.FetchDirection\");\n+        _hints.add(\"openjpa.FetchPlan.TransactionIsolation\");\n+        _hints.add(\"openjpa.FetchPlan.JoinSyntax\");\n+        _hints.add(\"openjpa.FetchPlan.LRSSize\");\n+        _hints.add(\"openjpa.FetchPlan.ResultSetType\");\n+        _hints.add(\"openjpa.FetchPlan.SubclassFetchMode\");\n+        \n+        _hints.add(MySQLDictionary.SELECT_HINT);\n+        _hints.add(OracleDictionary.SELECT_HINT);\n+        \n+        _hints = Collections.unmodifiableSet(_hints);\n     }\n+\n+    @Override\n+    public Set<String> getSupportedQueryHints() {\n+        return _hints;\n+    }\n+\n }"},{"sha":"6f36c4f9f7039b59948caa723611c2eec62b5b09","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/LRSSizeAlgorithm.java","status":"modified","additions":37,"deletions":7,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/LRSSizeAlgorithm.java","raw_url":"https://github.com/apache/openjpa/raw/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/LRSSizeAlgorithm.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/LRSSizeAlgorithm.java?ref=db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","patch":"@@ -19,25 +19,29 @@\n package org.apache.openjpa.persistence.jdbc;\n \n import org.apache.openjpa.jdbc.kernel.LRSSizes;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.persistence.OpenJPAEnum;\n \n /**\n  * Algorithm to use for computing the size of an LRS relation.\n  *\n  * @since 1.0.0\n  * @published\n  */\n-public enum LRSSizeAlgorithm {\n-    UNKNOWN(LRSSizes.SIZE_UNKNOWN),\n-    LAST(LRSSizes.SIZE_LAST),\n-    QUERY(LRSSizes.SIZE_QUERY);\n+public enum LRSSizeAlgorithm implements OpenJPAEnum<Enum<?>> {\n+    UNKNOWN(LRSSizes.SIZE_UNKNOWN, \"unknown\"),\n+    LAST(LRSSizes.SIZE_LAST, \"last\"),\n+    QUERY(LRSSizes.SIZE_QUERY, \"query\");\n \n     private final int lrsConstant;\n-\n-    private LRSSizeAlgorithm(int value) {\n+    private final String[] _names;\n+    \n+    private LRSSizeAlgorithm(int value, String...aliases) {\n         lrsConstant = value;\n+        _names = aliases;\n     }\n \n-    int toKernelConstant() {\n+    public int toKernelConstant() {\n         return lrsConstant;\n     }\n \n@@ -56,4 +60,30 @@ static LRSSizeAlgorithm fromKernelConstant(int kernelConstant) {\n                 throw new IllegalArgumentException(kernelConstant + \"\");\n         }\n     }\n+\n+    public int convertToKernelConstant(String s) {\n+        return LRSSizeAlgorithm.toKernelConstantFromString(s);\n+    }\n+    \n+    public int convertToKernelConstant(int i) {\n+        try {\n+            if (i == FetchConfiguration.DEFAULT)\n+                return i;\n+            return LRSSizeAlgorithm.values()[i].ordinal();\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new IllegalArgumentException(i + \" is invalid value for LRSSize Algorithm\");\n+        }\n+    }\n+    \n+    public static int toKernelConstantFromString(String s) {\n+        for (LRSSizeAlgorithm level : LRSSizeAlgorithm.values()) {\n+            for (String name : level._names) {\n+                if (name.equalsIgnoreCase(s) || String.valueOf(level.toKernelConstant()).equals(s))\n+                    return level.toKernelConstant();\n+            }\n+        }\n+        throw new IllegalArgumentException(s + \" is not a valid name for \" + IsolationLevel.class.getName());\n+    }\n+\n+\n }"},{"sha":"b190bd3df03e97ec349578c98c31719e224fe72f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestQueryTimeout.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestQueryTimeout.java","raw_url":"https://github.com/apache/openjpa/raw/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestQueryTimeout.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestQueryTimeout.java?ref=db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","patch":"@@ -799,8 +799,7 @@ public void testQueryTimeout5() {\n         } catch (Exception e) {\n             // expected - setHint(-2000) should cause IllegalArgumentException\n             checkException(\"testQueryTimeout5()\", e, \n-                IllegalArgumentException.class, \"invalid timeout of \"\n-                + NumberFormat.getIntegerInstance().format(setTime));\n+                IllegalArgumentException.class, null);\n         } finally {\n             if ((em != null) && em.isOpen()) {\n                 em.close();"},{"sha":"34d830643a37a4dba8fc4fa4d9c7b73c6ca6c04b","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java","status":"modified","additions":24,"deletions":45,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java","raw_url":"https://github.com/apache/openjpa/raw/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlan.java?ref=db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","patch":"@@ -94,7 +94,6 @@\n      *\n      * @since 1.0.0\n      */\n-    @Reflectable(false)\n     public boolean getQueryResultCacheEnabled();\n \n     /**\n@@ -109,58 +108,14 @@\n     /**\n      * @deprecated use {@link #getQueryResultCacheEnabled()} instead.\n      */\n-    @Reflectable(false)\n     public boolean getQueryResultCache();\n \n     /**\n      * @deprecated use {@link #setQueryResultCacheEnabled} instead.\n      */\n     public FetchPlan setQueryResultCache(boolean cache);\n     \n-    /**\n-     * Gets the hint for the given key.\n-     * \n-     * @since 2.0.0\n-     */\n-    public Object getHint(String key);\n-    \n-    /**\n-     * Sets the hint for the given key to the given value.\n-     * \n-     * @since 2.0.0\n-     */\n-    public void setHint(String key, Object value);\n     \n-    /**\n-     * Sets the hint for the given key to the given value.\n-     * \n-     * @since 2.0.0\n-     */\n-    public void setHint(String key, Object value, boolean validThrowException);\n-\n-    /**\n-     * Adds the hint and the associated value to the list.\n-     *\n-     * @param name the name of the hint\n-     * @param value the value of the hint\n-     * @since 2.0.0\n-     */\n-    public void addHint(String name, Object value);\n-\n-    /**\n-     * Sets the hint keys and values currently set of this receiver.\n-     * \n-     * @since 2.0.0\n-     */\n-    public void addHints(Map<String, Object> hints);\n-\n-    /**\n-     * Gets the hint keys and values currently set of this receiver.\n-     * \n-     * @since 2.0.0\n-     */\n-    public Map<String, Object> getHints();\n-\n     /**\n      * Returns the names of the fetch groups that this component will use\n      * when loading objects. Defaults to the\n@@ -411,4 +366,28 @@\n      * @since 2.0.0\n      */\n     public FetchPlan setCacheRetrieveMode(DataCacheRetrieveMode mode);\n+    \n+    /**\n+     * Set the hint for the given key to the given value.\n+     * \n+     * @param value the value of the hint.\n+     * @param name the name of the hint.\n+     * \n+     * @since 2.0.0\n+     */\n+    public void setHint(String key, Object value);\n+\n+    /**\n+     * Get the hints and their values currently set on this receiver.\n+     * \n+     * @return empty map if no hint has been set.\n+     */\n+    Map<String, Object> getHints();\n+    \n+    /**\n+     * Get the hint value for the given key.\n+     * \n+     * @return null if the key has not been set.\n+     */\n+    Object getHint(String key);\n }"},{"sha":"3c8712d1bb9593f668aba7c38e43f0495fff114d","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanImpl.java","status":"modified","additions":121,"deletions":20,"changes":141,"blob_url":"https://github.com/apache/openjpa/blob/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanImpl.java","raw_url":"https://github.com/apache/openjpa/raw/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/FetchPlanImpl.java?ref=db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","patch":"@@ -21,7 +21,9 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.HashMap;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n \n import javax.persistence.LockModeType;\n@@ -31,6 +33,7 @@\n import org.apache.openjpa.kernel.DataCacheStoreMode;\n import org.apache.openjpa.kernel.DelegatingFetchConfiguration;\n import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.QueryFlushModes;\n \n /**\n  * Implements FetchPlan via delegation to FetchConfiguration.\n@@ -44,23 +47,82 @@\n \timplements FetchPlan {\n \n     private final DelegatingFetchConfiguration _fetch;\n-    private FetchPlanHintHandler _hintHandler;\n+    \n+    /**\n+     * Structure holds ranking of equivalent hint keys. Each entry value is a list of other keys that are higher rank\n+     * than the entry key.   \n+     */\n+    protected static Map<String, List<String>> _precedence = new HashMap<String, List<String>>();\n+    \n+    /**\n+     * Structure holds one or more converters for a user-specified hint value. \n+     */\n+    protected static Map<String,HintValueConverter[]> _hints = new HashMap<String,HintValueConverter[]>();\n+    \n+    /**\n+     * Statically registers supported hint keys with their ranking and converters. \n+     */\n+    static {\n+        registerHint(new String[]{\"openjpa.FetchPlan.ExtendedPathLookup\"}, \n+                new HintValueConverter.StringToBoolean());\n+        registerHint(new String[]{\"openjpa.FetchBatchSize\", \"openjpa.FetchPlan.FetchBatchSize\"}, \n+                new HintValueConverter.StringToInteger());\n+        registerHint(new String[]{\"openjpa.MaxFetchDepth\", \"openjpa.FetchPlan.MaxFetchDepth\"}, \n+                new HintValueConverter.StringToInteger());\n+        registerHint(new String[]{\"openjpa.LockTimeout\", \"openjpa.FetchPlan.LockTimeout\", \n+                \"javax.persistence.lock.timeout\"}, new HintValueConverter.StringToInteger());\n+        registerHint(new String[]{\"openjpa.QueryTimeout\", \"openjpa.FetchPlan.QueryTimeout\", \n+                \"javax.persistence.query.timeout\"}, new HintValueConverter.StringToInteger());\n+        registerHint(new String[]{\"openjpa.FlushBeforeQueries\", \"openjpa.FetchPlan.FlushBeforeQueries\"}, \n+                new HintValueConverter.StringToInteger(\n+                   new String[] {\"0\", \"1\", \"2\"},\n+                   new int[]{QueryFlushModes.FLUSH_TRUE, QueryFlushModes.FLUSH_FALSE, \n+                           QueryFlushModes.FLUSH_WITH_CONNECTION}));\n+        registerHint(new String[]{\"openjpa.ReadLockMode\", \"openjpa.FetchPlan.ReadLockMode\"},\n+                new MixedLockLevelsHelper());\n+        registerHint(new String[]{\"openjpa.ReadLockLevel\", \"openjpa.FetchPlan.ReadLockLevel\"},\n+                new MixedLockLevelsHelper());\n+        registerHint(new String[]{\"openjpa.WriteLockMode\", \"openjpa.FetchPlan.WriteLockMode\"}, \n+                new MixedLockLevelsHelper());\n+        registerHint(new String[]{\"openjpa.WriteLockLevel\", \"openjpa.FetchPlan.WriteLockLevel\"}, \n+                new MixedLockLevelsHelper());\n+    }\n+    \n+    /**\n+     * Registers a hint key with its value converters. \n+     * \n+     * @param keys a set of keys in increasing order of ranking. Can not be null or empty.\n+     * \n+     * @param converters array of converters that are attempts in order to convert a user-specified hint value\n+     * to a value that is consumable by the kernel.\n+     */\n+    protected static void registerHint(String[] keys, HintValueConverter... converters) {\n+        for (String key : keys) {\n+            _hints.put(key, converters);\n+        }\n+        if (keys.length > 1) {\n+            for (int i = 0; i < keys.length-1; i++) {\n+                List<String> list = new ArrayList<String>(keys.length-i-1);\n+                for (int j = i+1; j < keys.length; j++) {\n+                    list.add(keys[j]);\n+                }\n+                _precedence.put(keys[i], list);\n+            }\n+        }\n+    }\n     \n     /**\n      * Constructor; supply delegate.\n      */\n     public FetchPlanImpl(FetchConfiguration fetch) {\n         _fetch = newDelegatingFetchConfiguration(fetch);\n-        _hintHandler = new FetchPlanHintHandler(this);\n     }\n \n     /**\n      * Create a new exception-translating delegating fetch configuration.\n      */\n-    protected DelegatingFetchConfiguration newDelegatingFetchConfiguration\n-        (FetchConfiguration fetch) {\n-        return new DelegatingFetchConfiguration(fetch,\n-            PersistenceExceptions.TRANSLATOR);\n+    protected DelegatingFetchConfiguration newDelegatingFetchConfiguration(FetchConfiguration fetch) {\n+        return new DelegatingFetchConfiguration(fetch, PersistenceExceptions.TRANSLATOR);\n     }\n \n     /**\n@@ -287,23 +349,30 @@ public Object getHint(String key) {\n         return _fetch.getHint(key);\n     }\n     \n-    public void addHint(String key, Object value) {\n-        _fetch.addHint(key, value);\n-    }\n-\n+    /**\n+     * Sets the hint after converting the value appropriately.\n+     * If a higher ranking equivalent hint is already set, then bypasses this hint. \n+     */\n     public void setHint(String key, Object value) {\n-        setHint(key, value, true);\n-    }\n-\n-    public void setHint(String key, Object value, boolean validThrowException) {\n-        if( _hintHandler.setHint(key, value, validThrowException) )\n-            _fetch.addHint(key, value);\n+        if (!isRecognizedHint(key))\n+            return;\n+        if (_precedence.containsKey(key)) {\n+            List<String> higherKeys = _precedence.get(key);\n+            for (String higherKey : higherKeys) {\n+                if (_fetch.isHintSet(higherKey))\n+                    return;\n+            }\n+        }\n+        Object newValue = convertHintValue(key, value); \n+        _fetch.setHint(key, newValue, value);\n     }\n \n-    public void addHints(Map<String, Object> hints) {\n-        if (hints != null && hints.size() > 0) {\n-            for (String name : hints.keySet())\n-                setHint(name, hints.get(name), false);\n+    public void setHints(Map<String, Object> hints) {\n+        if (hints == null || hints.isEmpty()) {\n+            return;\n+        }\n+        for (Map.Entry<String,Object> hint : hints.entrySet()) {\n+            setHint(hint.getKey(), hint.getValue());\n         }\n     }\n     \n@@ -340,4 +409,36 @@ public FetchPlan setCacheRetrieveMode(DataCacheRetrieveMode mode) {\n         _fetch.setCacheRetrieveMode(mode);\n         return this;\n     }\n+\n+    Object convertHintValue(String key, Object value) {\n+        if (value == null)\n+            return null;\n+        HintValueConverter[] converters = _hints.get(key);\n+        if (converters == null)\n+            return value;\n+        for (HintValueConverter converter : converters) {\n+            if (converter.canConvert(value.getClass())) {\n+                return converter.convert(value);\n+            }\n+        }\n+        return value;\n+    }\n+    \n+    boolean isRecognizedHint(String key) {\n+        if (key == null)\n+            return false;\n+        if (_hints.containsKey(key))\n+            return true;\n+        return key.startsWith(\"openjpa.\");\n+    }\n+    \n+    boolean intersects(Collection<String> keys, Collection<String> b) {\n+        if (keys == null || keys.isEmpty() || b == null || b.isEmpty())\n+            return false;\n+        for (String key : keys) {\n+            if (b.contains(key))\n+                return true;\n+        }\n+        return false;\n+    }\n }"},{"sha":"2f3c3bb0ff9b4c04d8d63c7aedd7b755178219b9","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/HintHandler.java","status":"modified","additions":127,"deletions":166,"changes":293,"blob_url":"https://github.com/apache/openjpa/blob/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/HintHandler.java","raw_url":"https://github.com/apache/openjpa/raw/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/HintHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/HintHandler.java?ref=db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","patch":"@@ -18,23 +18,18 @@\n  */\n package org.apache.openjpa.persistence;\n \n-import static org.apache.openjpa.kernel.QueryHints.HINT_IGNORE_PREPARED_QUERY;\n-import static org.apache.openjpa.kernel.QueryHints\n-                    .HINT_INVALIDATE_PREPARED_QUERY;\n-import static org.apache.openjpa.kernel.QueryHints.HINT_RESULT_COUNT;\n-\n-import java.lang.reflect.Modifier;\n import java.util.Collections;\n-import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.TreeMap;\n-import java.util.TreeSet;\n \n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.enhance.Reflection;\n import org.apache.openjpa.kernel.FetchConfiguration;\n import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.QueryHints;\n import org.apache.openjpa.kernel.exps.AggregateListener;\n import org.apache.openjpa.kernel.exps.FilterListener;\n import org.apache.openjpa.lib.conf.ProductDerivation;\n@@ -97,206 +92,172 @@\n  * \n  * @nojavadoc\n  */\n-public class HintHandler extends FetchPlanHintHandler {\n+public class HintHandler  {\n+  protected final QueryImpl<?> owner;\n \n-    private static final Localizer _loc = Localizer.forPackage(\n-        HintHandler.class);\n+    private static final Localizer _loc = Localizer.forPackage(HintHandler.class);\n+    protected static Set<String> _supportedHints = ProductDerivations.getSupportedQueryHints();\n \n-    private final QueryImpl owner;\n+    protected static final String PREFIX_OPENJPA = \"openjpa.\";\n+    protected static final String PREFIX_JDBC = PREFIX_OPENJPA + \"jdbc.\";\n+    protected static final String PREFIX_FETCHPLAN = PREFIX_OPENJPA + \"FetchPlan.\";\n     private Map<String, Object> _hints;\n-    private static Set<String> _supportedKeys;\n-    private static Set<String> _supportedPrefixes;\n-    \n-    // These keys are directly handled in {@link QueryImpl} class.\n-    // Declaring a public static final String variable in this class will \n-    // make it register as a supported hint key\n-    // if you do not want that then annotate as {@link Reflectable(false)}.\n-    public static final String HINT_SUBCLASSES = \"openjpa.Subclasses\";\n-    public static final String HINT_FILTER_LISTENER = \"openjpa.FilterListener\";\n-    public static final String HINT_FILTER_LISTENERS = \n-        \"openjpa.FilterListeners\";\n-    public static final String HINT_AGGREGATE_LISTENER = \n-        \"openjpa.AggregateListener\";\n-    public static final String HINT_AGGREGATE_LISTENERS = \n-        \"openjpa.AggregateListeners\";\n+\n     \n-    HintHandler(QueryImpl impl) {\n-        super((FetchPlanImpl)impl.getFetchPlan());\n+    HintHandler(QueryImpl<?> impl) {\n+        super();\n         owner = impl;\n     }\n     \n-    /**\n-     * Gets all the recorded hint keys and their values.\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    public Map<String, Object> getHints() {\n-        return _hints == null ? Collections.EMPTY_MAP \n-            : Collections.unmodifiableMap(_hints);\n-    }\n-    \n     /**\n      * Record a key-value pair only only if the given key is supported.\n      * \n      * @return FALSE if the key is unrecognized. \n      *         null (i.e. MAY BE) if the key is recognized, but not supported.\n      *         TRUE if the key is supported.\n      */\n-    private Boolean record(String hint, Object value) {\n+    protected Boolean record(String hint, Object value) {\n         if (hint == null)\n             return Boolean.FALSE;\n-        if (isSupported(hint)) {\n+        if (_supportedHints.contains(hint)) {\n             if (_hints == null)\n                 _hints = new TreeMap<String, Object>();\n             _hints.put(hint, value);\n             return Boolean.TRUE;\n         }\n-        \n-        Log log = owner.getDelegate().getBroker().getConfiguration()\n-            .getLog(OpenJPAConfiguration.LOG_RUNTIME);\n-        String possible = StringDistance.getClosestLevenshteinDistance(hint, \n-            getSupportedHints());\n-        if (log.isWarnEnabled())\n-            log.warn(_loc.get(\"bad-query-hint\", hint, possible));\n-        return (isKnownHintPrefix(hint)) ? null : Boolean.FALSE;\n-    }\n-    \n-    /**\n-     * Gets all the supported hint keys. The set of supported hint keys is\n-     * statically determined by collecting hint keys from the ProductDerivations\n-     * and reflecting upon some of the known classes.\n-     */\n-    public Set<String> getSupportedHints() {\n-        if (_supportedKeys == null) {\n-            _supportedKeys = new TreeSet<String>();\n-            _supportedPrefixes = new TreeSet<String>();\n-            \n-            _supportedKeys.addAll(Reflection.getFieldValues(\n-                org.apache.openjpa.kernel.QueryHints.class, \n-                Modifier.PUBLIC | Modifier.STATIC | Modifier.FINAL, \n-                String.class));\n-\n-            _supportedKeys.addAll(addPrefix(PREFIX_FETCHPLAN, \n-                Reflection.getBeanStylePropertyNames(\n-                      owner.getFetchPlan().getClass())));\n-\n-            _supportedKeys.addAll(javaxHintsMap.keySet());\n-\n-            _supportedKeys.addAll(Reflection.getFieldValues(\n-                HintHandler.class, \n-                Modifier.PUBLIC | Modifier.STATIC | Modifier.FINAL, \n-                String.class));\n-\n-            _supportedKeys.addAll(ProductDerivations.getSupportedQueryHints());\n-            \n-            for (String key : _supportedKeys) {\n-                _supportedPrefixes.add(getPrefixOf(key));\n-            }\n+        if (isKnownPrefix(hint)) {\n+            Log log = owner.getDelegate().getBroker().getConfiguration().getLog(OpenJPAConfiguration.LOG_RUNTIME);\n+            String possible = StringDistance.getClosestLevenshteinDistance(hint, getSupportedHints());\n+            if (log.isWarnEnabled())\n+                log.warn(_loc.get(\"bad-query-hint\", hint, possible));\n+            return null; // possible but not registered\n         }\n-        return _supportedKeys;\n-    }\n-    \n-    /**\n-     * Add a hint key to the set of supported hint keys.\n-     */\n-    public void addHintKey(String key) {\n-        getSupportedHints().add(key);\n-        _supportedPrefixes.add(getPrefixOf(key));\n-    }\n-    \n-    public Set<String> getKnownPrefixes() {\n-        getSupportedHints();\n-        return _supportedPrefixes;\n-    }\n-    \n-    /**\n-     * Affirms the given key matches one of the supported keys.\n-     */\n-    private boolean isSupported(String key) {\n-        return getSupportedHints().contains(key);\n-    }\n-    \n-    private boolean isKnownHintPrefix(String key) {\n-        String prefix = getPrefixOf(key);\n-        return getKnownPrefixes().contains(prefix);\n+        return Boolean.FALSE; // not possible\n     }\n \n     public void setHint(String key, Object value) {\n-        owner.lock();\n-        try {\n-            Boolean record = record(key, value);\n-            if (record == Boolean.FALSE)\n-                return;\n-            FetchPlan plan = owner.getFetchPlan();\n-            if (record == null) {\n-                plan.setHint(key, value);\n-                return;\n-            }\n-            // request to throw IllegalArgumentException, if needed.\n-            if (setHint(key, value, true))\n-                plan.addHint(key, value);\n-        } finally {\n-            owner.unlock();\n+        Boolean status = record(key, value);\n+        if (Boolean.FALSE.equals(status))\n+            return;\n+        FetchPlan plan = owner.getFetchPlan();\n+        if (status == null) {\n+            plan.setHint(key, value);\n+            return;\n         }\n-    }\n-    \n-    protected boolean setHintInternal(String key, Object value,\n-        boolean validateThrowException) {\n+        \n         ClassLoader loader = owner.getDelegate().getBroker().getClassLoader();\n-        FetchPlan fPlan = owner.getFetchPlan();\n-        boolean objectSet = true;\n-        if (HINT_SUBCLASSES.equals(key)) {\n+        if (QueryHints.HINT_SUBCLASSES.equals(key)) {\n             if (value instanceof String)\n                 value = Boolean.valueOf((String) value);\n             owner.setSubclasses(((Boolean) value).booleanValue());\n-        } else if (HINT_FILTER_LISTENER.equals(key))\n-            owner.addFilterListener(Filters.hintToFilterListener(value, \n-                loader));\n-        else if (HINT_FILTER_LISTENERS.equals(key)) {\n+        } else if (QueryHints.HINT_FILTER_LISTENER.equals(key)) {\n+            owner.addFilterListener(Filters.hintToFilterListener(value, loader));\n+        } else if (QueryHints.HINT_FILTER_LISTENERS.equals(key)) {\n             FilterListener[] arr = Filters.hintToFilterListeners(value, loader);\n             for (int i = 0; i < arr.length; i++)\n                 owner.addFilterListener(arr[i]);\n-        } else if (HINT_AGGREGATE_LISTENER.equals(key))\n-            owner.addAggregateListener(Filters.hintToAggregateListener(value,\n-                loader));\n-        else if (HINT_AGGREGATE_LISTENERS.equals(key)) {\n-            AggregateListener[] arr = Filters.hintToAggregateListeners(value,\n-                loader);\n-            for (int i = 0; i < arr.length; i++)\n+        } else if (QueryHints.HINT_AGGREGATE_LISTENER.equals(key)) {\n+            owner.addAggregateListener(Filters.hintToAggregateListener(value, loader));\n+        } else if (QueryHints.HINT_AGGREGATE_LISTENERS.equals(key)) {\n+            AggregateListener[] arr = Filters.hintToAggregateListeners(value, loader);\n+            for (int i = 0; i < arr.length; i++) {\n                 owner.addAggregateListener(arr[i]);\n-        } else if (HINT_RESULT_COUNT.equals(key)) {\n+            }\n+        } else if (QueryHints.HINT_RESULT_COUNT.equals(key)) {\n             int v = (Integer) Filters.convert(value, Integer.class);\n-            if (v < 0)\n-                throw new ArgumentException(_loc.get(\"bad-query-hint-value\",\n-                    key, value), null, null, false);\n-            fPlan.setHint(key, v);\n-            objectSet = false;\n-        } else if (HINT_INVALIDATE_PREPARED_QUERY.equals(key)) {\n-            fPlan.setHint(key, Filters.convert(value, Boolean.class));\n+            if (v < 0) {\n+                throw new IllegalArgumentException(_loc.get(\"bad-query-hint-value\", key, value).toString());\n+            }\n+            plan.setHint(key, v);\n+        } else if (QueryHints.HINT_INVALIDATE_PREPARED_QUERY.equals(key)) {\n+            plan.setHint(key, Filters.convert(value, Boolean.class));\n             owner.invalidatePreparedQuery();\n-            objectSet = false;\n-        } else if (HINT_IGNORE_PREPARED_QUERY.equals(key)) {\n-            fPlan.setHint(key, Filters.convert(value, Boolean.class));\n+        } else if (QueryHints.HINT_IGNORE_PREPARED_QUERY.equals(key)) {\n+            plan.setHint(key, Filters.convert(value, Boolean.class));\n             owner.ignorePreparedQuery();\n-            objectSet = false;\n         } else { // default \n-            fPlan.setHint(key, value);\n-            objectSet = false;\n+            plan.setHint(key, value);\n         }\n-        return objectSet;\n     }\n-\n-    protected String hintToKey(String key) {\n-        // Let superclass performs key transformation when fPlan.setHint() \n-        // is called.\n-        return key;\n+    \n+    /**\n+     * Affirms if the given key starts with any of the known prefix.\n+     * @param key\n+     * @return\n+     */\n+    protected boolean isKnownPrefix(String key) {\n+        if (key == null)\n+            return false;\n+        for (String prefix : ProductDerivations.getConfigurationPrefixes()) {\n+            if (key.startsWith(prefix))\n+                return true;\n+        }\n+        return false;\n     }\n \n-    private Set<String> addPrefix(String prefix, Set<String> original) {\n-        Set<String> result = new TreeSet<String>();\n-        String join = prefix.endsWith(DOT) ? BLANK : DOT;\n-        for (String o : original)\n-            result.add(prefix + join + o);\n-        return result;\n+    \n+    \n+//    protected boolean hasPrecedent(String key) {\n+//        boolean hasPrecedent = true;\n+//        String[] list = precedenceMap.get(key);\n+//        if (list != null) {\n+//            for (String hint : list) {\n+//                if (hint.equals(key))\n+//                    break;\n+//                // stop if a higher precedence hint has already defined \n+//                if (getHints().containsKey(hint)) {\n+//                    hasPrecedent = false;\n+//                    break;\n+//                }\n+//            }\n+//        }\n+//        return hasPrecedent;\n+//    }\n+\n+//    private Integer toLockLevel(Object value) {\n+//        Object origValue = value;\n+//        if (value instanceof String) {\n+//            // to accommodate alias name input in relationship with enum values\n+//            //  e.g. \"optimistic-force-increment\" == LockModeType.OPTIMISTIC_FORCE_INCREMENT\n+//            String strValue = ((String) value).toUpperCase().replace('-', '_');\n+//            value = Enum.valueOf(LockModeType.class, strValue);\n+//        }\n+//        if (value instanceof LockModeType)\n+//            value = MixedLockLevelsHelper.toLockLevel((LockModeType) value);\n+//\n+//        Integer intValue = null;\n+//        if (value instanceof Integer)\n+//            intValue = (Integer) value;\n+//        if (intValue == null\n+//            || (intValue != MixedLockLevels.LOCK_NONE\n+//                && intValue != MixedLockLevels.LOCK_READ\n+//                && intValue != MixedLockLevels.LOCK_OPTIMISTIC\n+//                && intValue != MixedLockLevels.LOCK_WRITE\n+//                && intValue != MixedLockLevels.LOCK_OPTIMISTIC_FORCE_INCREMENT\n+//                && intValue != MixedLockLevels.LOCK_PESSIMISTIC_READ\n+//                && intValue != MixedLockLevels.LOCK_PESSIMISTIC_WRITE\n+//                && intValue != MixedLockLevels.LOCK_PESSIMISTIC_FORCE_INCREMENT)\n+//                )\n+//            throw new IllegalArgumentException(_loc.get(\"bad-lock-level\", origValue).getMessage());\n+//        return intValue;\n+//    }\n+    \n+    /**\n+     * Gets all the supported hint keys. The set of supported hint keys is\n+     * statically determined by collecting hint keys from the ProductDerivations.\n+     */\n+    public Set<String> getSupportedHints() {\n+        return _supportedHints;\n     }\n+    \n+    /**\n+     * Gets all the recorded hint keys and their values.\n+     */\n+    public Map<String, Object> getHints() {\n+        if (_hints == null)\n+            return Collections.emptyMap();\n+        return Collections.unmodifiableMap(_hints);\n+    }\n+\n }\n "},{"sha":"39db10e28ae92a98d479c7b38cd317d21a9d701e","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEnum.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEnum.java","raw_url":"https://github.com/apache/openjpa/raw/db20d8a011cf6efc33b0e3b9c9d04da4ee67674a/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEnum.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/OpenJPAEnum.java?ref=db20d8a011cf6efc33b0e3b9c9d04da4ee67674a","patch":"@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence;\n+\n+/**\n+ * An interface to define conversion of a facade based enum to a kernel integer constant.\n+ * Facade specific enums implement this interface to convert user specified string or integer.\n+ * \n+ * @author Pinaki Poddar\n+ * @since 2.0.0\n+ * \n+ * @param <E> the enum type that needs to be converted. \n+ */\n+public interface OpenJPAEnum<E extends Enum<?>> {\n+    /**\n+     * Convert this receiver to an equivalent kernel constant.\n+     */\n+    int toKernelConstant();\n+    \n+    /**\n+     * Convert the given integer to an equivalent kernel constant.\n+     * This method has a <em>static</em> semantics in the sense that it can be invoked on any enum instance, \n+     * but the conversion is done w.r.t. all enums of the generic type. \n+     * \n+     * @exception throw IllegalArgumentException if no enum instance of the generic type matches the given integer. \n+     */\n+    int convertToKernelConstant(int i);\n+\n+    /**\n+     * Convert the given String to an equivalent kernel constant.\n+     * This method has a <em>static</em> semantics in the sense that it can be invoked on any enum instance, \n+     * but the conversion is done w.r.t. all enums of the generic type. \n+     * \n+     * @exception throw IllegalArgumentException if no enum instance of the generic type matches the given String. \n+     */\n+    int convertToKernelConstant(String s);\n+}"}]}

