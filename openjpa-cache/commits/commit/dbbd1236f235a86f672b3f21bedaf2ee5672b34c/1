{"sha":"dbbd1236f235a86f672b3f21bedaf2ee5672b34c","node_id":"MDY6Q29tbWl0MjA2MzY0OmRiYmQxMjM2ZjIzNWE4NmY2NzJiM2YyMWJlZGFmMmVlNTY3MmIzNGM=","commit":{"author":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2008-05-28T06:08:41Z"},"committer":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2008-05-28T06:08:41Z"},"message":"OPENJPA-612 Add support for calculating update value in QueryImpl.updateInMemory\nHelp comitting patch provided by Fay Wang\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@660825 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0d8e69264e22d977e8f9726ef6668e3f4b121a21","url":"https://api.github.com/repos/apache/openjpa/git/trees/0d8e69264e22d977e8f9726ef6668e3f4b121a21"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/dbbd1236f235a86f672b3f21bedaf2ee5672b34c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/dbbd1236f235a86f672b3f21bedaf2ee5672b34c","html_url":"https://github.com/apache/openjpa/commit/dbbd1236f235a86f672b3f21bedaf2ee5672b34c","comments_url":"https://api.github.com/repos/apache/openjpa/commits/dbbd1236f235a86f672b3f21bedaf2ee5672b34c/comments","author":null,"committer":null,"parents":[{"sha":"c1e5f27724f3b4a39d9624a8758d56c2a3ee6b0f","url":"https://api.github.com/repos/apache/openjpa/commits/c1e5f27724f3b4a39d9624a8758d56c2a3ee6b0f","html_url":"https://github.com/apache/openjpa/commit/c1e5f27724f3b4a39d9624a8758d56c2a3ee6b0f"}],"stats":{"total":2483,"additions":1312,"deletions":1171},"files":[{"sha":"0acabbc0eaa857ce0c541589d3bc99c6880502b0","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","status":"modified","additions":109,"deletions":0,"changes":109,"blob_url":"https://github.com/apache/openjpa/blob/dbbd1236f235a86f672b3f21bedaf2ee5672b34c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/dbbd1236f235a86f672b3f21bedaf2ee5672b34c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java?ref=dbbd1236f235a86f672b3f21bedaf2ee5672b34c","patch":"@@ -35,10 +35,12 @@\n import org.apache.openjpa.jdbc.kernel.exps.JDBCExpressionFactory;\n import org.apache.openjpa.jdbc.kernel.exps.JDBCStringContains;\n import org.apache.openjpa.jdbc.kernel.exps.JDBCWildcardMatch;\n+import org.apache.openjpa.jdbc.kernel.exps.PCPath;\n import org.apache.openjpa.jdbc.kernel.exps.QueryExpressionsState;\n import org.apache.openjpa.jdbc.kernel.exps.SQLEmbed;\n import org.apache.openjpa.jdbc.kernel.exps.SQLExpression;\n import org.apache.openjpa.jdbc.kernel.exps.SQLValue;\n+import org.apache.openjpa.jdbc.kernel.exps.Val;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n import org.apache.openjpa.jdbc.meta.strats.VerticalClassStrategy;\n@@ -50,18 +52,24 @@\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.jdbc.sql.Union;\n import org.apache.openjpa.kernel.ExpressionStoreQuery;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.OrderingMergedResultObjectProvider;\n import org.apache.openjpa.kernel.QueryHints;\n+import org.apache.openjpa.kernel.exps.Constant;\n import org.apache.openjpa.kernel.exps.ExpressionFactory;\n import org.apache.openjpa.kernel.exps.ExpressionParser;\n import org.apache.openjpa.kernel.exps.FilterListener;\n+import org.apache.openjpa.kernel.exps.Literal;\n import org.apache.openjpa.kernel.exps.QueryExpressions;\n import org.apache.openjpa.lib.rop.MergedResultObjectProvider;\n import org.apache.openjpa.lib.rop.RangeResultObjectProvider;\n import org.apache.openjpa.lib.rop.ResultObjectProvider;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.meta.ValueMetaData;\n+import org.apache.openjpa.util.UnsupportedException;\n import org.apache.openjpa.util.UserException;\n import serp.util.Numbers;\n \n@@ -671,4 +679,105 @@ protected PreparedStatement prepareStatement(Connection conn, SQLBuffer sql)\n         throws SQLException {\n         return sql.prepareStatement(conn);\n     }    \n+\n+    public Object evaluate(Object value, Object ob, Object[] params,\n+        OpenJPAStateManager sm) {\n+        if (value instanceof org.apache.openjpa.jdbc.kernel.exps.Math) {\n+            org.apache.openjpa.jdbc.kernel.exps.Math mathVal =\n+                (org.apache.openjpa.jdbc.kernel.exps.Math) value;\n+\n+            Val value1 = mathVal.getVal1();\n+            Object val1 = getValue(value1, ob, params, sm);\n+            Class c1 = value1.getType();\n+\n+            Val value2 = mathVal.getVal2();\n+            Object val2 = getValue(value2, ob, params, sm);\n+            Class c2 = value2.getType();\n+\n+            String op = mathVal.getOperation();\n+\n+            if (op.equals(org.apache.openjpa.jdbc.kernel.exps.Math.ADD))\n+                return Filters.add(val1, c1, val2, c2);\n+            else if (op.equals(\n+                    org.apache.openjpa.jdbc.kernel.exps.Math.SUBTRACT))\n+                return Filters.subtract(val1, c1, val2, c2);\n+            else if (op.equals(\n+                    org.apache.openjpa.jdbc.kernel.exps.Math.MULTIPLY))\n+                return Filters.multiply(val1, c1, val2, c2);\n+            else if (op.equals(\n+                    org.apache.openjpa.jdbc.kernel.exps.Math.DIVIDE))\n+                return Filters.divide(val1, c1, val2, c2);\n+            else if (op.equals(org.apache.openjpa.jdbc.kernel.exps.Math.MOD))\n+                return Filters.mod(val1, c1, val2, c2);\n+            throw new UnsupportedException();\n+        }\n+        throw new UnsupportedException();\n+    }\n+\n+    private Object getValue(Object ob, FieldMapping fmd,\n+        OpenJPAStateManager sm) {\n+        int i = fmd.getIndex();\n+        switch (fmd.getDeclaredTypeCode()) {\n+            case JavaTypes.BOOLEAN:\n+                return sm.fetchBooleanField(i);\n+            case JavaTypes.BYTE:\n+                return sm.fetchByteField(i);\n+            case JavaTypes.CHAR:\n+                return sm.fetchCharField(i);\n+            case JavaTypes.DOUBLE:\n+                return sm.fetchDoubleField(i);\n+            case JavaTypes.FLOAT:\n+                return sm.fetchFloatField(i);\n+            case JavaTypes.INT:\n+                return sm.fetchIntField(i);\n+            case JavaTypes.LONG:\n+                return sm.fetchLongField(i);\n+            case JavaTypes.SHORT:\n+                return sm.fetchShortField(i);\n+            case JavaTypes.STRING:\n+                return sm.fetchStringField(i);\n+            case JavaTypes.DATE:\n+            case JavaTypes.NUMBER:\n+            case JavaTypes.BOOLEAN_OBJ:\n+            case JavaTypes.BYTE_OBJ:\n+            case JavaTypes.CHAR_OBJ:\n+            case JavaTypes.DOUBLE_OBJ:\n+            case JavaTypes.FLOAT_OBJ:\n+            case JavaTypes.INT_OBJ:\n+            case JavaTypes.LONG_OBJ:\n+            case JavaTypes.SHORT_OBJ:\n+            case JavaTypes.BIGDECIMAL:\n+            case JavaTypes.BIGINTEGER:\n+            case JavaTypes.LOCALE:\n+            case JavaTypes.OBJECT:\n+            case JavaTypes.OID:\n+                return sm.fetchObjectField(i);\n+            default:\n+                throw new UnsupportedException();\n+        }\n+    }\n+\n+    private Object eval(Object ob, Object value, Object[] params,\n+        OpenJPAStateManager sm) {\n+        Object val = null;\n+        if (value instanceof Literal)\n+            val = ((Literal) value).getValue();\n+        else if (value instanceof Constant)\n+            val = ((Constant) value).getValue(params);\n+        else\n+            val = evaluate(value, ob, params, sm);\n+\n+        return val;\n+    }\n+\n+    private Object getValue(Object value, Object ob, Object[] params,\n+        OpenJPAStateManager sm) {\n+        if (value instanceof org.apache.openjpa.jdbc.kernel.exps.Math)\n+            return evaluate(value, ob, params, sm);\n+        else if (value instanceof PCPath) {\n+            FieldMapping fm = (FieldMapping)((PCPath)value).last();\n+            return getValue(ob, fm, sm);\n+        } else\n+            return eval(ob, value, params, sm);\n+    }\n }"},{"sha":"4ccfb154a93ed813a77545b69efb640091d4e2ef","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Math.java","status":"modified","additions":13,"deletions":1,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/dbbd1236f235a86f672b3f21bedaf2ee5672b34c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Math.java","raw_url":"https://github.com/apache/openjpa/raw/dbbd1236f235a86f672b3f21bedaf2ee5672b34c/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Math.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Math.java?ref=dbbd1236f235a86f672b3f21bedaf2ee5672b34c","patch":"@@ -33,7 +33,7 @@\n  *\n  * @author Abe White\n  */\n-class Math\n+public class Math\n     extends AbstractVal {\n \n     public static final String ADD = \"+\";\n@@ -57,6 +57,18 @@ public Math(Val val1, Val val2, String op) {\n         _op = op;\n     }\n \n+    public Val getVal1() {\n+        return _val1;\n+    }\n+\n+    public Val getVal2() {\n+        return _val2;\n+    }\n+\n+    public String getOperation() {\n+        return _op;\n+    }\n+\n     public ClassMetaData getMetaData() {\n         return _meta;\n     }"},{"sha":"50e0b7ab51dd9c8ee9e38edf0413c04c23c9d563","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","status":"modified","additions":667,"deletions":660,"changes":1327,"blob_url":"https://github.com/apache/openjpa/blob/dbbd1236f235a86f672b3f21bedaf2ee5672b34c/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/dbbd1236f235a86f672b3f21bedaf2ee5672b34c/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java?ref=dbbd1236f235a86f672b3f21bedaf2ee5672b34c","patch":"@@ -1,660 +1,667 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.datacache;\n-\n-import java.io.ObjectStreamException;\n-import java.io.Serializable;\n-import java.util.AbstractList;\n-import java.util.ArrayList;\n-import java.util.BitSet;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.TreeMap;\n-\n-import org.apache.commons.collections.map.LinkedMap;\n-import org.apache.openjpa.kernel.FetchConfiguration;\n-import org.apache.openjpa.kernel.LockLevels;\n-import org.apache.openjpa.kernel.QueryContext;\n-import org.apache.openjpa.kernel.StoreContext;\n-import org.apache.openjpa.kernel.StoreQuery;\n-import org.apache.openjpa.kernel.exps.AggregateListener;\n-import org.apache.openjpa.kernel.exps.FilterListener;\n-import org.apache.openjpa.lib.rop.ListResultObjectProvider;\n-import org.apache.openjpa.lib.rop.ResultObjectProvider;\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.meta.JavaTypes;\n-import org.apache.openjpa.meta.MetaDataRepository;\n-import org.apache.openjpa.util.ObjectNotFoundException;\n-import serp.util.Numbers;\n-\n-/**\n- * A {@link StoreQuery} implementation that caches the OIDs involved in\n- * the query, and can determine whether or not the query has been dirtied.\n- *\n- * @author Patrick Linskey\n- * @since 0.2.5.0\n- */\n-public class QueryCacheStoreQuery\n-    implements StoreQuery {\n-\n-    private final StoreQuery _query;\n-    private final QueryCache _cache;\n-    private StoreContext _sctx;\n-    private MetaDataRepository _repos;\n-\n-    /**\n-     * Create a new instance that delegates to <code>query</code> if no\n-     * cached results are available.\n-     */\n-    public QueryCacheStoreQuery(StoreQuery query, QueryCache cache) {\n-        _query = query;\n-        _cache = cache;\n-    }\n-\n-    /**\n-     * Return the {@link QueryCache} that this object is associated with.\n-     */\n-    public QueryCache getCache() {\n-        return _cache;\n-    }\n-\n-    /**\n-     * Delegate.\n-     */\n-    public StoreQuery getDelegate() {\n-        return _query;\n-    }\n-\n-    /**\n-     * Look in the query cache for a result for the given query\n-     * key. Only look if this query is being executed outside a\n-     * transaction or in a transaction with IgnoreChanges set to true\n-     * or in a transaction with IgnoreChanges set to false but in which\n-     * none of the classes involved in this query have been touched.\n-     *  Caching is not used when using object locking.\n-     * This is because we must obtain locks on the\n-     * data, and it is likely that making n trips to the database to\n-     * make the locks will be slower than running the query against\n-     * the database.\n-     *  If the fetch configuration has query caching disabled,\n-     * then this method returns <code>null</code>.\n-     *  Return the list if we meet the above criteria and if a list\n-     * is found for <code>qk</code>. Else, return\n-     * <code>null</code>.\n-     *  This implementation means that queries against the cache\n-     * are of READ_COMMITTED isolation level. It'd be nice to support\n-     * READ_SERIALIZABLE -- to do so, we'd just return false when in\n-     * a transaction.\n-     */\n-    private List checkCache(QueryKey qk) {\n-        if (qk == null)\n-            return null;\n-        FetchConfiguration fetch = getContext().getFetchConfiguration();\n-        if (!fetch.getQueryCacheEnabled())\n-            return null;\n-        if (fetch.getReadLockLevel() > LockLevels.LOCK_NONE)\n-            return null;\n-\n-        // get the cached data\n-        QueryResult res = _cache.get(qk);\n-        if (res == null)\n-            return null;\n-        if (res.isEmpty())\n-            return Collections.EMPTY_LIST;\n-\n-        int projs = getContext().getProjectionAliases().length;\n-        if (projs == 0) {\n-            // make sure the data cache contains the oids for the query result;\n-            // if it doesn't, then using the result could be slower than not\n-            // using it because of the individual by-oid lookups\n-            ClassMetaData meta = _repos.getMetaData(getContext().\n-                getCandidateType(), _sctx.getClassLoader(), true);\n-            if (meta.getDataCache() == null)\n-                return null;\n-\n-            BitSet idxs = meta.getDataCache().containsAll(res);\n-\n-            // eventually we should optimize this to figure out how many objects\n-            // the cache is missing and if only a few do a bulk fetch for them\n-            int len = idxs.length();\n-            if (len < res.size())\n-                return null;\n-            for (int i = 0; i < len; i++)\n-                if (!idxs.get(i))\n-                    return null;\n-        }\n-        return new CachedList(res, projs != 0, _sctx);\n-    }\n-\n-    /**\n-     * Wrap the result object provider returned by our delegate in a\n-     * caching provider.\n-     */\n-    private ResultObjectProvider wrapResult(ResultObjectProvider rop,\n-        QueryKey key) {\n-        if (key == null)\n-            return rop;\n-        return new CachingResultObjectProvider(rop, getContext().\n-            getProjectionAliases().length > 0, key);\n-    }\n-\n-    /**\n-     * Copy a projection element for caching / returning.\n-     */\n-    private static Object copyProjection(Object obj, StoreContext ctx) {\n-        if (obj == null)\n-            return null;\n-        switch (JavaTypes.getTypeCode(obj.getClass())) {\n-            case JavaTypes.STRING:\n-            case JavaTypes.BOOLEAN_OBJ:\n-            case JavaTypes.BYTE_OBJ:\n-            case JavaTypes.CHAR_OBJ:\n-            case JavaTypes.DOUBLE_OBJ:\n-            case JavaTypes.FLOAT_OBJ:\n-            case JavaTypes.INT_OBJ:\n-            case JavaTypes.LONG_OBJ:\n-            case JavaTypes.SHORT_OBJ:\n-            case JavaTypes.BIGDECIMAL:\n-            case JavaTypes.BIGINTEGER:\n-            case JavaTypes.OID:\n-                return obj;\n-            case JavaTypes.DATE:\n-                return ((Date) obj).clone();\n-            case JavaTypes.LOCALE:\n-                return ((Locale) obj).clone();\n-            default:\n-                if (obj instanceof CachedObjectId)\n-                    return fromObjectId(((CachedObjectId) obj).oid, ctx);\n-                Object oid = ctx.getObjectId(obj);\n-                if (oid != null)\n-                    return new CachedObjectId(oid);\n-                return obj;\n-        }\n-    }\n-\n-    /**\n-     * Return the result object based on its cached oid.\n-     */\n-    private static Object fromObjectId(Object oid, StoreContext sctx) {\n-        if (oid == null)\n-            return null;\n-\n-        Object obj = sctx.find(oid, null, null, null, 0);\n-        if (obj == null)\n-            throw new ObjectNotFoundException(oid);\n-        return obj;\n-    }\n-\n-    public Object writeReplace()\n-        throws ObjectStreamException {\n-        return _query;\n-    }\n-\n-    public QueryContext getContext() {\n-        return _query.getContext();\n-    }\n-\n-    public void setContext(QueryContext qctx) {\n-        _query.setContext(qctx);\n-        _sctx = qctx.getStoreContext();\n-        _repos = _sctx.getConfiguration().getMetaDataRepositoryInstance();\n-    }\n-\n-    public boolean setQuery(Object query) {\n-        return _query.setQuery(query);\n-    }\n-\n-    public FilterListener getFilterListener(String tag) {\n-        return _query.getFilterListener(tag);\n-    }\n-\n-    public AggregateListener getAggregateListener(String tag) {\n-        return _query.getAggregateListener(tag);\n-    }\n-\n-    public Object newCompilationKey() {\n-        return _query.newCompilationKey();\n-    }\n-\n-    public Object newCompilation() {\n-        return _query.newCompilation();\n-    }\n-\n-    public void populateFromCompilation(Object comp) {\n-        _query.populateFromCompilation(comp);\n-    }\n-\n-    public void invalidateCompilation() {\n-        _query.invalidateCompilation();\n-    }\n-\n-    public boolean supportsDataStoreExecution() {\n-        return _query.supportsDataStoreExecution();\n-    }\n-\n-    public boolean supportsInMemoryExecution() {\n-        return _query.supportsInMemoryExecution();\n-    }\n-\n-    public Executor newInMemoryExecutor(ClassMetaData meta, boolean subs) {\n-        return _query.newInMemoryExecutor(meta, subs);\n-    }\n-\n-    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\n-        Executor ex = _query.newDataStoreExecutor(meta, subs);\n-        return new QueryCacheExecutor(ex, meta, subs);\n-    }\n-\n-    public boolean supportsAbstractExecutors() {\n-        return _query.supportsAbstractExecutors();\n-    }\n-\n-    public boolean requiresCandidateType() {\n-        return _query.requiresCandidateType();\n-    }\n-\n-    public boolean requiresParameterDeclarations() {\n-        return _query.requiresParameterDeclarations();\n-    }\n-\n-    public boolean supportsParameterDeclarations() {\n-        return _query.supportsParameterDeclarations();\n-    }\n-\n-    /**\n-     * Caching executor.\n-     */\n-    private static class QueryCacheExecutor\n-        implements Executor {\n-\n-        private final Executor _ex;\n-        private final Class _candidate;\n-        private final boolean _subs;\n-\n-        public QueryCacheExecutor(Executor ex, ClassMetaData meta,\n-            boolean subs) {\n-            _ex = ex;\n-            _candidate = (meta == null) ? null : meta.getDescribedType();\n-            _subs = subs;\n-        }\n-\n-        public ResultObjectProvider executeQuery(StoreQuery q, Object[] params,\n-            Range range) {\n-            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\n-            QueryKey key = QueryKey.newInstance(cq.getContext(),\n-                _ex.isPacking(q), params, _candidate, _subs, range.start, \n-                range.end);\n-            List cached = cq.checkCache(key);\n-            if (cached != null)\n-                return new ListResultObjectProvider(cached);\n-\n-            ResultObjectProvider rop = _ex.executeQuery(cq.getDelegate(),\n-                params, range);\n-            return cq.wrapResult(rop, key);\n-        }\n-\n-        /**\n-         * Clear the cached queries associated with the access path\n-         * classes in the query. This is done when bulk operations\n-         * (such as deletes or updates) are performed so that the\n-         * cache remains up-to-date.\n-         */\n-        private void clearAccessPath(StoreQuery q) {\n-            if (q == null)\n-                return;\n-\n-            ClassMetaData[] cmd = getAccessPathMetaDatas(q);\n-            if (cmd == null || cmd.length == 0)\n-                return;\n-\n-            List classes = new ArrayList(cmd.length);\n-            for (int i = 0; i < cmd.length; i++)\n-                classes.add(cmd[i].getDescribedType());\n-\n-            // evict from the query cache\n-            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\n-            cq.getCache().onTypesChanged(new TypesChangedEvent\n-                (q.getContext(), classes));\n-\n-            // evict from the data cache\n-            for (int i = 0; i < cmd.length; i++) {\n-                if (cmd[i].getDataCache() != null)\n-                    cmd[i].getDataCache().removeAll(\n-                        cmd[i].getDescribedType(), true);\n-            }\n-        }\n-\n-        public Number executeDelete(StoreQuery q, Object[] params) {\n-            try {\n-                return _ex.executeDelete(unwrap(q), params);\n-            } finally {\n-                clearAccessPath(q);\n-            }\n-        }\n-\n-        public Number executeUpdate(StoreQuery q, Object[] params) {\n-            try {\n-                return _ex.executeUpdate(unwrap(q), params);\n-            } finally {\n-                clearAccessPath(q);\n-            }\n-        }\n-\n-        public String[] getDataStoreActions(StoreQuery q, Object[] params,\n-            Range range) {\n-            return EMPTY_STRINGS;\n-        }\n-\n-        public void validate(StoreQuery q) {\n-            _ex.validate(unwrap(q));\n-        }\n-        \n-        public void getRange(StoreQuery q, Object[] params, Range range) {\n-            _ex.getRange(q, params, range); \n-        }\n-\n-        public Object getOrderingValue(StoreQuery q, Object[] params,\n-            Object resultObject, int orderIndex) {\n-            return _ex.getOrderingValue(unwrap(q), params, resultObject,\n-                orderIndex);\n-        }\n-\n-        public boolean[] getAscending(StoreQuery q) {\n-            return _ex.getAscending(unwrap(q));\n-        }\n-\n-        public boolean isPacking(StoreQuery q) {\n-            return _ex.isPacking(unwrap(q));\n-        }\n-\n-        public String getAlias(StoreQuery q) {\n-            return _ex.getAlias(unwrap(q));\n-        }\n-\n-        public Class getResultClass(StoreQuery q) {\n-            return _ex.getResultClass(unwrap(q));\n-        }\n-\n-        public String[] getProjectionAliases(StoreQuery q) {\n-            return _ex.getProjectionAliases(unwrap(q));\n-        }\n-\n-        public Class[] getProjectionTypes(StoreQuery q) {\n-            return _ex.getProjectionTypes(unwrap(q));\n-        }\n-\n-        public ClassMetaData[] getAccessPathMetaDatas(StoreQuery q) {\n-            return _ex.getAccessPathMetaDatas(unwrap(q));\n-        }\n-\n-        public int getOperation(StoreQuery q) {\n-            return _ex.getOperation(unwrap(q));\n-        }\n-\n-        public boolean isAggregate(StoreQuery q) {\n-            return _ex.isAggregate(unwrap(q));\n-        }\n-\n-        public boolean hasGrouping(StoreQuery q) {\n-            return _ex.hasGrouping(unwrap(q));\n-        }\n-\n-        public LinkedMap getParameterTypes(StoreQuery q) {\n-            return _ex.getParameterTypes(unwrap(q));\n-        }\n-\n-        public Map getUpdates(StoreQuery q) {\n-            return _ex.getUpdates(unwrap(q));\n-        }\n-\n-        private static StoreQuery unwrap(StoreQuery q) {\n-            return ((QueryCacheStoreQuery) q).getDelegate();\n-        }\n-    }\n-\n-    /**\n-     * Result list implementation for a cached query result. Package-protected\n-     * for testing.\n-     */\n-    public static class CachedList\n-        extends AbstractList\n-        implements Serializable {\n-\n-        private final QueryResult _res;\n-        private final boolean _proj;\n-        private final StoreContext _sctx;\n-\n-        public CachedList(QueryResult res, boolean proj, StoreContext ctx) {\n-            _res = res;\n-            _proj = proj;\n-            _sctx = ctx;\n-        }\n-\n-        public Object get(int idx) {\n-            if (!_proj)\n-                return fromObjectId(_res.get(idx), _sctx);\n-\n-            Object[] cached = (Object[]) _res.get(idx);\n-            if (cached == null)\n-                return null;\n-            Object[] uncached = new Object[cached.length];\n-            for (int i = 0; i < cached.length; i++)\n-                uncached[i] = copyProjection(cached[i], _sctx);\n-            return uncached;\n-        }\n-\n-        public int size() {\n-            return _res.size();\n-        }\n-\n-        public Object writeReplace()\n-            throws ObjectStreamException {\n-            return new ArrayList(this);\n-        }\n-    }\n-\n-    /**\n-     * A wrapper around a {@link ResultObjectProvider} that builds up a list of\n-     * all the OIDs in this list and registers that list with the\n-     * query cache. Abandons monitoring and registering if one of the classes\n-     * in the access path is modified while the query results are being loaded.\n-     */\n-    private class CachingResultObjectProvider\n-        implements ResultObjectProvider, TypesChangedListener {\n-\n-        private final ResultObjectProvider _rop;\n-        private final boolean _proj;\n-        private final QueryKey _qk;\n-        private final TreeMap _data = new TreeMap();\n-        private boolean _maintainCache = true;\n-        private int _pos = -1;\n-\n-        // used to determine list size without necessarily calling size(),\n-        // which may require a DB trip or return Integer.MAX_VALUE\n-        private int _max = -1;\n-        private int _size = Integer.MAX_VALUE;\n-\n-        /**\n-         * Constructor. Supply delegate result provider and our query key.\n-         */\n-        public CachingResultObjectProvider(ResultObjectProvider rop,\n-            boolean proj, QueryKey key) {\n-            _rop = rop;\n-            _proj = proj;\n-            _qk = key;\n-            _cache.addTypesChangedListener(this);\n-        }\n-\n-        /**\n-         * Stop caching.\n-         */\n-        private void abortCaching() {\n-            if (!_maintainCache)\n-                return;\n-\n-            // this can be called via an event from another thread\n-            synchronized (this) {\n-                // it's important that we set this flag first so that any\n-                // subsequent calls to this object are bypassed.\n-                _maintainCache = false;\n-                _cache.removeTypesChangedListener(this);\n-                _data.clear();\n-            }\n-        }\n-\n-        /**\n-         * Check whether we've buffered all results, while optionally adding\n-         * the given result.\n-         */\n-        private void checkFinished(Object obj, boolean result) {\n-            // this can be called at the same time as abortCaching via\n-            // a types changed event\n-            boolean finished = false;\n-            synchronized (this) {\n-                if (_maintainCache) {\n-                    if (result) {\n-                        Integer index = Numbers.valueOf(_pos);\n-                        if (!_data.containsKey(index)) {\n-                            Object cached;\n-                            if (obj == null)\n-                                cached = null;\n-                            else if (!_proj)\n-                                cached = _sctx.getObjectId(obj);\n-                            else {\n-                                Object[] arr = (Object[]) obj;\n-                                Object[] cp = new Object[arr.length];\n-                                for (int i = 0; i < arr.length; i++)\n-                                    cp[i] = copyProjection(arr[i], _sctx);\n-                                cached = cp;\n-                            }\n-                            if (cached != null)\n-                                _data.put(index, cached);\n-                        }\n-                    }\n-                    finished = _size == _data.size();\n-                }\n-            }\n-\n-            if (finished) {\n-                // an abortCaching call can sneak in here via onExpire; the\n-                // cache is locked during event firings, so the lock here will\n-                // wait for it (or will force the next firing to wait)\n-                _cache.writeLock();\n-                try {\n-                    // make sure we didn't abort\n-                    if (_maintainCache) {\n-                        QueryResult res = new QueryResult(_qk, _data.values());\n-                        _cache.put(_qk, res);\n-                        abortCaching();\n-                    }\n-                }\n-                finally {\n-                    _cache.writeUnlock();\n-                }\n-            }\n-        }\n-\n-        public boolean supportsRandomAccess() {\n-            return _rop.supportsRandomAccess();\n-        }\n-\n-        public void open()\n-            throws Exception {\n-            _rop.open();\n-        }\n-\n-        public Object getResultObject()\n-            throws Exception {\n-            Object obj = _rop.getResultObject();\n-            checkFinished(obj, true);\n-            return obj;\n-        }\n-\n-        public boolean next()\n-            throws Exception {\n-            _pos++;\n-            boolean next = _rop.next();\n-            if (!next && _pos == _max + 1) {\n-                _size = _pos;\n-                checkFinished(null, false);\n-            } else if (next && _pos > _max)\n-                _max = _pos;\n-            return next;\n-        }\n-\n-        public boolean absolute(int pos)\n-            throws Exception {\n-            _pos = pos;\n-            boolean valid = _rop.absolute(pos);\n-            if (!valid && _pos == _max + 1) {\n-                _size = _pos;\n-                checkFinished(null, false);\n-            } else if (valid && _pos > _max)\n-                _max = _pos;\n-            return valid;\n-        }\n-\n-        public int size()\n-            throws Exception {\n-            if (_size != Integer.MAX_VALUE)\n-                return _size;\n-            int size = _rop.size();\n-            _size = size;\n-            checkFinished(null, false);\n-            return size;\n-        }\n-\n-        public void reset()\n-            throws Exception {\n-            _rop.reset();\n-            _pos = -1;\n-        }\n-\n-        public void close()\n-            throws Exception {\n-            abortCaching();\n-            _rop.close();\n-        }\n-\n-        public void handleCheckedException(Exception e) {\n-            _rop.handleCheckedException(e);\n-        }\n-\n-        public void onTypesChanged(TypesChangedEvent ev) {\n-            if (_qk.changeInvalidatesQuery(ev.getTypes()))\n-                abortCaching();\n-        }\n-    }\n-\n-    /**\n-     * Struct to recognize cached oids.\n-     */\n-    private static class CachedObjectId {\n-\n-        public final Object oid;\n-\n-        public CachedObjectId (Object oid)\n-\t\t{\n-\t\t\tthis.oid = oid;\n-\t\t}\n-\t}\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.datacache;\r\n+\r\n+import java.io.ObjectStreamException;\r\n+import java.io.Serializable;\r\n+import java.util.AbstractList;\r\n+import java.util.ArrayList;\r\n+import java.util.BitSet;\r\n+import java.util.Collections;\r\n+import java.util.Date;\r\n+import java.util.List;\r\n+import java.util.Locale;\r\n+import java.util.Map;\r\n+import java.util.TreeMap;\r\n+\r\n+import org.apache.commons.collections.map.LinkedMap;\r\n+import org.apache.openjpa.kernel.FetchConfiguration;\r\n+import org.apache.openjpa.kernel.LockLevels;\r\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n+import org.apache.openjpa.kernel.QueryContext;\r\n+import org.apache.openjpa.kernel.StoreContext;\r\n+import org.apache.openjpa.kernel.StoreQuery;\r\n+import org.apache.openjpa.kernel.exps.AggregateListener;\r\n+import org.apache.openjpa.kernel.exps.FilterListener;\r\n+import org.apache.openjpa.lib.rop.ListResultObjectProvider;\r\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.meta.MetaDataRepository;\r\n+import org.apache.openjpa.util.ObjectNotFoundException;\r\n+\r\n+import serp.util.Numbers;\r\n+\r\n+/**\r\n+ * A {@link StoreQuery} implementation that caches the OIDs involved in\r\n+ * the query, and can determine whether or not the query has been dirtied.\r\n+ *\r\n+ * @author Patrick Linskey\r\n+ * @since 0.2.5.0\r\n+ */\r\n+public class QueryCacheStoreQuery\r\n+    implements StoreQuery {\r\n+\r\n+    private final StoreQuery _query;\r\n+    private final QueryCache _cache;\r\n+    private StoreContext _sctx;\r\n+    private MetaDataRepository _repos;\r\n+\r\n+    /**\r\n+     * Create a new instance that delegates to <code>query</code> if no\r\n+     * cached results are available.\r\n+     */\r\n+    public QueryCacheStoreQuery(StoreQuery query, QueryCache cache) {\r\n+        _query = query;\r\n+        _cache = cache;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the {@link QueryCache} that this object is associated with.\r\n+     */\r\n+    public QueryCache getCache() {\r\n+        return _cache;\r\n+    }\r\n+\r\n+    /**\r\n+     * Delegate.\r\n+     */\r\n+    public StoreQuery getDelegate() {\r\n+        return _query;\r\n+    }\r\n+\r\n+    /**\r\n+     * Look in the query cache for a result for the given query\r\n+     * key. Only look if this query is being executed outside a\r\n+     * transaction or in a transaction with IgnoreChanges set to true\r\n+     * or in a transaction with IgnoreChanges set to false but in which\r\n+     * none of the classes involved in this query have been touched.\r\n+     *  Caching is not used when using object locking.\r\n+     * This is because we must obtain locks on the\r\n+     * data, and it is likely that making n trips to the database to\r\n+     * make the locks will be slower than running the query against\r\n+     * the database.\r\n+     *  If the fetch configuration has query caching disabled,\r\n+     * then this method returns <code>null</code>.\r\n+     *  Return the list if we meet the above criteria and if a list\r\n+     * is found for <code>qk</code>. Else, return\r\n+     * <code>null</code>.\r\n+     *  This implementation means that queries against the cache\r\n+     * are of READ_COMMITTED isolation level. It'd be nice to support\r\n+     * READ_SERIALIZABLE -- to do so, we'd just return false when in\r\n+     * a transaction.\r\n+     */\r\n+    private List checkCache(QueryKey qk) {\r\n+        if (qk == null)\r\n+            return null;\r\n+        FetchConfiguration fetch = getContext().getFetchConfiguration();\r\n+        if (!fetch.getQueryCacheEnabled())\r\n+            return null;\r\n+        if (fetch.getReadLockLevel() > LockLevels.LOCK_NONE)\r\n+            return null;\r\n+\r\n+        // get the cached data\r\n+        QueryResult res = _cache.get(qk);\r\n+        if (res == null)\r\n+            return null;\r\n+        if (res.isEmpty())\r\n+            return Collections.EMPTY_LIST;\r\n+\r\n+        int projs = getContext().getProjectionAliases().length;\r\n+        if (projs == 0) {\r\n+            // make sure the data cache contains the oids for the query result;\r\n+            // if it doesn't, then using the result could be slower than not\r\n+            // using it because of the individual by-oid lookups\r\n+            ClassMetaData meta = _repos.getMetaData(getContext().\r\n+                getCandidateType(), _sctx.getClassLoader(), true);\r\n+            if (meta.getDataCache() == null)\r\n+                return null;\r\n+\r\n+            BitSet idxs = meta.getDataCache().containsAll(res);\r\n+\r\n+            // eventually we should optimize this to figure out how many objects\r\n+            // the cache is missing and if only a few do a bulk fetch for them\r\n+            int len = idxs.length();\r\n+            if (len < res.size())\r\n+                return null;\r\n+            for (int i = 0; i < len; i++)\r\n+                if (!idxs.get(i))\r\n+                    return null;\r\n+        }\r\n+        return new CachedList(res, projs != 0, _sctx);\r\n+    }\r\n+\r\n+    /**\r\n+     * Wrap the result object provider returned by our delegate in a\r\n+     * caching provider.\r\n+     */\r\n+    private ResultObjectProvider wrapResult(ResultObjectProvider rop,\r\n+        QueryKey key) {\r\n+        if (key == null)\r\n+            return rop;\r\n+        return new CachingResultObjectProvider(rop, getContext().\r\n+            getProjectionAliases().length > 0, key);\r\n+    }\r\n+\r\n+    /**\r\n+     * Copy a projection element for caching / returning.\r\n+     */\r\n+    private static Object copyProjection(Object obj, StoreContext ctx) {\r\n+        if (obj == null)\r\n+            return null;\r\n+        switch (JavaTypes.getTypeCode(obj.getClass())) {\r\n+            case JavaTypes.STRING:\r\n+            case JavaTypes.BOOLEAN_OBJ:\r\n+            case JavaTypes.BYTE_OBJ:\r\n+            case JavaTypes.CHAR_OBJ:\r\n+            case JavaTypes.DOUBLE_OBJ:\r\n+            case JavaTypes.FLOAT_OBJ:\r\n+            case JavaTypes.INT_OBJ:\r\n+            case JavaTypes.LONG_OBJ:\r\n+            case JavaTypes.SHORT_OBJ:\r\n+            case JavaTypes.BIGDECIMAL:\r\n+            case JavaTypes.BIGINTEGER:\r\n+            case JavaTypes.OID:\r\n+                return obj;\r\n+            case JavaTypes.DATE:\r\n+                return ((Date) obj).clone();\r\n+            case JavaTypes.LOCALE:\r\n+                return ((Locale) obj).clone();\r\n+            default:\r\n+                if (obj instanceof CachedObjectId)\r\n+                    return fromObjectId(((CachedObjectId) obj).oid, ctx);\r\n+                Object oid = ctx.getObjectId(obj);\r\n+                if (oid != null)\r\n+                    return new CachedObjectId(oid);\r\n+                return obj;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the result object based on its cached oid.\r\n+     */\r\n+    private static Object fromObjectId(Object oid, StoreContext sctx) {\r\n+        if (oid == null)\r\n+            return null;\r\n+\r\n+        Object obj = sctx.find(oid, null, null, null, 0);\r\n+        if (obj == null)\r\n+            throw new ObjectNotFoundException(oid);\r\n+        return obj;\r\n+    }\r\n+\r\n+    public Object writeReplace()\r\n+        throws ObjectStreamException {\r\n+        return _query;\r\n+    }\r\n+\r\n+    public QueryContext getContext() {\r\n+        return _query.getContext();\r\n+    }\r\n+\r\n+    public void setContext(QueryContext qctx) {\r\n+        _query.setContext(qctx);\r\n+        _sctx = qctx.getStoreContext();\r\n+        _repos = _sctx.getConfiguration().getMetaDataRepositoryInstance();\r\n+    }\r\n+\r\n+    public boolean setQuery(Object query) {\r\n+        return _query.setQuery(query);\r\n+    }\r\n+\r\n+    public FilterListener getFilterListener(String tag) {\r\n+        return _query.getFilterListener(tag);\r\n+    }\r\n+\r\n+    public AggregateListener getAggregateListener(String tag) {\r\n+        return _query.getAggregateListener(tag);\r\n+    }\r\n+\r\n+    public Object newCompilationKey() {\r\n+        return _query.newCompilationKey();\r\n+    }\r\n+\r\n+    public Object newCompilation() {\r\n+        return _query.newCompilation();\r\n+    }\r\n+\r\n+    public void populateFromCompilation(Object comp) {\r\n+        _query.populateFromCompilation(comp);\r\n+    }\r\n+\r\n+    public void invalidateCompilation() {\r\n+        _query.invalidateCompilation();\r\n+    }\r\n+\r\n+    public boolean supportsDataStoreExecution() {\r\n+        return _query.supportsDataStoreExecution();\r\n+    }\r\n+\r\n+    public boolean supportsInMemoryExecution() {\r\n+        return _query.supportsInMemoryExecution();\r\n+    }\r\n+\r\n+    public Executor newInMemoryExecutor(ClassMetaData meta, boolean subs) {\r\n+        return _query.newInMemoryExecutor(meta, subs);\r\n+    }\r\n+\r\n+    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\r\n+        Executor ex = _query.newDataStoreExecutor(meta, subs);\r\n+        return new QueryCacheExecutor(ex, meta, subs);\r\n+    }\r\n+\r\n+    public boolean supportsAbstractExecutors() {\r\n+        return _query.supportsAbstractExecutors();\r\n+    }\r\n+\r\n+    public boolean requiresCandidateType() {\r\n+        return _query.requiresCandidateType();\r\n+    }\r\n+\r\n+    public boolean requiresParameterDeclarations() {\r\n+        return _query.requiresParameterDeclarations();\r\n+    }\r\n+\r\n+    public boolean supportsParameterDeclarations() {\r\n+        return _query.supportsParameterDeclarations();\r\n+    }\r\n+ \r\n+    public Object evaluate(Object value, Object ob, Object[] params,\r\n+        OpenJPAStateManager sm) {\r\n+        return _query.evaluate(value, ob, params, sm);         \r\n+    }\r\n+\r\n+    /**\r\n+     * Caching executor.\r\n+     */\r\n+    private static class QueryCacheExecutor\r\n+        implements Executor {\r\n+\r\n+        private final Executor _ex;\r\n+        private final Class _candidate;\r\n+        private final boolean _subs;\r\n+\r\n+        public QueryCacheExecutor(Executor ex, ClassMetaData meta,\r\n+            boolean subs) {\r\n+            _ex = ex;\r\n+            _candidate = (meta == null) ? null : meta.getDescribedType();\r\n+            _subs = subs;\r\n+        }\r\n+\r\n+        public ResultObjectProvider executeQuery(StoreQuery q, Object[] params,\r\n+            Range range) {\r\n+            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\r\n+            QueryKey key = QueryKey.newInstance(cq.getContext(),\r\n+                _ex.isPacking(q), params, _candidate, _subs, range.start, \r\n+                range.end);\r\n+            List cached = cq.checkCache(key);\r\n+            if (cached != null)\r\n+                return new ListResultObjectProvider(cached);\r\n+\r\n+            ResultObjectProvider rop = _ex.executeQuery(cq.getDelegate(),\r\n+                params, range);\r\n+            return cq.wrapResult(rop, key);\r\n+        }\r\n+\r\n+        /**\r\n+         * Clear the cached queries associated with the access path\r\n+         * classes in the query. This is done when bulk operations\r\n+         * (such as deletes or updates) are performed so that the\r\n+         * cache remains up-to-date.\r\n+         */\r\n+        private void clearAccessPath(StoreQuery q) {\r\n+            if (q == null)\r\n+                return;\r\n+\r\n+            ClassMetaData[] cmd = getAccessPathMetaDatas(q);\r\n+            if (cmd == null || cmd.length == 0)\r\n+                return;\r\n+\r\n+            List classes = new ArrayList(cmd.length);\r\n+            for (int i = 0; i < cmd.length; i++)\r\n+                classes.add(cmd[i].getDescribedType());\r\n+\r\n+            // evict from the query cache\r\n+            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\r\n+            cq.getCache().onTypesChanged(new TypesChangedEvent\r\n+                (q.getContext(), classes));\r\n+\r\n+            // evict from the data cache\r\n+            for (int i = 0; i < cmd.length; i++) {\r\n+                if (cmd[i].getDataCache() != null)\r\n+                    cmd[i].getDataCache().removeAll(\r\n+                        cmd[i].getDescribedType(), true);\r\n+            }\r\n+        }\r\n+\r\n+        public Number executeDelete(StoreQuery q, Object[] params) {\r\n+            try {\r\n+                return _ex.executeDelete(unwrap(q), params);\r\n+            } finally {\r\n+                clearAccessPath(q);\r\n+            }\r\n+        }\r\n+\r\n+        public Number executeUpdate(StoreQuery q, Object[] params) {\r\n+            try {\r\n+                return _ex.executeUpdate(unwrap(q), params);\r\n+            } finally {\r\n+                clearAccessPath(q);\r\n+            }\r\n+        }\r\n+\r\n+        public String[] getDataStoreActions(StoreQuery q, Object[] params,\r\n+            Range range) {\r\n+            return EMPTY_STRINGS;\r\n+        }\r\n+\r\n+        public void validate(StoreQuery q) {\r\n+            _ex.validate(unwrap(q));\r\n+        }\r\n+        \r\n+        public void getRange(StoreQuery q, Object[] params, Range range) {\r\n+            _ex.getRange(q, params, range); \r\n+        }\r\n+\r\n+        public Object getOrderingValue(StoreQuery q, Object[] params,\r\n+            Object resultObject, int orderIndex) {\r\n+            return _ex.getOrderingValue(unwrap(q), params, resultObject,\r\n+                orderIndex);\r\n+        }\r\n+\r\n+        public boolean[] getAscending(StoreQuery q) {\r\n+            return _ex.getAscending(unwrap(q));\r\n+        }\r\n+\r\n+        public boolean isPacking(StoreQuery q) {\r\n+            return _ex.isPacking(unwrap(q));\r\n+        }\r\n+\r\n+        public String getAlias(StoreQuery q) {\r\n+            return _ex.getAlias(unwrap(q));\r\n+        }\r\n+\r\n+        public Class getResultClass(StoreQuery q) {\r\n+            return _ex.getResultClass(unwrap(q));\r\n+        }\r\n+\r\n+        public String[] getProjectionAliases(StoreQuery q) {\r\n+            return _ex.getProjectionAliases(unwrap(q));\r\n+        }\r\n+\r\n+        public Class[] getProjectionTypes(StoreQuery q) {\r\n+            return _ex.getProjectionTypes(unwrap(q));\r\n+        }\r\n+\r\n+        public ClassMetaData[] getAccessPathMetaDatas(StoreQuery q) {\r\n+            return _ex.getAccessPathMetaDatas(unwrap(q));\r\n+        }\r\n+\r\n+        public int getOperation(StoreQuery q) {\r\n+            return _ex.getOperation(unwrap(q));\r\n+        }\r\n+\r\n+        public boolean isAggregate(StoreQuery q) {\r\n+            return _ex.isAggregate(unwrap(q));\r\n+        }\r\n+\r\n+        public boolean hasGrouping(StoreQuery q) {\r\n+            return _ex.hasGrouping(unwrap(q));\r\n+        }\r\n+\r\n+        public LinkedMap getParameterTypes(StoreQuery q) {\r\n+            return _ex.getParameterTypes(unwrap(q));\r\n+        }\r\n+\r\n+        public Map getUpdates(StoreQuery q) {\r\n+            return _ex.getUpdates(unwrap(q));\r\n+        }\r\n+\r\n+        private static StoreQuery unwrap(StoreQuery q) {\r\n+            return ((QueryCacheStoreQuery) q).getDelegate();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Result list implementation for a cached query result. Package-protected\r\n+     * for testing.\r\n+     */\r\n+    public static class CachedList\r\n+        extends AbstractList\r\n+        implements Serializable {\r\n+\r\n+        private final QueryResult _res;\r\n+        private final boolean _proj;\r\n+        private final StoreContext _sctx;\r\n+\r\n+        public CachedList(QueryResult res, boolean proj, StoreContext ctx) {\r\n+            _res = res;\r\n+            _proj = proj;\r\n+            _sctx = ctx;\r\n+        }\r\n+\r\n+        public Object get(int idx) {\r\n+            if (!_proj)\r\n+                return fromObjectId(_res.get(idx), _sctx);\r\n+\r\n+            Object[] cached = (Object[]) _res.get(idx);\r\n+            if (cached == null)\r\n+                return null;\r\n+            Object[] uncached = new Object[cached.length];\r\n+            for (int i = 0; i < cached.length; i++)\r\n+                uncached[i] = copyProjection(cached[i], _sctx);\r\n+            return uncached;\r\n+        }\r\n+\r\n+        public int size() {\r\n+            return _res.size();\r\n+        }\r\n+\r\n+        public Object writeReplace()\r\n+            throws ObjectStreamException {\r\n+            return new ArrayList(this);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * A wrapper around a {@link ResultObjectProvider} that builds up a list of\r\n+     * all the OIDs in this list and registers that list with the\r\n+     * query cache. Abandons monitoring and registering if one of the classes\r\n+     * in the access path is modified while the query results are being loaded.\r\n+     */\r\n+    private class CachingResultObjectProvider\r\n+        implements ResultObjectProvider, TypesChangedListener {\r\n+\r\n+        private final ResultObjectProvider _rop;\r\n+        private final boolean _proj;\r\n+        private final QueryKey _qk;\r\n+        private final TreeMap _data = new TreeMap();\r\n+        private boolean _maintainCache = true;\r\n+        private int _pos = -1;\r\n+\r\n+        // used to determine list size without necessarily calling size(),\r\n+        // which may require a DB trip or return Integer.MAX_VALUE\r\n+        private int _max = -1;\r\n+        private int _size = Integer.MAX_VALUE;\r\n+\r\n+        /**\r\n+         * Constructor. Supply delegate result provider and our query key.\r\n+         */\r\n+        public CachingResultObjectProvider(ResultObjectProvider rop,\r\n+            boolean proj, QueryKey key) {\r\n+            _rop = rop;\r\n+            _proj = proj;\r\n+            _qk = key;\r\n+            _cache.addTypesChangedListener(this);\r\n+        }\r\n+\r\n+        /**\r\n+         * Stop caching.\r\n+         */\r\n+        private void abortCaching() {\r\n+            if (!_maintainCache)\r\n+                return;\r\n+\r\n+            // this can be called via an event from another thread\r\n+            synchronized (this) {\r\n+                // it's important that we set this flag first so that any\r\n+                // subsequent calls to this object are bypassed.\r\n+                _maintainCache = false;\r\n+                _cache.removeTypesChangedListener(this);\r\n+                _data.clear();\r\n+            }\r\n+        }\r\n+\r\n+        /**\r\n+         * Check whether we've buffered all results, while optionally adding\r\n+         * the given result.\r\n+         */\r\n+        private void checkFinished(Object obj, boolean result) {\r\n+            // this can be called at the same time as abortCaching via\r\n+            // a types changed event\r\n+            boolean finished = false;\r\n+            synchronized (this) {\r\n+                if (_maintainCache) {\r\n+                    if (result) {\r\n+                        Integer index = Numbers.valueOf(_pos);\r\n+                        if (!_data.containsKey(index)) {\r\n+                            Object cached;\r\n+                            if (obj == null)\r\n+                                cached = null;\r\n+                            else if (!_proj)\r\n+                                cached = _sctx.getObjectId(obj);\r\n+                            else {\r\n+                                Object[] arr = (Object[]) obj;\r\n+                                Object[] cp = new Object[arr.length];\r\n+                                for (int i = 0; i < arr.length; i++)\r\n+                                    cp[i] = copyProjection(arr[i], _sctx);\r\n+                                cached = cp;\r\n+                            }\r\n+                            if (cached != null)\r\n+                                _data.put(index, cached);\r\n+                        }\r\n+                    }\r\n+                    finished = _size == _data.size();\r\n+                }\r\n+            }\r\n+\r\n+            if (finished) {\r\n+                // an abortCaching call can sneak in here via onExpire; the\r\n+                // cache is locked during event firings, so the lock here will\r\n+                // wait for it (or will force the next firing to wait)\r\n+                _cache.writeLock();\r\n+                try {\r\n+                    // make sure we didn't abort\r\n+                    if (_maintainCache) {\r\n+                        QueryResult res = new QueryResult(_qk, _data.values());\r\n+                        _cache.put(_qk, res);\r\n+                        abortCaching();\r\n+                    }\r\n+                }\r\n+                finally {\r\n+                    _cache.writeUnlock();\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        public boolean supportsRandomAccess() {\r\n+            return _rop.supportsRandomAccess();\r\n+        }\r\n+\r\n+        public void open()\r\n+            throws Exception {\r\n+            _rop.open();\r\n+        }\r\n+\r\n+        public Object getResultObject()\r\n+            throws Exception {\r\n+            Object obj = _rop.getResultObject();\r\n+            checkFinished(obj, true);\r\n+            return obj;\r\n+        }\r\n+\r\n+        public boolean next()\r\n+            throws Exception {\r\n+            _pos++;\r\n+            boolean next = _rop.next();\r\n+            if (!next && _pos == _max + 1) {\r\n+                _size = _pos;\r\n+                checkFinished(null, false);\r\n+            } else if (next && _pos > _max)\r\n+                _max = _pos;\r\n+            return next;\r\n+        }\r\n+\r\n+        public boolean absolute(int pos)\r\n+            throws Exception {\r\n+            _pos = pos;\r\n+            boolean valid = _rop.absolute(pos);\r\n+            if (!valid && _pos == _max + 1) {\r\n+                _size = _pos;\r\n+                checkFinished(null, false);\r\n+            } else if (valid && _pos > _max)\r\n+                _max = _pos;\r\n+            return valid;\r\n+        }\r\n+\r\n+        public int size()\r\n+            throws Exception {\r\n+            if (_size != Integer.MAX_VALUE)\r\n+                return _size;\r\n+            int size = _rop.size();\r\n+            _size = size;\r\n+            checkFinished(null, false);\r\n+            return size;\r\n+        }\r\n+\r\n+        public void reset()\r\n+            throws Exception {\r\n+            _rop.reset();\r\n+            _pos = -1;\r\n+        }\r\n+\r\n+        public void close()\r\n+            throws Exception {\r\n+            abortCaching();\r\n+            _rop.close();\r\n+        }\r\n+\r\n+        public void handleCheckedException(Exception e) {\r\n+            _rop.handleCheckedException(e);\r\n+        }\r\n+\r\n+        public void onTypesChanged(TypesChangedEvent ev) {\r\n+            if (_qk.changeInvalidatesQuery(ev.getTypes()))\r\n+                abortCaching();\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Struct to recognize cached oids.\r\n+     */\r\n+    private static class CachedObjectId {\r\n+\r\n+        public final Object oid;\r\n+\r\n+        public CachedObjectId (Object oid)\r\n+\t\t{\r\n+\t\t\tthis.oid = oid;\r\n+\t\t}\r\n+\t}\r\n+}\r"},{"sha":"f8f12dc4b9445a3d4537d5af367e2f602076abc1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","status":"modified","additions":190,"deletions":184,"changes":374,"blob_url":"https://github.com/apache/openjpa/blob/dbbd1236f235a86f672b3f21bedaf2ee5672b34c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/dbbd1236f235a86f672b3f21bedaf2ee5672b34c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java?ref=dbbd1236f235a86f672b3f21bedaf2ee5672b34c","patch":"@@ -1,184 +1,190 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.kernel;\n-\n-import java.util.Map;\n-\n-import org.apache.commons.collections.map.LinkedMap;\n-import org.apache.openjpa.kernel.exps.AggregateListener;\n-import org.apache.openjpa.kernel.exps.FilterListener;\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.util.InternalException;\n-\n-/**\n- * Abstract {@link StoreQuery} that implements most methods as no-ops.\n- *\n- * @author Abe White\n- * @since 0.4.0\n- */\n-public abstract class AbstractStoreQuery\n-    implements StoreQuery {\n-\n-    protected QueryContext ctx = null;\n-   \n-    public QueryContext getContext() {\n-        return ctx;\n-    }\n-\n-    public void setContext(QueryContext ctx) {\n-        this.ctx = ctx;\n-    }\n-\n-    public boolean setQuery(Object query) {\n-        return false;\n-    }\n-\n-    public FilterListener getFilterListener(String tag) {\n-        return null;\n-    }\n-\n-    public AggregateListener getAggregateListener(String tag) {\n-        return null;\n-    }\n-\n-    public Object newCompilationKey() {\n-        return null;\n-    }\n-\n-    public Object newCompilation() {\n-        return null;\n-    }\n-\n-    public void populateFromCompilation(Object comp) {\n-    }\n-\n-    public void invalidateCompilation() {\n-    }\n-\n-    public boolean supportsDataStoreExecution() {\n-        return false;\n-    }\n-\n-    public boolean supportsInMemoryExecution() {\n-        return false;\n-    }\n-\n-    public Executor newInMemoryExecutor(ClassMetaData meta, boolean subs) {\n-        throw new InternalException();\n-    }\n-\n-    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\n-        throw new InternalException();\n-    }\n-\n-    public boolean supportsAbstractExecutors() {\n-        return false;\n-    }\n-\n-    public boolean requiresCandidateType() {\n-        return true;\n-    }\n-\n-    public boolean requiresParameterDeclarations() {\n-        return true;\n-    }\n-\n-    public boolean supportsParameterDeclarations() {\n-        return true;\n-    }\n-\n-    /**\n-     * Abstract {@link Executor} that implements most methods as no-ops.\n-     */\n-    public static abstract class AbstractExecutor\n-        implements Executor {\n-\n-        public Number executeDelete(StoreQuery q, Object[] params) {\n-            return q.getContext().deleteInMemory(q, this, params);\n-        }\n-\n-        public Number executeUpdate(StoreQuery q, Object[] params) {\n-            return q.getContext().updateInMemory(q, this, params);\n-        }\n-\n-        public String[] getDataStoreActions(StoreQuery q, Object[] params,\n-            Range range) {\n-            return EMPTY_STRINGS;\n-        }\n-\n-        public void validate(StoreQuery q) {\n-        }\n-\n-        public void getRange(StoreQuery q, Object[] params, Range range) {\n-        }\n-\n-        public Object getOrderingValue(StoreQuery q, Object[] params,\n-            Object resultObject, int orderIndex) {\n-            return null;\n-        }\n-\n-        public boolean[] getAscending(StoreQuery q) {\n-            return EMPTY_BOOLEANS;\n-        }\n-\n-        public boolean isPacking(StoreQuery q) {\n-            return false;\n-        }\n-\n-        public String getAlias(StoreQuery q) {\n-            return null;\n-        }\n-\n-        public String[] getProjectionAliases(StoreQuery q) {\n-            return EMPTY_STRINGS;\n-        }\n-\n-        public Class[] getProjectionTypes(StoreQuery q) {\n-            return EMPTY_CLASSES;\n-        }\n-\n-        public ClassMetaData[] getAccessPathMetaDatas(StoreQuery q) {\n-            return EMPTY_METAS;\n-        }\n-\n-        public int getOperation(StoreQuery q) {\n-            return OP_SELECT;\n-        }\n-\n-        public boolean isAggregate(StoreQuery q) {\n-            return false;\n-        }\n-\n-        public boolean hasGrouping(StoreQuery q) {\n-            return false;\n-        }\n-\n-        public LinkedMap getParameterTypes(StoreQuery q) {\n-            return EMPTY_PARAMS;\n-        }\n-\n-        public Class getResultClass(StoreQuery q) {\n-            return null;\n-        }\n-\n-        public Map getUpdates(StoreQuery q) {\n-            return null;\n-        }\n-    }\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import java.util.Map;\r\n+\r\n+import org.apache.commons.collections.map.LinkedMap;\r\n+import org.apache.openjpa.kernel.exps.AggregateListener;\r\n+import org.apache.openjpa.kernel.exps.FilterListener;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.util.InternalException;\r\n+import org.apache.openjpa.util.UnsupportedException;\r\n+\r\n+/**\r\n+ * Abstract {@link StoreQuery} that implements most methods as no-ops.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 0.4.0\r\n+ */\r\n+public abstract class AbstractStoreQuery\r\n+    implements StoreQuery {\r\n+\r\n+    protected QueryContext ctx = null;\r\n+   \r\n+    public QueryContext getContext() {\r\n+        return ctx;\r\n+    }\r\n+\r\n+    public void setContext(QueryContext ctx) {\r\n+        this.ctx = ctx;\r\n+    }\r\n+\r\n+    public boolean setQuery(Object query) {\r\n+        return false;\r\n+    }\r\n+\r\n+    public FilterListener getFilterListener(String tag) {\r\n+        return null;\r\n+    }\r\n+\r\n+    public AggregateListener getAggregateListener(String tag) {\r\n+        return null;\r\n+    }\r\n+\r\n+    public Object newCompilationKey() {\r\n+        return null;\r\n+    }\r\n+\r\n+    public Object newCompilation() {\r\n+        return null;\r\n+    }\r\n+\r\n+    public void populateFromCompilation(Object comp) {\r\n+    }\r\n+\r\n+    public void invalidateCompilation() {\r\n+    }\r\n+\r\n+    public boolean supportsDataStoreExecution() {\r\n+        return false;\r\n+    }\r\n+\r\n+    public boolean supportsInMemoryExecution() {\r\n+        return false;\r\n+    }\r\n+\r\n+    public Executor newInMemoryExecutor(ClassMetaData meta, boolean subs) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\r\n+        throw new InternalException();\r\n+    }\r\n+\r\n+    public boolean supportsAbstractExecutors() {\r\n+        return false;\r\n+    }\r\n+\r\n+    public boolean requiresCandidateType() {\r\n+        return true;\r\n+    }\r\n+\r\n+    public boolean requiresParameterDeclarations() {\r\n+        return true;\r\n+    }\r\n+\r\n+    public boolean supportsParameterDeclarations() {\r\n+        return true;\r\n+    }\r\n+\r\n+    public Object evaluate(Object value, Object ob, Object[] params,\r\n+        OpenJPAStateManager sm) {\r\n+        throw new UnsupportedException();\r\n+    }\r\n+\r\n+    /**\r\n+     * Abstract {@link Executor} that implements most methods as no-ops.\r\n+     */\r\n+    public static abstract class AbstractExecutor\r\n+        implements Executor {\r\n+\r\n+        public Number executeDelete(StoreQuery q, Object[] params) {\r\n+            return q.getContext().deleteInMemory(q, this, params);\r\n+        }\r\n+\r\n+        public Number executeUpdate(StoreQuery q, Object[] params) {\r\n+            return q.getContext().updateInMemory(q, this, params);\r\n+        }\r\n+\r\n+        public String[] getDataStoreActions(StoreQuery q, Object[] params,\r\n+            Range range) {\r\n+            return EMPTY_STRINGS;\r\n+        }\r\n+\r\n+        public void validate(StoreQuery q) {\r\n+        }\r\n+\r\n+        public void getRange(StoreQuery q, Object[] params, Range range) {\r\n+        }\r\n+\r\n+        public Object getOrderingValue(StoreQuery q, Object[] params,\r\n+            Object resultObject, int orderIndex) {\r\n+            return null;\r\n+        }\r\n+\r\n+        public boolean[] getAscending(StoreQuery q) {\r\n+            return EMPTY_BOOLEANS;\r\n+        }\r\n+\r\n+        public boolean isPacking(StoreQuery q) {\r\n+            return false;\r\n+        }\r\n+\r\n+        public String getAlias(StoreQuery q) {\r\n+            return null;\r\n+        }\r\n+\r\n+        public String[] getProjectionAliases(StoreQuery q) {\r\n+            return EMPTY_STRINGS;\r\n+        }\r\n+\r\n+        public Class[] getProjectionTypes(StoreQuery q) {\r\n+            return EMPTY_CLASSES;\r\n+        }\r\n+\r\n+        public ClassMetaData[] getAccessPathMetaDatas(StoreQuery q) {\r\n+            return EMPTY_METAS;\r\n+        }\r\n+\r\n+        public int getOperation(StoreQuery q) {\r\n+            return OP_SELECT;\r\n+        }\r\n+\r\n+        public boolean isAggregate(StoreQuery q) {\r\n+            return false;\r\n+        }\r\n+\r\n+        public boolean hasGrouping(StoreQuery q) {\r\n+            return false;\r\n+        }\r\n+\r\n+        public LinkedMap getParameterTypes(StoreQuery q) {\r\n+            return EMPTY_PARAMS;\r\n+        }\r\n+\r\n+        public Class getResultClass(StoreQuery q) {\r\n+            return null;\r\n+        }\r\n+\r\n+        public Map getUpdates(StoreQuery q) {\r\n+            return null;\r\n+        }\r\n+    }\r\n+}\r"},{"sha":"b23f5b90bb923c46a1af6e0559ff852a0f120f46","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","status":"modified","additions":8,"deletions":4,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/dbbd1236f235a86f672b3f21bedaf2ee5672b34c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/dbbd1236f235a86f672b3f21bedaf2ee5672b34c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java?ref=dbbd1236f235a86f672b3f21bedaf2ee5672b34c","patch":"@@ -1048,7 +1048,7 @@ public Number updateInMemory(StoreQuery q, StoreQuery.Executor executor,\n \r\n             int size = 0;\r\n             for (Iterator i = ((Collection) o).iterator(); i.hasNext(); size++)\r\n-                updateInMemory(i.next(), params);\r\n+                updateInMemory(i.next(), params, q);\r\n             return Numbers.valueOf(size);\r\n         } catch (OpenJPAException ke) {\r\n             throw ke;\r\n@@ -1063,12 +1063,13 @@ public Number updateInMemory(StoreQuery q, StoreQuery.Executor executor,\n      * @param ob the persistent instance to change\r\n      * @param params the parameters passed to the query\r\n      */\r\n-    private void updateInMemory(Object ob, Object[] params) {\r\n+    private void updateInMemory(Object ob, Object[] params, StoreQuery q) {\r\n         for (Iterator it = getUpdates().entrySet().iterator();\r\n             it.hasNext();) {\r\n             Map.Entry e = (Map.Entry) it.next();\r\n             Path path = (Path) e.getKey();\r\n             FieldMetaData fmd = (FieldMetaData) path.last();\r\n+            OpenJPAStateManager sm = _broker.getStateManager(ob);\r\n \r\n             Object val;\r\n             Object value = e.getValue();\r\n@@ -1080,10 +1081,13 @@ private void updateInMemory(Object ob, Object[] params) {\n             } else if (value instanceof Constant) {\r\n                 val = ((Constant) value).getValue(params);\r\n             } else {\r\n-                throw new UserException(_loc.get(\"only-update-primitives\"));\r\n+                try {\r\n+                    val = q.evaluate(value, ob, params, sm);\r\n+                } catch (UnsupportedException e1) {\r\n+                    throw new UserException(_loc.get(\"fail-to-get-update-value\"));\r\n+                }\r\n             }\r\n \r\n-            OpenJPAStateManager sm = _broker.getStateManager(ob);\r\n             int i = fmd.getIndex();\r\n             PersistenceCapable into = ImplHelper.toPersistenceCapable(ob,\r\n                 _broker.getConfiguration());\r"},{"sha":"5a690e83221aca9fa827ef5754243db26b8c12a8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","status":"modified","additions":325,"deletions":322,"changes":647,"blob_url":"https://github.com/apache/openjpa/blob/dbbd1236f235a86f672b3f21bedaf2ee5672b34c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/dbbd1236f235a86f672b3f21bedaf2ee5672b34c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java?ref=dbbd1236f235a86f672b3f21bedaf2ee5672b34c","patch":"@@ -1,322 +1,325 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.kernel;\n-\n-import java.io.Serializable;\n-import java.util.Iterator;\n-import java.util.Map;\n-\n-import org.apache.commons.collections.map.LinkedMap;\n-import org.apache.openjpa.kernel.exps.AggregateListener;\n-import org.apache.openjpa.kernel.exps.Constant;\n-import org.apache.openjpa.kernel.exps.FilterListener;\n-import org.apache.openjpa.lib.rop.ResultObjectProvider;\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.meta.FieldMetaData;\n-\n-/**\n- * Component that executes queries against the datastore. For\n- * expression-based queries, consider subclassing\n- * {@link ExpressionStoreManagerQuery}.\n- *\n- * @author Abe White\n- * @since 0.4.0\n- */\n-public interface StoreQuery\n-    extends QueryOperations, Serializable {\n-\n-    // linkedmap doesn't allow a size of 0, so use 1\n-    public static final LinkedMap EMPTY_PARAMS = new LinkedMap(1, 1F);\n-    public static final ClassMetaData[] EMPTY_METAS = new ClassMetaData[0];\n-    public static final String[] EMPTY_STRINGS = new String[0];\n-    public static final Object[] EMPTY_OBJECTS = new Object[0];\n-    public static final Class[] EMPTY_CLASSES = new Class[0];\n-    public static final boolean[] EMPTY_BOOLEANS = new boolean[0];\n-\n-    /**\n-     * Return the query context that has been set.\n-     */\n-    public QueryContext getContext();\n-\n-    /**\n-     * Set the current query context. This will be called before use.\n-     */\n-    public void setContext(QueryContext ctx);\n-\n-    /**\n-     * This is invoked when the user or a facade creates a new query with\n-     * an object that the system does not recognize. Return true if\n-     * the object is recognized by the store, false otherwise.\n-     */\n-    public boolean setQuery(Object query);\n-\n-    /**\n-     * Return the standard filter listener for the given tag, or null.\n-     */\n-    public FilterListener getFilterListener(String tag);\n-\n-    /**\n-     * Return the standard filter listener for the given tag, or null.\n-     */\n-    public AggregateListener getAggregateListener(String tag);\n-\n-    /**\n-     * Create a new key for caching compiled query information. May be null.\n-     */\n-    public Object newCompilationKey();\n-\n-    /**\n-     * Create a new compilation for this query. May be null.\n-     */\n-    public Object newCompilation();\n-\n-    /**\n-     * Populate internal data from compilation.\n-     */\n-    public void populateFromCompilation(Object comp);\n-\n-    /**\n-     * Invalidate any internal compilation state.\n-     */\n-    public void invalidateCompilation();\n-\n-    /**\n-     * True if this query supports datastore execution, false if it\n-     * can only run in memory.\n-     */\n-    public boolean supportsDataStoreExecution();\n-\n-    /**\n-     * True if this query supports in-memory execution, false if it\n-     * can only run against the datastore.\n-     */\n-    public boolean supportsInMemoryExecution();\n-\n-    /**\n-     * Return an executor for in-memory execution of this query.\n-     * Executors must be cachable and thread safe. If this class returns\n-     * true from {@link #supportsAbstractExecutors}, the given metadata\n-     * will always be for the candidate class of this query, or possibly\n-     * null if the candidate class is not itself persistence capable (like\n-     * an interface or abstract base class). Otherwise, the given type will\n-     * be a mapped class.\n-     *\n-     * @param subs whether to include dependent mapped subclasses in the\n-     * results; independent subclasses should never be included\n-     */\n-    public Executor newInMemoryExecutor(ClassMetaData meta, boolean subs);\n-\n-    /**\n-     * Return an executor for datastore execution of this query.\n-     * Executors must be cachable and thread safe. If this class returns\n-     * true from {@link #supportsAbstractExecutors}, the given metadata\n-     * will always be for the candidate class of this query, or possibly\n-     * null if the candidate class is not itself persistence capable (like\n-     * an interface or abstract base class). Otherwise, the given type will\n-     * be a mapped class.\n-     *\n-     * @param subs whether to include dependent mapped subclasses in the\n-     * results; independent subclasses should never be included\n-     */\n-    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs);\n-\n-    /**\n-     * Return true if this query supports execution against abstract or\n-     * interface types. Returns false by default, meaning we will only\n-     * request executors for persistent classes. In this case, we will\n-     * automatically combine the results of the executors for all\n-     * implementing classes if we execute a query for an interface for\n-     * abstract type.\n-     */\n-    public boolean supportsAbstractExecutors();\n-\n-    /**\n-     * Whether this query requires a candidate class.\n-     */\n-    public boolean requiresCandidateType();\n-\n-    /**\n-     * Whether this query requires parameters to be declared.\n-     */\n-    public boolean requiresParameterDeclarations();\n-\n-    /**\n-     * Whether this query supports declared parameters.\n-     */\n-    public boolean supportsParameterDeclarations();\n-\n-    /**\n-     * A query result range.\n-     */\n-    public static class Range {\n-        public long start = 0L;\n-        public long end = Long.MAX_VALUE;\n-        public boolean lrs = false;\n-\n-        public Range() {\n-        }\n-\n-        public Range(long start, long end) {\n-            this.start = start;\n-            this.end = end;\n-        }\n-    }\n-\n-    /**\n-     * An executor provides a uniform interface to the mechanism for executing\n-     * either an in-memory or datastore query. In the common case, the\n-     * {@link #executeQuery} method will be called before other methods,\n-     * though this is not guaranteed.\n-     *\n-     * @author Marc Prud'hommeaux\n-     */\n-    public static interface Executor {\n-\n-        /**\n-         * Return the result of executing this query with the given parameter\n-         * values. If this query is a projection and this executor does not\n-         * pack results itself, each element of the returned result object\n-         * provider should be an object array containing the projection values.\n-         *\n-         * @param lrs true if the query result should be treated as a\n-         * large result set, assuming the query is not an\n-         * aggregate and does not have grouping\n-         * @see #isPacking\n-         */\n-        public ResultObjectProvider executeQuery(StoreQuery q, Object[] params,\n-            Range range);\n-\n-        /**\n-         * Deleted the objects that result from the execution of the\n-         * query, retuning the number of objects that were deleted.\n-         */\n-        public Number executeDelete(StoreQuery q, Object[] params);\n-\n-        /**\n-         * Updates the objects that result from the execution of the\n-         * query, retuning the number of objects that were updated.\n-         */\n-        public Number executeUpdate(StoreQuery q, Object[] params);\n-\n-        /**\n-         * Return a description of the commands that will be sent to\n-         * the datastore in order to execute the query.\n-         */\n-        public String[] getDataStoreActions(StoreQuery q, Object[] params,\n-            Range range);\n-\n-        /**\n-         * Validate components of query.\n-         */\n-        public void validate(StoreQuery q);\n-\n-        /**\n-         * Mutate the given range to set any range information stored in \n-         * the query string and/or parameters.\n-         */\n-        public void getRange(StoreQuery q, Object[] params, Range range);\n-\n-        /**\n-         * Extract the value of the <code>orderIndex</code>th ordering\n-         * expression in {@link Query#getOrderingClauses} from the\n-         * given result object. The result object will be an object from\n-         * the result object provider returned from {@link #executeQuery}.\n-         * This method is used when several result lists have to be merged\n-         * in memory. If this exeuctor's parent query supports executors on\n-         * abstract or interface classes, this method will not be used.\n-         *\n-         * @see StoreQuery#supportsAbstractExecutors\n-         */\n-        public Object getOrderingValue(StoreQuery q, Object[] params,\n-            Object resultObject, int orderIndex);\n-\n-        /**\n-         * Return the ordering direction for all ordering clauses, or empty\n-         * array if none.\n-         */\n-        public boolean[] getAscending(StoreQuery q);\n-\n-        /**\n-         * Return true if this executor packs projections into the result\n-         * class itself. Executors for query languages that allow projections\n-         * without result clauses must return true and perform the result\n-         * packing themselves.\n-         */\n-        public boolean isPacking(StoreQuery q);\n-\n-        /**\n-         * If this is not a projection but the candidate results are placed\n-         * into a result class with an alias, return that alias.\n-         */\n-        public String getAlias(StoreQuery q);\n-\n-        /**\n-         * Return the alias for each projection element, or empty array\n-         * if not a projection.\n-         */\n-        public String[] getProjectionAliases(StoreQuery q);\n-\n-        /**\n-         * Return the expected types of the projections used by this query,\n-         * or an empty array if not a projection.\n-         */\n-        public Class[] getProjectionTypes(StoreQuery q);\n-\n-        /**\n-         * Return an array of all persistent classes used in this query, or\n-         * empty array if unknown.\n-         */\n-        public ClassMetaData[] getAccessPathMetaDatas(StoreQuery q);\n-\n-        /**\n-         * Returns the operation this executor is meant to execute.\n-         *\n-         * @see QueryOperations\n-         */\n-        public int getOperation(StoreQuery q);\n-\n-        /**\n-         * Return true if the compiled query is an aggregate.\n-         */\n-        public boolean isAggregate(StoreQuery q);\n-\n-        /**\n-         * Whether the compiled query has grouping.\n-         */\n-        public boolean hasGrouping(StoreQuery q);\n-\n-        /**\n-         * Return a map of parameter names to types. The returned\n-         * {@link Map#entrySet}'s {@link Iterator} must return values in the\n-         * order in which they were declared or used.\n-         */\n-        public LinkedMap getParameterTypes(StoreQuery q);\n-\n-        /**\n-         * Returns the result class, if any.\n-         */\n-        public Class getResultClass(StoreQuery q);\n-\n-        /**\n-         * Return a map of {@link FieldMetaData} to update\n-\t\t * {@link Constant}s, in cases where this query is for a bulk update.\n-\t \t */\n-\t\tpublic Map getUpdates (StoreQuery q);\n-\t}\n-}\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.kernel;\r\n+\r\n+import java.io.Serializable;\r\n+import java.util.Iterator;\r\n+import java.util.Map;\r\n+\r\n+import org.apache.commons.collections.map.LinkedMap;\r\n+import org.apache.openjpa.kernel.exps.AggregateListener;\r\n+import org.apache.openjpa.kernel.exps.Constant;\r\n+import org.apache.openjpa.kernel.exps.FilterListener;\r\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n+import org.apache.openjpa.meta.ClassMetaData;\r\n+import org.apache.openjpa.meta.FieldMetaData;\r\n+\r\n+/**\r\n+ * Component that executes queries against the datastore. For\r\n+ * expression-based queries, consider subclassing\r\n+ * {@link ExpressionStoreManagerQuery}.\r\n+ *\r\n+ * @author Abe White\r\n+ * @since 0.4.0\r\n+ */\r\n+public interface StoreQuery\r\n+    extends QueryOperations, Serializable {\r\n+\r\n+    // linkedmap doesn't allow a size of 0, so use 1\r\n+    public static final LinkedMap EMPTY_PARAMS = new LinkedMap(1, 1F);\r\n+    public static final ClassMetaData[] EMPTY_METAS = new ClassMetaData[0];\r\n+    public static final String[] EMPTY_STRINGS = new String[0];\r\n+    public static final Object[] EMPTY_OBJECTS = new Object[0];\r\n+    public static final Class[] EMPTY_CLASSES = new Class[0];\r\n+    public static final boolean[] EMPTY_BOOLEANS = new boolean[0];\r\n+\r\n+    /**\r\n+     * Return the query context that has been set.\r\n+     */\r\n+    public QueryContext getContext();\r\n+\r\n+    /**\r\n+     * Set the current query context. This will be called before use.\r\n+     */\r\n+    public void setContext(QueryContext ctx);\r\n+\r\n+    /**\r\n+     * This is invoked when the user or a facade creates a new query with\r\n+     * an object that the system does not recognize. Return true if\r\n+     * the object is recognized by the store, false otherwise.\r\n+     */\r\n+    public boolean setQuery(Object query);\r\n+\r\n+    /**\r\n+     * Return the standard filter listener for the given tag, or null.\r\n+     */\r\n+    public FilterListener getFilterListener(String tag);\r\n+\r\n+    /**\r\n+     * Return the standard filter listener for the given tag, or null.\r\n+     */\r\n+    public AggregateListener getAggregateListener(String tag);\r\n+\r\n+    /**\r\n+     * Create a new key for caching compiled query information. May be null.\r\n+     */\r\n+    public Object newCompilationKey();\r\n+\r\n+    /**\r\n+     * Create a new compilation for this query. May be null.\r\n+     */\r\n+    public Object newCompilation();\r\n+\r\n+    /**\r\n+     * Populate internal data from compilation.\r\n+     */\r\n+    public void populateFromCompilation(Object comp);\r\n+\r\n+    /**\r\n+     * Invalidate any internal compilation state.\r\n+     */\r\n+    public void invalidateCompilation();\r\n+\r\n+    /**\r\n+     * True if this query supports datastore execution, false if it\r\n+     * can only run in memory.\r\n+     */\r\n+    public boolean supportsDataStoreExecution();\r\n+\r\n+    /**\r\n+     * True if this query supports in-memory execution, false if it\r\n+     * can only run against the datastore.\r\n+     */\r\n+    public boolean supportsInMemoryExecution();\r\n+\r\n+    /**\r\n+     * Return an executor for in-memory execution of this query.\r\n+     * Executors must be cachable and thread safe. If this class returns\r\n+     * true from {@link #supportsAbstractExecutors}, the given metadata\r\n+     * will always be for the candidate class of this query, or possibly\r\n+     * null if the candidate class is not itself persistence capable (like\r\n+     * an interface or abstract base class). Otherwise, the given type will\r\n+     * be a mapped class.\r\n+     *\r\n+     * @param subs whether to include dependent mapped subclasses in the\r\n+     * results; independent subclasses should never be included\r\n+     */\r\n+    public Executor newInMemoryExecutor(ClassMetaData meta, boolean subs);\r\n+\r\n+    /**\r\n+     * Return an executor for datastore execution of this query.\r\n+     * Executors must be cachable and thread safe. If this class returns\r\n+     * true from {@link #supportsAbstractExecutors}, the given metadata\r\n+     * will always be for the candidate class of this query, or possibly\r\n+     * null if the candidate class is not itself persistence capable (like\r\n+     * an interface or abstract base class). Otherwise, the given type will\r\n+     * be a mapped class.\r\n+     *\r\n+     * @param subs whether to include dependent mapped subclasses in the\r\n+     * results; independent subclasses should never be included\r\n+     */\r\n+    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs);\r\n+\r\n+    /**\r\n+     * Return true if this query supports execution against abstract or\r\n+     * interface types. Returns false by default, meaning we will only\r\n+     * request executors for persistent classes. In this case, we will\r\n+     * automatically combine the results of the executors for all\r\n+     * implementing classes if we execute a query for an interface for\r\n+     * abstract type.\r\n+     */\r\n+    public boolean supportsAbstractExecutors();\r\n+\r\n+    /**\r\n+     * Whether this query requires a candidate class.\r\n+     */\r\n+    public boolean requiresCandidateType();\r\n+\r\n+    /**\r\n+     * Whether this query requires parameters to be declared.\r\n+     */\r\n+    public boolean requiresParameterDeclarations();\r\n+\r\n+    /**\r\n+     * Whether this query supports declared parameters.\r\n+     */\r\n+    public boolean supportsParameterDeclarations();\r\n+\r\n+    public Object evaluate(Object value, Object ob, Object[] params, \r\n+        OpenJPAStateManager sm);\r\n+\r\n+    /**\r\n+     * A query result range.\r\n+     */\r\n+    public static class Range {\r\n+        public long start = 0L;\r\n+        public long end = Long.MAX_VALUE;\r\n+        public boolean lrs = false;\r\n+\r\n+        public Range() {\r\n+        }\r\n+\r\n+        public Range(long start, long end) {\r\n+            this.start = start;\r\n+            this.end = end;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * An executor provides a uniform interface to the mechanism for executing\r\n+     * either an in-memory or datastore query. In the common case, the\r\n+     * {@link #executeQuery} method will be called before other methods,\r\n+     * though this is not guaranteed.\r\n+     *\r\n+     * @author Marc Prud'hommeaux\r\n+     */\r\n+    public static interface Executor {\r\n+\r\n+        /**\r\n+         * Return the result of executing this query with the given parameter\r\n+         * values. If this query is a projection and this executor does not\r\n+         * pack results itself, each element of the returned result object\r\n+         * provider should be an object array containing the projection values.\r\n+         *\r\n+         * @param lrs true if the query result should be treated as a\r\n+         * large result set, assuming the query is not an\r\n+         * aggregate and does not have grouping\r\n+         * @see #isPacking\r\n+         */\r\n+        public ResultObjectProvider executeQuery(StoreQuery q, Object[] params,\r\n+            Range range);\r\n+\r\n+        /**\r\n+         * Deleted the objects that result from the execution of the\r\n+         * query, retuning the number of objects that were deleted.\r\n+         */\r\n+        public Number executeDelete(StoreQuery q, Object[] params);\r\n+\r\n+        /**\r\n+         * Updates the objects that result from the execution of the\r\n+         * query, retuning the number of objects that were updated.\r\n+         */\r\n+        public Number executeUpdate(StoreQuery q, Object[] params);\r\n+\r\n+        /**\r\n+         * Return a description of the commands that will be sent to\r\n+         * the datastore in order to execute the query.\r\n+         */\r\n+        public String[] getDataStoreActions(StoreQuery q, Object[] params,\r\n+            Range range);\r\n+\r\n+        /**\r\n+         * Validate components of query.\r\n+         */\r\n+        public void validate(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Mutate the given range to set any range information stored in \r\n+         * the query string and/or parameters.\r\n+         */\r\n+        public void getRange(StoreQuery q, Object[] params, Range range);\r\n+\r\n+        /**\r\n+         * Extract the value of the <code>orderIndex</code>th ordering\r\n+         * expression in {@link Query#getOrderingClauses} from the\r\n+         * given result object. The result object will be an object from\r\n+         * the result object provider returned from {@link #executeQuery}.\r\n+         * This method is used when several result lists have to be merged\r\n+         * in memory. If this exeuctor's parent query supports executors on\r\n+         * abstract or interface classes, this method will not be used.\r\n+         *\r\n+         * @see StoreQuery#supportsAbstractExecutors\r\n+         */\r\n+        public Object getOrderingValue(StoreQuery q, Object[] params,\r\n+            Object resultObject, int orderIndex);\r\n+\r\n+        /**\r\n+         * Return the ordering direction for all ordering clauses, or empty\r\n+         * array if none.\r\n+         */\r\n+        public boolean[] getAscending(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Return true if this executor packs projections into the result\r\n+         * class itself. Executors for query languages that allow projections\r\n+         * without result clauses must return true and perform the result\r\n+         * packing themselves.\r\n+         */\r\n+        public boolean isPacking(StoreQuery q);\r\n+\r\n+        /**\r\n+         * If this is not a projection but the candidate results are placed\r\n+         * into a result class with an alias, return that alias.\r\n+         */\r\n+        public String getAlias(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Return the alias for each projection element, or empty array\r\n+         * if not a projection.\r\n+         */\r\n+        public String[] getProjectionAliases(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Return the expected types of the projections used by this query,\r\n+         * or an empty array if not a projection.\r\n+         */\r\n+        public Class[] getProjectionTypes(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Return an array of all persistent classes used in this query, or\r\n+         * empty array if unknown.\r\n+         */\r\n+        public ClassMetaData[] getAccessPathMetaDatas(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Returns the operation this executor is meant to execute.\r\n+         *\r\n+         * @see QueryOperations\r\n+         */\r\n+        public int getOperation(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Return true if the compiled query is an aggregate.\r\n+         */\r\n+        public boolean isAggregate(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Whether the compiled query has grouping.\r\n+         */\r\n+        public boolean hasGrouping(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Return a map of parameter names to types. The returned\r\n+         * {@link Map#entrySet}'s {@link Iterator} must return values in the\r\n+         * order in which they were declared or used.\r\n+         */\r\n+        public LinkedMap getParameterTypes(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Returns the result class, if any.\r\n+         */\r\n+        public Class getResultClass(StoreQuery q);\r\n+\r\n+        /**\r\n+         * Return a map of {@link FieldMetaData} to update\r\n+\t\t * {@link Constant}s, in cases where this query is for a bulk update.\r\n+\t \t */\r\n+\t\tpublic Map getUpdates (StoreQuery q);\r\n+\t}\r\n+}\r"}]}

