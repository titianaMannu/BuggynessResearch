{"sha":"dd2790cfc58414c663cb0781f17e10a2e939286e","node_id":"MDY6Q29tbWl0MjA2MzY0OmRkMjc5MGNmYzU4NDE0YzY2M2NiMDc4MWYxN2UxMGEyZTkzOTI4NmU=","commit":{"author":{"name":"Donald Woods","email":"dwoods@apache.org","date":"2010-04-07T02:18:26Z"},"committer":{"name":"Donald Woods","email":"dwoods@apache.org","date":"2010-04-07T02:18:26Z"},"message":"OPENJPA-1550 Fix TestBatchLimitException tests for Oracle, which fails all statements in the batch, instead of just the duplicate entity.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/2.0.x@931406 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"45713a957f912aa7d77ddfeb4b20cf67b1dd6c40","url":"https://api.github.com/repos/apache/openjpa/git/trees/45713a957f912aa7d77ddfeb4b20cf67b1dd6c40"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/dd2790cfc58414c663cb0781f17e10a2e939286e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/dd2790cfc58414c663cb0781f17e10a2e939286e","html_url":"https://github.com/apache/openjpa/commit/dd2790cfc58414c663cb0781f17e10a2e939286e","comments_url":"https://api.github.com/repos/apache/openjpa/commits/dd2790cfc58414c663cb0781f17e10a2e939286e/comments","author":null,"committer":null,"parents":[{"sha":"551a5d211cd8907390f6df36fdcf6e7b497d733e","url":"https://api.github.com/repos/apache/openjpa/commits/551a5d211cd8907390f6df36fdcf6e7b497d733e","html_url":"https://github.com/apache/openjpa/commit/551a5d211cd8907390f6df36fdcf6e7b497d733e"}],"stats":{"total":73,"additions":61,"deletions":12},"files":[{"sha":"a88d267499b66b7ec86ec7fdece53bba3c18dc58","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/batch/exception/TestBatchLimitException.java","status":"modified","additions":61,"deletions":12,"changes":73,"blob_url":"https://github.com/apache/openjpa/blob/dd2790cfc58414c663cb0781f17e10a2e939286e/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/batch/exception/TestBatchLimitException.java","raw_url":"https://github.com/apache/openjpa/raw/dd2790cfc58414c663cb0781f17e10a2e939286e/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/batch/exception/TestBatchLimitException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/batch/exception/TestBatchLimitException.java?ref=dd2790cfc58414c663cb0781f17e10a2e939286e","patch":"@@ -21,6 +21,10 @@\n import javax.persistence.EntityManager;\n import javax.persistence.EntityManagerFactory;\n \n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.OracleDictionary;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n import org.apache.openjpa.persistence.test.PersistenceTestCase;\n import org.apache.openjpa.util.ExceptionInfo;\n \n@@ -33,23 +37,32 @@\n public class TestBatchLimitException extends PersistenceTestCase {\n \n     static Ent1 expectedFailedObject;\n+    static Ent1 expectedFailedObjectOracle;\n+    static boolean isOracle = false;\n     final String expectedFailureMsg =\n         \"INSERT INTO Ent1 (pk, name) VALUES (?, ?) [params=(int) 200, (String) twohundred]\";\n+    final String expectedFailureMsg18 =\n+        \"INSERT INTO Ent1 (pk, name) VALUES (?, ?) [params=(int) 18, (String) name18]\";\n+    String expectedFailureMsgOracle = expectedFailureMsg18;\n \n     public EntityManagerFactory newEmf(String batchLimit) {\n-        EntityManagerFactory emf =\n+        OpenJPAEntityManagerFactorySPI emf =\n             createEMF(Ent1.class, \n                 \"openjpa.jdbc.SynchronizeMappings\", \n                 \"buildSchema(ForeignKeys=true)\",\n                 \"openjpa.jdbc.DBDictionary\", batchLimit, \n                 CLEAR_TABLES);\n \n         assertNotNull(\"Unable to create EntityManagerFactory\", emf);\n+        JDBCConfiguration conf = (JDBCConfiguration) emf.getConfiguration();\n+        DBDictionary dict = conf.getDBDictionaryInstance();\n+        isOracle = dict instanceof OracleDictionary;\n         return emf;\n     }\n \n     public void setUp() {\n         expectedFailedObject = null;\n+        expectedFailedObjectOracle = null;\n     }\n \n     // Test that we get the correct 'failed object' when we have a batchLimt\n@@ -71,7 +84,10 @@ public void testExceptionInFirstBatch() throws Throwable {\n         EntityManager em2 = emf.createEntityManager();\n \n         em2.getTransaction().begin();\n-        em2.persist(new Ent1(0, \"zero\"));\n+        // special case, due to how Oracle returns all statements in the batch\n+        expectedFailedObjectOracle = new Ent1(18, \"name18\");\n+        expectedFailureMsgOracle = expectedFailureMsg18;\n+        em2.persist(expectedFailedObjectOracle);\n         em2.persist(new Ent1(2, \"two\"));\n         em2.persist(new Ent1(200, \"twohundred\"));\n         em2.persist(new Ent1(3, \"three\"));\n@@ -101,6 +117,8 @@ public void testExceptionSingleBatchedRow() throws Throwable {\n \n         em.getTransaction().begin();\n         expectedFailedObject = new Ent1(200, \"twohundred\");\n+        expectedFailedObjectOracle = expectedFailedObject;\n+        expectedFailureMsgOracle = expectedFailureMsg;\n         em.persist(expectedFailedObject);\n         em.getTransaction().commit();\n         em.close();\n@@ -140,6 +158,8 @@ public void testExceptionInSecondBatch() throws Throwable {\n \n         em.getTransaction().begin();\n         expectedFailedObject = new Ent1(200, \"twohundred\");\n+        expectedFailedObjectOracle = expectedFailedObject;\n+        expectedFailureMsgOracle = expectedFailureMsg;\n         em.persist(expectedFailedObject);\n         em.getTransaction().commit();\n         em.close();\n@@ -176,7 +196,8 @@ public void testExceptionInSecondBatch() throws Throwable {\n     // it somewhere in the middle of the third batch. Again, we want to make sure our\n     // indexing into the batch containing the 'failed object' is correct.\n     public void testExceptionInThirdBatch() throws Throwable {\n-        EntityManagerFactory emf = newEmf(\"batchLimit=9\");\n+        final int batchLimit=9;\n+        EntityManagerFactory emf = newEmf(\"batchLimit=\"+batchLimit);\n         EntityManager em = emf.createEntityManager();\n \n         em.getTransaction().begin();\n@@ -191,15 +212,22 @@ public void testExceptionInThirdBatch() throws Throwable {\n \n         // Persist 21 objects/rows....as such we will have two 'full'\n         // batches (9*2=18) and 3 (21-18=3) objects/rows in the 3rd batch.\n-        for (int i = 0; i < 22; i++) {\n+        int i=0;\n+        for (; i < 2*batchLimit; i++) {\n             em2.persist(new Ent1(i, \"name\" + i));\n         }\n \n+        // manually create third batch, due to how Oracle returns all statements in the batch\n+        expectedFailedObjectOracle = new Ent1(i, \"name\" + i++);\n+        expectedFailureMsgOracle = expectedFailureMsg18;\n+        em2.persist(expectedFailedObjectOracle);    // 18\n+        em2.persist(new Ent1(i, \"name\" + i++));     // 19\n+        em2.persist(new Ent1(i, \"name\" + i++));     // 20\n+        em2.persist(new Ent1(i, \"name\" + i++));     // 21        \n         // Put the duplicate row in the 3rd batch.\n         em2.persist(new Ent1(200, \"twohundred\"));\n-\n         // Put a few more objects into the batch.\n-        for (int i = 22; i < 40; i++) {\n+        for (i = 22; i < 4*batchLimit; i++) {\n             em2.persist(new Ent1(i, \"name\" + i));\n         }\n \n@@ -222,20 +250,25 @@ public void testExceptionInThirdBatch() throws Throwable {\n     // again with failures again.....just want to make sure things are not in\n     // some way 're-used' between the two commits as far as the indexes go.\n     public void testSecondExceptionHasRightIndex() throws Throwable {\n+        final int batchLimit=9;\n+\n         testExceptionInThirdBatch();\n \n         EntityManagerFactory emf = newEmf(\"batchLimit=9\");\n         EntityManager em = emf.createEntityManager();\n \n         em.getTransaction().begin();\n \n-        for (int i = 40; i < 55; i++) {\n+        for (int i = 4*batchLimit; i < 5*batchLimit; i++) {\n             em.persist(new Ent1(i, \"name\" + i));\n         }\n \n-        em.persist(new Ent1(200, \"twohundred\"));\n+        // manually capture start of batch, due to how Oracle returns all statements in the batch\n+        expectedFailedObjectOracle = new Ent1(200, \"twohundred\");\n+        expectedFailureMsgOracle = expectedFailureMsg;\n+        em.persist(expectedFailedObjectOracle);\n \n-        for (int i = 55; i < 65; i++) {\n+        for (int i = 5*batchLimit; i < 7*batchLimit; i++) {\n             em.persist(new Ent1(i, \"name\" + i));\n         }\n \n@@ -267,12 +300,17 @@ public void testExceptionWithMultipleCommits() throws Throwable {\n \n         EntityManager em2 = emf.createEntityManager();\n         em2.getTransaction().begin();\n+        em2.persist(new Ent1(4, \"four\"));\n         em2.persist(new Ent1(0, \"zero\"));\n         em2.persist(new Ent1(2, \"two\"));\n         em2.persist(new Ent1(3, \"three\"));\n         em2.getTransaction().commit();\n \n         em2.getTransaction().begin();\n+        // special case, due to how Oracle returns all statements in the batch\n+        expectedFailedObjectOracle = new Ent1(18, \"name18\");\n+        expectedFailureMsgOracle = expectedFailureMsg18;\n+        em2.persist(expectedFailedObjectOracle);\n         em2.persist(new Ent1(6, \"six\"));\n         em2.persist(new Ent1(200, \"twohundred\"));\n         em2.persist(new Ent1(7, \"seven\"));\n@@ -308,7 +346,12 @@ public void verifyFailedObject(Throwable excp) throws Throwable {\n             Ent1 failedObject = (Ent1) e.getFailedObject();\n \n             assertNotNull(\"Failed object was null.\", failedObject);\n-            assertEquals(expectedFailedObject, failedObject);\n+            if (!isOracle) {\n+                assertEquals(expectedFailedObject, failedObject);\n+            } else {\n+                // special case, as Oracle returns all statements in the batch\n+                assertEquals(expectedFailedObjectOracle, failedObject);                \n+            }\n         }\n         else {\n             throw excp;\n@@ -317,8 +360,14 @@ public void verifyFailedObject(Throwable excp) throws Throwable {\n \n     public void verifyExMsg(String msg) {\n         assertNotNull(\"Exception message was null.\", msg);\n-        assertTrue(\"Did not see expected text in message. Expected <\" + expectedFailureMsg + \"> but was \" + msg, msg\n-            .contains(expectedFailureMsg));\n+        if (!isOracle) {\n+            assertTrue(\"Did not see expected text in message. Expected <\" + expectedFailureMsg + \"> but was \" +\n+                msg, msg.contains(expectedFailureMsg));\n+        } else {\n+            // special case, as Oracle returns all statements in the batch\n+            assertTrue(\"Did not see expected text in message. Expected <\" + expectedFailureMsgOracle + \"> but was \" +\n+                msg, msg.contains(expectedFailureMsgOracle));\n+        }\n     }\n }\n "}]}

