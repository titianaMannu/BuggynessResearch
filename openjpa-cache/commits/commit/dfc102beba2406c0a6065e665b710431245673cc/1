{"sha":"dfc102beba2406c0a6065e665b710431245673cc","node_id":"MDY6Q29tbWl0MjA2MzY0OmRmYzEwMmJlYmEyNDA2YzBhNjA2NWU2NjViNzEwNDMxMjQ1NjczY2M=","commit":{"author":{"name":"Kevin W. Sutter","email":"kwsutter@apache.org","date":"2007-02-16T13:52:08Z"},"committer":{"name":"Kevin W. Sutter","email":"kwsutter@apache.org","date":"2007-02-16T13:52:08Z"},"message":"OPENJPA-141.  A few improvements to the performance-related changes done with the previous Issue.  Reference OPENJPA-141 for details.  Biggest change was moving some of the common caching code to ImplHelper.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@508395 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"5982d9e39d7ffb085d866943df0a4388cade416a","url":"https://api.github.com/repos/apache/openjpa/git/trees/5982d9e39d7ffb085d866943df0a4388cade416a"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/dfc102beba2406c0a6065e665b710431245673cc","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/dfc102beba2406c0a6065e665b710431245673cc","html_url":"https://github.com/apache/openjpa/commit/dfc102beba2406c0a6065e665b710431245673cc","comments_url":"https://api.github.com/repos/apache/openjpa/commits/dfc102beba2406c0a6065e665b710431245673cc/comments","author":null,"committer":null,"parents":[{"sha":"7a2330ce3bcb238be8df2295e13c49b2994cf5ed","url":"https://api.github.com/repos/apache/openjpa/commits/7a2330ce3bcb238be8df2295e13c49b2994cf5ed","html_url":"https://github.com/apache/openjpa/commit/7a2330ce3bcb238be8df2295e13c49b2994cf5ed"}],"stats":{"total":136,"additions":51,"deletions":85},"files":[{"sha":"cfe5caf080d2ee8b41883265a89dc7f2c2322dec","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/dfc102beba2406c0a6065e665b710431245673cc/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/dfc102beba2406c0a6065e665b710431245673cc/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java?ref=dfc102beba2406c0a6065e665b710431245673cc","patch":"@@ -29,7 +29,7 @@\n     implements ManagedRuntime {\n \n     private String _tmLoc = \"java:/TransactionManager\";\n-    private static TransactionManager _tm;\n+    private TransactionManager _tm = null;\n \n     /**\n      * Return the location of the {@link TransactionManager} in JNDI.\n@@ -43,12 +43,14 @@ public String getTransactionManagerName() {\n      */\n     public void setTransactionManagerName(String name) {\n         _tmLoc = name;\n+        _tm = null;  // reset the cached TM\n     }\n \n     /**\n      * Return the cached TransactionManager instance.\n      */\n     public TransactionManager getTransactionManager() throws Exception {\n+\n         if (_tm == null) {\n             Context ctx = new InitialContext();\n             try {"},{"sha":"8122267ce8bfc6b342c88896a50285a908906d88","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":3,"deletions":36,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/dfc102beba2406c0a6065e665b710431245673cc/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/dfc102beba2406c0a6065e665b710431245673cc/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=dfc102beba2406c0a6065e665b710431245673cc","patch":"@@ -63,7 +63,6 @@\n import org.apache.openjpa.lib.util.ReferenceHashMap;\n import org.apache.openjpa.lib.util.ReferenceHashSet;\n import org.apache.openjpa.lib.util.ReferenceMap;\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n import org.apache.openjpa.lib.util.concurrent.ReentrantLock;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n@@ -75,6 +74,7 @@\n import org.apache.openjpa.util.CallbackException;\n import org.apache.openjpa.util.Exceptions;\n import org.apache.openjpa.util.GeneralException;\n+import org.apache.openjpa.util.ImplHelper;\n import org.apache.openjpa.util.InternalException;\n import org.apache.openjpa.util.InvalidStateException;\n import org.apache.openjpa.util.NoTransactionException;\n@@ -139,9 +139,6 @@\n \n     private static final Localizer _loc =\n         Localizer.forPackage(BrokerImpl.class);\n-    // Cache for from/to type assignments\n-    private static ConcurrentReferenceHashMap _assignableTypes =\n-        new ConcurrentReferenceHashMap(ReferenceMap.HARD, ReferenceMap.WEAK);\n \n     //\tthe store manager in use; this may be a decorator such as a\n     //\tdata cache store manager around the native store manager\n@@ -1101,7 +1098,8 @@ public Object newObjectId(Class cls, Object val) {\n                         cls));\n                 return PCRegistry.newObjectId(cls, (String) val);\n             }\n-            if (isAssignable(meta.getObjectIdType(), val.getClass())) {\n+            if (ImplHelper.isAssignable(meta.getObjectIdType(), val.getClass()))\n+            {\n                 if (!meta.isOpenJPAIdentity() && meta.isObjectIdTypeShared())\n                     return new ObjectId(cls, val);\n                 return val;\n@@ -1122,37 +1120,6 @@ public Object newObjectId(Class cls, Object val) {\n         }\n     }\n \n-    /**\n-     * Cache from/to assignments to avoid Class.isAssignableFrom overhead\n-     * @param from the target Class\n-     * @param to the Class to test\n-     * @return true if the \"to\" class could be assigned to \"from\" class\n-     */\n-    private boolean isAssignable(Class from, Class to) {\n-      boolean isAssignable;\n-      ConcurrentReferenceHashMap assignableTo =\n-          (ConcurrentReferenceHashMap) _assignableTypes.get(from);\n-\n-      if (assignableTo != null) { // \"to\" cache exists...\n-          isAssignable = (assignableTo.get(to) != null);\n-          if (!isAssignable) { // not in the map yet...\n-              isAssignable = from.isAssignableFrom(to);\n-              if (isAssignable) {\n-                  assignableTo.put(to, new Object());\n-              }\n-          }\n-      } else { // no \"to\" cache yet...\n-          isAssignable = from.isAssignableFrom(to);\n-          if (isAssignable) {\n-              assignableTo = new ConcurrentReferenceHashMap(\n-                      ReferenceMap.HARD, ReferenceMap.WEAK);\n-              _assignableTypes.put(from, assignableTo);\n-              assignableTo.put(to, new Object());\n-          }\n-      }\n-      return isAssignable;\n-    }\n-\n     /**\n      * Create a new state manager for the given oid.\n      */"},{"sha":"fb17730c23b9d8860642770d8a07886f3520ec85","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","status":"modified","additions":6,"deletions":45,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/dfc102beba2406c0a6065e665b710431245673cc/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/dfc102beba2406c0a6065e665b710431245673cc/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java?ref=dfc102beba2406c0a6065e665b710431245673cc","patch":"@@ -36,11 +36,10 @@\n import org.apache.openjpa.lib.rop.SimpleResultList;\n import org.apache.openjpa.lib.rop.WindowResultList;\n import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.util.ReferenceMap;\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FetchGroup;\n import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.util.ImplHelper;\n import org.apache.openjpa.util.InternalException;\n import org.apache.openjpa.util.NoTransactionException;\n import org.apache.openjpa.util.UserException;\n@@ -60,10 +59,6 @@\n     private static final Localizer _loc = Localizer.forPackage\n         (FetchConfigurationImpl.class);\n \n-    // Cache the from/to isAssignable invocations\n-    private static ConcurrentReferenceHashMap _assignableTypes =\n-        new ConcurrentReferenceHashMap(ReferenceMap.HARD, ReferenceMap.WEAK);\n-\n     /**\n      * Configurable state shared throughout a traversal chain.\n      */\n@@ -563,7 +558,7 @@ private int getAvailableRecursionDepth(FieldMetaData fm, Class type,\n         // see if there's a previous limit\n         int avail = Integer.MIN_VALUE;\n         for (FetchConfigurationImpl f = this; f != null; f = f._parent) {\n-            if (isAssignable(type, f._fromType)) {\n+            if (ImplHelper.isAssignable(type, f._fromType)) {\n                 avail = f._availableRecursion;\n                 if (traverse)\n                     avail = reduce(avail);\n@@ -588,15 +583,15 @@ private int getAvailableRecursionDepth(FieldMetaData fm, Class type,\n                 max = cur;\n         }\n         // reduce max if we're traversing a self-type relation\n-        if (traverse && max != Integer.MIN_VALUE \n-            && isAssignable(meta.getDescribedType(), type))\n+        if (traverse && max != Integer.MIN_VALUE\n+            && ImplHelper.isAssignable(meta.getDescribedType(), type))\n             max = reduce(max);\n \n         // take min/defined of previous avail and fetch group max\n         if (avail == Integer.MIN_VALUE && max == Integer.MIN_VALUE) {\n             int def = FetchGroup.RECURSION_DEPTH_DEFAULT;\n-            return (traverse && isAssignable(meta.getDescribedType(), type))\n-                ? def - 1 : def;\n+            return (traverse && ImplHelper.isAssignable(\n+                    meta.getDescribedType(), type)) ? def - 1 : def;\n         }\n         if (avail == Integer.MIN_VALUE || avail == FetchGroup.DEPTH_INFINITE)\n             return max;\n@@ -618,40 +613,6 @@ private static Class getRelationType(FieldMetaData fm) {\n         return null;\n     }\n \n-    /**\n-     * Whether either of the two types is assignable from the other.  Optimize\n-     * for the repeat calls with similar parameters by caching the from/to\n-     * type parameters.\n-     */\n-    private static boolean isAssignable(Class from, Class to) {\n-        boolean isAssignable;\n-\n-        if (from == null || to == null)\n-            return false;\n-        ConcurrentReferenceHashMap assignableTo =\n-            (ConcurrentReferenceHashMap) _assignableTypes.get(from);\n-\n-        if (assignableTo != null) { // \"to\" cache exists...\n-            isAssignable = (assignableTo.get(to) != null);\n-            if (!isAssignable) {  // not in the map yet...\n-                isAssignable = from.isAssignableFrom(to);\n-                if (isAssignable) {\n-                    assignableTo.put(to, new Object());\n-                }\n-            }\n-        } else {  // no \"to\" cache yet...\n-            isAssignable = from.isAssignableFrom(to);\n-            if (isAssignable) {\n-                assignableTo = new ConcurrentReferenceHashMap(\n-                        ReferenceMap.HARD, ReferenceMap.WEAK);\n-                _assignableTypes.put(from, assignableTo);\n-                assignableTo.put(to, new Object());\n-            }\n-        }\n-\n-        return isAssignable;\n-    }\n-\n     /**\n      * Reduce the given logical depth by 1.\n      */"},{"sha":"415c07bb9f252665e27a1c5ef6489c7b89d2f951","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","status":"modified","additions":38,"deletions":1,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/dfc102beba2406c0a6065e665b710431245673cc/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","raw_url":"https://github.com/apache/openjpa/raw/dfc102beba2406c0a6065e665b710431245673cc/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java?ref=dfc102beba2406c0a6065e665b710431245673cc","patch":"@@ -20,8 +20,8 @@\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Iterator;\n+import java.util.Map;\n \n-import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.kernel.FetchConfiguration;\n import org.apache.openjpa.kernel.LockManager;\n@@ -30,7 +30,10 @@\n import org.apache.openjpa.kernel.StoreContext;\n import org.apache.openjpa.kernel.StoreManager;\n import org.apache.openjpa.lib.util.Closeable;\n+import org.apache.openjpa.lib.util.ReferenceMap;\n import org.apache.openjpa.lib.util.UUIDGenerator;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n import org.apache.openjpa.meta.JavaTypes;\n@@ -46,6 +49,10 @@\n  */\n public class ImplHelper {\n \n+    // Cache for from/to type assignments\n+    private static ConcurrentReferenceHashMap _assignableTypes =\n+        new ConcurrentReferenceHashMap(ReferenceMap.WEAK, ReferenceMap.HARD);\n+\n     /**\n      * Helper for store manager implementations. This method simply delegates\n      * to the proper singular method for each state manager.\n@@ -187,4 +194,34 @@ public static boolean isManagedType(Class type) {\n     public static boolean isManageable(Object instance) {\n         return instance instanceof PersistenceCapable;\n     }\n+\n+    /**\n+     * Returns true if the referenced \"to\" class is assignable to the \"from\"\n+     * class.  This helper method utilizes a cache to help avoid the overhead\n+     * of the Class.isAssignableFrom() method.\n+     *\n+     * @param from target class instance to be checked for assignability\n+     * @param to second class instance to be checked for assignability\n+     * @return true if the \"to\" class is assignable to the \"from\" class\n+     */\n+    public static boolean isAssignable(Class from, Class to) {\n+        Boolean isAssignable = null;\n+        if (from == null || to == null)\n+            return false;\n+        Map assignableTo = (Map) _assignableTypes.get(from);\n+\n+        if (assignableTo == null) { // \"to\" cache doesn't exist, so create it...\n+            assignableTo = new ConcurrentHashMap();\n+            _assignableTypes.put(from, assignableTo);\n+        } else { // \"to\" cache exists...\n+            isAssignable = (Boolean) assignableTo.get(to);\n+        }\n+\n+        if (isAssignable == null) {// we don't have a record of this pair...\n+            isAssignable = new Boolean(from.isAssignableFrom(to));\n+            assignableTo.put(to, isAssignable);\n+        }\n+\n+        return isAssignable.booleanValue();\n+    }\n }"},{"sha":"f2c081b2010884cbc426ddcc4cdcb2997ee05a23","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","status":"modified","additions":1,"deletions":2,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/dfc102beba2406c0a6065e665b710431245673cc/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","raw_url":"https://github.com/apache/openjpa/raw/dfc102beba2406c0a6065e665b710431245673cc/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java?ref=dfc102beba2406c0a6065e665b710431245673cc","patch":"@@ -17,7 +17,6 @@\n \n import java.io.Serializable;\n \n-import org.apache.openjpa.lib.util.ReferenceHashSet;\n import org.apache.openjpa.lib.util.ReferenceMap;\n import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n \n@@ -37,7 +36,7 @@\n     private transient int _typeHash = 0;\n     // cache the types' generated hashcodes\n     private static ConcurrentReferenceHashMap _typeCache =\n-        new ConcurrentReferenceHashMap(ReferenceMap.HARD, ReferenceMap.WEAK);\n+        new ConcurrentReferenceHashMap(ReferenceMap.WEAK, ReferenceMap.HARD);\n \n     protected OpenJPAId() {\n     }"}]}

