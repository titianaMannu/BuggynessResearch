{"sha":"e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c","node_id":"MDY6Q29tbWl0MjA2MzY0OmUxNDM3OGY3ZjMyYmZiYWE1OWU1NThiOGMyOWZmNDJmZjNlNzFjMGM=","commit":{"author":{"name":"Kevin W. Sutter","email":"kwsutter@apache.org","date":"2007-02-12T02:33:05Z"},"committer":{"name":"Kevin W. Sutter","email":"kwsutter@apache.org","date":"2007-02-12T02:33:05Z"},"message":"OPENJPA-138.  Some updates to help with performance of OpenJPA in an application server environment.  Details can be found in the OPENJPA-138 Issue.\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@506230 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"f26790d4eb55129da2efac3bdcb69eb29adbb1d1","url":"https://api.github.com/repos/apache/openjpa/git/trees/f26790d4eb55129da2efac3bdcb69eb29adbb1d1"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c","html_url":"https://github.com/apache/openjpa/commit/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c","comments_url":"https://api.github.com/repos/apache/openjpa/commits/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c/comments","author":null,"committer":null,"parents":[{"sha":"7d0839f9ff14644050133a19edcb61d030432602","url":"https://api.github.com/repos/apache/openjpa/commits/7d0839f9ff14644050133a19edcb61d030432602","html_url":"https://github.com/apache/openjpa/commit/7d0839f9ff14644050133a19edcb61d030432602"}],"stats":{"total":205,"additions":167,"deletions":38},"files":[{"sha":"76f7233347dc98dd7bea2202c191fa90ecc63d46","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","status":"modified","additions":14,"deletions":8,"changes":22,"blob_url":"https://github.com/apache/openjpa/blob/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java?ref=e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c","patch":"@@ -29,6 +29,7 @@\n     implements ManagedRuntime {\n \n     private String _tmLoc = \"java:/TransactionManager\";\n+    private static TransactionManager _tm;\n \n     /**\n      * Return the location of the {@link TransactionManager} in JNDI.\n@@ -44,13 +45,18 @@ public void setTransactionManagerName(String name) {\n         _tmLoc = name;\n     }\n \n-    public TransactionManager getTransactionManager()\n-        throws Exception {\n-        Context ctx = new InitialContext();\n-        try {\n-            return (TransactionManager) ctx.lookup(_tmLoc);\n-        } finally {\n-            ctx.close();\n+    /**\n+     * Return the cached TransactionManager instance.\n+     */\n+    public TransactionManager getTransactionManager() throws Exception {\n+        if (_tm == null) {\n+            Context ctx = new InitialContext();\n+            try {\n+                _tm = (TransactionManager) ctx.lookup(_tmLoc);\n+            } finally {\n+                ctx.close();\n+            }\n         }\n-\t}\n+        return _tm;\n+    }\n }"},{"sha":"b63db33205f7c8fff605a3bff21e021ef595366f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","status":"modified","additions":17,"deletions":7,"changes":24,"blob_url":"https://github.com/apache/openjpa/blob/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java?ref=e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c","patch":"@@ -64,7 +64,8 @@\n     // configuration\n     private final OpenJPAConfiguration _conf;\n     private transient boolean _readOnly = false;\n-    private transient RuntimeException _closed = null;\n+    private transient boolean _closed = false;\n+    private transient RuntimeException _closedException = null;\n     private Map _userObjects = null;\n \n     // internal lock: spec forbids synchronization on this object\n@@ -267,7 +268,7 @@ public void removeLifecycleListener(Object listener) {\n      * Returns true if this broker factory is closed.\n      */\n     public boolean isClosed() {\n-        return _closed != null;\n+        return _closed;\n     }\n \n     public void close() {\n@@ -297,7 +298,10 @@ public void close() {\n                 (_conf.getMetaDataRepositoryInstance());\n \n             _conf.close();\n-            _closed = new IllegalStateException();\n+            _closed = true;\n+            Log log = _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME);\n+            if (log.isTraceEnabled())\n+                _closedException = new IllegalStateException();\n         } finally {\n             unlock();\n         }\n@@ -546,12 +550,18 @@ protected Object getFactoryInitializationBanner() {\n     }\n \n     /**\n-     * Throw an exception if the factory is closed.\n+     * Throw an exception if the factory is closed.  The exact message and\n+     * content of the exception varies whether TRACE is enabled or not.\n      */\n     private void assertOpen() {\n-        if (_closed != null)\n-            throw new InvalidStateException(_loc.get(\"closed-factory\")).\n-                setCause(_closed);\n+        if (_closed) {\n+            if (_closedException == null)  // TRACE not enabled\n+                throw new InvalidStateException(_loc\n+                        .get(\"closed-factory-notrace\"));\n+            else\n+                throw new InvalidStateException(_loc.get(\"closed-factory\"))\n+                        .setCause(_closedException);\n+        }\n     }\n \n     ////////////////////"},{"sha":"42edeae4380ccce0cfe1c22e342232e04845598d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":55,"deletions":10,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c","patch":"@@ -63,6 +63,7 @@\n import org.apache.openjpa.lib.util.ReferenceHashMap;\n import org.apache.openjpa.lib.util.ReferenceHashSet;\n import org.apache.openjpa.lib.util.ReferenceMap;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n import org.apache.openjpa.lib.util.concurrent.ReentrantLock;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n@@ -138,6 +139,9 @@\n \n     private static final Localizer _loc =\n         Localizer.forPackage(BrokerImpl.class);\n+    // Cache for from/to type assignments\n+    private static ConcurrentReferenceHashMap _assignableTypes =\n+        new ConcurrentReferenceHashMap(ReferenceMap.HARD, ReferenceMap.WEAK);\n \n     //\tthe store manager in use; this may be a decorator such as a\n     //\tdata cache store manager around the native store manager\n@@ -215,7 +219,8 @@\n \n     // status\n     private int _flags = 0;\n-    private RuntimeException _closed = null;\n+    private boolean _closed = false;\n+    private RuntimeException _closedException = null;\n \n     // event managers\n     private TransactionEventManager _transEventManager = null;\n@@ -1096,8 +1101,7 @@ public Object newObjectId(Class cls, Object val) {\n                         cls));\n                 return PCRegistry.newObjectId(cls, (String) val);\n             }\n-\n-            if (meta.getObjectIdType().isAssignableFrom(val.getClass())) {\n+            if (isAssignable(meta.getObjectIdType(), val.getClass())) {\n                 if (!meta.isOpenJPAIdentity() && meta.isObjectIdTypeShared())\n                     return new ObjectId(cls, val);\n                 return val;\n@@ -1118,6 +1122,37 @@ public Object newObjectId(Class cls, Object val) {\n         }\n     }\n \n+    /**\n+     * Cache from/to assignments to avoid Class.isAssignableFrom overhead\n+     * @param from the target Class\n+     * @param to the Class to test\n+     * @return true if the \"to\" class could be assigned to \"from\" class\n+     */\n+    private boolean isAssignable(Class from, Class to) {\n+      boolean isAssignable;\n+      ConcurrentReferenceHashMap assignableTo =\n+          (ConcurrentReferenceHashMap) _assignableTypes.get(from);\n+\n+      if (assignableTo != null) { // \"to\" cache exists...\n+          isAssignable = (assignableTo.get(to) != null);\n+          if (!isAssignable) { // not in the map yet...\n+              isAssignable = from.isAssignableFrom(to);\n+              if (isAssignable) {\n+                  assignableTo.put(to, new Object());\n+              }\n+          }\n+      } else { // no \"to\" cache yet...\n+          isAssignable = from.isAssignableFrom(to);\n+          if (isAssignable) {\n+              assignableTo = new ConcurrentReferenceHashMap(\n+                      ReferenceMap.HARD, ReferenceMap.WEAK);\n+              _assignableTypes.put(from, assignableTo);\n+              assignableTo.put(to, new Object());\n+          }\n+      }\n+      return isAssignable;\n+    }\n+\n     /**\n      * Create a new state manager for the given oid.\n      */\n@@ -3969,11 +4004,11 @@ public Collection getDeletedTypes() {\n     ///////////\n \n     public boolean isClosed() {\n-        return _closed != null;\n+        return _closed;\n     }\n \n     public boolean isCloseInvoked() {\n-        return _closed != null || (_flags & FLAG_CLOSE_INVOKED) != 0;\n+        return _closed || (_flags & FLAG_CLOSE_INVOKED) != 0;\n     }\n \n     public void close() {\n@@ -4055,8 +4090,10 @@ protected void free() {\n \n         _lm.close();\n         _store.close();\n-        _closed = new IllegalStateException();\n         _flags = 0;\n+        _closed = true;\n+        if (_log.isTraceEnabled())\n+            _closedException = new IllegalStateException();\n \n         if (err != null)\n             throw err;\n@@ -4246,11 +4283,19 @@ protected PersistenceCapable assertPersistenceCapable(Object obj) {\n     /////////\n     // Utils\n     /////////\n-\n+    /**\n+     * Throw an exception if the context is closed.  The exact message and\n+     * content of the exception varies whether TRACE is enabled or not.\n+     */\n     public void assertOpen() {\n-        if (_closed != null)\n-            throw new InvalidStateException(_loc.get(\"closed\"), _closed).\n-                setFatal(true);\n+        if (_closed) {\n+            if (_closedException == null)  // TRACE not enabled\n+                throw new InvalidStateException(_loc.get(\"closed-notrace\"))\n+                        .setFatal(true);\n+            else\n+                throw new InvalidStateException(_loc.get(\"closed\"),\n+                        _closedException).setFatal(true);\n+        }\n     }\n \n     public void assertActiveTransaction() {"},{"sha":"113efe2dfc08566e76a476819d03a40ba066243c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","status":"modified","additions":36,"deletions":4,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java?ref=e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c","patch":"@@ -36,6 +36,8 @@\n import org.apache.openjpa.lib.rop.SimpleResultList;\n import org.apache.openjpa.lib.rop.WindowResultList;\n import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.ReferenceMap;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FetchGroup;\n import org.apache.openjpa.meta.FieldMetaData;\n@@ -58,6 +60,10 @@\n     private static final Localizer _loc = Localizer.forPackage\n         (FetchConfigurationImpl.class);\n \n+    // Cache the from/to isAssignable invocations\n+    private static ConcurrentReferenceHashMap _assignableTypes =\n+        new ConcurrentReferenceHashMap(ReferenceMap.HARD, ReferenceMap.WEAK);\n+\n     /**\n      * Configurable state shared throughout a traversal chain.\n      */\n@@ -613,11 +619,37 @@ private static Class getRelationType(FieldMetaData fm) {\n     }\n \n     /**\n-     * Whether either of the two types is assignable from the other.\n+     * Whether either of the two types is assignable from the other.  Optimize\n+     * for the repeat calls with similar parameters by caching the from/to\n+     * type parameters.\n      */\n-    private static boolean isAssignable(Class c1, Class c2) {\n-        return c1 != null && c2 != null \n-            && (c1.isAssignableFrom(c2) || c2.isAssignableFrom(c1));\n+    private static boolean isAssignable(Class from, Class to) {\n+        boolean isAssignable;\n+\n+        if (from == null || to == null)\n+            return false;\n+        ConcurrentReferenceHashMap assignableTo =\n+            (ConcurrentReferenceHashMap) _assignableTypes.get(from);\n+\n+        if (assignableTo != null) { // \"to\" cache exists...\n+            isAssignable = (assignableTo.get(to) != null);\n+            if (!isAssignable) {  // not in the map yet...\n+                isAssignable = from.isAssignableFrom(to);\n+                if (isAssignable) {\n+                    assignableTo.put(to, new Object());\n+                }\n+            }\n+        } else {  // no \"to\" cache yet...\n+            isAssignable = from.isAssignableFrom(to);\n+            if (isAssignable) {\n+                assignableTo = new ConcurrentReferenceHashMap(\n+                        ReferenceMap.HARD, ReferenceMap.WEAK);\n+                _assignableTypes.put(from, assignableTo);\n+                assignableTo.put(to, new Object());\n+            }\n+        }\n+\n+        return isAssignable;\n     }\n \n     /**"},{"sha":"b6432f78e06de06e91eb92cba132ee25e7b1bee8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","status":"modified","additions":24,"deletions":5,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","raw_url":"https://github.com/apache/openjpa/raw/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java?ref=e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c","patch":"@@ -17,6 +17,10 @@\n \n import java.io.Serializable;\n \n+import org.apache.openjpa.lib.util.ReferenceHashSet;\n+import org.apache.openjpa.lib.util.ReferenceMap;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n+\n /**\n  * Identity class extended by builtin OpenJPA identity objects.\n  *\n@@ -31,6 +35,9 @@\n     // type has his based on the least-derived non-object class so that\n     // user-given ids with non-exact types match ids with exact types\n     private transient int _typeHash = 0;\n+    // cache the types' generated hashcodes\n+    private static ConcurrentReferenceHashMap _typeCache =\n+        new ConcurrentReferenceHashMap(ReferenceMap.HARD, ReferenceMap.WEAK);\n \n     protected OpenJPAId() {\n     }\n@@ -82,13 +89,25 @@ public void setManagedInstanceType(Class type) {\n      */\n     protected abstract boolean idEquals(OpenJPAId other);\n \n+    /**\n+     * Generate the hashcode for this Id.  Cache the type's generated hashcode\n+     * so that it doesn't have to be generated each time.\n+     */\n     public int hashCode() {\n         if (_typeHash == 0) {\n-            Class base = type;\n-            while (base.getSuperclass() != null\n-                && base.getSuperclass() != Object.class)\n-                base = base.getSuperclass();\n-            _typeHash = base.hashCode();\n+            Integer typeHashInt = (Integer) _typeCache.get(type);\n+            if (typeHashInt == null) {\n+                Class base = type;\n+                Class superclass = base.getSuperclass();\n+                while (superclass != null && superclass != Object.class) {\n+                    base = base.getSuperclass();\n+                    superclass = base.getSuperclass();\n+                }\n+                _typeHash = base.hashCode();\n+                _typeCache.put(type, new Integer(_typeHash));\n+            } else {\n+                _typeHash = typeHashInt.intValue();\n+            }\n         }\n         return _typeHash ^ idHash();\n     }"},{"sha":"f86a47ff72c6346d9ab4fd4782e6bc2286818fc6","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties?ref=e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c","patch":"@@ -94,8 +94,13 @@ trans-active: The \"{0}\" transaction property cannot be set during an \\\n active: This operation cannot be performed while a Transaction is active.\n closed: The context has been closed.  The stack trace at which the \\\n \tcontext was closed is held in the embedded exception.\n+closed-notrace: The context has been closed.  The stack trace at which the \\\n+\tcontext was closed is available if Runtime=TRACE logging is enabled.\n closed-factory: The factory has been closed.  The stack trace at \\\n \twhich the factory was closed is held in the embedded exception.\n+closed-factory-notrace: The factory has been closed.  The stack trace at \\\n+\twhich the factory was closed is available if Runtime=TRACE logging is \\\n+\tenabled.\n non-trans-read: To perform reads on persistent data outside of a transaction, \\\n \tthe \"NontransactionalRead\" property must be set on the Transaction.\n non-trans-write: To perform writes on persistent data outside of a \\"},{"sha":"a9c0675d179fd866364a24bf083f51eaef8418cd","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","status":"modified","additions":16,"deletions":4,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","raw_url":"https://github.com/apache/openjpa/raw/e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java?ref=e14378f7f32bfbaa59e558b8c29ff42ff3e71c0c","patch":"@@ -17,6 +17,8 @@\n \n import org.apache.commons.lang.ObjectUtils;\n import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.ReferenceMap;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n \n /**\n  * An object {@link Value}.\n@@ -28,6 +30,10 @@\n     private static final Localizer _loc = Localizer.forPackage\n         (ObjectValue.class);\n \n+    // cache the types' classloader\n+    private static ConcurrentReferenceHashMap _classloaderCache =\n+        new ConcurrentReferenceHashMap(ReferenceMap.HARD, ReferenceMap.WEAK);\n+\n     private Object _value = null;\n \n     public ObjectValue(String prop) {\n@@ -81,10 +87,16 @@ public Object instantiate(Class type, Configuration conf, boolean fatal) {\n      * Allow subclasses to instantiate additional plugins. This method does\n      * not perform configuration.\n      */\n-    public Object newInstance(String clsName, Class type,\n-        Configuration conf, boolean fatal) {\n-        return Configurations.newInstance(clsName, this, conf,\n-            type.getClassLoader(), fatal);\n+    public Object newInstance(String clsName, Class type, Configuration conf,\n+            boolean fatal) {\n+        ClassLoader cl = (ClassLoader) _classloaderCache.get(type);\n+        if (cl == null) {\n+            cl = type.getClassLoader();\n+            if (cl != null) {  // System classloader is returned as null\n+                _classloaderCache.put(type, cl);\n+            }\n+        }\n+        return Configurations.newInstance(clsName, this, conf, cl, fatal);\n     }\n \n     public Class getValueType() {"}]}

