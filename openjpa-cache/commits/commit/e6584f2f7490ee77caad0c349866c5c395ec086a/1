{"sha":"e6584f2f7490ee77caad0c349866c5c395ec086a","node_id":"MDY6Q29tbWl0MjA2MzY0OmU2NTg0ZjJmNzQ5MGVlNzdjYWFkMGMzNDk4NjZjNWMzOTVlYzA4NmE=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-05-14T20:29:21Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-05-14T20:29:21Z"},"message":"removing unused file\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@406418 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"9a055b6111686b00d36d7e6572bf5b68ca271f92","url":"https://api.github.com/repos/apache/openjpa/git/trees/9a055b6111686b00d36d7e6572bf5b68ca271f92"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/e6584f2f7490ee77caad0c349866c5c395ec086a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/e6584f2f7490ee77caad0c349866c5c395ec086a","html_url":"https://github.com/apache/openjpa/commit/e6584f2f7490ee77caad0c349866c5c395ec086a","comments_url":"https://api.github.com/repos/apache/openjpa/commits/e6584f2f7490ee77caad0c349866c5c395ec086a/comments","author":null,"committer":null,"parents":[{"sha":"42cbc4dd743d0072aea113d13788f9324eb193e0","url":"https://api.github.com/repos/apache/openjpa/commits/42cbc4dd743d0072aea113d13788f9324eb193e0","html_url":"https://github.com/apache/openjpa/commit/42cbc4dd743d0072aea113d13788f9324eb193e0"}],"stats":{"total":965,"additions":0,"deletions":965},"files":[{"sha":"30e219f5fdfcf2fc7a0e0add132fba981b5fc805","filename":"openjpa-lib/java/org/apache/openjpa/lib/util/ConcurrentHashMap.java","status":"removed","additions":0,"deletions":965,"changes":965,"blob_url":"https://github.com/apache/openjpa/blob/42cbc4dd743d0072aea113d13788f9324eb193e0/openjpa-lib/java/org/apache/openjpa/lib/util/ConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/42cbc4dd743d0072aea113d13788f9324eb193e0/openjpa-lib/java/org/apache/openjpa/lib/util/ConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/java/org/apache/openjpa/lib/util/ConcurrentHashMap.java?ref=42cbc4dd743d0072aea113d13788f9324eb193e0","patch":"@@ -1,965 +0,0 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.openjpa.lib.util;\r\n-\r\n-\r\n-/*\r\n- * @author Copyright (c) 1997 by WebLogic, Inc. All Rights Reserved.\r\n- */\r\n-import java.io.*;\r\n-import java.util.*;\r\n-\r\n-\r\n-/** This class implements a HashMap which has limited synchronization.\r\n-  * In particular mutators are generally synchronized while accessors\r\n-  * are generally not.  Additionally the Iterators returned by this\r\n-  * class are not \"fail-fast\", but instead try to continue to iterate\r\n-  * over the data structure after changes have been made.\r\n-  *\r\n-  * The synchronization semantics are built right in to the\r\n-  * implementation rather than using a delegating wrapper like the\r\n-  * other collection classes do because it wasn't clear to me that the\r\n-  * how the two should be seperated or that it would be useful to do\r\n-  * so.  This can probably be a topic for further debate in the\r\n-  * future.\r\n-  *\r\n-  * This class is based heavily on the HashMap class in the Java\r\n-  * collections package. */\r\n-public class ConcurrentHashMap extends AbstractMap\r\n-\timplements Map, Cloneable, Serializable \r\n-{\r\n-\tprivate static Localizer _loc = Localizer.forPackage\r\n-\t\t(ConcurrentHashMap.class);\r\n-\r\n-\t/**\r\n-\t * The default initial capacity - MUST be a power of two.\r\n-\t */\r\n-\tprivate static final int DEFAULT_INITIAL_CAPACITY = 16;\r\n-\r\n-\t/**\r\n-\t * The maximum capacity, used if a higher value is implicitly specified\r\n-\t * by either of the constructors with arguments.\r\n-\t * MUST be a power of two <= 1<<30.\r\n-\t */\r\n-\tprivate static final int MAXIMUM_CAPACITY = 1 << 30;\r\n-\r\n-\t/**\r\n-\t * The load fast used when none specified in constructor.\r\n-\t **/\r\n-\tprivate static final float DEFAULT_LOAD_FACTOR = 0.75f;\r\n-\r\n-\t/**\r\n-\t * Value representing null keys inside tables.\r\n-\t */\r\n-\tprivate static final Object NULL_KEY = new Object ();\r\n-\r\n-\t/**\r\n-\t * The table, resized as necessary. Length MUST Always be a power of two.\r\n-\t */\r\n-\tprivate transient Entry[] table;\r\n-\r\n-\t/**\r\n-\t * The number of key-value mappings contained in this identity hash map.\r\n-\t */\r\n-\tprivate transient int size;\r\n-\r\n-\t/**\r\n-\t * The next size value at which to resize (capacity * load factor).\r\n-\t * @serial\r\n-\t */\r\n-\tprivate int threshold;\r\n-\r\n-\t/**\r\n-\t * The load factor for the hash table.\r\n-\t *\r\n-\t * @serial\r\n-\t */\r\n-\tprivate final float loadFactor;\r\n-\r\n-\t/**\r\n-\t * Constructs an empty <tt>ConcurrentHashMap</tt> with the specified initial\r\n-\t * capacity and load factor.\r\n-\t *\r\n-\t * @param\tinitialCapacity The initial capacity.\r\n-\t * @param\tloadFactor\t\t\tThe load factor.\r\n-\t * @throws IllegalArgumentException if the initial capacity is negative\r\n-\t *\t\t\t\t or the load factor is nonpositive.\r\n-\t */\r\n-\tpublic ConcurrentHashMap (int initialCapacity, float loadFactor) \r\n-\t{\r\n-\t\tif (initialCapacity < 0) \r\n-\t\t{\r\n-\t\t\tthrow new IllegalArgumentException (_loc.get (\"concurrent-initial\",\r\n-\t\t\t\tinitialCapacity + \"\"));\r\n-\t\t}\r\n-\t\tif (initialCapacity > MAXIMUM_CAPACITY)\r\n-\t\t\tinitialCapacity = MAXIMUM_CAPACITY;\r\n-\t\tif (loadFactor <= 0 || loadFactor > 1) \r\n-\t\t{\r\n-\t\t\tthrow new IllegalArgumentException (_loc.get (\"concurrent-load\",\r\n-\t\t\t\tloadFactor + \"\"));\r\n-\t\t}\r\n-\r\n-\t\t// Find a power of 2 >= initialCapacity\r\n-\t\tint capacity = 1;\r\n-\t\twhile (capacity < initialCapacity) capacity <<= 1;\r\n-\r\n-\t\tthis.loadFactor = loadFactor;\r\n-\t\tthreshold = (int) (capacity * loadFactor);\r\n-\t\ttable = new Entry[capacity];\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Constructs an empty <tt>ConcurrentHashMap</tt> with the specified initial\r\n-\t * capacity and the default load factor (0.75).\r\n-\t *\r\n-\t * @param\tinitialCapacity the initial capacity.\r\n-\t * @throws IllegalArgumentException if the initial capacity is negative.\r\n-\t */\r\n-\tpublic ConcurrentHashMap (int initialCapacity) \r\n-\t{\r\n-\t\tthis (initialCapacity, DEFAULT_LOAD_FACTOR);\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Constructs an empty <tt>ConcurrentHashMap</tt> with the default initial\r\n-\t * capacity (16) and the default load factor (0.75).\r\n-\t */\r\n-\tpublic ConcurrentHashMap () \r\n-\t{\r\n-\t\tthis (DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Constructs a new <tt>ConcurrentHashMap</tt> with the same mappings as the\r\n-\t * specified <tt>Map</tt>.\tThe <tt>ConcurrentHashMap</tt> is created with\r\n-\t * default load factor (0.75) and an initial capacity sufficient to\r\n-\t * hold the mappings in the specified <tt>Map</tt>.\r\n-\t *\r\n-\t * @param\t m the map whose mappings are to be placed in this map.\r\n-\t * @throws\tNullPointerException if the specified map is null.\r\n-\t */\r\n-\tpublic ConcurrentHashMap (Map m) \r\n-\t{\r\n-\t\tthis (Math.max ( (int) (m.size () / DEFAULT_LOAD_FACTOR) + 1,\r\n-\t\t\tDEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);\r\n-\t\tputAll (m);\r\n-\t}\r\n-\r\n-\r\n-\t// internal utilities\r\n-\r\n-\r\n-\t/**\r\n-\t * Returns internal representation for key. Use NULL_KEY if key is null.\r\n-\t */\r\n-\tprivate static Object maskNull (Object key) \r\n-\t{\r\n-\t\treturn (key == null ? NULL_KEY : key);\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Returns key represented by specified internal representation.\r\n-\t */\r\n-\tprivate static Object unmaskNull (Object key) \r\n-\t{\r\n-\t\treturn (key == NULL_KEY ? null : key);\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Returns a hash code for non-null Object x.\r\n-\t */\r\n-\tprivate static int hash (Object x) \r\n-\t{\r\n-\t\tint h = x.hashCode ();\r\n-\t\treturn h - (h << 7);\t// i.e., -127 * h\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Check for equality of non-null reference x and possibly-null y.\r\n-\t */\r\n-\tprivate static boolean eq (Object x, Object y) \r\n-\t{\r\n-\t\treturn x == y || x.equals (y);\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Returns the current capacity of backing table in this map.\r\n-\t *\r\n-\t * @return the current capacity of backing table in this map.\r\n-\t */\r\n-\tpublic final int capacity () \r\n-\t{\r\n-\t\treturn table.length;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Returns the load factor for this map.\r\n-\t *\r\n-\t * @return the load factor for this map.\r\n-\t */\r\n-\tpublic final float loadFactor () \r\n-\t{\r\n-\t\treturn loadFactor;\r\n-\t}\r\n-\t\r\n-\t/**\r\n-\t * Returns the number of key-value mappings in this map.\r\n-\t *\r\n-\t * @return the number of key-value mappings in this map.\r\n-\t */\r\n-\tpublic final int size () \r\n-\t{\r\n-\t\treturn size;\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Returns <tt>true</tt> if this map contains no key-value mappings.\r\n-\t *\r\n-\t * @return <tt>true</tt> if this map contains no key-value mappings.\r\n-\t */\r\n-\tpublic final boolean isEmpty () \r\n-\t{\r\n-\t\treturn size == 0;\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Returns the value to which the specified key is mapped in this identity\r\n-\t * hash map, or <tt>null</tt> if the map contains no mapping for this key.\r\n-\t * A return value of <tt>null</tt> does not <i>necessarily</i> indicate\r\n-\t * that the map contains no mapping for the key; it is also possible that\r\n-\t * the map explicitly maps the key to <tt>null</tt>. The\r\n-\t * <tt>containsKey</tt> method may be used to distinguish these two cases.\r\n-\t *\r\n-\t * @param\t key the key whose associated value is to be returned.\r\n-\t * @return\tthe value to which this map maps the specified key, or\r\n-\t *\t\t\t\t\t<tt>null</tt> if the map contains no mapping for this \r\n-\t\t\t\t\t\tkey.\r\n-\t * @see #put (Object, Object)\r\n-\t */\r\n-\tpublic Object get (Object key) \r\n-\t{\r\n-\t\tEntry e = getEntry (key);\r\n-\t\treturn e == null? null: e.value;\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Returns <tt>true</tt> if this map contains a mapping for the\r\n-\t * specified key.\r\n-\t *\r\n-\t * @param\t key\t The key whose presence in this map is to be tested\r\n-\t * @return <tt>true</tt> if this map contains a mapping for the specified\r\n-\t * key.\r\n-\t */\r\n-\tpublic final boolean containsKey (Object key) \r\n-\t{\r\n-\t\treturn getEntry (key) != null;\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Returns the entry associated with the specified key in the\r\n-\t * ConcurrentHashMap.\tReturns null if the ConcurrentHashMap contains no\r\n-\t * mapping for this key.\r\n-\t */\r\n-\tprotected Entry getEntry (Object key) \r\n-\t{\r\n-\t\tObject k = maskNull (key);\r\n-\t\tint hash = hash (k);\r\n-\t\tEntry[] tab = table;\r\n-\t\tfor (Entry e = tab[hash & (tab.length-1)]; e != null; e = e.next) \r\n-\t\t{\r\n-\t\t\tif (e.hash == hash && eq (k, e.key)) return e;\r\n-\t\t}\r\n-\t\treturn null;\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Associates the specified value with the specified key in this map.\r\n-\t * If the map previously contained a mapping for this key, the old\r\n-\t * value is replaced.\r\n-\t *\r\n-\t * @param key key with which the specified value is to be associated.\r\n-\t * @param value value to be associated with the specified key.\r\n-\t * @return previous value associated with specified key, or <tt>null</tt>\r\n-\t *\t\t\t\t if there was no mapping for key.\tA <tt>null</tt> return\r\n-\t *\t\t\t\t can also indicate that the ConcurrentHashMap previously\r\n-\t *\t\t\t\t associated\r\n-\t *\t\t\t\t <tt>null</tt> with the specified key.\r\n-\t */\r\n-\tpublic Object put (Object key, Object value) \r\n-\t{\r\n-\t\tObject k = maskNull (key);\r\n-\t\tint hash = hash (k);\r\n-\t\tsynchronized (this) \r\n-\t{\r\n-\t\t\tint i = hash & (table.length - 1);\r\n-\r\n-\t\t\tfor (Entry e = table[i]; e != null; e = e.next) \r\n-\t\t\t{\r\n-\t\t\t\tif (e.hash == hash && eq (k, e.key)) \r\n-\t\t\t\t{\r\n-\t\t\t\t\tObject oldValue = e.value;\r\n-\t\t\t\t\te.value = value;\r\n-\t\t\t\t\treturn oldValue;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\r\n-\t\t\ttable[i] = createEntry (hash, k, value, table[i]);\r\n-\t\t\tif (size++ >= threshold) resize (2 * table.length);\r\n-\t\t}\r\n-\t\treturn null;\r\n-\t}\r\n-\r\n-\r\n-\tpublic Object putIfAbsent (Object key, Object value) \r\n-\t{\r\n-\t\tObject k = maskNull (key);\r\n-\t\tint hash = hash (k);\r\n-\t\tsynchronized (this) \r\n-\t\t{\r\n-\t\t\tint i = hash & (table.length - 1);\r\n-\r\n-\t\t\tfor (Entry e = table[i]; e != null; e = e.next) \r\n-\t\t\t{\r\n-\t\t\t\tif (e.hash == hash && eq (k, e.key)) \r\n-\t\t\t\t{\r\n-\t\t\t\t\treturn e.value;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\r\n-\t\t\ttable[i] = createEntry (hash, k, value, table[i]);\r\n-\t\t\tif (size++ >= threshold) resize (2 * table.length);\r\n-\t\t}\r\n-\t\treturn null;\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Rehashes the contents of this map into a new <tt>ConcurrentHashMap</tt>\r\n-\t * instance with a larger capacity. This method is called automatically when\r\n-\t * the number of keys in this map exceeds its capacity and load factor.\r\n-\t *\r\n-\t * @param newCapacity the new capacity, MUST be a power of two.\r\n-\t */\r\n-\tprivate void resize (int newCapacity) \r\n-\t{\r\n-\t\t// assert (newCapacity & -newCapacity) == newCapacity; // power of 2\r\n-\t\tEntry[] oldTable = table;\r\n-\t\tint oldCapacity = oldTable.length;\r\n-\r\n-\t\t// check if needed\r\n-\t\tif (size < threshold || oldCapacity > newCapacity) return;\r\n-\r\n-\t\tEntry[] newTable = new Entry[newCapacity];\r\n-\t\tint mask = newCapacity-1;\r\n-\t\tfor (int i = oldCapacity; i-- > 0; ) \r\n-\t\t{\r\n-\t\t\tfor (Entry e = oldTable[i]; e != null; e = e.next) \r\n-\t\t\t{\r\n-\t\t\t\tEntry clone = (Entry) e.clone ();\r\n-\t\t\t\tint j = clone.hash & mask;\r\n-\t\t\t\tclone.next = newTable[j];\r\n-\t\t\t\tnewTable[j] = clone;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\ttable = newTable;\r\n-\t\tthreshold = (int) (newCapacity * loadFactor);\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Copies all of the mappings from the specified map to this map\r\n-\t * These mappings will replace any mappings that\r\n-\t * this map had for any of the keys currently in the specified map.\r\n-\t *\r\n-\t * @param t mappings to be stored in this map.\r\n-\t * @throws NullPointerException if the specified map is null.\r\n-\t */\r\n-\tpublic final synchronized void putAll (Map t) \r\n-\t{\r\n-\t\t// Expand enough to hold t's elements without resizing.\r\n-\t\tint n = t.size ();\r\n-\t\tif (n == 0) return;\r\n-\t\tif (n >= threshold) \r\n-\t\t{\r\n-\t\t\tn = (int) (n / loadFactor + 1);\r\n-\t\t\tif (n > MAXIMUM_CAPACITY) n = MAXIMUM_CAPACITY;\r\n-\t\t\tint capacity = table.length;\r\n-\t\t\twhile (capacity < n) capacity <<= 1;\r\n-\t\t\tresize (capacity);\r\n-\t\t}\r\n-\r\n-\t\tfor (Iterator i = t.entrySet ().iterator (); i.hasNext (); ) \r\n-\t\t{\r\n-\t\t\tMap.Entry e = (Map.Entry) i.next ();\r\n-\t\t\tput (e.getKey (), e.getValue ());\r\n-\t\t}\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Removes the mapping for this key from this map if present.\r\n-\t *\r\n-\t * @param\tkey key whose mapping is to be removed from the map.\r\n-\t * @return previous value associated with specified key, or <tt>null</tt>\r\n-\t *\t\t\t\t if there was no mapping for key.\tA <tt>null</tt> return\r\n-\t *\t\t\t\t can also indicate that the map previously associated\r\n-\t *\t\t\t\t <tt>null</tt> with the specified key.\r\n-\t */\r\n-\tpublic Object remove (Object key) \r\n-\t{\r\n-\t\tEntry e = removeEntryForKey (key, null);\r\n-\t\treturn (e == null ? e : e.value);\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Removes the mapping for this key from this map if present and value\r\n-\t * equals the parameter value. If parameter value is null, behaves\r\n-\t * exactly like <code>remove (Object key)</code>.\r\n-\t *\r\n-\t * @param\tkey key whose mapping is to be removed from the map.\r\n-\t * @param\tvalue value that is mapped to this key.\r\n-\t * @return <tt>true</tt> if the entry was removed, or <tt>false</tt>\r\n-\t *\t\t\t\t if there was no mapping for key or the key is not mapped to\r\n-\t *\t\t\t\t\t the parameter value.\r\n-\t */\r\n-\tpublic boolean remove (Object key, Object value) \r\n-\t{\r\n-\t\tEntry e = removeEntryForKey (key, value);\r\n-\t\treturn (e == null ? false : true);\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Removes and returns the entry associated with the specified key and value\r\n-\t * in the ConcurrentHashMap. If value is null, only matches the key.\r\n-\t * Returns null if the ConcurrentHashMap contains no mapping for this key or\r\n-\t * key is not mapped to the input value.\r\n-\t */\r\n-\tprivate Entry removeEntryForKey (Object key, Object v) \r\n-\t{\r\n-\t\tObject k = maskNull (key);\r\n-\t\tint hash = hash (k);\r\n-\t\tsynchronized (this) \r\n-\t\t{\r\n-\t\t\tint i = hash & (table.length - 1);\r\n-\t\t\tEntry e = table[i];\r\n-\r\n-\t\t\tif (e == null) return null;\r\n-\t\t\tif (e.hash == hash && eq (k, e.key) && \r\n-\t\t\t\t(v == null || eq (v, e.value))) \r\n-\t\t\t{\r\n-\t\t\t\tsize--;\r\n-\t\t\t\ttable[i] = e.next;\r\n-\t\t\t\treturn e;\r\n-\t\t\t}\r\n-\r\n-\t\t\tEntry prev = e;\r\n-\t\t\tfor (e = e.next; e != null; prev = e, e = e.next) \r\n-\t\t\t{\r\n-\t\t\t\tif (e.hash == hash && eq (k, e.key) && \r\n-\t\t\t\t\t(v == null || eq (v, e.value))) \r\n-\t\t\t\t{\r\n-\t\t\t\t\tsize--;\r\n-\t\t\t\t\tprev.next = e.next;\r\n-\t\t\t\t\treturn e;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn null;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Special version of remove for EntrySet.\r\n-\t */\r\n-\tprivate Entry removeMapping (Object o) \r\n-\t{\r\n-\t\tif (! (o instanceof Map.Entry)) return null;\r\n-\r\n-\t\tMap.Entry entry = (Map.Entry) o;\r\n-\t\tObject k = maskNull (entry.getKey ());\r\n-\t\tint hash = hash (k);\r\n-\t\tsynchronized (this) \r\n-\t\t{\r\n-\t\t\tint i = hash & (table.length - 1);\r\n-\t\t\tEntry e = table[i];\r\n-\r\n-\t\t\tif (e == null) return null;\r\n-\t\t\tif (e.hash == hash && e.equals (entry)) \r\n-\t\t\t{\r\n-\t\t\t\tsize--;\r\n-\t\t\t\ttable[i] = e.next;\r\n-\t\t\t\treturn e;\r\n-\t\t\t}\r\n-\r\n-\t\t\tEntry prev = e;\r\n-\t\t\tfor (e = e.next; e != null; prev = e, e = e.next) \r\n-\t\t\t{\r\n-\t\t\t\tif (e.hash == hash && e.equals (entry)) \r\n-\t\t\t\t{\r\n-\t\t\t\t\tsize--;\r\n-\t\t\t\t\tprev.next = e.next;\r\n-\t\t\t\t\treturn e;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn null;\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Removes all mappings from this map.\r\n-\t */\r\n-\tpublic synchronized void clear () \r\n-\t{\r\n-\t\ttable = new Entry[table.length];\r\n-\t\tsize = 0;\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Returns <tt>true</tt> if this map maps one or more keys to the\r\n-\t * specified value.\r\n-\t *\r\n-\t * @param value value whose presence in this map is to be tested.\r\n-\t * @return <tt>true</tt> if this map maps one or more keys to the\r\n-\t *\t\t\t\t specified value.\r\n-\t */\r\n-\tpublic final boolean containsValue (Object value) \r\n-\t{\r\n-\t\tif (value == null) return containsNullValue ();\r\n-\r\n-\t\tEntry tab[] = table;\r\n-\t\tfor (int i = 0; i < tab.length ; i++) \r\n-\t\t{\r\n-\t\t\tfor (Entry e = tab[i] ; e != null ; e = e.next) \r\n-\t\t\t{\r\n-\t\t\t\tif (value.equals (e.value)) return true;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Special-case code for containsValue with null argument\r\n-\t **/\r\n-\tprivate boolean containsNullValue () \r\n-\t{\r\n-\t\tEntry tab[] = table;\r\n-\t\tfor (int i = 0; i < tab.length ; i++) \r\n-\t\t{\r\n-\t\t\tfor (Entry e = tab[i] ; e != null ; e = e.next) \r\n-\t\t\t{\r\n-\t\t\t\tif (e.value == null) return true;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Returns a shallow copy of this <tt>ConcurrentHashMap</tt> instance: the\r\n-\t * keys and values themselves are not cloned.\r\n-\t *\r\n-\t * @return a shallow copy of this map.\r\n-\t */\r\n-\tpublic final Object clone () \r\n-\t{\r\n-\t\treturn new ConcurrentHashMap (this);\r\n-\t}\r\n-\r\n-\r\n-\tprotected Entry createEntry (int h, Object k, Object v, Entry n) \r\n-\t{\r\n-\t\treturn new Entry (h, k, v, n);\r\n-\t}\r\n-\r\n-\r\n-\tprotected static class Entry implements Map.Entry \r\n-\t{\r\n-\r\n-\t\tfinal Object key;\r\n-\t\tObject value;\r\n-\t\tfinal int hash;\r\n-\t\tEntry next;\r\n-\r\n-\t\t/**\r\n-\t\t * Create new entry.\r\n-\t\t */\r\n-\t\tprotected Entry (int h, Object k, Object v, Entry n) \r\n-\t\t{\r\n-\t\t\tvalue = v;\r\n-\t\t\tnext = n;\r\n-\t\t\tkey = k;\r\n-\t\t\thash = h;\r\n-\t\t}\r\n-\r\n-\r\n-\t\tpublic Object getKey () \r\n-\t\t{\r\n-\t\t\treturn unmaskNull (key);\r\n-\t\t}\r\n-\r\n-\r\n-\t\tpublic Object getValue () \r\n-\t\t{\r\n-\t\t\treturn value;\r\n-\t\t}\r\n-\r\n-\r\n-\t\tpublic Object setValue (Object newValue) \r\n-\t\t{\r\n-\t\t\tObject oldValue = value;\r\n-\t\t\tvalue = newValue;\r\n-\t\t\treturn oldValue;\r\n-\t\t}\r\n-\r\n-\r\n-\t\tpublic boolean equals (Object o) \r\n-\t\t{\r\n-\t\t\tif (! (o instanceof Map.Entry)) return false;\r\n-\t\t\tMap.Entry e = (Map.Entry) o;\r\n-\t\t\tObject k1 = getKey ();\r\n-\t\t\tObject k2 = e.getKey ();\r\n-\t\t\tif (k1 == k2 || (k1 != null && k1.equals (k2))) \r\n-\t\t\t{\r\n-\t\t\t\tObject v1 = getValue ();\r\n-\t\t\t\tObject v2 = e.getValue ();\r\n-\t\t\t\tif (v1 == v2 || (v1 != null && v1.equals (v2)))\r\n-\t\t\t\t\treturn true;\r\n-\t\t\t}\r\n-\t\t\treturn false;\r\n-\t\t}\r\n-\r\n-\r\n-\t\tpublic int hashCode () \r\n-\t\t{\r\n-\t\t\treturn (key==NULL_KEY ? 0 : key.hashCode ()) ^\r\n-\t\t\t\t (value==null\t ? 0 : value.hashCode ());\r\n-\t\t}\r\n-\r\n-\r\n-\t\tprotected Object clone () \r\n-\t\t{\r\n-\t\t\t// It is the callers responsibility to set the next field\r\n-\t\t\t// correctly.\r\n-\t\t\treturn new Entry (hash, key, value, null);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\r\n-\tprivate abstract class HashIterator implements Iterator \r\n-\t{\r\n-\t\tfinal Entry[] table = ConcurrentHashMap.this.table;\r\n-\t\tEntry next;\t\t\t\t\t\t\t\t\t// next entry to return\r\n-\t\tint index;\t\t\t\t\t\t\t\t\t // current slot\r\n-\t\tEntry current;\t\t\t\t\t\t\t // current entry\r\n-\r\n-\t\tHashIterator () \r\n-\t\t{\r\n-\t\t\tif (size == 0) return;\r\n-\t\t\tEntry[] t = table;\r\n-\t\t\tint i = t.length-1;\r\n-\t\t\tEntry n = t[i];\r\n-\t\t\twhile (n == null && i > 0) n = t[--i];\r\n-\t\t\tindex = i;\r\n-\t\t\tnext = n;\r\n-\t\t}\r\n-\r\n-\r\n-\t\tpublic final boolean hasNext () \r\n-\t\t{\r\n-\t\t\treturn next != null;\r\n-\t\t}\r\n-\r\n-\r\n-\t\tfinal Entry nextEntry () \r\n-\t\t{\r\n-\t\t\tEntry e = next;\r\n-\t\t\tif (e == null) throw new NoSuchElementException ();\r\n-\r\n-\t\t\tEntry n = e.next;\r\n-\t\t\tEntry[] t = table;\r\n-\t\t\tint i = index;\r\n-\t\t\twhile (n == null && i > 0) n = t[--i];\r\n-\t\t\tindex = i;\r\n-\t\t\tnext = n;\r\n-\t\t\treturn current = e;\r\n-\t\t}\r\n-\r\n-\r\n-\t\tpublic final void remove () \r\n-\t\t{\r\n-\t\t\tif (current == null) throw new IllegalStateException ();\r\n-\t\t\tObject k = current.key;\r\n-\t\t\tcurrent = null;\r\n-\t\t\tConcurrentHashMap.this.removeEntryForKey (k, null);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\r\n-\tprivate final class ValueIterator extends HashIterator \r\n-\t{\r\n-\t\tpublic Object next () \r\n-\t\t{\r\n-\t\t\treturn nextEntry ().value;\r\n-\t\t}\r\n-\t}\r\n-\r\n-\r\n-\tprivate final class KeyIterator extends HashIterator \r\n-\t{\r\n-\t\tpublic Object next () \r\n-\t\t{\r\n-\t\t\treturn nextEntry ().getKey ();\r\n-\t\t}\r\n-\t}\r\n-\r\n-\r\n-\tprivate final class EntryIterator extends HashIterator \r\n-\t{\r\n-\t\tpublic Object next () \r\n-\t\t{\r\n-\t\t\treturn nextEntry ();\r\n-\t\t}\r\n-\t}\r\n-\r\n-\r\n-\t// Views\r\n-\r\n-\tprivate transient Set entrySet = null;\r\n-\tprivate transient Set keySet = null;\r\n-\tprivate transient Collection values = null;\r\n-\r\n-\t/**\r\n-\t * Returns a set view of the keys contained in this map.\tThe set is\r\n-\t * backed by the map, so changes to the map are reflected in the set, and\r\n-\t * vice-versa.\tThe set supports element removal, which removes the\r\n-\t * corresponding mapping from this map, via the <tt>Iterator.remove</tt>,\r\n-\t * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt>, and\r\n-\t * <tt>clear</tt> operations.\tIt does not support the <tt>add</tt> or\r\n-\t * <tt>addAll</tt> operations.\r\n-\t *\r\n-\t * @return a set view of the keys contained in this map.\r\n-\t */\r\n-\tpublic final Set keySet () \r\n-\t{\r\n-\t\tSet ks = keySet;\r\n-\t\treturn (ks != null ? ks : (keySet = new KeySet ()));\r\n-\t}\r\n-\r\n-\r\n-\tprivate final class KeySet extends AbstractSet \r\n-\t{\r\n-\t\tpublic Iterator iterator () \r\n-\t\t{\r\n-\t\t\treturn new KeyIterator ();\r\n-\t\t}\r\n-\r\n-\r\n-\t\tpublic int size () \r\n-\t\t{\r\n-\t\t\treturn size;\r\n-\t\t}\r\n-\r\n-\r\n-\t\tpublic boolean contains (Object o) \r\n-\t\t{\r\n-\t\t\treturn containsKey (o);\r\n-\t\t}\r\n-\r\n-\r\n-\t\tpublic boolean remove (Object o) \r\n-\t\t{\r\n-\t\t\treturn ConcurrentHashMap.this.removeEntryForKey (o, null) != null;\r\n-\t\t}\r\n-\r\n-\r\n-\t\tpublic void clear () \r\n-\t\t{\r\n-\t\t\tConcurrentHashMap.this.clear ();\r\n-\t\t}\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Returns a collection view of the values contained in this map.\tThe\r\n-\t * collection is backed by the map, so changes to the map are reflected in\r\n-\t * the collection, and vice-versa.\tThe collection supports element\r\n-\t * removal, which removes the corresponding mapping from this map, via the\r\n-\t * <tt>Iterator.remove</tt>, <tt>Collection.remove</tt>,\r\n-\t * <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt> operations.\r\n-\t * It does not support the <tt>add</tt> or <tt>addAll</tt> operations.\r\n-\t *\r\n-\t * @return a collection view of the values contained in this map.\r\n-\t */\r\n-\tpublic final Collection values () \r\n-\t{\r\n-\t\tCollection vs = values;\r\n-\t\treturn (vs != null ? vs : (values = new Values ()));\r\n-\t}\r\n-\r\n-\r\n-\tprivate final class Values extends AbstractCollection \r\n-\t{\r\n-\t\tpublic Iterator iterator () \r\n-\t\t{\r\n-\t\t\treturn new ValueIterator ();\r\n-\t\t}\r\n-\t\tpublic int size () \r\n-\t\t{\r\n-\t\t\treturn size;\r\n-\t\t}\r\n-\t\tpublic boolean contains (Object o) \r\n-\t\t{\r\n-\t\t\treturn containsValue (o);\r\n-\t\t}\r\n-\t\tpublic void clear () \r\n-\t\t{\r\n-\t\t\tConcurrentHashMap.this.clear ();\r\n-\t\t}\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Returns a collection view of the mappings contained in this map.\tEach\r\n-\t * element in the returned collection is a <tt>Map.Entry</tt>.\tThe\r\n-\t * collection is backed by the map, so changes to the map are reflected in\r\n-\t * the collection, and vice-versa.\tThe collection supports element\r\n-\t * removal, which removes the corresponding mapping from the map, via the\r\n-\t * <tt>Iterator.remove</tt>, <tt>Collection.remove</tt>,\r\n-\t * <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt> operations.\r\n-\t * It does not support the <tt>add</tt> or <tt>addAll</tt> operations.\r\n-\t *\r\n-\t * @return a collection view of the mappings contained in this map.\r\n-\t * @see Map.Entry\r\n-\t */\r\n-\tpublic final Set entrySet () \r\n-\t{\r\n-\t\tSet es = entrySet;\r\n-\t\treturn (es != null ? es : (entrySet = new EntrySet ()));\r\n-\t}\r\n-\r\n-\r\n-\tprivate final class EntrySet extends AbstractSet \r\n-\t{\r\n-\t\tpublic Iterator iterator () \r\n-\t\t{\r\n-\t\t\treturn new EntryIterator ();\r\n-\t\t}\r\n-\t\tpublic boolean contains (Object o) \r\n-\t\t{\r\n-\t\t\tif (! (o instanceof Map.Entry)) return false;\r\n-\t\t\tMap.Entry e = (Map.Entry) o;\r\n-\t\t\tEntry candidate = getEntry (e.getKey ());\r\n-\t\t\treturn candidate != null && candidate.equals (e);\r\n-\t\t}\r\n-\t\tpublic boolean remove (Object o) \r\n-\t\t{\r\n-\t\t\treturn removeMapping (o) != null;\r\n-\t\t}\r\n-\t\tpublic int size () \r\n-\t\t{\r\n-\t\t\treturn size;\r\n-\t\t}\r\n-\t\tpublic void clear () \r\n-\t\t{\r\n-\t\t\tConcurrentHashMap.this.clear ();\r\n-\t\t}\r\n-\t}\r\n-\r\n-\r\n-\t/**\r\n-\t * Save the state of the <tt>ConcurrentHashMap</tt> instance to a stream\r\n-\t * (i.e., serialize it).\r\n-\t *\r\n-\t * @serialData The <i>capacity</i> of the ConcurrentHashMap (the length of\r\n-\t * the bucket array) is emitted (int), followed by the <i>size</i> of the\r\n-\t * ConcurrentHashMap (the number of key-value mappings), followed by the key\r\n-\t * (Object) and value (Object) for each key-value mapping represented by the\r\n-\t * ConcurrentHashMap The key-value mappings are emitted in the order that\r\n-\t * they are returned by <tt>entrySet ().iterator ()</tt>.\r\n-\t *\r\n-\t */\r\n-\tprivate void writeObject (ObjectOutputStream s)\r\n-\t\tthrows IOException\r\n-\t\r\n-\t{\r\n-\t\t// Write out the threshold, loadfactor, and any hidden stuff\r\n-\t\ts.defaultWriteObject ();\r\n-\r\n-\t\t// Write out number of buckets\r\n-\t\ts.writeInt (table.length);\r\n-\r\n-\t\t// Write out size (number of Mappings)\r\n-\t\ts.writeInt (size);\r\n-\r\n-\t\t// Write out keys and values (alternating)\r\n-\t\tfor (Iterator i = entrySet ().iterator (); i.hasNext (); ) \r\n-\t\t{\r\n-\t\t\tMap.Entry e = (Map.Entry) i.next ();\r\n-\t\t\ts.writeObject (e.getKey ());\r\n-\t\t\ts.writeObject (e.getValue ());\r\n-\t\t}\r\n-\t}\r\n-\r\n-\r\n-\tprivate static final long serialVersionUID = -6452706556724125778L;\r\n-\r\n-\t/**\r\n-\t * Reconstitute the <tt>ConcurrentHashMap</tt> instance from a stream (i.e.,\r\n-\t * deserialize it).\r\n-\t */\r\n-\tprivate void readObject (ObjectInputStream s)\r\n-\t\tthrows IOException, ClassNotFoundException\r\n-\t\r\n-\t{\r\n-\t\t// Read in the threshold, loadfactor, and any hidden stuff\r\n-\t\ts.defaultReadObject ();\r\n-\r\n-\t\t// Read in number of buckets and allocate the bucket array;\r\n-\t\tint numBuckets = s.readInt ();\r\n-\t\ttable = new Entry[numBuckets];\r\n-\r\n-\t\t// Read in size (number of Mappings)\r\n-\t\tint size = s.readInt ();\r\n-\r\n-\t\t// Read the keys and values, and put the mappings in the \r\n-\t\t// ConcurrentHashMap\r\n-\t\tfor (int i=0; i<size; i++) \r\n-\t\t{\r\n-\t\t\tObject key = s.readObject ();\r\n-\t\t\tObject value = s.readObject ();\r\n-\t\t\tput (key, value);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\r\n-}\r"}]}

