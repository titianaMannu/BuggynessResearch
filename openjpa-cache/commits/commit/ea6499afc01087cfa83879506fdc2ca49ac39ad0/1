{"sha":"ea6499afc01087cfa83879506fdc2ca49ac39ad0","node_id":"MDY6Q29tbWl0MjA2MzY0OmVhNjQ5OWFmYzAxMDg3Y2ZhODM4Nzk1MDZmZGMyY2E0OWFjMzlhZDA=","commit":{"author":{"name":"Albert Lee","email":"allee8285@apache.org","date":"2009-11-03T18:50:48Z"},"committer":{"name":"Albert Lee","email":"allee8285@apache.org","date":"2009-11-03T18:50:48Z"},"message":"OPENJPA-1306 - Correct secondary table locking problem and test cases to match. Also fixed multiple SQLs validation test case problem.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@832506 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"dd4551f835cc89afd41f903d27df24b3cb57e23f","url":"https://api.github.com/repos/apache/openjpa/git/trees/dd4551f835cc89afd41f903d27df24b3cb57e23f"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/ea6499afc01087cfa83879506fdc2ca49ac39ad0","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/ea6499afc01087cfa83879506fdc2ca49ac39ad0","html_url":"https://github.com/apache/openjpa/commit/ea6499afc01087cfa83879506fdc2ca49ac39ad0","comments_url":"https://api.github.com/repos/apache/openjpa/commits/ea6499afc01087cfa83879506fdc2ca49ac39ad0/comments","author":null,"committer":null,"parents":[{"sha":"d59954d4b460c3d95b52a46054d721ba1e596872","url":"https://api.github.com/repos/apache/openjpa/commits/d59954d4b460c3d95b52a46054d721ba1e596872","html_url":"https://github.com/apache/openjpa/commit/d59954d4b460c3d95b52a46054d721ba1e596872"}],"stats":{"total":310,"additions":195,"deletions":115},"files":[{"sha":"ba0949ccc907af5ac44dba2f44add6509e668334","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/MixedLockManager.java","status":"modified","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/ea6499afc01087cfa83879506fdc2ca49ac39ad0/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/MixedLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/ea6499afc01087cfa83879506fdc2ca49ac39ad0/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/MixedLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/MixedLockManager.java?ref=ea6499afc01087cfa83879506fdc2ca49ac39ad0","patch":"@@ -19,9 +19,16 @@\n package org.apache.openjpa.jdbc.kernel;\n \n import java.sql.SQLException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.jdbc.sql.SQLFactory;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.MixedLockLevels;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n@@ -74,6 +81,32 @@ protected void lockInternal(OpenJPAStateManager sm, int level, int timeout,\n         }\n     }\n \n+    protected List<SQLBuffer> getLockRows(DBDictionary dict, Object id, ClassMapping mapping,\n+            JDBCFetchConfiguration fetch, SQLFactory factory) {\n+        List<SQLBuffer> sqls = super.getLockRows(dict, id, mapping, fetch, factory);\n+        // \n+        if(!dict.supportsLockingWithMultipleTables) {\n+            // look for columns mapped to secondary tables which need to be locked\n+            Map<String,FieldMapping> colsMappedToSecTable = new HashMap<String,FieldMapping>();\n+            FieldMapping fms[] = mapping.getFieldMappings();\n+            for( FieldMapping fm : fms) {\n+                String secTableName = fm.getMappingInfo().getTableName();\n+                if( secTableName != null ) {\n+                    colsMappedToSecTable.put(secTableName, fm);\n+                }\n+            }\n+            for( String secTableName : colsMappedToSecTable.keySet()) {\n+                FieldMapping fm = colsMappedToSecTable.get(secTableName);\n+                // select only the PK columns, since we just want to lock\n+                Select select = factory.newSelect();\n+                select.select(fm.getColumns());\n+                select.whereForeignKey(fm.getJoinForeignKey(), id, mapping, _store);\n+                sqls.add(select.toSelect(true, fetch));\n+            }\n+        }\n+        return sqls;\n+    }\n+\n     protected void optimisticLockInternal(OpenJPAStateManager sm, int level,\n         int timeout, Object sdata, boolean postLockVersionCheck) {\n         super.optimisticLockInternal(sm, level, timeout, sdata,"},{"sha":"911e9b0718992d7776a9289374f27753d7172d33","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","status":"modified","additions":24,"deletions":12,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/ea6499afc01087cfa83879506fdc2ca49ac39ad0/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/ea6499afc01087cfa83879506fdc2ca49ac39ad0/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java?ref=ea6499afc01087cfa83879506fdc2ca49ac39ad0","patch":"@@ -22,11 +22,14 @@\n import java.sql.PreparedStatement;\n import java.sql.ResultSet;\n import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n \n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.jdbc.sql.SQLFactory;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.StoreContext;\n@@ -48,7 +51,7 @@\n     private static final Localizer _loc = Localizer.forPackage\n         (PessimisticLockManager.class);\n \n-    private JDBCStore _store;\n+    protected JDBCStore _store;\n \n     public PessimisticLockManager() {\n         setVersionCheckOnReadLock(false);\n@@ -119,24 +122,20 @@ private void lockRow(OpenJPAStateManager sm, int timeout, int level) {\n \n         Object id = sm.getObjectId();\n         ClassMapping mapping = (ClassMapping) sm.getMetaData();\n-        while (mapping.getJoinablePCSuperclassMapping() != null)\n-            mapping = mapping.getJoinablePCSuperclassMapping();\n \n-        // select only the PK columns, since we just want to lock\n-        Select select = _store.getSQLFactory().newSelect();\n-        select.select(mapping.getPrimaryKeyColumns());\n-        select.wherePrimaryKey(id, mapping, _store);\n-        SQLBuffer sql = select.toSelect(true, fetch);\n+        List<SQLBuffer> sqls = getLockRows(dict, id, mapping, fetch, _store.getSQLFactory()); \n \n         ensureStoreManagerTransaction();\n         Connection conn = _store.getConnection();\n         PreparedStatement stmnt = null;\n         ResultSet rs = null;\n         try {\n-            stmnt = prepareStatement(conn, sql);\n-            dict.setTimeouts(stmnt, fetch, true);\n-            rs = executeQuery(conn, stmnt, sql);\n-            checkLock(rs, sm, timeout);\n+            for (SQLBuffer sql : sqls) {\n+                stmnt = prepareStatement(conn, sql);\n+                dict.setTimeouts(stmnt, fetch, true);\n+                rs = executeQuery(conn, stmnt, sql);\n+                checkLock(rs, sm, timeout);\n+            }\n         } catch (SQLException se) {\n             throw SQLExceptions.getStoreSQLException(sm, se, dict,\n                 level);\n@@ -149,6 +148,19 @@ private void lockRow(OpenJPAStateManager sm, int timeout, int level) {\n         }\n     }\n \n+    protected List<SQLBuffer> getLockRows(DBDictionary dict, Object id, ClassMapping mapping,\n+            JDBCFetchConfiguration fetch, SQLFactory factory) {\n+        while (mapping.getJoinablePCSuperclassMapping() != null)\n+            mapping = mapping.getJoinablePCSuperclassMapping();\n+        // select only the PK columns, since we just want to lock\n+        Select select = factory.newSelect();\n+        select.select(mapping.getPrimaryKeyColumns());\n+        select.wherePrimaryKey(id, mapping, _store);\n+        List<SQLBuffer> sqls = new ArrayList<SQLBuffer>();\n+        sqls.add(select.toSelect(true, fetch));\n+        return sqls;\n+    }\n+\n     /**\n      * Enforce that we have an actual transaction in progress so that we can\n      * start locking. The transaction should already be begun when using a"},{"sha":"0eb52d18b0da7618be62d46136aa92cd29ac8b3e","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LockScopeTestCase.java","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/ea6499afc01087cfa83879506fdc2ca49ac39ad0/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LockScopeTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/ea6499afc01087cfa83879506fdc2ca49ac39ad0/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LockScopeTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/LockScopeTestCase.java?ref=ea6499afc01087cfa83879506fdc2ca49ac39ad0","patch":"@@ -66,8 +66,11 @@\n  */\n public abstract class LockScopeTestCase extends SQLListenerTestCase {\n     \n+    protected final String Any              = \".*\";\n     protected final String Select           = \"SELECT.*FROM.*\";\n     protected final String Where            = \".*WHERE.*\";\n+//    protected final String Join             = \".*(JOIN){1}.*\";\n+    protected final String NoJoin           = \"(JOIN){0}\";\n     protected final String ForUpdateRex     = \"FOR UPDATE.*\";\n     protected final String ForUpdateClause  = \"(\" + ForUpdateRex + \")\";\n     protected final String ForUpdate        = ForUpdateClause + \"{1}\";\n@@ -149,7 +152,7 @@ public void assertLockTestSQLs(String... expected) {\n             log.trace(\"\\r\\n\" + toString(sql));\n             return;\n         }\n-        assertAnySQLAnyOrder(expected);\n+        assertAllSQLAnyOrder(expected);\n     }\n     \n     protected void logStack(Throwable t) {"},{"sha":"c31c38c345b95a0bbe41d964e2d4d7357c96e50e","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/Test1x1LockScope.java","status":"modified","additions":32,"deletions":24,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/ea6499afc01087cfa83879506fdc2ca49ac39ad0/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/Test1x1LockScope.java","raw_url":"https://github.com/apache/openjpa/raw/ea6499afc01087cfa83879506fdc2ca49ac39ad0/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/Test1x1LockScope.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/Test1x1LockScope.java?ref=ea6499afc01087cfa83879506fdc2ca49ac39ad0","patch":"@@ -30,6 +30,14 @@\n public class Test1x1LockScope extends LockScopeTestCase {\n \n     public void setUp() {\n+        setSupportedDatabases(\n+                org.apache.openjpa.jdbc.sql.DerbyDictionary.class,\n+                org.apache.openjpa.jdbc.sql.OracleDictionary.class,\n+                org.apache.openjpa.jdbc.sql.DB2Dictionary.class);\n+        if (isTestsDisabled()) {\n+            return;\n+        }\n+\n         setUp(LSE1x1Lf.class\n             , LSE1x1LfLzy.class\n             , LSE1x1LfJT.class\n@@ -113,7 +121,7 @@ public void findNoLockDbSQL(EntityManager em) {\n                             // SELECT t0.version, t0.firstName, t1.id, t1.version, t1.lastName \n                             //      FROM LSE1x1Lf t0, LSE1x1Rt t1 WHERE t0.id = ? AND t0.UNIRIGHT_ID = t1.id(+) \n                             //      [params=(int) 1111201]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n                                     + NoForUpdate);\n                             break;\n                         case derby:\n@@ -143,7 +151,7 @@ public void findPessimisticForcIncDbSQL(EntityManager em) {\n                             //      FOR UPDATE [params=(int) 1111202]\n                             // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? FOR UPDATE [params=(int) 1121202]\n                             // SELECT t0.version FROM LSE1x1Lf t0 WHERE t0.id = ? FOR UPDATE [params=(int) 1111202]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n                                     + ForUpdate);\n                             break;\n                         case derby:     //TODO: **Non-atomic lock.\n@@ -158,8 +166,8 @@ public void findPessimisticForcIncDbSQL(EntityManager em) {\n                             // SELECT t0.id FROM LSE1x1Lf t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1111202]\n                             // SELECT t0.version FROM LSE1x1Lf t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1111202]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + tableLfName + \".*\" + Where + ForUpdate,\n-                                    Select + tableRtName + \".*\" + Where + ForUpdate\n+                                    Select + NoJoin + Any + tableLfName + Any + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + ForUpdate\n                                     );\n                             break;\n                         default:\n@@ -185,7 +193,7 @@ public void queryPessimisticReadDbSQL(EntityManager em) {\n                             //      FOR UPDATE [params=(String) firstName%1111201]\n                             // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? [params=(int) 1121201]\n                             // SELECT t0.version FROM LSE1x1Lf t0 WHERE t0.id = ? [params=(int) 1111201]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n                                     + ForUpdate);\n                             break;\n                         case derby:     //TODO: **Non-atomic lock.\n@@ -200,8 +208,8 @@ public void queryPessimisticReadDbSQL(EntityManager em) {\n                             // SELECT t0.id FROM LSE1x1Lf t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1111201]\n                             // SELECT t0.version FROM LSE1x1Lf t0 WHERE t0.id = ? [params=(int) 1111201]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + tableLfName + \".*\" + Where + ForUpdate,\n-                                    Select + tableRtName + \".*\" + Where + ForUpdate\n+                                    Select + NoJoin + Any + tableLfName + Any + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + ForUpdate\n                                     );\n                             break;\n                         default:\n@@ -221,7 +229,7 @@ public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n                             // SELECT t0.version, t0.firstName, t1.id, t1.version, t1.lastName \n                             //      FROM LSE1x1Lf t0, LSE1x1Rt t1 WHERE t0.id = ? AND t0.UNIRIGHT_ID = t1.id(+) \n                             //      [params=(int) 1111202]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n                                     + NoForUpdate);\n                             break;\n                         case derby:\n@@ -251,7 +259,7 @@ public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n                             //      FOR UPDATE [params=(String) firstName%1111201]\n                             // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? [params=(int) 1121201]\n                             // SELECT t0.version FROM LSE1x1Lf t0 WHERE t0.id = ? [params=(int) 1111201]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n                                     + ForUpdate);\n                             break;\n                         case derby:     //TODO: **Non-atomic lock.\n@@ -266,8 +274,8 @@ public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n                             // SELECT t0.id FROM LSE1x1Lf t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1111201]\n                             // SELECT t0.version FROM LSE1x1Lf t0 WHERE t0.id = ? [params=(int) 1111201]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + tableLfName + \".*\" + Where + ForUpdate,\n-                                    Select + tableRtName + \".*\" + Where + ForUpdate\n+                                    Select + NoJoin + Any + tableLfName + Any + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + ForUpdate\n                                     );\n                             break;\n                         default:\n@@ -287,7 +295,7 @@ public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n                             // SELECT t0.version, t0.firstName, t1.id, t1.version, t1.lastName \n                             //      FROM LSE1x1Lf t0, LSE1x1Rt t1 WHERE t0.id = ? AND t0.UNIRIGHT_ID = t1.id(+) \n                             //      [params=(int) 1111202]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableRtName + Where + \"\\\\(\\\\+\\\\).*\"\n                                     + NoForUpdate);\n                             break;\n                         case derby:\n@@ -552,7 +560,7 @@ public void findNoLockDbSQL(EntityManager em) {\n                             //      FROM LSE1x1LfJT t0, Uni1x1LfJT_Uni1x1RT t1, LSE1x1Rt t2 \n                             //      WHERE t0.id = ? AND t0.id = t1.LSE1X1LFJT_ID AND t1.UNIRIGHTJT_ID = t2.id(+) \n                             //      [params=(int) 1112201]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n                             break;\n                         case derby:\n@@ -583,7 +591,7 @@ public void findPessimisticForcIncDbSQL(EntityManager em) {\n                             //      FOR UPDATE [params=(int) 1112202]\n                             // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? FOR UPDATE [params=(int) 1122202]\n                             // SELECT t0.version FROM LSE1x1LfJT t0 WHERE t0.id = ? FOR UPDATE [params=(int) 1112202]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + \"\\\\(\\\\+\\\\).*\" + ForUpdate);\n                             break;\n                         case derby:     //TODO: **Non-atomic lock, if jpa2/extended scope, LOCK Uni1x1LfJT_Uni1x1RT\n@@ -600,8 +608,8 @@ public void findPessimisticForcIncDbSQL(EntityManager em) {\n                             // SELECT t0.id FROM LSE1x1LfJT t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1112202]\n                             // SELECT t0.version FROM LSE1x1LfJT t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1112202]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + tableLfName + \".*\" + Where + ForUpdate,\n-                                    Select + tableRtName + \".*\" + Where + ForUpdate\n+                                    Select + NoJoin + Any + tableLfName + Any + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + ForUpdate\n                                     );\n                             break;\n                         default:\n@@ -628,7 +636,7 @@ public void queryPessimisticReadDbSQL(EntityManager em) {\n                             //      AND t1.UNIRIGHTJT_ID = t2.id(+) FOR UPDATE [params=(String) firstName%1112201]\n                             // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? [params=(int) 1122201]\n                             // SELECT t0.version FROM LSE1x1LfJT t0 WHERE t0.id = ? [params=(int) 1112201]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + \"\\\\(\\\\+\\\\).*\" + ForUpdate);\n                             break;\n                         case derby:     //TODO: **Non-atomic lock, if jpa2/extended scope, LOCK Uni1x1LfJT_Uni1x1RT\n@@ -645,8 +653,8 @@ public void queryPessimisticReadDbSQL(EntityManager em) {\n                             // SELECT t0.id FROM LSE1x1LfJT t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1112201]\n                             // SELECT t0.version FROM LSE1x1LfJT t0 WHERE t0.id = ? [params=(int) 1112201]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + tableLfName + \".*\" + Where + ForUpdate,\n-                                    Select + tableRtName + \".*\" + Where + ForUpdate\n+                                    Select + NoJoin + Any + tableLfName + Any + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + ForUpdate\n                                     );\n                             break;\n                         default:\n@@ -668,7 +676,7 @@ public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n                             //      FROM LSE1x1LfJT t0, Uni1x1LfJT_Uni1x1RT t1, LSE1x1Rt t2 \n                             //      WHERE t0.id = ? AND t0.id = t1.LSE1X1LFJT_ID AND t1.UNIRIGHTJT_ID = t2.id(+) \n                             //      [params=(int) 1112202]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n                             break;\n                         case derby:\n@@ -700,7 +708,7 @@ public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n                             //      AND t1.UNIRIGHTJT_ID = t2.id(+) FOR UPDATE [params=(String) firstName%1112201]\n                             // SELECT t0.version FROM LSE1x1Rt t0 WHERE t0.id = ? [params=(int) 1122201]\n                             // SELECT t0.version FROM LSE1x1LfJT t0 WHERE t0.id = ? [params=(int) 1112201]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + \"\\\\(\\\\+\\\\).*\" + ForUpdate);\n                             break;\n                         case derby:     //TODO: **Non-atomic lock, if jpa2/extended scope, LOCK Uni1x1LfJT_Uni1x1RT\n@@ -717,8 +725,8 @@ public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n                             // SELECT t0.id FROM LSE1x1LfJT t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 1112201]\n                             // SELECT t0.version FROM LSE1x1LfJT t0 WHERE t0.id = ? [params=(int) 1112201]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + tableLfName + \".*\" + Where + ForUpdate,\n-                                    Select + tableRtName + \".*\" + Where + ForUpdate\n+                                    Select + NoJoin + Any + tableLfName + Any + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + ForUpdate\n                                     );\n                             break;\n                         default:\n@@ -740,7 +748,7 @@ public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n                             //      FROM LSE1x1LfJT t0, Uni1x1LfJT_Uni1x1RT t1, LSE1x1Rt t2 \n                             //      WHERE t0.id = ? AND t0.id = t1.LSE1X1LFJT_ID AND t1.UNIRIGHTJT_ID = t2.id(+) \n                             //      [params=(int) 1112202]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n                             break;\n                         case derby:"},{"sha":"73221fe6a21b860c4e793b270555f6fb16262aba","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/Test1xmLockScope.java","status":"modified","additions":54,"deletions":46,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/ea6499afc01087cfa83879506fdc2ca49ac39ad0/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/Test1xmLockScope.java","raw_url":"https://github.com/apache/openjpa/raw/ea6499afc01087cfa83879506fdc2ca49ac39ad0/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/Test1xmLockScope.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/Test1xmLockScope.java?ref=ea6499afc01087cfa83879506fdc2ca49ac39ad0","patch":"@@ -30,6 +30,14 @@\n public class Test1xmLockScope extends LockScopeTestCase {\n \n     public void setUp() {\n+        setSupportedDatabases(\n+                org.apache.openjpa.jdbc.sql.DerbyDictionary.class,\n+                org.apache.openjpa.jdbc.sql.OracleDictionary.class,\n+                org.apache.openjpa.jdbc.sql.DB2Dictionary.class);\n+        if (isTestsDisabled()) {\n+            return;\n+        }\n+\n         setUp(LSE1xmLf.class\n             , LSE1xmLfEgr.class\n             , LSE1xmLfJT.class\n@@ -316,7 +324,7 @@ public void findNoLockDbSQL(EntityManager em) {\n                             //      FROM LSE1xmLfEgr t0, LSE1xmLfEgr_LSE1xmRt t1, LSE1xmRt t2 \n                             //      WHERE t0.id = ? AND t0.id = t1.LSE1XMLFEGR_ID(+) AND t1.UNIRIGHT_ID = t2.id(+) \n                             //      [params=(int) 2111201] \n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n                             break;\n                         case derby:\n@@ -353,7 +361,7 @@ public void findPessimisticForcIncDbSQL(EntityManager em) {\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE [params=(int) 2121203]\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE [params=(int) 2121204]\n                             // SELECT t0.version FROM LSE1xmLfEgr t0 WHERE t0.id = ? FOR UPDATE [params=(int) 2111202]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + \"\\\\(\\\\+\\\\).*\" + ForUpdate);\n                             break;\n                         case derby:     //TODO: **Non-atomic lock. If jpa2, DO NOT lock LSE1xmRt, \n@@ -378,9 +386,9 @@ public void findPessimisticForcIncDbSQL(EntityManager em) {\n                             // SELECT t0.version FROM LSE1xmLfEgr t0 WHERE t0.id = ? FOR UPDATE WITH RR\n                             //      [params=(int) 2111202]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + tableLfName + Where + ForUpdate,\n-                                    Select + tableRtName + Where + ForUpdate,\n-                                    Select + tableRtName + Where + ForUpdate\n+                                    Select + NoJoin + Any + tableLfName + Any + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + ForUpdate\n                                     );\n                             break;\n                         default:\n@@ -410,10 +418,10 @@ public void queryPessimisticReadDbSQL(EntityManager em) {\n                             //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(int) 2121202]\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ?  [params=(int) 2121202]\n                             // SELECT t0.version FROM LSE1xmLfEgr t0 WHERE t0.id = ?  [params=(int) 2111201]\n-                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock,\n+                            assertLockTestSQLs(Select + NoJoin + Any + tableLfName + Any + NoJoin + Where + DB2Lock,\n                                     Select + joinTables + Where + NoDB2Lock,\n-                                    Select + tableRtName + Where + DB2Lock,\n-                                    Select + tableRtName + Where + DB2Lock);\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + DB2Lock,\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + DB2Lock);\n                             break;\n                         case oracle:    // TODO: if jpa2, DO NOT lock LSE1xmRT using \"FOR UPDATE OF col\"\n                             // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfEgr t0 WHERE (t0.firstName LIKE ?) \n@@ -425,8 +433,8 @@ public void queryPessimisticReadDbSQL(EntityManager em) {\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2121202]\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2121201]\n                             // SELECT t0.version FROM LSE1xmLfEgr t0 WHERE t0.id = ? [params=(int) 2111201]\n-                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate,\n-                                    Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + NoJoin + tableLfName + NoJoin + Where + ForUpdate,\n+                                    Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + ForUpdate);\n                             break;\n                         case derby:     //TODO: **Non-atomic lock. If jpa2, DO NOT lock LSE1xmRt, \n@@ -448,9 +456,9 @@ public void queryPessimisticReadDbSQL(EntityManager em) {\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2121201]\n                             // SELECT t0.version FROM LSE1xmLfEgr t0 WHERE t0.id = ? [params=(int) 2111201]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + tableLfName + Where + ForUpdate,\n-                                    Select + tableRtName + Where + ForUpdate,\n-                                    Select + tableRtName + Where + ForUpdate\n+                                    Select + NoJoin + tableLfName + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + tableRtName + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + tableRtName + NoJoin + Where + ForUpdate\n                                     );\n                             break;\n                         default:\n@@ -472,7 +480,7 @@ public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n                             //      FROM LSE1xmLfEgr t0, LSE1xmLfEgr_LSE1xmRt t1, LSE1xmRt t2 \n                             //      WHERE t0.id = ? AND t0.id = t1.LSE1XMLFEGR_ID(+) AND t1.UNIRIGHT_ID = t2.id(+) \n                             //      [params=(int) 2111202] \n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n                             break;\n                         case derby:\n@@ -507,10 +515,10 @@ public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n                             //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(int) 2121202]\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ?  [params=(int) 2121202]\n                             // SELECT t0.version FROM LSE1xmLfEgr t0 WHERE t0.id = ?  [params=(int) 2111201]\n-                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock,\n+                            assertLockTestSQLs(Select + NoJoin + Any + tableLfName + Any + NoJoin + Where + DB2Lock,\n                                     Select + joinTables + Where + NoDB2Lock,\n-                                    Select + tableRtName + Where + DB2Lock,\n-                                    Select + tableRtName + Where + DB2Lock);\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + DB2Lock,\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + DB2Lock);\n                             break;\n                         case oracle:    // TODO: if jpa2, DO NOT lock LSE1xmRT using \"FOR UPDATE OF col\"\n                             // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfEgr t0 WHERE (t0.firstName LIKE ?) \n@@ -522,8 +530,8 @@ public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2121202]\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2121201]\n                             // SELECT t0.version FROM LSE1xmLfEgr t0 WHERE t0.id = ? [params=(int) 2111201]\n-                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate,\n-                                    Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + NoJoin + tableLfName + NoJoin + Where + ForUpdate,\n+                                    Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + ForUpdate);\n                             break;\n                         case derby:     //TODO: **Non-atomic lock. If jpa2, DO NOT lock LSE1xmRt, \n@@ -545,9 +553,9 @@ public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2121201]\n                             // SELECT t0.version FROM LSE1xmLfEgr t0 WHERE t0.id = ? [params=(int) 2111201]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + tableLfName + Where + ForUpdate,\n-                                    Select + tableRtName + Where + ForUpdate,\n-                                    Select + tableRtName + Where + ForUpdate\n+                                    Select + NoJoin + tableLfName + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + tableRtName + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + tableRtName + NoJoin + Where + ForUpdate\n                                     );\n                             break;\n                         default:\n@@ -569,7 +577,7 @@ public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n                             //      FROM LSE1xmLfEgr t0, LSE1xmLfEgr_LSE1xmRt t1, LSE1xmRt t2 \n                             //      WHERE t0.id = ? AND t0.id = t1.LSE1XMLFEGR_ID(+) AND t1.UNIRIGHT_ID = t2.id(+) \n                             //      [params=(int) 2111202]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n                             break;\n                         case derby:\n@@ -854,7 +862,7 @@ public void findNoLockDbSQL(EntityManager em) {\n                             //      FROM LSE1xmLfJTEgr t0, LSE1xmLfJTEgr_LSE1xmRt t1, LSE1xmRt t2 \n                             //      WHERE t0.id = ? AND t0.id = t1.LSE1XMLFJTEGR_ID(+) AND t1.UNIRIGHT_ID = t2.id(+) \n                             //      [params=(int) 2112201]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n                             break;\n                         case derby:\n@@ -891,7 +899,7 @@ public void findPessimisticForcIncDbSQL(EntityManager em) {\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE [params=(int) 2122203]\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? FOR UPDATE [params=(int) 2122204]\n                             // SELECT t0.version FROM LSE1xmLfJTEgr t0 WHERE t0.id = ? FOR UPDATE [params=(int) 2112202]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + \"\\\\(\\\\+\\\\).*\" + ForUpdate);\n                             break;\n                         case derby:     //TODO: **Non-atomic lock. If jpa2, DO NOT lock LSE1xmRt, \n@@ -916,9 +924,9 @@ public void findPessimisticForcIncDbSQL(EntityManager em) {\n                             // SELECT t0.version FROM LSE1xmLfJTEgr t0 WHERE t0.id = ? FOR UPDATE WITH RR\n                             //      [params=(int) 2112202]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + tableLfName + Where + ForUpdate,\n-                                    Select + tableRtName + Where + ForUpdate,\n-                                    Select + tableRtName + Where + ForUpdate\n+                                    Select + NoJoin + Any + tableLfName + Any + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + ForUpdate\n                                     );\n                             break;\n                         default:\n@@ -948,10 +956,10 @@ public void queryPessimisticReadDbSQL(EntityManager em) {\n                             //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(int) 2122202]\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ?  [params=(int) 2122202]\n                             // SELECT t0.version FROM LSE1xmLfJTEgr t0 WHERE t0.id = ?  [params=(int) 2112201]\n-                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock,\n+                            assertLockTestSQLs(Select + NoJoin + Any + tableLfName + Any + NoJoin + Where + DB2Lock,\n                                     Select + joinTables + Where + NoDB2Lock,\n-                                    Select + tableRtName + Where + DB2Lock,\n-                                    Select + tableRtName + Where + DB2Lock);\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + DB2Lock,\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + DB2Lock);\n                             break;\n                         case oracle:    // TODO: if jpa2, DO NOT lock LSE1xmRT using \"FOR UPDATE OF col\"\n                             // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfJTEgr t0 WHERE (t0.firstName LIKE ?) \n@@ -964,8 +972,8 @@ public void queryPessimisticReadDbSQL(EntityManager em) {\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2122201]\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2122202]\n                             // SELECT t0.version FROM LSE1xmLfJTEgr t0 WHERE t0.id = ? [params=(int) 2112201]\n-                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate,\n-                                    Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + NoJoin + tableLfName + NoJoin + Where + ForUpdate,\n+                                    Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + ForUpdate);\n                             break;\n                         case derby:     //TODO: **Non-atomic lock. If jpa2, DO NOT lock LSE1xmRt, \n@@ -987,9 +995,9 @@ public void queryPessimisticReadDbSQL(EntityManager em) {\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2122201]\n                             // SELECT t0.version FROM LSE1xmLfJTEgr t0 WHERE t0.id = ? [params=(int) 2112201]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + tableLfName + Where + ForUpdate,\n-                                    Select + tableRtName + Where + ForUpdate,\n-                                    Select + tableRtName + Where + ForUpdate\n+                                    Select + NoJoin + tableLfName + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + tableRtName + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + tableRtName + NoJoin + Where + ForUpdate\n                                     );\n                             break;\n                         default:\n@@ -1011,7 +1019,7 @@ public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n                             //      FROM LSE1xmLfJTEgr t0, LSE1xmLfJTEgr_LSE1xmRt t1, LSE1xmRt t2 \n                             //      WHERE t0.id = ? AND t0.id = t1.LSE1XMLFJTEGR_ID(+) AND t1.UNIRIGHT_ID = t2.id(+) \n                             //      [params=(int) 2112202]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n                             break;\n                         case derby:\n@@ -1046,10 +1054,10 @@ public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n                             //      FOR READ ONLY WITH RS USE AND KEEP UPDATE LOCKS [params=(int) 2122202]\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ?  [params=(int) 2122202]\n                             // SELECT t0.version FROM LSE1xmLfJTEgr t0 WHERE t0.id = ?  [params=(int) 2112201]\n-                            assertLockTestSQLs(Select + tableLfName + Where + DB2Lock,\n+                            assertLockTestSQLs(Select + NoJoin + Any + tableLfName + Any + NoJoin + Where + DB2Lock,\n                                     Select + joinTables + Where + NoDB2Lock,\n-                                    Select + tableRtName + Where + DB2Lock,\n-                                    Select + tableRtName + Where + DB2Lock);\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + DB2Lock,\n+                                    Select + NoJoin + Any + tableRtName + Any + NoJoin + Where + DB2Lock);\n                             break;\n                         case oracle:    // TODO: if jpa2, DO NOT lock LSE1xmRT using \"FOR UPDATE OF col\"\n                             // SELECT t0.id, t0.version, t0.firstName FROM LSE1xmLfJTEgr t0 WHERE (t0.firstName LIKE ?) \n@@ -1062,8 +1070,8 @@ public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2122201]\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2122202]\n                             // SELECT t0.version FROM LSE1xmLfJTEgr t0 WHERE t0.id = ? [params=(int) 2112201]\n-                            assertLockTestSQLs(Select + tableLfName + Where + ForUpdate,\n-                                    Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + NoJoin + tableLfName + NoJoin + Where + ForUpdate,\n+                                    Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + ForUpdate);\n                             break;\n                         case derby:     //TODO: **Non-atomic lock. If jpa2, DO NOT lock LSE1xmRt, \n@@ -1085,9 +1093,9 @@ public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n                             // SELECT t0.version FROM LSE1xmRt t0 WHERE t0.id = ? [params=(int) 2122201]\n                             // SELECT t0.version FROM LSE1xmLfJTEgr t0 WHERE t0.id = ? [params=(int) 2112201]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + tableLfName + Where + ForUpdate,\n-                                    Select + tableRtName + Where + ForUpdate,\n-                                    Select + tableRtName + Where + ForUpdate\n+                                    Select + tableLfName + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + tableRtName + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + tableRtName + NoJoin + Where + ForUpdate\n                                     );\n                             break;\n                         default:\n@@ -1109,7 +1117,7 @@ public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n                             //      FROM LSE1xmLfJTEgr t0, LSE1xmLfJTEgr_LSE1xmRt t1, LSE1xmRt t2 \n                             //      WHERE t0.id = ? AND t0.id = t1.LSE1XMLFJTEGR_ID(+) AND t1.UNIRIGHT_ID = t2.id(+) \n                             //      [params=(int) 2112202]\n-                            assertLockTestSQLs(Select + tableLfName + \".*\" + tableJTName + \".*\" + tableRtName + Where\n+                            assertLockTestSQLs(Select + tableLfName + Any + tableJTName + Any + tableRtName + Where\n                                     + \"\\\\(\\\\+\\\\).*\" + NoForUpdate);\n                             break;\n                         case derby:"},{"sha":"c4a75c2f8dd29cac0caf869f825f1a6dacc2d959","filename":"openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/TestBasicLockScope.java","status":"modified","additions":48,"deletions":32,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/ea6499afc01087cfa83879506fdc2ca49ac39ad0/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/TestBasicLockScope.java","raw_url":"https://github.com/apache/openjpa/raw/ea6499afc01087cfa83879506fdc2ca49ac39ad0/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/TestBasicLockScope.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-locking/src/test/java/org/apache/openjpa/persistence/lock/extended/TestBasicLockScope.java?ref=ea6499afc01087cfa83879506fdc2ca49ac39ad0","patch":"@@ -32,6 +32,14 @@\n public class TestBasicLockScope extends LockScopeTestCase {\n \n     public void setUp() {\n+        setSupportedDatabases(\n+                org.apache.openjpa.jdbc.sql.DerbyDictionary.class,\n+                org.apache.openjpa.jdbc.sql.OracleDictionary.class,\n+                org.apache.openjpa.jdbc.sql.DB2Dictionary.class);\n+        if (isTestsDisabled()) {\n+            return;\n+        }\n+\n         setUp(LSEBase.class\n             , LSESecTbl.class\n             , LSESngTblCon.class\n@@ -269,7 +277,7 @@ public void findNoLockDbSQL(EntityManager em) {\n                         case oracle:\n                             // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0, LSESecTblDtl t1 \n                             //      WHERE t0.id = ? AND t0.id = t1.LSESECTBL_ID [params=(int) 100]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + NoForUpdate);\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + NoForUpdate);\n                             break;\n                         case derby:\n                             // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0\n@@ -294,19 +302,21 @@ public void findPessimisticForcIncDbSQL(EntityManager em) {\n                             // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0, LSESecTblDtl t1 \n                             //      WHERE t0.id = ? AND t0.id = t1.LSESECTBL_ID FOR UPDATE [params=(int) 101]\n                             // SELECT t0.version FROM LSESecTbl t0 WHERE t0.id = ? FOR UPDATE [params=(int) 101]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + ForUpdate);\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + ForUpdate);\n                             break;\n-                        case derby:     //TODO: **Non-atomic lock, SecTblDtl NOT locked *********\n+                        case derby:\n                             // The database is unable to lock this query.  Each object matching the query will be \n                             //  locked individually after it is loaded; however, it is technically possible that\n                             //  another transaction could modify the data before the lock is obtained.\n                             // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0\n                             //      INNER JOIN LSESecTblDtl t1 ON t0.id = t1.LSESECTBL_ID WHERE t0.id = ?\n                             //      [params=(int) 101]\n                             // SELECT t0.id FROM LSESecTbl t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 101]\n+                            // SELECT t0.id FROM LSESecTblDtl t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 101]\n                             // SELECT t0.version FROM LSESecTbl t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 101]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + table1Name + \".*\" + Where + ForUpdate);\n+                                    Select + NoJoin + Any + table1Name + Any + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + Any + table2Name + Any + NoJoin + Where + ForUpdate);\n                             break;\n                         default:\n                             assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n@@ -328,19 +338,21 @@ public void queryPessimisticReadDbSQL(EntityManager em) {\n                             //      WHERE (t0.firstName LIKE ?) AND t0.id = t1.LSESECTBL_ID FOR UPDATE \n                             //      [params=(String) firstName%100]\n                             // SELECT t0.version FROM LSESecTbl t0 WHERE t0.id = ? [params=(int) 100]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + ForUpdate);\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + ForUpdate);\n                             break;\n-                        case derby:     //TODO: **Non-atomic lock, SecTblDtl NOT locked *********\n+                        case derby:\n                             // The database is unable to lock this query.  Each object matching the query will be \n                             //  locked individually after it is loaded; however, it is technically possible that\n                             //  another transaction could modify the data before the lock is obtained.\n                             // SELECT t0.id, t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0\n                             //      INNER JOIN LSESecTblDtl t1 ON t0.id = t1.LSESECTBL_ID \n                             //      WHERE (t0.firstName LIKE ? ESCAPE '\\') [params=(String) firstName%100]\n                             // SELECT t0.id FROM LSESecTbl t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 100]\n+                            // SELECT t0.id FROM LSESecTblDtl t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 100]\n                             // SELECT t0.version FROM LSESecTbl t0 WHERE t0.id = ? [params=(int) 100]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + table1Name + \".*\" + Where + ForUpdate);\n+                                    Select + NoJoin + Any + table1Name + Any + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + Any + table2Name + Any + NoJoin + Where + ForUpdate);\n                             break;\n                         default:\n                             assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n@@ -358,7 +370,7 @@ public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n                         case oracle:\n                             // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0, LSESecTblDtl t1 \n                             //      WHERE t0.id = ? AND t0.id = t1.LSESECTBL_ID [params=(int) 101]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + NoForUpdate);\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + NoForUpdate);\n                             break;\n                         case derby:\n                             // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0\n@@ -384,19 +396,21 @@ public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n                             //      WHERE (t0.firstName LIKE ?) AND t0.id = t1.LSESECTBL_ID FOR UPDATE \n                             //      [params=(String) firstName%100]\n                             // SELECT t0.version FROM LSESecTbl t0 WHERE t0.id = ? [params=(int) 100]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + ForUpdate);\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + ForUpdate);\n                             break;\n-                        case derby:     //TODO: **Non-atomic lock, SecTblDtl NOT locked *********\n+                        case derby:\n                             // The database is unable to lock this query.  Each object matching the query will be \n                             //  locked individually after it is loaded; however, it is technically possible that\n                             //  another transaction could modify the data before the lock is obtained.\n                             // SELECT t0.id, t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0\n                             //      INNER JOIN LSESecTblDtl t1 ON t0.id = t1.LSESECTBL_ID\n                             //      WHERE (t0.firstName LIKE ? ESCAPE '\\') [params=(String) firstName%100]\n                             // SELECT t0.id FROM LSESecTbl t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 100]\n+                            // SELECT t0.id FROM LSESecTblDtl t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 100]\n                             // SELECT t0.version FROM LSESecTbl t0 WHERE t0.id = ? [params=(int) 100]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + table1Name + \".*\" + Where + ForUpdate);\n+                                    Select + NoJoin + Any + table1Name + Any + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + Any + table2Name + Any + NoJoin + Where + ForUpdate);\n                             break;\n                         default:\n                             assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n@@ -414,7 +428,7 @@ public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n                         case oracle:\n                             // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0, LSESecTblDtl t1 \n                             //      WHERE t0.id = ? AND t0.id = t1.LSESECTBL_ID [params=(int) 101]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + NoForUpdate);\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + NoForUpdate);\n                             break;\n                         case derby:\n                             // SELECT t0.version, t0.firstName, t1.lastName FROM LSESecTbl t0\n@@ -659,7 +673,7 @@ public void findNoLockDbSQL(EntityManager em) {\n                         case oracle:\n                             // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0, LSEJoinAbs t1 \n                             //      WHERE t0.id = ? AND t0.id = t1.id [params=(int) 400]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + NoForUpdate);\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + NoForUpdate);\n                             break;\n                         case derby:\n                             // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0\n@@ -683,7 +697,7 @@ public void findPessimisticForcIncDbSQL(EntityManager em) {\n                             // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0, LSEJoinAbs t1 \n                             //      WHERE t0.id = ? AND t0.id = t1.id FOR UPDATE [params=(int) 401]\n                             // SELECT t0.version FROM LSEJoinAbs t0 WHERE t0.id = ? FOR UPDATE [params=(int) 401]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + ForUpdate);\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + ForUpdate);\n                             break;\n                         case derby:     //TODO: **Non-atomic lock, LSEJoinCon NOT locked *********\n                             // The database is unable to lock this query.  Each object matching the query will be \n@@ -695,7 +709,8 @@ public void findPessimisticForcIncDbSQL(EntityManager em) {\n                             // SELECT t0.version FROM LSEJoinAbs t0 WHERE t0.id = ? FOR UPDATE WITH RR\n                             //      [params=(int) 401]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + table2Name + \".*\" + Where + ForUpdate);\n+                                    // Select + NoJoin + table1Name + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + Any + table2Name + Any + NoJoin + Where + ForUpdate);\n                             break;\n                         default:\n                             assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n@@ -717,7 +732,7 @@ public void queryPessimisticReadDbSQL(EntityManager em) {\n                             //      FROM LSEJoinCon t0, LSEJoinAbs t1 WHERE (t1.firstName LIKE ?) AND t0.id = t1.id \n                             //      FOR UPDATE [params=(String) firstName%400]\n                             // SELECT t0.version FROM LSEJoinAbs t0 WHERE t0.id = ? [params=(int) 400]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + ForUpdate);\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + ForUpdate);\n                             break;\n                         case derby:     //TODO: **Non-atomic lock, LSEJoinCon NOT locked *********\n                             // The database is unable to lock this query.  Each object matching the query will be \n@@ -729,7 +744,8 @@ public void queryPessimisticReadDbSQL(EntityManager em) {\n                             // SELECT t0.id FROM LSEJoinAbs t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 400]\n                             // SELECT t0.version FROM LSEJoinAbs t0 WHERE t0.id = ? [params=(int) 400]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + table2Name + \".*\" + Where + ForUpdate);\n+                                    // Select + NoJoin + table1Name + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + Any + table2Name + Any + NoJoin + Where + ForUpdate);\n                             break;\n                         default:\n                             assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n@@ -747,7 +763,7 @@ public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n                         case oracle:\n                             // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0, LSEJoinAbs t1 \n                             //      WHERE t0.id = ? AND t0.id = t1.id [params=(int) 401]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + NoForUpdate);\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + NoForUpdate);\n                             break;\n                         case derby:\n                             // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0\n@@ -772,7 +788,7 @@ public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n                             //      FROM LSEJoinCon t0, LSEJoinAbs t1 WHERE (t1.firstName LIKE ?) AND t0.id = t1.id \n                             //      FOR UPDATE [params=(String) firstName%400]\n                             // SELECT t0.version FROM LSEJoinAbs t0 WHERE t0.id = ? [params=(int) 400]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + ForUpdate);\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + ForUpdate);\n                             break;\n                         case derby:     //TODO: **Non-atomic lock, LSEJoinCon NOT locked *********\n                             // The database is unable to lock this query.  Each object matching the query will be \n@@ -784,7 +800,8 @@ public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n                             // SELECT t0.id FROM LSEJoinAbs t0 WHERE t0.id = ? FOR UPDATE WITH RR [params=(int) 400]\n                             // SELECT t0.version FROM LSEJoinAbs t0 WHERE t0.id = ? [params=(int) 400]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + table2Name + \".*\" + Where + ForUpdate);\n+                                    // Select + NoJoin + table1Name + NoJoin + Where + ForUpdate,\n+                                    Select + NoJoin + Any + table2Name + Any + NoJoin + Where + ForUpdate);\n                             break;\n                         default:\n                             assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n@@ -802,7 +819,7 @@ public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n                         case oracle:\n                             // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0, LSEJoinAbs t1 \n                             //      WHERE t0.id = ? AND t0.id = t1.id [params=(int) 401]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + NoForUpdate);\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + NoForUpdate);\n                             break;\n                         case derby:\n                             // SELECT t0.id, t1.version, t1.firstName, t0.lastName FROM LSEJoinCon t0\n@@ -1036,7 +1053,7 @@ public void findNoLockDbSQL(EntityManager em) {\n                             // SELECT t0.version, t0.firstName, t1.LSEELECOLEGR_ID, t1.element \n                             //      FROM LSEEleColEgr t0, LSEEleColEgr_collection t1 \n                             //      WHERE t0.id = ? AND t0.id = t1.LSEELECOLEGR_ID(+) [params=(int) 600]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + \"\\\\(\\\\+\\\\).*\"\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + \"\\\\(\\\\+\\\\).*\"\n                                     + NoForUpdate);\n                             break;\n                         case derby:\n@@ -1063,7 +1080,7 @@ public void findPessimisticForcIncDbSQL(EntityManager em) {\n                             //      FROM LSEEleColEgr t0, LSEEleColEgr_collection t1 \n                             //      WHERE t0.id = ? AND t0.id = t1.LSEELECOLEGR_ID(+) FOR UPDATE [params=(int) 601]\n                             // SELECT t0.version FROM LSEEleColEgr t0 WHERE t0.id = ? FOR UPDATE [params=(int) 601]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + \"\\\\(\\\\+\\\\).*\"\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + \"\\\\(\\\\+\\\\).*\"\n                                     + NoForUpdate);\n                             break;\n                         case derby:     // **Non-atomic lock, No need to lock LSEEleColEgr_collection *********\n@@ -1079,7 +1096,7 @@ public void findPessimisticForcIncDbSQL(EntityManager em) {\n                             // SELECT t0.version FROM LSEEleColEgr t0 WHERE t0.id = ? FOR UPDATE WITH RR\n                             //      [params=(int) 601]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate, \n-                                    Select + table1Name + \".*\" + Where + ForUpdate);\n+                                    Select + table1Name + Where + ForUpdate);\n                             break;\n                         default:\n                             assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n@@ -1109,7 +1126,7 @@ public void queryPessimisticReadDbSQL(EntityManager em) {\n                             //      WHERE (t0.firstName LIKE ?) AND t0.id = t1.LSEELECOLEGR_ID ORDER BY t0.id ASC \n                             //      FOR UPDATE [params=(String) firstName%600]\n                             // SELECT t0.version FROM LSEEleColEgr t0 WHERE t0.id = ? [params=(int) 600]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + ForUpdate);\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + ForUpdate);\n                             break;\n                         case derby:     //**Non-atomic lock, No need to lock LSEEleColEgr_Collection *********\n                             // The database is unable to lock this query.  Each object matching the query will be \n@@ -1122,7 +1139,7 @@ public void queryPessimisticReadDbSQL(EntityManager em) {\n                             //      ORDER BY t0.id ASC [params=(String) firstName%600]\n                             // SELECT t0.version FROM LSEEleColEgr t0 WHERE t0.id = ? [params=(int) 600]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate,\n-                                    Select + table1Name + \".*\" + Where + ForUpdate);\n+                                    Select + table1Name + Where + ForUpdate);\n                             break;\n                         default:\n                             assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n@@ -1135,14 +1152,13 @@ public void findNoLockAfterQueryPessimisticReadDbSQL(EntityManager em) {\n                             // SELECT t0.version, t0.firstName, t1.LSEELECOLEGR_ID, t1.element FROM LSEEleColEgr t0\n                             //      LEFT OUTER JOIN LSEEleColEgr_collection t1 ON t0.id = t1.LSEELECOLEGR_ID\n                             //      WHERE t0.id = ?  [params=(int) 601]\n-                            assertLockTestSQLs(Select + \"LSEEleColEgr.*\" + Where + DB2Lock,\n-                                    Select + joinTables + Where + NoDB2Lock);\n+                            assertLockTestSQLs(Select + joinTables + Where + NoDB2Lock);\n                             break;\n                         case oracle:\n                             // SELECT t0.version, t0.firstName, t1.LSEELECOLEGR_ID, t1.element \n                             //      FROM LSEEleColEgr t0, LSEEleColEgr_collection t1 \n                             //      WHERE t0.id = ? AND t0.id = t1.LSEELECOLEGR_ID(+) [params=(int) 601]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + \"\\\\(\\\\+\\\\).*\"\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + \"\\\\(\\\\+\\\\).*\"\n                                     + NoForUpdate);\n                             break;\n                         case derby:\n@@ -1177,7 +1193,7 @@ public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n                             //      WHERE (t0.firstName LIKE ?) AND t0.id = t1.LSEELECOLEGR_ID ORDER BY t0.id ASC \n                             //      FOR UPDATE [params=(String) firstName%600]\n                             // SELECT t0.version FROM LSEEleColEgr t0 WHERE t0.id = ? [params=(int) 600]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + ForUpdate);\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + ForUpdate);\n                             break;\n                         case derby:     // **Non-atomic lock, No need to lock LSEEleColEgr_collection *********   \n                             // The database is unable to lock this query.  Each object matching the query will be \n@@ -1190,7 +1206,7 @@ public void namedQueryPessimisticWriteDbSql(EntityManager em) {\n                             //      ORDER BY t0.id ASC [params=(String) firstName%600]\n                             // SELECT t0.version FROM LSEEleColEgr t0 WHERE t0.id = ? [params=(int) 600]\n                             assertLockTestSQLs(Select + joinTables + Where + NoForUpdate, \n-                                    Select + table1Name + \".*\" + Where + ForUpdate);\n+                                    Select + table1Name + Where + ForUpdate);\n                             break;\n                         default:\n                             assertLockTestSQLs(Select + joinTables + Where + ForUpdate);\n@@ -1209,7 +1225,7 @@ public void findNoLockAfterNamedQueryPessimisticWriteDbSql(EntityManager em) {\n                             // SELECT t0.version, t0.firstName, t1.LSEELECOLEGR_ID, t1.element \n                             //      FROM LSEEleColEgr t0, LSEEleColEgr_collection t1 \n                             //      WHERE t0.id = ? AND t0.id = t1.LSEELECOLEGR_ID(+) [params=(int) 601]\n-                            assertLockTestSQLs(Select + table1Name + \".*\" + table2Name + Where + \"\\\\(\\\\+\\\\).*\"\n+                            assertLockTestSQLs(Select + table1Name + Any + table2Name + Where + \"\\\\(\\\\+\\\\).*\"\n                                     + NoForUpdate);\n                             break;\n                         case derby:"}]}

