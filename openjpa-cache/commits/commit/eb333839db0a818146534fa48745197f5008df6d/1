{"sha":"eb333839db0a818146534fa48745197f5008df6d","node_id":"MDY6Q29tbWl0MjA2MzY0OmViMzMzODM5ZGIwYTgxODE0NjUzNGZhNDg3NDUxOTdmNTAwOGRmNmQ=","commit":{"author":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-08-03T19:16:47Z"},"committer":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-08-03T19:16:47Z"},"message":"More work on type promotion and casting in queries.  Also, make sure DFG is\nin active fetch groups before testing it for post-load callbacks.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@428484 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"1dfea89e6b7b6c46df1e7900d70fde9708f62e72","url":"https://api.github.com/repos/apache/openjpa/git/trees/1dfea89e6b7b6c46df1e7900d70fde9708f62e72"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/eb333839db0a818146534fa48745197f5008df6d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/eb333839db0a818146534fa48745197f5008df6d","html_url":"https://github.com/apache/openjpa/commit/eb333839db0a818146534fa48745197f5008df6d","comments_url":"https://api.github.com/repos/apache/openjpa/commits/eb333839db0a818146534fa48745197f5008df6d/comments","author":null,"committer":null,"parents":[{"sha":"a6b57c2e9cdfd3524d507ef220e85a1781acc4f2","url":"https://api.github.com/repos/apache/openjpa/commits/a6b57c2e9cdfd3524d507ef220e85a1781acc4f2","html_url":"https://github.com/apache/openjpa/commit/a6b57c2e9cdfd3524d507ef220e85a1781acc4f2"}],"stats":{"total":161,"additions":95,"deletions":66},"files":[{"sha":"75a809212c1a8a6c808fded7cb36e693cb2dfe3c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","status":"modified","additions":12,"deletions":8,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/eb333839db0a818146534fa48745197f5008df6d/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/eb333839db0a818146534fa48745197f5008df6d/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java?ref=eb333839db0a818146534fa48745197f5008df6d","patch":"@@ -2293,11 +2293,13 @@ public void mathFunction(SQLBuffer buf, String op, FilterValue lhs,\n         if (requiresCastForMathFunctions && (lc != rc\n             || (lhs.isConstant() && rhs.isConstant()))) {\n             Class c = Filters.promote(lhs.getType(), rhs.getType());\n-            castlhs = (lhs.isConstant() && rhs.isConstant())\n-                || Filters.wrap(lhs.getType()) != c;\n-            castrhs = (lhs.isConstant() && rhs.isConstant())\n-                || Filters.wrap(rhs.getType()) != c;\n             type = getJDBCType(JavaTypes.getTypeCode(c), false);\n+            if (type != Types.VARBINARY && type != Types.BLOB) {\n+                castlhs = (lhs.isConstant() && rhs.isConstant())\n+                    || Filters.wrap(lhs.getType()) != c;\n+                castrhs = (lhs.isConstant() && rhs.isConstant())\n+                    || Filters.wrap(rhs.getType()) != c;\n+            }\n         }\n \n         boolean mod = \"MOD\".equals(op);\n@@ -2345,11 +2347,13 @@ public void comparison(SQLBuffer buf, String op, FilterValue lhs,\n         if (requiresCastForComparisons && (lc != rc\n             || (lhs.isConstant() && rhs.isConstant()))) {\n             Class c = Filters.promote(lhs.getType(), rhs.getType());\n-            castlhs = (lhs.isConstant() && rhs.isConstant())\n-                || Filters.wrap(lhs.getType()) != c;\n-            castrhs = (lhs.isConstant() && rhs.isConstant())\n-                || Filters.wrap(rhs.getType()) != c;\n             type = getJDBCType(JavaTypes.getTypeCode(c), false);\n+            if (type != Types.VARBINARY && type != Types.BLOB) {\n+                castlhs = (lhs.isConstant() && rhs.isConstant())\n+                    || Filters.wrap(lhs.getType()) != c;\n+                castrhs = (lhs.isConstant() && rhs.isConstant())\n+                    || Filters.wrap(rhs.getType()) != c;\n+            }\n         }\n \n         if (castlhs)"},{"sha":"46bfadb20a7a7d263f09bffa1a0d8ef54bbf76f8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","status":"modified","additions":66,"deletions":41,"changes":107,"blob_url":"https://github.com/apache/openjpa/blob/eb333839db0a818146534fa48745197f5008df6d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","raw_url":"https://github.com/apache/openjpa/raw/eb333839db0a818146534fa48745197f5008df6d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java?ref=eb333839db0a818146534fa48745197f5008df6d","patch":"@@ -29,6 +29,7 @@\n import org.apache.openjpa.kernel.exps.FilterListener;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.util.ImplHelper;\n import org.apache.openjpa.util.InternalException;\n import org.apache.openjpa.util.UserException;\n@@ -106,78 +107,102 @@ public static Class unwrap(Class c) {\n     }\n \n     /**\n-     * Given two numeric types, return type they should both be converted\n-     * to before performing any mathematical operations between them.\n+     * Given two types, return type they should both be converted\n+     * to before performing any operations between them.\n      */\n     public static Class promote(Class c1, Class c2) {\n         if (c1 == c2)\n-            return c1;\n-        if (c1 == Object.class)\n-            return c2;\n-        if (c2 == Object.class)\n-            return c1;\n-\n+            return unwrap(c1);\n         Class w1 = wrap(c1);\n         Class w2 = wrap(c2);\n         if (w1 == w2)\n-            return c1;\n-        c1 = w1;\n-        c2 = w2;\n+            return unwrap(c1);\n \n         // not numbers?\n-        boolean c1Number = Number.class.isAssignableFrom(c1);\n-        boolean c2Number = Number.class.isAssignableFrom(c2);\n-        if (!c1Number || !c2Number) {\n+        boolean w1Number = Number.class.isAssignableFrom(w1);\n+        boolean w2Number = Number.class.isAssignableFrom(w2);\n+        if (!w1Number || !w2Number) {\n             // the only non-numeric promotion we do is string to char,\n             // or from char/string to number\n-            if (!c1Number) {\n-                if (c2Number && (c1 == Character.class || c1 == String.class))\n-                    return (c2 == Byte.class || c2 == Short.class)\n-                        ? Integer.class : c2;\n-                if (!c2Number && c1 == Character.class && c2 == String.class)\n+            if (!w1Number) {\n+                if (w2Number && (w1 == Character.class || w1 == String.class))\n+                    return (w2 == Byte.class || w2 == Short.class)\n+                        ? Integer.class : unwrap(c2);\n+                if (!w2Number && w1 == Character.class && w2 == String.class)\n                     return String.class;\n+                if (w2Number)\n+                    return unwrap(c2);\n             }\n-            if (!c2Number) {\n-                if (c1Number && (c2 == Character.class || c2 == String.class))\n-                    return (c1 == Byte.class || c1 == Short.class)\n-                        ? Integer.class : c1;\n-                if (!c1Number && c2 == Character.class && c1 == String.class)\n+            if (!w2Number) {\n+                if (w1Number && (w2 == Character.class || w2 == String.class))\n+                    return (w1 == Byte.class || w1 == Short.class)\n+                        ? Integer.class : unwrap(c1);\n+                if (!w1Number && w2 == Character.class && w1 == String.class)\n                     return String.class;\n+                if (w1Number)\n+                    return unwrap(c1);\n             }\n \n-            // if neither are numbers and one is a superclass of the\n-            // other, return the least-derived of the two types\n-            if (!c1Number && !c2Number) {\n-                if (c1.isAssignableFrom(c2))\n-                    return c1;\n-                if (c2.isAssignableFrom(c1))\n-                    return c2;\n+            // if neither are numbers, use least-derived of the two.  if neither\n+            // is assignable from the other but one is a standard type, assume\n+            // the other can be converted to that standard type\n+            if (!w1Number && !w2Number) {\n+                if (w1 == Object.class)\n+                    return unwrap(c2);\n+                if (w2 == Object.class)\n+                    return unwrap(c1);\n+                if (w1.isAssignableFrom(w2))\n+                    return unwrap(c1);\n+                if (w2.isAssignableFrom(w1))\n+                    return unwrap(c2);\n+                if (isNonstandardType(w1))\n+                    return (isNonstandardType(w2)) ? Object.class : unwrap(c2);\n+                if (isNonstandardType(w2))\n+                    return (isNonstandardType(w1)) ? Object.class : unwrap(c1);\n             }\n-\n-            return c1;\n+            return Object.class;\n         }\n \n-        if (c1 == BigDecimal.class || c2 == BigDecimal.class)\n+        if (w1 == BigDecimal.class || w2 == BigDecimal.class)\n             return BigDecimal.class;\n-        if (c1 == BigInteger.class) {\n-            if (c2 == Float.class || c2 == Double.class)\n+        if (w1 == BigInteger.class) {\n+            if (w2 == Float.class || w2 == Double.class)\n                 return BigDecimal.class;\n             return BigInteger.class;\n         }\n-        if (c2 == BigInteger.class) {\n-            if (c1 == Float.class || c1 == Double.class)\n+        if (w2 == BigInteger.class) {\n+            if (w1 == Float.class || w1 == Double.class)\n                 return BigDecimal.class;\n             return BigInteger.class;\n         }\n-        if (c1 == Double.class || c2 == Double.class)\n+        if (w1 == Double.class || w2 == Double.class)\n             return double.class;\n-        if (c1 == Float.class || c2 == Float.class)\n+        if (w1 == Float.class || w2 == Float.class)\n             return float.class;\n-        if (c1 == Long.class || c2 == Long.class)\n+        if (w1 == Long.class || w2 == Long.class)\n             return long.class;\n         return int.class;\n     }\n \n+    /**\n+     * Return whether the given type is not a standard persistent type.\n+     */\n+    private static boolean isNonstandardType(Class c) {\n+        switch (JavaTypes.getTypeCode(c))\n+        {\n+        case JavaTypes.ARRAY:\n+        case JavaTypes.COLLECTION:\n+        case JavaTypes.MAP:\n+        case JavaTypes.PC:\n+        case JavaTypes.PC_UNTYPED:\n+        case JavaTypes.OID:\n+        case JavaTypes.OBJECT:\n+            return true;\n+        default:\n+            return false;\n+        }\n+    }\n+\n     /**\n      * Return whether an instance of the first class can be converted to\n      * an instance of the second."},{"sha":"3c74428318c9ce89dad9cd9e3d00196232a1bce2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"modified","additions":17,"deletions":17,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/eb333839db0a818146534fa48745197f5008df6d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/eb333839db0a818146534fa48745197f5008df6d/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=eb333839db0a818146534fa48745197f5008df6d","patch":"@@ -2872,25 +2872,24 @@ private void postLoad(int field, FetchConfiguration fetch) {\n         if (mgr == null || !mgr.hasLoadListeners(getManagedInstance(), _meta))\n             return;\n \n+        if (fetch == null)\n+            fetch = _broker.getFetchConfiguration();\n         // is this field a post-load field?\n         if (field != -1) {\n-            FieldMetaData fmd = _meta.getField (field);\n+            FieldMetaData fmd = _meta.getField(field);\n             if (fmd.isInDefaultFetchGroup() \n-               && postLoad(_meta.getFetchGroup(FetchGroup.NAME_DEFAULT), fetch))\n-               return;\n+                && fetch.hasFetchGroup(FetchGroup.NAME_DEFAULT)\n+                && postLoad(FetchGroup.NAME_DEFAULT, fetch))\n+                return;\n             String[] fgs = fmd.getCustomFetchGroups();\n             for (int i = 0; i < fgs.length; i++)\n-                if (postLoad(_meta.getFetchGroup(fgs[i]), fetch))\n+                if (fetch.hasFetchGroup(fgs[i]) && postLoad(fgs[i], fetch))\n                     return;\n         } else {\n-            if (postLoad(_meta.getFetchGroup(FetchGroup.NAME_DEFAULT), fetch))\n-                return;\n-            \n-            Iterator fgs = fetch.getFetchGroups().iterator();\n-            for (;fgs.hasNext();) {\n-            \tFetchGroup fg = _meta.getFetchGroup(fgs.next().toString());\n-                if (fg != null && postLoad(fg, fetch))\n-                    return; \n+            for (Iterator itr = fetch.getFetchGroups().iterator(); \n+                itr.hasNext();) {\n+                if (postLoad((String) itr.next(), fetch))\n+                    return;\n             }\n         }\n     }\n@@ -2899,14 +2898,15 @@ private void postLoad(int field, FetchConfiguration fetch) {\n      * Perform post-load actions if the given fetch group is a post-load group\n      * and is fully loaded.\n      */\n-    private boolean postLoad(FetchGroup fg, FetchConfiguration fetch) {\n-        if (!fg.isPostLoad())\n+    private boolean postLoad(String fgName, FetchConfiguration fetch) {\n+        FetchGroup fg = _meta.getFetchGroup(fgName);\n+        if (fg == null || !fg.isPostLoad())\n             return false;\n+\n         FieldMetaData[] fmds = _meta.getFields();\n         for (int i = 0; i < fmds.length; i++)\n-        \tif (fmds[i].isInFetchGroup(fg.getName()))\n-        \t\tif (!_loaded.get(i))\n-        \t\t\treturn false;\n+            if (!_loaded.get(i) && fmds[i].isInFetchGroup(fgName))\n+                return false;\n \n         _flags |= FLAG_LOADED;\n         _broker.fireLifecycleEvent(getManagedInstance(), fetch, _meta, "}]}

