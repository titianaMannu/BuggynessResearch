{"sha":"eb96e89f4d55d240fdfcb3ea236492f84312a8af","node_id":"MDY6Q29tbWl0MjA2MzY0OmViOTZlODlmNGQ1NWQyNDBmZGZjYjNlYTIzNjQ5MmY4NDMxMmE4YWY=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-08-01T05:03:08Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2006-08-01T05:03:08Z"},"message":"Brett Porter's patch to resolve OPENJPA-3\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@427444 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"2788b279c99a498191cba7ef93ec542f33c47d70","url":"https://api.github.com/repos/apache/openjpa/git/trees/2788b279c99a498191cba7ef93ec542f33c47d70"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/eb96e89f4d55d240fdfcb3ea236492f84312a8af","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/eb96e89f4d55d240fdfcb3ea236492f84312a8af","html_url":"https://github.com/apache/openjpa/commit/eb96e89f4d55d240fdfcb3ea236492f84312a8af","comments_url":"https://api.github.com/repos/apache/openjpa/commits/eb96e89f4d55d240fdfcb3ea236492f84312a8af/comments","author":null,"committer":null,"parents":[{"sha":"803e15990dbd28a5ee35523d82c24d2b5aaf3dff","url":"https://api.github.com/repos/apache/openjpa/commits/803e15990dbd28a5ee35523d82c24d2b5aaf3dff","html_url":"https://github.com/apache/openjpa/commit/803e15990dbd28a5ee35523d82c24d2b5aaf3dff"}],"stats":{"total":772,"additions":394,"deletions":378},"files":[{"sha":"ac9574b7da708996ea767e5ea129130da29d761b","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","status":"modified","additions":394,"deletions":378,"changes":772,"blob_url":"https://github.com/apache/openjpa/blob/eb96e89f4d55d240fdfcb3ea236492f84312a8af/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","raw_url":"https://github.com/apache/openjpa/raw/eb96e89f4d55d240fdfcb3ea236492f84312a8af/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java?ref=eb96e89f4d55d240fdfcb3ea236492f84312a8af","patch":"@@ -1,378 +1,394 @@\n-/*\n- * Copyright 2006 The Apache Software Foundation.\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *  http://www.apache.org/licenses/LICENSE-2.0\n- *  Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.openjpa.lib.util;\n-\n-import java.io.BufferedInputStream;\n-import java.io.BufferedReader;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.StringBufferInputStream;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Properties;\n-\n-import junit.framework.TestCase;\n-import org.apache.openjpa.lib.util.FormatPreservingProperties.DuplicateKeyException;\n-\n-// things to test:\n-// - delimiters in keys\n-// - escape chars, including \\:, \\= in files(as generated by Properties)\n-// - unicode\n-// - non-String keys / vals\n-// - list() method behavior\n-\n-public class TestPropertiesParser extends TestCase {\n-\n-    public void testSimpleProperties() throws IOException {\n-        StringBuffer buf = new StringBuffer();\n-        buf.append(\"key: value\\n\");\n-        buf.append(\"key2: value2\"); // no EOL -- this is intentional\n-        Properties p = toProperties(buf.toString());\n-        assertProperties(new String[][]{\n-            { \"key\", \"value\" }, { \"key2\", \"value2\" } }, p);\n-    }\n-\n-    public void testComments() throws IOException {\n-        StringBuffer buf = new StringBuffer();\n-        buf.append(\"# this is a comment\\n\");\n-        buf.append(\" # another one, with leading whitespace\t\\n\");\n-        buf.append(\" \t# \tand more with interesting whitespace\t\\n\");\n-        buf.append(\"! and with a ! delimiter\\n\");\n-        buf.append(\"! and with escape \\t chars\\n\");\n-        buf.append(\"#and a comment with no whitespace\\n\");\n-        Properties p = toProperties(buf.toString());\n-        assertEquals(0, p.size());\n-    }\n-\n-    public void testMixedContent() throws IOException {\n-        StringBuffer buf = new StringBuffer();\n-        buf.append(\"# this is a comment\\n\");\n-        buf.append(\" # another one, with leading whitespace\t\\n\");\n-        buf.append(\"foo: bar#baz\\n\");\n-        buf.append(\"! and with a ! delimiter\\n\");\n-        buf.append(\"! and with escape \\t chars\\n\");\n-        Properties p = toProperties(buf.toString());\n-        assertProperties(new String[][]{ { \"foo\", \"bar#baz\" } }, p);\n-    }\n-\n-    public void testMultiLineInput() throws IOException {\n-        String s = \"foo: bar\\\\\\n\" + \"more line goes here\";\n-        Properties p = toProperties(s);\n-        assertProperties(\n-            new String[][]{ { \"foo\", \"barmore line goes here\" } }, p);\n-    }\n-\n-    public void testEmptyLines() throws IOException {\n-        Properties p = toProperties(\"\\nfoo: bar\\n\\nbaz: val\");\n-        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\n-            p);\n-    }\n-\n-    public void testAddProperties() throws IOException {\n-        // intentionally left out the trailing end line\n-        String s = \"foo: bar\\nbaz: val\";\n-        Properties p = toProperties(s);\n-        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\n-            p);\n-\n-        p.put(\"new-key\", \"val1\");\n-        p.put(\"new-key-2\", \"val2\");\n-        p.put(\"another-new-key\", \"val3\");\n-        assertRoundTrip(s + \"\\nnew-key: val1\\nnew-key-2: val2\\n\" +\n-            \"another-new-key: val3\\n\", p);\n-    }\n-\n-    public void testAddAndMutateProperties() throws IOException {\n-        // intentionally left out the trailing end line\n-        Properties p = toProperties(\"foo: bar\\nbaz: val\");\n-        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\n-            p);\n-\n-        p.put(\"new-key\", \"new value\");\n-        p.put(\"foo\", \"barbar\");\n-        assertRoundTrip(\"foo: barbar\\nbaz: val\\nnew-key: new value\\n\", p);\n-    }\n-\n-    public void testEscapedEquals() throws IOException {\n-        Properties p = toProperties(\"foo=bar\\\\=WARN,baz\\\\=TRACE\");\n-        assertProperties(new String[][]{ { \"foo\", \"bar=WARN,baz=TRACE\" } }, p);\n-    }\n-\n-    public void testLineTypes() throws IOException {\n-        StringBuffer buf = new StringBuffer();\n-        buf.append(\"   !comment\\n \\t  \\nname = no\\n    \"\n-            + \"#morec\\tomm\\\\\\nents\\n\\n  dog=no\\\\cat   \\nburps    \"\n-            + \":\\ntest=\\ndate today\\n\\n\\nlong\\\\\\n   value=tryin \\\\\\n \"\n-            + \"gto\\n4:vier\\nvier     :4\");\n-        Properties p = toProperties(buf.toString());\n-        assertProperties(new String[][]{\n-            { \"name\", \"no\" }, { \"ents\", \"\" }, { \"dog\", \"nocat   \" },\n-            { \"burps\", \"\" }, { \"test\", \"\" }, { \"date\", \"today\" },\n-            { \"longvalue\", \"tryin gto\" }, { \"4\", \"vier\" }, { \"vier\", \"4\" },\n-        }, p);\n-    }\n-\n-    public void testSpecialChars() throws Throwable {\n-        testSpecialChars(false, true);\n-        testSpecialChars(true, true);\n-        testSpecialChars(false, false);\n-        testSpecialChars(true, false);\n-    }\n-\n-    /**\n-     * Test that special characters work.\n-     *\n-     * @param formattingProps if true, test against the\n-     * FormatPreservingProperties, otherwise test\n-     * against a normal Properties instance(for validation of the test case).\n-     * @param value whether to test the key or the value\n-     */\n-    public void testSpecialChars(boolean formattingProps, boolean value)\n-        throws Throwable {\n-        List valueList = new ArrayList(Arrays.asList(new String[]{\n-            \"xxyy\", \"xx\\\\yy\", \"xx\\nyy\", \"xx\\\\nyy\", \"xx\\tyy\", \"xx\\\\tyy\",\n-            \"xx\\ryy\", \"xx\\\\ryy\", \"xx\\fyy\", \"xx\\\\fyy\", \"xx\\r\\n\\\\\\t\\r\\t\\nyy\",\n-            \"xx\\\\r\\n\\\\\\t\\\\r\\t\\\\nyy\",\n-            \"xx\\r\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\t\\r\\t\\nyy\",\n-            \"C:\\\\Program Files\\\\Some Application\\\\OpenJPA\\\\My File.dat\", }));\n-\n-        // also store every individual character\n-        for (char c = 'a'; c < 'Z'; c++) {\n-            valueList.add(new String(new char[]{ c }));\n-            valueList.add(new String(new char[]{ c, '\\\\', c }));\n-            valueList.add(new String(new char[]{ '\\\\', c }));\n-        }\n-\n-        String[] values = (String[]) valueList.toArray(new String[0]);\n-\n-        final String dummy = \"XXX\";\n-\n-        for (int i = 0; i < values.length; i++) {\n-            // test special characters in either keys or values\n-            String val = value ? values[i] : dummy;\n-            String key = value ? dummy : values[i];\n-\n-            Properties p = formattingProps ?\n-                new FormatPreservingProperties() : new Properties();\n-            if (p instanceof FormatPreservingProperties) {\n-                // set these properties so we behave the same way as\n-                // java.util.Properties\n-                ((FormatPreservingProperties) p).setDefaultEntryDelimiter('=');\n-                ((FormatPreservingProperties) p).\n-                    setAddWhitespaceAfterDelimiter(false);\n-            }\n-\n-            p.setProperty(key, val);\n-            ByteArrayOutputStream out = new ByteArrayOutputStream();\n-            p.store(out, null);\n-\n-            Properties copy = new Properties();\n-            copy.setProperty(key, val);\n-            ByteArrayOutputStream copyOut = new ByteArrayOutputStream();\n-            copy.store(copyOut, null);\n-\n-            p = formattingProps ?\n-                new FormatPreservingProperties() : new Properties();\n-\n-            InputStream in = new BufferedInputStream\n-                (new ByteArrayInputStream(out.toByteArray()));\n-\n-            try {\n-                // make sure that the 2 properties serialized are the same\n-                String copyOutString = stripComments(copyOut.toByteArray());\n-                String outString = stripComments(out.toByteArray());\n-                assertEquals(copyOutString, outString);\n-\n-                p.load(in);\n-\n-                assertNotNull(\"Property \\\"\" + key + \"\\\" was null\",\n-                    p.getProperty(key));\n-                assertEquals(val.trim(), p.getProperty(key).trim());\n-            } catch (Throwable ioe) {\n-                if (!formattingProps)\n-                    throw ioe;\n-\n-                // bug(1211, ioe,\n-                // \"Cannot store backslash in FormatPreservingProperties\");\n-                throw ioe;\n-            }\n-        }\n-    }\n-\n-    static Character randomChar() {\n-        char [] TEST_CHAR_ARRAY = new char []{\n-            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\n-            'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\n-            's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '1',\n-            '2', '3', '4', '5', '6', '7', '8', '9' };\n-\n-        return new Character(TEST_CHAR_ARRAY[\n-            (int) (Math.random() * TEST_CHAR_ARRAY.length)]);\n-    }\n-\n-    static String randomString(int len) {\n-        StringBuffer buf = new StringBuffer();\n-        for (int i = 0; i < (int) (Math.random() * len) + 1; i++)\n-            buf.append(randomChar());\n-        return buf.toString();\n-    }\n-\n-    public void testEquivalentStore() throws IOException {\n-        Properties p1 = new Properties();\n-        FormatPreservingProperties p2 = new FormatPreservingProperties();\n-\n-        ((FormatPreservingProperties) p2).setDefaultEntryDelimiter('=');\n-        ((FormatPreservingProperties) p2).setAddWhitespaceAfterDelimiter(false);\n-\n-        String[] values = new String[]{\n-            \"x\", \"x\\ny\", \"x\\\\ny\", \"x\\ty\", \"x\\\\ty\", \"x\\fy\", \"x\\\\fy\", \"x\\ry\",\n-            \"x\\\\ry\", \"C:\\\\Foo Bar\\\\Baz\", randomString(5).replace('a', '\\\\'),\n-            randomString(500).replace('a', '\\\\'),\n-            randomString(5000).replace('a', '\\\\'), };\n-\n-        for (int i = 0; i < values.length; i++) {\n-            p1.clear();\n-            p2.clear();\n-\n-            p1.setProperty(\"xxx\", values[i]);\n-            p2.setProperty(\"xxx\", values[i]);\n-\n-            ByteArrayOutputStream out1 = new ByteArrayOutputStream();\n-            ByteArrayOutputStream out2 = new ByteArrayOutputStream();\n-\n-            p1.store(out1, null);\n-            p2.store(out2, null);\n-\n-            String s1 = new String(out1.toByteArray());\n-            String s2 = new String(out2.toByteArray());\n-\n-            assertTrue(\"Expected <\" + s1 + \"> but was <\" + s2 + \">\",\n-                s1.indexOf(s2) != -1);\n-        }\n-    }\n-\n-    static String stripComments(byte[] bytes) throws IOException {\n-        BufferedReader reader = new BufferedReader(new InputStreamReader\n-            (new ByteArrayInputStream(bytes)));\n-        StringBuffer sbuf = new StringBuffer();\n-        String line;\n-        while ((line = reader.readLine()) != null) {\n-            // skip comments\n-            if (line.trim().startsWith(\"#\"))\n-                continue;\n-\n-            sbuf.append(line);\n-            sbuf.append('\\n');\n-        }\n-\n-        return sbuf.toString();\n-    }\n-\n-    public void testDuplicateProperties() throws IOException {\n-        FormatPreservingProperties p = new FormatPreservingProperties();\n-        try {\n-            toProperties(\"foo=bar\\nfoo=baz\", p);\n-            fail(\"expected duplicate keys to cause exception\");\n-        } catch (DuplicateKeyException e) {\n-            // expected\n-        }\n-\n-        // now test the expected behavior when duplicates are allowed.\n-        p = new FormatPreservingProperties();\n-        p.setAllowDuplicates(true);\n-        toProperties(\"foo=bar\\nfoo=baz\", p);\n-        assertProperties(new String[][]{ { \"foo\", \"baz\" } }, p);\n-    }\n-\n-    public void testMultipleLoads() throws IOException {\n-        String props = \"foo=bar\\nbaz=quux\";\n-        String props2 = \"a=b\\nc=d\";\n-        Properties vanilla = new Properties();\n-        vanilla.load(new BufferedInputStream\n-            (new StringBufferInputStream(props)));\n-        vanilla.load(new BufferedInputStream\n-            (new StringBufferInputStream(props2)));\n-\n-        Properties p = new FormatPreservingProperties();\n-        p.load(new BufferedInputStream(new StringBufferInputStream(props)));\n-        p.load(new BufferedInputStream(new StringBufferInputStream(props2)));\n-        assertPropertiesSame(vanilla, p);\n-    }\n-\n-    protected FormatPreservingProperties toProperties(String s)\n-        throws IOException {\n-        return toProperties(s, new FormatPreservingProperties());\n-    }\n-\n-    protected FormatPreservingProperties toProperties(String s,\n-        FormatPreservingProperties p) throws IOException {\n-        Properties vanilla = new Properties();\n-        vanilla.load(new StringBufferInputStream(s));\n-\n-        p.load(new StringBufferInputStream(s));\n-        assertRoundTrip(s, p);\n-\n-        assertPropertiesSame(vanilla, p);\n-\n-        return p;\n-    }\n-\n-    private void assertRoundTrip(String s, Properties p) throws IOException {\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        p.store(out, null);\n-        assertEquals(s, out.toString());\n-\n-        // also check serializable\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        new ObjectOutputStream(bout).writeObject(p);\n-\n-        try {\n-            FormatPreservingProperties deserialized =\n-                (FormatPreservingProperties) new ObjectInputStream\n-                    (new ByteArrayInputStream(bout.toByteArray())).\n-                    readObject();\n-            assertEquals(p, deserialized);\n-\n-            out = new ByteArrayOutputStream();\n-            deserialized.store(out, null);\n-            assertEquals(s, out.toString());\n-        } catch (ClassNotFoundException cnfe) {\n-            fail(cnfe + \"\");\n-        }\n-    }\n-\n-    public static void assertEquals(String expected, String actual) {\n-        if (expected == actual)\n-            return;\n-\n-        if (expected == null || !expected.equals(actual))\n-            fail(\"Expected <\" + expected + \"> but was <\" + actual + \">\");\n-    }\n-\n-    private void assertPropertiesSame(Properties vanilla, Properties p) {\n-        assertEquals(vanilla, p);\n-    }\n-\n-    protected void assertProperties(String[][] strings, Properties p) {\n-        for (int i = 0; i < strings.length; i++)\n-            assertEquals(strings[i][1], p.get(strings[i][0]));\n-\n-        assertEquals(strings.length, p.size());\n-    }\n-}\n+/*\r\n+ * Copyright 2006 The Apache Software Foundation.\r\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *  http://www.apache.org/licenses/LICENSE-2.0\r\n+ *  Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package org.apache.openjpa.lib.util;\r\n+\r\n+import java.io.BufferedInputStream;\r\n+import java.io.BufferedReader;\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.ByteArrayOutputStream;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.InputStreamReader;\r\n+import java.io.ObjectInputStream;\r\n+import java.io.ObjectOutputStream;\r\n+import java.io.StringBufferInputStream;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.List;\r\n+import java.util.Properties;\r\n+\r\n+import junit.framework.TestCase;\r\n+import org.apache.openjpa.lib.util.FormatPreservingProperties.DuplicateKeyException;\r\n+\r\n+// things to test:\r\n+// - delimiters in keys\r\n+// - escape chars, including \\:, \\= in files(as generated by Properties)\r\n+// - unicode\r\n+// - non-String keys / vals\r\n+// - list() method behavior\r\n+\r\n+public class TestPropertiesParser extends TestCase {\r\n+\r\n+    private static final String LS = System.getProperty( \"line.separator\" );\r\n+\r\n+    public void testSimpleProperties() throws IOException {\r\n+        StringBuffer buf = new StringBuffer();\r\n+        buf.append(\"key: value\" + LS);\r\n+        buf.append(\"key2: value2\"); // no EOL -- this is intentional\r\n+        Properties p = toProperties(buf.toString());\r\n+        assertProperties(new String[][]{\r\n+            { \"key\", \"value\" }, { \"key2\", \"value2\" } }, p);\r\n+    }\r\n+\r\n+    public void testComments() throws IOException {\r\n+        StringBuffer buf = new StringBuffer();\r\n+        buf.append(\"# this is a comment\" + LS);\r\n+        buf.append(\" # another one, with leading whitespace\t\" + LS);\r\n+        buf.append(\" \t# \tand more with interesting whitespace\t\" + LS);\r\n+        buf.append(\"! and with a ! delimiter\" + LS);\r\n+        buf.append(\"! and with escape \\t chars\" + LS);\r\n+        buf.append(\"#and a comment with no whitespace\" + LS);\r\n+        Properties p = toProperties(buf.toString());\r\n+        assertEquals(0, p.size());\r\n+    }\r\n+\r\n+    public void testMixedContent() throws IOException {\r\n+        StringBuffer buf = new StringBuffer();\r\n+        buf.append(\"# this is a comment\" + LS);\r\n+        buf.append(\" # another one, with leading whitespace\t\" + LS);\r\n+        buf.append(\"foo: bar#baz\" + LS);\r\n+        buf.append(\"! and with a ! delimiter\" + LS);\r\n+        buf.append(\"! and with escape \\t chars\" + LS);\r\n+        Properties p = toProperties(buf.toString());\r\n+        assertProperties(new String[][]{ { \"foo\", \"bar#baz\" } }, p);\r\n+    }\r\n+\r\n+    public void testMultiLineInput() throws IOException {\r\n+        String s = \"foo: bar\\\\\" + LS + \"more line goes here\";\r\n+        Properties p = toProperties(s);\r\n+        assertProperties(\r\n+            new String[][]{ { \"foo\", \"barmore line goes here\" } }, p);\r\n+    }\r\n+\r\n+    public void testEmptyLines() throws IOException {\r\n+        Properties p = toProperties(LS + \"foo: bar\" + LS + LS + \"baz: val\");\r\n+        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\r\n+            p);\r\n+    }\r\n+\r\n+    public void testAddProperties() throws IOException {\r\n+        // intentionally left out the trailing end line\r\n+        String s = \"foo: bar\" + LS + \"baz: val\";\r\n+        Properties p = toProperties(s);\r\n+        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\r\n+            p);\r\n+\r\n+        p.put(\"new-key\", \"val1\");\r\n+        p.put(\"new-key-2\", \"val2\");\r\n+        p.put(\"another-new-key\", \"val3\");\r\n+        assertRoundTrip(s + LS + \"new-key: val1\" + LS + \"new-key-2: val2\" + LS +\r\n+            \"another-new-key: val3\" + LS, p);\r\n+    }\r\n+\r\n+    public void testAddAndMutateProperties() throws IOException {\r\n+        // intentionally left out the trailing end line\r\n+        Properties p = toProperties(\"foo: bar\" + LS + \"baz: val\");\r\n+        assertProperties(new String[][]{ { \"foo\", \"bar\" }, { \"baz\", \"val\" } },\r\n+            p);\r\n+\r\n+        p.put(\"new-key\", \"new value\");\r\n+        p.put(\"foo\", \"barbar\");\r\n+        assertRoundTrip(\"foo: barbar\" + LS + \"baz: val\" + LS \r\n+            + \"new-key: new value\" + LS, p);\r\n+    }\r\n+\r\n+    public void testEscapedEquals() throws IOException {\r\n+        Properties p = toProperties(\"foo=bar\\\\=WARN,baz\\\\=TRACE\");\r\n+        assertProperties(new String[][]{ { \"foo\", \"bar=WARN,baz=TRACE\" } }, p);\r\n+    }\r\n+\r\n+    public void testLineTypes() throws IOException {\r\n+        StringBuffer buf = new StringBuffer();\r\n+        buf.append(\"   !comment\" + LS + \" \\t  \" + LS + \"name = no\" + LS + \"    \"\r\n+            + \"#morec\\tomm\\\\\" + LS + \"ents\" + LS + LS + \"  dog=no\\\\cat   \" + LS \r\n+            + \"burps    :\" + LS + \"test=\" + LS + \"date today\" + LS + LS + LS \r\n+            + \"long\\\\\" + LS + \"   value=tryin \\\\\" + LS + \" \"\r\n+            + \"gto\" + LS + \"4:vier\" + LS + \"vier     :4\");\r\n+        Properties p = toProperties(buf.toString());\r\n+        assertProperties(new String[][]{\r\n+            { \"name\", \"no\" }, { \"ents\", \"\" }, { \"dog\", \"nocat   \" },\r\n+            { \"burps\", \"\" }, { \"test\", \"\" }, { \"date\", \"today\" },\r\n+            { \"longvalue\", \"tryin gto\" }, { \"4\", \"vier\" }, { \"vier\", \"4\" },\r\n+        }, p);\r\n+    }\r\n+\r\n+    public void testSpecialChars() throws Throwable {\r\n+        testSpecialChars(false, true);\r\n+        testSpecialChars(true, true);\r\n+        testSpecialChars(false, false);\r\n+        testSpecialChars(true, false);\r\n+    }\r\n+\r\n+    /**\r\n+     * Test that special characters work.\r\n+     *\r\n+     * @param formattingProps if true, test against the\r\n+     * FormatPreservingProperties, otherwise test\r\n+     * against a normal Properties instance(for validation of the test case).\r\n+     * @param value whether to test the key or the value\r\n+     */\r\n+    public void testSpecialChars(boolean formattingProps, boolean value)\r\n+        throws Throwable {\r\n+        List valueList = new ArrayList(Arrays.asList(new String[]{\r\n+            \"xxyy\", \"xx\\\\yy\", \"xx\" + LS + \"yy\", \"xx\\\\nyy\", \"xx\\tyy\", \"xx\\\\tyy\",\r\n+            \"xx\\ryy\", \"xx\\\\ryy\", \"xx\\fyy\", \"xx\\\\fyy\", \"xx\\r\" + LS + \"\\\\\\t\\r\\t\" \r\n+            + LS + \"yy\",\r\n+            \"xx\\\\r\" + LS + \"\\\\\\t\\\\r\\t\\\\nyy\",\r\n+            \"xx\\r\" + LS + \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\t\\r\\t\" + LS + \"yy\",\r\n+            \"C:\\\\Program Files\\\\Some Application\\\\OpenJPA\\\\My File.dat\", }));\r\n+\r\n+        // also store every individual character\r\n+        for (char c = 'a'; c < 'Z'; c++) {\r\n+            valueList.add(new String(new char[]{ c }));\r\n+            valueList.add(new String(new char[]{ c, '\\\\', c }));\r\n+            valueList.add(new String(new char[]{ '\\\\', c }));\r\n+        }\r\n+\r\n+        String[] values = (String[]) valueList.toArray(new String[0]);\r\n+\r\n+        final String dummy = \"XXX\";\r\n+\r\n+        for (int i = 0; i < values.length; i++) {\r\n+            // test special characters in either keys or values\r\n+            String val = value ? values[i] : dummy;\r\n+            String key = value ? dummy : values[i];\r\n+\r\n+            Properties p = formattingProps ?\r\n+                new FormatPreservingProperties() : new Properties();\r\n+            if (p instanceof FormatPreservingProperties) {\r\n+                // set these properties so we behave the same way as\r\n+                // java.util.Properties\r\n+                ((FormatPreservingProperties) p).setDefaultEntryDelimiter('=');\r\n+                ((FormatPreservingProperties) p).\r\n+                    setAddWhitespaceAfterDelimiter(false);\r\n+            }\r\n+\r\n+            p.setProperty(key, val);\r\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n+            p.store(out, null);\r\n+\r\n+            Properties copy = new Properties();\r\n+            copy.setProperty(key, val);\r\n+            ByteArrayOutputStream copyOut = new ByteArrayOutputStream();\r\n+            copy.store(copyOut, null);\r\n+\r\n+            p = formattingProps ?\r\n+                new FormatPreservingProperties() : new Properties();\r\n+\r\n+            InputStream in = new BufferedInputStream\r\n+                (new ByteArrayInputStream(out.toByteArray()));\r\n+\r\n+            try {\r\n+                // make sure that the 2 properties serialized are the same\r\n+                String copyOutString = stripComments(copyOut.toByteArray());\r\n+                String outString = stripComments(out.toByteArray());\r\n+                assertEquals(copyOutString, outString);\r\n+\r\n+                p.load(in);\r\n+\r\n+                assertNotNull(\"Property \\\"\" + key + \"\\\" was null\",\r\n+                    p.getProperty(key));\r\n+                assertEquals(val.trim(), p.getProperty(key).trim());\r\n+            } catch (Throwable ioe) {\r\n+                if (!formattingProps)\r\n+                    throw ioe;\r\n+\r\n+                // bug(1211, ioe,\r\n+                // \"Cannot store backslash in FormatPreservingProperties\");\r\n+                throw ioe;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    static Character randomChar() {\r\n+        char [] TEST_CHAR_ARRAY = new char []{\r\n+            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\r\n+            'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\r\n+            's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '1',\r\n+            '2', '3', '4', '5', '6', '7', '8', '9' };\r\n+\r\n+        return new Character(TEST_CHAR_ARRAY[\r\n+            (int) (Math.random() * TEST_CHAR_ARRAY.length)]);\r\n+    }\r\n+\r\n+    static String randomString(int len) {\r\n+        StringBuffer buf = new StringBuffer();\r\n+        for (int i = 0; i < (int) (Math.random() * len) + 1; i++)\r\n+            buf.append(randomChar());\r\n+        return buf.toString();\r\n+    }\r\n+\r\n+    public void testEquivalentStore() throws IOException {\r\n+        Properties p1 = new Properties();\r\n+        FormatPreservingProperties p2 = new FormatPreservingProperties();\r\n+\r\n+        ((FormatPreservingProperties) p2).setDefaultEntryDelimiter('=');\r\n+        ((FormatPreservingProperties) p2).setAddWhitespaceAfterDelimiter(false);\r\n+\r\n+        String[] values =\r\n+            new String[] { \r\n+                \"x\", \r\n+                \"x\" + LS + \"y\", \r\n+                \"x\\\\ny\", \r\n+                \"x\\ty\", \r\n+                \"x\\\\ty\",\r\n+                \"x\\fy\", \r\n+                \"x\\\\fy\", \r\n+                \"x\\ry\", \r\n+                \"x\\\\ry\", \r\n+                \"C:\\\\Foo Bar\\\\Baz\",\r\n+                randomString(5).replace('a', '\\\\'),\r\n+                randomString(500).replace('a', '\\\\'),\r\n+                randomString(5000).replace('a', '\\\\'), \r\n+                };\r\n+\r\n+        for (int i = 0; i < values.length; i++) {\r\n+            p1.clear();\r\n+            p2.clear();\r\n+\r\n+            p1.setProperty(\"xxx\", values[i]);\r\n+            p2.setProperty(\"xxx\", values[i]);\r\n+\r\n+            ByteArrayOutputStream out1 = new ByteArrayOutputStream();\r\n+            ByteArrayOutputStream out2 = new ByteArrayOutputStream();\r\n+\r\n+            p1.store(out1, null);\r\n+            p2.store(out2, null);\r\n+\r\n+            String s1 = new String(out1.toByteArray());\r\n+            String s2 = new String(out2.toByteArray());\r\n+\r\n+            assertTrue(\"Expected <\" + s1 + \"> but was <\" + s2 + \">\",\r\n+                s1.indexOf(s2) != -1);\r\n+        }\r\n+    }\r\n+\r\n+    static String stripComments(byte[] bytes) throws IOException {\r\n+        BufferedReader reader = new BufferedReader(new InputStreamReader\r\n+            (new ByteArrayInputStream(bytes)));\r\n+        StringBuffer sbuf = new StringBuffer();\r\n+        String line;\r\n+        while ((line = reader.readLine()) != null) {\r\n+            // skip comments\r\n+            if (line.trim().startsWith(\"#\"))\r\n+                continue;\r\n+\r\n+            sbuf.append(line);\r\n+            sbuf.append(LS);\r\n+        }\r\n+\r\n+        return sbuf.toString();\r\n+    }\r\n+\r\n+    public void testDuplicateProperties() throws IOException {\r\n+        FormatPreservingProperties p = new FormatPreservingProperties();\r\n+        try {\r\n+            toProperties(\"foo=bar\" + LS + \"foo=baz\", p);\r\n+            fail(\"expected duplicate keys to cause exception\");\r\n+        } catch (DuplicateKeyException e) {\r\n+            // expected\r\n+        }\r\n+\r\n+        // now test the expected behavior when duplicates are allowed.\r\n+        p = new FormatPreservingProperties();\r\n+        p.setAllowDuplicates(true);\r\n+        toProperties(\"foo=bar\" + LS + \"foo=baz\", p);\r\n+        assertProperties(new String[][]{ { \"foo\", \"baz\" } }, p);\r\n+    }\r\n+\r\n+    public void testMultipleLoads() throws IOException {\r\n+        String props = \"foo=bar\" + LS + \"baz=quux\";\r\n+        String props2 = \"a=b\" + LS + \"c=d\";\r\n+        Properties vanilla = new Properties();\r\n+        vanilla.load(new BufferedInputStream\r\n+            (new StringBufferInputStream(props)));\r\n+        vanilla.load(new BufferedInputStream\r\n+            (new StringBufferInputStream(props2)));\r\n+\r\n+        Properties p = new FormatPreservingProperties();\r\n+        p.load(new BufferedInputStream(new StringBufferInputStream(props)));\r\n+        p.load(new BufferedInputStream(new StringBufferInputStream(props2)));\r\n+        assertPropertiesSame(vanilla, p);\r\n+    }\r\n+\r\n+    protected FormatPreservingProperties toProperties(String s)\r\n+        throws IOException {\r\n+        return toProperties(s, new FormatPreservingProperties());\r\n+    }\r\n+\r\n+    protected FormatPreservingProperties toProperties(String s,\r\n+        FormatPreservingProperties p) throws IOException {\r\n+        Properties vanilla = new Properties();\r\n+        vanilla.load(new StringBufferInputStream(s));\r\n+\r\n+        p.load(new StringBufferInputStream(s));\r\n+        assertRoundTrip(s, p);\r\n+\r\n+        assertPropertiesSame(vanilla, p);\r\n+\r\n+        return p;\r\n+    }\r\n+\r\n+    private void assertRoundTrip(String s, Properties p) throws IOException {\r\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n+        p.store(out, null);\r\n+        assertEquals(s, out.toString());\r\n+\r\n+        // also check serializable\r\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\r\n+        new ObjectOutputStream(bout).writeObject(p);\r\n+\r\n+        try {\r\n+            FormatPreservingProperties deserialized =\r\n+                (FormatPreservingProperties) new ObjectInputStream\r\n+                    (new ByteArrayInputStream(bout.toByteArray())).\r\n+                    readObject();\r\n+            assertEquals(p, deserialized);\r\n+\r\n+            out = new ByteArrayOutputStream();\r\n+            deserialized.store(out, null);\r\n+            assertEquals(s, out.toString());\r\n+        } catch (ClassNotFoundException cnfe) {\r\n+            fail(cnfe + \"\");\r\n+        }\r\n+    }\r\n+\r\n+    public static void assertEquals(String expected, String actual) {\r\n+        if (expected == actual)\r\n+            return;\r\n+\r\n+        if (expected == null || !expected.equals(actual))\r\n+            fail(\"Expected <\" + expected + \"> but was <\" + actual + \">\");\r\n+    }\r\n+\r\n+    private void assertPropertiesSame(Properties vanilla, Properties p) {\r\n+        assertEquals(vanilla, p);\r\n+    }\r\n+\r\n+    protected void assertProperties(String[][] strings, Properties p) {\r\n+        for (int i = 0; i < strings.length; i++)\r\n+            assertEquals(strings[i][1], p.get(strings[i][0]));\r\n+\r\n+        assertEquals(strings.length, p.size());\r\n+    }\r\n+}\r"}]}

