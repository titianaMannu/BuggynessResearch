{"sha":"ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5","node_id":"MDY6Q29tbWl0MjA2MzY0OmVjOGViNTRhOGU3NWJiZjBiZTQ0M2JmYjk4MmUxYWRiMmU1YzMyYjU=","commit":{"author":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T21:51:26Z"},"committer":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T21:51:26Z"},"message":"OPENJPA-250: Committing to 1.2.x. Submitted by Patrick Linskey, Simon Droscher, and Rick Curtis.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@888586 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ea69906e7730ae0eddd004116042a6ad876014a6","url":"https://api.github.com/repos/apache/openjpa/git/trees/ea69906e7730ae0eddd004116042a6ad876014a6"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5","html_url":"https://github.com/apache/openjpa/commit/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5","comments_url":"https://api.github.com/repos/apache/openjpa/commits/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5/comments","author":null,"committer":null,"parents":[{"sha":"eaf25282aa910886487e42e3b9c835bb461887f2","url":"https://api.github.com/repos/apache/openjpa/commits/eaf25282aa910886487e42e3b9c835bb461887f2","html_url":"https://github.com/apache/openjpa/commit/eaf25282aa910886487e42e3b9c835bb461887f2"}],"stats":{"total":901,"additions":722,"deletions":179},"files":[{"sha":"72f633a67cefcb430abc2cf3c12a0ccdb192f141","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","status":"modified","additions":108,"deletions":29,"changes":137,"blob_url":"https://github.com/apache/openjpa/blob/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","raw_url":"https://github.com/apache/openjpa/raw/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java?ref=ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5","patch":"@@ -143,7 +143,15 @@ public void setMappingDefaults(MappingDefaults defaults) {\n     /**\n      * Representation of the database schema.\n      */\n-    public synchronized SchemaGroup getSchemaGroup() {\n+    public SchemaGroup getSchemaGroup() {\n+        if(_locking){\n+            synchronized(this){\n+                if (_schema == null)\n+                    _schema = ((JDBCConfiguration) getConfiguration()).\n+                        getSchemaFactoryInstance().readSchema();\n+                return _schema;                \n+            }\n+        }\n         if (_schema == null)\n             _schema = ((JDBCConfiguration) getConfiguration()).\n                 getSchemaFactoryInstance().readSchema();\n@@ -153,33 +161,59 @@ public synchronized SchemaGroup getSchemaGroup() {\n     /**\n      * Representation of the database schema.\n      */\n-    public synchronized void setSchemaGroup(SchemaGroup schema) {\n-        _schema = schema;\n+    public void setSchemaGroup(SchemaGroup schema) {\n+        if (_locking) {\n+            synchronized (this) {\n+                _schema = schema;\n+            }\n+        } else {\n+            _schema = schema;\n+        }\n     }\n \n     /**\n      * Installs mapping strategies on components.\n      */\n-    public synchronized StrategyInstaller getStrategyInstaller() {\n-        if (_installer == null)\n-            _installer = new RuntimeStrategyInstaller(this);\n-        return _installer;\n+    public StrategyInstaller getStrategyInstaller() {\n+        if (_locking) {\n+            synchronized (this) {\n+                if (_installer == null)\n+                    _installer = new RuntimeStrategyInstaller(this);\n+                return _installer;\n+            }\n+        } else {\n+            if (_installer == null)\n+                _installer = new RuntimeStrategyInstaller(this);\n+            return _installer;\n+        }\n     }\n \n     /**\n      * Installs mapping strategies on components.\n      */\n-    public synchronized void setStrategyInstaller(StrategyInstaller installer) {\n-        _installer = installer;\n+    public void setStrategyInstaller(StrategyInstaller installer) {\n+        if (_locking) {\n+            synchronized (this) {\n+                _installer = installer;\n+            }\n+        } else {\n+            _installer = installer;\n+        }\n     }\n \n     /**\n      * Return the query result mapping for the given name.\n      */\n-    public synchronized QueryResultMapping getQueryResultMapping(Class cls,\n+    public QueryResultMapping getQueryResultMapping(Class cls,\n         String name, ClassLoader envLoader, boolean mustExist) {\n-        QueryResultMapping res = getQueryResultMappingInternal(cls, name,\n-            envLoader);\n+        QueryResultMapping res = null;\n+        if (_locking) {\n+            synchronized (this) {\n+                res = getQueryResultMappingInternal(cls, name, envLoader);\n+            }\n+        } else {\n+            res = getQueryResultMappingInternal(cls, name, envLoader);\n+        }\n         if (res == null && mustExist)\n             throw new MetaDataException(_loc.get(\"no-query-res\", cls, name));\n         return res;\n@@ -219,26 +253,49 @@ private QueryResultMapping getQueryResultMappingInternal(Class cls,\n     /**\n      * Return all cached query result mappings.\n      */\n-    public synchronized QueryResultMapping[] getQueryResultMappings() {\n-        Collection values = _results.values();\n-        return (QueryResultMapping[]) values.toArray\n-            (new QueryResultMapping[values.size()]);\n+    public QueryResultMapping[] getQueryResultMappings() {\n+        if (_locking) {\n+            synchronized (this) {\n+                Collection values = _results.values();\n+                return (QueryResultMapping[]) values.toArray(new QueryResultMapping[values.size()]);\n+            }\n+        } else {\n+            Collection values = _results.values();\n+            return (QueryResultMapping[]) values.toArray(new QueryResultMapping[values.size()]);\n+        }\n     }\n \n     /**\n      * Return the cached query result mapping with the given name, or null if\n      * none.\n      */\n-    public synchronized QueryResultMapping getCachedQueryResultMapping\n+    public QueryResultMapping getCachedQueryResultMapping\n         (Class cls, String name) {\n-        return (QueryResultMapping) _results.get(getQueryResultKey(cls, name));\n+        if (_locking) {\n+            synchronized (this) {\n+                return (QueryResultMapping) _results.get(getQueryResultKey(cls, name));\n+            }\n+        } else {\n+            return (QueryResultMapping) _results.get(getQueryResultKey(cls, name));\n+        }\n     }\n \n     /**\n      * Add a query result mapping.\n      */\n-    public synchronized QueryResultMapping addQueryResultMapping(Class cls,\n+    public QueryResultMapping addQueryResultMapping(Class cls,\n         String name) {\n+        if (_locking) {\n+            return addQueryResultMappingLocking(cls, name);\n+        } else {\n+            return addQueryResultMappingInternal(cls, name);\n+        }\n+    }\n+    private synchronized QueryResultMapping addQueryResultMappingLocking(Class cls, String name) {\n+        return addQueryResultMappingInternal(cls, name);\n+    }\n+\n+    private QueryResultMapping addQueryResultMappingInternal(Class cls, String name) {\n         QueryResultMapping res = new QueryResultMapping(name, this);\n         res.setDefiningType(cls);\n         _results.put(getQueryResultKey(res), res);\n@@ -248,19 +305,33 @@ public synchronized QueryResultMapping addQueryResultMapping(Class cls,\n     /**\n      * Remove a query result mapping.\n      */\n-    public synchronized boolean removeQueryResultMapping\n+    public boolean removeQueryResultMapping\n         (QueryResultMapping res) {\n-        return _results.remove(getQueryResultKey(res)) != null;\n+        if (_locking) {\n+            synchronized (this) {\n+                return _results.remove(getQueryResultKey(res)) != null;\n+            }\n+        } else {\n+            return _results.remove(getQueryResultKey(res)) != null;\n+        }\n     }\n \n     /**\n      * Remove a query result mapping.\n      */\n-    public synchronized boolean removeQueryResultMapping(Class cls,\n+    public boolean removeQueryResultMapping(Class cls,\n         String name) {\n-        if (name == null)\n-            return false;\n-        return _results.remove(getQueryResultKey(cls, name)) != null;\n+        if (_locking) {\n+            synchronized (this) {\n+                if (name == null)\n+                    return false;\n+                return _results.remove(getQueryResultKey(cls, name)) != null;\n+            }\n+        } else {\n+            if (name == null)\n+                return false;\n+            return _results.remove(getQueryResultKey(cls, name)) != null;\n+        }\n     }\n \n     /**\n@@ -300,10 +371,18 @@ public ClassMapping getMapping(Object oid, ClassLoader envLoader,\n             mustExist);\n     }\n \n-    public synchronized void clear() {\n-        super.clear();\n-        _schema = null;\n-        _results.clear();\n+    public void clear() {\n+        if (_locking) {\n+            synchronized (this) {\n+                super.clear();\n+                _schema = null;\n+                _results.clear();\n+            }\n+        } else {\n+            super.clear();\n+            _schema = null;\n+            _results.clear();\n+        }\n     }\n \n     protected void prepareMapping(ClassMetaData meta) {"},{"sha":"218ae07b52688ec7027f1e54adb2eeabff3c8012","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java?ref=ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5","patch":"@@ -126,7 +126,7 @@\n     public BooleanValue multithreaded;\n     public StringValue mapping;\n     public PluginValue metaFactoryPlugin;\n-    public ObjectValue metaRepositoryPlugin;\n+    public MetaDataRepositoryValue metaRepositoryPlugin;\n     public ObjectValue lockManagerPlugin;\n     public ObjectValue inverseManagerPlugin;\n     public ObjectValue savepointManagerPlugin;\n@@ -303,7 +303,7 @@ public OpenJPAConfigurationImpl(boolean derivations, boolean loadGlobals) {\n         mapping = addString(\"Mapping\");\n         metaFactoryPlugin = addPlugin(\"MetaDataFactory\", false);\n \n-        metaRepositoryPlugin = (ObjectValue)\n+        metaRepositoryPlugin = (MetaDataRepositoryValue)\n             addValue(new MetaDataRepositoryValue());\n \n         connectionFactory = addObject(\"ConnectionFactory\");"},{"sha":"7398858be29d01f61149753b59ad80c565aa6b2f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java?ref=ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5","patch":"@@ -256,7 +256,7 @@ protected void addListeners(BrokerImpl broker) {\n      * Load the configured persistent classes list. Performed automatically\n      * whenever a broker is created.\n      */\n-    private void loadPersistentTypes(ClassLoader envLoader) {\n+    public void loadPersistentTypes(ClassLoader envLoader) {\n         // if we've loaded the persistent types and the class name list\n         // is empty, then we can simply return. Note that there is a\n         // potential threading scenario in which _persistentTypesLoaded is"},{"sha":"559b1ab16f4634149f4ece394b9c7fd4c62cf807","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","status":"modified","additions":571,"deletions":145,"changes":716,"blob_url":"https://github.com/apache/openjpa/blob/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","raw_url":"https://github.com/apache/openjpa/raw/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java?ref=ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5","patch":"@@ -20,6 +20,7 @@\n \n import java.io.Serializable;\n import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n@@ -37,20 +38,23 @@\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.enhance.DynamicPersistenceCapable;\n import org.apache.openjpa.enhance.PCRegistry;\n-import org.apache.openjpa.enhance.PCRegistry.RegisterClassListener;\n import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.enhance.PCRegistry.RegisterClassListener;\n import org.apache.openjpa.event.LifecycleEventManager;\n import org.apache.openjpa.lib.conf.Configurable;\n import org.apache.openjpa.lib.conf.Configuration;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.util.Closeable;\n import org.apache.openjpa.lib.util.J2DoPrivHelper;\n import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.MultiClassLoader;\n+import org.apache.openjpa.lib.util.Options;\n import org.apache.openjpa.lib.util.StringDistance;\n import org.apache.openjpa.util.ImplHelper;\n import org.apache.openjpa.util.InternalException;\n import org.apache.openjpa.util.MetaDataException;\n import org.apache.openjpa.util.OpenJPAId;\n+\n import serp.util.Strings;\n \n /**\n@@ -63,6 +67,8 @@\n public class MetaDataRepository\n     implements PCRegistry.RegisterClassListener, Configurable, Closeable, \n     MetaDataModes, Serializable {\n+    \n+    protected boolean _locking = true;\n \n     /**\n      * Constant to not validate any metadata.\n@@ -105,18 +111,18 @@\n \n     // cache of parsed metadata, oid class to class, and interface class\n     // to metadatas\n-    private final Map _metas = new HashMap();\n-    private final Map _oids = Collections.synchronizedMap(new HashMap());\n-    private final Map _impls = Collections.synchronizedMap(new HashMap());\n-    private final Map _ifaces = Collections.synchronizedMap(new HashMap());\n-    private final Map _queries = new HashMap();\n-    private final Map _seqs = new HashMap();\n-    private final Map _aliases = Collections.synchronizedMap(new HashMap());\n-    private final Map _pawares = Collections.synchronizedMap(new HashMap());\n-    private final Map _nonMapped = Collections.synchronizedMap(new HashMap());\n+\tprivate Map _metas = new HashMap();\n+\tprivate Map _oids = Collections.synchronizedMap(new HashMap());\n+\tprivate Map _impls = Collections.synchronizedMap(new HashMap());\n+\tprivate Map _ifaces = Collections.synchronizedMap(new HashMap());\n+\tprivate Map _queries = new HashMap();\n+\tprivate Map _seqs = new HashMap();\n+\tprivate Map _aliases = Collections.synchronizedMap(new HashMap());\n+\tprivate Map _pawares = Collections.synchronizedMap(new HashMap());\n+\tprivate Map _nonMapped = Collections.synchronizedMap(new HashMap());\n     \n     // map of classes to lists of their subclasses\n-    private final Map _subs = Collections.synchronizedMap(new HashMap());\n+\tprivate Map _subs = Collections.synchronizedMap(new HashMap());\n \n     // xml mapping\n     protected final XMLMetaData[] EMPTY_XMLMETAS;\n@@ -147,6 +153,9 @@\n         new LifecycleEventManager.ListenerList(3);\n \n     private boolean _reorderMetaDataResolution = false;\n+    protected boolean _preload = false;\n+    protected boolean _preloadComplete = false;\n+    private static final String PRELOAD_STR = \"Preload\";\n     \n     /**\n      * Default constructor.  Configure via {@link Configurable}.\n@@ -274,6 +283,70 @@ else if (on)\n             _sourceMode &= ~mode;\n     }\n \n+    /**\n+     * Sets whether this repository will load all MetaData for all known persistent classes at\n+     * initialization and remove all locking. Defaults to false.\n+     */\n+    public void setPreload(boolean p) {\n+        _preload = p;\n+    }\n+\n+    /**\n+     * Returns a boolean indicating whether this repository will load all MetaData for all known\n+     * persistent classes at initialization.\n+     */\n+    public boolean getPreload() {\n+        return _preload;\n+    }   \n+    \n+     /**\n+     * If the openjpa.MetaDataRepository plugin value Preload=true is set, this method will load all\n+     * MetaData for all persistent classes and will remove locking from this class.\n+     * <p>\n+     * \n+     */\n+    public synchronized void preload() {\n+        if (_preload == false) {\n+            return;\n+        }\n+        // If pooling EMFs, this method may be invoked more than once. Only perform this work once.\n+        if (_preloadComplete == true) {\n+            return;\n+        }\n+\n+        MultiClassLoader multi = AccessController.doPrivileged(J2DoPrivHelper.newMultiClassLoaderAction());\n+        multi.addClassLoader(AccessController.doPrivileged(J2DoPrivHelper.getContextClassLoaderAction()));\n+        multi.addClassLoader(AccessController.doPrivileged(J2DoPrivHelper\n+            .getClassLoaderAction(MetaDataRepository.class)));\n+\n+        Set<String> classes = getPersistentTypeNames(false, multi);\n+        if (classes == null || classes.size() == 0) {\n+            throw new MetaDataException(_loc.get(\"repos-initializeEager-none\"));\n+        }\n+        if (_log.isTraceEnabled() == true) {\n+            _log.trace(_loc.get(\"repos-initializeEager-found\", classes));\n+        }\n+\n+        List<Class> loaded = new ArrayList<Class>();\n+        for (String c : classes) {\n+            try {\n+                Class<?> cls = AccessController.doPrivileged((J2DoPrivHelper.getForNameAction(c, true, multi)));\n+                loaded.add(cls);\n+                // This call may be unnecessary?\n+                _factory.load(cls, MODE_ALL, multi);\n+            } catch (PrivilegedActionException pae) {\n+                throw new MetaDataException(_loc.get(\"repos-initializeEager-error\"), pae);\n+            }\n+        }\n+        resolveAll(multi);\n+        \n+        // Hook in this class as a listener and process registered classes list to populate _aliases list.\n+        PCRegistry.addRegisterClassListener(this);\n+        processRegisteredClasses(multi);\n+        _locking = false;\n+        _preloadComplete = true;\n+    }\n+    \n     /**\n      * Return the metadata for the given class.\n      *\n@@ -282,7 +355,17 @@ else if (on)\n      * @param mustExist if true, throws a {@link MetaDataException}\n      * if no metadata is found\n      */\n-    public synchronized ClassMetaData getMetaData(Class cls,\n+    public ClassMetaData getMetaData(Class cls, ClassLoader envLoader, boolean mustExist) {\n+        if (_locking) {\n+            return getMetaDataLocking(cls, envLoader, mustExist);\n+        } else {\n+            return getMetaDataInternal(cls, envLoader, mustExist);\n+        }\n+    }\n+    private synchronized ClassMetaData getMetaDataLocking(Class cls, ClassLoader envLoader, boolean mustExist) {\n+        return getMetaDataInternal(cls, envLoader, mustExist);\n+    }\n+    private ClassMetaData getMetaDataInternal(Class cls,\n         ClassLoader envLoader, boolean mustExist) {\n         if (cls != null &&\n             DynamicPersistenceCapable.class.isAssignableFrom(cls))\n@@ -403,14 +486,24 @@ public String getClosestAliasName(String alias) {\n      * @since 1.1.0\n      */\n     public Collection getAliasNames() {\n-        Collection aliases = new HashSet();\n+        if (_locking) {\n+            return getAliasNamesLocking();\n+        } else {\n+            return getAliasNamesInternal();\n+        }\n+    }\n+\n+    private Collection getAliasNamesLocking() {\n         synchronized (_aliases) {\n-            for (Iterator iter = _aliases.entrySet().iterator();\n-                iter.hasNext(); ) {\n-                Map.Entry e = (Map.Entry) iter.next();\n-                if (e.getValue() != null)\n-                    aliases.add(e.getKey());\n-            }\n+            return getAliasNamesInternal();\n+        }\n+    }\n+    private final Collection getAliasNamesInternal() {\n+        Collection aliases = new HashSet();\n+        for (Iterator iter = _aliases.entrySet().iterator(); iter.hasNext();) {\n+            Map.Entry e = (Map.Entry) iter.next();\n+            if (e.getValue() != null)\n+                aliases.add(e.getKey());\n         }\n         return aliases;\n     }\n@@ -749,7 +842,17 @@ private List processBuffer(ClassMetaData meta,\n     /**\n      * Return all the metadata instances currently in the repository.\n      */\n-    public synchronized ClassMetaData[] getMetaDatas() {\n+    public ClassMetaData[] getMetaDatas() {\n+        if (_locking) {\n+            return getMetaDatasLocking();\n+        } else {\n+            return getMetaDatasInternal();\n+        }\n+    }\n+    private synchronized ClassMetaData[] getMetaDatasLocking() {\n+        return getMetaDatasInternal();\n+    }\n+    private ClassMetaData[] getMetaDatasInternal() {\n         // prevent concurrent mod errors when resolving one metadata\n         // introduces others\n         ClassMetaData[] metas = (ClassMetaData[]) _metas.values().\n@@ -803,13 +906,22 @@ public ClassMetaData addMetaData(Class cls, int access) {\n \n         // synchronize on this rather than the map, because all other methods\n         // that access _metas are synchronized on this\n-        synchronized (this) {\n-            if (_pawares.containsKey(cls))\n-                throw new MetaDataException(_loc.get(\"pc-and-aware\", cls));\n-            _metas.put(cls, meta);\n+        if (_locking) {\n+            metasPutLocking(cls, meta);\n+        } else {\n+            metasPutInternal(cls, meta);\n         }\n+            \n         return meta;\n     }\n+    private synchronized void metasPutLocking(Class cls, ClassMetaData meta){\n+        metasPutInternal(cls, meta);\n+    }\n+    private void metasPutInternal(Class cls, ClassMetaData meta){\n+        if (_pawares.containsKey(cls))\n+            throw new MetaDataException(_loc.get(\"pc-and-aware\", cls));\n+        _metas.put(cls, meta);\n+    }\n     \n     /**\n      * Create a new class metadata instance.\n@@ -927,7 +1039,17 @@ public boolean removeMetaData(ClassMetaData meta) {\n      *\n      * @return true if removed, false if not in this repository\n      */\n-    public synchronized boolean removeMetaData(Class cls) {\n+    public boolean removeMetaData(Class cls) {\n+        if(_locking){\n+            return removeMetaDataLocking(cls);\n+        }else{\n+            return removeMetaDataInternal(cls);\n+        }\n+    }\n+    private synchronized boolean removeMetaDataLocking(Class cls) {\n+        return removeMetaDataInternal(cls);\n+    }\n+    private boolean removeMetaDataInternal(Class cls) {\n         if (cls == null)\n             return false;\n         if (_metas.remove(cls) != null) {\n@@ -943,24 +1065,42 @@ public synchronized boolean removeMetaData(Class cls) {\n      * Add the given metadata as declared interface implementation.\n      */\n     void addDeclaredInterfaceImpl(ClassMetaData meta, Class iface) {\n+        if (_locking) {\n+            addDeclaredInterfaceImplLocking(meta, iface);\n+        } else {\n+            addDeclaredInterfaceImplInternal(meta, iface);\n+        }\n+    }\n+    void addDeclaredInterfaceImplLocking(ClassMetaData meta, Class iface) {\n         synchronized (_impls) {\n-            Collection vals = (Collection) _impls.get(iface);\n-            \n-            // check to see if the superclass already declares to avoid dups\n-            if (vals != null) {\n-                ClassMetaData sup = meta.getPCSuperclassMetaData();\n-                for (; sup != null; sup = sup.getPCSuperclassMetaData())\n-                    if (vals.contains(sup.getDescribedType()))\n-                        return;\n-            }\n-            addToCollection(_impls, iface, meta.getDescribedType(), false);\n+            addDeclaredInterfaceImplInternal(meta, iface);\n         }\n     }\n-\n+    private void addDeclaredInterfaceImplInternal(ClassMetaData meta, Class iface) {\n+        Collection vals = (Collection) _impls.get(iface);\n+        // check to see if the superclass already declares to avoid dups\n+        if (vals != null) {\n+            ClassMetaData sup = meta.getPCSuperclassMetaData();\n+            for (; sup != null; sup = sup.getPCSuperclassMetaData())\n+                if (vals.contains(sup.getDescribedType()))\n+                    return;\n+        }\n+        addToCollection(_impls, iface, meta.getDescribedType(), false);\n+    }\n     /**\n      * Set the implementation for the given managed interface.\n      */\n-    synchronized void setInterfaceImpl(ClassMetaData meta, Class impl) {\n+    void setInterfaceImpl(ClassMetaData meta, Class impl) {\n+        if(_locking){\n+            setInterfaceImplLocking(meta, impl);\n+        }else{\n+            setInterfaceImplInternal(meta, impl);\n+        }\n+    }\n+    private synchronized void setInterfaceImplLocking(ClassMetaData meta, Class impl) {\n+        setInterfaceImplInternal(meta, impl);\n+    }\n+    private void setInterfaceImplInternal(ClassMetaData meta, Class impl) {\n         if (!meta.isManagedInterface())\n             throw new MetaDataException(_loc.get(\"not-managed-interface\", \n                 meta, impl));\n@@ -1096,19 +1236,12 @@ private void resolveIdentityClass(Object oid) {\n         // get impls of given interface / abstract class\n         loadRegisteredClassMetaData(envLoader);\n         Collection vals = (Collection) _impls.get(cls);\n-        ClassMetaData meta;\n         Collection mapped = null;\n         if (vals != null) {\n-            synchronized (vals) {\n-                for (Iterator itr = vals.iterator(); itr.hasNext();) {\n-                    meta = getMetaData((Class) itr.next(), envLoader, true);\n-                    if (meta.isMapped()\n-                        || meta.getMappedPCSubclassMetaDatas().length > 0) {\n-                        if (mapped == null)\n-                            mapped = new ArrayList(vals.size());\n-                        mapped.add(meta);\n-                    }\n-                }\n+            if (_locking) {\n+                mapped = getImplementorMetaDatasLocking(vals, envLoader, mustExist);\n+            } else {\n+                mapped = getImplementorMetaDatasInternal(vals, envLoader, mustExist);\n             }\n         }\n \n@@ -1119,6 +1252,22 @@ private void resolveIdentityClass(Object oid) {\n         return (ClassMetaData[]) mapped.toArray(newClassMetaDataArray\n             (mapped.size()));\n     }\n+    private Collection getImplementorMetaDatasLocking(Collection<Class> classes, ClassLoader envLoader, boolean mustExist) {\n+        synchronized (classes) {\n+            return getImplementorMetaDatasInternal(classes, envLoader, mustExist);\n+        }\n+    }\n+    private Collection getImplementorMetaDatasInternal(Collection<Class> classes, ClassLoader envLoader, boolean mustExist) {\n+        Collection mapped = new ArrayList(classes.size());\n+        ClassMetaData meta = null;\n+        for (Iterator itr = classes.iterator(); itr.hasNext();) {\n+            meta = getMetaData((Class) itr.next(), envLoader, true);\n+            if (meta.isMapped() || meta.getMappedPCSubclassMetaDatas().length > 0) {\n+                mapped.add(meta);\n+            }\n+        }\n+        return mapped;\n+    }\n      \n     /**\n      * Gets the metadata corresponding to the given persistence-aware class. \n@@ -1135,12 +1284,21 @@ public NonPersistentMetaData getPersistenceAware(Class cls) {\n      * @return empty array if no class has been registered as pers-aware\n      */\n     public NonPersistentMetaData[] getPersistenceAwares() {\n+        if (_locking) {\n+            return getPersistenceAwaresLocking();\n+        } else {\n+            return getPersistenceAwaresInternal();\n+        }\n+    }\n+    private NonPersistentMetaData[] getPersistenceAwaresLocking() {\n         synchronized (_pawares) {\n+            return getPersistenceAwaresInternal();\n+        }\n+    }\n+    private NonPersistentMetaData[] getPersistenceAwaresInternal() {\n             if (_pawares.isEmpty())\n                 return EMPTY_NON_PERSISTENT;\n-            return (NonPersistentMetaData[])_pawares.values().toArray\n-                (new NonPersistentMetaData[_pawares.size()]);\n-        }\n+        return (NonPersistentMetaData[]) _pawares.values().toArray(new NonPersistentMetaData[_pawares.size()]);\n     }\n \n     /**\n@@ -1151,17 +1309,26 @@ public NonPersistentMetaData getPersistenceAware(Class cls) {\n     public NonPersistentMetaData addPersistenceAware(Class cls) {\n     \tif (cls == null)\n     \t\treturn null;\n-        synchronized(this) {\n+        if (_locking) {\n+            return addPersistenceAwareLocking(cls);\n+        } else {\n+            return addPersistenceAwareInternal(cls);\n+        }\n+    }\n+\n+    private synchronized NonPersistentMetaData addPersistenceAwareLocking(Class cls) {\n+        return addPersistenceAwareInternal(cls);\n+    }\n+\n+    private NonPersistentMetaData addPersistenceAwareInternal(Class cls) {\n             if (_pawares.containsKey(cls))\n                 return (NonPersistentMetaData)_pawares.get(cls);\n             if (getCachedMetaData(cls) != null)\n                 throw new MetaDataException(_loc.get(\"pc-and-aware\", cls));\n-            NonPersistentMetaData meta = new NonPersistentMetaData(cls, this,\n-                NonPersistentMetaData.TYPE_PERSISTENCE_AWARE);\n+        NonPersistentMetaData meta = new NonPersistentMetaData(cls, this, NonPersistentMetaData.TYPE_PERSISTENCE_AWARE);\n             _pawares.put(cls, meta);\n             return meta;\n     \t}\n-    }\n \n     /**\n      * Remove a persitence-aware class from the repository\n@@ -1188,12 +1355,21 @@ public NonPersistentMetaData getNonMappedInterface(Class iface) {\n      * @return empty array if no non-mapped interface has been registered.\n      */\n     public NonPersistentMetaData[] getNonMappedInterfaces() {\n+        if(_locking){\n+            return getNonMappedInterfacesLocking();   \n+        }else{\n+            return getNonMappedInterfacesInternal();\n+        }\n+    }\n+    private NonPersistentMetaData[] getNonMappedInterfacesLocking() {\n         synchronized (_nonMapped) {\n+            return getNonMappedInterfacesInternal();\n+        }\n+    }\n+    private NonPersistentMetaData[] getNonMappedInterfacesInternal() {\n             if (_nonMapped.isEmpty())\n                 return EMPTY_NON_PERSISTENT;\n-            return (NonPersistentMetaData[])_nonMapped.values().toArray\n-                (new NonPersistentMetaData[_nonMapped.size()]);\n-        }\n+        return (NonPersistentMetaData[]) _nonMapped.values().toArray(new NonPersistentMetaData[_nonMapped.size()]);\n     }\n \n     /**\n@@ -1206,7 +1382,17 @@ public NonPersistentMetaData addNonMappedInterface(Class iface) {\n     \t\treturn null;\n         if (!iface.isInterface())\n             throw new MetaDataException(_loc.get(\"not-non-mapped\", iface));\n-        synchronized(this) {\n+        if(_locking){\n+            return addNonMappedInterfaceLocking(iface);\n+        }else{\n+            return addNonMappedInterfaceInternal(iface); \n+        }\n+    }\n+    private synchronized NonPersistentMetaData addNonMappedInterfaceLocking(Class iface) {\n+        return addNonMappedInterfaceInternal(iface);\n+    }\n+    \n+    private NonPersistentMetaData addNonMappedInterfaceInternal(Class iface) {\n             if (_nonMapped.containsKey(iface))\n                 return (NonPersistentMetaData)_nonMapped.get(iface);\n             if (getCachedMetaData(iface) != null)\n@@ -1216,7 +1402,6 @@ public NonPersistentMetaData addNonMappedInterface(Class iface) {\n             _nonMapped.put(iface, meta);\n             return meta;\n     \t}\n-    }\n \n     /**\n      * Remove a non-mapped interface from the repository\n@@ -1231,10 +1416,21 @@ public boolean removeNonMappedInterface(Class iface) {\n      * Clear the cache of parsed metadata. This method also clears the\n      * internal {@link MetaDataFactory MetaDataFactory}'s cache.\n      */\n-    public synchronized void clear() {\n+    public void clear() {\n         if (_log.isTraceEnabled())\n             _log.trace(_loc.get(\"clear-repos\", this));\n-\n+        \n+        if (_locking) {\n+            clearLocking();\n+        } else {\n+            clearInternal();\n+        }\n+    }\n+    private synchronized void clearLocking(){\n+        clearInternal();\n+    }\n+    private void clearInternal(){\n+        // Recreating these datastructures is probably faster than calling clear. Future change?\n         _metas.clear();\n         _oids.clear();\n         _subs.clear();\n@@ -1247,7 +1443,6 @@ public synchronized void clear() {\n         _pawares.clear();\n         _nonMapped.clear();\n     }\n-\n     /**\n      * Return the set of configured persistent classes, or null if the user\n      * did not configure any.\n@@ -1256,8 +1451,18 @@ public synchronized void clear() {\n      * in the classpath if no classes are configured explicitly\n      * @param envLoader the class loader to use, or null for default\n      */\n-    public synchronized Set getPersistentTypeNames(boolean devpath,\n+    public Set getPersistentTypeNames(boolean devpath,\n         ClassLoader envLoader) {\n+        if (_locking) {\n+            return getPersistentTypeNamesLocking(devpath, envLoader);\n+        } else {\n+            return getPersistentTypeNamesInternal(devpath, envLoader);\n+        }\n+    }\n+    private synchronized Set getPersistentTypeNamesLocking(boolean devpath, ClassLoader envLoader) {\n+        return getPersistentTypeNamesInternal(devpath, envLoader);\n+    }\n+    private Set getPersistentTypeNamesInternal(boolean devpath, ClassLoader envLoader) {\n         return _factory.getPersistentTypeNames(devpath, envLoader);\n     }\n \n@@ -1273,15 +1478,26 @@ public synchronized Set getPersistentTypeNames(boolean devpath,\n      * @param envLoader the class loader to use, or null for default\n      * @return the loaded classes, or empty collection if none\n      */\n-    public synchronized Collection loadPersistentTypes(boolean devpath,\n+    public Collection loadPersistentTypes(boolean devpath,\n         ClassLoader envLoader) {\n+        if (_locking) {\n+            return loadPersistentTypesLocking(devpath, envLoader);\n+        } else {\n+            return loadPersistentTypesInternal(devpath, envLoader);\n+        }\n+    }\n+\n+    private synchronized Collection loadPersistentTypesLocking(boolean devpath, ClassLoader envLoader) {\n+        return loadPersistentTypesInternal(devpath, envLoader);\n+    }\n+\n+    private Collection loadPersistentTypesInternal(boolean devpath, ClassLoader envLoader) {\n         Set names = getPersistentTypeNames(devpath, envLoader);\n         if (names == null || names.isEmpty())\n             return Collections.EMPTY_LIST;\n \n         // attempt to load classes so that they get processed\n-        ClassLoader clsLoader = _conf.getClassResolverInstance().\n-            getClassLoader(getClass(), envLoader);\n+        ClassLoader clsLoader = _conf.getClassResolverInstance().getClassLoader(getClass(), envLoader);\n         List classes = new ArrayList(names.size());\n         Class cls;\n         for (Iterator itr = names.iterator(); itr.hasNext();) {\n@@ -1349,7 +1565,11 @@ Collection getPCSubclasses(Class cls) {\n     public void register(Class cls) {\n         // buffer registered classes until an oid metadata request is made,\n         // at which point we'll parse everything in the buffer\n+        if (_locking) {\n         synchronized (_registered) {\n+                _registered.add(cls);\n+            }\n+        } else {\n             _registered.add(cls);\n         }\n     }\n@@ -1379,7 +1599,12 @@ private void loadRegisteredClassMetaData(ClassLoader envLoader) {\n         // copy into new collection to avoid concurrent mod errors on reentrant\n         // registrations\n         Class[] reg;\n-        synchronized (_registered) {\n+        if (_locking) {\n+            synchronized (_registered) {\n+                reg = (Class[]) _registered.toArray(new Class[_registered.size()]);\n+                _registered.clear();\n+            }\n+        } else {\n             reg = (Class[]) _registered.toArray(new Class[_registered.size()]);\n             _registered.clear();\n         }\n@@ -1408,7 +1633,11 @@ private void loadRegisteredClassMetaData(ClassLoader envLoader) {\n             }\n         }\n         if (failed != null) {\n-            synchronized (_registered) {\n+            if(_locking){\n+                synchronized (_registered) {\n+                    _registered.addAll(failed);\n+                }\n+            }else{\n                 _registered.addAll(failed);\n             }\n         }\n@@ -1428,16 +1657,10 @@ private void processRegisteredClass(Class cls) {\n         // update subclass lists; synchronize on this because accessing _metas\n         // requires it\n         Class leastDerived = cls;\n-        synchronized (this) {\n-            ClassMetaData meta;\n-            for (Class anc = cls;\n-                (anc = PCRegistry.getPersistentSuperclass(anc)) != null;) {\n-                addToCollection(_subs, anc, cls, true);\n-                meta = (ClassMetaData) _metas.get(anc);\n-                if (meta != null)\n-                    meta.clearSubclassCache();\n-                leastDerived = anc;\n-            }\n+        if (_locking) {\n+        \tleastDerived = calcualteLeastDerivedLocking(cls);\n+        } else {\n+            leastDerived = calcualteLeastDerivedInternal(cls);\n         }\n \n         // update oid mappings if this is a base concrete class\n@@ -1467,25 +1690,67 @@ private void processRegisteredClass(Class cls) {\n \n         // update mappings from interfaces and non-pc superclasses to\n         // pc implementing types\n-        synchronized (_impls) {\n+        if (_locking) {\n+            synchronized (_impls) {\n+                updateImpls(cls, leastDerived, cls);\n+            }\n+        } else {\n             updateImpls(cls, leastDerived, cls);\n         }\n \n         // set alias for class\n         String alias = PCRegistry.getTypeAlias(cls);\n         if (alias != null) {\n-            synchronized (_aliases) {\n-                List classList = (List) _aliases.get(alias);\n-                if (classList == null) {\n-                    classList = new ArrayList(3);\n-                    _aliases.put(alias, classList);\n-                }\n-                if (!classList.contains(cls))\n-                    classList.add(cls);\n+            if(_locking){\n+                setAliasForClassLocking(alias, cls);\n+            }else{\n+                setAliasForClassInternal(alias, cls);\n             }\n         }\n     }\n-\n+    /**\n+     * Private worker method for use by processRegisterClasses.\n+     */\n+    private void setAliasForClassLocking(String alias, Class cls){\n+        synchronized(_aliases){\n+            setAliasForClassInternal(alias, cls);\n+        }\n+    }\n+    /**\n+     * Private worker method for use by processRegisterClasses.\n+     */\n+    private void setAliasForClassInternal(String alias, Class cls){\n+        List classList = (List) _aliases.get(alias);\n+        if (classList == null) {\n+            classList = new ArrayList(3);\n+            _aliases.put(alias, classList);\n+        }\n+        if (!classList.contains(cls))\n+            classList.add(cls);\n+    }\n+    /**\n+     * Private worker method for use by processRegisterClasses.\n+     */\n+    private synchronized Class calcualteLeastDerivedLocking(Class cls){\n+        return calcualteLeastDerivedInternal(cls);\n+    }\n+    /**\n+     * Private worker method for use by processRegisterClasses.\n+     */\n+    private Class calcualteLeastDerivedInternal(Class cls){\n+        Class leastDerived = cls;\n+        ClassMetaData meta;\n+        for (Class anc = cls; (anc = PCRegistry.getPersistentSuperclass(anc)) != null;) {\n+            addToCollection(_subs, anc, cls, true);\n+            meta = (ClassMetaData) _metas.get(anc);\n+            if (meta != null)\n+                meta.clearSubclassCache();\n+            leastDerived = anc;\n+        }\n+        \n+        return leastDerived;\n+    }\n+    \n     /**\n      * Update the list of implementations of base classes and interfaces.\n      */\n@@ -1535,7 +1800,18 @@ private boolean isLeastDerivedImpl(Class inter, Class cls) {\n      */\n     private void addToCollection(Map map, Class key, Class value,\n         boolean inheritance) {\n+        if(_locking){\n+            addToCollectionLocking(map, key, value, inheritance);\n+        }else{\n+            addToCollectionInternal(map, key, value, inheritance);\n+        }\n+    }\n+    private void addToCollectionLocking(Map map, Class key, Class value, boolean inheritance) {\n         synchronized (map) {\n+            addToCollectionInternal(map, key, value, inheritance);\n+        }\n+    }\n+    private void addToCollectionInternal(Map map, Class key, Class value, boolean inheritance) {\n             Collection coll = (Collection) map.get(key);\n             if (coll == null) {\n                 if (inheritance) {\n@@ -1548,7 +1824,6 @@ private void addToCollection(Map map, Class key, Class value,\n             }\n             coll.add(value);\n         }\n-    }\n \n     ///////////////////////////////\n     // Configurable implementation\n@@ -1567,6 +1842,16 @@ public void endConfiguration() {\n         initializeMetaDataFactory();\n         if (_implGen == null)\n             _implGen = new InterfaceImplGenerator(this);\n+        if (_preload == true) {\n+            _oids = new HashMap();\n+            _impls = new HashMap();\n+            _ifaces = new HashMap();\n+            _aliases = new HashMap();\n+            _pawares = new HashMap();\n+            _nonMapped = new HashMap();\n+            _subs = new HashMap();\n+            // Wait till we're done loading MetaData to remove lock.\n+        }            \n     }\n \n     private void initializeMetaDataFactory() {\n@@ -1585,8 +1870,20 @@ private void initializeMetaDataFactory() {\n     /**\n      * Return query metadata for the given class, name, and classloader.\n      */\n-    public synchronized QueryMetaData getQueryMetaData(Class cls, String name,\n+    public QueryMetaData getQueryMetaData(Class cls, String name,\n         ClassLoader envLoader, boolean mustExist) {\n+        if(_locking){\n+            return getQueryMetaDataLocking(cls, name, envLoader, mustExist);\n+        }else{\n+            return getQueryMetaDataInternal(cls, name, envLoader, mustExist);\n+        }\n+    }\n+    private synchronized QueryMetaData getQueryMetaDataLocking(Class cls, String name, ClassLoader envLoader,\n+        boolean mustExist) {\n+        return getQueryMetaDataInternal(cls, name, envLoader, mustExist);\n+    }\n+\n+    private QueryMetaData getQueryMetaDataInternal(Class cls, String name, ClassLoader envLoader, boolean mustExist) {\n         QueryMetaData meta = getQueryMetaDataInternal(cls, name, envLoader);\n         if (meta == null) {\n             // load all the metadatas for all the known classes so that\n@@ -1597,12 +1894,10 @@ public synchronized QueryMetaData getQueryMetaData(Class cls, String name,\n \n         if (meta == null && mustExist) {\n             if (cls == null) {\n-                throw new MetaDataException(_loc.get\n-                    (\"no-named-query-null-class\", \n-                        getPersistentTypeNames(false, envLoader), name));\n+                throw new MetaDataException(_loc.get(\"no-named-query-null-class\", getPersistentTypeNames(false,\n+                    envLoader), name));\n             } else {\n-                throw new MetaDataException(_loc.get(\"no-named-query\",\n-                    cls, name));\n+                throw new MetaDataException(_loc.get(\"no-named-query\", cls, name));\n             }\n         }\n \n@@ -1655,26 +1950,45 @@ private QueryMetaData getQueryMetaDataInternal(Class cls, String name,\n     /**\n      * Return the cached query metadata.\n      */\n-    public synchronized QueryMetaData[] getQueryMetaDatas() {\n-        return (QueryMetaData[]) _queries.values().toArray\n-            (new QueryMetaData[_queries.size()]);\n+    public QueryMetaData[] getQueryMetaDatas() {\n+        if (_locking) {\n+            synchronized (this) {\n+                return (QueryMetaData[]) _queries.values().toArray(new QueryMetaData[_queries.size()]);\n+            }\n+        } else {\n+            return (QueryMetaData[]) _queries.values().toArray(new QueryMetaData[_queries.size()]);\n+        }\n     }\n \n     /**\n      * Return the cached query metadata for the given name.\n      */\n-    public synchronized QueryMetaData getCachedQueryMetaData(Class cls,\n+    public QueryMetaData getCachedQueryMetaData(Class cls,\n         String name) {\n-        return (QueryMetaData) _queries.get(getQueryKey(cls, name));\n+        if (_locking) {\n+            synchronized (this) {\n+                return (QueryMetaData) _queries.get(getQueryKey(cls, name));\n+            }\n+        } else {\n+            return (QueryMetaData) _queries.get(getQueryKey(cls, name));\n+        }\n     }\n \n     /**\n      * Add a new query metadata to the repository and return it.\n      */\n-    public synchronized QueryMetaData addQueryMetaData(Class cls, String name) {\n-        QueryMetaData meta = newQueryMetaData(cls, name);\n-        _queries.put(getQueryKey(meta), meta);\n-        return meta;\n+    public QueryMetaData addQueryMetaData(Class cls, String name) {\n+        if (_locking) {\n+            synchronized (this) {\n+                QueryMetaData meta = newQueryMetaData(cls, name);\n+                _queries.put(getQueryKey(meta), meta);\n+                return meta;\n+            }\n+        }else{\n+            QueryMetaData meta = newQueryMetaData(cls, name);\n+            _queries.put(getQueryKey(meta), meta);\n+            return meta;   \n+        }\n     }\n \n     /**\n@@ -1689,19 +2003,35 @@ protected QueryMetaData newQueryMetaData(Class cls, String name) {\n     /**\n      * Remove the given query metadata from the repository.\n      */\n-    public synchronized boolean removeQueryMetaData(QueryMetaData meta) {\n-        if (meta == null)\n-            return false;\n-        return _queries.remove(getQueryKey(meta)) != null;\n+    public  boolean removeQueryMetaData(QueryMetaData meta) {\n+        if(_locking){\n+            synchronized (this) {\n+                if (meta == null)\n+                    return false;\n+                return _queries.remove(getQueryKey(meta)) != null;\n+            }\n+        }else{\n+            if (meta == null)\n+                return false;\n+            return _queries.remove(getQueryKey(meta)) != null;\n+        }\n     }\n \n     /**\n      * Remove query metadata for the given class name if in the repository.\n      */\n-    public synchronized boolean removeQueryMetaData(Class cls, String name) {\n-        if (name == null)\n-            return false;\n-        return _queries.remove(getQueryKey(cls, name)) != null;\n+    public boolean removeQueryMetaData(Class cls, String name) {\n+        if (_locking) {\n+            synchronized (this) {\n+                if (name == null)\n+                    return false;\n+                return _queries.remove(getQueryKey(cls, name)) != null;\n+            }\n+        } else {\n+            if (name == null)\n+                return false;\n+            return _queries.remove(getQueryKey(cls, name)) != null;\n+        }\n     }\n \n     /**\n@@ -1733,7 +2063,19 @@ protected static Object getQueryKey(Class cls, String name) {\n     /**\n      * Return sequence metadata for the given name and classloader.\n      */\n-    public synchronized SequenceMetaData getSequenceMetaData(String name,\n+    public SequenceMetaData getSequenceMetaData(String name,\n+        ClassLoader envLoader, boolean mustExist) {\n+        if(_locking){\n+            return getSequenceMetaDataLocking(name, envLoader, mustExist);\n+        }else{\n+            return getSequenceMetaDataInternal(name, envLoader, mustExist);\n+        }\n+    }\n+    private synchronized SequenceMetaData getSequenceMetaDataLocking(String name,\n+        ClassLoader envLoader, boolean mustExist) {\n+        return getSequenceMetaDataInternal(name, envLoader, mustExist);\n+    }\n+    private SequenceMetaData getSequenceMetaDataInternal(String name,\n         ClassLoader envLoader, boolean mustExist) {\n         SequenceMetaData meta = getSequenceMetaDataInternal(name, envLoader);\n         if (meta == null && SequenceMetaData.NAME_SYSTEM.equals(name)) {\n@@ -1806,26 +2148,44 @@ private SequenceMetaData getSequenceMetaDataInternal(String name,\n     /**\n      * Return the cached sequence metadata.\n      */\n-    public synchronized SequenceMetaData[] getSequenceMetaDatas() {\n-        return (SequenceMetaData[]) _seqs.values().toArray\n-            (new SequenceMetaData[_seqs.size()]);\n+    public SequenceMetaData[] getSequenceMetaDatas() {\n+        if (_locking) {\n+            synchronized (this) {\n+                return (SequenceMetaData[]) _seqs.values().toArray(new SequenceMetaData[_seqs.size()]);\n+            }\n+        } else {\n+            return (SequenceMetaData[]) _seqs.values().toArray(new SequenceMetaData[_seqs.size()]);\n+        }\n     }\n \n     /**\n      * Return the cached a sequence metadata for the given name.\n      */\n-    public synchronized SequenceMetaData getCachedSequenceMetaData(\n-        String name) {\n-        return (SequenceMetaData) _seqs.get(name);\n+    public SequenceMetaData getCachedSequenceMetaData(String name) {\n+        if (_locking) {\n+            synchronized (this) {\n+                return (SequenceMetaData) _seqs.get(name);\n+            }\n+        } else {\n+            return (SequenceMetaData) _seqs.get(name);\n+        }\n     }\n \n     /**\n      * Add a new sequence metadata to the repository and return it.\n      */\n-    public synchronized SequenceMetaData addSequenceMetaData(String name) {\n-        SequenceMetaData meta = newSequenceMetaData(name);\n-        _seqs.put(name, meta);\n-        return meta;\n+    public SequenceMetaData addSequenceMetaData(String name) {\n+        if (_locking) {\n+            synchronized (this) {\n+                SequenceMetaData meta = newSequenceMetaData(name);\n+                _seqs.put(name, meta);\n+                return meta;\n+            }\n+        } else {\n+            SequenceMetaData meta = newSequenceMetaData(name);\n+            _seqs.put(name, meta);\n+            return meta;\n+        }\n     }\n \n     /**\n@@ -1838,44 +2198,76 @@ protected SequenceMetaData newSequenceMetaData(String name) {\n     /**\n      * Remove the given sequence metadata from the repository.\n      */\n-    public synchronized boolean removeSequenceMetaData(SequenceMetaData meta) {\n-        if (meta == null)\n-            return false;\n-        return _seqs.remove(meta.getName()) != null;\n+    public boolean removeSequenceMetaData(SequenceMetaData meta) {\n+        if (_locking) {\n+            synchronized (this) {\n+                if (meta == null)\n+                    return false;\n+                return _seqs.remove(meta.getName()) != null;\n+            }\n+        } else {\n+            if (meta == null)\n+                return false;\n+            return _seqs.remove(meta.getName()) != null;\n+        }\n     }\n \n     /**\n      * Remove sequence metadata for the name if in the repository.\n      */\n-    public synchronized boolean removeSequenceMetaData(String name) {\n-        if (name == null)\n-            return false;\n-        return _seqs.remove(name) != null;\n+    public boolean removeSequenceMetaData(String name) {\n+        if (_locking) {\n+            synchronized (this) {\n+                if (name == null)\n+                    return false;\n+                return _seqs.remove(name) != null;\n+            }\n+        }else{\n+            if (name == null)\n+                return false;\n+            return _seqs.remove(name) != null;\n+        }\n     }\n \n     /**\n      * Add the given system lifecycle listener.\n      */\n-    public synchronized void addSystemListener(Object listener) {\n-        // copy to avoid issues with ListenerList and avoid unncessary\n-        // locking on the list during runtime\n-        LifecycleEventManager.ListenerList listeners = new\n-            LifecycleEventManager.ListenerList(_listeners);\n-        listeners.add(listener);\n-        _listeners = listeners;\n+    public void addSystemListener(Object listener) {\n+        if (_locking) {\n+            synchronized (this) {\n+                // copy to avoid issues with ListenerList and avoid unncessary\n+                // locking on the list during runtime\n+                LifecycleEventManager.ListenerList listeners = new LifecycleEventManager.ListenerList(_listeners);\n+                listeners.add(listener);\n+                _listeners = listeners;\n+            }\n+        } else {\n+            LifecycleEventManager.ListenerList listeners = new LifecycleEventManager.ListenerList(_listeners);\n+            listeners.add(listener);\n+            _listeners = listeners;\n+        }\n     }\n \n     /**\n      * Remove the given system lifecycle listener.\n      */\n-    public synchronized boolean removeSystemListener(Object listener) {\n+    public boolean removeSystemListener(Object listener) {\n+        if (_locking) {\n+            return removeSystemListenerLocking(listener);\n+        } else {\n+            return removeSystemListenerInternal(listener);\n+        }\n+    }\n+    private synchronized boolean removeSystemListenerLocking(Object listener) {\n+        return removeSystemListenerInternal(listener);\n+    }\n+    private boolean removeSystemListenerInternal(Object listener) {\n         if (!_listeners.contains(listener))\n             return false;\n \n         // copy to avoid issues with ListenerList and avoid unncessary\n         // locking on the list during runtime\n-        LifecycleEventManager.ListenerList listeners = new\n-            LifecycleEventManager.ListenerList(_listeners);\n+        LifecycleEventManager.ListenerList listeners = new LifecycleEventManager.ListenerList(_listeners);\n         listeners.remove(listener);\n         _listeners = listeners;\n         return true;\n@@ -1891,7 +2283,17 @@ public synchronized boolean removeSystemListener(Object listener) {\n     /**\n      * Free the resources used by this repository. Closes all user sequences.\n      */\n-    public synchronized void close() {\n+    public void close() {\n+        if(_locking){\n+            closeLocking();\n+        }else{\n+            closeInternal();\n+        }\n+    }\n+    private synchronized void closeLocking() {\n+        closeInternal();\n+    }\n+    private void closeInternal() {\n         SequenceMetaData[] smds = getSequenceMetaDatas();\n         for (int i = 0; i < smds.length; i++)\n             smds[i].close();\n@@ -1931,7 +2333,17 @@ public boolean equals(Object obj)\n      * @param fmd\n      * @return XML metadata\n      */\n-    public synchronized XMLMetaData getXMLMetaData(FieldMetaData fmd) {\n+    public XMLMetaData getXMLMetaData(FieldMetaData fmd) {\n+        if(_locking){\n+            return getXMLMetaDataLocking(fmd);\n+        }else{\n+            return getXMLMetaDataInternal(fmd);\n+        }\n+    }\n+    private synchronized XMLMetaData getXMLMetaDataLocking(FieldMetaData fmd) {\n+        return getXMLMetaDataInternal(fmd);\n+    }\n+    private XMLMetaData getXMLMetaDataInternal(FieldMetaData fmd) {\n         Class cls = fmd.getDeclaredType();\n         // check if cached before\n         XMLMetaData xmlmeta = (XMLClassMetaData) _xmlmetas.get(cls);\n@@ -1957,7 +2369,11 @@ public XMLClassMetaData addXMLMetaData(Class type, String name) {\n         \n         // synchronize on this rather than the map, because all other methods\n         // that access _xmlmetas are synchronized on this\n+        if(_locking){\n         synchronized (this) {\n+                    _xmlmetas.put(type, meta);\n+                }\n+        }else{\n             _xmlmetas.put(type, meta);\n         }\n         return meta;\n@@ -1992,6 +2408,17 @@ protected XMLClassMetaData newXMLClassMetaData(Class type, String name) {\n     public XMLFieldMetaData newXMLFieldMetaData(Class type, String name) {\n         return new XMLFieldMetaData(type, name);\n     }\n+    \n+    /**\n+     * This helper method returns true if Options paramater has the property Preload\n+     * set to true.\n+     */\n+    public static boolean needsPreload(Options o) {\n+        if (o.getBooleanProperty(PRELOAD_STR) == true) {\n+            return true;\n+        }\n+        return false;\n+    }\n \n     /**\n      * Analyzes the list of ClassMetaData in the supplied list for any which has foreign keys to other ClassMetaData \n@@ -2090,7 +2517,6 @@ public XMLFieldMetaData newXMLFieldMetaData(Class type, String name) {\n         return returnList;\n     }\n \n-\n     /**\n      * Linked list node class for managing any foreign keys in the identity of a ClassMetaData instance.\n      * "},{"sha":"541703691524e414ccfe32e343978189875be318","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties?ref=ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5","patch":"@@ -324,3 +324,8 @@ unexpected_proxy_sm_attribute_type: Unexpected attribute type \"{1}\" for \\\n cmd-discover-cycle: A cycle was detected while resolving the identity \\\n     references for type \"{0}\".  The original process buffer ordering \\\n     will be used.\n+repos-initializeEager-none: No persistent metadata found for loading during initialization. \\\n+    The persistent classes must be listed in persistence unit configuration to be loaded during initialization.\n+repos-initializeEager-found: The following classes are being preloaded \"{0}\".\t   \n+repos-initializeEager-error: Unexpected error during early loading of entity metadata during initialization. \\\n+    See nested stacktrace for details.\t  "},{"sha":"919258cd6b7165d06afae66d84c5c94a914ca777","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPrivHelper.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPrivHelper.java","raw_url":"https://github.com/apache/openjpa/raw/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPrivHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPrivHelper.java?ref=ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5","patch":"@@ -905,9 +905,9 @@ public Object run() {\n      *   \n      * @return MultiClassLoader\n      */\n-    public static final PrivilegedAction newMultiClassLoaderAction() {\n+    public static final PrivilegedAction<MultiClassLoader> newMultiClassLoaderAction() {\n         return new PrivilegedAction() {\n-            public Object run() {\n+            public MultiClassLoader run() {\n                 return new MultiClassLoader();\n             }\n         };"},{"sha":"953fe7c8c0d29e24c05890d45d09ddc14ab70079","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","status":"modified","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","raw_url":"https://github.com/apache/openjpa/raw/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/PersistenceProviderImpl.java?ref=ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5","patch":"@@ -20,24 +20,30 @@\n \n import java.lang.instrument.ClassFileTransformer;\n import java.lang.instrument.IllegalClassFormatException;\n+import java.security.AccessController;\n import java.security.ProtectionDomain;\n import java.util.Map;\n+\n import javax.persistence.EntityManager;\n import javax.persistence.spi.ClassTransformer;\n import javax.persistence.spi.PersistenceProvider;\n import javax.persistence.spi.PersistenceUnitInfo;\n \n import org.apache.openjpa.conf.BrokerValue;\n+import org.apache.openjpa.conf.MetaDataRepositoryValue;\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\n import org.apache.openjpa.enhance.PCClassFileTransformer;\n+import org.apache.openjpa.kernel.AbstractBrokerFactory;\n import org.apache.openjpa.kernel.Bootstrap;\n import org.apache.openjpa.kernel.BrokerFactory;\n import org.apache.openjpa.lib.conf.Configuration;\n import org.apache.openjpa.lib.conf.ConfigurationProvider;\n import org.apache.openjpa.lib.conf.Configurations;\n import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\n import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Options;\n import org.apache.openjpa.meta.MetaDataModes;\n import org.apache.openjpa.meta.MetaDataRepository;\n import org.apache.openjpa.util.ClassResolver;\n@@ -79,6 +85,8 @@ public OpenJPAEntityManagerFactory createEntityManagerFactory(String name,\n                 return null;\n \n             BrokerFactory factory = getBrokerFactory(cp, poolValue, null);\n+            preloadMetaDataRepository(factory);\n+            \n             return JPAFacadeHelper.toEntityManagerFactory(factory);\n         } catch (Exception e) {\n             throw PersistenceExceptions.toPersistenceException(e);\n@@ -153,6 +161,7 @@ public OpenJPAEntityManagerFactory createContainerEntityManagerFactory(\n                         _loc.get(\"transformer-registration-error\", pui));\n                 }\n             }\n+            preloadMetaDataRepository(factory);           \n             return JPAFacadeHelper.toEntityManagerFactory(factory);\n         } catch (Exception e) {\n             throw PersistenceExceptions.toPersistenceException(e);\n@@ -177,6 +186,30 @@ protected String getDefaultBrokerAlias() {\n     protected OpenJPAConfiguration newConfigurationImpl() {\n         return new OpenJPAConfigurationImpl();\n     }\n+\n+    /**\n+     * Private worker method that will call to the MetaDataRepository to preload if the provided\n+     * BrokerFactory is configured to do so.\n+     */\n+    private void preloadMetaDataRepository(BrokerFactory factory){\n+        // We need to wait to preload until after we get back a fully configured/instantiated\n+        // BrokerFactory. This is because it is possible that someone has extended OpenJPA\n+        // functions and they need to be allowed time to configure themselves before we go off and\n+        // start instanting configurable objects (ie:openjpa.MetaDataRepository). Don't catch\n+        // any exceptions here because we want to fail-fast.\n+        OpenJPAConfiguration conf = factory.getConfiguration();\n+        Options o = Configurations.parseProperties(Configurations.getProperties(conf.getMetaDataRepository()));\n+        if (MetaDataRepository.needsPreload(o) == true) {\n+            MetaDataRepository mdr = conf.getMetaDataRepositoryInstance(); \n+            mdr.setValidate(MetaDataRepository.VALIDATE_RUNTIME, true);\n+            mdr.setResolve(MetaDataRepository.MODE_MAPPING_INIT, true);\n+            \n+            // Load persistent classes and hook in subclasser\n+            ((AbstractBrokerFactory) factory).loadPersistentTypes((ClassLoader) AccessController\n+                .doPrivileged(J2DoPrivHelper.getContextClassLoaderAction()));\n+            mdr.preload();\n+        }\n+    }\n     \n     /**\n      * Java EE 5 class transformer."}]}

