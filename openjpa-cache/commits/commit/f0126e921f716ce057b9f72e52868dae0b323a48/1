{"sha":"f0126e921f716ce057b9f72e52868dae0b323a48","node_id":"MDY6Q29tbWl0MjA2MzY0OmYwMTI2ZTkyMWY3MTZjZTA1N2I5ZjcyZTUyODY4ZGFlMGIzMjNhNDg=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-08-25T14:25:36Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2008-08-25T14:25:36Z"},"message":"OPENJPA-697: Upgrade version strategy for multiple numeric-valued columns to support @VersionColumns.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@688734 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"3e15d52d8658f393dcb071643b07d5a806542a51","url":"https://api.github.com/repos/apache/openjpa/git/trees/3e15d52d8658f393dcb071643b07d5a806542a51"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/f0126e921f716ce057b9f72e52868dae0b323a48","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/f0126e921f716ce057b9f72e52868dae0b323a48","html_url":"https://github.com/apache/openjpa/commit/f0126e921f716ce057b9f72e52868dae0b323a48","comments_url":"https://api.github.com/repos/apache/openjpa/commits/f0126e921f716ce057b9f72e52868dae0b323a48/comments","author":null,"committer":null,"parents":[{"sha":"322689a573483d14cdd807b5881f707a1ff8a3f9","url":"https://api.github.com/repos/apache/openjpa/commits/322689a573483d14cdd807b5881f707a1ff8a3f9","html_url":"https://github.com/apache/openjpa/commit/322689a573483d14cdd807b5881f707a1ff8a3f9"}],"stats":{"total":498,"additions":434,"deletions":64},"files":[{"sha":"a46ea7af927ce6ab68264fb25771665dd955c7a4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","raw_url":"https://github.com/apache/openjpa/raw/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java?ref=f0126e921f716ce057b9f72e52868dae0b323a48","patch":"@@ -50,6 +50,7 @@\n import org.apache.openjpa.jdbc.meta.strats.MaxEmbeddedByteArrayFieldStrategy;\n import org.apache.openjpa.jdbc.meta.strats.MaxEmbeddedCharArrayFieldStrategy;\n import org.apache.openjpa.jdbc.meta.strats.MaxEmbeddedClobFieldStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.MultiColumnVersionStrategy;\n import org.apache.openjpa.jdbc.meta.strats.NanoPrecisionTimestampVersionStrategy;\n import org.apache.openjpa.jdbc.meta.strats.NoneClassStrategy;\n import org.apache.openjpa.jdbc.meta.strats.NoneDiscriminatorStrategy;\n@@ -626,6 +627,8 @@ protected VersionStrategy instantiateVersionStrategy(String name,\n \n         if (NumberVersionStrategy.ALIAS.equals(name))\n             strat = NumberVersionStrategy.class;\n+        else if (MultiColumnVersionStrategy.ALIAS.equals(name))\n+        \tstrat = MultiColumnVersionStrategy.class;\n         else if (TimestampVersionStrategy.ALIAS.equals(name))\n             strat = TimestampVersionStrategy.class;\n         else if (NanoPrecisionTimestampVersionStrategy.ALIAS.equals(name))"},{"sha":"043db492f06152a07c4baec351347c1e9061cf2a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ColumnVersionStrategy.java","status":"modified","additions":105,"deletions":59,"changes":164,"blob_url":"https://github.com/apache/openjpa/blob/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ColumnVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ColumnVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ColumnVersionStrategy.java?ref=f0126e921f716ce057b9f72e52868dae0b323a48","patch":"@@ -18,9 +18,12 @@\n  */\n package org.apache.openjpa.jdbc.meta.strats;\n \n+import java.lang.reflect.Array;\n import java.math.BigDecimal;\n import java.sql.SQLException;\n import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Set;\n \n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n@@ -36,8 +39,11 @@\n import org.apache.openjpa.kernel.StoreManager;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.InternalException;\n import org.apache.openjpa.util.MetaDataException;\n \n+import serp.util.Numbers;\n+\n /**\n  * Uses a single column and corresponding version object.\n  *\n@@ -54,6 +60,13 @@\n      * strategy uses. This method is only used during mapping installation.\n      */\n     protected abstract int getJavaType();\n+    \n+    /**\n+     * Return the code from {@link JavaTypes} for the version value this given\n+     * column index uses. Only used if the version strategy employs more than\n+     * one column. \n+     */\n+    protected abstract int getJavaType(int i);\n \n     /**\n      * Return the next version given the current one, which may be null.\n@@ -73,7 +86,12 @@ protected int compare(Object v1, Object v2) {\n             return -1;\n         if (v2 == null)\n             return 1;\n-\n+        \n+        if (v1.getClass().isArray()) {\n+        \tif (!v2.getClass().isArray())\n+        \t\tthrow new InternalException();\n+        \treturn compare((Object[])v1, (Object[])v2);\n+        }\n         if (v1.getClass() != v2.getClass()) {\n             if (v1 instanceof Number && !(v1 instanceof BigDecimal))\n                 v1 = new BigDecimal(((Number) v1).doubleValue());\n@@ -85,6 +103,29 @@ protected int compare(Object v1, Object v2) {\n         return ((Comparable) v1).compareTo(v2);\n     }\n \n+\n+\t/**\n+\t * Compare each element of the given arrays that must be of equal size. \n+\t * \n+\t * @return If each element comparison results into same sign then returns \n+\t * that sign. If some elements compare equal and all the rest has the same\n+\t * sign then return that sign. Otherwise, return 1.\n+\t */\n+\tprotected int compare(Object[] a1, Object[] a2) {\n+\t\tif (a1.length != a2.length)\n+\t    \tthrow new InternalException();\n+\t\tSet<Integer> comps = new HashSet<Integer>();\n+\t\tfor (int i = 0; i < a1.length; i++)\n+\t\t\tcomps.add(sign(compare(a1[i], a2[i])));\n+\t\tif (comps.size() == 1 || (comps.size() == 2 && comps.remove(0)))\n+\t\t\treturn comps.iterator().next();\n+\t\treturn 1;\n+\t}\n+\t\n+\tint sign(int i) {\n+\t\treturn (i > 0) ? 1 : (i == 0) ? 0 : -1;\n+\t}\n+\n     public void map(boolean adapt) {\n         ClassMapping cls = vers.getClassMapping();\n         if (cls.getJoinablePCSuperclassMapping() != null\n@@ -95,18 +136,35 @@ public void map(boolean adapt) {\n         info.assertNoJoin(vers, true);\n         info.assertNoForeignKey(vers, !adapt);\n         info.assertNoUnique(vers, false);\n-\n-        Column tmplate = new Column();\n-        tmplate.setJavaType(getJavaType());\n-        tmplate.setName(\"versn\");\n-\n-        Column[] cols = info.getColumns(vers, new Column[]{ tmplate }, adapt);\n-        cols[0].setVersionStrategy(this);\n-        vers.setColumns(cols);\n-        vers.setColumnIO(info.getColumnIO());\n-\n-        Index idx = info.getIndex(vers, cols, adapt);\n-        vers.setIndex(idx);\n+        if (info.getColumns().size() > 1) {\n+        \tColumn[] templates = new Column[info.getColumns().size()];\n+        \tfor (int i = 0; i < info.getColumns().size(); i++) {\n+                templates[i] = new Column();\n+        \t\tColumn infoColumn = (Column)info.getColumns().get(i);\n+        \t\ttemplates[i].setType(infoColumn.getType());\n+        \t\ttemplates[i].setSize(infoColumn.getSize());\n+        \t\ttemplates[i].setDecimalDigits(infoColumn.getDecimalDigits());\n+        \t\ttemplates[i].setJavaType(getJavaType(i));\n+        \t\ttemplates[i].setName(\"versn\" +i);\n+        \t}\n+        \tColumn[] cols = info.getColumns(vers, templates, adapt);\n+        \tfor (int i = 0; i < cols.length; i++)\n+        \t\tcols[i].setVersionStrategy(this);\n+        \tvers.setColumns(cols);\n+        \tvers.setColumnIO(info.getColumnIO());\n+        } else {\n+           Column tmplate = new Column();\n+           tmplate.setJavaType(getJavaType());\n+           tmplate.setName(\"versn\");\n+\n+           Column[] cols = info.getColumns(vers, new Column[]{ tmplate }, adapt);\n+           cols[0].setVersionStrategy(this);\n+           vers.setColumns(cols);\n+           vers.setColumnIO(info.getColumnIO());\n+\n+           Index idx = info.getIndex(vers, cols, adapt);\n+           vers.setIndex(idx);\n+        }\n     }\n \n     public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n@@ -118,7 +176,7 @@ public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n             Row.ACTION_INSERT, sm, true);\n         for (int i = 0; i < cols.length; i++)\n             if (io.isInsertable(i, initial == null))\n-                row.setObject(cols[i], initial);\n+                row.setObject(cols[i], getColumnValue(initial, i));\n \n         // set initial version into state manager\n         Object nextVersion;\n@@ -143,9 +201,9 @@ public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n         // set where and update conditions on row\n         for (int i = 0; i < cols.length; i++) {\n             if (curVersion != null && sm.isVersionCheckRequired())\n-                row.whereObject(cols[i], curVersion);\n+                row.whereObject(cols[i], getColumnValue(curVersion, i));\n             if (vers.getColumnIO().isUpdatable(i, nextVersion == null))\n-                row.setObject(cols[i], nextVersion);\n+                row.setObject(cols[i], getColumnValue(nextVersion, i));\n         }\n \n         if (nextVersion != null)\n@@ -162,11 +220,7 @@ public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n         Object curVersion = sm.getVersion();\n         Object cur;\n         for (int i = 0; i < cols.length; i++) {\n-            if (cols.length == 1 || curVersion == null)\n-                cur = curVersion;\n-            else\n-                cur = ((Object[]) curVersion)[i];\n-\n+            cur = getColumnValue(curVersion, i);\n             // set where and update conditions on row\n             if (cur != null)\n                 row.whereObject(cols[i], cur);\n@@ -186,19 +240,8 @@ public Object load(OpenJPAStateManager sm, JDBCStore store, Result res)\n         if (!res.contains(cols[0]))\n             return null;\n \n-        Object version = null;\n-        if (cols.length > 0)\n-            version = new Object[cols.length];\n-        Object cur;\n-        for (int i = 0; i < cols.length; i++) {\n-            if (i > 0 && !res.contains(cols[i]))\n-                return null;\n-            cur = res.getObject(cols[i], -1, null);\n-            if (cols.length == 1)\n-                version = cur;\n-            else\n-                ((Object[]) version)[i] = cur;\n-        }\n+        Object version = populateFromResult(res);\n+\n         // OPENJPA-662 Allow a null StateManager because this method may just be\n         // invoked to get the result of projection query\n         if (sm != null)\n@@ -220,31 +263,8 @@ public boolean checkVersion(OpenJPAStateManager sm, JDBCStore store,\n                 return false;\n \n             Object memVersion = sm.getVersion();\n-            Object dbVersion = null;\n-            if (cols.length > 1)\n-                dbVersion = new Object[cols.length];\n-\n-            boolean refresh = false;\n-            Object mem, db;\n-            for (int i = 0; i < cols.length; i++) {\n-                db = res.getObject(cols[i], -1, null);\n-                if (cols.length == 1)\n-                    dbVersion = db;\n-                else\n-                    ((Object[]) dbVersion)[i] = db;\n-\n-                // if we haven't already determined that we need a refresh,\n-                // check if the mem version is earlier than the db one\n-                if (!refresh) {\n-                    if (cols.length == 1 || memVersion == null)\n-                        mem = memVersion;\n-                    else\n-                        mem = ((Object[]) memVersion)[i];\n-\n-                    if (mem == null || (db != null && compare(mem, db) < 0))\n-                        refresh = true;\n-                }\n-            }\n+            Object dbVersion  = populateFromResult(res);\n+            boolean refresh   = compare(memVersion, dbVersion) < 0;\n \n             if (updateVersion)\n                 sm.setVersion(dbVersion);\n@@ -267,4 +287,30 @@ public int compareVersion(Object v1, Object v2) {\n             return StoreManager.VERSION_LATER;\n         return StoreManager.VERSION_SAME;\n     }\n+        \n+    /**\n+     * Populate values of a version object from the given result.\n+     * \n+     * @return a single Object or an array depending on whether using a single\n+     * or multiple columns being used for representation.\n+    */\n+    Object populateFromResult(Result res) throws SQLException {\n+        if (res == null)\n+ \t\treturn null;\n+    \t\n+        Column[] cols = vers.getColumns();\n+        Object[] values = new Object[cols.length];\n+        for (int i = 0; i < cols.length; i++) {\n+            values[i] = res.getObject(cols[i], -1, null);\n+        }\n+        return (cols.length == 1) ? values[0] : values;\n+    }\n+    \n+    Object getColumnValue(Object o, int idx) {\n+    \tif (o == null) \n+    \t\treturn null;\n+    \tif (o.getClass().isArray())\n+    \t\treturn Array.get(o, idx);\n+    \treturn o;\n+    }\n }"},{"sha":"d69114a83e556c263ce7a5f5a2c5cd7e8cbf1c8c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MultiColumnVersionStrategy.java","status":"added","additions":113,"deletions":0,"changes":113,"blob_url":"https://github.com/apache/openjpa/blob/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MultiColumnVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MultiColumnVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MultiColumnVersionStrategy.java?ref=f0126e921f716ce057b9f72e52868dae0b323a48","patch":"@@ -0,0 +1,113 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.jdbc.meta.strats;\r\n+\r\n+import java.util.Arrays;\r\n+import java.util.List;\r\n+\r\n+import org.apache.commons.lang.StringUtils;\r\n+import org.apache.openjpa.jdbc.schema.Column;\r\n+import org.apache.openjpa.jdbc.schema.Schemas;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+\r\n+import serp.util.Numbers;\r\n+\r\n+/**\r\n+ * Uses multiple version numbers spanning multiple columns for optimistic \r\n+ * versioning.\r\n+ * \r\n+ * @since 1.3.0\r\n+ *\r\n+ * @author Pinaki Poddar\r\n+ */\r\n+public class MultiColumnVersionStrategy extends NumberVersionStrategy {\r\n+\r\n+    public static final String ALIAS = \"version-numbers\";\r\n+    \r\n+    private Number[] _initials = null;\r\n+    private Integer[] _javaTypes;\r\n+    \r\n+    @Override\r\n+    public void initialize() {\r\n+    \tif (_initials == null) {\r\n+    \t\tColumn[] cols = vers.getColumns();\r\n+    \t\t_initials = new Number[cols.length];\r\n+    \t\tfor (int i = 0; i < cols.length; i++) {\r\n+    \t\t\t_initials[i] = nextValue(Numbers.valueOf(0), getJavaType(i));\r\n+    \t\t}\r\n+    \t}\r\n+    \tsuper.initialize();\r\n+    }\r\n+    \t\r\n+    /**\r\n+     * Set the initial value for version columns. Defaults to 1 for each column.\r\n+     */\r\n+    public void setInitialValues(Number[] initial) {\r\n+    \t_initials = new Number[initial.length];\r\n+    \tSystem.arraycopy(initial, 0, _initials, 0, initial.length);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Return the initial values for version columns. Defaults to 1 for each \r\n+     * column.\r\n+     */\r\n+    public Number[] getInitialValues() {\r\n+    \treturn _initials;\r\n+    }\r\n+\r\n+    public String getAlias() {\r\n+        return ALIAS;\r\n+    }\r\n+    \r\n+    protected int getJavaType() {\r\n+        return JavaTypes.ARRAY;\r\n+    }\r\n+    \r\n+    protected int getJavaType(int i) {\r\n+    \tif (_javaTypes == null) {\r\n+    \t\t_javaTypes = new Integer[vers.getMappingInfo().getColumns().size()];\r\n+    \t}\r\n+    \tif (_javaTypes[i] == null) {\r\n+    \t\tColumn col = (Column)vers.getMappingInfo().getColumns().get(i);\r\n+    \t\tif (!StringUtils.isEmpty(col.getTypeName())) {\r\n+    \t\t\tClass javaType = Schemas.getJavaType(col.getType(), \r\n+    \t\t\t\t\tcol.getSize(), col.getDecimalDigits());\r\n+    \t\t\t_javaTypes[i] = JavaTypes.getTypeCode(javaType);\r\n+    \t\t} else {\r\n+    \t\t\t_javaTypes[i] = JavaTypes.INT;\r\n+    \t\t}\r\n+    \t}\r\n+    \treturn _javaTypes[i];\r\n+    }\r\n+\r\n+    protected Object nextVersion(Object version) {\r\n+        if (version == null)\r\n+            return _initials;\r\n+        Object[] values = (Object[])version;\r\n+        Number[] result = new Number[values.length];\r\n+        for (int i = 0; i < values.length; i++)\r\n+        \tresult[i] = nextValue(values[i], getJavaType(i));\r\n+        return result;\r\n+    }\r\n+    \r\n+    Number nextValue(Object number, int javaTypeCode) {\r\n+    \tNumber result = (number == null) ? 1 : ((Number)number).intValue() + 1;\r\n+    \treturn\t(Number)JavaTypes.convert(\"\"+result, javaTypeCode);\r\n+    }\r\n+}\r"},{"sha":"e7e0750c7ea15b54dd3bfcc380bd414897e5fcb5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NumberVersionStrategy.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NumberVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NumberVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NumberVersionStrategy.java?ref=f0126e921f716ce057b9f72e52868dae0b323a48","patch":"@@ -22,6 +22,7 @@\n import java.util.HashMap;\n \n import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.InternalException;\n import org.apache.openjpa.jdbc.schema.Column;\n import serp.util.Numbers;\n \n@@ -58,6 +59,10 @@ public String getAlias() {\n     protected int getJavaType() {\n         return JavaTypes.INT;\n     }\n+    \n+    protected int getJavaType(int i) {\n+       throw new InternalException(\"multi-column-version-not-supported\");\n+    }\n \n     protected Object nextVersion(Object version) {\n         if (version == null)"},{"sha":"42da3e4210579360819ceea0ea808fc49ed3887a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/TimestampVersionStrategy.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/TimestampVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/TimestampVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/TimestampVersionStrategy.java?ref=f0126e921f716ce057b9f72e52868dae0b323a48","patch":"@@ -25,6 +25,7 @@\n \n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.util.InternalException;\n \n /**\n  * Uses a timestamp for optimistic versioning.\n@@ -43,6 +44,10 @@ public String getAlias() {\n     protected int getJavaType() {\n         return JavaSQLTypes.TIMESTAMP;\n     }\n+    \n+    protected int getJavaType(int i) {\n+        throw new InternalException(\"multi-column-version-not-supported\");\n+    }\n \n     protected Object nextVersion(Object version) {\n         return new Timestamp(System.currentTimeMillis());"},{"sha":"6a93f446293af505fc0a48e87a674719403d568d","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingParser.java","status":"modified","additions":7,"deletions":2,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingParser.java","raw_url":"https://github.com/apache/openjpa/raw/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingParser.java?ref=f0126e921f716ce057b9f72e52868dae0b323a48","patch":"@@ -73,6 +73,7 @@\n import org.apache.openjpa.jdbc.meta.strats.FullClassStrategy;\n import org.apache.openjpa.jdbc.meta.strats.VerticalClassStrategy;\n import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Schemas;\n import org.apache.openjpa.jdbc.schema.Unique;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.lib.log.Log;\n@@ -808,14 +809,18 @@ private static Column newColumn(VersionColumn anno) {\n         Column col = new Column();\n         if (!StringUtils.isEmpty(anno.name()))\n             col.setName(anno.name());\n-        if (!StringUtils.isEmpty(anno.columnDefinition()))\n-            col.setTypeName(anno.columnDefinition());\n         if (anno.precision() != 0)\n             col.setSize(anno.precision());\n         else if (anno.length() != 255)\n             col.setSize(anno.length());\n         col.setNotNull(!anno.nullable());\n         col.setDecimalDigits(anno.scale());\n+        if (!StringUtils.isEmpty(anno.columnDefinition())) {\n+            col.setTypeName(anno.columnDefinition());\n+            col.setType(Schemas.getJDBCType(col.getTypeName()));\n+            col.setJavaType(JavaTypes.getTypeCode(Schemas.getJavaType\n+            \t(col.getType(), col.getSize(), col.getDecimalDigits())));\n+        }\n         col.setFlag(Column.FLAG_UNINSERTABLE, !anno.insertable());\n         col.setFlag(Column.FLAG_UNUPDATABLE, !anno.updatable());\n         return col;"},{"sha":"1a0430bb7f4f6cc91f03a13b32c7c41a3c41e102","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingDefaults.java","status":"modified","additions":7,"deletions":3,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingDefaults.java?ref=f0126e921f716ce057b9f72e52868dae0b323a48","patch":"@@ -25,6 +25,7 @@\n import org.apache.openjpa.jdbc.meta.ValueMapping;\n import org.apache.openjpa.jdbc.meta.Version;\n import org.apache.openjpa.jdbc.meta.strats.FlatClassStrategy;\n+import org.apache.openjpa.jdbc.meta.strats.MultiColumnVersionStrategy;\n import org.apache.openjpa.jdbc.meta.strats.NoneDiscriminatorStrategy;\n import org.apache.openjpa.jdbc.meta.strats.NoneVersionStrategy;\n import org.apache.openjpa.jdbc.meta.strats.NumberVersionStrategy;\n@@ -84,9 +85,12 @@ public Object getStrategy(Version vers, boolean adapt) {\n             || cls.getVersionField() != null)\n             return strat;\n \n-        if (vers.getMappingInfo().getColumns().isEmpty())\n-            return NoneVersionStrategy.getInstance();\n-        return new NumberVersionStrategy();\n+        int nColumn = vers.getMappingInfo().getColumns().size();\n+        switch (nColumn) {\n+\t        case 0 : return NoneVersionStrategy.getInstance();\n+\t        case 1 : return new NumberVersionStrategy();\n+\t        default: return new MultiColumnVersionStrategy();\n+        }\n     }\n \n     @Override"},{"sha":"c282b6fef2b94cd1a41ddd62c056b5179d05fdbe","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/annotations/MultiColumnVersionPC.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/annotations/MultiColumnVersionPC.java","raw_url":"https://github.com/apache/openjpa/raw/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/annotations/MultiColumnVersionPC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/annotations/MultiColumnVersionPC.java?ref=f0126e921f716ce057b9f72e52868dae0b323a48","patch":"@@ -0,0 +1,63 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.persistence.jdbc.annotations;\r\n+\r\n+import javax.persistence.Entity;\r\n+import javax.persistence.GeneratedValue;\r\n+import javax.persistence.Id;\r\n+\r\n+import org.apache.openjpa.persistence.jdbc.VersionColumn;\r\n+import org.apache.openjpa.persistence.jdbc.VersionColumns;\r\n+import org.apache.openjpa.persistence.jdbc.VersionStrategy;\r\n+\r\n+/**\r\n+ * Persistent entity for testing multiple column numeric version strategy as \r\n+ * set by @VersionColumns annotations.\r\n+ * \r\n+ * The version columns can have numeric values of different types.\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ *\r\n+ */\r\n+@Entity\r\n+@VersionStrategy(\"version-numbers\")\r\n+@VersionColumns({\r\n+\t@VersionColumn(name=\"v1\"), \r\n+\t@VersionColumn(name=\"v2\"),\r\n+\t@VersionColumn(name=\"v3\", columnDefinition=\"FLOAT\", scale=3, precision=10)\r\n+})\r\n+public class MultiColumnVersionPC {\r\n+\t@Id\r\n+\t@GeneratedValue\r\n+\tprivate long id;\r\n+\t\r\n+\tprivate String name;\r\n+\r\n+\tpublic long getId() {\r\n+\t\treturn id;\r\n+\t}\r\n+\r\n+\tpublic String getName() {\r\n+\t\treturn name;\r\n+\t}\r\n+\r\n+\tpublic void setName(String name) {\r\n+\t\tthis.name = name;\r\n+\t}\r\n+}\r"},{"sha":"12826d5e28fff50138d393d0b690b6b90c40a79e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/annotations/TestMultiColumnVersion.java","status":"added","additions":126,"deletions":0,"changes":126,"blob_url":"https://github.com/apache/openjpa/blob/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/annotations/TestMultiColumnVersion.java","raw_url":"https://github.com/apache/openjpa/raw/f0126e921f716ce057b9f72e52868dae0b323a48/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/annotations/TestMultiColumnVersion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/jdbc/annotations/TestMultiColumnVersion.java?ref=f0126e921f716ce057b9f72e52868dae0b323a48","patch":"@@ -0,0 +1,126 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.persistence.jdbc.annotations;\r\n+\r\n+import java.lang.reflect.Array;\r\n+import java.util.Arrays;\r\n+\r\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n+import org.apache.openjpa.jdbc.meta.strats.MultiColumnVersionStrategy;\r\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\r\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n+\r\n+/**\r\n+ * Tests numeric version spanning multiple columns. \r\n+ *\r\n+ * @author Pinaki Poddar\r\n+ */\r\n+public class TestMultiColumnVersion extends SingleEMFTestCase {\r\n+    public void setUp() {\r\n+        setUp(MultiColumnVersionPC.class, CLEAR_TABLES);\r\n+    }\r\n+    \r\n+    public void testVersionStrategyIsSet() {\r\n+    \tClassMapping mapping = getMapping(MultiColumnVersionPC.class);\r\n+    \tassertNotNull(mapping.getVersion());\r\n+    \tassertTrue(mapping.getVersion().getStrategy() \r\n+    \t\tinstanceof MultiColumnVersionStrategy);\r\n+    }\r\n+    \r\n+    public void testVersionOnPersistAndUpdate() {\r\n+    \tOpenJPAEntityManager em = emf.createEntityManager();\r\n+    \tem.getTransaction().begin();\r\n+        MultiColumnVersionPC pc = new MultiColumnVersionPC();\r\n+        assertEquals(null, em.getVersion(pc));\r\n+        em.persist(pc);\r\n+        em.getTransaction().commit();\r\n+        assertVersionEquals(new Number[]{1,1, 1.0f}, em.getVersion(pc));\r\n+    \t\r\n+    \tem.getTransaction().begin();\r\n+    \tpc.setName(\"updated\");\r\n+    \tem.merge(pc);\r\n+        em.getTransaction().commit();\r\n+        assertVersionEquals(new Number[]{2,2, 2.0f}, em.getVersion(pc));\r\n+    }\r\n+\r\n+    public void testConcurrentOptimisticUpdateFails() {\r\n+    \tOpenJPAEntityManager em1 = emf.createEntityManager();\r\n+        em1.getTransaction().begin();\r\n+        OpenJPAEntityManager em2 = emf.createEntityManager();\r\n+        em2.getTransaction().begin();\r\n+\r\n+        MultiColumnVersionPC pc1 = new MultiColumnVersionPC();\r\n+        em1.persist(pc1);\r\n+        em1.getTransaction().commit();\r\n+        em1.getTransaction().begin();\r\n+        Object oid = em1.getObjectId(pc1);\r\n+        \r\n+        \r\n+        MultiColumnVersionPC pc2 = em2.find(MultiColumnVersionPC.class, oid);\r\n+        assertVersionEquals(em1.getVersion(pc1), em2.getVersion(pc2));\r\n+        \r\n+        pc1.setName(\"Updated in em1\");\r\n+        pc2.setName(\"Updated in em2\");\r\n+        em1.getTransaction().commit();\r\n+        \r\n+        try {\r\n+            em2.getTransaction().commit();\r\n+            fail(\"Optimistic fail\");\r\n+        } catch (Exception e) {\r\n+        } finally {\r\n+            em2.close();\r\n+        }\r\n+    }\r\n+\r\n+    public void testConcurrentOptimisticReadSucceeds() {\r\n+    \tOpenJPAEntityManager em1 = emf.createEntityManager();\r\n+        em1.getTransaction().begin();\r\n+        OpenJPAEntityManager em2 = emf.createEntityManager();\r\n+        em2.getTransaction().begin();\r\n+\r\n+        MultiColumnVersionPC pc1 = new MultiColumnVersionPC();\r\n+        em1.persist(pc1);\r\n+        em1.getTransaction().commit();\r\n+        em1.getTransaction().begin();\r\n+        Object oid = em1.getObjectId(pc1);\r\n+        \r\n+        \r\n+        MultiColumnVersionPC pc2 = em2.find(MultiColumnVersionPC.class, oid);\r\n+        assertVersionEquals(em1.getVersion(pc1), em2.getVersion(pc2));\r\n+        \r\n+        em1.getTransaction().commit();\r\n+        em2.getTransaction().commit();\r\n+    }\r\n+    \r\n+    static void assertVersionEquals(Object expected, Object actual) {\r\n+    \tassertTrue(expected.getClass().isArray());\r\n+    \tassertTrue(actual.getClass().isArray());\r\n+    \tassertEquals(Array.getLength(expected), Array.getLength(actual));\r\n+    \tint n = Array.getLength(expected);\r\n+    \tfor (int i = 0; i < n; i++) {\r\n+    \t\tObject v1 = Array.get(expected, i);\r\n+    \t\tObject v2 = Array.get(actual, i);\r\n+    \t\t// exact equality may fail on non-integral values\r\n+    \t\tassertTrue(\"element \" + i + \" mismatch. Expeceted: \" + \r\n+       \t\t    v1 + \" actual: \" + v2,\r\n+       \t\t    Math.abs(((Number)v1).doubleValue() - ((Number)v2).doubleValue()) \r\n+       \t\t    < 0.01);\r\n+    \t}\r\n+    }\r\n+}\r"}]}

