{"sha":"f12c0926de48a09a52731065bd9175b8f579c455","node_id":"MDY6Q29tbWl0MjA2MzY0OmYxMmMwOTI2ZGU0OGEwOWE1MjczMTA2NWJkOTE3NWI4ZjU3OWM0NTU=","commit":{"author":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2008-02-01T02:41:00Z"},"committer":{"name":"Patrick Linskey","email":"pcl@apache.org","date":"2008-02-01T02:41:00Z"},"message":"OPENJPA-506\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.0.x@617334 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"5400030e3c2e0eb7324ee072a186b6e58e73a040","url":"https://api.github.com/repos/apache/openjpa/git/trees/5400030e3c2e0eb7324ee072a186b6e58e73a040"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/f12c0926de48a09a52731065bd9175b8f579c455","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/f12c0926de48a09a52731065bd9175b8f579c455","html_url":"https://github.com/apache/openjpa/commit/f12c0926de48a09a52731065bd9175b8f579c455","comments_url":"https://api.github.com/repos/apache/openjpa/commits/f12c0926de48a09a52731065bd9175b8f579c455/comments","author":null,"committer":null,"parents":[{"sha":"dc1088934b55a74d53cc403f0a075119986b9d58","url":"https://api.github.com/repos/apache/openjpa/commits/dc1088934b55a74d53cc403f0a075119986b9d58","html_url":"https://github.com/apache/openjpa/commit/dc1088934b55a74d53cc403f0a075119986b9d58"}],"stats":{"total":653,"additions":614,"deletions":39},"files":[{"sha":"bb8cf0127e1405a196416071fc7289b258aa5d32","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEvent.java","status":"modified","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEvent.java","raw_url":"https://github.com/apache/openjpa/raw/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEvent.java?ref=f12c0926de48a09a52731065bd9175b8f579c455","patch":"@@ -41,6 +41,12 @@\n      */\n     public static final int AFTER_PERSIST = 1;\n \n+    /**\n+     * Event type when an instance is made persistent, after the record has\n+     * been written to the store\n+     */\n+    public static final int AFTER_PERSIST_PERFORMED = 18;\n+\n     /**\n      * Event type when an instance is loaded.\n      */\n@@ -76,6 +82,12 @@\n      */\n     public static final int AFTER_DELETE = 8;\n \n+    /**\n+     * Event type when an instance is deleted, after the record has been\n+     * deleted from the store.\n+     */\n+    public static final int AFTER_DELETE_PERFORMED = 19;\n+\n     /**\n      * Event type when an instance is dirtied for the first time.\n      */\n@@ -121,19 +133,34 @@\n      */\n     public static final int AFTER_REFRESH = 17;\n \n+    /**\n+     * Event type when an instance is modified. This is not invoked for\n+     * PNEW records, but is invoked for PNEWFLUSHED.\n+     */\n+    public static final int BEFORE_UPDATE = 20;\n+\n+    /**\n+     * Event type when an instance is modified, after the change has been\n+     * sent to the store. This is not invoked for PNEW records, but is\n+     * invoked for PNEWFLUSHED records.\n+     */\n+    public static final int AFTER_UPDATE_PERFORMED = 21;\n+\n     /**\n      * Convenience array of all event types.\n      */\n     public static final int[] ALL_EVENTS = new int[]{\n         BEFORE_PERSIST,\n         AFTER_PERSIST,\n+        AFTER_PERSIST_PERFORMED,\n         AFTER_LOAD,\n         BEFORE_STORE,\n         AFTER_STORE,\n         BEFORE_CLEAR,\n         AFTER_CLEAR,\n         BEFORE_DELETE,\n         AFTER_DELETE,\n+        AFTER_DELETE_PERFORMED,\n         BEFORE_DIRTY,\n         AFTER_DIRTY,\n         BEFORE_DIRTY_FLUSHED,\n@@ -143,6 +170,8 @@\n         BEFORE_ATTACH,\n         AFTER_ATTACH,\n         AFTER_REFRESH,\n+        BEFORE_UPDATE,\n+        AFTER_UPDATE_PERFORMED,\n     };\n \n     private final int _type;"},{"sha":"f5d250b7215db542f023707edf2d758c7af5a83f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","status":"modified","additions":28,"deletions":2,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java?ref=f12c0926de48a09a52731065bd9175b8f579c455","patch":"@@ -28,6 +28,8 @@\n \n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.MetaDataDefaults;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n \n /**\n  * Manager that can be used to track and notify listeners on lifecycle events.\n@@ -48,6 +50,9 @@\n \n     private static final Exception[] EMPTY_EXCEPTIONS = new Exception[0];\n \n+    private static final Localizer _loc = Localizer.forPackage(\n+        LifecycleEventManager.class);\n+\n     private Map _classListeners = null; // class -> listener list\n     private ListenerList _listeners = null;\n     private List _addListeners = new LinkedList();\n@@ -56,6 +61,11 @@\n     private boolean _firing = false;\n     private boolean _fail = false;\n     private boolean _failFast = false;\n+    private final Log _log;\n+\n+    public LifecycleEventManager(Log log) {\n+        _log = log;\n+    }\n \n     /**\n      * Whether to fail after first exception when firing events to listeners.\n@@ -132,15 +142,18 @@ public synchronized void removeListener(Object listener) {\n      */\n     public boolean hasPersistListeners(Object source, ClassMetaData meta) {\n         return hasHandlers(source, meta, LifecycleEvent.BEFORE_PERSIST)\n-            || hasHandlers(source, meta, LifecycleEvent.AFTER_PERSIST);\n+            || hasHandlers(source, meta, LifecycleEvent.AFTER_PERSIST)\n+            || hasHandlers(source, meta,\n+                LifecycleEvent.AFTER_PERSIST_PERFORMED);\n     }\n \n     /**\n      * Return whether there are listeners or callbacks for the given source.\n      */\n     public boolean hasDeleteListeners(Object source, ClassMetaData meta) {\n         return hasHandlers(source, meta, LifecycleEvent.BEFORE_DELETE)\n-            || hasHandlers(source, meta, LifecycleEvent.AFTER_DELETE);\n+            || hasHandlers(source, meta, LifecycleEvent.AFTER_DELETE)\n+            || hasHandlers(source, meta, LifecycleEvent.AFTER_DELETE_PERFORMED);\n     }\n \n     /**\n@@ -166,6 +179,14 @@ public boolean hasStoreListeners(Object source, ClassMetaData meta) {\n             || hasHandlers(source, meta, LifecycleEvent.AFTER_STORE);\n     }\n \n+    /**\n+     * Return whether there are listeners or callbacks for the given source.\n+     */\n+    public boolean hasUpdateListeners(Object source, ClassMetaData meta) {\n+        return hasHandlers(source, meta, LifecycleEvent.BEFORE_UPDATE)\n+            || hasHandlers(source, meta, LifecycleEvent.AFTER_UPDATE_PERFORMED);\n+    }\n+\n     /**\n      * Return whether there are listeners or callbacks for the given source.\n      */\n@@ -470,6 +491,11 @@ else if (listener instanceof ListenerAdapter) {\n                                 ((AttachListener) listener).afterAttach(ev);\n                         }\n                         break;\n+                    default:\n+                        if (_log.isWarnEnabled())\n+                            _log.warn(_loc.get(\"unknown-lifecycle-event\",\n+                                Integer.toString(type)));\n+                        break;\n                 }\n             }\n             catch (Exception e) {"},{"sha":"a690b7a3e1981ec17595ac5c74597ef59f362cf6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=f12c0926de48a09a52731065bd9175b8f579c455","patch":"@@ -264,7 +264,8 @@ public void initialize(AbstractBrokerFactory factory,\n         else\n             _runtime = new LocalManagedRuntime(this);\n \n-        _lifeEventManager = new LifecycleEventManager();\n+        _lifeEventManager = new LifecycleEventManager(\n+            _conf.getLog(OpenJPAConfiguration.LOG_RUNTIME));\n         _transEventManager = new TransactionEventManager();\n         int cmode = _conf.getMetaDataRepositoryInstance().\n             getMetaDataFactory().getDefaults().getCallbackMode();"},{"sha":"5edeb8a82c38324e98a078307b920718063e1bc8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"modified","additions":19,"deletions":0,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=f12c0926de48a09a52731065bd9175b8f579c455","patch":"@@ -952,6 +952,11 @@ void afterFlush(int reason) {\n \n         if (reason != BrokerImpl.FLUSH_ROLLBACK\n             && reason != BrokerImpl.FLUSH_LOGICAL) {\n+            // analyze previous state for later\n+            boolean wasNew = isNew();\n+            boolean wasFlushed = isFlushed();\n+            boolean wasDeleted = isDeleted();\n+\n             // all dirty fields were flushed\n             _flush.or(_dirty);\n \n@@ -972,6 +977,15 @@ void afterFlush(int reason) {\n             // if this object was stored with preFlush, do post-store callback\n             if ((_flags & FLAG_PRE_FLUSHED) > 0)\n                 fireLifecycleEvent(LifecycleEvent.AFTER_STORE);\n+\n+            // do post-update as needed\n+            if (wasNew && !wasFlushed)\n+                fireLifecycleEvent(LifecycleEvent.AFTER_PERSIST_PERFORMED);\n+            else if (wasDeleted)\n+                fireLifecycleEvent(LifecycleEvent.AFTER_DELETE_PERFORMED);\n+            else \n+                // updates and new-flushed with changes\n+                fireLifecycleEvent(LifecycleEvent.AFTER_UPDATE_PERFORMED);\n         } else if (reason == BrokerImpl.FLUSH_ROLLBACK) {\n             // revert to last loaded version and original oid\n             assignVersionField(_loadVersion);\n@@ -2761,6 +2775,11 @@ void preFlush(boolean logical, OpCallbacks call) {\n \n         if (isPersistent()) {\n             fireLifecycleEvent(LifecycleEvent.BEFORE_STORE);\n+            // BEFORE_PERSIST is handled during Broker.persist and Broker.attach\n+            if (isDeleted())\n+                fireLifecycleEvent(LifecycleEvent.BEFORE_DELETE);\n+            else \n+                fireLifecycleEvent(LifecycleEvent.BEFORE_UPDATE);\n             _flags |= FLAG_PRE_FLUSHED;\n         }\n "},{"sha":"7fa741f7b5d2a19b50f590ef56cfda581c2c6794","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","status":"modified","additions":8,"deletions":2,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java?ref=f12c0926de48a09a52731065bd9175b8f579c455","patch":"@@ -33,6 +33,7 @@\n import org.apache.openjpa.util.ObjectNotFoundException;\n import org.apache.openjpa.util.OptimisticException;\n import org.apache.openjpa.util.ImplHelper;\n+import org.apache.openjpa.event.LifecycleEvent;\n \n /**\n  * Handles attaching instances using version and primary key fields.\n@@ -133,8 +134,13 @@ public Object attach(AttachManager manager, Object toAttach,\n             return into;\n         }\n \n-        // invoke any preAttach on the detached instance\n-        manager.fireBeforeAttach(toAttach, meta);\n+        if (isNew) {\n+            broker.fireLifecycleEvent(toAttach, null, meta,\n+                LifecycleEvent.BEFORE_PERSIST);\n+        } else {\n+            // invoke any preAttach on the detached instance\n+            manager.fireBeforeAttach(toAttach, meta);\n+        }\n \n         // assign the detached pc the same state manager as the object we're\n         // copying into during the attach process"},{"sha":"69e0d4d4ce3cc3a0fa13dd80d6650ae06e5d5bc1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","raw_url":"https://github.com/apache/openjpa/raw/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java?ref=f12c0926de48a09a52731065bd9175b8f579c455","patch":"@@ -168,9 +168,9 @@ private static Object generateValue(StoreContext ctx,\n         }\n     }\n \n-    /** \n-     * Returns the fields of the state that require an update. \n-     *  \n+    /**\n+     * Returns the fields of the state that require an update.\n+     *\n      * @param  sm  the state to check\n      * @return the BitSet of fields that need update, or null if none\n      */"},{"sha":"d146f0848187106bf1cc7acc0d1cc7d81020c951","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/event/localizer.properties","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-kernel/src/main/resources/org/apache/openjpa/event/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-kernel/src/main/resources/org/apache/openjpa/event/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/event/localizer.properties?ref=f12c0926de48a09a52731065bd9175b8f579c455","patch":"@@ -96,4 +96,6 @@ bean-constructor: Could not instantiate class {0}.  Make sure it has an \\\n method-notfound: Method \"{1}\" with arguments of type: {2} \\\n     not found in class \"{0}\".\n broker-factory-listener-exception: Exception thrown while calling a \\\n-    BrokerFactoryListener. This exception will be ignored.\n\\ No newline at end of file\n+    BrokerFactoryListener. This exception will be ignored.\n+unknown-lifecycle-event: An unknown lifecycle event was encountered. Please \\\n+    report this to dev@openjpa.apache.org. Event type: {0}.\n\\ No newline at end of file"},{"sha":"57bc1bae44264ae138bb2c8b97536eb42cec390f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ExceptionsFromCallbacksEntity.java","status":"modified","additions":68,"deletions":11,"changes":79,"blob_url":"https://github.com/apache/openjpa/blob/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ExceptionsFromCallbacksEntity.java","raw_url":"https://github.com/apache/openjpa/raw/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ExceptionsFromCallbacksEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/ExceptionsFromCallbacksEntity.java?ref=f12c0926de48a09a52731065bd9175b8f579c455","patch":"@@ -24,29 +24,54 @@\n import javax.persistence.PrePersist;\n import javax.persistence.PreUpdate;\n import javax.persistence.Version;\n-\n+import javax.persistence.PreRemove;\n+import javax.persistence.PostRemove;\n+import javax.persistence.PostUpdate;\n+import javax.persistence.PostPersist;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.Transient;\n \n @Entity\n public class ExceptionsFromCallbacksEntity {\n-    @Id private long id;\n+    @Id @GeneratedValue private long id;\n     @Version private int version;\n-    private boolean throwOnPrePersist;\n-    private boolean throwOnPreUpdate;\n+    @Transient private boolean throwOnPrePersist;\n+    @Transient private boolean throwOnPostPersist;\n+    @Transient private boolean throwOnPreUpdate;\n+    @Transient private boolean throwOnPostUpdate;\n     private boolean throwOnPostLoad;\n+    @Transient private boolean throwOnPreRemove;\n+    @Transient private boolean throwOnPostRemove;\n     private String stringField;\n-    \n+\n     public void setThrowOnPrePersist(boolean b) {\n         throwOnPrePersist = b;\n     }\n \n-    public void setThrowOnPostLoad(boolean b) {\n-        throwOnPostLoad = b;\n+    public void setThrowOnPostPersist(boolean b) {\n+        throwOnPostPersist = b;\n     }\n \n     public void setThrowOnPreUpdate(boolean b) {\n         throwOnPreUpdate = b;\n     }\n \n+    public void setThrowOnPostUpdate(boolean b) {\n+        throwOnPostUpdate = b;\n+    }\n+\n+    public void setThrowOnPostLoad(boolean b) {\n+        throwOnPostLoad = b;\n+    }\n+\n+    public void setThrowOnPreRemove(boolean b) {\n+        throwOnPreRemove = b;\n+    }\n+\n+    public void setThrowOnPostRemove(boolean b) {\n+        throwOnPostRemove = b;\n+    }\n+\n     public void setStringField(String s) {\n         stringField = s;\n     }\n@@ -57,18 +82,50 @@ public void prePersist() {\n             throw new CallbackTestException();\n     }\n \n+    @PostPersist\n+    public void postPersist() {\n+        if (throwOnPostPersist)\n+            throw new CallbackTestException();\n+    }\n+\n+    @PostLoad\n+    public void postLoad() {\n+        if (throwOnPostLoad && isInvokedFromTestMethod())\n+            throw new CallbackTestException();\n+    }\n+\n+    private boolean isInvokedFromTestMethod() {\n+        return TestExceptionsFromCallbacks.testRunning;\n+    }\n+\n     @PreUpdate\n     public void preUpdate() {\n         if (throwOnPreUpdate)\n             throw new CallbackTestException();\n     }\n \n-    @PostLoad\n-    public void postLoad() {\n-        if (throwOnPostLoad)\n+    @PostUpdate\n+    public void postUpdate() {\n+        if (throwOnPostUpdate)\n             throw new CallbackTestException();\n     }\n-    \n+\n+    @PreRemove\n+    public void preRemove() {\n+        if (throwOnPreRemove && isInvokedFromTestMethod())\n+            throw new CallbackTestException();\n+    }\n+\n+    @PostRemove\n+    public void postRemove() {\n+        if (throwOnPostRemove && isInvokedFromTestMethod())\n+            throw new CallbackTestException();\n+    }\n+\n+    public Object getId() {\n+        return id;\n+    }\n+\n     public class CallbackTestException\n         extends RuntimeException {\n     }"},{"sha":"33b40440cf7314d9b7ce5ad106250b58b1c27730","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestExceptionsFromCallbacks.java","status":"modified","additions":424,"deletions":14,"changes":438,"blob_url":"https://github.com/apache/openjpa/blob/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestExceptionsFromCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestExceptionsFromCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestExceptionsFromCallbacks.java?ref=f12c0926de48a09a52731065bd9175b8f579c455","patch":"@@ -18,27 +18,51 @@\n  */\n package org.apache.openjpa.persistence.callbacks;\n \n-import java.util.HashMap;\n-import java.util.Map;\n-\n+import java.util.Set;\n+import java.util.HashSet;\n import javax.persistence.EntityManager;\n-import javax.persistence.Persistence;\n import javax.persistence.RollbackException;\n \n-import junit.framework.TestCase;\n-import org.apache.openjpa.persistence.OpenJPAEntityManagerFactory;\n import org.apache.openjpa.persistence.OpenJPAPersistence;\n import org.apache.openjpa.persistence.callbacks.ExceptionsFromCallbacksEntity.CallbackTestException;\n import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+import org.apache.openjpa.enhance.PersistenceCapable;\n \n /**\n  * Tests against JPA section 3.5's description of callback exception handling.\n  */\n public class TestExceptionsFromCallbacks\n     extends SingleEMFTestCase {\n \n+    public static boolean testRunning = false;\n+\n+    @Override\n     public void setUp() {\n-        setUp(ExceptionsFromCallbacksEntity.class);\n+        Set needEnhancement = new HashSet();\n+        needEnhancement.add(\n+            \"testPostUpdateExceptionDuringFlushWithNewInstance\");\n+        needEnhancement.add(\n+            \"testPreUpdateExceptionDuringFlushWithExistingFlushedInstance\");\n+        needEnhancement.add(\n+            \"testPreUpdateExceptionDuringCommitWithExistingFlushedInstance\");\n+        needEnhancement.add(\n+            \"testPostUpdateExceptionDuringFlushWithExistingFlushedInstance\");\n+        needEnhancement.add(\n+            \"testPostUpdateExceptionDuringCommitWithExistingFlushedInstance\");\n+        if (!PersistenceCapable.class.isAssignableFrom(\n+            ExceptionsFromCallbacksEntity.class)\n+            && needEnhancement.contains(getName()))\n+            // actually, we really only need redef\n+            fail(\"this test method does not work without enhancement\");\n+\n+        setUp(ExceptionsFromCallbacksEntity.class, CLEAR_TABLES, \"openjpa.Log\", \"SQL=TRACE\");\n+        testRunning = true;\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        testRunning = false;\n+        super.tearDown();\n     }\n \n     public void testPrePersistException() {\n@@ -60,13 +84,41 @@ public void testPrePersistException() {\n         }\n     }\n \n-    public void testPreUpdateExceptionDuringFlush() {\n+    public void testPrePersistExceptionOnMerge() {\n         EntityManager em = emf.createEntityManager();\n         em.getTransaction().begin();\n         ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n-        o.setThrowOnPreUpdate(true);\n+        o.setThrowOnPrePersist(true);\n+        try {\n+            em.merge(o);\n+            fail(\"merge should have failed\");\n+        } catch (CallbackTestException cte) {\n+            // transaction should be still active, but marked for rollback\n+            assertTrue(em.getTransaction().isActive());\n+            assertTrue(em.getTransaction().getRollbackOnly());\n+        } finally {\n+            if (em.getTransaction().isActive())\n+                em.getTransaction().rollback();\n+            em.close();\n+        }\n+    }\n+\n+    public void testPostPersistExceptionDuringFlush() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        o.setThrowOnPostPersist(true);\n         em.persist(o);\n+        mutateAndFlush(em, o);\n+    }\n+\n+    private void mutateAndFlush(EntityManager em,\n+        ExceptionsFromCallbacksEntity o) {\n         o.setStringField(\"foo\");\n+        flush(em);\n+    }\n+\n+    private void flush(EntityManager em) {\n         try {\n             em.flush();\n             fail(\"flush should have failed\");\n@@ -81,20 +133,29 @@ public void testPreUpdateExceptionDuringFlush() {\n         }\n     }\n \n-    public void testPreUpdateExceptionDuringCommit() {\n+    public void testPostPersistExceptionDuringCommit() {\n         EntityManager em = emf.createEntityManager();\n         em.getTransaction().begin();\n         ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n-        o.setThrowOnPreUpdate(true);\n+        o.setThrowOnPostPersist(true);\n         em.persist(o);\n+        mutateAndCommit(em, o);\n+    }\n+\n+    private void mutateAndCommit(EntityManager em,\n+        ExceptionsFromCallbacksEntity o) {\n         o.setStringField(\"foo\");\n+        commit(em);\n+    }\n+\n+    private void commit(EntityManager em) {\n         try {\n             em.getTransaction().commit();\n             fail(\"commit should have failed\");\n         } catch (RollbackException re) {\n             assertEquals(CallbackTestException.class,\n                 re.getCause().getClass());\n-            \n+\n             // transaction should be rolled back at this point\n             assertFalse(em.getTransaction().isActive());\n         } finally {\n@@ -103,7 +164,253 @@ public void testPreUpdateExceptionDuringCommit() {\n             em.close();\n         }\n     }\n-    \n+\n+    public void testPrePersistExceptionDuringFlushWithNewFlushedInstance() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        em.persist(o);\n+        em.flush();\n+        o.setThrowOnPrePersist(true);\n+        // should pass; pre-persist should not be triggered\n+        o.setStringField(\"foo\");\n+        em.flush();\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    public void testPrePersistExceptionDuringCommitWithNewFlushedInstance() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        em.persist(o);\n+        em.flush();\n+        o.setThrowOnPrePersist(true);\n+        // should pass; pre-persist should not be triggered\n+        o.setStringField(\"foo\");\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    public void testPostPersistExceptionDuringFlushWithNewFlushedInstance() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        em.persist(o);\n+        em.flush();\n+        o.setThrowOnPostPersist(true);\n+        // should pass; post-persist should not be triggered\n+        o.setStringField(\"foo\");\n+        em.flush();\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    public void testPostPersistExceptionDuringCommitWithNewFlushedInstance() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        em.persist(o);\n+        em.flush();\n+        o.setThrowOnPostPersist(true);\n+        // should pass; post-persist should not be triggered\n+        o.setStringField(\"foo\");\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    public void testPreUpdateExceptionWithNewInstance() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        o.setThrowOnPreUpdate(true);\n+        em.persist(o);\n+        o.setStringField(\"foo\");\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    public void testPostUpdateExceptionDuringFlushWithNewInstance() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        o.setThrowOnPostUpdate(true);\n+        em.persist(o);\n+        o.setStringField(\"foo\");\n+        em.flush();\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    public void testPostUpdateExceptionDuringCommitWithNewInstance() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        o.setThrowOnPostUpdate(true);\n+        em.persist(o);\n+        o.setStringField(\"foo\");\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    public void testPreUpdateExceptionDuringFlushWithNewFlushedInstance() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        em.persist(o);\n+        em.flush();\n+        o.setThrowOnPreUpdate(true);\n+        mutateAndFlush(em, o);\n+    }\n+\n+    public void testPreUpdateExceptionDuringCommitWithNewFlushedInstance() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        em.persist(o);\n+        em.flush();\n+        o.setThrowOnPreUpdate(true);\n+        mutateAndCommit(em, o);\n+    }\n+\n+    public void testPostUpdateExceptionDuringFlushWithNewFlushedInstance() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        em.persist(o);\n+        em.flush();\n+        o.setThrowOnPostUpdate(true);\n+        mutateAndFlush(em, o);\n+    }\n+\n+    public void testPostUpdateExceptionDuringCommitWithNewFlushedInstance() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        em.persist(o);\n+        em.flush();\n+        o.setThrowOnPostUpdate(true);\n+        mutateAndCommit(em, o);\n+    }\n+\n+    public void testPreUpdateExceptionDuringFlushWithExistingInstance() {\n+        Object oid = insert(\"new instance\");\n+\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o =\n+            em.find(ExceptionsFromCallbacksEntity.class, oid);\n+        o.setThrowOnPreUpdate(true);\n+        mutateAndFlush(em, o);\n+    }\n+\n+    private Object insert(String s) {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        o.setStringField(s);\n+        em.persist(o);\n+        em.getTransaction().commit();\n+        em.close();\n+        return o.getId();\n+    }\n+\n+    public void testPreUpdateExceptionDuringCommitWithExistingInstance() {\n+        Object oid = insert(\"new instance\");\n+\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o =\n+            em.find(ExceptionsFromCallbacksEntity.class, oid);\n+        o.setThrowOnPreUpdate(true);\n+        mutateAndCommit(em, o);\n+    }\n+\n+    public void testPostUpdateExceptionDuringFlushWithExistingInstance() {\n+        Object oid = insert(\"new instance\");\n+\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o =\n+            em.find(ExceptionsFromCallbacksEntity.class, oid);\n+        o.setThrowOnPostUpdate(true);\n+        mutateAndFlush(em, o);\n+    }\n+\n+    public void testPostUpdateExceptionDuringCommitWithExistingInstance() {\n+        Object oid = insert(\"new instance\");\n+\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o =\n+            em.find(ExceptionsFromCallbacksEntity.class, oid);\n+        o.setThrowOnPostUpdate(true);\n+        mutateAndCommit(em, o);\n+    }\n+\n+    public void testPreUpdateExceptionDuringFlushWithExistingFlushedInstance() {\n+        Object oid = insert(\"new instance\");\n+\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o =\n+            em.find(ExceptionsFromCallbacksEntity.class, oid);\n+        o.setStringField(\"foo\");\n+        em.flush();\n+        o.setThrowOnPreUpdate(true);\n+        // there's no additional flush work; should not re-invoke the callback\n+        em.flush();\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    public void testPreUpdateExceptionDuringCommitWithExistingFlushedInstance(){\n+        Object oid = insert(\"new instance\");\n+\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o =\n+            em.find(ExceptionsFromCallbacksEntity.class, oid);\n+        o.setStringField(\"foo\");\n+        em.flush();\n+        o.setThrowOnPreUpdate(true);\n+        // there's no additional flush work; should not re-invoke the callback\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    public void testPostUpdateExceptionDuringFlushWithExistingFlushedInstance(){\n+        Object oid = insert(\"new instance\");\n+\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o =\n+            em.find(ExceptionsFromCallbacksEntity.class, oid);\n+        o.setStringField(\"foo\");\n+        em.flush();\n+        o.setThrowOnPostUpdate(true);\n+        // no mutations; should not trigger a PostUpdate\n+        em.flush();\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    public void testPostUpdateExceptionDuringCommitWithExistingFlushedInstance()\n+    {\n+        Object oid = insert(\"new instance\");\n+\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o =\n+            em.find(ExceptionsFromCallbacksEntity.class, oid);\n+        o.setStringField(\"foo\");\n+        em.flush();\n+        // no mutations; should not trigger a PostUpdate\n+        o.setThrowOnPostUpdate(true);\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n     public void testPostLoadException() {\n         EntityManager em = emf.createEntityManager();\n         em.getTransaction().begin();\n@@ -117,7 +424,7 @@ public void testPostLoadException() {\n         em = emf.createEntityManager();\n         em.getTransaction().begin();\n         try {\n-            o = em.find(ExceptionsFromCallbacksEntity.class, oid);\n+            em.find(ExceptionsFromCallbacksEntity.class, oid);\n             fail(\"find should have failed\");\n         } catch (CallbackTestException cte) {\n             // transaction should be active but marked for rollback\n@@ -129,4 +436,107 @@ public void testPostLoadException() {\n             em.close();\n         }\n     }\n+\n+    public void testPreDeleteException() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        em.persist(o);\n+        em.flush();\n+        o.setThrowOnPreRemove(true);\n+        try {\n+            em.remove(o);\n+        } catch (CallbackTestException cte) {\n+            // transaction should be active but marked for rollback\n+            assertTrue(em.getTransaction().isActive());\n+            assertTrue(em.getTransaction().getRollbackOnly());\n+        } finally {\n+            if (em.getTransaction().isActive())\n+                em.getTransaction().rollback();\n+            em.close();\n+        }\n+    }\n+\n+    public void testPostDeleteExceptionDuringFlush() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        em.persist(o);\n+        em.flush();\n+        o.setThrowOnPostRemove(true);\n+        try {\n+            em.remove(o);\n+        } catch (CallbackTestException e) {\n+            em.getTransaction().rollback();\n+            em.close();\n+            fail(\"PostRemove is being called too soon (before SQL is issued)\");\n+        }\n+        flush(em);\n+    }\n+\n+    public void testPostDeleteExceptionDuringCommit() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        em.persist(o);\n+        em.flush();\n+        o.setThrowOnPostRemove(true);\n+        try {\n+            em.remove(o);\n+        } catch (CallbackTestException e) {\n+            em.getTransaction().rollback();\n+            em.close();\n+            fail(\"PostRemove is being called too soon (before SQL is issued)\");\n+        }\n+        commit(em);\n+    }\n+\n+    public void testPreDeleteExceptionDoubleDelete() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        em.persist(o);\n+        em.flush();\n+        // this should pass\n+        em.remove(o);\n+        em.flush();\n+        o.setThrowOnPreRemove(true);\n+        // this shoud also pass; no work to do for delete\n+        em.remove(o);\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    public void testPostDeleteExceptionDuringFlushDoubleDelete() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        em.persist(o);\n+        em.flush();\n+        // this should pass\n+        em.remove(o);\n+        em.flush();\n+        o.setThrowOnPostRemove(true);\n+        // this shoud also pass; no work to do for delete\n+        em.remove(o);\n+        em.flush();\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+\n+    public void testPostDeleteExceptionDuringCommitDoubleDelete() {\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        ExceptionsFromCallbacksEntity o = new ExceptionsFromCallbacksEntity();\n+        em.persist(o);\n+        em.flush();\n+        // this should pass\n+        em.remove(o);\n+        em.flush();\n+        o.setThrowOnPostRemove(true);\n+        // this shoud also pass; no work to do for delete\n+        em.remove(o);\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n }"},{"sha":"365e69a8d094509e6eb0af90da31f269c3c5d104","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/test/PersistenceTestCase.java","status":"modified","additions":21,"deletions":1,"changes":22,"blob_url":"https://github.com/apache/openjpa/blob/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/test/PersistenceTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/test/PersistenceTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/test/PersistenceTestCase.java?ref=f12c0926de48a09a52731065bd9175b8f579c455","patch":"@@ -29,6 +29,7 @@\n import javax.persistence.Persistence;\n \n import junit.framework.TestCase;\n+import junit.framework.TestResult;\n import org.apache.openjpa.kernel.AbstractBrokerFactory;\n import org.apache.openjpa.kernel.Broker;\n import org.apache.openjpa.meta.ClassMetaData;\n@@ -47,6 +48,11 @@\n      */\n     protected static final Object CLEAR_TABLES = new Object();\n \n+    /**\n+     * The {@link TestResult} instance for the current test run.\n+     */\n+    protected TestResult testResult;\n+\n     /**\n      * Create an entity manager factory. Put {@link #CLEAR_TABLES} in\n      * this list to tell the test framework to delete all table contents\n@@ -88,8 +94,22 @@ protected OpenJPAEntityManagerFactorySPI createEMF(Object... props) {\n             createEntityManagerFactory(\"test\", map);\n     }\n \n+    @Override\n+    public void run(TestResult testResult) {\n+        this.testResult = testResult;\n+        super.run(testResult);\n+    }\n+\n+    @Override\n     public void tearDown() throws Exception {\n-        super.tearDown();\n+        try {\n+            super.tearDown();\n+        } catch (Exception e) {\n+            // if a test failed, swallow any exceptions that happen\n+            // during tear-down, as these just mask the original problem.\n+            if (testResult.wasSuccessful())\n+                throw e;\n+        }\n     }\n \n     /**"},{"sha":"60c4394904e589717f60d1d7800f3348d0c800e5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/test/SingleEMFTestCase.java","status":"modified","additions":5,"deletions":0,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/test/SingleEMFTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/test/SingleEMFTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/test/SingleEMFTestCase.java?ref=f12c0926de48a09a52731065bd9175b8f579c455","patch":"@@ -58,6 +58,11 @@ public void tearDown() throws Exception {\n \n         try {\n             clear(emf);\n+        } catch (Exception e) {\n+            // if a test failed, swallow any exceptions that happen\n+            // during tear-down, as these just mask the original problem.\n+            if (testResult.wasSuccessful())\n+                throw e;\n         } finally {\n             closeEMF(emf);\n         }"},{"sha":"6eb378d9f75b5c8c1f1cc18e66b5a6953c8feb8f","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/MetaDataParsers.java","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/MetaDataParsers.java","raw_url":"https://github.com/apache/openjpa/raw/f12c0926de48a09a52731065bd9175b8f579c455/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/MetaDataParsers.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/MetaDataParsers.java?ref=f12c0926de48a09a52731065bd9175b8f579c455","patch":"@@ -47,15 +47,15 @@\n             case PRE_PERSIST:\n                 return new int[]{ LifecycleEvent.BEFORE_PERSIST };\n             case POST_PERSIST:\n-                return new int[]{ LifecycleEvent.AFTER_PERSIST };\n+                return new int[]{ LifecycleEvent.AFTER_PERSIST_PERFORMED };\n             case PRE_REMOVE:\n                 return new int[]{ LifecycleEvent.BEFORE_DELETE };\n             case POST_REMOVE:\n-                return new int[]{ LifecycleEvent.AFTER_DELETE };\n+                return new int[]{ LifecycleEvent.AFTER_DELETE_PERFORMED };\n             case PRE_UPDATE:\n-                return new int[]{ LifecycleEvent.BEFORE_STORE };\n+                return new int[]{ LifecycleEvent.BEFORE_UPDATE };\n             case POST_UPDATE:\n-                return new int[]{ LifecycleEvent.AFTER_STORE };\n+                return new int[]{ LifecycleEvent.AFTER_UPDATE_PERFORMED };\n             case POST_LOAD:\n                 return new int[]{ LifecycleEvent.AFTER_LOAD,\n                     LifecycleEvent.AFTER_REFRESH };"}]}

