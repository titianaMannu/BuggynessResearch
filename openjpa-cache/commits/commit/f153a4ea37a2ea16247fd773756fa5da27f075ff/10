{"sha":"f153a4ea37a2ea16247fd773756fa5da27f075ff","node_id":"MDY6Q29tbWl0MjA2MzY0OmYxNTNhNGVhMzdhMmVhMTYyNDdmZDc3Mzc1NmZhNWRhMjdmMDc1ZmY=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-12T14:10:03Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-12T14:10:03Z"},"message":"Deleting old tag will recreate from rev 752732\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/tags/1.2.1@752872 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4b825dc642cb6eb9a060e54bf8d69288fbee4904","url":"https://api.github.com/repos/apache/openjpa/git/trees/4b825dc642cb6eb9a060e54bf8d69288fbee4904"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/f153a4ea37a2ea16247fd773756fa5da27f075ff","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/f153a4ea37a2ea16247fd773756fa5da27f075ff","html_url":"https://github.com/apache/openjpa/commit/f153a4ea37a2ea16247fd773756fa5da27f075ff","comments_url":"https://api.github.com/repos/apache/openjpa/commits/f153a4ea37a2ea16247fd773756fa5da27f075ff/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"f290fad39391ba583289c4abfe52d3f81f95d18a","url":"https://api.github.com/repos/apache/openjpa/commits/f290fad39391ba583289c4abfe52d3f81f95d18a","html_url":"https://github.com/apache/openjpa/commit/f290fad39391ba583289c4abfe52d3f81f95d18a"}],"stats":{"total":895102,"additions":0,"deletions":895102},"files":[{"sha":"28db9446fcdb342f16eb74330caeb9434cd9ad3a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EqualExpression.java","status":"removed","additions":0,"deletions":78,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/EqualExpression.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,78 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-\n-/**\n- * Compares two values.\n- *\n- * @author Abe White\n- */\n-class EqualExpression\n-    extends CompareEqualExpression {\n-\n-    /**\n-     * Constructor. Supply values to compare.\n-     */\n-    public EqualExpression(Val val1, Val val2) {\n-        super(val1, val2);\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, BinaryOpExpState bstate, \n-        SQLBuffer buf, boolean val1Null, boolean val2Null) {\n-        if (val1Null && val2Null)\n-            buf.append(\"1 = 1\");\n-        else if (val1Null || val2Null) {\n-            Val val = (val1Null) ? getValue2() : getValue1();\n-            ExpState state = (val1Null) ? bstate.state2 : bstate.state1;\n-            if (!isDirectComparison()) {\n-                int len = val.length(sel, ctx, state);\n-                for (int i = 0; i < len; i++) {\n-                    if (i > 0)\n-                        buf.append(\" AND \");\n-                    val.appendTo(sel, ctx, state, buf, i);\n-                    buf.append(\" IS \").appendValue(null);\n-                }\n-            } else\n-                val.appendIsNull(sel, ctx, state, buf);\n-        } else {\n-            Val val1 = getValue1();\n-            Val val2 = getValue2();\n-            if (val1.length(sel, ctx, bstate.state1) == 1 \n-                && val2.length(sel, ctx, bstate.state2) == 1) {\n-                ctx.store.getDBDictionary().comparison(buf, \"=\",\n-                    new FilterValueImpl(sel, ctx, bstate.state1, val1),\n-                    new FilterValueImpl(sel, ctx, bstate.state2, val2));\n-            } else {\n-                int len = java.lang.Math.max(val1.length(sel, ctx, \n-                    bstate.state1), val2.length(sel, ctx, bstate.state2));\n-                for (int i = 0; i < len; i++) {\n-                    if (i > 0)\n-                        buf.append(\" AND \");\n-\n-                    val1.appendTo(sel, ctx, bstate.state1, buf, i);\n-                    buf.append(\" = \");\n-                    val2.appendTo(sel, ctx, bstate.state2, buf, i);\n-                }\n-            }\n-        }\n-    }\n-}"},{"sha":"add1fb7a2a98fd8ce2f208de518dca2d6055581e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Exp.java","status":"removed","additions":0,"deletions":59,"changes":59,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Exp.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Exp.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Exp.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,59 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.util.Map;\n-\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.exps.Expression;\n-\n-/**\n- * An Expression represents a query ready for execution. Generally, it is\n- * a set of conditions that must be met for the query to be true.\n- *\n- * @author Abe White\n- */\n-interface Exp\n-    extends Expression {\n-\n-    /**\n-     * Initialize the expression. This method should recursively\n-     * initialize any sub-expressions or values.\n-     *\n-     * @param contains map of relation paths to the number of times\n-     * the paths appear in a contains() expression;\n-     * used to ensure paths used for contains() within\n-     * the same AND expression used different aliases\n-     */\n-    public ExpState initialize(Select sel, ExpContext ctx, Map contains);\n-\n-    /**\n-     * Append the SQL for this expression to the given buffer. The SQL\n-     * should optionally include any joins this expression needs.\n-     */\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf);\n-\n-    /**\n-     * Select just the columns for this expression.\n-     */\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks);\n-}"},{"sha":"f59e172214ada7ee72fb245d38c7b5e8efe4ea87","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ExpContext.java","status":"removed","additions":0,"deletions":56,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ExpContext.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ExpContext.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ExpContext.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,56 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-\n-/**\n- * Expression tree context.\n- * \n- * @author Abe White\n- * @nojavadoc\n- */\n-public class ExpContext {\n-\n-    /**\n-     * Store.\n-     */\n-    public JDBCStore store;\n-\n-    /**\n-     * Parameters to query.\n-     */\n-    public Object[] params;\n-\n-    /**\n-     * Fetch configuration.\n-     */\n-    public JDBCFetchConfiguration fetch; \n-\n-    public ExpContext() {\n-    }\n-\n-    public ExpContext(JDBCStore store, Object[] params, \n-        JDBCFetchConfiguration fetch) {\n-        this.store = store;\n-        this.params = params;\n-        this.fetch = fetch;\n-    }\n-}"},{"sha":"5a0a99fd48d1095990a22ce9d2aab33947c27682","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ExpState.java","status":"removed","additions":0,"deletions":44,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ExpState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ExpState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ExpState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,44 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.sql.Joins;\n-\n-/**\n- * Expression tree state.\n- * \n- * @author Abe White\n- * @nojavadoc\n- */\n-public class ExpState {\n-\n-    /**\n-     * State with no joins.\n-     */\n-    public static final ExpState NULL = new ExpState();\n-\n-    public Joins joins;\n-\n-    public ExpState() {\n-    }\n-\n-    public ExpState(Joins joins) {\n-        this.joins = joins;\n-    }\n-}"},{"sha":"6683be36abccea1cd3365c99b367133cd1d36bd8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Extension.java","status":"removed","additions":0,"deletions":224,"changes":224,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Extension.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Extension.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Extension.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,224 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.sql.SQLException;\n-import java.util.Map;\n-\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.Filters;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-import org.apache.openjpa.meta.ClassMetaData;\n-\n-/**\n- * Filter listener that evaluates to a value.\n- *\n- * @author Abe White\n- */\n-class Extension\n-    extends AbstractVal\n-    implements Val, Exp {\n-\n-    private final JDBCFilterListener _listener;\n-    private final Val _target;\n-    private final Val _arg;\n-    private final ClassMapping _candidate;\n-    private ClassMetaData _meta = null;\n-    private Class _cast = null;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public Extension(JDBCFilterListener listener, Val target,\n-        Val arg, ClassMapping candidate) {\n-        _listener = listener;\n-        _target = target;\n-        _arg = arg;\n-        _candidate = candidate;\n-    }\n-\n-    public ClassMetaData getMetaData() {\n-        return _meta;\n-    }\n-\n-    public void setMetaData(ClassMetaData meta) {\n-        _meta = meta;\n-    }\n-\n-    public boolean isVariable() {\n-        return false;\n-    }\n-\n-    public boolean isAggregate() {\n-        return false;\n-    }\n-\n-    public Class getType() {\n-        if (_cast != null)\n-            return _cast;\n-        Class targetClass = (_target == null) ? null : _target.getType();\n-        return _listener.getType(targetClass, getArgTypes());\n-    }\n-\n-    private Class[] getArgTypes() {\n-        if (_arg == null)\n-            return null;\n-        if (_arg instanceof Args)\n-            return ((Args) _arg).getTypes();\n-        return new Class[]{ _arg.getType() };\n-    }\n-\n-    public void setImplicitType(Class type) {\n-        _cast = type;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n-        // note that we tell targets and args to extensions that are sql\n-        // paths to go ahead and join to their related object (if any),\n-        // because we assume that, unlike most operations, if a relation\n-        // field like a 1-1 is given as the target of an extension, then\n-        // the extension probably acts on some field or column in the\n-        // related object, not the 1-1 field itself\n-        ExpState targetState = null;\n-        ExpState argState = null;\n-        if (_target != null)\n-            targetState = _target.initialize(sel, ctx, JOIN_REL);\n-        if (_arg != null)\n-            argState = _arg.initialize(sel, ctx, JOIN_REL);\n-        Joins j1 = (targetState == null) ? null : targetState.joins;\n-        Joins j2 = (argState == null) ? null : argState.joins;\n-        return new ExtensionExpState(sel.and(j1, j2), targetState, \n-            argState);\n-    }\n-\n-    /**\n-     * Expression state.\n-     */\n-    private static class ExtensionExpState\n-        extends ExpState {\n-\n-        public final ExpState targetState;\n-        public final ExpState argState;\n-\n-        public ExtensionExpState(Joins joins, ExpState targetState,\n-            ExpState argState) {\n-            super(joins);\n-            this.targetState = targetState;\n-            this.argState = argState;\n-        }\n-    }\n-\n-    public void select(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        sel.select(newSQLBuffer(sel, ctx, state), this);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        ExtensionExpState estate = (ExtensionExpState) state;\n-        if (_target != null)\n-            _target.selectColumns(sel, ctx, estate.targetState, true);\n-        if (_arg != null)\n-            _arg.selectColumns(sel, ctx, estate.argState, true);\n-    }\n-\n-    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n-        sel.groupBy(newSQLBuffer(sel, ctx, state));\n-    }\n-\n-    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n-        boolean asc) {\n-        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n-    }\n-\n-    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n-        calculateValue(sel, ctx, state, null, null);\n-        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n-        appendTo(sel, ctx, state, buf, 0);\n-        return buf;\n-    }\n-\n-    public Object load(ExpContext ctx, ExpState state, Result res) \n-        throws SQLException {\n-        return Filters.convert(res.getObject(this,\n-            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n-    }\n-\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n-        Val other, ExpState otherState) {\n-        ExtensionExpState estate = (ExtensionExpState) state;\n-        if (_target != null)\n-            _target.calculateValue(sel, ctx, estate.targetState, null, null);\n-        if (_arg != null)\n-            _arg.calculateValue(sel, ctx, estate.argState, null, null);\n-    }\n-\n-    public int length(Select sel, ExpContext ctx, ExpState state) {\n-        return 1;\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql, int index) {\n-        ExtensionExpState estate = (ExtensionExpState) state;\n-        FilterValue target = (_target == null) ? null\n-            : new FilterValueImpl(sel, ctx, estate.targetState, _target);\n-        _listener.appendTo(sql, target, getArgs(sel, ctx, estate.argState),\n-            _candidate, ctx.store);\n-        sel.append(sql, state.joins);\n-    }\n-\n-    private FilterValue[] getArgs(Select sel, ExpContext ctx, ExpState state) {\n-        if (_arg == null)\n-            return null;\n-        if (_arg instanceof Args)\n-            return ((Args) _arg).newFilterValues(sel, ctx, state);\n-        return new FilterValue[] {\n-            new FilterValueImpl(sel, ctx, state, _arg)\n-        };\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter((Exp) this);\n-        if (_target != null)\n-            _target.acceptVisit(visitor);\n-        if (_arg != null)\n-            _arg.acceptVisit(visitor);\n-        visitor.exit((Exp) this);\n-    }\n-\n-    //////////////////////\n-    // Exp implementation\n-    //////////////////////\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n-        return initialize(sel, ctx, 0);\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql) {\n-        calculateValue(sel, ctx, state, null, null);\n-        appendTo(sel, ctx, state, sql, 0);\n-        sel.append(sql, state.joins);\n-    }\n-}"},{"sha":"a2a63f4d7956c8b80f0e7da2cffb899ea3b198ca","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValue.java","status":"removed","additions":0,"deletions":119,"changes":119,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValue.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValue.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,119 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.meta.FieldMapping;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.Table;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.meta.XMLMetaData;\n-\n-/**\n- * The simplified public view of any non-operator in a query filter,\n- * including constants, variables, and object fields.\n- *\n- * @author Abe White\n- */\n-public interface FilterValue {\n-\n-    /**\n-     * Return the expected type of this value.\n-     */\n-    public Class getType();\n-\n-    /**\n-     * Return the number of SQL elements in this value. Usually 1.\n-     */\n-    public int length();\n-\n-    /**\n-     * Append the first SQL element for this value to the given buffer.\n-     */\n-    public void appendTo(SQLBuffer buf);\n-\n-    /**\n-     * Append the <code>index</code>th SQL element for this value to the\n-     * given buffer.\n-     */\n-    public void appendTo(SQLBuffer buf, int index);\n-\n-    /**\n-     * Return the alias to use for the given column (this includes the table\n-     * alias prefix, if any).\n-     */\n-    public String getColumnAlias(Column col);\n-\n-    /**\n-     * Return the alias to use for the given column (this includes the table\n-     * alias prefix, if any).\n-     */\n-    public String getColumnAlias(String col, Table table);\n-\n-    /**\n-     * Transform the given value into its datastore equivalent.\n-     */\n-    public Object toDataStoreValue(Object val);\n-\n-    /**\n-     * Return true if this value represents a literal or parameter.\n-     */\n-    public boolean isConstant();\n-\n-    /**\n-     * If this is a constant, return its value, else return null.\n-     */\n-    public Object getValue();\n-\n-    /**\n-     * If this is a constant, returns its value as it would be represented\n-     * in the database in this context, else return null.\n-     */\n-    public Object getSQLValue();\n-\n-    /**\n-     * Return true if this value represents a persistent field traversal,\n-     * such as 'this', 'address.street', or 'projectVariable.title'.\n-     */\n-    public boolean isPath();\n-\n-    /**\n-     * If this is a path to a persistent object, return its class mapping,\n-     * else return null.\n-     */\n-    public ClassMapping getClassMapping();\n-\n-    /**\n-     * If this is a path to a persistent field, return its mapping, else\n-     * return null.\n-     */\n-    public FieldMapping getFieldMapping();\n-    \n-    /**\n-     * If this is an XPath, return it,\n-     * else return null;\n-     */\n-    public PCPath getXPath();\n-    \n-    /**\n-     * If this is an XPath, return XML mapping metadata,\n-     * else return null;\n-     */\n-    public XMLMetaData getXmlMapping();\n-}"},{"sha":"bfa10db61f0f7dcfc7a39232a695148a8b112cd4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValueImpl.java","status":"removed","additions":0,"deletions":113,"changes":113,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValueImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValueImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/FilterValueImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,113 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.meta.FieldMapping;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.Table;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.meta.XMLMetaData;\n-\n-/**\n- * Implementation of {@link FilterValue} that wraps a {@link Val}.\n- *\n- * @author Abe White\n- */\n-class FilterValueImpl\n-    implements FilterValue {\n-\n-    private final Select _sel;\n-    private final ExpContext _ctx;\n-    private final ExpState _state;\n-    private final Val _val;\n-\n-    public FilterValueImpl(Select sel, ExpContext ctx, ExpState state, \n-        Val val) {\n-        _sel = sel;\n-        _ctx = ctx;\n-        _state = state;\n-        _val = val;\n-    }\n-\n-    public Class getType() {\n-        return _val.getType();\n-    }\n-\n-    public int length() {\n-        return _val.length(_sel, _ctx, _state);\n-    }\n-\n-    public void appendTo(SQLBuffer buf) {\n-        appendTo(buf, 0);\n-    }\n-\n-    public void appendTo(SQLBuffer buf, int index) {\n-        _val.appendTo(_sel, _ctx, _state, buf, index);\n-    }\n-\n-    public String getColumnAlias(Column col) {\n-        return _sel.getColumnAlias(col, _state.joins);\n-    }\n-\n-    public String getColumnAlias(String col, Table table) {\n-        return _sel.getColumnAlias(col, table, _state.joins);\n-    }\n-\n-    public Object toDataStoreValue(Object val) {\n-        return _val.toDataStoreValue(_sel, _ctx, _state, val);\n-    }\n-\n-    public boolean isConstant() {\n-        return _val instanceof Const;\n-    }\n-\n-    public Object getValue() {\n-        return (isConstant()) ? ((Const) _val).getValue(_ctx.params) : null;\n-    }\n-\n-    public Object getSQLValue() {\n-        return (isConstant()) ? ((Const) _val).getSQLValue(_sel, _ctx, _state) \n-            : null;\n-    }\n-\n-    public boolean isPath() {\n-        return _val instanceof PCPath;\n-    }\n-\n-    public ClassMapping getClassMapping() {\n-        return (isPath()) ? ((PCPath) _val).getClassMapping(_state) : null;\n-    }\n-\n-    public FieldMapping getFieldMapping() {\n-        return (isPath()) ? ((PCPath) _val).getFieldMapping(_state) : null;\n-    }\n-    \n-    public PCPath getXPath() {\n-        if (isPath() && ((PCPath) _val).isXPath())\n-            return (PCPath) _val;\n-        else\n-            return null;\n-    }\n-    \n-    public XMLMetaData getXmlMapping() {\n-        return (getXPath() == null) ? null : getXPath().getXmlMapping();\n-    }\n-}"},{"sha":"64d26732b84b44fc6037a197357dbf53a37fb5ee","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetColumn.java","status":"removed","additions":0,"deletions":83,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetColumn.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetColumn.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,83 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.kernel.StoreContext;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.util.UnsupportedException;\n-import org.apache.openjpa.util.UserException;\n-\n-/**\n- * Returns the SQL alias of the named column for use in a query. Note that\n- * to retrieve columns in the table of the candidate object, you must\n- * explicitly qualify the extension with <code>this</code>, as demonstrated\n- * in the second example below.\n- *  Examples:<br />\n- * <code> \"company.address.ext:getColumn (\\\"ID\\\") == 5\"<br />\n- * \"this.ext:getColumn (\\\"CLS\\\") == \\\"org.apache.openjpa.example.Person\\\"\"\n- * </code>\n- *\n- * @nojavadoc\n- */\n-public class GetColumn\n-    implements JDBCFilterListener {\n-\n-    public static final String TAG = \"getColumn\";\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (GetColumn.class);\n-\n-    public String getTag() {\n-        return TAG;\n-    }\n-\n-    public boolean expectsArguments() {\n-        return true;\n-    }\n-\n-    public boolean expectsTarget() {\n-        return true;\n-    }\n-\n-    public Object evaluate(Object target, Class targetClass, Object[] args,\n-        Class[] argClasses, Object candidate, StoreContext ctx) {\n-        throw new UnsupportedException(_loc.get(\"no-in-mem\", TAG));\n-    }\n-\n-    public void appendTo(SQLBuffer buf, FilterValue target,\n-        FilterValue[] args, ClassMapping type, JDBCStore store) {\n-        if (!args[0].isConstant())\n-            throw new UserException(_loc.get(\"const-only\", TAG));\n-        if (!target.isPath())\n-            throw new UserException(_loc.get(\"path-only\", TAG));\n-\n-        // alias the column using the target's context, so that the\n-        // correct relation path to the target is used\n-        ClassMapping mapping = target.getClassMapping();\n-        String colName = args[0].getValue().toString();\n-        buf.append(target.getColumnAlias(colName, mapping.getTable()));\n-    }\n-\n-    public Class getType(Class targetClass, Class[] argClasses) {\n-        return Object.class;\n-    }\n-}"},{"sha":"a47794298025826ae84f2f42e893488aa257d9bc","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetMapValue.java","status":"removed","additions":0,"deletions":213,"changes":213,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetMapValue.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetMapValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetMapValue.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,213 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.meta.FieldMapping;\n-import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n-import org.apache.openjpa.jdbc.meta.strats.ContainerFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.LRSMapFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.RelationStrategies;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.Filters;\n-import org.apache.openjpa.meta.ClassMetaData;\n-\n-/**\n- * Returns the value of the given map's key.\n- *\n- * @author Marc Prud'hommeaux\n- */\n-class GetMapValue\n-    extends AbstractVal {\n-\n-    private final Val _map;\n-    private final Val _key;\n-    private final String _alias;\n-    private ClassMetaData _meta = null;\n-    private Class _cast = null;\n-\n-    /**\n-     * Constructor. Provide the map and key to operate on.\n-     */\n-    public GetMapValue(Val map, Val key, String alias) {\n-        _map = map;\n-        _key = key;\n-        _alias = alias;\n-    }\n-\n-    public ClassMetaData getMetaData() {\n-        return _meta;\n-    }\n-\n-    public void setMetaData(ClassMetaData meta) {\n-        _meta = meta;\n-    }\n-\n-    public boolean isVariable() {\n-        return false;\n-    }\n-\n-    public Class getType() {\n-        if (_cast != null)\n-            return _cast;\n-        return _map.getType();\n-    }\n-\n-    public void setImplicitType(Class type) {\n-        _cast = type;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n-        ExpState mapState = _map.initialize(sel, ctx, 0);\n-        ExpState keyState = _key.initialize(sel, ctx, 0);\n-        return new GetMapValueExpState(sel.and(mapState.joins, keyState.joins),\n-            mapState, keyState);\n-    }\n-\n-    /**\n-     * Expression state.\n-     */\n-    private static class GetMapValueExpState\n-        extends ExpState {\n-\n-        public final ExpState mapState;\n-        public final ExpState keyState;\n-\n-        public GetMapValueExpState(Joins joins, ExpState mapState, \n-            ExpState keyState) {\n-            super(joins);\n-            this.mapState = mapState;\n-            this.keyState = keyState;\n-        }\n-    }\n-\n-    public Object toDataStoreValue(Select sel, ExpContext ctx, ExpState state, \n-        Object val) {\n-        GetMapValueExpState gstate = (GetMapValueExpState) state;\n-        return _map.toDataStoreValue(sel, ctx, gstate.mapState, val);\n-    }\n-\n-\n-    public void select(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        sel.select(newSQLBuffer(sel, ctx, state).append(\" AS \").append(_alias),\n-            this);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state,\n-        boolean pks) {\n-        GetMapValueExpState gstate = (GetMapValueExpState) state;\n-        _map.selectColumns(sel, ctx, gstate.mapState, true);\n-        _key.selectColumns(sel, ctx, gstate.keyState, true);\n-    }\n-\n-    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n-        sel.groupBy(newSQLBuffer(sel, ctx, state));\n-    }\n-\n-    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n-        boolean asc) {\n-        sel.orderBy(_alias, asc, false);\n-    }\n-\n-    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n-        calculateValue(sel, ctx, state, null, null);\n-        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n-        appendTo(sel, ctx, state, buf, 0);\n-        return buf;\n-    }\n-\n-    public Object load(ExpContext ctx, ExpState state, Result res)\n-        throws SQLException {\n-        return Filters.convert(res.getObject(this,\n-            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n-    }\n-\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n-        Val other, ExpState otherState) {\n-        GetMapValueExpState gstate = (GetMapValueExpState) state;\n-        _map.calculateValue(sel, ctx, gstate.mapState, null, null);\n-        _key.calculateValue(sel, ctx, gstate.keyState, null, null);\n-    }\n-\n-    public int length(Select sel, ExpContext ctx, ExpState state) {\n-        return 1;\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql, int index) {\n-        if (!(_map instanceof PCPath))\n-            throw new UnsupportedOperationException();\n-        if (!(_key instanceof Const))\n-            throw new UnsupportedOperationException();\n-\n-        GetMapValueExpState gstate = (GetMapValueExpState) state;\n-        PCPath map = (PCPath) _map;\n-        Object key = ((Const) _key).getValue(ctx, gstate.keyState);\n-        FieldMapping field = map.getFieldMapping(gstate.mapState);\n-        if (!(field.getStrategy() instanceof LRSMapFieldStrategy))\n-            throw new UnsupportedOperationException();\n-\n-        LRSMapFieldStrategy strat = (LRSMapFieldStrategy) field.getStrategy();\n-        ClassMapping[] clss = strat.getIndependentValueMappings(true);\n-        if (clss != null && clss.length > 1)\n-            throw RelationStrategies.unjoinable(field);\n-\n-        ClassMapping cls = (clss.length == 0) ? null : clss[0];\n-        ForeignKey fk = strat.getJoinForeignKey(cls);\n-\n-        // manually create a subselect for the Map's value\n-        sql.append(\"(SELECT \");\n-        Column[] values = field.getElementMapping().getColumns();\n-        for (int i = 0; i < values.length; i++) {\n-            if (i > 0)\n-                sql.append(\", \");\n-            sql.append(values[i].getFullName());\n-        }\n-        sql.append(\" FROM \").append(values[0].getTable().getFullName()).\n-            append(\" WHERE \");\n-\n-        // add in the joins\n-        ContainerFieldStrategy.appendUnaliasedJoin(sql, sel, null, \n-            ctx.store.getDBDictionary(), field, fk);\n-        sql.append(\" AND \");\n-\n-        key = strat.toKeyDataStoreValue(key, ctx.store);\n-        Column[] cols = strat.getKeyColumns(cls);\n-        Object[] vals = (cols.length == 1) ? null : (Object[]) key;\n-\n-        for (int i = 0; i < cols.length; i++) {\n-            sql.append(cols[i].getFullName());\n-            if (vals == null)\n-                sql.append((key == null) ? \" IS \" : \" = \").\n-                    appendValue(key, cols[i]);\n-            else\n-                sql.append((vals[i] == null) ? \" IS \" : \" = \").\n-                    appendValue(vals[i], cols[i]);\n-        }\n-        sql.append(\")\");\n-    }\n-}"},{"sha":"120bfee9d892ad9900308a820a8cb48c61d42e08","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetObjectId.java","status":"removed","additions":0,"deletions":176,"changes":176,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetObjectId.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetObjectId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/GetObjectId.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,176 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.meta.Joinable;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.Filters;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.util.ApplicationIds;\n-import org.apache.openjpa.util.Id;\n-import org.apache.openjpa.util.OpenJPAId;\n-import org.apache.openjpa.util.UserException;\n-import serp.util.Numbers;\n-\n-/**\n- * Select the oid value of an object; typically used in projections.\n- *\n- * @author Abe White\n- */\n-class GetObjectId\n-    extends AbstractVal {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (GetObjectId.class);\n-\n-    private final PCPath _path;\n-    private ClassMetaData _meta = null;\n-\n-    /**\n-     * Constructor. Provide the value whose oid to extract.\n-     */\n-    public GetObjectId(PCPath path) {\n-        _path = path;\n-    }\n-\n-    /**\n-     * Return the oid columns.\n-     */\n-    public Column[] getColumns(ExpState state) {\n-        return _path.getClassMapping(state).getPrimaryKeyColumns();\n-    }\n-\n-    public ClassMetaData getMetaData() {\n-        return _meta;\n-    }\n-\n-    public void setMetaData(ClassMetaData meta) {\n-        _meta = meta;\n-    }\n-\n-    public Class getType() {\n-        return Object.class;\n-    }\n-\n-    public void setImplicitType(Class type) {\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n-        ExpState state = _path.initialize(sel, ctx, JOIN_REL);\n-\n-        // it's difficult to get calls on non-pc fields to always return null\n-        // without screwing up the SQL, to just don't let users call it on\n-        // non-pc fields at all\n-        ClassMapping cls = _path.getClassMapping(state);\n-        if (cls == null || cls.getEmbeddingMapping() != null)\n-            throw new UserException(_loc.get(\"bad-getobjectid\",\n-                _path.getFieldMapping(state)));\n-        return state;\n-    }\n-\n-    public Object toDataStoreValue(Select sel, ExpContext ctx, ExpState state, \n-        Object val) {\n-        // if datastore identity, try to convert to a long value\n-        ClassMapping mapping = _path.getClassMapping(state);\n-        if (mapping.getIdentityType() == mapping.ID_DATASTORE) {\n-            if (val instanceof Id)\n-                return Numbers.valueOf(((Id) val).getId());\n-            return Filters.convert(val, long.class);\n-        }\n-\n-        // if unknown identity, can't do much\n-        if (mapping.getIdentityType() == mapping.ID_UNKNOWN)\n-            return (val instanceof OpenJPAId) ?\n-                ((OpenJPAId) val).getIdObject() : val;\n-\n-        // application identity; convert to pk values in the same order as\n-        // the mapping's primary key columns will be returned\n-        Object[] pks = ApplicationIds.toPKValues(val, mapping);\n-        if (pks.length == 1)\n-            return pks[0];\n-        if (val == null)\n-            return pks;\n-        while (!mapping.isPrimaryKeyObjectId(false))\n-            mapping = mapping.getJoinablePCSuperclassMapping();\n-\n-        Column[] cols = mapping.getPrimaryKeyColumns();\n-        Object[] vals = new Object[cols.length];\n-        Joinable join;\n-        for (int i = 0; i < cols.length; i++) {\n-            join = mapping.assertJoinable(cols[i]);\n-            vals[i] = pks[mapping.getField(join.getFieldIndex()).\n-                getPrimaryKeyIndex()];\n-            vals[i] = join.getJoinValue(vals[i], cols[i], ctx.store);\n-        }\n-        return vals;\n-    }\n-\n-    public void select(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        selectColumns(sel, ctx, state, true);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        _path.selectColumns(sel, ctx, state, true);\n-    }\n-\n-    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n-        _path.groupBy(sel, ctx, state);\n-    }\n-\n-    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n-        boolean asc) {\n-        _path.orderBy(sel, ctx, state, asc);\n-    }\n-\n-    public Object load(ExpContext ctx, ExpState state, Result res)\n-        throws SQLException {\n-        return _path.load(ctx, state, res, true);\n-    }\n-\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n-        Val other, ExpState otherState) {\n-        _path.calculateValue(sel, ctx, state, null, null);\n-    }\n-\n-    public int length(Select sel, ExpContext ctx, ExpState state) {\n-        return _path.length(sel, ctx, state);\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql, int index) {\n-        _path.appendTo(sel, ctx, state, sql, index);\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        _path.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-}\n-"},{"sha":"e177c4449743ab29fdb186bd585e4d806afdf4c6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/HasContainsExpressionVisitor.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/HasContainsExpressionVisitor.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/HasContainsExpressionVisitor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/HasContainsExpressionVisitor.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,47 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.kernel.exps.AbstractExpressionVisitor;\n-import org.apache.openjpa.kernel.exps.Expression;\n-\n-/**\n- * Determines whether the visited expressions include a \"contains\" expression.\n- * \n- * @author Abe White\n- */\n-class HasContainsExpressionVisitor \n-    extends AbstractExpressionVisitor {\n-\n-    private boolean _found = false;\n-\n-    public static boolean hasContains(Expression exp) {\n-        if (exp == null)\n-            return false;\n-        HasContainsExpressionVisitor v = new HasContainsExpressionVisitor();\n-        exp.acceptVisit(v);\n-        return v._found;\n-    }\n-\n-    public void enter(Expression exp) {\n-        if (!_found)\n-            _found = exp instanceof ContainsExpression \n-                || exp instanceof BindVariableAndExpression;\n-    }\n-} "},{"sha":"3f5a31bcf1237d08405fcc835aa65c6b1035691a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InExpression.java","status":"removed","additions":0,"deletions":224,"changes":224,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InExpression.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InExpression.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,224 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-\n-/**\n- * Tests whether a value is IN a collection.\n- *\n- * @author Abe White\n- */\n-class InExpression\n-    implements Exp {\n-\n-    private final Val _val;\n-    private final Const _const;\n-\n-    /**\n-     * Constructor. Supply the value to test and the constant to obtain\n-     * the parameters from.\n-     */\n-    public InExpression(Val val, Const constant) {\n-        _val = val;\n-        _const = constant;\n-    }\n-\n-    /**\n-     * Constant collection.\n-     */\n-    public Const getConstant() {\n-        return _const;\n-    }\n-\n-    /**\n-     * Contained value.\n-     */\n-    public Val getValue() {\n-        return _val;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n-        ExpState valueState = _val.initialize(sel, ctx, 0);\n-        ExpState constantState = _const.initialize(sel, ctx, 0);\n-        return new InExpState(valueState.joins, constantState, valueState);\n-    }\n-\n-    /**\n-     * Expression state.\n-     */\n-    private static class InExpState\n-        extends ExpState {\n-\n-        public final ExpState constantState;\n-        public final ExpState valueState;\n-\n-        public InExpState(Joins joins, ExpState constantState, \n-            ExpState valueState) {\n-            super(joins);\n-            this.constantState = constantState;\n-            this.valueState = valueState;\n-        }\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf) {\n-        InExpState istate = (InExpState) state; \n-        _const.calculateValue(sel, ctx, istate.constantState, null, null);\n-        _val.calculateValue(sel, ctx, istate.valueState, null, null);\n-\n-        List list = null;\n-        Collection coll = getCollection(ctx, istate.constantState);\n-        if (coll != null) {\n-            list = new ArrayList(coll.size());\n-            for (Iterator itr = coll.iterator(); itr.hasNext();)\n-                list.add(_val.toDataStoreValue(sel, ctx, istate.valueState, \n-                    itr.next()));\n-        }\n-\n-        Column[] cols = null;\n-        if (_val instanceof PCPath)\n-            cols = ((PCPath) _val).getColumns(istate.valueState);\n-        else if (_val instanceof GetObjectId)\n-            cols = ((GetObjectId) _val).getColumns(istate.valueState);\n-\n-        if (list == null || list.isEmpty())\n-            buf.append(\"1 <> 1\");\n-        else if (_val.length(sel, ctx, istate.valueState) == 1)\n-            createInContains(sel, ctx, istate.valueState, buf, list, cols);\n-        else\n-            orContains(sel, ctx, istate.valueState, buf, list, cols);\n-        sel.append(buf, state.joins);\n-    }\n-\n-    /**\n-     * Based on the inClauseLimit of the DBDictionary, create the needed IN \n-     * clauses\n-     */\n-    private void createInContains(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf, List list, Column[] cols) {\n-\n-        int inClauseLimit = ctx.store.getDBDictionary().inClauseLimit;\n-        if (inClauseLimit <= 0 || list.size() <= inClauseLimit)\n-            inContains(sel, ctx, state, buf, list, cols);\n-        else {\n-            buf.append(\"(\");\n-            for (int low = 0, high; low < list.size(); low = high) {\n-                if (low > 0)\n-                    buf.append(\" OR \");\n-                high = java.lang.Math.min(low + inClauseLimit, list.size());\n-                inContains(sel, ctx, state, buf, list.subList(low, high), cols);\n-            }\n-            buf.append(\")\");\n-        }\n-    }\n-\n-    /**\n-     * Construct an IN clause with the value of the given collection.\n-     */\n-    private void inContains(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf, Collection coll, Column[] cols) {\n-        _val.appendTo(sel, ctx, state, buf, 0);\n-        buf.append(\" IN (\");\n-\n-        Column col = (cols != null && cols.length == 1) ? cols[0] : null;\n-        for (Iterator itr = coll.iterator(); itr.hasNext();) {\n-            buf.appendValue(itr.next(), col);\n-            if (itr.hasNext())\n-                buf.append(\", \");\n-        }\n-        buf.append(\")\");\n-    }\n-\n-    /**\n-     * If the value to test is a compound key, we can't use IN,\n-     * so create a clause like '(a = b AND c = d) OR (e = f AND g = h) ...'\n-     */\n-    private void orContains(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf, Collection coll, Column[] cols) {\n-        if (coll.size() > 1)\n-            buf.append(\"(\");\n-\n-        Object[] vals;\n-        Column col;\n-        for (Iterator itr = coll.iterator(); itr.hasNext();) {\n-            vals = (Object[]) itr.next();\n-\n-            buf.append(\"(\");\n-            for (int i = 0; i < vals.length; i++) {\n-                col = (cols != null && cols.length == vals.length)\n-                    ? cols[i] : null;\n-                if (i > 0)\n-                    buf.append(\" AND \");\n-\n-                _val.appendTo(sel, ctx, state, buf, i);\n-                if (vals[i] == null)\n-                    buf.append(\" IS \");\n-                else\n-                    buf.append(\" = \");\n-                buf.appendValue(vals[i], col);\n-            }\n-            buf.append(\")\");\n-\n-            if (itr.hasNext())\n-                buf.append(\" OR \");\n-        }\n-        if (coll.size() > 1)\n-            buf.append(\")\");\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        InExpState istate = (InExpState) state; \n-        _const.selectColumns(sel, ctx, istate.constantState, true);\n-        _val.selectColumns(sel, ctx, istate.valueState, true);\n-    }\n-\n-    /**\n-     * Return the collection to test for containment with.\n-     */\n-    protected Collection getCollection(ExpContext ctx, ExpState state) {\n-        Object val = _const.getValue(ctx, state);\n-\n-        // wrap non-Collection parameters in a Collections so the query\n-        // lanuage can permit varargs \"in\" clauses\n-        if (!(val instanceof Collection))\n-            val = Collections.singleton(val);\n-\n-        return (Collection) val;\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        _val.acceptVisit(visitor);\n-        _const.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-}"},{"sha":"94bb4dc43f5a3fa788f8cabd6fa376f3a876e7a9","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InKeyExpression.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InKeyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InKeyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InKeyExpression.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,47 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.util.Collection;\n-import java.util.Map;\n-\n-/**\n- * Tests whether a value is IN a map key set.\n- *\n- * @author Abe White\n- */\n-class InKeyExpression\n-    extends InExpression {\n-\n-    /**\n-     * Constructor. Supply the value to test and the constant to obtain\n-     * the parameters from.\n-     */\n-    public InKeyExpression(Val val, Const constant) {\n-        super(val, constant);\n-    }\n-\n-    /**\n-     * Return the collection to test for containment with.\n-     */\n-    protected Collection getCollection(ExpContext ctx, ExpState state) {\n-        Map map = (Map) getConstant().getValue(ctx, state);\n-        return (map == null) ? null : map.keySet();\n-    }\n-}"},{"sha":"95bcea6effa209e3ca9d562512f410c0925def02","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InSubQExpression.java","status":"removed","additions":0,"deletions":93,"changes":93,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InSubQExpression.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InSubQExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InSubQExpression.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,93 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.util.Map;\n-\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-\n-/**\n- * Tests whether a value is IN a subquery.\n- *\n- * @author Abe White\n- */\n-class InSubQExpression\n-    implements Exp {\n-\n-    private final Val _val;\n-    private final SubQ _sub;\n-\n-    /**\n-     * Constructor. Supply the value to test and the subquery.\n-     */\n-    public InSubQExpression(Val val, SubQ sub) {\n-        _val = val;\n-        _sub = sub;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n-        ExpState subqState = _sub.initialize(sel, ctx, 0);\n-        ExpState valueState = _val.initialize(sel, ctx, 0);\n-        return new InSubQExpState(valueState.joins, subqState, valueState);\n-    }\n-\n-    /**\n-     * Expression state.\n-     */\n-    private static class InSubQExpState\n-        extends ExpState {\n-\n-        public final ExpState subqState;\n-        public final ExpState valueState;\n-\n-        public InSubQExpState(Joins joins, ExpState subqState, \n-            ExpState valueState) {\n-            super(joins);\n-            this.subqState = subqState;\n-            this.valueState = valueState;\n-        }\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf) {\n-        InSubQExpState istate = (InSubQExpState) state;\n-        _sub.calculateValue(sel, ctx, istate.subqState, null, null);\n-        _val.calculateValue(sel, ctx, istate.valueState, null, null);\n-        _val.appendTo(sel, ctx, istate.valueState, buf, 0);\n-        buf.append(\" IN \");\n-        _sub.appendTo(sel, ctx, istate.valueState, buf, 0);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        InSubQExpState istate = (InSubQExpState) state;\n-        _sub.selectColumns(sel, ctx, istate.subqState, pks);\n-        _val.selectColumns(sel, ctx, istate.valueState, true);\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        _val.acceptVisit(visitor);\n-        _sub.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-}"},{"sha":"fd37e796fccb0db2434fe5d3338f90f13ee1534c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InValueExpression.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InValueExpression.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InValueExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InValueExpression.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,47 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.util.Collection;\n-import java.util.Map;\n-\n-/**\n- * Tests whether a value is IN a map value collection.\n- *\n- * @author Abe White\n- */\n-class InValueExpression\n-    extends InExpression {\n-\n-    /**\n-     * Constructor. Supply the value to test and the constant to obtain\n-     * the parameters from.\n-     */\n-    public InValueExpression(Val val, Const constant) {\n-        super(val, constant);\n-    }\n-\n-    /**\n-     * Return the collection to test for containment with.\n-     */\n-    protected Collection getCollection(ExpContext ctx, ExpState state) {\n-        Map map = (Map) getConstant().getValue(ctx, state);\n-        return (map == null) ? null : map.values();\n-    }\n-}"},{"sha":"ec0f36aabb65fd80a21a40903390deaa2b0d970d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IndexOf.java","status":"removed","additions":0,"deletions":156,"changes":156,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IndexOf.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IndexOf.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IndexOf.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,156 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.Filters;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-import org.apache.openjpa.meta.ClassMetaData;\n-\n-/**\n- * Find the index of one string within another.\n- *\n- * @author Abe White\n- */\n-public class IndexOf\n-    extends AbstractVal {\n-\n-    private final Val _val1;\n-    private final Val _val2;\n-    private ClassMetaData _meta = null;\n-    private Class _cast = null;\n-\n-    /**\n-     * Constructor. Provide the strings to operate on.\n-     */\n-    public IndexOf(Val val1, Val val2) {\n-        _val1 = val1;\n-        _val2 = val2;\n-    }\n-\n-    public Val getVal1() {\n-        return _val1;\n-    }\n-\n-    public Val getVal2() {\n-        return _val2;\n-    }\n-    public ClassMetaData getMetaData() {\n-        return _meta;\n-    }\n-\n-    public void setMetaData(ClassMetaData meta) {\n-        _meta = meta;\n-    }\n-\n-    public Class getType() {\n-        if (_cast != null)\n-            return _cast;\n-        return int.class;\n-    }\n-\n-    public void setImplicitType(Class type) {\n-        _cast = type;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n-        ExpState s1 = _val1.initialize(sel, ctx, 0);\n-        ExpState s2 = _val2.initialize(sel, ctx, 0);\n-        return new BinaryOpExpState(sel.and(s1.joins, s2.joins), s1, s2);\n-    }\n-\n-    public void select(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        sel.select(newSQLBuffer(sel, ctx, state), this);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        BinaryOpExpState bstate = (BinaryOpExpState) state;\n-        _val1.selectColumns(sel, ctx, bstate.state1, true);\n-        _val2.selectColumns(sel, ctx, bstate.state2, true);\n-    }\n-\n-    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n-        sel.groupBy(newSQLBuffer(sel, ctx, state));\n-    }\n-\n-    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n-        boolean asc) {\n-        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n-    }\n-\n-    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n-        calculateValue(sel, ctx, state, null, null);\n-        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n-        appendTo(sel, ctx, state, buf, 0);\n-        return buf;\n-    }\n-\n-    public Object load(ExpContext ctx, ExpState state, Result res) \n-        throws SQLException {\n-        return Filters.convert(res.getObject(this, JavaSQLTypes.JDBC_DEFAULT, \n-            null), getType());\n-    }\n-\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n-        Val other, ExpState otherState) {\n-        BinaryOpExpState bstate = (BinaryOpExpState) state;\n-        _val1.calculateValue(sel, ctx, bstate.state1, null, null);\n-        _val2.calculateValue(sel, ctx, bstate.state2, null, null);\n-    }\n-\n-    public int length(Select sel, ExpContext ctx, ExpState state) {\n-        return 1;\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql, int index) {\n-        BinaryOpExpState bstate = (BinaryOpExpState) state;\n-        FilterValue str = new FilterValueImpl(sel, ctx, bstate.state1, _val1);\n-        FilterValue search;\n-        FilterValue start = null;\n-        if (_val2 instanceof Args) {\n-            FilterValue[] filts = ((Args) _val2).newFilterValues(sel, ctx, \n-                bstate.state2);\n-            search = filts[0];\n-            start = filts[1];\n-        } else\n-            search = new FilterValueImpl(sel, ctx, bstate.state2, _val2);\n-\n-        ctx.store.getDBDictionary().indexOf(sql, str, search, start);\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        _val1.acceptVisit(visitor);\n-        _val2.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-\n-    public int getId() {\n-        return Val.INDEXOF_VAL;\n-    }\n-}\n-"},{"sha":"43046164129a0e72deb6233208120b6851526037","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InstanceofExpression.java","status":"removed","additions":0,"deletions":168,"changes":168,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InstanceofExpression.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InstanceofExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/InstanceofExpression.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,168 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.util.Map;\n-\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.meta.Discriminator;\n-import org.apache.openjpa.jdbc.meta.FieldMapping;\n-import org.apache.openjpa.jdbc.meta.MappingRepository;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-import org.apache.openjpa.meta.JavaTypes;\n-\n-/**\n- * Tests whether the given path is an instance of the given class.\n- *\n- * @author Abe White\n- */\n-class InstanceofExpression\n-    implements Exp {\n-\n-    private final PCPath _path;\n-    private final Class _cls;\n-\n-    /**\n-     * Constructor. Supply path and class to test for.\n-     */\n-    public InstanceofExpression(PCPath path, Class cls) {\n-        _path = path;\n-        _cls = cls;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n-        // note that we tell the path to go ahead and join to its related\n-        // object (if any) in order to access its class indicator\n-        ExpState pathState = _path.initialize(sel, ctx, Val.JOIN_REL);\n-\n-        // does this path represent a relation?  if not, what class\n-        // is the field?\n-        ClassMapping relMapping = _path.getClassMapping(pathState);\n-        Class rel = null;\n-        if (relMapping == null) {\n-            FieldMapping field = _path.getFieldMapping(pathState);\n-            switch (field.getTypeCode()) {\n-                case JavaTypes.MAP:\n-                    if (_path.isKey())\n-                        rel = field.getKey().getDeclaredType();\n-                    // no break\n-                case JavaTypes.ARRAY:\n-                case JavaTypes.COLLECTION:\n-                    rel = field.getElement().getDeclaredType();\n-                    break;\n-                default:\n-                    rel = field.getDeclaredType();\n-            }\n-        } else\n-            rel = relMapping.getDescribedType();\n-\n-        // if the path represents a relation, get its class indicator and\n-        // make sure it's joined down to its base type\n-        Discriminator discrim = (relMapping == null \n-            || !relMapping.getDescribedType().isAssignableFrom(_cls)) \n-            ? null : relMapping.getDiscriminator();\n-        ClassMapping mapping = null;\n-        Joins joins = pathState.joins;\n-        if (discrim != null) {\n-            // cache mapping for cast\n-            MappingRepository repos = ctx.store.getConfiguration().\n-                getMappingRepositoryInstance();\n-            mapping = repos.getMapping(_cls, ctx.store.getContext().\n-                getClassLoader(), false);\n-\n-            // if not looking for a PC, don't bother with indicator\n-            if (mapping == null || !discrim.hasClassConditions(mapping, true))\n-                discrim = null;\n-            else {\n-                ClassMapping owner = discrim.getClassMapping();\n-                ClassMapping from, to;\n-                if (relMapping.getDescribedType().isAssignableFrom\n-                    (owner.getDescribedType())) {\n-                    from = owner;\n-                    to = relMapping;\n-                } else {\n-                    from = relMapping;\n-                    to = owner;\n-                }\n-\n-                for (; from != null && from != to;\n-                    from = from.getJoinablePCSuperclassMapping())\n-                    joins = from.joinSuperclass(joins, false);\n-            }\n-        }\n-        return new InstanceofExpState(joins, pathState, mapping, discrim, rel);\n-    }\n-\n-    /**\n-     * Expression state.\n-     */\n-    private static class InstanceofExpState\n-        extends ExpState {\n-\n-        public final ExpState pathState;\n-        public final ClassMapping mapping;\n-        public final Discriminator discrim;\n-        public final Class rel;\n-\n-        public InstanceofExpState(Joins joins, ExpState pathState, \n-            ClassMapping mapping, Discriminator discrim, Class rel) {\n-            super(joins);\n-            this.pathState = pathState;\n-            this.mapping = mapping;\n-            this.discrim = discrim;\n-            this.rel = rel;\n-        }\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql) {\n-        // if no class indicator or a final class, just append true or false\n-        // depending on whether the cast matches the expected type\n-        InstanceofExpState istate = (InstanceofExpState) state;\n-        if (istate.discrim == null) {\n-            if (_cls.isAssignableFrom(istate.rel))\n-                sql.append(\"1 = 1\");\n-            else\n-                sql.append(\"1 <> 1\");\n-        } else {\n-            ctx.store.loadSubclasses(istate.discrim.getClassMapping());\n-            SQLBuffer buf = istate.discrim.getClassConditions(sel,\n-                istate.joins, istate.mapping, true);\n-            sql.append(buf);\n-        }\n-        sel.append(sql, istate.joins);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        InstanceofExpState istate = (InstanceofExpState) state;\n-        if (istate.discrim != null)\n-            sel.select(istate.discrim.getColumns(), istate.joins);\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        _path.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-}\n-"},{"sha":"1601c0cf9c764de96256db925fca323f71c7f080","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsEmptyExpression.java","status":"removed","additions":0,"deletions":65,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsEmptyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsEmptyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsEmptyExpression.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,65 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.util.Map;\n-\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-\n-/**\n- * Tests whether the given value is empty.\n- *\n- * @author Abe White\n- */\n-class IsEmptyExpression\n-    implements Exp {\n-\n-    private final Val _val;\n-\n-    /**\n-     * Constructor. Supply value to test.\n-     */\n-    public IsEmptyExpression(Val val) {\n-        _val = val;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n-        return _val.initialize(sel, ctx, Val.NULL_CMP);\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf) {\n-        _val.calculateValue(sel, ctx, state, null, null);\n-        _val.appendIsEmpty(sel, ctx, state, buf);\n-        sel.append(buf, state.joins);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        _val.selectColumns(sel, ctx, state, true);\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        _val.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-}"},{"sha":"2dc7ba2001fcaaca33aa447f884ede3460ba920c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsNotEmptyExpression.java","status":"removed","additions":0,"deletions":65,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsNotEmptyExpression.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsNotEmptyExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/IsNotEmptyExpression.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,65 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.util.Map;\n-\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-\n-/**\n- * Tests whether the given value is not empty.\n- *\n- * @author Marc Prud'hommeaux\n- */\n-class IsNotEmptyExpression\n-    implements Exp {\n-\n-    private final Val _val;\n-\n-    /**\n-     * Constructor. Supply value to test.\n-     */\n-    public IsNotEmptyExpression(Val val) {\n-        _val = val;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n-        return _val.initialize(sel, ctx, Val.NULL_CMP);\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf) {\n-        _val.calculateValue(sel, ctx, state, null, null);\n-        _val.appendIsNotEmpty(sel, ctx, state, buf);\n-        sel.append(buf, state.joins);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        _val.selectColumns(sel, ctx, state, true);\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        _val.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-}"},{"sha":"4e6d836cdadf54abcfdf8ee3f9be94287cf3676a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCAggregateListener.java","status":"removed","additions":0,"deletions":45,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCAggregateListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCAggregateListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCAggregateListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,45 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.kernel.exps.AggregateListener;\n-\n-/**\n- * JDBC extension to the {@link AggregateListener}.\n- *\n- * @author Abe White\n- */\n-public interface JDBCAggregateListener\n-    extends AggregateListener {\n-\n-    /**\n-     * Append the SQL for this aggregate.\n-     *\n-     * @param buf the SQL buffer to append to\n-     * @param args the values of the arguments given in the filter, or\n-     * null if this listener doesn't expect arguments\n-     * @param mapping the class mapping for the query's candidate class\n-     * @param store the store that owns the query\n-     */\n-    public void appendTo(SQLBuffer buf, FilterValue[] args,\n-        ClassMapping mapping, JDBCStore store);\n-}"},{"sha":"d3f760a1839bc9f01d337b4b1de7da2e3b3b2800","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","status":"removed","additions":0,"deletions":403,"changes":403,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,403 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.io.Serializable;\n-\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\n-import org.apache.openjpa.kernel.exps.AggregateListener;\n-import org.apache.openjpa.kernel.exps.Arguments;\n-import org.apache.openjpa.kernel.exps.Expression;\n-import org.apache.openjpa.kernel.exps.ExpressionFactory;\n-import org.apache.openjpa.kernel.exps.FilterListener;\n-import org.apache.openjpa.kernel.exps.Literal;\n-import org.apache.openjpa.kernel.exps.Parameter;\n-import org.apache.openjpa.kernel.exps.Path;\n-import org.apache.openjpa.kernel.exps.Subquery;\n-import org.apache.openjpa.kernel.exps.Value;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.util.UserException;\n-\n-/**\n- * Expression factory implementation that can be used to execute queries\n- * via SQL.\n- *\n- * @author Abe White\n- * @nojavadoc\n- */\n-public class JDBCExpressionFactory\n-    implements ExpressionFactory, Serializable {\n-\n-    private static final Val NULL = new Null();\n-    private static final Val CURRENT_DATE = new CurrentDate(JavaSQLTypes.DATE);\n-    private static final Val CURRENT_TIME = new CurrentDate(JavaSQLTypes.TIME);\n-    private static final Val CURRENT_TIMESTAMP =\n-        new CurrentDate(JavaSQLTypes.TIMESTAMP);\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (JDBCExpressionFactory.class);\n-\n-    private final ClassMapping _type;\n-    private final SelectConstructor _cons = new SelectConstructor();\n-    private int _getMapValueAlias = 0;\n-\n-    /**\n-     * Constructor. Supply the type we're querying against.\n-     */\n-    public JDBCExpressionFactory(ClassMapping type) {\n-        _type = type;\n-    }\n-\n-    /**\n-     * Use to create SQL select.\n-     */\n-    public SelectConstructor getSelectConstructor() {\n-        return _cons;\n-    }\n-\n-    public Expression emptyExpression() {\n-        return new EmptyExpression();\n-    }\n-\n-    public Expression asExpression(Value v) {\n-        return equal(v, newLiteral(Boolean.TRUE, Literal.TYPE_BOOLEAN));\n-    }\n-\n-    public Expression equal(Value v1, Value v2) {\n-        // if we're comparing an unaccessed bound variable, like in:\n-        // coll.contains (var) && var == x, then translate into:\n-        // coll.contains (x)\n-        if (v1 instanceof PCPath && ((PCPath) v1).isUnaccessedVariable())\n-            return contains(v1, v2);\n-        if (v2 instanceof PCPath && ((PCPath) v2).isUnaccessedVariable())\n-            return contains(v2, v1);\n-        return new EqualExpression((Val) v1, (Val) v2);\n-    }\n-\n-    public Expression notEqual(Value v1, Value v2) {\n-        return new NotEqualExpression((Val) v1, (Val) v2);\n-    }\n-\n-    public Expression lessThan(Value v1, Value v2) {\n-        return new CompareExpression((Val) v1, (Val) v2,\n-            CompareExpression.LESS);\n-    }\n-\n-    public Expression greaterThan(Value v1, Value v2) {\n-        return new CompareExpression((Val) v1, (Val) v2,\n-            CompareExpression.GREATER);\n-    }\n-\n-    public Expression lessThanEqual(Value v1, Value v2) {\n-        return new CompareExpression((Val) v1, (Val) v2,\n-            CompareExpression.LESS_EQUAL);\n-    }\n-\n-    public Expression greaterThanEqual(Value v1, Value v2) {\n-        return new CompareExpression((Val) v1, (Val) v2,\n-            CompareExpression.GREATER_EQUAL);\n-    }\n-\n-    public Expression isEmpty(Value val) {\n-        return new IsEmptyExpression((Val) val);\n-    }\n-\n-    public Expression isNotEmpty(Value val) {\n-        return new IsNotEmptyExpression((Val) val);\n-    }\n-\n-    public Expression contains(Value map, Value arg) {\n-        if (map instanceof Const)\n-            return new InExpression((Val) arg, (Const) map);\n-        if (map instanceof SubQ)\n-            return new InSubQExpression((Val) arg, (SubQ) map);\n-        return new ContainsExpression((Val) map, (Val) arg);\n-    }\n-\n-    public Expression containsKey(Value map, Value arg) {\n-        if (map instanceof Const)\n-            return new InKeyExpression((Val) arg, (Const) map);\n-        return new ContainsKeyExpression((Val) map, (Val) arg);\n-    }\n-\n-    public Expression containsValue(Value map, Value arg) {\n-        if (map instanceof Const)\n-            return new InValueExpression((Val) arg, (Const) map);\n-        return new ContainsExpression((Val) map, (Val) arg);\n-    }\n-\n-    public Expression isInstance(Value val, Class c) {\n-        if (val instanceof Const)\n-            return new ConstInstanceofExpression((Const) val, c);\n-        return new InstanceofExpression((PCPath) val, c);\n-    }\n-\n-    public Expression and(Expression exp1, Expression exp2) {\n-        if (exp1 instanceof BindVariableExpression)\n-            return new BindVariableAndExpression((BindVariableExpression) exp1,\n-                (Exp) exp2);\n-        if (exp2 instanceof BindVariableExpression)\n-            return new BindVariableAndExpression((BindVariableExpression) exp2,\n-                (Exp) exp1);\n-        return new AndExpression((Exp) exp1, (Exp) exp2);\n-    }\n-\n-    public Expression or(Expression exp1, Expression exp2) {\n-        return new OrExpression((Exp) exp1, (Exp) exp2);\n-    }\n-\n-    public Expression not(Expression exp) {\n-        if (HasContainsExpressionVisitor.hasContains(exp))\n-            return new NotContainsExpression((Exp) exp);\n-        return new NotExpression((Exp) exp);\n-    }\n-\n-    public Expression bindVariable(Value var, Value val) {\n-        // handle the strange case of using a constant path to bind a\n-        // variable; in these cases the variable acts like an unbound\n-        // variable that we limit by using an IN clause on the constant\n-        // value collection\n-        if (val instanceof Const) {\n-            PCPath path = new PCPath(_type, (Variable) var);\n-            path.setMetaData(var.getMetaData());\n-            return new InExpression(path, (Const) val);\n-        }\n-        return new BindVariableExpression((Variable) var, (PCPath) val, false);\n-    }\n-\n-    public Expression bindKeyVariable(Value var, Value val) {\n-        // handle the strange case of using a constant path to bind a\n-        // variable; in these cases the variable acts like an unbound\n-        // variable that we limit by using an IN clause on the constant\n-        // value collection\n-        if (val instanceof Const) {\n-            PCPath path = new PCPath(_type, (Variable) var);\n-            path.setMetaData(var.getMetaData());\n-            return new InKeyExpression(path, (Const) val);\n-        }\n-        return new BindVariableExpression((Variable) var, (PCPath) val, true);\n-    }\n-\n-    public Expression bindValueVariable(Value var, Value val) {\n-        return bindVariable(var, val);\n-    }\n-\n-    public Expression startsWith(Value v1, Value v2) {\n-        return new StartsWithExpression((Val) v1, (Val) v2);\n-    }\n-\n-    public Expression endsWith(Value v1, Value v2) {\n-        return new EndsWithExpression((Val) v1, (Val) v2);\n-    }\n-\n-    public Expression notMatches(Value v1, Value v2,\n-        String single, String multi, String esc) {\n-        return not(matches(v1, v2, single, multi, esc));\n-    }\n-\n-    public Expression matches(Value v1, Value v2,\n-        String single, String multi, String esc) {\n-        if (!(v2 instanceof Const))\n-            throw new UserException(_loc.get(\"const-only\", \"matches\"));\n-        return new MatchesExpression((Val) v1, (Const) v2, single, multi,\n-            esc != null ? esc : _type.getMappingRepository().\n-                getDBDictionary().searchStringEscape);\n-    }\n-\n-    public Subquery newSubquery(ClassMetaData candidate, boolean subs,\n-        String alias) {\n-        DBDictionary dict = _type.getMappingRepository().getDBDictionary();\n-        dict.assertSupport(dict.supportsSubselect, \"SupportsSubselect\");\n-        return new SubQ((ClassMapping) candidate, subs, alias);\n-    }\n-\n-    public Path newPath() {\n-        return new PCPath(_type);\n-    }\n-\n-    public Path newPath(Value val) {\n-        if (val instanceof Const)\n-            return new ConstPath((Const) val);\n-        if (val instanceof SubQ)\n-            return new PCPath((SubQ) val);\n-        return new PCPath(_type, (Variable) val);\n-    }\n-\n-    public Literal newLiteral(Object val, int ptype) {\n-        return new Lit(val, ptype);\n-    }\n-\n-    public Value getThis() {\n-        return new PCPath(_type);\n-    }\n-\n-    public Value getNull() {\n-        return NULL;\n-    }\n-\n-    public Value getCurrentDate() {\n-        return CURRENT_DATE;\n-    }\n-\n-    public Value getCurrentTime() {\n-        return CURRENT_TIME;\n-    }\n-\n-    public Value getCurrentTimestamp() {\n-        return CURRENT_TIMESTAMP;\n-    }\n-\n-    public Parameter newParameter(String name, Class type) {\n-        return new Param(name, type);\n-    }\n-\n-    public Value newExtension(FilterListener listener, Value target,\n-        Value arg) {\n-        return new Extension((JDBCFilterListener) listener,\n-            (Val) target, (Val) arg, _type);\n-    }\n-\n-    public Value newAggregate(AggregateListener listener, Value arg) {\n-        return new Aggregate((JDBCAggregateListener) listener,\n-            (Val) arg, _type);\n-    }\n-\n-    public Arguments newArgumentList(Value v1, Value v2) {\n-        return new Args((Val) v1, (Val) v2);\n-    }\n-\n-    public Value newUnboundVariable(String name, Class type) {\n-        return new Variable(name, type);\n-    }\n-\n-    public Value newBoundVariable(String name, Class type) {\n-        return newUnboundVariable(name, type);\n-    }\n-\n-    public Value cast(Value val, Class cls) {\n-        val.setImplicitType(cls);\n-        return val;\n-    }\n-\n-    public Value add(Value v1, Value v2) {\n-        return new Math((Val) v1, (Val) v2, Math.ADD);\n-    }\n-\n-    public Value subtract(Value v1, Value v2) {\n-        return new Math((Val) v1, (Val) v2, Math.SUBTRACT);\n-    }\n-\n-    public Value multiply(Value v1, Value v2) {\n-        return new Math((Val) v1, (Val) v2, Math.MULTIPLY);\n-    }\n-\n-    public Value divide(Value v1, Value v2) {\n-        return new Math((Val) v1, (Val) v2, Math.DIVIDE);\n-    }\n-\n-    public Value mod(Value v1, Value v2) {\n-        return new Math((Val) v1, (Val) v2, Math.MOD);\n-    }\n-\n-    public Value abs(Value val) {\n-        return new Abs((Val) val);\n-    }\n-\n-    public Value indexOf(Value v1, Value v2) {\n-        return new IndexOf((Val) v1, (Val) v2);\n-    }\n-\n-    public Value concat(Value v1, Value v2) {\n-        return new Concat((Val) v1, (Val) v2);\n-    }\n-\n-    public Value stringLength(Value str) {\n-        return new StringLength((Val) str);\n-    }\n-\n-    public Value trim(Value str, Value trimChar, Boolean where) {\n-        return new Trim((Val) str, (Val) trimChar, where);\n-    }\n-\n-    public Value sqrt(Value val) {\n-        return new Sqrt((Val) val);\n-    }\n-\n-    public Value substring(Value v1, Value v2) {\n-        return new Substring((Val) v1, (Val) v2);\n-    }\n-\n-    public Value toUpperCase(Value val) {\n-        return new ToUpperCase((Val) val);\n-    }\n-\n-    public Value toLowerCase(Value val) {\n-        return new ToLowerCase((Val) val);\n-    }\n-\n-    public Value avg(Value val) {\n-        return new Avg((Val) val);\n-    }\n-\n-    public Value count(Value val) {\n-        return new Count((Val) val);\n-    }\n-\n-    public Value distinct(Value val) {\n-        return new Distinct((Val) val);\n-    }\n-\n-    public Value max(Value val) {\n-        return new Max((Val) val);\n-    }\n-\n-    public Value min(Value val) {\n-        return new Min((Val) val);\n-    }\n-\n-    public Value sum(Value val) {\n-        return new Sum((Val) val);\n-    }\n-\n-    public Value any(Value val) {\n-        return new Any((Val) val);\n-    }\n-\n-    public Value all(Value val) {\n-        return new All((Val) val);\n-    }\n-\n-    public Value size(Value val) {\n-        return new Size((Val) val);\n-    }\n-\n-    public Value getObjectId(Value val) {\n-        if (val instanceof Const)\n-            return new ConstGetObjectId((Const) val);\n-        return new GetObjectId((PCPath) val);\n-    }\n-\n-    public Value getMapValue(Value map, Value arg) {\n-        return new GetMapValue((Val) map, (Val) arg, \n-            \"gmv\" + _getMapValueAlias++);\n-    }\n-}"},{"sha":"f461e9f8543361a6484fcce317d5ad5ee9ec3846","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCFilterListener.java","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCFilterListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCFilterListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCFilterListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,47 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.kernel.exps.FilterListener;\n-\n-/**\n- * JDBC extension to the {@link FilterListener}.\n- *\n- * @author Abe White\n- */\n-public interface JDBCFilterListener\n-    extends FilterListener {\n-\n-    /**\n-     * Append the SQL for this expression or value.\n-     *\n-     * @param buf the SQL buffer to append to\n-     * @param target the target to act on, or null if the listener\n-     * doesn't expect a target\n-     * @param args the values of the arguments given in the filter, or\n-     * null if this listener doesn't expect arguments\n-     * @param mapping the class mapping for the query's candidate class\n-     * @param store the store that owns the query\n-     */\n-    public void appendTo(SQLBuffer buf, FilterValue target, FilterValue[] args,\n-        ClassMapping mapping, JDBCStore store);\n-}"},{"sha":"18eaef270c15c58cdb5d4070f278440a5ebbc9df","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCPath.java","status":"removed","additions":0,"deletions":32,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCPath.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCPath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCPath.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,32 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.kernel.exps.Path;\n-\n-/**\n- * A path represents a traversal into fields of a candidate object.\n- *\n- * @author Abe White\n- */\n-interface JDBCPath\n-    extends Path, Val {\n-\n-    public void getKey();\n-}"},{"sha":"ca90f0a624450405630b0da9a31b20075f463b20","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCStringContains.java","status":"removed","additions":0,"deletions":56,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCStringContains.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCStringContains.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCStringContains.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,56 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.kernel.exps.StringContains;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.util.UserException;\n-\n-/**\n- * Tests if the target contains the given argument. The argument must be\n- * a constant.\n- *  Examples:<br />\n- * <code>\"address.street.ext:stringContains (\\\"main\\\")\"</code>\n- *\n- * @nojavadoc\n- * @deprecated Use <code>matches()</code> instead.\n- */\n-public class JDBCStringContains\n-    extends StringContains\n-    implements JDBCFilterListener {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (JDBCStringContains.class);\n-\n-    public void appendTo(SQLBuffer buf, FilterValue target, FilterValue[] args,\n-        ClassMapping type, JDBCStore store) {\n-        if (!args[0].isConstant())\n-            throw new UserException(_loc.get(\"const-only\", TAG));\n-\n-        Object val = args[0].getValue();\n-        target.appendTo(buf);\n-        if (val == null)\n-            buf.append(\" IS \").appendValue(null);\n-        else\n-            buf.append(\" LIKE \").appendValue(\"%\" + val + \"%\");\n-    }\n-}"},{"sha":"b1caa15fd02de7fdcbe55a5fdebc79c8908626df","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCWildcardMatch.java","status":"removed","additions":0,"deletions":61,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCWildcardMatch.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCWildcardMatch.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCWildcardMatch.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,61 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.kernel.exps.WildcardMatch;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.util.UserException;\n-\n-/**\n- * Tests if the target matches the wildcard expression given in the\n- * argument. The wildcard '?' is used to represent any single character,\n- * while '*' is used to represent any series of 0 or more characters.\n- *  Examples:<br />\n- * <code>\"address.street.ext:wildcardMatch (\\\"?ain*reet\\\")\"</code>\n- *\n- * @nojavadoc\n- * @deprecated Use <code>matches()</code> instead.\n- */\n-public class JDBCWildcardMatch\n-    extends WildcardMatch\n-    implements JDBCFilterListener {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (JDBCWildcardMatch.class);\n-\n-    public void appendTo(SQLBuffer sql, FilterValue target, FilterValue[] args,\n-        ClassMapping type, JDBCStore store) {\n-        if (!args[0].isConstant())\n-            throw new UserException(_loc.get(\"const-only\", TAG));\n-\n-        Object val = args[0].getValue();\n-        target.appendTo(sql);\n-        if (val == null)\n-            sql.append(\" IS \").appendValue(null);\n-        else {\n-            // create a DB wildcard string by replacing '*' with '%' and\n-            // '?' with '_'\n-            String wild = val.toString().replace('*', '%').replace('?', '_');\n-            sql.append(\" LIKE \").appendValue(wild);\n-        }\n-    }\n-}"},{"sha":"5b45fab3923b85b86d5a6b6c3183e13690a53eb2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Lit.java","status":"removed","additions":0,"deletions":104,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Lit.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Lit.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Lit.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,104 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.Filters;\n-import org.apache.openjpa.kernel.exps.Literal;\n-\n-/**\n- * A literal value in a filter.\n- *\n- * @author Abe White\n- */\n-public class Lit\n-    extends Const\n-    implements Literal {\n-\n-    private Object _val;\n-    private int _ptype;\n-\n-    /**\n-     * Constructor. Supply literal value.\n-     */\n-    public Lit(Object val, int ptype) {\n-        _val = val;\n-        _ptype = ptype;\n-    }\n-\n-    public Class getType() {\n-        return (_val == null) ? Object.class : _val.getClass();\n-    }\n-\n-    public void setImplicitType(Class type) {\n-        _val = Filters.convert(_val, type);\n-    }\n-\n-    public int getParseType() {\n-        return _ptype;\n-    }\n-\n-    public Object getValue() { \n-        return _val;\n-    }\n-\n-    public void setValue(Object val) {\n-        _val = val;\n-    }\n-\n-    public Object getValue(Object[] params) {\n-        return getValue();\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n-        return new LitExpState();\n-    }\n-\n-    /**\n-     * Expression state.\n-     */\n-    private static class LitExpState\n-        extends ConstExpState {\n-\n-        public Object sqlValue;\n-        public int otherLength; \n-    } \n-\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n-        Val other, ExpState otherState) {\n-        super.calculateValue(sel, ctx, state, other, otherState);\n-        LitExpState lstate = (LitExpState) state;\n-        if (other != null) {\n-            lstate.sqlValue = other.toDataStoreValue(sel, ctx, otherState,_val);\n-            lstate.otherLength = other.length(sel, ctx, otherState);\n-        } else\n-            lstate.sqlValue = _val;\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql, int index) {\n-        LitExpState lstate = (LitExpState) state;\n-        if (lstate.otherLength > 1)\n-            sql.appendValue(((Object[]) lstate.sqlValue)[index], \n-                lstate.getColumn(index));\n-        else\n-            sql.appendValue(lstate.sqlValue, lstate.getColumn(index));\n-    }\n-}"},{"sha":"977cc60c29cc85c231250e3fdc6b8e0239610036","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MatchesExpression.java","status":"removed","additions":0,"deletions":155,"changes":155,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MatchesExpression.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MatchesExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/MatchesExpression.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,155 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.util.Map;\n-\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-import serp.util.Strings;\n-\n-/**\n- * Test if a string matches a regexp.\n- *\n- * @author Abe White\n- */\n-class MatchesExpression\n-    implements Exp {\n-\n-    private final Val _val;\n-    private final Const _const;\n-    private final String _single;\n-    private final String _multi;\n-    private final String _escape;\n-\n-    /**\n-     * Constructor. Supply values.\n-     */\n-    public MatchesExpression(Val val, Const con,\n-        String single, String multi, String escape) {\n-        _val = val;\n-        _const = con;\n-        _single = single;\n-        _multi = multi;\n-        _escape = escape;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n-        ExpState s1 = _val.initialize(sel, ctx, 0);\n-        ExpState s2 = _const.initialize(sel, ctx, 0);\n-        return new BinaryOpExpState(sel.and(s1.joins, s2.joins), s1, s2);\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf) {\n-        BinaryOpExpState bstate = (BinaryOpExpState) state;\n-        _val.calculateValue(sel, ctx, bstate.state1, _const, bstate.state2);\n-        _const.calculateValue(sel, ctx, bstate.state2, _val, bstate.state1);\n-\n-        Column col = null;\n-        if (_val instanceof PCPath) {\n-            Column[] cols = ((PCPath) _val).getColumns(bstate.state1);\n-            if (cols.length == 1)\n-                col = cols[0];\n-        }\n-\n-        Object o = _const.getValue(ctx, bstate.state2);\n-        if (o == null)\n-            buf.append(\"1 <> 1\");\n-        else {\n-            // look for ignore case flag and strip it out if present\n-            boolean ignoreCase = false;\n-            String str = o.toString();\n-            int idx = str.indexOf(\"(?i)\");\n-            if (idx != -1) {\n-                ignoreCase = true;\n-                if (idx + 4 < str.length())\n-                    str = str.substring(0, idx) + str.substring(idx + 4);\n-                else\n-                    str = str.substring(0, idx);\n-                str = str.toLowerCase();\n-            }\n-\n-            // append target\n-            if (ignoreCase)\n-                buf.append(\"LOWER(\");\n-            _val.appendTo(sel, ctx, bstate.state1, buf, 0);\n-            if (ignoreCase)\n-                buf.append(\")\");\n-\n-            // create a DB wildcard string by replacing the\n-            // multi token (e.g., '.*') and the single token (e.g., \".\")\n-            // with '%' and '.' with '_'\n-            str = replaceEscape(str, _multi, \"%\", _escape);\n-            str = replaceEscape(str, _single, \"_\", _escape);\n-            buf.append(\" LIKE \").appendValue(str, col);\n-\n-            // escape out characters by using the database's escape sequence\n-            if (_escape != null)\n-                buf.append(\" ESCAPE '\").append(_escape).append(\"'\");\n-        }\n-        sel.append(buf, state.joins);\n-    }\n-\n-    /** \n-     * Perform a string replacement with simplistic escape handing. \n-     *  \n-     * @param  str      the source string\n-     * @param  from     the string to find\n-     * @param  to       the string to replace\n-     * @param  escape   the string to use to escape replacement\n-     * @return          the replaced string\n-     */\n-    private static String replaceEscape(String str, String from, String to,\n-        String escape) {\n-        String[] parts = Strings.split(str, from, Integer.MAX_VALUE);\n-        StringBuffer repbuf = new StringBuffer();\n-        for (int i = 0; i < parts.length; i++) {\n-            if (i > 0) {\n-                // if the previous part ended with an escape character, then\n-                // escape the character and remove the previous escape;\n-                // this doesn't support any double-escaping or other more\n-                // sophisticated features\n-                if (!from.equals(to) && parts[i - 1].endsWith(escape)) {\n-                    repbuf.setLength(repbuf.length() - 1);\n-                    repbuf.append(from);\n-                } else\n-                    repbuf.append(to);\n-            }\n-            repbuf.append(parts[i]);\n-        }\n-        return repbuf.toString();\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        BinaryOpExpState bstate = (BinaryOpExpState) state;\n-        _val.selectColumns(sel, ctx, bstate.state1, true);\n-        _const.selectColumns(sel, ctx, bstate.state2, true);\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        _val.acceptVisit(visitor);\n-        _const.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-}"},{"sha":"f08db8f6da7cf232333842a0047e88d1ae079fc5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Math.java","status":"removed","additions":0,"deletions":162,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Math.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Math.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Math.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,162 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.Filters;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-import org.apache.openjpa.meta.ClassMetaData;\n-\n-/**\n- * Value produced by a mathematical operation on two values.\n- *\n- * @author Abe White\n- */\n-public class Math\n-    extends AbstractVal {\n-\n-    public static final String ADD = \"+\";\n-    public static final String SUBTRACT = \"-\";\n-    public static final String MULTIPLY = \"*\";\n-    public static final String DIVIDE = \"/\";\n-    public static final String MOD = \"MOD\";\n-\n-    private final Val _val1;\n-    private final Val _val2;\n-    private final String _op;\n-    private ClassMetaData _meta = null;\n-    private Class _cast = null;\n-\n-    /**\n-     * Constructor. Provide the values to operate on, and the operator.\n-     */\n-    public Math(Val val1, Val val2, String op) {\n-        _val1 = val1;\n-        _val2 = val2;\n-        _op = op;\n-    }\n-\n-    public Val getVal1() {\n-        return _val1;\n-    }\n-\n-    public Val getVal2() {\n-        return _val2;\n-    }\n-\n-    public String getOperation() {\n-        return _op;\n-    }\n-\n-    public ClassMetaData getMetaData() {\n-        return _meta;\n-    }\n-\n-    public void setMetaData(ClassMetaData meta) {\n-        _meta = meta;\n-    }\n-\n-    public Class getType() {\n-        if (_cast != null)\n-            return _cast;\n-        Class c1 = _val1.getType();\n-        Class c2 = _val2.getType();\n-        return Filters.promote(c1, c2);\n-    }\n-\n-    public void setImplicitType(Class type) {\n-        _cast = type;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n-        ExpState s1 = _val1.initialize(sel, ctx, 0);\n-        ExpState s2 = _val2.initialize(sel, ctx, 0);\n-        return new BinaryOpExpState(sel.and(s1.joins, s2.joins), s1, s2);\n-    }\n-\n-    public void select(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        sel.select(newSQLBuffer(sel, ctx, state), this);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        BinaryOpExpState bstate = (BinaryOpExpState) state;\n-        _val1.selectColumns(sel, ctx, bstate.state1, true);\n-        _val2.selectColumns(sel, ctx, bstate.state2, true);\n-    }\n-\n-    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n-        sel.groupBy(newSQLBuffer(sel, ctx, state));\n-    }\n-\n-    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n-        boolean asc) {\n-        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n-    }\n-\n-    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n-        calculateValue(sel, ctx, state, null, null);\n-        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n-        appendTo(sel, ctx, state, buf, 0);\n-        return buf;\n-    }\n-\n-    public Object load(ExpContext ctx, ExpState state, Result res)\n-        throws SQLException {\n-        return Filters.convert(res.getObject(this, JavaSQLTypes.JDBC_DEFAULT, \n-            null), getType());\n-    }\n-\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n-        Val other, ExpState otherState) {\n-        BinaryOpExpState bstate = (BinaryOpExpState) state;\n-        _val1.calculateValue(sel, ctx, bstate.state1, _val2, bstate.state2);\n-        _val2.calculateValue(sel, ctx, bstate.state2, _val1, bstate.state1);\n-    }\n-\n-    public int length(Select sel, ExpContext ctx, ExpState state) {\n-        return 1;\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql, int index) {\n-        BinaryOpExpState bstate = (BinaryOpExpState) state;\n-        ctx.store.getDBDictionary().mathFunction(sql, _op,\n-            new FilterValueImpl(sel, ctx, bstate.state1, _val1),\n-            new FilterValueImpl(sel, ctx, bstate.state2, _val2));\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        _val1.acceptVisit(visitor);\n-        _val2.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-\n-    public int getId() {\n-        return Val.MATH_VAL;\n-    }\n-}\n-"},{"sha":"a6c6e2cbd436169d0da875239bc44972d721213c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Max.java","status":"removed","additions":0,"deletions":44,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Max.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Max.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Max.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,44 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-/**\n- * Maximum.\n- *\n- * @author Abe White\n- */\n-class Max\n-    extends UnaryOp {\n-\n-    /**\n-     * Constructor. Provide the value to operate on.\n-     */\n-    public Max(Val val) {\n-        super(val);\n-    }\n-\n-    protected String getOperator() {\n-        return \"MAX\";\n-    }\n-\n-    public boolean isAggregate() {\n-        return true;\n-    }\n-}\n-"},{"sha":"c79171b053b5b5b04b2c8161e81505d48c906a85","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Min.java","status":"removed","additions":0,"deletions":44,"changes":44,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Min.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Min.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Min.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,44 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-/**\n- * Minimum.\n- *\n- * @author Abe White\n- */\n-class Min\n-    extends UnaryOp {\n-\n-    /**\n-     * Constructor. Provide the value to operate on.\n-     */\n-    public Min(Val val) {\n-        super(val);\n-    }\n-\n-    protected String getOperator() {\n-        return \"MIN\";\n-    }\n-\n-    public boolean isAggregate() {\n-        return true;\n-    }\n-}\n-"},{"sha":"4592103b04c2ebc70158524530ae7eadfb39652e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotContainsExpression.java","status":"removed","additions":0,"deletions":95,"changes":95,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotContainsExpression.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotContainsExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotContainsExpression.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,95 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.util.Map;\n-\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-\n-/**\n- * Negates a contains expression using a subselect to make sure no\n- * elements meet the criteria.\n- *\n- * @author Abe White\n- */\n-class NotContainsExpression\n-    implements Exp {\n-\n-    private final Exp _exp;\n-\n-    /**\n-     * Constructor. Supply the expression to negate.\n-     */\n-    public NotContainsExpression(Exp exp) {\n-        _exp = exp;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n-        return new NotContainsExpState(contains);\n-    }\n-\n-    /**\n-     * Expression state.\n-     */\n-    private static class NotContainsExpState\n-        extends ExpState {\n-        \n-        public final Map contains;\n-\n-        public NotContainsExpState(Map contains) {\n-            this.contains = contains;\n-        }\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf) {\n-        DBDictionary dict = ctx.store.getDBDictionary();\n-        dict.assertSupport(dict.supportsSubselect, \"SupportsSubselect\");\n-\n-        Select sub = ctx.store.getSQLFactory().newSelect();\n-        sub.setParent(sel, null);\n-        ExpState estate = _exp.initialize(sub, ctx, ((NotContainsExpState) \n-            state).contains);\n-        sub.where(sub.and(null, estate.joins));\n-\n-        SQLBuffer where = new SQLBuffer(dict).append(\"(\");\n-        _exp.appendTo(sub, ctx, estate, where);\n-        if (where.getSQL().length() > 1)\n-            sub.where(where.append(\")\"));\n-\n-        buf.append(\"0 = \");\n-        buf.appendCount(sub, ctx.fetch);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        ExpState estate = _exp.initialize(sel, ctx, ((NotContainsExpState) \n-            state).contains);\n-        _exp.selectColumns(sel, ctx, estate, true);\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        _exp.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-}"},{"sha":"41cc89da620a791b5d31180890458385a82f0f27","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotEqualExpression.java","status":"removed","additions":0,"deletions":79,"changes":79,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotEqualExpression.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotEqualExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotEqualExpression.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,79 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-\n-/**\n- * Compares two values.\n- *\n- * @author Abe White\n- */\n-class NotEqualExpression\n-    extends CompareEqualExpression {\n-\n-    /**\n-     * Constructor. Supply values to compare.\n-     */\n-    public NotEqualExpression(Val val1, Val val2) {\n-        super(val1, val2);\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, BinaryOpExpState bstate, \n-        SQLBuffer buf, boolean val1Null, boolean val2Null) {\n-        if (val1Null && val2Null)\n-            buf.append(\"1 <> 1\");\n-        else if (val1Null || val2Null) {\n-            Val val = (val1Null) ? getValue2() : getValue1();\n-            ExpState state = (val1Null) ? bstate.state2 : bstate.state1;\n-            if (!isDirectComparison()) {\n-                int len = val.length(sel, ctx, state);\n-                for (int i = 0; i < len; i++) {\n-                    if (i > 0)\n-                        buf.append(\" AND \");\n-                    val.appendTo(sel, ctx, state, buf, i);\n-                    buf.append(\" IS NOT \").appendValue(null);\n-                }\n-            } else\n-                val.appendIsNotNull(sel, ctx, state, buf);\n-        } else {\n-            Val val1 = getValue1();\n-            Val val2 = getValue2();\n-            if (val1.length(sel, ctx, bstate.state1) == 1 \n-                && val2.length(sel, ctx, bstate.state2) == 1) {\n-                ctx.store.getDBDictionary().comparison(buf, \"<>\",\n-                    new FilterValueImpl(sel, ctx, bstate.state1, val1),\n-                    new FilterValueImpl(sel, ctx, bstate.state2, val2));\n-            } else {\n-                int len = java.lang.Math.max(val1.length(sel, ctx, \n-                    bstate.state1), val2.length(sel, ctx, bstate.state2));\n-                buf.append(\"(\");\n-                for (int i = 0; i < len; i++) {\n-                    if (i > 0)\n-                        buf.append(\" OR \");\n-                    val1.appendTo(sel, ctx, bstate.state1, buf, i);\n-                    buf.append(\" <> \");\n-                    val2.appendTo(sel, ctx, bstate.state2, buf, i);\n-                }\n-                buf.append(\")\");\n-            }\n-        }\n-    }\n-}"},{"sha":"913d0b9e01f1b711c111ea079b81eba029e5023b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotExpression.java","status":"removed","additions":0,"deletions":81,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotExpression.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotExpression.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,81 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.util.Map;\n-\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-\n-/**\n- * Negates an expression.\n- *\n- * @author Abe White\n- */\n-class NotExpression\n-    implements Exp {\n-\n-    private final Exp _exp;\n-\n-    /**\n-     * Constructor. Supply the expression to negate.\n-     */\n-    public NotExpression(Exp exp) {\n-        _exp = exp;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, Map contains) { \n-        ExpState state = _exp.initialize(sel, ctx, contains);\n-        return new NotExpState(sel.or(state.joins, null), state);\n-    }\n-\n-    /**\n-     * Expression state.\n-     */\n-    private static class NotExpState \n-        extends ExpState {\n-\n-        public final ExpState state;\n-\n-        public NotExpState(Joins joins, ExpState state) {\n-            super(joins);\n-            this.state = state;\n-        }\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf) {\n-        buf.append(\"NOT (\");\n-        _exp.appendTo(sel, ctx, ((NotExpState) state).state, buf);\n-        buf.append(\")\");\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        _exp.selectColumns(sel, ctx, ((NotExpState) state).state, pks);\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        _exp.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-}"},{"sha":"2fd52fd5bd273a2238060fbf317ff1c81f12ee0d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Null.java","status":"removed","additions":0,"deletions":51,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Null.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Null.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Null.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,51 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-\n-/**\n- * A literal null value in a filter.\n- *\n- * @author Abe White\n- */\n-public class Null\n-    extends Const {\n-\n-    public Class getType() {\n-        return Object.class;\n-    }\n-\n-    public void setImplicitType(Class type) {\n-    }\n-\n-    public Object getValue(Object[] params) {\n-        return null;\n-    }\n-\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n-        Val other, ExpState otherState) {\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql, int index) {\n-        sql.appendValue(null);\n-    }\n-}"},{"sha":"bfbd4af79d1ac08df5ef7a04df91d2e9860d6c56","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/OrExpression.java","status":"removed","additions":0,"deletions":103,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/OrExpression.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/OrExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/OrExpression.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,103 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.Map;\n-\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-\n-/**\n- * Combines two expressions.\n- *\n- * @author Abe White\n- */\n-class OrExpression\n-    implements Exp {\n-\n-    private final Exp _exp1;\n-    private final Exp _exp2;\n-\n-    /**\n-     * Constructor. Supply the expressions to combine.\n-     */\n-    public OrExpression(Exp exp1, Exp exp2) {\n-        _exp1 = exp1;\n-        _exp2 = exp2;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n-        // when OR'ing expressions each expression gets its own copy of the\n-        // contains counts, cause it's OK for each to use the same aliases\n-        Map contains2 = null;\n-        if (contains != null)\n-            contains2 = new HashMap(contains);\n-\n-        ExpState s1 = _exp1.initialize(sel, ctx, contains);\n-        ExpState s2 = _exp2.initialize(sel, ctx, contains2);\n-        ExpState ret = new BinaryOpExpState(sel.or(s1.joins, s2.joins), s1, s2);\n-        if (contains == null)\n-            return ret;\n-\n-        // combine the contains counts from the copy into the main map\n-        Map.Entry entry;\n-        Integer val1, val2;\n-        for (Iterator itr = contains2.entrySet().iterator(); itr.hasNext();) {\n-            entry = (Map.Entry) itr.next();\n-            val2 = (Integer) entry.getValue();\n-            val1 = (Integer) contains.get(entry.getKey());\n-            if (val1 == null || val2.intValue() > val1.intValue())\n-                contains.put(entry.getKey(), val2);\n-        }\n-        return ret;\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf) {\n-        BinaryOpExpState bstate = (BinaryOpExpState) state;\n-        boolean paren = bstate.joins != null && !bstate.joins.isEmpty();\n-        if (paren)\n-            buf.append(\"(\");\n-\n-        _exp1.appendTo(sel, ctx, bstate.state1, buf);\n-        buf.append(\" OR \");\n-        _exp2.appendTo(sel, ctx, bstate.state2, buf);\n-\n-        if (paren)\n-            buf.append(\")\");\n-        sel.append(buf, bstate.joins);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        BinaryOpExpState bstate = (BinaryOpExpState) state;\n-        _exp1.selectColumns(sel, ctx, bstate.state1, pks);\n-        _exp2.selectColumns(sel, ctx, bstate.state2, pks);\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        _exp1.acceptVisit(visitor);\n-        _exp2.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-}"},{"sha":"e59a58252fd988c3a0b4ac36becf8678e5d2668d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","status":"removed","additions":0,"deletions":831,"changes":831,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,831 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.io.Serializable;\n-import java.sql.SQLException;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.ListIterator;\n-\n-import org.apache.commons.lang.ObjectUtils;\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.meta.FieldMapping;\n-import org.apache.openjpa.jdbc.meta.ValueMapping;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\n-import org.apache.openjpa.jdbc.schema.Schemas;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.Filters;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.meta.FieldMetaData;\n-import org.apache.openjpa.meta.JavaTypes;\n-import org.apache.openjpa.meta.XMLMetaData;\n-import org.apache.openjpa.util.UserException;\n-\n-/**\n- * A path represents a traversal into fields of a candidate object.\n- *\n- * @author Abe White\n- */\n-public class PCPath\n-    extends AbstractVal\n-    implements JDBCPath {\n-\n-    private static final int PATH = 0;\n-    private static final int BOUND_VAR = 1;\n-    private static final int UNBOUND_VAR = 2;\n-    private static final int UNACCESSED_VAR = 3;\n-    private static final int XPATH = 4;\n-\n-    private static final Localizer _loc = Localizer.forPackage(PCPath.class);\n-\n-    private final ClassMapping _candidate;\n-    private ClassMapping _class = null;\n-    private LinkedList _actions = null;\n-    private boolean _key = false;\n-    private int _type = PATH;\n-    private String _varName = null;\n-    private Class _cast = null;\n-    private boolean _cid = false;\n-    private FieldMetaData _xmlfield = null;\n-\n-    /**\n-     * Return a path starting with the 'this' ptr.\n-     */\n-    public PCPath(ClassMapping type) {\n-        _candidate = type;\n-    }\n-\n-    /**\n-     * Return a path starting from the given variable.\n-     */\n-    public PCPath(ClassMapping candidate, Variable var) {\n-        _candidate = candidate;\n-        _actions = new LinkedList();\n-\n-        PCPath other = var.getPCPath();\n-        Action action = new Action();\n-        if (other == null) {\n-            _type = UNBOUND_VAR;\n-            action.op = Action.UNBOUND_VAR;\n-            action.data = var;\n-        } else {\n-            // bound variable; copy path\n-            _type = UNACCESSED_VAR;\n-            _actions.addAll(other._actions);\n-            _key = other._key;\n-\n-            action.op = Action.VAR;\n-            action.data = var.getName();\n-        }\n-        _actions.add(action);\n-        _cast = var.getType(); // initial type is var type\n-    }\n-\n-    /**\n-     * Return a path starting from the given subquery.\n-     */\n-    public PCPath(SubQ sub) {\n-        _candidate = sub.getCandidate();\n-        _actions = new LinkedList();\n-\n-        Action action = new Action();\n-        action.op = Action.SUBQUERY;\n-        action.data = sub.getCandidateAlias();\n-        _actions.add(action);\n-        _cast = sub.getType(); // initial type is subquery type\n-        _varName = sub.getCandidateAlias();\n-    }\n-\n-    /**\n-     * Set the path as a binding of the given variable.\n-     */\n-    public void addVariableAction(Variable var) {\n-        _varName = var.getName();\n-    }\n-\n-    /**\n-     * Return true if this is a bound variable that has not been accessed\n-     * after binding. Useful for filters like\n-     * \"coll.contains (var) &amp;&amp; var == null\", which should really\n-     * just act like \"coll.contains (null)\".\n-     */\n-    public boolean isUnaccessedVariable() {\n-        return _type == UNACCESSED_VAR;\n-    }\n-\n-    /**\n-     * Return whether this is a path involving a variable.\n-     */\n-    public boolean isVariablePath() {\n-        return _type != PATH;\n-    }\n-\n-    /**\n-     * If this path is part of a contains clause, then alias it to the\n-     * proper contains id before initialization.\n-     */\n-    public synchronized void setContainsId(String id) {\n-        if (_cid)\n-            return;\n-\n-        // treat it just like a unique variable\n-        Action action = new Action();\n-        action.op = Action.VAR;\n-        action.data = id;\n-        if (_actions == null)\n-            _actions = new LinkedList();\n-        _actions.add(action);\n-        _cid = true;\n-    }\n-\n-    public ClassMetaData getMetaData() {\n-        return _class;\n-    }\n-\n-    public void setMetaData(ClassMetaData meta) {\n-        _class = (ClassMapping) meta;\n-    }\n-\n-    public boolean isKey() {\n-        return _key;\n-    }\n-    \n-    public boolean isXPath() {\n-        return _type == XPATH;\n-    }\n-    \n-    public String getXPath() {\n-        StringBuffer xpath = new StringBuffer();\n-        Action action;\n-        Iterator itr = _actions.iterator();\n-        \n-        // Skip variable actions since they are not part of the xpath\n-        // until we reach the first xpath action.\n-        // The first xpath action maps to the root of an xml document.\n-        do \n-            action = (Action) itr.next(); \n-        while (action.op != Action.GET_XPATH);\n-        \n-        // Skip XmlRootElement:\n-        // We can't rely on the accuracy of the name of the root element,\n-        // because it could be set to some default by JAXB XML Binding.\n-        // The caller(DBDictionary) should start with \"/*\" or \"/*/\",\n-        // we build the remaining xpath that follows the root element.\n-        while (itr.hasNext()) {\n-            action = (Action) itr.next();\n-            if (((XMLMetaData) action.data).getXmlname() != null)                 \n-                xpath.append(((XMLMetaData) action.data).getXmlname());\n-            else\n-                xpath.append(\"*\");\n-            if (itr.hasNext())\n-                xpath.append(\"/\");\n-        }\n-        return xpath.toString();\n-    }\n-    \n-    public String getPath() {\n-        if (_actions == null)\n-            return (_varName == null) ? \"\" : _varName + \".\";\n-\n-        StringBuffer path = new StringBuffer();\n-        Action action;\n-        for (Iterator itr = _actions.iterator(); itr.hasNext();) {\n-            action = (Action) itr.next();\n-            if (action.op == Action.VAR || action.op == Action.SUBQUERY)\n-                path.append(action.data);\n-            else if (action.op == Action.UNBOUND_VAR)\n-                path.append(((Variable) action.data).getName());\n-            else \n-                path.append(((FieldMapping) action.data).getName());\n-            path.append('.');\n-        }\n-        if (_varName != null)\n-            path.append(_varName).append('.');\n-        return path.toString();\n-    }\n-\n-    public ClassMapping getClassMapping(ExpState state) {\n-        PathExpState pstate = (PathExpState) state;\n-        if (pstate.field == null)\n-            return _class;\n-        if (_key) {\n-            if (pstate.field.getKey().getTypeCode() == JavaTypes.PC)\n-                return pstate.field.getKeyMapping().getTypeMapping();\n-            return null;\n-        }\n-        if (pstate.field.getElement().getTypeCode() == JavaTypes.PC)\n-            return pstate.field.getElementMapping().getTypeMapping();\n-        if (pstate.field.getTypeCode() == JavaTypes.PC)\n-            return pstate.field.getTypeMapping();\n-        return null;\n-    }\n-\n-    public FieldMapping getFieldMapping(ExpState state) {\n-        return ((PathExpState) state).field;\n-    }\n-\n-    public Column[] getColumns(ExpState state) {\n-        PathExpState pstate = (PathExpState) state;\n-        if (pstate.cols == null)\n-            pstate.cols = calculateColumns(pstate);\n-        return pstate.cols;\n-    }\n-\n-    /**\n-     * The columns used by this path.\n-     */\n-    private Column[] calculateColumns(PathExpState pstate) {\n-        if (_key) {\n-            if (!pstate.joinedRel \n-                && pstate.field.getKey().getValueMappedBy() != null)\n-                joinRelation(pstate, _key, false, false);\n-            else if (pstate.joinedRel \n-                && pstate.field.getKey().getTypeCode() == JavaTypes.PC)\n-                return pstate.field.getKeyMapping().getTypeMapping().\n-                    getPrimaryKeyColumns();\n-            return pstate.field.getKeyMapping().getColumns();\n-        }\n-        if (pstate.field != null) {\n-            switch (pstate.field.getTypeCode()) {\n-                case JavaTypes.MAP:\n-                case JavaTypes.ARRAY:\n-                case JavaTypes.COLLECTION:\n-                    ValueMapping elem = pstate.field.getElementMapping();\n-                    if (pstate.joinedRel && elem.getTypeCode() == JavaTypes.PC)\n-                        return elem.getTypeMapping().getPrimaryKeyColumns();\n-                    if (elem.getColumns().length > 0)\n-                        return elem.getColumns();\n-                    return pstate.field.getColumns();\n-                case JavaTypes.PC:\n-                    if (pstate.joinedRel)\n-                        return pstate.field.getTypeMapping().\n-                            getPrimaryKeyColumns();\n-                    return pstate.field.getColumns();\n-                default:\n-                    return pstate.field.getColumns();\n-            }\n-        }\n-        return (_class == null) ? Schemas.EMPTY_COLUMNS\n-            : _class.getPrimaryKeyColumns();\n-    }\n-\n-    public boolean isVariable() {\n-        if (_actions == null)\n-            return false;\n-        Action action = (Action) _actions.getLast();\n-        return action.op == Action.UNBOUND_VAR || action.op == Action.VAR; \n-    }\n-\n-    public void get(FieldMetaData field, boolean nullTraversal) {\n-        if (_actions == null)\n-            _actions = new LinkedList();\n-        Action action = new Action();\n-        action.op = (nullTraversal) ? Action.GET_OUTER : Action.GET;\n-        action.data = field;\n-        _actions.add(action);\n-        if (_type == UNACCESSED_VAR)\n-            _type = BOUND_VAR;\n-        _cast = null;\n-        _key = false;\n-    }\n-    \n-    public void get(FieldMetaData fmd, XMLMetaData meta) {\n-        if (_actions == null)\n-            _actions = new LinkedList();\n-        Action action = new Action();\n-        action.op = Action.GET_XPATH;\n-        action.data = meta;\n-        _actions.add(action);\n-        _cast = null;\n-        _key = false;\n-        _type = XPATH;\n-        _xmlfield = fmd;\n-    }\n-    \n-    public void get(XMLMetaData meta, String name) {\n-        Action action = new Action();\n-        action.op = Action.GET_XPATH;\n-        action.data = meta.getFieldMapping(name);\n-        _actions.add(action);\n-        _cast = null;\n-        _key = false;\n-        _type = XPATH;\n-    }\n-    \n-    public XMLMetaData getXmlMapping() {\n-        Action act = (Action) _actions.getLast();\n-        if (act != null)\n-            return (XMLMetaData) act.data;\n-        return null;\n-    }\n-\n-    public synchronized void getKey() {\n-        if (_cid)\n-            return;\n-\n-        // change the last action to a get key\n-        Action action = (Action) _actions.getLast();\n-        action.op = Action.GET_KEY;\n-        _cast = null;\n-        _key = true;\n-    }\n-\n-    public FieldMetaData last() {\n-        Action act = lastFieldAction();\n-        return (act == null) ? null : isXPath() ? _xmlfield :\n-            (FieldMetaData) act.data;\n-    }\n-\n-    /**\n-     * Return the last action that gets a field.\n-     */\n-    private Action lastFieldAction() {\n-        if (_actions == null)\n-            return null;\n-\n-        if (isXPath())\n-            return (Action) _actions.getLast();\n-        \n-        ListIterator itr = _actions.listIterator(_actions.size());\n-        Action prev;\n-        while (itr.hasPrevious()) {\n-            prev = (Action) itr.previous();\n-            if (prev.op == Action.GET || prev.op == Action.GET_OUTER\n-                || prev.op == Action.GET_KEY)\n-                return prev;\n-        }\n-        return null;\n-    }\n-\n-    public Class getType() {\n-        if (_cast != null)\n-            return _cast;\n-        Action act = lastFieldAction();\n-        if (act != null && act.op == Action.GET_XPATH)\n-            return ((XMLMetaData) act.data).getType();\n-        \n-        FieldMetaData fld = (act == null) ? null : (FieldMetaData) act.data;\n-        boolean key = act != null && act.op == Action.GET_KEY;\n-        if (fld != null) {\n-            switch (fld.getDeclaredTypeCode()) {\n-                case JavaTypes.ARRAY:\n-                    if (fld.getDeclaredType() == byte[].class\n-                        || fld.getDeclaredType() == Byte[].class\n-                        || fld.getDeclaredType() == char[].class\n-                        || fld.getDeclaredType() == Character[].class)\n-                        return fld.getDeclaredType();\n-                    return fld.getElement().getDeclaredType();\n-                case JavaTypes.MAP:\n-                    if (key)\n-                        return fld.getKey().getDeclaredType();\n-                    return fld.getElement().getDeclaredType();\n-                case JavaTypes.COLLECTION:\n-                    return fld.getElement().getDeclaredType();\n-                default:\n-                    return fld.getDeclaredType();\n-            }\n-        }\n-        if (_class != null)\n-            return _class.getDescribedType();\n-        return Object.class;\n-    }\n-\n-    public void setImplicitType(Class type) {\n-        _cast = type;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n-        PathExpState pstate = new PathExpState(sel.newJoins());\n-        boolean key = false;\n-        boolean forceOuter = false;\n-        ClassMapping rel = _candidate;\n-\n-        // iterate to the final field\n-        ClassMapping owner;\n-        ClassMapping from, to;\n-        Action action;\n-        Variable var;\n-        Iterator itr = (_actions == null) ? null : _actions.iterator();\n-        FieldMapping field;\n-        while (itr != null && itr.hasNext()) {\n-            action = (Action) itr.next();\n-\n-            // treat subqueries like variables for alias generation purposes\n-            if (action.op == Action.VAR)\n-                pstate.joins = pstate.joins.setVariable((String) action.data);\n-            else if (action.op == Action.SUBQUERY)\n-                pstate.joins = pstate.joins.setSubselect((String) action.data);\n-            else if (action.op == Action.UNBOUND_VAR) {\n-                // unbound vars are cross-joined to the candidate table\n-                var = (Variable) action.data;\n-                rel = (ClassMapping) var.getMetaData();\n-                pstate.joins = pstate.joins.setVariable(var.getName());\n-                pstate.joins = pstate.joins.crossJoin(_candidate.getTable(), \n-                    rel.getTable());\n-            } else {\n-                // move past the previous field, if any\n-                field = (action.op == Action.GET_XPATH) ? (FieldMapping) _xmlfield :\n-                    (FieldMapping) action.data;\n-                if (pstate.field != null) {\n-                    // if this is the second-to-last field and the last is\n-                    // the related field this field joins to, no need to\n-                    // traverse: just use this field's fk columns\n-                    if (!itr.hasNext() && (flags & JOIN_REL) == 0\n-                        && isJoinedField(pstate.field, key, field)) {\n-                        pstate.cmpfield = field;\n-                        break;\n-                    }\n-                    rel = traverseField(pstate, key, forceOuter, false);\n-                }\n-\n-                // mark if the next traversal should go through\n-                // the key rather than value\n-                key = action.op == Action.GET_KEY;\n-                forceOuter |= action.op == Action.GET_OUTER;\n-\n-                // get mapping for the current field\n-                pstate.field = field;\n-                owner = pstate.field.getDefiningMapping();\n-                if (pstate.field.getManagement() \n-                    != FieldMapping.MANAGE_PERSISTENT)\n-                    throw new UserException(_loc.get(\"non-pers-field\", \n-                        pstate.field));\n-\n-                // find the most-derived type between the declared relation\n-                // type and the field's owner, and join from that type to\n-                // the lesser derived type\n-                if (rel != owner && rel != null) {\n-                    if (rel.getDescribedType().isAssignableFrom\n-                        (owner.getDescribedType())) {\n-                        from = owner;\n-                        to = rel;\n-                    } else {\n-                        from = rel;\n-                        to = owner;\n-                    }\n-\n-                    for (; from != null && from != to;\n-                        from = from.getJoinablePCSuperclassMapping()) {\n-                    \tFieldMapping cast = from.getFieldMapping(pstate.field\n-                    \t\t\t.getName());\n-                    \tif (cast != null)\n-                    \t\tpstate.field = cast;\n-                        pstate.joins = from.joinSuperclass(pstate.joins, false);\n-                    }\n-                }\n-                // nothing more to do from here on as we encountered an xpath action\n-                if (action.op == Action.GET_XPATH)\n-                    break;\n-            }\n-        }\n-        if (_varName != null)\n-            pstate.joins = pstate.joins.setVariable(_varName);\n-\n-        // if we're not comparing to null or doing an isEmpty, then\n-        // join into the data on the final field; obviously we can't do these\n-        // joins when comparing to null b/c the whole purpose is to see\n-        // whether the joins even exist\n-        if ((flags & NULL_CMP) == 0)\n-            traverseField(pstate, key, forceOuter, true);\n-        pstate.joinedRel = false;\n-        if ((flags & JOIN_REL) != 0)\n-            joinRelation(pstate, key, forceOuter || (flags & FORCE_OUTER) != 0,\n-                false);\n-        return pstate;\n-    }\n-\n-    /**\n-     * Return whether the given source field joins to the given target field.\n-     */\n-    private static boolean isJoinedField(FieldMapping src, boolean key, \n-        FieldMapping target) {\n-        ValueMapping vm;\n-        switch (src.getTypeCode()) {\n-            case JavaTypes.ARRAY:\n-            case JavaTypes.COLLECTION:\n-                vm = src.getElementMapping();\n-                break;\n-            case JavaTypes.MAP:\n-                vm = (key) ? src.getKeyMapping() : src.getElementMapping();\n-                break;\n-            default:\n-                vm = src;\n-        }\n-        if (vm.getJoinDirection() != ValueMapping.JOIN_FORWARD)\n-            return false;\n-        ForeignKey fk = vm.getForeignKey();\n-        if (fk == null)\n-            return false; \n-        \n-        // foreign key must join to target columns\n-        Column[] rels = fk.getColumns();\n-        Column[] pks = target.getColumns(); \n-        if (rels.length != pks.length)\n-            return false;\n-        for (int i = 0; i < rels.length; i++)\n-            if (fk.getPrimaryKeyColumn(rels[i]) != pks[i])\n-                return false;\n-        return true;\n-    }\n-\n-    /**\n-     * Expression state.\n-     */\n-    public static class PathExpState\n-        extends ExpState {\n-\n-        public FieldMapping field = null;\n-        public FieldMapping cmpfield = null;\n-        public Column[] cols = null;\n-        public boolean joinedRel = false;\n-\n-        public PathExpState(Joins joins) {\n-            super(joins);\n-        }\n-    }\n-\n-    /**\n-     * Traverse into the previous field of a relation path.\n-     *\n-     * @param last whether this is the last field in the path\n-     * @return the mapping of the related type, or null\n-     */\n-    private ClassMapping traverseField(PathExpState pstate, boolean key, \n-        boolean forceOuter, boolean last) {\n-        if (pstate.field == null)\n-            return null;\n-\n-        // traverse into field value\n-        if (key)\n-            pstate.joins = pstate.field.joinKey(pstate.joins, forceOuter);\n-        else\n-            pstate.joins = pstate.field.join(pstate.joins, forceOuter);\n-\n-        // if this isn't the last field, traverse into the relation\n-        if (!last)\n-            joinRelation(pstate, key, forceOuter, true);\n-\n-        // return the maping of the related type, if any\n-        if (key)\n-            return pstate.field.getKeyMapping().getTypeMapping();\n-        if (pstate.field.getElement().getTypeCode() == JavaTypes.PC)\n-            return pstate.field.getElementMapping().getTypeMapping();\n-        return pstate.field.getTypeMapping();\n-    }\n-\n-    /**\n-     * Join into the relation represented by the current field, if any.\n-     */\n-    private void joinRelation(PathExpState pstate, boolean key, \n-        boolean forceOuter, boolean traverse) {\n-        if (pstate.field == null)\n-            return;\n-        if (key)\n-            pstate.joins = pstate.field.joinKeyRelation(pstate.joins, \n-                forceOuter, traverse);\n-        else\n-            pstate.joins = pstate.field.joinRelation(pstate.joins, forceOuter,\n-                traverse);\n-        pstate.joinedRel = true;\n-    }\n-\n-    public Object toDataStoreValue(Select sel, ExpContext ctx, ExpState state, \n-        Object val) {\n-        PathExpState pstate = (PathExpState) state;\n-        FieldMapping field = (pstate.cmpfield != null) ? pstate.cmpfield \n-            : pstate.field;\n-        if (isXPath())\n-            return val;\n-        if (field != null) {\n-            if (_key)\n-                return field.toKeyDataStoreValue(val, ctx.store);\n-            if (field.getElement().getDeclaredTypeCode() != JavaTypes.OBJECT)\n-                return field.toDataStoreValue(val, ctx.store);\n-\n-            val = field.getExternalValue(val, ctx.store.getContext());\n-            return field.toDataStoreValue(val, ctx.store);\n-        }\n-        return _class.toDataStoreValue(val, _class.getPrimaryKeyColumns(),\n-            ctx.store);\n-    }\n-\n-    public void select(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        selectColumns(sel, ctx, state, pks);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        ClassMapping mapping = getClassMapping(state);\n-        PathExpState pstate = (PathExpState) state;\n-        if (mapping == null || !pstate.joinedRel)\n-            sel.select(getColumns(state), pstate.joins);\n-        else if (pks)\n-            sel.select(mapping.getPrimaryKeyColumns(), pstate.joins);\n-        else {\n-            // select the mapping; allow any subs because we know this must\n-            // be either a relation, in which case it will already be\n-            // constrained by the joins, or 'this', in which case the\n-            // JDBCExpressionFactory takes care of adding class conditions for\n-            // the candidate class on the select\n-            int subs = (_type == UNBOUND_VAR) ? Select.SUBS_JOINABLE\n-                : Select.SUBS_ANY_JOINABLE;\n-            sel.select(mapping, subs, ctx.store, ctx.fetch,\n-                JDBCFetchConfiguration.EAGER_NONE, sel.outer(pstate.joins));\n-        }\n-    }\n-\n-    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n-        ClassMapping mapping = getClassMapping(state);\n-        PathExpState pstate = (PathExpState) state;\n-        if (mapping == null || !pstate.joinedRel)\n-            sel.groupBy(getColumns(state), sel.outer(pstate.joins));\n-        else {\n-            int subs = (_type == UNBOUND_VAR) ? Select.SUBS_JOINABLE\n-                : Select.SUBS_ANY_JOINABLE;\n-            sel.groupBy(mapping, subs, ctx.store, ctx.fetch, \n-                sel.outer(pstate.joins));\n-        }\n-    }\n-\n-    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n-        boolean asc) {\n-        sel.orderBy(getColumns(state), asc, sel.outer(state.joins), false);\n-    }\n-\n-    public Object load(ExpContext ctx, ExpState state, Result res)\n-        throws SQLException {\n-        return load(ctx, state, res, false);\n-    }\n-\n-    Object load(ExpContext ctx, ExpState state, Result res, boolean pks)\n-        throws SQLException {\n-        ClassMapping mapping = getClassMapping(state);\n-        PathExpState pstate = (PathExpState) state;\n-        if (mapping != null && (pstate.field == null \n-            || !pstate.field.isEmbedded())) {\n-            if (pks)\n-                return mapping.getObjectId(ctx.store, res, null, true, \n-                    pstate.joins);\n-            return res.load(mapping, ctx.store, ctx.fetch, pstate.joins);\n-        }\n-\n-        Object ret;\n-        if (_key)\n-            ret = pstate.field.loadKeyProjection(ctx.store, ctx.fetch, res, \n-                pstate.joins);\n-        else\n-            ret = pstate.field.loadProjection(ctx.store, ctx.fetch, res, \n-                pstate.joins);\n-        if (_cast != null)\n-            ret = Filters.convert(ret, _cast);\n-        return ret;\n-    }\n-\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n-        Val other, ExpState otherState) {\n-        // we don't create the SQL b/c it forces the Select to cache aliases\n-        // for the tables we use, and these aliases might not ever be used if\n-        // we eventually call appendIsEmpty or appendIsNull rather than appendTo\n-    }\n-\n-    public int length(Select sel, ExpContext ctx, ExpState state) {\n-        return getColumns(state).length;\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql, int index) {\n-        Column col = getColumns(state)[index];\n-\n-        // if select is null, it means we are not aliasing columns\n-        // (e.g., during a bulk update)\n-        if (sel == null)\n-            sql.append(col.getName());\n-        else if (_type == XPATH)\n-            // if this is an xpath, append xpath string\n-            sql.append(getXPath());\n-        else\n-            sql.append(sel.getColumnAlias(col, state.joins));\n-    }\n-\n-    public void appendIsEmpty(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql) {\n-        PathExpState pstate = (PathExpState) state;\n-        if (pstate.field == null)\n-            sql.append(FALSE);\n-        else\n-            pstate.field.appendIsEmpty(sql, sel, pstate.joins);\n-    }\n-\n-    public void appendIsNotEmpty(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql) {\n-        PathExpState pstate = (PathExpState) state;\n-        if (pstate.field == null)\n-            sql.append(FALSE);\n-        else\n-            pstate.field.appendIsNotEmpty(sql, sel, pstate.joins);\n-    }\n-\n-    public void appendSize(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql) {\n-        PathExpState pstate = (PathExpState) state;\n-        if (pstate.field == null)\n-            sql.append(\"1\");\n-        else\n-            pstate.field.appendSize(sql, sel, pstate.joins);\n-    }\n-\n-    public void appendIsNull(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql) {\n-        PathExpState pstate = (PathExpState) state;\n-        if (pstate.field == null)\n-            sql.append(FALSE);\n-        else\n-            pstate.field.appendIsNull(sql, sel, pstate.joins);\n-    }\n-\n-    public void appendIsNotNull(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql) {\n-        PathExpState pstate = (PathExpState) state;\n-        if (pstate.field == null)\n-            sql.append(TRUE);\n-        else\n-            pstate.field.appendIsNotNull(sql, sel, pstate.joins);\n-    }\n-\n-    public int hashCode() {\n-        if (_actions == null)\n-            return _candidate.hashCode();\n-        return _candidate.hashCode() ^ _actions.hashCode();\n-    }\n-\n-    public boolean equals(Object other) {\n-        if (other == this)\n-            return true;\n-        if (!(other instanceof PCPath))\n-            return false;\n-        PCPath path = (PCPath) other;\n-        return ObjectUtils.equals(_candidate, path._candidate)\n-            && ObjectUtils.equals(_actions, path._actions);\n-    }\n-\n-    /**\n-     * Helper class representing an action.\n-     */\n-    private static class Action\n-        implements Serializable {\n-\n-        public static final int GET = 0;\n-        public static final int GET_OUTER = 1;\n-        public static final int GET_KEY = 2;\n-        public static final int VAR = 3;\n-        public static final int SUBQUERY = 4;\n-        public static final int UNBOUND_VAR = 5;\n-        public static final int CAST = 6;\n-        public static final int GET_XPATH = 7;\n-\n-        public int op = -1;\n-        public Object data = null;\n-\n-        public String toString() {\n-            return op + \"|\" + data;\n-        }\n-\n-        public int hashCode() {\n-            if (data == null)\n-                return op;\n-            return op ^ data.hashCode();\n-        }\n-\n-        public boolean equals(Object other) {\n-            if (other == this)\n-                return true;\n-            Action a = (Action) other;\n-            return op == a.op\n-                && ObjectUtils.equals(data, a.data);\n-        }\n-    }\n-}"},{"sha":"85d1d42d2e09304f9b17c47ff560fb786fca658f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java","status":"removed","additions":0,"deletions":131,"changes":131,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Param.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,131 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.util.Collection;\n-import java.util.Map;\n-\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.Filters;\n-import org.apache.openjpa.kernel.exps.Parameter;\n-import org.apache.openjpa.util.ImplHelper;\n-\n-/**\n- * A parameter in a filter.\n- *\n- * @author Abe White\n- */\n-public class Param\n-    extends Const\n-    implements Parameter {\n-\n-    private final String _name;\n-    private Class _type = null;\n-    private int _idx = -1;\n-    private boolean _container = false;\n-\n-    /**\n-     * Constructor. Supply parameter name and type.\n-     */\n-    public Param(String name, Class type) {\n-        _name = name;\n-        setImplicitType(type);\n-    }\n-\n-    public String getName() {\n-        return _name;\n-    }\n-\n-    public String getParameterName() {\n-        return getName();\n-    }\n-\n-    public Class getType() {\n-        return _type;\n-    }\n-\n-    public void setImplicitType(Class type) {\n-        _type = type;\n-        _container = (getMetaData() == null || !ImplHelper.isManagedType(\n-            getMetaData().getRepository().getConfiguration(), type))\n-            && (Collection.class.isAssignableFrom(type)\n-            || Map.class.isAssignableFrom(type));\n-    }\n-\n-    public int getIndex() {\n-        return _idx;\n-    }\n-\n-    public void setIndex(int idx) {\n-        _idx = idx;\n-    }\n-\n-    public Object getValue(Object[] params) {\n-        return Filters.convert(params[_idx], getType());\n-    }\n-\n-    public Object getSQLValue(Select sel, ExpContext ctx, ExpState state) {\n-        return ((ParamExpState) state).sqlValue;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n-        return new ParamExpState();\n-    }\n-\n-    /**\n-     * Expression state.\n-     */\n-    public static class ParamExpState\n-        extends ConstExpState {\n-\n-        public Object sqlValue = null;\n-        public int otherLength = 1; \n-    } \n-\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n-        Val other, ExpState otherState) {\n-        super.calculateValue(sel, ctx, state, other, otherState);\n-        Object val = getValue(ctx.params);\n-        ParamExpState pstate = (ParamExpState) state;\n-        if (other != null && !_container) {\n-            pstate.sqlValue = other.toDataStoreValue(sel, ctx, otherState, val);\n-            pstate.otherLength = other.length(sel, ctx, otherState);\n-        } else if (ImplHelper.isManageable(val)) {\n-            ClassMapping mapping = ctx.store.getConfiguration().\n-                getMappingRepositoryInstance().getMapping(val.getClass(),\n-                ctx.store.getContext().getClassLoader(), true);\n-            pstate.sqlValue = mapping.toDataStoreValue(val,\n-                mapping.getPrimaryKeyColumns(), ctx.store);\n-            pstate.otherLength = mapping.getPrimaryKeyColumns().length;\n-        } else\n-            pstate.sqlValue = val;\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql, int index) {\n-        ParamExpState pstate = (ParamExpState) state;\n-        if (pstate.otherLength > 1)\n-            sql.appendValue(((Object[]) pstate.sqlValue)[index], \n-                pstate.getColumn(index));\n-        else\n-            sql.appendValue(pstate.sqlValue, pstate.getColumn(index));\n-    }\n-}"},{"sha":"c101b1cd3ef54ee3e50cb71fa4e1010ab56d00fd","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/QueryExpressionsState.java","status":"removed","additions":0,"deletions":36,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/QueryExpressionsState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/QueryExpressionsState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/QueryExpressionsState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,36 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-/**\n- * Struct to hold the state of a query expressions instance.\n- *\n- * @author Abe White\n- * @nojavadoc\n- */\n-public class QueryExpressionsState {\n-\n-    public static final ExpState[] EMPTY_STATES = new ExpState[0];\n-\n-    public ExpState[] projections = EMPTY_STATES;\n-    public ExpState filter = null;\n-    public ExpState[] grouping = EMPTY_STATES;\n-    public ExpState having = null;\n-    public ExpState[] ordering = EMPTY_STATES;\n-}"},{"sha":"285da8f121fa02e49f0ef2e3db25bc068456dc4f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLEmbed.java","status":"removed","additions":0,"deletions":71,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLEmbed.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLEmbed.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLEmbed.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,71 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.kernel.StoreContext;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.util.UnsupportedException;\n-import org.apache.openjpa.util.UserException;\n-\n-/**\n- * Simple listener which embeds its SQL argument into the query. Listens\n- * on <code>sql</code>.\n- *  Example:<br />\n- * <code>\"price &lt; sql(\\\"(SELECT AVG (PRICE) FROM PRODUCT_TABLE)\\\")\"</code>\n- *\n- * @nojavadoc\n- */\n-public class SQLEmbed\n-    implements JDBCFilterListener {\n-\n-    public static String TAG = \"sql\";\n-\n-    private static final Localizer _loc = Localizer.forPackage(SQLEmbed.class);\n-\n-    public String getTag() {\n-        return TAG;\n-    }\n-\n-    public boolean expectsArguments() {\n-        return true;\n-    }\n-\n-    public boolean expectsTarget() {\n-        return false;\n-    }\n-\n-    public Object evaluate(Object target, Class targetClass, Object[] args,\n-        Class[] argClasses, Object candidate, StoreContext ctx) {\n-        throw new UnsupportedException(_loc.get(\"no-in-mem\", TAG));\n-    }\n-\n-    public void appendTo(SQLBuffer buf, FilterValue target, FilterValue[] args,\n-        ClassMapping type, JDBCStore store) {\n-        if (!args[0].isConstant())\n-            throw new UserException(_loc.get(\"const-only\", TAG));\n-        buf.append(args[0].getValue().toString());\n-    }\n-\n-    public Class getType(Class targetClass, Class[] argClasses) {\n-        return Object.class;\n-    }\n-}"},{"sha":"4d2e821d1c9793d9208bc0f11b65a7a9ae121b9e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLExpression.java","status":"removed","additions":0,"deletions":41,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLExpression.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLExpression.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,41 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-/**\n- * Simple listener which embeds the argument as an expression into the\n- * where clause generated by the query. Listens on \"ext:sqlExp\".\n- *  Example:<br />\n- * <code>\n- * \"price &lt; 10 || ext:sqlExp (\\\"(SELECT AVG (PRICE) FROM PRODUCT_TABLE)\n- * &gt; 100\\\")\"\n- * </code>\n- *\n- * @nojavadoc\n- * @deprecated Use {@link SQLEmbed} directly\n- */\n-public class SQLExpression\n-    extends SQLEmbed {\n-\n-    public static final String TAG = \"sqlExp\";\n-\n-    public String getTag() {\n-        return TAG;\n-    }\n-}"},{"sha":"1a81f41965c29c99f80ec02f51934ea1a101405e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLValue.java","status":"removed","additions":0,"deletions":39,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLValue.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SQLValue.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,39 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-/**\n- * Simple listener which embeds the argument as a value into the where\n- * clause generated by the query. Listens on \"ext:sqlVal\".\n- *  Example:<br />\n- * <code> \"price &lt; ext:sqlVal (\\\"(SELECT AVG (PRICE) FROM PRODUCT_TABLE)\\\")\"\n- * </code>\n- *\n- * @nojavadoc\n- * @deprecated Use {@link SQLEmbed} directly\n- */\n-public class SQLValue\n-    extends SQLEmbed {\n-\n-    public static final String TAG = \"sqlVal\";\n-\n-    public String getTag() {\n-        return TAG;\n-    }\n-}"},{"sha":"200f404214366318fd9981c75a9356322b62f0a6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java","status":"removed","additions":0,"deletions":345,"changes":345,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,345 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.io.Serializable;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.exps.AbstractExpressionVisitor;\n-import org.apache.openjpa.kernel.exps.Constant;\n-import org.apache.openjpa.kernel.exps.Expression;\n-import org.apache.openjpa.kernel.exps.QueryExpressions;\n-import org.apache.openjpa.kernel.exps.Value;\n-\n-/**\n- * Turns parsed queries into selects.\n- *\n- * @author Abe White\n- * @nojavadoc\n- */\n-public class SelectConstructor\n-    implements Serializable {\n-\n-    private boolean _extent = false;\n-\n-    /**\n-     * Return true if we know the select to have on criteria; to be an extent.\n-     * Note that even if this method returns false, {@link #evaluate} may still\n-     * return null if we haven't cached whether the query is an extent yet.\n-     */\n-    public boolean isExtent() {\n-        return _extent;\n-    }\n-\n-    /**\n-     * Evaluate the expression, returning a new select and filling in any\n-     * associated expression state. Use {@link #select} to then select the data.\n-     * \n-     * @param ctx fill with execution context\n-     * @param state will be filled with expression state\n-     */\n-    public Select evaluate(ExpContext ctx, Select parent, String alias, \n-        QueryExpressions exps, QueryExpressionsState state) {\n-        // already know that this query is equivalent to an extent?\n-        Select sel;\n-        if (_extent) {\n-            sel = ctx.store.getSQLFactory().newSelect();\n-            sel.setAutoDistinct((exps.distinct & exps.DISTINCT_AUTO) != 0);\n-            return sel;\n-        }\n-\n-        // create a new select and initialize it with the joins needed for\n-        // the criteria of this query\n-        sel = newSelect(ctx, parent, alias, exps, state);\n-\n-        // create where clause; if there are no where conditions and\n-        // no ordering or projections, we return null to signify that this\n-        // query should be treated like an extent\n-        Select inner = sel.getFromSelect();\n-        SQLBuffer where = buildWhere((inner != null) ? inner : sel, ctx, \n-            state.filter, exps.filter);\n-        if (where == null && exps.projections.length == 0\n-            && exps.ordering.length == 0\n-            && (sel.getJoins() == null || sel.getJoins().isEmpty())) {\n-            _extent = true;\n-            sel.setAutoDistinct((exps.distinct & exps.DISTINCT_AUTO) != 0);\n-            return sel;\n-        }\n-\n-        // now set sql criteria; it goes on the inner select if present\n-        if (inner != null)\n-            inner.where(where);\n-        else\n-            sel.where(where);\n-\n-        // apply grouping and having.  this does not select the grouping\n-        // columns, just builds the GROUP BY clauses.  we don't build the\n-        // ORDER BY clauses yet because if we decide to add this select\n-        // to a union, the ORDER BY values get aliased differently\n-        if (exps.having != null) {\n-            Exp havingExp = (Exp) exps.having;\n-            SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n-            havingExp.appendTo(sel, ctx, state.having, buf);\n-            sel.having(buf);\n-        }\n-        for (int i = 0; i < exps.grouping.length; i++)\n-            ((Val) exps.grouping[i]).groupBy(sel, ctx, state.grouping[i]);\n-        return sel;\n-    }\n-\n-    /**\n-     * Return a new select with expressions initialized.\n-     */\n-    private Select newSelect(ExpContext ctx, Select parent,\n-        String alias, QueryExpressions exps, QueryExpressionsState state) {\n-        Select sel = ctx.store.getSQLFactory().newSelect();\n-        sel.setAutoDistinct((exps.distinct & exps.DISTINCT_AUTO) != 0);\n-        sel.setJoinSyntax(ctx.fetch.getJoinSyntax());\n-        sel.setParent(parent, alias);\n-        initialize(sel, ctx, exps, state);\n-\n-        if (!sel.getAutoDistinct()) {\n-            if ((exps.distinct & exps.DISTINCT_TRUE) != 0)\n-                sel.setDistinct(true);\n-            else if ((exps.distinct & exps.DISTINCT_FALSE) != 0)\n-                sel.setDistinct(false);\n-        } else if (exps.projections.length > 0) {\n-            if (!sel.isDistinct() && (exps.distinct & exps.DISTINCT_TRUE) != 0){\n-                // if the select is not distinct but the query is, force\n-                // the select to be distinct\n-                sel.setDistinct(true);\n-            } else if (sel.isDistinct()) {\n-                // when aggregating data or making a non-distinct projection\n-                // from a distinct select, we have to select from a tmp\n-                // table formed by a distinct subselect in the from clause;\n-                // this subselect selects the pks of the candidate (to\n-                // get unique candidate values) and needed field values and\n-                // applies the where conditions; the outer select applies\n-                // ordering, grouping, etc\n-                boolean agg = exps.isAggregate();\n-                boolean candidate = ProjectionExpressionVisitor.\n-                    hasCandidateProjections(exps.projections);\n-                if (agg || (candidate \n-                    && (exps.distinct & exps.DISTINCT_TRUE) == 0)) {\n-                    DBDictionary dict = ctx.store.getDBDictionary();\n-                    dict.assertSupport(dict.supportsSubselect,\n-                        \"SupportsSubselect\");\n-\n-                    Select inner = sel;\n-                    sel = ctx.store.getSQLFactory().newSelect();\n-                    sel.setParent(parent, alias);\n-                    sel.setDistinct(agg\n-                        && (exps.distinct & exps.DISTINCT_TRUE) != 0);\n-                    sel.setFromSelect(inner);\n-\n-                // auto-distincting happens to get unique candidate instances\n-                // back; don't auto-distinct if the user isn't selecting \n-                // candidate data\n-                } else if (!candidate \n-                    && (exps.distinct & exps.DISTINCT_TRUE) == 0) \n-                    sel.setDistinct(false);\n-            }\n-        }\n-        return sel;\n-    }\n-\n-    /**\n-     * Initialize all expressions.\n-     */\n-    private void initialize(Select sel, ExpContext ctx, QueryExpressions exps, \n-        QueryExpressionsState state) {\n-        Map contains = null;\n-        if (HasContainsExpressionVisitor.hasContains(exps.filter)\n-            || HasContainsExpressionVisitor.hasContains(exps.having))\n-            contains = new HashMap(7);\n-\n-        // initialize filter and having expressions\n-        Exp filterExp = (Exp) exps.filter;\n-        state.filter = filterExp.initialize(sel, ctx, contains);\n-        Exp havingExp = (Exp) exps.having;\n-        if (havingExp != null)\n-            state.having = havingExp.initialize(sel, ctx, contains);\n-\n-        // get the top-level joins and null the expression's joins\n-        // at the same time so they aren't included in the where/having SQL\n-        Joins filterJoins = state.filter.joins;\n-        Joins havingJoins = (state.having == null) ? null : state.having.joins;\n-        Joins joins = sel.and(filterJoins, havingJoins);\n-\n-        // initialize result values\n-        if (exps.projections.length > 0) {\n-            state.projections = new ExpState[exps.projections.length];\n-            Val resultVal;\n-            for (int i = 0; i < exps.projections.length; i++) {\n-                resultVal = (Val) exps.projections[i];\n-                // have to join through to related type for pc object \n-                // projections; this ensures that we have all our joins cached\n-                state.projections[i] = resultVal.initialize(sel, ctx, \n-                    Val.JOIN_REL | Val.FORCE_OUTER);\n-                joins = sel.and(joins, state.projections[i].joins);\n-            }\n-        }\n-\n-        // initialize grouping\n-        if (exps.grouping.length > 0) {\n-            state.grouping = new ExpState[exps.grouping.length];\n-            Val groupVal;\n-            for (int i = 0; i < exps.grouping.length; i++) {\n-                groupVal = (Val) exps.grouping[i];\n-                // have to join through to related type for pc object groupings;\n-                // this ensures that we have all our joins cached\n-                state.grouping[i] = groupVal.initialize(sel, ctx, Val.JOIN_REL);\n-                joins = sel.and(joins, state.grouping[i].joins);\n-            }\n-        }\n-\n-        // initialize ordering\n-        if (exps.ordering.length > 0) {\n-            state.ordering = new ExpState[exps.ordering.length];\n-            Val orderVal;\n-            for (int i = 0; i < exps.ordering.length; i++) {\n-                orderVal = (Val) exps.ordering[i];\n-                state.ordering[i] = orderVal.initialize(sel, ctx, 0);\n-                joins = sel.and(joins, state.ordering[i].joins);\n-            }\n-        }\n-        sel.where(joins);\n-    }\n-\n-    /**\n-     * Create the where sql.\n-     */\n-    private SQLBuffer buildWhere(Select sel, ExpContext ctx, ExpState state, \n-        Expression filter) {\n-        // create where buffer\n-        SQLBuffer where = new SQLBuffer(ctx.store.getDBDictionary());\n-        where.append(\"(\");\n-        Exp filterExp = (Exp) filter;\n-        filterExp.appendTo(sel, ctx, state, where);\n-\n-        if (where.sqlEquals(\"(\") || where.sqlEquals(\"(1 = 1\"))\n-            return null;\n-        return where.append(\")\");\n-    }\n-\n-    /**\n-     * Select the data for this query.\n-     */\n-    public void select(Select sel, ExpContext ctx, ClassMapping mapping,\n-        boolean subclasses, QueryExpressions exps, QueryExpressionsState state,\n-        int eager) {\n-        Select inner = sel.getFromSelect();\n-        Val val;\n-        Joins joins = null;\n-        if (sel.getSubselectPath() != null)\n-            joins = sel.newJoins().setSubselect(sel.getSubselectPath());\n-\n-        // build ordering clauses before select so that any eager join\n-        // ordering gets applied after query ordering\n-        for (int i = 0; i < exps.ordering.length; i++)\n-            ((Val) exps.ordering[i]).orderBy(sel, ctx, state.ordering[i],\n-                exps.ascending[i]);\n-\n-        // if no result string set, select matching objects like normal\n-        if (exps.projections.length == 0 && sel.getParent() == null) {\n-            int subs = (subclasses) ? Select.SUBS_JOINABLE : Select.SUBS_NONE;\n-            sel.selectIdentifier(mapping, subs, ctx.store, ctx.fetch, eager);\n-        } else if (exps.projections.length == 0) {\n-            // subselect for objects; we really just need the primary key values\n-            sel.select(mapping.getPrimaryKeyColumns(), joins);\n-        } else {\n-            // if we have an inner select, we need to select the candidate\n-            // class' pk columns to guarantee unique instances\n-            if (inner != null)\n-                inner.select(mapping.getPrimaryKeyColumns(), joins);\n-\n-            // select each result value; no need to pass on the eager mode since\n-            // under projections we always use EAGER_NONE\n-            boolean pks = sel.getParent() != null;\n-            for (int i = 0; i < exps.projections.length; i++) {\n-                val = (Val) exps.projections[i];\n-                if (inner != null)\n-                    val.selectColumns(inner, ctx, state.projections[i], pks);\n-                val.select(sel, ctx, state.projections[i], pks);\n-            }\n-\n-            // make sure having columns are selected since it is required by \n-            // some DBs.  put them last so they don't affect result processing\n-            if (exps.having != null && inner != null)\n-                ((Exp) exps.having).selectColumns(inner, ctx, state.having, \n-                    true);\n-        }\n-\n-        // select ordering columns, since it is required by some DBs.  put them\n-        // last so they don't affect result processing\n-        for (int i = 0; i < exps.ordering.length; i++) {\n-            val = (Val) exps.ordering[i];\n-            if (inner != null)\n-                val.selectColumns(inner, ctx, state.ordering[i], true);\n-            val.select(sel, ctx, state.ordering[i], true);\n-        }\n-\n-        // add conditions limiting the projections to the proper classes; if\n-        // this isn't a projection or a subq then they will already be added\n-        if (exps.projections.length > 0 || sel.getParent() != null) {\n-            ctx.store.loadSubclasses(mapping);\n-            mapping.getDiscriminator().addClassConditions((inner != null) \n-                ? inner : sel, subclasses, joins);\n-        }\n-    }\n-\n-    /**\n-     * Used to check whether a query's result projections are on the candidate.\n-     */\n-    private static class ProjectionExpressionVisitor\n-        extends AbstractExpressionVisitor {\n-\n-        private boolean _candidate = false;\n-        private int _level = 0;\n-\n-        public static boolean hasCandidateProjections(Value[] projs) {\n-            ProjectionExpressionVisitor v = new ProjectionExpressionVisitor();\n-            for (int i = 0; i < projs.length; i++) {\n-                projs[i].acceptVisit(v);\n-                if (v._candidate)\n-                    return true;\n-            }\n-            return false;\n-        }\n-\n-        public void enter(Value val) {\n-            if (!_candidate) {\n-                _candidate = (_level == 0 && val instanceof Constant)\n-                    || (val instanceof PCPath \n-                    && !((PCPath) val).isVariablePath());\n-            }\n-            _level++;\n-        }\n-\n-        public void exit(Value val) {\n-            _level--;\n-        }\n-    }\n-}"},{"sha":"9a4b666d9231197137074d080116b5aaaeb9e065","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Size.java","status":"removed","additions":0,"deletions":57,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Size.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Size.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Size.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,57 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.util.InternalException;\n-\n-/**\n- * Size.\n- *\n- * @author Marc Prud'hommeaux\n- */\n-class Size\n-    extends UnaryOp {\n-\n-    public Size(Val val) {\n-        super(val);\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n-        // initialize the value with a null test\n-        return initializeValue(sel, ctx, NULL_CMP);\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql, int index) {\n-        getValue().calculateValue(sel, ctx, state, null, null);\n-        getValue().appendSize(sel, ctx, state, sql);\n-        sel.append(sql, state.joins);\n-    }\n-\n-    protected Class getType(Class c) {\n-        return long.class;\n-    }\n-\n-    protected String getOperator() {\n-        // since we override appendTo(), this method should never be called\n-        throw new InternalException();\n-    }\n-}"},{"sha":"1fe57961c3bfbc4a13618e29feaf2dcf55d0a603","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Sqrt.java","status":"removed","additions":0,"deletions":48,"changes":48,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Sqrt.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Sqrt.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Sqrt.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,48 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-/**\n- * Square root.\n- *\n- * @author Abe White\n- */\n-public class Sqrt\n-    extends UnaryOp {\n-\n-    /**\n-     * Constructor. Provide the value to operate on.\n-     */\n-    public Sqrt(Val val) {\n-        super(val);\n-    }\n-\n-    protected Class getType(Class c) {\n-        return double.class;\n-    }\n-\n-    protected String getOperator() {\n-        return \"SQRT\";\n-    }\n-\n-    public int getId() {\n-        return Val.SQRT_VAL;\n-    }\n-}\n-"},{"sha":"e7b2c518681e06ea44dd5be27049bea4344efd04","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StartsWithExpression.java","status":"removed","additions":0,"deletions":282,"changes":282,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StartsWithExpression.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StartsWithExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StartsWithExpression.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,282 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.util.Map;\n-\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.meta.FieldMapping;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.Table;\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-import org.apache.openjpa.meta.XMLMetaData;\n-import serp.util.Numbers;\n-\n-/**\n- * Test if one string starts with another.\n- *\n- * @author Abe White\n- */\n-class StartsWithExpression\n-    implements Exp {\n-\n-    private final Val _val1;\n-    private final Val _val2;\n-\n-    /**\n-     * Constructor. Supply values.\n-     */\n-    public StartsWithExpression(Val val1, Val val2) {\n-        _val1 = val1;\n-        _val2 = val2;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, Map contains) {\n-        ExpState s1 = _val1.initialize(sel, ctx, 0);\n-        ExpState s2 = _val2.initialize(sel, ctx, 0);\n-        return new BinaryOpExpState(sel.and(s1.joins, s2.joins), s1, s2);\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf) {\n-        BinaryOpExpState bstate = (BinaryOpExpState) state;\n-        _val1.calculateValue(sel, ctx, bstate.state1, _val2, bstate.state2);\n-        _val2.calculateValue(sel, ctx, bstate.state2, _val1, bstate.state1);\n-\n-        if (_val1 instanceof Const \n-            && ((Const) _val1).getValue(ctx, bstate.state1) == null)\n-            buf.append(\"1 <> 1\");\n-        else if (_val2 instanceof Const) {\n-            Object o = ((Const) _val2).getValue(ctx, bstate.state2);\n-            if (o == null)\n-                buf.append(\"1 <> 1\");\n-            else {\n-                Column col = null;\n-                if (_val1 instanceof PCPath) {\n-                    Column[] cols = ((PCPath) _val1).getColumns(bstate.state1);\n-                    if (cols.length == 1)\n-                        col = cols[0];\n-                }\n-\n-                _val1.appendTo(sel, ctx, bstate.state1, buf, 0);\n-                buf.append(\" LIKE \");\n-                buf.appendValue(o.toString() + \"%\", col);\n-            }\n-        } else {\n-            String pre = null;\n-            String post = null;\n-            DBDictionary dict = ctx.store.getDBDictionary();\n-            String func = dict.stringLengthFunction;\n-            if (func != null) {\n-                int idx = func.indexOf(\"{0}\");\n-                pre = func.substring(0, idx);\n-                post = func.substring(idx + 3);\n-            }\n-\n-            // if we can't use LIKE, we have to take the substring of the\n-            // first value and compare it to the second\n-            dict.assertSupport(pre != null, \"StringLengthFunction\");\n-            dict.substring(buf,\n-                new FilterValueImpl(sel, ctx, bstate.state1, _val1),\n-                new ZeroFilterValue(sel, state),\n-                new StringLengthFilterValue(sel, ctx, bstate.state2, pre,post));\n-            buf.append(\" = \");\n-            _val2.appendTo(sel, ctx, bstate.state2, buf, 0);\n-        }\n-\n-        sel.append(buf, state.joins);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        BinaryOpExpState bstate = (BinaryOpExpState) state;\n-        _val1.selectColumns(sel, ctx, bstate.state1, true);\n-        _val2.selectColumns(sel, ctx, bstate.state2, true);\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        _val1.acceptVisit(visitor);\n-        _val2.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-\n-    /**\n-     * Evaluates to 0.\n-     */\n-    private static class ZeroFilterValue\n-        implements FilterValue {\n-\n-        private final Select _sel;\n-        private final ExpState _state;\n-\n-        public ZeroFilterValue(Select sel, ExpState state) {\n-            _sel = sel;\n-            _state = state;\n-        }\n-\n-        public Class getType() {\n-            return int.class;\n-        }\n-\n-        public int length() {\n-            return 1;\n-        }\n-\n-        public void appendTo(SQLBuffer buf) {\n-            appendTo(buf, 0);\n-        }\n-\n-        public void appendTo(SQLBuffer buf, int index) {\n-            buf.appendValue(0);\n-        }\n-\n-        public String getColumnAlias(Column col) {\n-            return _sel.getColumnAlias(col, _state.joins);\n-        }\n-\n-        public String getColumnAlias(String col, Table table) {\n-            return _sel.getColumnAlias(col, table, _state.joins);\n-        }\n-\n-        public Object toDataStoreValue(Object val) {\n-            return val;\n-        }\n-\n-        public boolean isConstant() {\n-            return true;\n-        }\n-\n-        public Object getValue() {\n-            return Numbers.valueOf(0);\n-        }\n-\n-        public Object getSQLValue() {\n-            return Numbers.valueOf(0);\n-        }\n-\n-        public boolean isPath() {\n-            return false;\n-        }\n-\n-        public ClassMapping getClassMapping() {\n-            return null;\n-        }\n-\n-        public FieldMapping getFieldMapping() {\n-            return null;\n-        }\n-        \n-        public PCPath getXPath() {\n-            return null;\n-        }\n-        \n-        public XMLMetaData getXmlMapping() {\n-            return null;\n-        }\n-\n-    }\n-\n-    /**\n-     * Evaluates to the length of a given value.\n-     */\n-    private class StringLengthFilterValue\n-        implements FilterValue {\n-\n-        private final Select _sel;\n-        private final ExpContext _ctx;\n-        private final ExpState _state;\n-        private final String _pre;\n-        private final String _post;\n-\n-        public StringLengthFilterValue(Select sel, ExpContext ctx, \n-            ExpState state, String pre, String post){\n-            _sel = sel;\n-            _ctx = ctx;\n-            _state = state;\n-            _pre = pre;\n-            _post = post;\n-        }\n-\n-        public Class getType() {\n-            return int.class;\n-        }\n-\n-        public int length() {\n-            return 1;\n-        }\n-\n-        public void appendTo(SQLBuffer buf) {\n-            appendTo(buf, 0);\n-        }\n-\n-        public void appendTo(SQLBuffer buf, int index) {\n-            buf.append(_pre);\n-            _val2.appendTo(_sel, _ctx, _state, buf, index);\n-            buf.append(_post);\n-        }\n-\n-        public String getColumnAlias(Column col) {\n-            return _sel.getColumnAlias(col, _state.joins);\n-        }\n-\n-        public String getColumnAlias(String col, Table table) {\n-            return _sel.getColumnAlias(col, table, _state.joins);\n-        }\n-\n-        public Object toDataStoreValue(Object val) {\n-            return _val2.toDataStoreValue(_sel, _ctx, _state, val);\n-        }\n-\n-        public boolean isConstant() {\n-            return false;\n-        }\n-\n-        public Object getValue() {\n-            return null;\n-        }\n-\n-        public Object getSQLValue() {\n-            return null;\n-        }\n-\n-        public boolean isPath() {\n-            return false;\n-        }\n-\n-        public ClassMapping getClassMapping() {\n-            return null;\n-        }\n-\n-        public FieldMapping getFieldMapping() {\n-            return null;\n-        }\n-        \n-        public PCPath getXPath() {\n-            return null;\n-        }\n-        \n-        public XMLMetaData getXmlMapping() {\n-            return null;\n-        }\n-    }\n-}"},{"sha":"3a2c251207ba31f270539dd4711bd77229f64868","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringFunction.java","status":"removed","additions":0,"deletions":119,"changes":119,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringFunction.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringFunction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringFunction.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,119 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.Filters;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-import org.apache.openjpa.meta.ClassMetaData;\n-\n-/**\n- * A JDBC string function.\n- *\n- * @author Marc Prud'hommeaux\n- */\n-abstract class StringFunction\n-    extends AbstractVal {\n-\n-    private final Val _val;\n-    private ClassMetaData _meta = null;\n-\n-    /**\n-     * Constructor. Provide the string to operate on.\n-     */\n-    public StringFunction(Val val) {\n-        _val = val;\n-    }\n-\n-    public Val getValue() {\n-        return _val;\n-    }\n-\n-    public ClassMetaData getMetaData() {\n-        return _meta;\n-    }\n-\n-    public void setMetaData(ClassMetaData meta) {\n-        _meta = meta;\n-    }\n-\n-    public Class getType() {\n-        return String.class;\n-    }\n-\n-    public void setImplicitType(Class type) {\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n-        return _val.initialize(sel, ctx, flags);\n-    }\n-\n-    public void select(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        sel.select(newSQLBuffer(sel, ctx, state), this);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        _val.selectColumns(sel, ctx, state, true);\n-    }\n-\n-    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n-        sel.groupBy(newSQLBuffer(sel, ctx, state));\n-    }\n-\n-    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n-        boolean asc) {\n-        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n-    }\n-\n-    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n-        calculateValue(sel, ctx, state, null, null);\n-        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n-        appendTo(sel, ctx, state, buf, 0);\n-        return buf;\n-    }\n-\n-    public Object load(ExpContext ctx, ExpState state, Result res)\n-        throws SQLException {\n-        return Filters.convert(res.getObject(this,\n-            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n-    }\n-\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n-        Val other, ExpState otherState) {\n-        _val.calculateValue(sel, ctx, state, null, null);\n-    }\n-\n-    public int length(Select sel, ExpContext ctx, ExpState state) {\n-        return 1;\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        _val.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-}\n-"},{"sha":"02535edfec268c9bcff629b098f828ef2cbd27cd","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringLength.java","status":"removed","additions":0,"deletions":69,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringLength.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringLength.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/StringLength.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,69 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-\n-/**\n- * Returns the number of characters in a string.\n- *\n- * @author Marc Prud'hommeaux\n- */\n-public class StringLength\n-    extends StringFunction {\n-\n-    private Class _cast = null;\n-\n-    /**\n-     * Constructor. Provide the string to operate on.\n-     */\n-    public StringLength(Val val) {\n-        super(val);\n-    }\n-\n-    public Class getType() {\n-        if (_cast != null)\n-            return _cast;\n-        return int.class;\n-    }\n-\n-    public void setImplicitType(Class type) {\n-        _cast = type;\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf, int index) {\n-        DBDictionary dict = ctx.store.getDBDictionary();\n-        String func = dict.stringLengthFunction;\n-        dict.assertSupport(func != null, \"StringLengthFunction\");\n-        func = dict.getCastFunction(getValue(), func);\n-        \n-        int idx = func.indexOf(\"{0}\");\n-        buf.append(func.substring(0, idx));\n-        getValue().appendTo(sel, ctx, state, buf, index);\n-        buf.append(func.substring(idx + 3));\n-    }\n-\n-    public int getId() {\n-        return Val.LENGTH_VAL;\n-    }\n-}\n-"},{"sha":"dcdb1510c09304a01ca5a911dc1884fd88f86bae","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java","status":"removed","additions":0,"deletions":207,"changes":207,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,207 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.Filters;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-import org.apache.openjpa.kernel.exps.QueryExpressions;\n-import org.apache.openjpa.kernel.exps.Subquery;\n-import org.apache.openjpa.meta.ClassMetaData;\n-\n-/**\n- * A subquery.\n- *\n- * @author Abe White\n- */\n-class SubQ\n-    extends AbstractVal\n-    implements Subquery {\n-\n-    private final ClassMapping _candidate;\n-    private final boolean _subs;\n-    private final String _alias;\n-    private final SelectConstructor _cons = new SelectConstructor();\n-\n-    private Class _type = null;\n-    private ClassMetaData _meta = null;\n-    private QueryExpressions _exps = null;\n-\n-    /**\n-     * Constructor. Supply candidate, whether subclasses are included in\n-     * the query, and the query alias.\n-     */\n-    public SubQ(ClassMapping candidate, boolean subs, String alias) {\n-        _candidate = candidate;\n-        _subs = subs;\n-        _alias = alias;\n-    }\n-\n-    /**\n-     * Return the subquery candidate type.\n-     */\n-    public ClassMapping getCandidate() {\n-        return _candidate;\n-    }\n-\n-    public Class getType() {\n-        if (_exps != null) {\n-            if (_exps.projections.length == 0)\n-                return _candidate.getDescribedType();\n-            if (_exps.projections.length == 1)\n-                return _exps.projections[0].getType();\n-        }\n-        return _type;\n-    }\n-\n-    public void setImplicitType(Class type) {\n-        if (_exps != null && _exps.projections.length == 1)\n-            _exps.projections[0].setImplicitType(type);\n-        _type = type;\n-    }\n-\n-    public ClassMetaData getMetaData() {\n-        return _meta;\n-    }\n-\n-    public void setMetaData(ClassMetaData meta) {\n-        _meta = meta;\n-    }\n-\n-    public String getCandidateAlias() {\n-        return _alias;\n-    }\n-\n-    public void setQueryExpressions(QueryExpressions query) {\n-        _exps = query;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n-        if (_exps.projections.length == 1)\n-            return ((Val) _exps.projections[0]).initialize(sel, ctx, flags);\n-        return ExpState.NULL;\n-    }\n-\n-    public Object toDataStoreValue(Select sel, ExpContext ctx, ExpState state, \n-        Object val) {\n-        if (_exps.projections.length == 0)\n-            return _candidate.toDataStoreValue(val,\n-                _candidate.getPrimaryKeyColumns(), ctx.store);\n-        if (_exps.projections.length == 1)\n-            return ((Val) _exps.projections[0]).toDataStoreValue(sel, ctx, \n-                state, val);\n-        return val;\n-    }\n-\n-    public void select(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        selectColumns(sel, ctx, state, pks);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        sel.select(newSQLBuffer(sel, ctx, state), this);\n-    }\n-\n-    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n-        sel.groupBy(newSQLBuffer(sel, ctx, state));\n-    }\n-\n-    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n-        boolean asc) {\n-        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n-    }\n-\n-    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n-        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n-        appendTo(sel, ctx, state, buf, 0);\n-        return buf;\n-    }\n-\n-    public Object load(ExpContext ctx, ExpState state, Result res) \n-        throws SQLException {\n-        return Filters.convert(res.getObject(this,\n-            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n-    }\n-\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n-        Val other, ExpState otherState) {\n-    }\n-\n-    public int length(Select sel, ExpContext ctx, ExpState state) {\n-        return 1;\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql, int index) {\n-        appendTo(sel, ctx, state, sql, index, false);\n-    }\n-\n-    private void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql, int index, boolean size) {\n-        QueryExpressionsState substate = new QueryExpressionsState();\n-        Select sub = _cons.evaluate(ctx, sel, _alias, _exps, substate);\n-        _cons.select(sub, ctx, _candidate, _subs, _exps, substate, \n-            JDBCFetchConfiguration.EAGER_NONE);\n-\n-        if (size)\n-            sql.appendCount(sub, ctx.fetch);\n-        else\n-            sql.append(sub, ctx.fetch);\n-    }\n-\n-    public void appendIsEmpty(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql) {\n-        sql.append(\"NOT EXISTS \");\n-        appendTo(sel, ctx, state, sql, 0);\n-    }\n-\n-    public void appendIsNotEmpty(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql) {\n-        sql.append(\"EXISTS \");\n-        appendTo(sel, ctx, state, sql, 0);\n-    }\n-\n-    public void appendSize(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql) {\n-        appendTo(sel, ctx, state, sql, 0, true);\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        for (int i = 0; i < _exps.projections.length; i++)\n-            _exps.projections[i].acceptVisit(visitor);\n-        if (_exps.filter != null)\n-            _exps.filter.acceptVisit(visitor);\n-        for (int i = 0; i < _exps.grouping.length; i++)\n-            _exps.grouping[i].acceptVisit(visitor);\n-        if (_exps.having != null)\n-            _exps.having.acceptVisit(visitor);\n-        for (int i = 0; i < _exps.ordering.length; i++)\n-            _exps.ordering[i].acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-}"},{"sha":"a7d01bde7d6ce5d4382ae93de97166e470e00973","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Substring.java","status":"removed","additions":0,"deletions":153,"changes":153,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Substring.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Substring.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Substring.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,153 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.Filters;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-import org.apache.openjpa.meta.ClassMetaData;\n-\n-/**\n- * Take a substring of a string.\n- *\n- * @author Abe White\n- */\n-public class Substring\n-    extends AbstractVal {\n-\n-    private final Val _val1;\n-    private final Val _val2;\n-    private ClassMetaData _meta = null;\n-\n-    /**\n-     * Constructor. Provide the strings to operate on.\n-     */\n-    public Substring(Val val1, Val val2) {\n-        _val1 = val1;\n-        _val2 = val2;\n-    }\n-\n-    public Val getVal1() {\n-        return _val1;\n-    }\n-\n-    public Val getVal2() {\n-        return _val2;\n-    }\n-\n-    public ClassMetaData getMetaData() {\n-        return _meta;\n-    }\n-\n-    public void setMetaData(ClassMetaData meta) {\n-        _meta = meta;\n-    }\n-\n-    public Class getType() {\n-        return String.class;\n-    }\n-\n-    public void setImplicitType(Class type) {\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n-        ExpState s1 = _val1.initialize(sel, ctx, 0);\n-        ExpState s2 = _val2.initialize(sel, ctx, 0);\n-        return new BinaryOpExpState(sel.and(s1.joins, s2.joins), s1, s2);\n-    }\n-\n-    public void select(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        sel.select(newSQLBuffer(sel, ctx, state), this);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        BinaryOpExpState bstate = (BinaryOpExpState) state;\n-        _val1.selectColumns(sel, ctx, bstate.state1, true);\n-        _val2.selectColumns(sel, ctx, bstate.state2, true);\n-    }\n-\n-    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n-        sel.groupBy(newSQLBuffer(sel, ctx, state));\n-    }\n-\n-    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n-        boolean asc) {\n-        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n-    }\n-\n-    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n-        calculateValue(sel, ctx, state, null, null);\n-        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n-        appendTo(sel, ctx, state, buf, 0);\n-        return buf;\n-    }\n-\n-    public Object load(ExpContext ctx, ExpState state, Result res)\n-        throws SQLException {\n-        return Filters.convert(res.getObject(this,\n-            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n-    }\n-\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n-        Val other, ExpState otherState) {\n-        BinaryOpExpState bstate = (BinaryOpExpState) state;\n-        _val1.calculateValue(sel, ctx, bstate.state1, null, null);\n-        _val2.calculateValue(sel, ctx, bstate.state2, null, null);\n-    }\n-\n-    public int length(Select sel, ExpContext ctx, ExpState state) {\n-        return 1;\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql, int index) {\n-        BinaryOpExpState bstate = (BinaryOpExpState) state;\n-        FilterValue str = new FilterValueImpl(sel, ctx, bstate.state1, _val1);\n-        FilterValue start;\n-        FilterValue end = null;\n-        if (_val2 instanceof Args) {\n-            FilterValue[] filts = ((Args) _val2).newFilterValues(sel, ctx, \n-                bstate.state2);\n-            start = filts[0];\n-            end = filts[1];\n-        } else\n-            start = new FilterValueImpl(sel, ctx, bstate.state2, _val2);\n-\n-        ctx.store.getDBDictionary().substring(sql, str, start, end);\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        _val1.acceptVisit(visitor);\n-        _val2.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-\n-    public int getId() {\n-        return Val.SUBSTRING_VAL;\n-    }\n-}\n-"},{"sha":"ad0f9c663ac324e78f09a64eed8e137a62ea8ca5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Sum.java","status":"removed","additions":0,"deletions":54,"changes":54,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Sum.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Sum.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Sum.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,54 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.kernel.Filters;\n-\n-/**\n- * Sum.\n- *\n- * @author Abe White\n- */\n-class Sum\n-    extends UnaryOp {\n-\n-    /**\n-     * Constructor. Provide the value to operate on.\n-     */\n-    public Sum(Val val) {\n-        super(val);\n-    }\n-\n-    protected Class getType(Class c) {\n-        Class wrap = Filters.wrap(c);\n-        if (wrap == Integer.class\n-            || wrap == Short.class\n-            || wrap == Byte.class)\n-            return long.class;\n-        return c;\n-    }\n-\n-    protected String getOperator() {\n-        return \"SUM\";\n-    }\n-\n-    public boolean isAggregate() {\n-        return true;\n-    }\n-}"},{"sha":"6c1dbfcf6a0d14da95d12bd0d78b6d257cda69db","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java","status":"removed","additions":0,"deletions":57,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,57 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-\n-/**\n- * Lower-cases a string.\n- *\n- * @author Abe White\n- */\n-public class ToLowerCase\n-    extends StringFunction {\n-\n-    /**\n-     * Constructor. Provide the string to operate on.\n-     */\n-    public ToLowerCase(Val val) {\n-        super(val);\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf, int index) {\n-\n-        DBDictionary dict = ctx.store.getDBDictionary();\n-        String func = dict.toLowerCaseFunction;\n-        dict.assertSupport(func != null, \"ToLowerCaseFunction\");\n-        func = dict.getCastFunction(getValue(), func);\n-\n-        int idx = func.indexOf(\"{0}\");\n-        buf.append(func.substring(0, idx));\n-        getValue().appendTo(sel, ctx, state, buf, index);\n-        buf.append(func.substring(idx + 3));\n-    }\n-\n-    public int getId() {\n-        return Val.LOWER_VAL;\n-    }\n-}"},{"sha":"8c176c7d4058254115a604dc1255f92639950452","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java","status":"removed","additions":0,"deletions":58,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,58 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-\n-/**\n- * Upper-cases a string.\n- *\n- * @author Abe White\n- */\n-public class ToUpperCase\n-    extends StringFunction {\n-\n-    /**\n-     * Constructor. Provide the string to operate on.\n-     */\n-    public ToUpperCase(Val val) {\n-        super(val);\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf, int index) {\n-\n-        DBDictionary dict = ctx.store.getDBDictionary();\n-        String func = dict.toUpperCaseFunction;\n-        dict.assertSupport(func != null, \"ToUpperCaseFunction\");\n-        func = dict.getCastFunction(getValue(), func);\n-\n-        int idx = func.indexOf(\"{0}\");\n-        buf.append(func.substring(0, idx));\n-        getValue().appendTo(sel, ctx, state, buf, index);\n-        buf.append(func.substring(idx + 3));\n-    }\n-\n-    public int getId() {\n-        return Val.UPPER_VAL;\n-    }\n-}\n-"},{"sha":"183ada1d22777cc7fd0f33ae60c98699567fa890","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Trim.java","status":"removed","additions":0,"deletions":215,"changes":215,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Trim.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Trim.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Trim.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,215 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.lang.Math;\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.Filters;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-import org.apache.openjpa.meta.ClassMetaData;\n-\n-/**\n- * Returns the number of characters in a string.\n- *\n- * @author Marc Prud'hommeaux\n- */\n-public class Trim\n-    extends AbstractVal {\n-\n-    private final Val _val;\n-    private final Val _trimChar;\n-    private final Boolean _where;\n-    private ClassMetaData _meta = null;\n-\n-    /**\n-     * Constructor. Provide the string to operate on.\n-     */\n-    public Trim(Val val, Val trimChar, Boolean where) {\n-        _val = val;\n-        _trimChar = trimChar;\n-        _where = where;\n-    }\n-\n-    public Val getVal() {\n-        return _val;\n-    }\n-\n-    public Val getTrimChar() {\n-        return _trimChar;\n-    }\n-\n-    public Boolean getWhere(){\n-        return _where;\n-    }\n-\n-    public ClassMetaData getMetaData() {\n-        return _meta;\n-    }\n-\n-    public void setMetaData(ClassMetaData meta) {\n-        _meta = meta;\n-    }\n-\n-    public Class getType() {\n-        return String.class;\n-    }\n-\n-    public void setImplicitType(Class type) {\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n-        ExpState valueState =  _val.initialize(sel, ctx, 0);\n-        ExpState charState = _trimChar.initialize(sel, ctx, 0);\n-        return new TrimExpState(sel.and(valueState.joins, charState.joins), \n-            valueState, charState);\n-    }\n-\n-    /**\n-     * Expression state.\n-     */\n-    private static class TrimExpState\n-        extends ExpState {\n-\n-        public final ExpState valueState;\n-        public final ExpState charState;\n-\n-        public TrimExpState(Joins joins, ExpState valueState, \n-            ExpState charState) {\n-            super(joins);\n-            this.valueState = valueState;\n-            this.charState = charState;\n-        }\n-    }\n-\n-    public void select(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        sel.select(newSQLBuffer(sel, ctx, state), this);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        TrimExpState tstate = (TrimExpState) state;\n-        _val.selectColumns(sel, ctx, tstate.valueState, true);\n-        _trimChar.selectColumns(sel, ctx, tstate.charState, true);\n-    }\n-\n-    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n-        sel.groupBy(newSQLBuffer(sel, ctx, state));\n-    }\n-\n-    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n-        boolean asc) {\n-        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n-    }\n-\n-    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n-        calculateValue(sel, ctx, state, null, null);\n-        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n-        appendTo(sel, ctx, state, buf, 0);\n-        return buf;\n-    }\n-\n-    public Object load(ExpContext ctx, ExpState state, Result res)\n-        throws SQLException {\n-        return Filters.convert(res.getObject(this,\n-            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n-    }\n-\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n-        Val other, ExpState otherState) {\n-        TrimExpState tstate = (TrimExpState) state;\n-        _val.calculateValue(sel, ctx, tstate.valueState, null, null);\n-        _trimChar.calculateValue(sel, ctx, tstate.charState, null, null);\n-    }\n-\n-    public int length(Select sel, ExpContext ctx, ExpState state) {\n-        return 1;\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql, int index) {\n-        DBDictionary dict = ctx.store.getDBDictionary();\n-        String func;\n-        if (_where == null) {\n-            func = dict.trimBothFunction;\n-            dict.assertSupport(func != null, \"TrimBothFunction\");\n-        } else if (_where.booleanValue()) {\n-            func = dict.trimLeadingFunction;\n-            dict.assertSupport(func != null, \"TrimLeadingFunction\");\n-        } else {\n-            func = dict.trimTrailingFunction;\n-            dict.assertSupport(func != null, \"TrimTrailingFunction\");\n-        }        \n-        func = dict.getCastFunction(_val, func);\n-        \n-        int fromPart = func.indexOf(\"{0}\");\n-        int charPart = func.indexOf(\"{1}\");\n-        if (charPart == -1)\n-            charPart = func.length();\n-        String part1 = func.substring(0, Math.min(fromPart, charPart));\n-        String part2 = func.substring(Math.min(fromPart, charPart) + 3,\n-            Math.max(fromPart, charPart));\n-        String part3 = null;\n-        if (charPart != func.length())\n-            part3 = func.substring(Math.max(fromPart, charPart) + 3);\n-\n-        TrimExpState tstate = (TrimExpState) state;\n-        sql.append(part1);\n-        if (fromPart < charPart)\n-            _val.appendTo(sel, ctx, tstate.valueState, sql, 0);\n-        else \n-            _trimChar.appendTo(sel, ctx, tstate.charState, sql, 0);\n-        sql.append(part2);\n-\n-        if (charPart != func.length()) {\n-            if (fromPart > charPart)\n-                _val.appendTo(sel, ctx, tstate.valueState, sql, 0);\n-            else\n-                _trimChar.appendTo(sel, ctx, tstate.charState, sql, 0);\n-            sql.append(part3);\n-        } else {\n-            // since the trim statement did not specify the token for\n-            // where to specify the trim char (denoted by \"{1}\"),\n-            // we do not have the ability to trim off non-whitespace\n-            // characters; throw an exception when we attempt to do so\n-            if (!(_trimChar instanceof Const) || String.valueOf(((Const) \n-                _trimChar).getValue(ctx,tstate.charState)).trim().length() != 0)\n-                dict.assertSupport(false, \"TrimNonWhitespaceCharacters\");\n-        }\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        _val.acceptVisit(visitor);\n-        _trimChar.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-\n-    public int getId() {\n-        return Val.TRIM_VAL;\n-    }\n-}\n-"},{"sha":"64e94eaf7d86f43338c4082f836446eeec48954a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/UnaryOp.java","status":"removed","additions":0,"deletions":158,"changes":158,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/UnaryOp.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/UnaryOp.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/UnaryOp.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,158 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.Filters;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-import org.apache.openjpa.meta.ClassMetaData;\n-\n-/**\n- * Value produced by a unary operation on a value.\n- *\n- * @author Abe White\n- */\n-abstract class UnaryOp\n-    extends AbstractVal {\n-\n-    private final Val _val;\n-    private ClassMetaData _meta = null;\n-    private Class _cast = null;\n-    private boolean _noParen = false;\n-\n-    /**\n-     * Constructor. Provide the value to operate on.\n-     */\n-    public UnaryOp(Val val) {\n-        _val = val;\n-    }\n-    \n-    public UnaryOp(Val val, boolean noParen) {\n-        _val = val;\n-        _noParen = noParen;\n-    }\n-\n-    public Val getValue() {\n-        return _val;\n-    }\n-\n-    public ClassMetaData getMetaData() {\n-        return _meta;\n-    }\n-\n-    public void setMetaData(ClassMetaData meta) {\n-        _meta = meta;\n-    }\n-\n-    public Class getType() {\n-        if (_cast != null)\n-            return _cast;\n-        return getType(_val.getType());\n-    }\n-\n-    public void setImplicitType(Class type) {\n-        _cast = type;\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n-        return initializeValue(sel, ctx, flags);\n-    }\n-\n-    protected ExpState initializeValue(Select sel, ExpContext ctx, int flags) {\n-        return _val.initialize(sel, ctx, flags);\n-    }\n-\n-    public void select(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        sel.select(newSQLBuffer(sel, ctx, state), this);\n-        if (isAggregate())\n-            sel.setAggregate(true);\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-        _val.selectColumns(sel, ctx, state, true);\n-    }\n-\n-    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n-        sel.groupBy(newSQLBuffer(sel, ctx, state));\n-    }\n-\n-    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n-        boolean asc) {\n-        sel.orderBy(newSQLBuffer(sel, ctx, state), asc, false);\n-    }\n-\n-    private SQLBuffer newSQLBuffer(Select sel, ExpContext ctx, ExpState state) {\n-        calculateValue(sel, ctx, state, null, null);\n-        SQLBuffer buf = new SQLBuffer(ctx.store.getDBDictionary());\n-        appendTo(sel, ctx, state, buf, 0);\n-        return buf;\n-    }\n-\n-    public Object load(ExpContext ctx, ExpState state, Result res)\n-        throws SQLException {\n-        return Filters.convert(res.getObject(this,\n-            JavaSQLTypes.JDBC_DEFAULT, null), getType());\n-    }\n-\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n-        Val other, ExpState otherState) {\n-        _val.calculateValue(sel, ctx, state, null, null);\n-    }\n-\n-    public int length(Select sel, ExpContext ctx, ExpState state) {\n-        return 1;\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql, int index) {\n-        sql.append(getOperator());\n-        sql.append(_noParen ? \" \" : \"(\");\n-        _val.appendTo(sel, ctx, state, sql, 0);\n-        sql.addCastForParam(getOperator(), _val);\n-        if (!_noParen)\n-            sql.append(\")\");\n-    }\n-\n-    /**\n-     * Return the type of this value based on the argument type. Returns\n-     * the argument type by default.\n-     */\n-    protected Class getType(Class c) {\n-        return c;\n-    }\n-\n-    /**\n-     * Return the name of this operator.\n-     */\n-    protected abstract String getOperator();\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        _val.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-}\n-"},{"sha":"d217622facb3a91841021cbff6e8500313c03ba8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Val.java","status":"removed","additions":0,"deletions":163,"changes":163,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Val.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Val.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Val.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,163 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.exps.Value;\n-\n-/**\n- * A Value represents any non-operator in a query filter, including\n- * constants, variables, and object fields.\n- *\n- * @author Abe White\n- * @nojavadoc\n- */\n-public interface Val\n-    extends Value {\n-\n-    /**\n-     * Initialization flag indicating that this value will be compared to null.\n-     */\n-    public final int NULL_CMP = 2 << 0;\n-\n-    /**\n-     * Initialization flag indicating to join into any relation path.\n-     */\n-    public final int JOIN_REL = 2 << 1; \n-\n-    /**\n-     * Initialization flag indicating to force an outer join into any relation \n-     * path.\n-     */\n-    public final int FORCE_OUTER = 2 << 2; \n-\n-    public final int VAL = 0;\n-    public final int MATH_VAL = 1;\n-    public final int CONCAT_VAL = 2;\n-    public final int SUBSTRING_VAL = 3;\n-    public final int UPPER_VAL = 4;\n-    public final int LOWER_VAL = 5;\n-    public final int TRIM_VAL = 6;\n-    public final int LENGTH_VAL = 7;\n-    public final int LOCATE_VAL = 8;\n-    public final int ARGS_VAL = 9;\n-    public final int INDEXOF_VAL = 10;\n-    public final int ABS_VAL = 11;\n-    public final int SQRT_VAL = 12;\n-\n-    /**\n-     * Initialize the value. This method should recursively initialize any\n-     * sub-values. \n-     */\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags);\n-\n-    /**\n-     * Return the datastore value of the given object in the context of this\n-     * value.\n-     */\n-    public Object toDataStoreValue(Select sel, ExpContext ctx, ExpState state, \n-        Object val);\n-\n-    /**\n-     * Select the data for this value.\n-     */\n-    public void select(Select sel, ExpContext ctx, ExpState state, boolean pks);\n-\n-    /**\n-     * Select just the columns for this value.\n-     */\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks);\n-\n-    /**\n-     * Group by this value.\n-     */\n-    public void groupBy(Select sel, ExpContext ctx, ExpState state);\n-\n-    /**\n-     * Order by this value.\n-     */\n-    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n-        boolean asc);\n-\n-    /**\n-     * Load the data for this value.\n-     */\n-    public Object load(ExpContext ctx, ExpState state, Result res)\n-        throws SQLException;\n-\n-    /**\n-     * Calculate and cache the SQL for this value. This method is called\n-     * before <code>length</code> or any <code>append</code> methods.\n-     *\n-     * @param other the value being compared to, or null if not a comparison\n-     */\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n-        Val other, ExpState otherState);\n-\n-    /**\n-     * Return the number of SQL elements in this value.\n-     */\n-    public int length(Select sel, ExpContext ctx, ExpState state);\n-\n-    /**\n-     * Append the <code>index</code>th SQL element to the given buffer.\n-     */\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql, \n-        int index);\n-\n-    /**\n-     * Append the SQL testing whether this value is empty to the given buffer.\n-     */\n-    public void appendIsEmpty(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql);\n-\n-    /**\n-     * Append the SQL testing whether this value is not empty to\n-     * the given buffer.\n-     */\n-    public void appendIsNotEmpty(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql);\n-\n-    /**\n-     * Append the SQL checking the size of this value.\n-     */\n-    public void appendSize(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql);\n-\n-    /**\n-     * Append the SQL testing whether this value is null to the given buffer.\n-     */\n-    public void appendIsNull(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql);\n-\n-    /**\n-     * Append the SQL testing whether this value is not null to the given\n-     * buffer.\n-     */\n-    public void appendIsNotNull(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql);\n-\n-    public int getId();\n-}"},{"sha":"f9eda41909dd61bfc8c3b299693730275cc1f96e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Variable.java","status":"removed","additions":0,"deletions":177,"changes":177,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Variable.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Variable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Variable.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,177 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.kernel.exps;\n-\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n-import org.apache.openjpa.meta.ClassMetaData;\n-\n-/**\n- * A variable in a filter. Typically, the {@link #initialize} and\n- * {@link #getJoins} methods of this value are not called. They are\n- * only called if the variable is bound but otherwise unused in the filter,\n- * in which case we must at least make the joins to the variable because the\n- * act of binding a variable should at least guarantee that an instance\n- * represting the variable could exist (i.e. the binding collection is not\n- * empty).\n- *\n- * @author Abe White\n- */\n-class Variable\n-    extends AbstractVal {\n-\n-    private final String _name;\n-    private final Class _type;\n-    private ClassMetaData _meta;\n-    private PCPath _path = null;\n-    private Class _cast = null;\n-\n-    /**\n-     * Constructor. Supply variable name and type.\n-     */\n-    public Variable(String name, Class type) {\n-        _name = name;\n-        _type = type;\n-    }\n-\n-    /**\n-     * Return the variable name.\n-     */\n-    public String getName() {\n-        return _name;\n-    }\n-\n-    /**\n-     * Return true if the variable is bound.\n-     */\n-    public boolean isBound() {\n-        return _path != null;\n-    }\n-\n-    /**\n-     * Return the path this variable is aliased to.\n-     */\n-    public PCPath getPCPath() {\n-        return _path;\n-    }\n-\n-    /**\n-     * Set the path this variable is aliased to.\n-     */\n-    public void setPCPath(PCPath path) {\n-        _path = path;\n-    }\n-\n-    public ClassMetaData getMetaData() {\n-        return _meta;\n-    }\n-\n-    public void setMetaData(ClassMetaData meta) {\n-        _meta = meta;\n-    }\n-\n-    public boolean isVariable() {\n-        return true;\n-    }\n-\n-    public Class getType() {\n-        if (_cast != null)\n-            return _cast;\n-        return _type;\n-    }\n-\n-    public void setImplicitType(Class type) {\n-        _cast = type;\n-        if (_path != null)\n-            _path.setImplicitType(type);\n-    }\n-\n-    public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n-        if (_path != null) {\n-            _path.addVariableAction(this);\n-            return _path.initialize(sel, ctx, flags | JOIN_REL);\n-        }\n-        return ExpState.NULL;\n-    }\n-\n-    public void select(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-    }\n-\n-    public void selectColumns(Select sel, ExpContext ctx, ExpState state, \n-        boolean pks) {\n-    }\n-\n-    public void groupBy(Select sel, ExpContext ctx, ExpState state) {\n-    }\n-\n-    public void orderBy(Select sel, ExpContext ctx, ExpState state, \n-        boolean asc) {\n-    }\n-\n-    public Object load(ExpContext ctx, ExpState state, Result res)\n-        throws SQLException {\n-        return null;\n-    }\n-\n-    public void calculateValue(Select sel, ExpContext ctx, ExpState state, \n-        Val other, ExpState otherState) {\n-        if (_path != null)\n-            _path.calculateValue(sel, ctx, state, other, otherState);\n-    }\n-\n-    public int length(Select sel, ExpContext ctx, ExpState state) {\n-        return 0;\n-    }\n-\n-    public void appendTo(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer sql, int index) {\n-    }\n-\n-    public void appendIsEmpty(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf) {\n-    }\n-\n-    public void appendIsNotEmpty(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf) {\n-    }\n-\n-    public void appendSize(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf) {\n-    }\n-\n-    public void appendIsNull(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf) {\n-    }\n-\n-    public void appendIsNotNull(Select sel, ExpContext ctx, ExpState state, \n-        SQLBuffer buf) {\n-    }\n-\n-    public void acceptVisit(ExpressionVisitor visitor) {\n-        visitor.enter(this);\n-        if (_path != null)\n-            _path.acceptVisit(visitor);\n-        visitor.exit(this);\n-    }\n-}"},{"sha":"d23684d1492bc34e42b09bf6f1830eb1c62590ec","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/package.html","status":"removed","additions":0,"deletions":23,"changes":23,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/package.html","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/package.html?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,23 +0,0 @@\n-<!--\n- Licensed to the Apache Software Foundation (ASF) under one\n- or more contributor license agreements.  See the NOTICE file\n- distributed with this work for additional information\n- regarding copyright ownership.  The ASF licenses this file\n- to you under the Apache License, Version 2.0 (the\n- \"License\"); you may not use this file except in compliance\n- with the License.  You may obtain a copy of the License at\n- \n- http://www.apache.org/licenses/LICENSE-2.0\n- \n- Unless required by applicable law or agreed to in writing,\n- software distributed under the License is distributed on an\n- \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- KIND, either express or implied.  See the License for the\n- specific language governing permissions and limitations\n- under the License.   \n--->\n-<html>\n-<body>\n-<p><strong>OpenJPA-JDBC Expression Tree</strong></p>\n-</body>\n-</html>"},{"sha":"a4157d2c2a236906c7142406ac9dd65c60ae00f4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/package.html","status":"removed","additions":0,"deletions":27,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/package.html","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/package.html?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,27 +0,0 @@\n-<!--\n- Licensed to the Apache Software Foundation (ASF) under one\n- or more contributor license agreements.  See the NOTICE file\n- distributed with this work for additional information\n- regarding copyright ownership.  The ASF licenses this file\n- to you under the Apache License, Version 2.0 (the\n- \"License\"); you may not use this file except in compliance\n- with the License.  You may obtain a copy of the License at\n- \n- http://www.apache.org/licenses/LICENSE-2.0\n- \n- Unless required by applicable law or agreed to in writing,\n- software distributed under the License is distributed on an\n- \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- KIND, either express or implied.  See the License for the\n- specific language governing permissions and limitations\n- under the License.   \n--->\n-<html>\n-<body>\n-<p><strong>OpenJPA-JDBC Runtime Kernel</strong></p>\n-\n-<p>\n-    Runtime services for the JDBC OpenJPA implementation.\n-</p>\n-</body>\n-</html>"},{"sha":"7fa96960795016f02afb8b63a492968207360625","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","status":"removed","additions":0,"deletions":1090,"changes":1090,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,1090 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.sql.SQLException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import org.apache.openjpa.enhance.PersistenceCapable;\n-import org.apache.openjpa.enhance.Reflection;\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.meta.strats.NoneClassStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.RelationFieldStrategy;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ColumnIO;\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\n-import org.apache.openjpa.jdbc.schema.Schemas;\n-import org.apache.openjpa.jdbc.schema.Table;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.RowManager;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.FetchConfiguration;\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\n-import org.apache.openjpa.kernel.PCState;\n-import org.apache.openjpa.lib.log.Log;\n-import org.apache.openjpa.lib.rop.ResultObjectProvider;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.meta.ValueMetaData;\n-import org.apache.openjpa.util.ApplicationIds;\n-import org.apache.openjpa.util.InternalException;\n-import org.apache.openjpa.util.MetaDataException;\n-import org.apache.openjpa.util.OpenJPAId;\n-import org.apache.openjpa.util.ImplHelper;\n-\n-/**\n- * Specialization of metadata for relational databases.\n- *\n- * @author Abe White\n- */\n-public class ClassMapping\n-    extends ClassMetaData\n-    implements ClassStrategy {\n-\n-    public static final ClassMapping[] EMPTY_MAPPINGS = new ClassMapping[0];\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (ClassMapping.class);\n-\n-    private final ClassMappingInfo _info;\n-    private final Discriminator _discrim;\n-    private final Version _version;\n-    private ClassStrategy _strategy = null;\n-\n-    private Table _table = null;\n-    private ColumnIO _io = null;\n-    private Column[] _cols = Schemas.EMPTY_COLUMNS;\n-    private ForeignKey _fk = null;\n-    private int _subclassMode = Integer.MAX_VALUE;\n-\n-    private ClassMapping[] _joinSubMaps = null;\n-    private ClassMapping[] _assignMaps = null;\n-\n-    // maps columns to joinables\n-    private final Map _joinables = Collections.synchronizedMap(new HashMap());\n-    private boolean redoPrimaryKeyColumns = false;\n-\n-    /**\n-     * Constructor. Supply described type and owning repository.\n-     */\n-    protected ClassMapping(Class type, MappingRepository repos) {\n-        super(type, repos);\n-        _discrim = repos.newDiscriminator(this);\n-        _version = repos.newVersion(this);\n-        _info = repos.newMappingInfo(this);\n-    }\n-\n-    /**\n-     * Embedded constructor. Supply embedding value and owning repository.\n-     */\n-    protected ClassMapping(ValueMetaData vmd) {\n-        super(vmd);\n-        _discrim = getMappingRepository().newDiscriminator(this);\n-        _version = getMappingRepository().newVersion(this);\n-        _info = getMappingRepository().newMappingInfo(this);\n-    }\n-\n-    /**\n-     * The class discriminator.\n-     */\n-    public Discriminator getDiscriminator() {\n-        return _discrim;\n-    }\n-\n-    /**\n-     * The version indicator.\n-     */\n-    public Version getVersion() {\n-        return _version;\n-    }\n-\n-    ///////////\n-    // Runtime\n-    ///////////\n-\n-    /**\n-     * Return the oid value stored in the result. This implementation will\n-     * recurse until it finds an ancestor class who uses oid values for its\n-     * primary key.\n-     *\n-     * @param fk if non-null, use the local columns of the given foreign\n-     * key in place of this class' primary key columns\n-     * @see #isPrimaryKeyObjectId\n-     */\n-    public Object getObjectId(JDBCStore store, Result res, ForeignKey fk,\n-        boolean subs, Joins joins)\n-        throws SQLException {\n-        ValueMapping embed = getEmbeddingMapping();\n-        if (embed != null)\n-            return embed.getFieldMapping().getDefiningMapping().\n-                getObjectId(store, res, fk, subs, joins);\n-\n-        return getObjectId(this, store, res, fk, subs, joins);\n-    }\n-\n-    /**\n-     * Recursive helper for public <code>getObjectId</code> method.\n-     */\n-    private Object getObjectId(ClassMapping cls, JDBCStore store, Result res,\n-        ForeignKey fk, boolean subs, Joins joins)\n-        throws SQLException {\n-        if (!isPrimaryKeyObjectId(true))\n-            return getPCSuperclassMapping().getObjectId(cls, store, res, fk,\n-                subs, joins);\n-        if (getIdentityType() == ID_UNKNOWN)\n-            throw new InternalException();\n-\n-        Column[] pks = getPrimaryKeyColumns();\n-        if (getIdentityType() == ID_DATASTORE) {\n-            Column col = (fk == null) ? pks[0] : fk.getColumn(pks[0]);\n-            long id = res.getLong(col, joins);\n-            return (id == 0 && res.wasNull()) ? null\n-                : store.newDataStoreId(id, cls, subs);\n-        }\n-\n-        // application identity\n-        Object[] vals = new Object[getPrimaryKeyFields().length];\n-        FieldMapping fm;\n-        Joinable join;\n-        int pkIdx;\n-        for (int i = 0; i < pks.length; i++) {\n-            // we know that all pk column join mappings use primary key fields,\n-            // cause this mapping uses the oid as its primary key (we recursed\n-            // at the beginning of the method to ensure this)\n-            join = assertJoinable(pks[i]);\n-            fm = getFieldMapping(join.getFieldIndex());\n-            pkIdx = fm.getPrimaryKeyIndex();\n-\n-            // could have already set value with previous multi-column joinable\n-            if (vals[pkIdx] == null) {\n-                res.startDataRequest(fm);\n-                vals[pkIdx] = join.getPrimaryKeyValue(res, join.getColumns(),\n-                    fk, store, joins);\n-                res.endDataRequest();\n-                if (vals[pkIdx] == null)\n-                    return null;\n-            }\n-        }\n-\n-        // the oid data is loaded by the base type, but if discriminator data\n-        // is present, make sure to use it to construct the actual oid instance\n-        // so that we get the correct app id class, etc\n-        ClassMapping dcls = cls;\n-        if (subs) {\n-            res.startDataRequest(cls.getDiscriminator());\n-            try {\n-                Class dtype = cls.getDiscriminator().getClass(store, cls, res);\n-                if (dtype != cls.getDescribedType())\n-                  dcls = cls.getMappingRepository().getMapping(dtype, \n-                    store.getContext().getClassLoader(), true); \n-            } catch (Exception e) {\n-                // intentionally ignored\n-            }\n-            res.endDataRequest();  \n-        }\n-        Object oid = ApplicationIds.fromPKValues(vals, dcls);\n-        if (oid instanceof OpenJPAId) {\n-            ((OpenJPAId) oid).setManagedInstanceType(dcls.getDescribedType(), \n-                subs);\n-        }\n-        return oid;\n-    }\n-\n-    /**\n-     * Return the given column value(s) for the given object. The given\n-     * columns will be primary key columns of this mapping, but may be in\n-     * any order. If there is only one column, return its value. If there\n-     * are multiple columns, return an object array of their values, in the\n-     * same order the columns are given.\n-     */\n-    public Object toDataStoreValue(Object obj, Column[] cols, JDBCStore store) {\n-        Object ret = (cols.length == 1) ? null : new Object[cols.length];\n-\n-        // in the past we've been lenient about being able to translate objects\n-        // from other persistence contexts, so try to get sm directly from\n-        // instance before asking our context\n-        OpenJPAStateManager sm;\n-        if (ImplHelper.isManageable(obj)) {\n-        \tPersistenceCapable pc = ImplHelper.toPersistenceCapable(obj,\n-                    getRepository().getConfiguration());\n-            sm = (OpenJPAStateManager) pc.pcGetStateManager();\n-            if (sm == null) {\n-            \tret = getValueFromUnmanagedInstance(obj, cols, true);\n-            } else if (sm.isDetached()) {\n-            \tobj = store.getContext().find(sm.getObjectId(), false, null);\n-            \tsm = store.getContext().getStateManager(obj);\n-            }\n-        } else {\n-            sm = store.getContext().getStateManager(obj);\n-        }\n-        if (sm == null)\n-            return ret;\n-\n-        Object val;\n-        for (int i = 0; i < cols.length; i++) {\n-            val = assertJoinable(cols[i]).getJoinValue(sm, cols[i], store);\n-            if (cols.length == 1)\n-                ret = val;\n-            else\n-                ((Object[]) ret)[i] = val;\n-        }\n-        return ret;\n-    }\n-    \n-    /**\n-     * Return the joinable for the given column, or throw an exception if\n-     * none is available.\n-     */\n-    public Joinable assertJoinable(Column col) {\n-        Joinable join = getJoinable(col);\n-        if (join == null)\n-            throw new MetaDataException(_loc.get(\"no-joinable\",\n-                col.getFullName()));\n-        return join;\n-    }\n-\n-    /**\n-     * Return the {@link Joinable} for the given column. Any column that\n-     * another mapping joins to must be controlled by a joinable.\n-     */\n-    public Joinable getJoinable(Column col) {\n-        Joinable join;\n-        if (getEmbeddingMetaData() != null) {\n-            join = getEmbeddingMapping().getFieldMapping().\n-                getDefiningMapping().getJoinable(col);\n-            if (join != null)\n-                return join;\n-        }\n-        ClassMapping sup = getJoinablePCSuperclassMapping();\n-        if (sup != null) {\n-            join = sup.getJoinable(col);\n-            if (join != null)\n-                return join;\n-        }\n-        return (Joinable) _joinables.get(col);\n-    }\n-\n-    /**\n-     * Add the given column-to-joinable mapping.\n-     */\n-    public void setJoinable(Column col, Joinable joinable) {\n-        // don't let non-pk override pk\n-        Joinable join = (Joinable) _joinables.get(col);\n-        if (join == null || (join.getFieldIndex() != -1\n-            && getField(join.getFieldIndex()).getPrimaryKeyIndex() == -1))\n-            _joinables.put(col, joinable);\n-    }\n-\n-    /**\n-     * Return whether the columns of the given foreign key to this mapping\n-     * can be used to construct an object id for this type. This is a\n-     * relatively expensive operation; its results should be cached.\n-     *\n-     * @return {@link Boolean#TRUE} if the foreign key contains all oid\n-     * columns, <code>null</code> if it contains only some columns,\n-     * or {@link Boolean#FALSE} if it contains non-oid columns\n-     */\n-    public Boolean isForeignKeyObjectId(ForeignKey fk) {\n-        // if this mapping's primary key can't construct an oid, then no way\n-        // foreign key can\n-        if (getIdentityType() == ID_UNKNOWN || !isPrimaryKeyObjectId(false))\n-            return Boolean.FALSE;\n-\n-        // with datastore identity, it's all or nothing\n-        Column[] cols = fk.getPrimaryKeyColumns();\n-        if (getIdentityType() == ID_DATASTORE) {\n-            if (cols.length != 1 || cols[0] != getPrimaryKeyColumns()[0])\n-                return Boolean.FALSE;\n-            return Boolean.TRUE;\n-        }\n-\n-        // check the join mapping for each pk column to see if it links up to\n-        // a primary key field\n-        Joinable join;\n-        for (int i = 0; i < cols.length; i++) {\n-            join = assertJoinable(cols[i]);\n-            if (join.getFieldIndex() != -1\n-                && getField(join.getFieldIndex()).getPrimaryKeyIndex() == -1)\n-                return Boolean.FALSE;\n-        }\n-\n-        // if all primary key links, see whether we join to all pks\n-        if (isPrimaryKeyObjectId(true)\n-            && cols.length == getPrimaryKeyColumns().length)\n-            return Boolean.TRUE;\n-        return null;\n-    }\n-\n-    ///////\n-    // ORM\n-    ///////\n-\n-    /**\n-     * Raw mapping data.\n-     */\n-    public ClassMappingInfo getMappingInfo() {\n-        return _info;\n-    }\n-\n-    /**\n-     * The strategy used to map this mapping.\n-     */\n-    public ClassStrategy getStrategy() {\n-        return _strategy;\n-    }\n-\n-    /**\n-     * The strategy used to map this mapping. The <code>adapt</code>\n-     * parameter determines whether to adapt when mapping the strategy;\n-     * use null if the strategy should not be mapped.\n-     */\n-    public void setStrategy(ClassStrategy strategy, Boolean adapt) {\n-        // set strategy first so we can access it during mapping\n-        ClassStrategy orig = _strategy;\n-        _strategy = strategy;\n-        if (strategy != null) {\n-            try {\n-                strategy.setClassMapping(this);\n-                if (adapt != null)\n-                    strategy.map(adapt.booleanValue());\n-            } catch (RuntimeException re) {\n-                // reset strategy\n-                _strategy = orig;\n-                throw re;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * The mapping's primary table.\n-     */\n-    public Table getTable() {\n-        return _table;\n-    }\n-\n-    /**\n-     * The mapping's primary table.\n-     */\n-    public void setTable(Table table) {\n-        _table = table;\n-    }\n-\n-    /**\n-     * The columns this mapping uses to uniquely identify an object.\n-     * These will typically be the primary key columns or the columns this\n-     * class uses to link to its superclass table.\n-     */\n-    public Column[] getPrimaryKeyColumns() {\n-        if (getIdentityType() == ID_APPLICATION && isMapped()) {\n-            if (_cols.length == 0 || redoPrimaryKeyColumns) {            \n-                FieldMapping[] pks = getPrimaryKeyFieldMappings();\n-                Collection cols = new ArrayList(pks.length);\n-                Column[] fieldCols;\n-                for (int i = 0; i < pks.length; i++) {\n-                    fieldCols = pks[i].getColumns();\n-                    if (fieldCols.length == 0) {\n-                        // some pk columns depends on fk. At this moment, \n-                        // the fk may not contain complete information.\n-                        // need to redo the primary key again later on\n-                        redoPrimaryKeyColumns = true;\n-                        continue;\n-                    }\n-                    for (int j = 0; j < fieldCols.length; j++)\n-                        cols.add(fieldCols[j]);\n-                }\n-                _cols = (Column[]) cols.toArray(new Column[cols.size()]);\n-            }\n-        }\n-        return _cols;\n-    }\n-\n-    /**\n-     * The columns this mapping uses to uniquely identify an object.\n-     * These will typically be the primary key columns or the columns this\n-     * class uses to link to its superclass table.\n-     */\n-    public void setPrimaryKeyColumns(Column[] cols) {\n-        if (cols == null)\n-            cols = Schemas.EMPTY_COLUMNS;\n-        _cols = cols;\n-    }\n-\n-    /**\n-     * I/O information on the key columns / join key.\n-     */\n-    public ColumnIO getColumnIO() {\n-        return (_io == null) ? ColumnIO.UNRESTRICTED : _io;\n-    }\n-\n-    /**\n-     * I/O information on the key columns / join key.\n-     */\n-    public void setColumnIO(ColumnIO io) {\n-        _io = io;\n-    }\n-\n-    /**\n-     * Foreign key linking the primary key columns to the superclass table,\n-     * or null if none.\n-     */\n-    public ForeignKey getJoinForeignKey() {\n-        return _fk;\n-    }\n-\n-    /**\n-     * Foreign key linking the primary key columns to the superclass table,\n-     * or null if none.\n-     */\n-    public void setJoinForeignKey(ForeignKey fk) {\n-        _fk = fk;\n-    }\n-\n-    public void refSchemaComponents() {\n-        if (getEmbeddingMetaData() == null) {\n-            if (_table != null && _table.getPrimaryKey() != null)\n-                _table.getPrimaryKey().ref();\n-            if (_fk != null)\n-                _fk.ref();\n-            Column[] pks = getPrimaryKeyColumns();\n-            for (int i = 0; i < pks.length; i++)\n-                pks[i].ref();\n-        } else {\n-            FieldMapping[] fields = getFieldMappings();\n-            for (int i = 0; i < fields.length; i++)\n-                fields[i].refSchemaComponents();\n-        }\n-    }\n-\n-    /**\n-     * Clear mapping information, including strategy.\n-     */\n-    public void clearMapping() {\n-        _strategy = null;\n-        _cols = Schemas.EMPTY_COLUMNS;\n-        _fk = null;\n-        _table = null;\n-        _info.clear();\n-        setResolve(MODE_MAPPING | MODE_MAPPING_INIT, false);\n-    }\n-\n-    /**\n-     * Update {@link MappingInfo} with our current mapping information.\n-     */\n-    public void syncMappingInfo() {\n-        if (getEmbeddingMetaData() == null)\n-            _info.syncWith(this);\n-        else {\n-            _info.clear();\n-            FieldMapping[] fields = getFieldMappings();\n-            for (int i = 0; i < fields.length; i++)\n-                fields[i].syncMappingInfo();\n-        }\n-    }\n-\n-    //////////////////////\n-    // MetaData interface\n-    //////////////////////\n-\n-    protected void setDescribedType(Class type) {\n-        super.setDescribedType(type);\n-        // this method called from superclass constructor, so _info not yet\n-        // initialized\n-        if (_info != null)\n-            _info.setClassName(type.getName());\n-    }\n-\n-    /**\n-     * The subclass fetch mode, as one of the eager constants in\n-     * {@link JDBCFetchConfiguration}.\n-     */\n-    public int getSubclassFetchMode() {\n-        if (_subclassMode == Integer.MAX_VALUE) {\n-            if (getPCSuperclass() != null)\n-                _subclassMode = getPCSuperclassMapping().\n-                    getSubclassFetchMode();\n-            else\n-                _subclassMode = FetchConfiguration.DEFAULT;\n-        }\n-        return _subclassMode;\n-    }\n-\n-    /**\n-     * The subclass fetch mode, as one of the eager constants in\n-     * {@link JDBCFetchConfiguration}.\n-     */\n-    public void setSubclassFetchMode(int mode) {\n-        _subclassMode = mode;\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link ClassMetaData#getRepository}.\n-     */\n-    public MappingRepository getMappingRepository() {\n-        return (MappingRepository) getRepository();\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link ClassMetaData#getEmbeddingMetaData}\n-     */\n-    public ValueMapping getEmbeddingMapping() {\n-        return (ValueMapping) getEmbeddingMetaData();\n-    }\n-\n-    /**\n-     * Returns true if this class does not use the \"none\" strategy (including\n-     * if it has a null strategy, and therefore is probably in the process of\n-     * being mapped).\n-     */\n-    public boolean isMapped() {\n-        if (!super.isMapped())\n-            return false;\n-        if (_strategy != null)\n-            return _strategy != NoneClassStrategy.getInstance();\n-        return !NoneClassStrategy.ALIAS.equals(_info.getStrategy());\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link ClassMetaData#getPCSuperclassMetaData}.\n-     */\n-    public ClassMapping getPCSuperclassMapping() {\n-        return (ClassMapping) getPCSuperclassMetaData();\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link ClassMetaData#getMappedPCSuperclassMetaData}.\n-     */\n-    public ClassMapping getMappedPCSuperclassMapping() {\n-        return (ClassMapping) getMappedPCSuperclassMetaData();\n-    }\n-\n-    /**\n-     * Return the nearest mapped superclass that can join to this class.\n-     */\n-    public ClassMapping getJoinablePCSuperclassMapping() {\n-        ClassMapping sup = getMappedPCSuperclassMapping();\n-        if (sup == null)\n-            return null;\n-        if (_fk != null || _table == null || _table.equals(sup.getTable()))\n-            return sup;\n-        return null;\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link ClassMetaData#getPCSubclassMetaDatas}.\n-     */\n-    public ClassMapping[] getPCSubclassMappings() {\n-        return (ClassMapping[]) getPCSubclassMetaDatas();\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link ClassMetaData#getMappedPCSubclassMetaDatas}.\n-     */\n-    public ClassMapping[] getMappedPCSubclassMappings() {\n-        return (ClassMapping[]) getMappedPCSubclassMetaDatas();\n-    }\n-\n-    /**\n-     * Return mapped subclasses that are reachable via joins.\n-     */\n-    public ClassMapping[] getJoinablePCSubclassMappings() {\n-        ClassMapping[] subs = getMappedPCSubclassMappings(); // checks for new\n-        if (_joinSubMaps == null) {\n-            if (subs.length == 0)\n-                _joinSubMaps = subs;\n-            else {\n-                List joinable = new ArrayList(subs.length);\n-                for (int i = 0; i < subs.length; i++)\n-                    if (isSubJoinable(subs[i]))\n-                        joinable.add(subs[i]);\n-                _joinSubMaps = (ClassMapping[]) joinable.toArray\n-                    (new ClassMapping[joinable.size()]);\n-            }\n-        }\n-        return _joinSubMaps;\n-    }\n-\n-    /**\n-     * Return whether we can reach the given subclass via joins.\n-     */\n-    private boolean isSubJoinable(ClassMapping sub) {\n-        if (sub == null)\n-            return false;\n-        if (sub == this)\n-            return true;\n-        return isSubJoinable(sub.getJoinablePCSuperclassMapping());\n-    }\n-\n-    /**\n-     * Returns the closest-derived list of non-inter-joinable mapped types\n-     * assignable to this type. May return this mapping.\n-     */\n-    public ClassMapping[] getIndependentAssignableMappings() {\n-        ClassMapping[] subs = getMappedPCSubclassMappings(); // checks for new\n-        if (_assignMaps == null) {\n-            // remove unmapped subs\n-            if (subs.length == 0) {\n-                if (isMapped())\n-                    _assignMaps = new ClassMapping[]{ this };\n-                else\n-                    _assignMaps = subs;\n-            } else {\n-                int size = (int) (subs.length * 1.33 + 2);\n-                Set independent = new LinkedHashSet(size);\n-                if (isMapped())\n-                    independent.add(this);\n-                independent.addAll(Arrays.asList(subs));\n-\n-                // remove all mappings that have a superclass mapping in the set\n-                ClassMapping map, sup;\n-                List clear = null;\n-                for (Iterator itr = independent.iterator(); itr.hasNext();) {\n-                    map = (ClassMapping) itr.next();\n-                    sup = map.getJoinablePCSuperclassMapping();\n-                    if (sup != null && independent.contains(sup)) {\n-                        if (clear == null)\n-                            clear = new ArrayList(independent.size() - 1);\n-                        clear.add(map);\n-                    }\n-                }\n-                if (clear != null)\n-                    independent.removeAll(clear);\n-\n-                _assignMaps = (ClassMapping[]) independent.toArray\n-                    (new ClassMapping[independent.size()]);\n-            }\n-        }\n-        return _assignMaps;\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from {@link ClassMetaData#getFields}.\n-     */\n-    public FieldMapping[] getFieldMappings() {\n-        return (FieldMapping[]) getFields();\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link ClassMetaData#getDeclaredFields}.\n-     */\n-    public FieldMapping[] getDeclaredFieldMappings() {\n-        return (FieldMapping[]) getDeclaredFields();\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link ClassMetaData#getPrimaryKeyFields}.\n-     */\n-    public FieldMapping[] getPrimaryKeyFieldMappings() {\n-        return (FieldMapping[]) getPrimaryKeyFields();\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link ClassMetaData#getVersionField}.\n-     */\n-    public FieldMapping getVersionFieldMapping() {\n-        return (FieldMapping) getVersionField();\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link ClassMetaData#getDefaultFetchGroupFields}.\n-     */\n-    public FieldMapping[] getDefaultFetchGroupFieldMappings() {\n-        return (FieldMapping[]) getDefaultFetchGroupFields();\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link ClassMetaData#getDefinedFields}.\n-     */\n-    public FieldMapping[] getDefinedFieldMappings() {\n-        return (FieldMapping[]) getDefinedFields();\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link ClassMetaData#getFieldsInListingOrder}.\n-     */\n-    public FieldMapping[] getFieldMappingsInListingOrder() {\n-        return (FieldMapping[]) getFieldsInListingOrder();\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link ClassMetaData#getDefinedFieldsInListingOrder}.\n-     */\n-    public FieldMapping[] getDefinedFieldMappingsInListingOrder() {\n-        return (FieldMapping[]) getDefinedFieldsInListingOrder();\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from {@link ClassMetaData#getField}.\n-     */\n-    public FieldMapping getFieldMapping(int index) {\n-        return (FieldMapping) getField(index);\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link ClassMetaData#getDeclaredField}.\n-     */\n-    public FieldMapping getDeclaredFieldMapping(int index) {\n-        return (FieldMapping) getDeclaredField(index);\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from {@link ClassMetaData#getField}.\n-     */\n-    public FieldMapping getFieldMapping(String name) {\n-        return (FieldMapping) getField(name);\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link ClassMetaData#getDeclaredField}.\n-     */\n-    public FieldMapping getDeclaredFieldMapping(String name) {\n-        return (FieldMapping) getDeclaredField(name);\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link ClassMetaData#getDeclaredUnmanagedFields}.\n-     */\n-    public FieldMapping[] getDeclaredUnmanagedFieldMappings() {\n-        return (FieldMapping[]) getDeclaredUnmanagedFields();\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link ClassMetaData#addDeclaredField}.\n-     */\n-    public FieldMapping addDeclaredFieldMapping(String name, Class type) {\n-        return (FieldMapping) addDeclaredField(name, type);\n-    }\n-\n-    protected void resolveMapping(boolean runtime) {\n-        super.resolveMapping(runtime);\n-\n-        // map class strategy; it may already be mapped by the repository before\n-        // the resolve process begins\n-        MappingRepository repos = getMappingRepository();\n-        if (_strategy == null)\n-            repos.getStrategyInstaller().installStrategy(this);\n-        Log log = getRepository().getLog();\n-        if (log.isTraceEnabled())\n-            log.trace(_loc.get(\"strategy\", this, _strategy.getAlias()));\n-\n-        // make sure unmapped superclass fields are defined if we're mapped;\n-        // also may have been done by repository already\n-        defineSuperclassFields(getJoinablePCSuperclassMapping() == null);\n-\n-        // resolve everything that doesn't rely on any relations to avoid\n-        // recursion, then resolve all fields\n-        resolveNonRelationMappings();\n-        FieldMapping[] fms = getFieldMappings();\n-        for (int i = 0; i < fms.length; i++) {\n-            if (fms[i].getDefiningMetaData() == this) {\n-                if (fms[i].getForeignKey() != null &&\n-                    fms[i].getStrategy() instanceof RelationFieldStrategy) {\n-                    // set resolve mode to force this field mapping to be \n-                    // resolved again. The need to resolve again occurs when \n-                    // a primary key is a relation field with the foreign key\n-                    // annotation. In this situation, this primary key field\n-                    // mapping is resolved during the call to \n-                    // resolveNonRelationMapping. Since it is a relation\n-                    // field, the foreign key will be constructed. However, \n-                    // the primary key of the parent entity may not have been \n-                    // resolved yet, resulting in missing informaiton in the fk\n-                    fms[i].setResolve(MODE_META); \n-\n-                    // set strategy to null to force fk to be re-constructed\n-                    fms[i].setStrategy(null, false); \n-                }                \n-                fms[i].resolve(MODE_MAPPING);\n-            }\n-        }\n-        fms = getDeclaredUnmanagedFieldMappings();\n-        for (int i = 0; i < fms.length; i++)\n-            fms[i].resolve(MODE_MAPPING);\n-\n-        // mark mapped columns\n-        if (_cols != null) {\n-            ColumnIO io = getColumnIO();\n-            for (int i = 0; i < _cols.length; i++) {\n-                if (io.isInsertable(i, false))\n-                    _cols[i].setFlag(Column.FLAG_DIRECT_INSERT, true);\n-                if (io.isUpdatable(i, false))\n-                    _cols[i].setFlag(Column.FLAG_DIRECT_UPDATE, true);\n-            }\n-        }\n-        // once columns are resolved, resolve unique constraints as they need\n-        // the columns be resolved \n-        _info.getUniques(this, true);\n-    }\n-    \n-    /**\n-     * Resolve non-relation field mappings so that when we do relation\n-     * mappings they can rely on them for joins.\n-     */\n-    void resolveNonRelationMappings() {\n-        // make sure primary key fields are resolved first because other\n-        // fields might rely on them\n-        FieldMapping[] fms = getPrimaryKeyFieldMappings();\n-        for (int i = 0; i < fms.length; i++)\n-            fms[i].resolve(MODE_MAPPING);\n-\n-        // resolve defined fields that are safe; that don't rely on other types\n-        // also being resolved.  don't use getDefinedFields b/c it relies on\n-        // whether fields are mapped, which isn't known yet\n-        fms = getFieldMappings();\n-        for (int i = 0; i < fms.length; i++)\n-            if (fms[i].getDefiningMetaData() == this\n-                && !fms[i].isTypePC() && !fms[i].getKey().isTypePC()\n-                && !fms[i].getElement().isTypePC())\n-                fms[i].resolve(MODE_MAPPING);\n-\n-        _discrim.resolve(MODE_MAPPING);\n-        _version.resolve(MODE_MAPPING);        \n-    }\n-\n-    protected void initializeMapping() {\n-        super.initializeMapping();\n-\n-        FieldMapping[] fields = getDefinedFieldMappings();\n-        for (int i = 0; i < fields.length; i++)\n-            fields[i].resolve(MODE_MAPPING_INIT);\n-        _discrim.resolve(MODE_MAPPING_INIT);\n-        _version.resolve(MODE_MAPPING_INIT);\n-        _strategy.initialize();\n-    }\n-\n-    protected void clearDefinedFieldCache() {\n-        // just make this method available to other classes in this package\n-        super.clearDefinedFieldCache();\n-    }\n-\n-    protected void clearSubclassCache() {\n-        super.clearSubclassCache();\n-        _joinSubMaps = null;\n-        _assignMaps = null;\n-    }\n-\n-    public void copy(ClassMetaData cls) {\n-        super.copy(cls);\n-        if (_subclassMode == Integer.MAX_VALUE)\n-            _subclassMode = ((ClassMapping) cls).getSubclassFetchMode();\n-    }\n-\n-    protected boolean validateDataStoreExtensionPrefix(String prefix) {\n-        return \"jdbc-\".equals(prefix);\n-    }\n-\n-    ////////////////////////////////\n-    // ClassStrategy implementation\n-    ////////////////////////////////\n-\n-    public String getAlias() {\n-        return assertStrategy().getAlias();\n-    }\n-\n-    public void map(boolean adapt) {\n-        assertStrategy().map(adapt);\n-    }\n-\n-    public void initialize() {\n-        assertStrategy().initialize();\n-    }\n-\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n-        throws SQLException {\n-        assertStrategy().insert(sm, store, rm);\n-    }\n-\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n-        throws SQLException {\n-        assertStrategy().update(sm, store, rm);\n-    }\n-\n-    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n-        throws SQLException {\n-        assertStrategy().delete(sm, store, rm);\n-    }\n-\n-    public Boolean isCustomInsert(OpenJPAStateManager sm, JDBCStore store) {\n-        return assertStrategy().isCustomInsert(sm, store);\n-    }\n-\n-    public Boolean isCustomUpdate(OpenJPAStateManager sm, JDBCStore store) {\n-        return assertStrategy().isCustomUpdate(sm, store);\n-    }\n-\n-    public Boolean isCustomDelete(OpenJPAStateManager sm, JDBCStore store) {\n-        return assertStrategy().isCustomDelete(sm, store);\n-    }\n-\n-    public void customInsert(OpenJPAStateManager sm, JDBCStore store)\n-        throws SQLException {\n-        assertStrategy().customInsert(sm, store);\n-    }\n-\n-    public void customUpdate(OpenJPAStateManager sm, JDBCStore store)\n-        throws SQLException {\n-        assertStrategy().customUpdate(sm, store);\n-    }\n-\n-    public void customDelete(OpenJPAStateManager sm, JDBCStore store)\n-        throws SQLException {\n-        assertStrategy().customDelete(sm, store);\n-    }\n-\n-    public void setClassMapping(ClassMapping owner) {\n-        assertStrategy().setClassMapping(owner);\n-    }\n-\n-    public boolean isPrimaryKeyObjectId(boolean hasAll) {\n-        return assertStrategy().isPrimaryKeyObjectId(hasAll);\n-    }\n-\n-    public Joins joinSuperclass(Joins joins, boolean toThis) {\n-        return assertStrategy().joinSuperclass(joins, toThis);\n-    }\n-\n-    public boolean supportsEagerSelect(Select sel, OpenJPAStateManager sm,\n-        JDBCStore store, ClassMapping base, JDBCFetchConfiguration fetch) {\n-        return assertStrategy().supportsEagerSelect(sel, sm, store, base,\n-            fetch);\n-    }\n-\n-    public ResultObjectProvider customLoad(JDBCStore store, boolean subclasses,\n-        JDBCFetchConfiguration fetch, long startIdx, long endIdx)\n-        throws SQLException {\n-        return assertStrategy().customLoad(store, subclasses, fetch,\n-            startIdx, endIdx);\n-    }\n-\n-    public boolean customLoad(OpenJPAStateManager sm, JDBCStore store,\n-        PCState state, JDBCFetchConfiguration fetch)\n-        throws SQLException, ClassNotFoundException {\n-        return assertStrategy().customLoad(sm, store, state, fetch);\n-    }\n-\n-    public boolean customLoad(OpenJPAStateManager sm, JDBCStore store,\n-        JDBCFetchConfiguration fetch, Result result)\n-        throws SQLException {\n-        return assertStrategy().customLoad(sm, store, fetch, result);\n-    }\n-    \n-    private ClassStrategy assertStrategy() {\n-        if (_strategy == null)\n-            throw new InternalException();\n-        return _strategy;\n-    }\n-    \n-    /**\n-     * Find the field mappings that correspond to the given columns.\n-     * \n-     * @return null if no columns are given or no field mapping uses the given\n-     * columns.\n-     */\n-    private List<FieldMapping> getFieldMappings(Column[] cols, boolean prime) {\n-    \tif (cols == null || cols.length == 0)\n-    \t\treturn null;\n-    \tList<FieldMapping> result = null;\n-    \tfor (Column c : cols) {\n-    \t\tList<FieldMapping> fms = hasColumn(c, prime);\n-    \t\tif (fms == null) continue;\n-\t\t\tif (result == null)\n-\t\t\t\tresult = new ArrayList<FieldMapping>();\n-\t\t\tfor (FieldMapping fm : fms)\n-\t\t\t\tif (!result.contains(fm))\n-\t\t\t\t\tresult.add(fm);\n-    \t}\n-    \treturn result;\n-    }\n-    \n-    /**\n-     * Looks up in reverse to find the list of field mappings that include the\n-     * given column. Costly.\n-     * \n-     * @return null if no field mappings carry this column. \n-     */\n-    private List<FieldMapping> hasColumn(Column c, boolean prime) {\n-    \tList<FieldMapping> result = null;\n-    \tFieldMapping[] fms = (prime) ? \n-    \t\tgetPrimaryKeyFieldMappings() : getFieldMappings();\n-    \tfor (FieldMapping fm : fms) {\n-    \t\tColumn[] cols = fm.getColumns();\n-    \t\tif (contains(cols, c)) {\n-    \t\t\tif (result == null)\n-    \t\t\t\tresult = new ArrayList<FieldMapping>();\n-    \t\t\tresult.add(fm);\n-    \t\t}\n-    \t}\n-    \treturn result;\n-    }\n-    \n-    boolean contains(Column[] cols, Column c) {\n-    \tfor (Column col : cols)\n-    \t\tif (col == c)\n-    \t\t\treturn true;\n-    \treturn false;\n-    }\n-    \n-    /**\n-     * Gets the field values of the given instance for the given columns.\n-     * The given columns are used to identify the fields by a reverse lookup.\n-     *  \n-     * @return a single object or an array of objects based on number of \n-     * fields the given columns represent.\n-     */\n-    private Object getValueFromUnmanagedInstance(Object obj, Column[] cols, \n-    \t\tboolean prime) {\n-    \tList<FieldMapping> fms = getFieldMappings(cols, prime);\n-    \tif (fms == null)\n-    \t\treturn null;\n-    \tif (fms.size() == 1)\n-    \t\treturn Reflection.getValue(obj, fms.get(0).getName(), true);\n-    \tObject[] result = new Object[fms.size()];\n-    \tint i = 0;\n-    \tfor (FieldMapping fm : fms) {\n-    \t\tresult[i++] = Reflection.getValue(obj, fm.getName(), true);\n-    \t}\n-    \treturn result;\n-    }\n-}"},{"sha":"d1699ea4979faaeafc14fe504d7a2f266fc53e0d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMappingInfo.java","status":"removed","additions":0,"deletions":493,"changes":493,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMappingInfo.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,493 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.io.File;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.apache.openjpa.jdbc.meta.strats.FullClassStrategy;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\n-import org.apache.openjpa.jdbc.schema.Schema;\n-import org.apache.openjpa.jdbc.schema.SchemaGroup;\n-import org.apache.openjpa.jdbc.schema.Table;\n-import org.apache.openjpa.jdbc.schema.Unique;\n-import org.apache.openjpa.lib.meta.SourceTracker;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.xml.Commentable;\n-import org.apache.openjpa.meta.MetaDataContext;\n-import org.apache.openjpa.util.UserException;\n-\n-/**\n- * Information about the mapping from a class to the schema, in raw form.\n- * The columns and tables used in mapping info will not be part of the\n- * {@link SchemaGroup} used at runtime. Rather, they will be structs\n- * with the relevant pieces of information filled in.\n- *\n- * @author Abe White\n- */\n-public class ClassMappingInfo\n-    extends MappingInfo\n-    implements SourceTracker, Commentable {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (ClassMappingInfo.class);\n-\n-    private String _className = Object.class.getName();\n-    private String _tableName = null;\n-    private String _schemaName = null;\n-    private boolean _joined = false;\n-    private Map _seconds = null;\n-    private String _subStrat = null;\n-    private File _file = null;\n-    private int _srcType = SRC_OTHER;\n-    private String[] _comments = null;\n-    private int _lineNum = 0;  \n-    private int _colNum = 0;  \n-    \n-    // Unique constraints indexed by primary or secondary table name\n-    private Map<String,List<Unique>> _uniques;\n-\n-    /**\n-     * The described class name.\n-     */\n-    public String getClassName() {\n-        return _className;\n-    }\n-\n-    /**\n-     * The described class name.\n-     */\n-    public void setClassName(String name) {\n-        _className = name;\n-    }\n-\n-    /**\n-     * The default strategy for subclasses in this hierarchy.\n-     */\n-    public String getHierarchyStrategy() {\n-        return _subStrat;\n-    }\n-\n-    /**\n-     * The default strategy for subclasses in this hierarchy.\n-     */\n-    public void setHierarchyStrategy(String strategy) {\n-        _subStrat = strategy;\n-    }\n-\n-    /**\n-     * The given table name.\n-     */\n-    public String getTableName() {\n-        return _tableName;\n-    }\n-\n-    /**\n-     * The given table name.\n-     */\n-    public void setTableName(String table) {\n-        _tableName = table;\n-    }\n-\n-    /**\n-     * The default schema name for unqualified tables.\n-     */\n-    public String getSchemaName() {\n-        return _schemaName;\n-    }\n-\n-    /**\n-     * The default schema name for unqualified tables.\n-     */\n-    public void setSchemaName(String schema) {\n-        _schemaName = schema;\n-    }\n-\n-    /**\n-     * Whether there is a join to the superclass table.\n-     */\n-    public boolean isJoinedSubclass() {\n-        return _joined;\n-    }\n-\n-    /**\n-     * Whether there is a join to the superclass table.\n-     */\n-    public void setJoinedSubclass(boolean joined) {\n-        _joined = joined;\n-    }\n-\n-    /**\n-     * Return the class-level joined tables.\n-     */\n-    public String[] getSecondaryTableNames() {\n-        if (_seconds == null)\n-            return new String[0];\n-        return (String[]) _seconds.keySet().toArray(new String[]{ });\n-    }\n-\n-    /**\n-     * We allow fields to reference class-level joins using just the table\n-     * name, whereas the class join might have schema, etc information.\n-     * This method returns the name of the given table as listed in a\n-     * class-level join, or the given name if no join exists.\n-     */\n-    public String getSecondaryTableName(String tableName) {\n-        // if no secondary table joins, bad table name, exact match,\n-        // or an already-qualified table name, nothing to do\n-        if (_seconds == null || tableName == null\n-            || _seconds.containsKey(tableName)\n-            || tableName.indexOf('.') != -1)\n-            return tableName;\n-\n-        // decide which class-level join table is best match\n-        String best = tableName;\n-        int pts = 0;\n-        String fullJoin;\n-        String join;\n-        int idx;\n-        for (Iterator itr = _seconds.keySet().iterator(); itr.hasNext();) {\n-            // award a caseless match without schema 2 points\n-            fullJoin = (String) itr.next();\n-            idx = fullJoin.lastIndexOf('.');\n-            if (idx == -1 && pts < 2 && fullJoin.equalsIgnoreCase(tableName)) {\n-                best = fullJoin;\n-                pts = 2;\n-            } else if (idx == -1)\n-                continue;\n-\n-            // immediately return an exact match with schema\n-            join = fullJoin.substring(idx + 1);\n-            if (join.equals(tableName))\n-                return fullJoin;\n-\n-            // caseless match with schema worth 1 point\n-            if (pts < 1 && join.equalsIgnoreCase(tableName)) {\n-                best = fullJoin;\n-                pts = 1;\n-            }\n-        }\n-        return best;\n-    }\n-\n-    /**\n-     * Return any columns defined for the given class level join, or empty\n-     * list if none.\n-     */\n-    public List getSecondaryTableJoinColumns(String tableName) {\n-        if (_seconds == null || tableName == null)\n-            return Collections.EMPTY_LIST;\n-\n-        // get the columns for the join with the best match for table name\n-        List cols = (List) _seconds.get(getSecondaryTableName(tableName));\n-        if (cols == null) {\n-            // possible that given table has extra info the join table\n-            // doesn't have; strip it\n-            int idx = tableName.lastIndexOf('.');\n-            if (idx != -1) {\n-                tableName = tableName.substring(idx + 1);\n-                cols = (List) _seconds.get(getSecondaryTableName(tableName));\n-            }\n-        }\n-        return (cols == null) ? Collections.EMPTY_LIST : cols;\n-    }\n-    \n-    /**\n-     * Adds a Secondary table of given name to this mapping. A secondary table \n-     * must be known before unique constraints are added to a Secondary table.\n-     */\n-    public void addSecondaryTable(String second) {\n-    \tsetSecondaryTableJoinColumns(second, null);\n-    }\n-\n-    /**\n-     * Declare the given class-level join to the named (secondary) table.\n-     */\n-    public void setSecondaryTableJoinColumns(String tableName, List cols) {\n-        if (cols == null)\n-            cols = Collections.EMPTY_LIST;\n-        if (_seconds == null)\n-            _seconds = new HashMap();\n-        _seconds.put(tableName, cols);\n-    }\n-    \n-    /**\n-     * Return the named table for the given class.\n-     */\n-    public Table getTable(final ClassMapping cls, String tableName, \n-    \t\tboolean adapt) {\n-        Table t = createTable(cls, new TableDefaults() {\n-            public String get(Schema schema) {\n-                // delay this so that we don't do schema reflection for unique\n-                // table name unless necessary\n-                return cls.getMappingRepository().getMappingDefaults().\n-                    getTableName(cls, schema);\n-            }\n-        }, _schemaName, tableName, adapt);\n-        t.setComment(cls.getTypeAlias() == null\n-            ? cls.getDescribedType().getName()\n-            : cls.getTypeAlias());\n-        return t;\n-    }\n-    \n-    /**\n-     * Return the primary table for the given class.\n-     */\n-    public Table getTable(final ClassMapping cls, boolean adapt) {\n-    \treturn getTable(cls, _tableName, adapt);\n-    }\n-    \n-    /**\n-     * Return the datastore identity columns for the given class, based on the\n-     * given templates.\n-     */\n-    public Column[] getDataStoreIdColumns(ClassMapping cls, Column[] tmplates,\n-        Table table, boolean adapt) {\n-        cls.getMappingRepository().getMappingDefaults().\n-            populateDataStoreIdColumns(cls, table, tmplates);\n-        return createColumns(cls, \"datastoreid\", tmplates, table, adapt);\n-    }\n-\n-    /**\n-     * Return the join from this class to its superclass. The table for\n-     * this class must be set.\n-     */\n-    public ForeignKey getSuperclassJoin(final ClassMapping cls, Table table,\n-        boolean adapt) {\n-        ClassMapping sup = cls.getJoinablePCSuperclassMapping();\n-        if (sup == null)\n-            return null;\n-\n-        ForeignKeyDefaults def = new ForeignKeyDefaults() {\n-            public ForeignKey get(Table local, Table foreign, boolean inverse) {\n-                return cls.getMappingRepository().getMappingDefaults().\n-                    getJoinForeignKey(cls, local, foreign);\n-            }\n-\n-            public void populate(Table local, Table foreign, Column col,\n-                Object target, boolean inverse, int pos, int cols) {\n-                cls.getMappingRepository().getMappingDefaults().\n-                    populateJoinColumn(cls, local, foreign, col, target,\n-                        pos, cols);\n-            }\n-        };\n-        return createForeignKey(cls, \"superclass\", getColumns(), def, table,\n-            cls, sup, false, adapt);\n-    }\n-\n-    /**\n-     * Synchronize internal information with the mapping data for the given\n-     * class.\n-     */\n-    public void syncWith(ClassMapping cls) {\n-        clear(false);\n-\n-        ClassMapping sup = cls.getMappedPCSuperclassMapping();\n-        if (cls.getTable() != null && (sup == null\n-            || sup.getTable() != cls.getTable()))\n-            _tableName = cls.getMappingRepository().getDBDictionary().\n-                getFullName(cls.getTable(), true);\n-\n-        // set io before syncing cols\n-        setColumnIO(cls.getColumnIO());\n-        if (cls.getJoinForeignKey() != null && sup != null\n-            && sup.getTable() != null)\n-            syncForeignKey(cls, cls.getJoinForeignKey(), cls.getTable(),\n-                sup.getTable());\n-        else if (cls.getIdentityType() == ClassMapping.ID_DATASTORE)\n-            syncColumns(cls, cls.getPrimaryKeyColumns(), false);\n-\n-        // record inheritance strategy if class does not use default strategy\n-        // for base classes, and for all subclasses so we can be sure subsequent\n-        // mapping runs don't think subclass is unmapped\n-        String strat = (cls.getStrategy() == null) ? null\n-            : cls.getStrategy().getAlias();\n-        if (strat != null && (cls.getPCSuperclass() != null\n-            || !FullClassStrategy.ALIAS.equals(strat)))\n-            setStrategy(strat);        \n-    }\n-\n-    public boolean hasSchemaComponents() {\n-        return super.hasSchemaComponents() || _tableName != null;\n-    }\n-\n-    protected void clear(boolean canFlags) {\n-        super.clear(canFlags);\n-        _tableName = null;\n-    }\n-\n-    public void copy(MappingInfo info) {\n-        super.copy(info);\n-        if (!(info instanceof ClassMappingInfo))\n-            return;\n-\n-        ClassMappingInfo cinfo = (ClassMappingInfo) info;\n-        if (_tableName == null)\n-            _tableName = cinfo.getTableName();\n-        if (_subStrat == null)\n-            _subStrat = cinfo.getHierarchyStrategy();\n-        if (cinfo._seconds != null) {\n-            if (_seconds == null)\n-                _seconds = new HashMap();\n-            Object key;\n-            for (Iterator itr = cinfo._seconds.keySet().iterator();\n-                itr.hasNext();) {\n-                key = itr.next();\n-                if (!_seconds.containsKey(key))\n-                    _seconds.put(key, cinfo._seconds.get(key));\n-            }\n-        }\n-        if (cinfo._uniques != null) {\n-        \tif (_uniques == null)\n-        \t\t_uniques = new HashMap<String, List<Unique>>();\n-        \tfor (Entry<String, List<Unique>> entry : cinfo._uniques.entrySet())\n-        \t\tif (!_uniques.containsKey(entry.getKey()))\n-        \t\t\t_uniques.put(entry.getKey(), entry.getValue());\n-        }\n-\n-    }\n-    \n-    /**\n-     * Add a unique constraint for the given table.\n-     * @param table must be primary table or secondary table name added a \n-     * priori to this receiver.\n-     * @param unique the unique constraint. null means no-op.\n-     */\n-    public void addUnique(String table, Unique unique) {\n-    \tif (!StringUtils.equals(_tableName, table) &&\n-    \t   (_seconds == null || !_seconds.containsKey(table))) {\n-    \t   \t\tthrow new UserException(_loc.get(\"unique-no-table\", \n-    \t   \t\t\tnew Object[]{table, _className, _tableName, \n-    \t   \t\t\t\t((_seconds == null) ? \"\" : _seconds.keySet())}));\n-    \t}\n-    \tif (unique == null)\n-    \t\treturn;\n-        if (_uniques == null)\n-            _uniques = new HashMap<String,List<Unique>>();\n-        unique.setTableName(table);\n-        List<Unique> uniques = _uniques.get(table);\n-        if (uniques == null) {\n-        \tuniques = new ArrayList<Unique>();\n-        \tuniques.add(unique);\n-        \t_uniques.put(table, uniques);\n-        } else {\n-        \tuniques.add(unique);\n-        }\n-    }\n-    \n-    /**\n-     * Get the unique constraints of the given primary or secondary table.\n-     */\n-    public Unique[] getUniques(String table) {\n-        if (_uniques == null || _uniques.isEmpty() \n-        || _uniques.containsKey(table))\n-            return new Unique[0];\n-        List<Unique> uniques = _uniques.get(table);\n-        return uniques.toArray(new Unique[uniques.size()]);\n-    }\n-    \n-    /**\n-     * Get all the unique constraints associated with both the primary and/or \n-     * secondary tables.\n-     * \n-     */\n-    public Unique[] getUniques(MetaDataContext cm, boolean adapt) {\n-        if (_uniques == null || _uniques.isEmpty())\n-            return new Unique[0];\n-        List<Unique> result = new ArrayList<Unique>();\n-        for (String tableName : _uniques.keySet()) {\n-        \tList<Unique> uniqueConstraints = _uniques.get(tableName);\n-        \tfor (Unique template : uniqueConstraints) {\n-        \t\tColumn[] templateColumns = template.getColumns();\n-        \t\tColumn[] uniqueColumns = new Column[templateColumns.length];\n-        \t\tTable table = getTable((ClassMapping)cm, tableName, adapt);\n-        \t\tfor (int i=0; i<uniqueColumns.length; i++) {\n-        \t\t\tString columnName = templateColumns[i].getName();\n-        \t\t\tif (!table.containsColumn(columnName)) {\n-        \t\t\t\tthrow new UserException(_loc.get(\"unique-missing-column\", \n-                           new Object[]{cm, columnName, tableName, \n-        \t\t\t\t\t\tArrays.toString(table.getColumnNames())}));\n-        \t\t\t}\n-        \t\t\tColumn uniqueColumn = table.getColumn(columnName);\n-        \t\t\tuniqueColumns[i] = uniqueColumn;\n-        \t\t}\n-        \t\tUnique unique = createUnique(cm, \"unique\", template,  \n-        \t\t\t\tuniqueColumns, adapt);\n-        \t\tif (unique != null)\n-        \t\t\tresult.add(unique);\n-        \t}\n-        }\n-        return result.toArray(new Unique[result.size()]);\n-    }   \n-    \n-    public File getSourceFile() {\n-        return _file;\n-    }\n-\n-    public Object getSourceScope() {\n-        return null;\n-    }\n-\n-    public int getSourceType() {\n-        return _srcType;\n-    }\n-\n-    public void setSource(File file, int srcType) {\n-        _file = file;\n-        _srcType = srcType;\n-    }\n-\n-    public String getResourceName() {\n-        return _className;\n-    }\n-\n-    public String[] getComments() {\n-        return (_comments == null) ? EMPTY_COMMENTS : _comments;\n-    }\n-\n-    public void setComments(String[] comments) {\n-        _comments = comments;\n-    }\n-    \n-    public int getLineNumber() {\n-        return _lineNum;\n-    }\n-\n-    public void setLineNumber(int lineNum) {\n-        _lineNum = lineNum;\n-    }\n-\n-    public int getColNumber() {\n-        return _colNum;\n-    }\n-\n-    public void setColNumber(int colNum) {\n-        _colNum = colNum;\n-    }\n-    \n-}"},{"sha":"1dc604b5c207bd3571c240951f37bf6782fc744e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassStrategy.java","status":"removed","additions":0,"deletions":115,"changes":115,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,115 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\n-import org.apache.openjpa.kernel.PCState;\n-import org.apache.openjpa.lib.rop.ResultObjectProvider;\n-\n-/**\n- * Mapping from a class to a relational schema.\n- *\n- * @author Abe White\n- * @since 0.4.0\n- */\n-public interface ClassStrategy\n-    extends Strategy {\n-\n-    /**\n-     * Set the class mapping using this strategy. This will be called before\n-     * use.\n-     */\n-    public void setClassMapping(ClassMapping owner);\n-\n-    /**\n-     * Return true if the this class' primary key columns correspond to the\n-     * base class' primary key columns used to construct oid values. Base\n-     * classes always return true. Classes that join to the base class table,\n-     * though, may not always join using the same columns the base class\n-     * uses for oid values, or may not use all the columns. When performing a\n-     * select, we will join down to the most-derived class that is identified\n-     * by oid values. We cannot use non-primary key field values for joining\n-     * during selects, because the field values to join on might be the ones\n-     * we're trying to select! Similarly, we can only reconstruct oid values\n-     * for selected objects using classes whose primary keys store oid values.\n-     *\n-     * @param hasAll if true, there must be a primary key column for every\n-     * base class primary key column; if false the primary key\n-     * must only match a subset of the base class primary key columns\n-     */\n-    public boolean isPrimaryKeyObjectId(boolean hasAll);\n-\n-    /**\n-     * Join the mapping and its superclass.\n-     *\n-     * @param toThis if false, inner join to the superclass table; if\n-     * true, outer join from the superclass table to this table\n-     */\n-    public Joins joinSuperclass(Joins joins, boolean toThis);\n-\n-    /**\n-     * Return true if this strategy can perform the given select from\n-     * the given <code>base</code> mapping.\n-     * The given state manager may be null if selecting multiple instances.\n-     */\n-    public boolean supportsEagerSelect(Select sel, OpenJPAStateManager sm,\n-        JDBCStore store, ClassMapping base, JDBCFetchConfiguration fetch);\n-\n-    /**\n-     * Implement this method to customize obtaining a result containing all\n-     * instances of this class. Return null for standard loading.\n-     */\n-    public ResultObjectProvider customLoad(JDBCStore store, boolean subclasses,\n-        JDBCFetchConfiguration fetch, long startIdx, long endIdx)\n-        throws SQLException;\n-\n-    /**\n-     * Implement this method to load the state of a given object, without\n-     * a previous {@link Result}. Return true if this method handles the\n-     * load. If the object does not exist in the data store, simply take no\n-     * action on it (but still return true). Return false to use default\n-     * loading.\n-     *\n-     * @param state if non-null, then you must initialize the state\n-     * and persistent object of the given state manager\n-     * (after determining the actual class of the object\n-     * from the database, if there are possible persistent\n-     * subclasses); initialization looks like this: <code>\n-     * sm.initialize (pcClass, state)</code>\n-     */\n-    public boolean customLoad(OpenJPAStateManager sm, JDBCStore store,\n-        PCState state, JDBCFetchConfiguration fetch)\n-        throws SQLException, ClassNotFoundException;\n-\n-    /**\n-     * Implement this method to customize loading from a {@link Result}\n-     * into an instance. Return true if this mapping handles the\n-     * load; false if normal loading should procede after calling this method.\n-     */\n-    public boolean customLoad(OpenJPAStateManager sm, JDBCStore store,\n-        JDBCFetchConfiguration fetch, Result result)\n-        throws SQLException;\n-}"},{"sha":"20efe87097b1c4e6be5c3ed573fa80da9d89455c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DelegatingJoinable.java","status":"removed","additions":0,"deletions":128,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DelegatingJoinable.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DelegatingJoinable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DelegatingJoinable.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,128 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.util.MetaDataException;\n-\n-/**\n- * Delegates to another {@link Joinable} after doing column\n- * translation. Useful for joins that are not managed by any fields on\n- * the joined-from side. For example, a vertical class mapping manages\n- * foreign key columns linking to the superclass table. It needs to use\n- * the joinables of the superclass to actually extract the column values\n- * from field values and so forth, but in order for other mappings to join\n- * to its foreign key columns it needs joinables of its own. So it creates\n- * delegating joinables.\n- *\n- * @author Abe White\n- */\n-public class DelegatingJoinable\n-    implements Joinable {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (DelegatingJoinable.class);\n-\n-    private final Joinable _join;\n-    private final ForeignKey _fk;\n-    private final Column[] _cols;\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param join the mapping to delegate to\n-     * @param fk the foreign key to use to translate any given columns\n-     * to the given delegate's columns\n-     */\n-    public DelegatingJoinable(Joinable join, ForeignKey fk) {\n-        _join = join;\n-        _fk = fk;\n-\n-        Column[] pks = join.getColumns();\n-        _cols = new Column[pks.length];\n-        for (int i = 0; i < pks.length; i++) {\n-            _cols[i] = fk.getColumn(pks[i]);\n-            if (_cols[i] == null)\n-                throw new MetaDataException(_loc.get(\"incomplete-join\",\n-                    pks[i].getFullName()));\n-        }\n-    }\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param join the mapping to delegate to\n-     * @param cols translated columns\n-     */\n-    public DelegatingJoinable(Joinable join, Column[] cols) {\n-        _join = join;\n-        _fk = null;\n-        _cols = cols;\n-        if (cols.length != join.getColumns().length)\n-            throw new MetaDataException(_loc.get(\"bad-remap\",\n-                join.getColumns()[0].getFullName()));\n-    }\n-\n-    public int getFieldIndex() {\n-        return _join.getFieldIndex();\n-    }\n-\n-    public Object getPrimaryKeyValue(Result res, Column[] cols, ForeignKey fk, \n-        JDBCStore store, Joins joins)\n-        throws SQLException {\n-        return _join.getPrimaryKeyValue(res, cols, fk, store, joins);\n-    }\n-\n-    public Column[] getColumns() {\n-        return _cols;\n-    }\n-\n-    public Object getJoinValue(Object val, Column col, JDBCStore store) {\n-        return _join.getJoinValue(val, translate(col), store);\n-    }\n-\n-    public Object getJoinValue(OpenJPAStateManager sm, Column col,\n-        JDBCStore store) {\n-        return _join.getJoinValue(sm, translate(col), store);\n-    }\n-\n-    public void setAutoAssignedValue(OpenJPAStateManager sm, JDBCStore store,\n-        Column col, Object autogen) {\n-        _join.setAutoAssignedValue(sm, store, translate(col), autogen);\n-    }\n-\n-    private Column translate(Column col) {\n-        if (_fk != null)\n-            return _fk.getPrimaryKeyColumn(col);\n-\n-        Column[] cols = _join.getColumns();\n-        for (int i = 0; i < cols.length; i++)\n-            if (col == cols[i])\n-                return _cols[i];\n-        return null;\n-    }\n-}"},{"sha":"5a41b30ff44c39a00e4523d4e4d89bab657b03db","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Discriminator.java","status":"removed","additions":0,"deletions":436,"changes":436,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Discriminator.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Discriminator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Discriminator.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,436 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ColumnIO;\n-import org.apache.openjpa.jdbc.schema.Index;\n-import org.apache.openjpa.jdbc.schema.Schemas;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.RowManager;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\n-import org.apache.openjpa.lib.log.Log;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.meta.JavaTypes;\n-import org.apache.openjpa.meta.MetaDataContext;\n-import org.apache.openjpa.meta.MetaDataModes;\n-import org.apache.openjpa.meta.MetaDataRepository;\n-import org.apache.openjpa.util.InternalException;\n-\n-/**\n- * Handles determining the object class of database records.\n- *\n- * @author Abe White\n- */\n-public class Discriminator\n-    implements DiscriminatorStrategy, MetaDataContext, MetaDataModes {\n-\n-    /**\n-     * Null discriminator value marker.\n-     */\n-    public static final Object NULL = new Object();\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (Discriminator.class);\n-\n-    private final ClassMapping _mapping;\n-    private final DiscriminatorMappingInfo _info;\n-    private DiscriminatorStrategy _strategy = null;\n-    private int _resMode = MODE_NONE;\n-\n-    private Column[] _cols = Schemas.EMPTY_COLUMNS;\n-    private ColumnIO _io = null;\n-    private Index _idx = null;\n-    private boolean _subsLoaded = false;\n-    private Object _value = null;\n-    \n-    private int _javaType = -1; \n-\n-    /**\n-     * Constructor. Supply owning mapping.\n-     */\n-    public Discriminator(ClassMapping mapping) {\n-        _mapping = mapping;\n-        _info = getMappingRepository().newMappingInfo(this);\n-    }\n-\n-    public MetaDataRepository getRepository() {\n-        return _mapping.getRepository();\n-    }\n-\n-    public MappingRepository getMappingRepository() {\n-        return _mapping.getMappingRepository();\n-    }\n-\n-    /**\n-     * Return the owning mapping.\n-     */\n-    public ClassMapping getClassMapping() {\n-        return _mapping;\n-    }\n-\n-    /**\n-     * The strategy used for class discrimination.\n-     */\n-    public DiscriminatorStrategy getStrategy() {\n-        return _strategy;\n-    }\n-\n-    /**\n-     * The strategy used for class discrimination. The <code>adapt</code>\n-     * parameter determines whether to adapt when mapping the strategy;\n-     * use null if the strategy should not be mapped.\n-     */\n-    public void setStrategy(DiscriminatorStrategy strategy, Boolean adapt) {\n-        // set strategy first so we can access it during mapping\n-        DiscriminatorStrategy orig = _strategy;\n-        _strategy = strategy;\n-        if (strategy != null) {\n-            try {\n-                strategy.setDiscriminator(this);\n-                if (adapt != null)\n-                    strategy.map(adapt.booleanValue());\n-            } catch (RuntimeException re) {\n-                // reset strategy\n-                _strategy = orig;\n-                throw re;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * The discriminator value.\n-     */\n-    public Object getValue() {\n-        return _value;\n-    }\n-\n-    /**\n-     * The discriminator value.\n-     */\n-    public void setValue(Object value) {\n-        _value = value;\n-    }\n-\n-    /**\n-     * Raw mapping data.\n-     */\n-    public DiscriminatorMappingInfo getMappingInfo() {\n-        return _info;\n-    }\n-\n-    /**\n-     * Columns used by this Discriminator.\n-     */\n-    public Column[] getColumns() {\n-        return _cols;\n-    }\n-\n-    /**\n-     * Columns used by this Discriminator.\n-     */\n-    public void setColumns(Column[] cols) {\n-        if (cols == null)\n-            cols = Schemas.EMPTY_COLUMNS;\n-        _cols = cols;\n-    }\n-\n-    /**\n-     * I/O information on the discriminator columns.\n-     */\n-    public ColumnIO getColumnIO() {\n-        return (_io == null) ? ColumnIO.UNRESTRICTED : _io;\n-    }\n-\n-    /**\n-     * I/O information on the discriminator columns.\n-     */\n-    public void setColumnIO(ColumnIO io) {\n-        _io = io;\n-    }\n-\n-    /**\n-     * Index on the Discriminator columns, or null if none.\n-     */\n-    public Index getIndex() {\n-        return _idx;\n-    }\n-\n-    /**\n-     * Index on the Discriminator columns, or null if none.\n-     */\n-    public void setIndex(Index idx) {\n-        _idx = idx;\n-    }\n-\n-    /**\n-     * Increment the reference count of used schema components.\n-     */\n-    public void refSchemaComponents() {\n-        for (int i = 0; i < _cols.length; i++)\n-            _cols[i].ref();\n-    }\n-\n-    /**\n-     * Clear mapping information, including strategy.\n-     */\n-    public void clearMapping() {\n-        _strategy = null;\n-        _cols = Schemas.EMPTY_COLUMNS;\n-        _idx = null;\n-        _value = null;\n-        _info.clear();\n-        setResolve(MODE_MAPPING | MODE_MAPPING_INIT, false);\n-    }\n-\n-    /**\n-     * Update {@link MappingInfo} with our current mapping information.\n-     */\n-    public void syncMappingInfo() {\n-        _info.syncWith(this);\n-    }\n-\n-    /**\n-     * Resolve mode.\n-     */\n-    public int getResolve() {\n-        return _resMode;\n-    }\n-\n-    /**\n-     * Resolve mode.\n-     */\n-    public void setResolve(int mode) {\n-        _resMode = mode;\n-    }\n-\n-    /**\n-     * Resolve mode.\n-     */\n-    public void setResolve(int mode, boolean on) {\n-        if (mode == MODE_NONE)\n-            _resMode = mode;\n-        else if (on)\n-            _resMode |= mode;\n-        else\n-            _resMode &= ~mode;\n-    }\n-\n-    /**\n-     * Resolve mapping information.\n-     */\n-    public boolean resolve(int mode) {\n-        if ((_resMode & mode) == mode)\n-            return true;\n-        int cur = _resMode;\n-        _resMode |= mode;\n-        if ((mode & MODE_MAPPING) != 0 && (cur & MODE_MAPPING) == 0)\n-            resolveMapping();\n-        if ((mode & MODE_MAPPING_INIT) != 0 && (cur & MODE_MAPPING_INIT) == 0)\n-            _strategy.initialize();\n-        return false;\n-    }\n-\n-    /**\n-     * Setup mapping.\n-     */\n-    private void resolveMapping() {\n-        // map strategy\n-        MappingRepository repos = getMappingRepository();\n-        if (_strategy == null)\n-            repos.getStrategyInstaller().installStrategy(this);\n-        Log log = repos.getLog();\n-        if (log.isTraceEnabled())\n-            log.trace(_loc.get(\"strategy\", this, _strategy.getAlias()));\n-\n-        // mark columns as mapped\n-        Column[] cols = getColumns();\n-        ColumnIO io = getColumnIO();\n-        for (int i = 0; i < cols.length; i++) {\n-            if (io.isInsertable(i, false))\n-                cols[i].setFlag(Column.FLAG_DIRECT_INSERT, true);\n-            if (io.isUpdatable(i, false))\n-                cols[i].setFlag(Column.FLAG_DIRECT_UPDATE, true);\n-        }\n-    }\n-\n-    /**\n-     * Whether this Discriminator has loaded subclasses yet.\n-     */\n-    public boolean getSubclassesLoaded() {\n-        if (!_subsLoaded) {\n-            ClassMapping sup = _mapping.getPCSuperclassMapping();\n-            if (sup != null && sup.getDiscriminator().getSubclassesLoaded())\n-                _subsLoaded = true;\n-        }\n-        return _subsLoaded;\n-    }\n-\n-    /**\n-     * Whether this Discriminator has loaded subclasses yet.\n-     */\n-    public void setSubclassesLoaded(boolean loaded) {\n-        _subsLoaded = loaded;\n-    }\n-\n-    /**\n-     * Add WHERE conditions to the given select limiting the returned results\n-     * to our mapping type, possibly including subclasses.\n-     */\n-    public boolean addClassConditions(Select sel, boolean subs, Joins joins) {\n-        if (_mapping.getJoinablePCSuperclassMapping() == null\n-            && _mapping.getJoinablePCSubclassMappings().length == 0)\n-            return false;\n-        if (!hasClassConditions(_mapping, subs))\n-            return false;\n-\n-        // join down to base class where conditions will be added\n-        ClassMapping from = _mapping;\n-        ClassMapping sup = _mapping.getJoinablePCSuperclassMapping();\n-        for (; sup != null; from = sup, sup = from\n-            .getJoinablePCSuperclassMapping()) {\n-            if (from.getTable() != sup.getTable()) {\n-                if (joins == null)\n-                    joins = sel.newJoins();\n-                joins = from.joinSuperclass(joins, false);\n-            }\n-        }\n-\n-        sel.where(getClassConditions(sel, joins, _mapping, subs), joins);\n-        return true;\n-    }\n-\n-    ////////////////////////////////////////\n-    // DiscriminatorStrategy implementation\n-    ////////////////////////////////////////\n-\n-    public String getAlias() {\n-        return assertStrategy().getAlias();\n-    }\n-\n-    public void map(boolean adapt) {\n-        assertStrategy().map(adapt);\n-    }\n-\n-    public void initialize() {\n-        assertStrategy().initialize();\n-    }\n-\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n-        throws SQLException {\n-        assertStrategy().insert(sm, store, rm);\n-    }\n-\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n-        throws SQLException {\n-        assertStrategy().update(sm, store, rm);\n-    }\n-\n-    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n-        throws SQLException {\n-        assertStrategy().delete(sm, store, rm);\n-    }\n-\n-    public Boolean isCustomInsert(OpenJPAStateManager sm, JDBCStore store) {\n-        return assertStrategy().isCustomInsert(sm, store);\n-    }\n-\n-    public Boolean isCustomUpdate(OpenJPAStateManager sm, JDBCStore store) {\n-        return assertStrategy().isCustomUpdate(sm, store);\n-    }\n-\n-    public Boolean isCustomDelete(OpenJPAStateManager sm, JDBCStore store) {\n-        return assertStrategy().isCustomDelete(sm, store);\n-    }\n-\n-    public void customInsert(OpenJPAStateManager sm, JDBCStore store)\n-        throws SQLException {\n-        assertStrategy().customInsert(sm, store);\n-    }\n-\n-    public void customUpdate(OpenJPAStateManager sm, JDBCStore store)\n-        throws SQLException {\n-        assertStrategy().customUpdate(sm, store);\n-    }\n-\n-    public void customDelete(OpenJPAStateManager sm, JDBCStore store)\n-        throws SQLException {\n-        assertStrategy().customDelete(sm, store);\n-    }\n-\n-    public void setDiscriminator(Discriminator owner) {\n-        assertStrategy().setDiscriminator(owner);\n-    }\n-\n-    public boolean select(Select sel, ClassMapping mapping) {\n-        return assertStrategy().select(sel, mapping);\n-    }\n-\n-    public void loadSubclasses(JDBCStore store)\n-        throws SQLException, ClassNotFoundException {\n-        assertStrategy().loadSubclasses(store);\n-    }\n-\n-    public Class getClass(JDBCStore store, ClassMapping base, Result result)\n-        throws SQLException, ClassNotFoundException {\n-        return assertStrategy().getClass(store, base, result);\n-    }\n-\n-    public boolean hasClassConditions(ClassMapping base, boolean subs) {\n-        return assertStrategy().hasClassConditions(base, subs);\n-    }\n-\n-    public SQLBuffer getClassConditions(Select sel, Joins joins, \n-        ClassMapping base, boolean subs) {\n-        return assertStrategy().getClassConditions(sel, joins, base, subs);\n-    }\n-\n-    private DiscriminatorStrategy assertStrategy() {\n-        if (_strategy == null)\n-            throw new InternalException();\n-        return _strategy;\n-    }\n-\n-    public String toString() {\n-        return _mapping + \"<discriminator>\";\n-    }\n-    \n-    public void setJavaType(int javaType) {\n-        _javaType = javaType;\n-    }\n-    \n-    public int getJavaType() {\n-        if (_javaType == -1) {\n-            ClassMapping superMapping = _mapping.getPCSuperclassMapping();\n-\n-            if (superMapping != null && \n-                superMapping.getDiscriminator() != null) {\n-                _javaType = superMapping.getDiscriminator().getJavaType();\n-            }\n-        }\n-\n-        return _javaType;\n-    }\n-}"},{"sha":"2ad836c0d6031865c47f8a60e73171efb4803a4b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorMappingInfo.java","status":"removed","additions":0,"deletions":170,"changes":170,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorMappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorMappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorMappingInfo.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,170 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.lang.reflect.Modifier;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.apache.openjpa.jdbc.meta.strats.NoneDiscriminatorStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.SuperclassDiscriminatorStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.ValueMapDiscriminatorStrategy;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.Index;\n-import org.apache.openjpa.jdbc.schema.SchemaGroup;\n-import org.apache.openjpa.jdbc.schema.Table;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.meta.JavaTypes;\n-import org.apache.openjpa.util.MetaDataException;\n-\n-/**\n- * Information about the mapping from a discriminator to the schema, in\n- * raw form. The columns and tables used in mapping info will not be part of\n- * the {@link SchemaGroup} used at runtime. Rather, they will be structs\n- * with the relevant pieces of information filled in.\n- *\n- * @author Abe White\n- */\n-public class DiscriminatorMappingInfo\n-    extends MappingInfo {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (DiscriminatorMappingInfo.class);\n-\n-    private String _value = null;\n-    \n-    /**\n-     * Raw discriminator value string.\n-     */\n-    public String getValue() {\n-        return _value;\n-    }\n-\n-    /**\n-     * Raw discriminator value string.\n-     */\n-    public void setValue(String value) {\n-        _value = value;\n-    }\n-\n-    /**\n-     * Return the discriminator value as an object of the right type.\n-     */\n-    public Object getValue(Discriminator discrim, boolean adapt) {\n-        if (discrim.getValue() != null)\n-            return discrim.getValue();\n-        if (StringUtils.isEmpty(_value)) {\n-            return discrim.getMappingRepository().getMappingDefaults().\n-                getDiscriminatorValue(discrim, adapt);\n-        }\n-        \n-        switch(discrim.getJavaType()) { \n-            case JavaTypes.INT:\n-                return Integer.valueOf(_value);\n-            case JavaTypes.CHAR:\n-               return new Character(_value.charAt(_value.indexOf('\\'')+1));\n-            case JavaTypes.STRING:\n-            default: \n-                return _value;\n-        }\n-    }\n-\n-    /**\n-     * Return the columns set for this discriminator, based on the given\n-     * templates.\n-     */\n-    public Column[] getColumns(Discriminator discrim, Column[] tmplates,\n-        boolean adapt) {\n-        Table table = discrim.getClassMapping().getTable();\n-        discrim.getMappingRepository().getMappingDefaults().populateColumns\n-            (discrim, table, tmplates);\n-        return createColumns(discrim, null, tmplates, table, adapt);\n-    }\n-\n-    /**\n-     * Return the index to set on the discriminator columns, or null if none.\n-     */\n-    public Index getIndex(Discriminator discrim, Column[] cols, boolean adapt) {\n-        Index idx = null;\n-        if (cols.length > 0)\n-            idx = discrim.getMappingRepository().getMappingDefaults().\n-                getIndex(discrim, cols[0].getTable(), cols);\n-        return createIndex(discrim, null, idx, cols, adapt);\n-    }\n-\n-    /**\n-     * Synchronize internal information with the mapping data for the given\n-     * discriminator.\n-     */\n-    public void syncWith(Discriminator disc) {\n-        clear(false);\n-\n-        // set io before syncing cols\n-        setColumnIO(disc.getColumnIO());\n-        syncColumns(disc, disc.getColumns(), disc.getValue() != null\n-            && !(disc.getValue() instanceof String));\n-        syncIndex(disc, disc.getIndex());\n-        if (disc.getValue() == Discriminator.NULL)\n-            _value = \"null\";\n-        else if (disc.getValue() != null)\n-            _value = disc.getValue().toString();\n-\n-        if (disc.getStrategy() == null\n-            || disc.getStrategy() instanceof SuperclassDiscriminatorStrategy)\n-            return;\n-\n-        // explicit discriminator strategy if:\n-        // - unmapped class and discriminator is mapped\n-        // - final base class and discriminator is mapped\n-        // - table-per-class subclass and discriminator is mapped\n-        // - mapped subclass and doesn't rely on superclass discriminator\n-        // - mapped base class and doesn't use value-map strategy with value\n-        //   and isn't a final class that uses the final strategy\n-        ClassMapping cls = disc.getClassMapping();\n-        String strat = disc.getStrategy().getAlias();\n-        boolean sync = false;\n-\n-        if (!cls.isMapped()\n-            || (cls.getJoinablePCSuperclassMapping() != null\n-            && Modifier.isFinal(cls.getDescribedType().getModifiers()))\n-            || (cls.getJoinablePCSuperclassMapping() == null\n-            && cls.getMappedPCSuperclassMapping() != null))\n-            sync = !NoneDiscriminatorStrategy.ALIAS.equals(strat);\n-        else\n-            sync = cls.getJoinablePCSuperclassMapping() != null\n-                || _value == null\n-                || !ValueMapDiscriminatorStrategy.ALIAS.equals(strat);\n-\n-        if (sync)\n-            setStrategy(strat);\n-    }\n-\n-    protected void clear(boolean canFlags) {\n-        super.clear(canFlags);\n-        _value = null;\n-    }\n-\n-    public void copy(MappingInfo info) {\n-        super.copy(info);\n-        if (!(info instanceof DiscriminatorMappingInfo))\n-            return;\n-\n-        if (_value == null)\n-            _value = ((DiscriminatorMappingInfo) info).getValue();\n-    }\n-}"},{"sha":"8a809444a5d5886f894d627a9bfb2def24e9f1a8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorStrategy.java","status":"removed","additions":0,"deletions":78,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,78 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-\n-/**\n- * Handles determining the object class of database records.\n- *\n- * @author Abe White\n- */\n-public interface DiscriminatorStrategy\n-    extends Strategy {\n-\n-    /**\n-     * Set the Discriminator that uses this strategy. This will be called\n-     * before use.\n-     */\n-    public void setDiscriminator(Discriminator owner);\n-\n-    /**\n-     * Select the data for this Discriminator.\n-     *\n-     * @param mapping the known base class being selected; this may\n-     * not be the base class in the inheritance hierarchy\n-     * @return true if anything was selected; false otherwise\n-     */\n-    public boolean select(Select sel, ClassMapping mapping);\n-\n-    /**\n-     * Load all subclasses of the owning class mapping into the JVM.\n-     */\n-    public void loadSubclasses(JDBCStore store)\n-        throws SQLException, ClassNotFoundException;\n-\n-    /**\n-     * Return the class for the current result row.\n-     */\n-    public Class getClass(JDBCStore store, ClassMapping base, Result result)\n-        throws SQLException, ClassNotFoundException;\n-\n-    /**\n-     * Whether any class conditions are necessary.\n-     *\n-     * @see #getClassConditions\n-     */\n-    public boolean hasClassConditions(ClassMapping base, boolean subs);\n-\n-    /**\n-     * Return SQL to limit the classes selected as much as possible to the\n-     * given base class, and optionally its subclasses. The select and joins \n-     * instances are supplied in order to get column aliases.\n-     */\n-    public SQLBuffer getClassConditions(Select sel, Joins joins, \n-        ClassMapping base, boolean subs);\n-}"},{"sha":"26b6ce1d917110ec65f63446cf39c05b188dde69","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Embeddable.java","status":"removed","additions":0,"deletions":85,"changes":85,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Embeddable.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Embeddable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Embeddable.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,85 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ColumnIO;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\n-\n-/**\n- * Interface for field strategies that can managed fields of\n- * embedded-element, embedded-key, and embedded-value objects. Fields of\n- * directly embedded objects do not have to implement this interface.\n- *\n- * @author Abe White\n- * @since 0.4.0\n- */\n-public interface Embeddable {\n-\n-    public static final Object UNSUPPORTED = new Object();\n-\n-    /**\n-     * Return the columns used by this strategy.\n-     */\n-    public Column[] getColumns();\n-\n-    /**\n-     * Return column I/O information for this mapping.\n-     */\n-    public ColumnIO getColumnIO();\n-\n-    /**\n-     * Return the arguments needed to extract datastore values via\n-     * {@link Result#getObject} for each column.\n-     */\n-    public Object[] getResultArguments();\n-\n-    /**\n-     * Convert the given Java value to its datastore equivalent. If this\n-     * mapping occupies multiple columns, return an object array with one\n-     * element per column. For relation id columns, return the state manager\n-     * the column depends on.\n-     */\n-    public Object toEmbeddedDataStoreValue(Object val, JDBCStore store);\n-\n-    /**\n-     * Convert the given datastore value to its Java equivalent.\n-     * If {@link #getColumns} returns multiple columns, the given datastore\n-     * value will be an object array of the corresponding length. This method\n-     * must only be supported by mappings of embedded id objects. In other\n-     * cases {@link #loadEmbedded} will be used instead. Return\n-     * {@link #UNSUPPORTED} if this mapping cannot support this method.\n-     */\n-    public Object toEmbeddedObjectValue(Object val);\n-\n-    /**\n-     * Load this strategy's field by transforming the given datastore value.\n-     * If {@link #getColumns} returns multiple columns, the given datastore\n-     * value will be an object array of the corresponding length. The value\n-     * does not have to be loaded immediately; it may be stored as impl data.\n-     */\n-    public void loadEmbedded(OpenJPAStateManager sm, JDBCStore store,\n-        JDBCFetchConfiguration fetch, Object val)\n-        throws SQLException;\n-}"},{"sha":"7cf3c535daf986d2581366017d5e408d49c9a788","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMapping.java","status":"removed","additions":0,"deletions":1050,"changes":1050,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMapping.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMapping.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,1050 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.meta.strats.NoneFieldStrategy;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ColumnIO;\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\n-import org.apache.openjpa.jdbc.schema.Index;\n-import org.apache.openjpa.jdbc.schema.Table;\n-import org.apache.openjpa.jdbc.schema.Unique;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.Row;\n-import org.apache.openjpa.jdbc.sql.RowManager;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.jdbc.sql.SelectExecutor;\n-import org.apache.openjpa.kernel.FetchConfiguration;\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\n-import org.apache.openjpa.lib.log.Log;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.meta.FieldMetaData;\n-import org.apache.openjpa.meta.JavaTypes;\n-import org.apache.openjpa.util.InternalException;\n-import org.apache.openjpa.util.MetaDataException;\n-\n-/**\n- * Specialization of metadata for relational databases.\n- *\n- * @author Abe White\n- */\n-public class FieldMapping\n-    extends FieldMetaData\n-    implements ValueMapping, FieldStrategy {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (FieldMapping.class);\n-\n-    private final ValueMapping _val;\n-    private final ValueMapping _key;\n-    private final ValueMapping _elem;\n-    private final FieldMappingInfo _info;\n-    private final JDBCColumnOrder _orderCol = new JDBCColumnOrder();\n-    private FieldStrategy _strategy = null;\n-\n-    private ForeignKey _fk = null;\n-    private ColumnIO _io = null;\n-    private Unique _unq = null;\n-    private Index _idx = null;\n-    private boolean _outer = false;\n-    private int _fetchMode = Integer.MAX_VALUE;\n-    private Unique[] _joinTableUniques; // Unique constraints on JoinTable\n-    \n-    /**\n-     * Constructor.\n-     */\n-    public FieldMapping(String name, Class type, ClassMapping owner) {\n-        super(name, type, owner);\n-        _info = owner.getMappingRepository().newMappingInfo(this);\n-        _val = (ValueMapping) getValue();\n-        _key = (ValueMapping) getKey();\n-        _elem = (ValueMapping) getElement();\n-\n-        setUsesIntermediate(false);\n-        setUsesImplData(Boolean.FALSE);\n-    }\n-\n-    ///////\n-    // ORM\n-    ///////\n-\n-    /**\n-     * Raw mapping data about field's join to parent table, as well as\n-     * miscellaneous specialized columns like order column.\n-     */\n-    public FieldMappingInfo getMappingInfo() {\n-        return _info;\n-    }\n-\n-    /**\n-     * The strategy used to map this mapping.\n-     */\n-    public FieldStrategy getStrategy() {\n-        return _strategy;\n-    }\n-\n-    /**\n-     * The strategy used to map this mapping. The <code>adapt</code>\n-     * parameter determines whether to adapt when mapping the strategy;\n-     * use null if the strategy should not be mapped.\n-     */\n-    public void setStrategy(FieldStrategy strategy, Boolean adapt) {\n-        // set strategy first so we can access it during mapping\n-        FieldStrategy orig = _strategy;\n-        _strategy = strategy;\n-        if (strategy != null) {\n-            try {\n-                strategy.setFieldMapping(this);\n-                if (adapt != null)\n-                    strategy.map(adapt.booleanValue());\n-            } catch (RuntimeException re) {\n-                // reset strategy\n-                _strategy = orig;\n-                throw re;\n-            }\n-\n-            // if set to unmapped, clear defined field cache in parent\n-            if (!isMapped())\n-                getDefiningMapping().clearDefinedFieldCache();\n-        }\n-    }\n-\n-    /**\n-     * The mapping's primary table.\n-     */\n-    public Table getTable() {\n-        if (_fk != null)\n-            return _fk.getTable();\n-        if (_val.getForeignKey() != null)\n-            return _val.getForeignKey().getTable();\n-        return getDefiningMapping().getTable();\n-    }\n-\n-    /**\n-     * I/O information on the join columns.\n-     */\n-    public ColumnIO getJoinColumnIO() {\n-        return (_io == null) ? ColumnIO.UNRESTRICTED : _io;\n-    }\n-\n-    /**\n-     * I/O information on the join columns.\n-     */\n-    public void setJoinColumnIO(ColumnIO io) {\n-        _io = io;\n-    }\n-\n-    /**\n-     * Foreign key linking the field table to the class' primary table.\n-     */\n-    public ForeignKey getJoinForeignKey() {\n-        return _fk;\n-    }\n-\n-    /**\n-     * Foreign key linking the field table to the class' primary table.\n-     */\n-    public void setJoinForeignKey(ForeignKey fk) {\n-        _fk = fk;\n-    }\n-\n-    /**\n-     * Unique constraint on join foreign key columns.\n-     */\n-    public Unique getJoinUnique() {\n-        return _unq;\n-    }\n-\n-    /**\n-     * Unique constraint on join foreign key columns.\n-     */\n-    public void setJoinUnique(Unique unq) {\n-        _unq = unq;\n-    }\n-\n-    public Unique[] getJoinTableUniques() {\n-    \treturn _joinTableUniques;\n-    }\n-    \n-    public void setJoinTableUniques(Unique[] unqs) {\n-    \t_joinTableUniques = unqs;\n-    }\n-    \n-    /**\n-     * Index on join foreign key columns.\n-     */\n-    public Index getJoinIndex() {\n-        return _idx;\n-    }\n-\n-    /**\n-     * Index on join foreign key columns.\n-     */\n-    public void setJoinIndex(Index idx) {\n-        _idx = idx;\n-    }\n-\n-    /**\n-     * Whether to use an outer join from the class' primary table.\n-     */\n-    public boolean isJoinOuter() {\n-        return _outer;\n-    }\n-\n-    /**\n-     * Whether to use an outer join from the class' primary table.\n-     */\n-    public void setJoinOuter(boolean outer) {\n-        _outer = outer;\n-    }\n-\n-    /**\n-     * Field order column, if any.\n-     */\n-    public Column getOrderColumn() {\n-        return _orderCol.getColumn();\n-    }\n-\n-    /**\n-     * Field order column, if any.\n-     */\n-    public void setOrderColumn(Column order) {\n-        _orderCol.setColumn(order);\n-    }\n-\n-    /**\n-     * I/O information for order column.\n-     */\n-    public ColumnIO getOrderColumnIO() {\n-        return _orderCol.getColumnIO();\n-    }\n-\n-    /**\n-     * I/O information for order column.\n-     */\n-    public void setOrderColumnIO(ColumnIO io) {\n-        _orderCol.setColumnIO(io);\n-    }\n-\n-    /**\n-     * Increment the reference count of used schema components.\n-     */\n-    public void refSchemaComponents() {\n-        if (_fk != null) {\n-            _fk.ref();\n-            _fk.refColumns();\n-        }\n-        if (_orderCol.getColumn() != null)\n-            _orderCol.getColumn().ref();\n-        _val.refSchemaComponents();\n-        _key.refSchemaComponents();\n-        _elem.refSchemaComponents();\n-        if (_joinTableUniques != null) {\n-        \tfor (Unique joinUnique : _joinTableUniques) {\n-        \t\tfor (Column col : joinUnique.getColumns()) {\n-        \t\t\tcol.ref();\n-        \t\t}\n-        \t}\n-        }\n-    }\n-\n-    /**\n-     * Clear mapping information, including strategy.\n-     */\n-    public void clearMapping() {\n-        _strategy = null;\n-        _fk = null;\n-        _unq = null;\n-        _idx = null;\n-        _outer = false;\n-        _orderCol.setColumn(null);\n-        _val.clearMapping();\n-        _key.clearMapping();\n-        _elem.clearMapping();\n-        _info.clear();\n-        setResolve(MODE_MAPPING, false);\n-    }\n-\n-    /**\n-     * Update {@link MappingInfo} with our current mapping information.\n-     */\n-    public void syncMappingInfo() {\n-        if (isVersion()) {\n-            // we rely on the fact that the version will setup our mapping\n-            // info correctly when it is synced\n-        } else if (getMappedByMapping() != null) {\n-            _info.clear();\n-            _val.getValueInfo().clear();\n-            _key.getValueInfo().clear();\n-            _elem.getValueInfo().clear();\n-\n-            FieldMapping mapped = getMappedByMapping();\n-            _info.syncStrategy(this);\n-            if (_orderCol.getColumn() != null\n-                && mapped.getOrderColumn() == null)\n-                _info.syncOrderColumn(this);\n-            _val.getValueInfo().setUseClassCriteria\n-                (_val.getUseClassCriteria());\n-            _key.getValueInfo().setUseClassCriteria\n-                (_key.getUseClassCriteria());\n-            _elem.getValueInfo().setUseClassCriteria\n-                (_elem.getUseClassCriteria());\n-        } else {\n-            _info.syncWith(this);\n-            _val.syncMappingInfo();\n-            _key.syncMappingInfo();\n-            _elem.syncMappingInfo();\n-        }\n-    }\n-\n-    /**\n-     * Returns true if field class does not use the \"none\" strategy (including\n-     * if it has a null strategy, and therefore is probably in the process of\n-     * being mapped).\n-     */\n-    public boolean isMapped() {\n-        return _strategy != NoneFieldStrategy.getInstance();\n-    }\n-\n-    //////////////////////\n-    // MetaData interface\n-    //////////////////////\n-\n-    /**\n-     * The eager fetch mode, as one of the eager constants in\n-     * {@link JDBCFetchConfiguration}.\n-     */\n-    public int getEagerFetchMode() {\n-        if (_fetchMode == Integer.MAX_VALUE)\n-            _fetchMode = FetchConfiguration.DEFAULT;\n-        return _fetchMode;\n-    }\n-\n-    /**\n-     * The eager fetch mode, as one of the eager constants in\n-     * {@link JDBCFetchConfiguration}.\n-     */\n-    public void setEagerFetchMode(int mode) {\n-        _fetchMode = mode;\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link FieldMetaData#getRepository}\n-     */\n-    public MappingRepository getMappingRepository() {\n-        return (MappingRepository) getRepository();\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link FieldMetaData#getDefiningMetaData}\n-     */\n-    public ClassMapping getDefiningMapping() {\n-        return (ClassMapping) getDefiningMetaData();\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link FieldMetaData#getDeclaringMetaData}\n-     */\n-    public ClassMapping getDeclaringMapping() {\n-        return (ClassMapping) getDeclaringMetaData();\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from {@link FieldMetaData#getKey}\n-     */\n-    public ValueMapping getKeyMapping() {\n-        return _key;\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from {@link FieldMetaData#getElement}\n-     */\n-    public ValueMapping getElementMapping() {\n-        return _elem;\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from {@link FieldMetaData#getValue}\n-     */\n-    public ValueMapping getValueMapping() {\n-        return (ValueMapping) getValue();\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link FieldMetaData#getMappedByMetaData}\n-     */\n-    public FieldMapping getMappedByMapping() {\n-        return (FieldMapping) getMappedByMetaData();\n-    }\n-\n-    /**\n-     * Convenience method to perform cast from\n-     * {@link FieldMetaData#getInverseMetaDatas}\n-     */\n-    public FieldMapping[] getInverseMappings() {\n-        return (FieldMapping[]) getInverseMetaDatas();\n-    }\n-\n-    public boolean resolve(int mode) {\n-        int cur = getResolve();\n-        if (super.resolve(mode))\n-            return true;\n-        if ((mode & MODE_MAPPING) != 0 && (cur & MODE_MAPPING) == 0)\n-            resolveMapping();\n-        if ((mode & MODE_MAPPING_INIT) != 0 && (cur & MODE_MAPPING_INIT) == 0)\n-            initializeMapping();\n-        return false;\n-    }\n-\n-    /**\n-     * Resolve the mapping information for this field.\n-     */\n-    private void resolveMapping() {\n-        MappingRepository repos = getMappingRepository();\n-        if (repos.getMappingDefaults().defaultMissingInfo()) {\n-            // copy embedded template mapping info\n-            ClassMapping cls = getDefiningMapping();\n-            if (cls.getEmbeddingMapping() != null) {\n-                ClassMapping orig = repos.getMapping(cls.getDescribedType(),\n-                    cls.getEnvClassLoader(), true);\n-                FieldMapping tmplate = orig.getFieldMapping(getName());\n-                if (tmplate != null)\n-                    copyMappingInfo(tmplate);\n-            }\n-            // copy superclass field info\n-            else if (cls.isMapped() && cls.getPCSuperclass() != null\n-                && cls.getDescribedType() != getDeclaringType()) {\n-                FieldMapping sup = cls.getPCSuperclassMapping().\n-                    getFieldMapping(getName());\n-                if (sup != null)\n-                    copyMappingInfo(sup);\n-            }\n-        }\n-\n-        if (_strategy == null) {\n-            if (isVersion())\n-                _strategy = NoneFieldStrategy.getInstance();\n-            else\n-                repos.getStrategyInstaller().installStrategy(this);\n-        }\n-        Log log = getRepository().getLog();\n-        if (log.isTraceEnabled())\n-            log.trace(_loc.get(\"field-strategy\", getName(),\n-                _strategy.getAlias()));\n-\n-        // mark mapped columns\n-        if (_orderCol.getColumn() != null) {\n-            if (getOrderColumnIO().isInsertable(0, false))\n-                _orderCol.getColumn().setFlag(Column.FLAG_DIRECT_INSERT, true);\n-            if (getOrderColumnIO().isUpdatable(0, false))\n-                _orderCol.getColumn().setFlag(Column.FLAG_DIRECT_UPDATE, true);\n-        }\n-        if (_fk != null) {\n-            Column[] cols = _fk.getColumns();\n-            ColumnIO io = getJoinColumnIO();\n-            for (int i = 0; i < cols.length; i++) {\n-                if (io.isInsertable(i, false))\n-                    cols[i].setFlag(Column.FLAG_FK_INSERT, true);\n-                if (io.isUpdatable(i, false))\n-                    cols[i].setFlag(Column.FLAG_FK_UPDATE, true);\n-            }\n-        }\n-\n-        _val.resolve(MODE_MAPPING);\n-        _key.resolve(MODE_MAPPING);\n-        _elem.resolve(MODE_MAPPING);\n-    }\n-\n-    /**\n-     * Copy mapping info from the given instance to this one.\n-     */\n-    public void copyMappingInfo(FieldMapping fm) {\n-        setMappedBy(fm.getMappedBy());\n-        _info.copy(fm.getMappingInfo());\n-        _val.copyMappingInfo(fm.getValueMapping());\n-        _key.copyMappingInfo(fm.getKeyMapping());\n-        _elem.copyMappingInfo(fm.getElementMapping());\n-    }\n-\n-    /**\n-     * Prepare mapping for runtime use.\n-     */\n-    private void initializeMapping() {\n-        _val.resolve(MODE_MAPPING_INIT);\n-        _key.resolve(MODE_MAPPING_INIT);\n-        _val.resolve(MODE_MAPPING_INIT);\n-        if (_strategy != null)\n-            _strategy.initialize();\n-    }\n-\n-    public void copy(FieldMetaData fmd) {\n-        super.copy(fmd);\n-        if (_fetchMode == Integer.MAX_VALUE)\n-            _fetchMode = ((FieldMapping) fmd).getEagerFetchMode();\n-    }\n-\n-    protected boolean validateDataStoreExtensionPrefix(String prefix) {\n-        return \"jdbc-\".equals(prefix);\n-    }\n-\n-    ////////////////////////////////\n-    // FieldStrategy implementation\n-    ////////////////////////////////\n-\n-    public String getAlias() {\n-        return assertStrategy().getAlias();\n-    }\n-\n-    public void map(boolean adapt) {\n-        assertStrategy().map(adapt);\n-    }\n-\n-    /**\n-     * Map this field to its table, optionally requiring that it be\n-     * in another table. Utility method for use by mapping strategies.\n-     */\n-    public void mapJoin(boolean adapt, boolean joinRequired) {\n-        Table table = _info.getTable(this, joinRequired, adapt);\n-\n-        if(table != null && table.equals(getDefiningMapping().getTable())) {\n-            // Don't create a join if the field's table is the same as the\n-            // class's table. \n-            table = null;\n-        }\n-\n-        ForeignKey join = null;\n-        if (table != null)\n-            join = _info.getJoin(this, table, adapt);\n-        if (join == null && joinRequired)\n-            throw new MetaDataException(_loc.get(\"join-required\", this));\n-\n-        if (join == null) {\n-            _info.assertNoJoin(this, true);\n-            _info.assertNoForeignKey(this, !adapt);\n-            _info.assertNoUnique(this, !adapt);\n-            _info.assertNoIndex(this, !adapt);\n-        } else {\n-            _fk = join;\n-            _io = _info.getColumnIO();\n-            _outer = _info.isJoinOuter();\n-            _unq = _info.getJoinUnique(this, false, adapt);\n-            _joinTableUniques = _info.getJoinTableUniques(this, false, adapt);\n-            _idx = _info.getJoinIndex(this, adapt);\n-        }\n-    }\n-\n-    /**\n-     * Maps the primary key on the secondary table for this field, if the\n-     * user's defaults create one. This must be called after\n-     * this field is mapped so that it's table has its columns set.\n-     */\n-    public void mapPrimaryKey(boolean adapt) {\n-        if (adapt && _fk != null && _fk.getTable().getPrimaryKey() == null)\n-            getMappingRepository().getMappingDefaults().\n-                installPrimaryKey(this, _fk.getTable());\n-    }\n-\n-    public void initialize() {\n-        assertStrategy().initialize();\n-    }\n-\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n-        throws SQLException {\n-        assertStrategy().insert(sm, store, rm);\n-    }\n-\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n-        throws SQLException {\n-        assertStrategy().update(sm, store, rm);\n-    }\n-\n-    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n-        throws SQLException {\n-        assertStrategy().delete(sm, store, rm);\n-    }\n-\n-    /**\n-     * Delete the row for this object if the reference foreign key exists.\n-     * Utility method for use by mapping strategies.\n-     */\n-    public void deleteRow(OpenJPAStateManager sm, JDBCStore store,\n-        RowManager rm)\n-        throws SQLException {\n-        if (_fk != null) {\n-            Row row = rm.getRow(getTable(), Row.ACTION_DELETE, sm, true);\n-            row.whereForeignKey(_fk, sm);\n-        }\n-    }\n-\n-    /**\n-     * Return the row to use for this field. This method is meant only for\n-     * single-value fields that might reside in a table that is joined to\n-     * the primary table through the join foreign key. It is not\n-     * meant for multi-valued fields like collections and maps. The method\n-     * checks whether we're using an outer join and if so it deletes the\n-     * field's previous value, then if the field is non-null returns an insert\n-     * row for the new value. The join foreign key will already be set on\n-     * the returned row; mapping strategies just need to set their own values.\n-     * Utility method for use by mapping strategies.\n-     */\n-    public Row getRow(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n-        int action)\n-        throws SQLException {\n-        Row row = null;\n-        boolean newOuterRow = false;\n-        if (_fk != null && _outer && action != Row.ACTION_DELETE) {\n-            // if updating with outer join, delete old value first, then insert;\n-            // we can't just update b/c the row might not exist\n-            if (action == Row.ACTION_UPDATE) {\n-                // maybe some other field already is updating?\n-                row = rm.getRow(getTable(), Row.ACTION_UPDATE, sm, false);\n-                if (row == null) {\n-                    Row del = rm.getRow(getTable(), Row.ACTION_DELETE, sm,\n-                        true);\n-                    del.whereForeignKey(_fk, sm);\n-                }\n-            } else\n-                row = rm.getRow(getTable(), Row.ACTION_INSERT, sm, false);\n-\n-            // only update/insert if the row exists already or the value is\n-            // not null/default\n-            if (row == null && !isNullValue(sm)) {\n-                row = rm.getRow(getTable(), Row.ACTION_INSERT, sm, true);\n-                newOuterRow = true;\n-            }\n-        } else\n-            row = rm.getRow(getTable(), action, sm, true);\n-\n-        // setup fk\n-        if (row != null && _fk != null) {\n-            if (row.getAction() == Row.ACTION_INSERT)\n-                row.setForeignKey(_fk, _io, sm);\n-            else\n-                row.whereForeignKey(_fk, sm);\n-\n-            // if this is a new outer joined row, mark it invalid until\n-            // some mapping actually sets information on it\n-            if (newOuterRow)\n-                row.setValid(false);\n-        }\n-        return row;\n-    }\n-\n-    /**\n-     * Return true if this field is null/default in the given instance.\n-     */\n-    private boolean isNullValue(OpenJPAStateManager sm) {\n-        switch (getTypeCode()) {\n-            case JavaTypes.BOOLEAN:\n-                return !sm.fetchBoolean(getIndex());\n-            case JavaTypes.BYTE:\n-                return sm.fetchByte(getIndex()) == 0;\n-            case JavaTypes.CHAR:\n-                return sm.fetchChar(getIndex()) == 0;\n-            case JavaTypes.DOUBLE:\n-                return sm.fetchDouble(getIndex()) == 0;\n-            case JavaTypes.FLOAT:\n-                return sm.fetchFloat(getIndex()) == 0;\n-            case JavaTypes.INT:\n-                return sm.fetchInt(getIndex()) == 0;\n-            case JavaTypes.LONG:\n-                return sm.fetchLong(getIndex()) == 0;\n-            case JavaTypes.SHORT:\n-                return sm.fetchShort(getIndex()) == 0;\n-            case JavaTypes.STRING:\n-                return sm.fetchString(getIndex()) == null;\n-            default:\n-                return sm.fetchObject(getIndex()) == null;\n-        }\n-    }\n-\n-    public Boolean isCustomInsert(OpenJPAStateManager sm, JDBCStore store) {\n-        return assertStrategy().isCustomInsert(sm, store);\n-    }\n-\n-    public Boolean isCustomUpdate(OpenJPAStateManager sm, JDBCStore store) {\n-        return assertStrategy().isCustomUpdate(sm, store);\n-    }\n-\n-    public Boolean isCustomDelete(OpenJPAStateManager sm, JDBCStore store) {\n-        return assertStrategy().isCustomDelete(sm, store);\n-    }\n-\n-    public void customInsert(OpenJPAStateManager sm, JDBCStore store)\n-        throws SQLException {\n-        assertStrategy().customInsert(sm, store);\n-    }\n-\n-    public void customUpdate(OpenJPAStateManager sm, JDBCStore store)\n-        throws SQLException {\n-        assertStrategy().customUpdate(sm, store);\n-    }\n-\n-    public void customDelete(OpenJPAStateManager sm, JDBCStore store)\n-        throws SQLException {\n-        assertStrategy().customDelete(sm, store);\n-    }\n-\n-    public void setFieldMapping(FieldMapping owner) {\n-        assertStrategy().setFieldMapping(owner);\n-    }\n-\n-    public int supportsSelect(Select sel, int type, OpenJPAStateManager sm,\n-        JDBCStore store, JDBCFetchConfiguration fetch) {\n-        return assertStrategy().supportsSelect(sel, type, sm, store, fetch);\n-    }\n-\n-    public void selectEagerParallel(SelectExecutor sel, OpenJPAStateManager sm,\n-        JDBCStore store, JDBCFetchConfiguration fetch, int eagerMode) {\n-        assertStrategy().selectEagerParallel(sel, sm, store, fetch, eagerMode);\n-    }\n-\n-    public void selectEagerJoin(Select sel, OpenJPAStateManager sm,\n-        JDBCStore store, JDBCFetchConfiguration fetch, int eagerMode) {\n-        assertStrategy().selectEagerJoin(sel, sm, store, fetch, eagerMode);\n-    }\n-\n-    public boolean isEagerSelectToMany() {\n-        return assertStrategy().isEagerSelectToMany();\n-    }\n-\n-    public int select(Select sel, OpenJPAStateManager sm, JDBCStore store,\n-        JDBCFetchConfiguration fetch, int eagerMode) {\n-        return assertStrategy().select(sel, sm, store, fetch, eagerMode);\n-    }\n-\n-    /**\n-     * Return any joins needed to get from the primary table to this table.\n-     */\n-    public Joins join(Select sel) {\n-        if (_fk == null)\n-            return null;\n-\n-        Joins joins = sel.newJoins();\n-        if (_outer)\n-            return joins.outerJoin(_fk, true, false);\n-        return joins.join(_fk, true, false);\n-    }\n-\n-    /**\n-     * Add a <code>wherePrimaryKey</code> or <code>whereForeignKey</code>\n-     * condition to the given select, depending on whether we have a join\n-     * foreign key.\n-     */\n-    public void wherePrimaryKey(Select sel, OpenJPAStateManager sm,\n-        JDBCStore store) {\n-        if (_fk != null)\n-            sel.whereForeignKey(_fk, sm.getObjectId(), getDefiningMapping(),\n-                store);\n-        else\n-            sel.wherePrimaryKey(sm.getObjectId(), getDefiningMapping(),\n-                store);\n-    }\n-\n-    /**\n-     * Add ordering to the given select for all non-relation order values,\n-     * including the synthetic order column, if any.\n-     *\n-     * @param elem the related type we're fetching, or null\n-     * @param joins the joins to this field's table\n-     */\n-    public void orderLocal(Select sel, ClassMapping elem, Joins joins) {\n-        _orderCol.order(sel, elem, joins);\n-        JDBCOrder[] orders = (JDBCOrder[]) getOrders();\n-        for (int i = 0; i < orders.length; i++)\n-            if (!orders[i].isInRelation())\n-                orders[i].order(sel, elem, joins);\n-    }\n-\n-    /**\n-     * Add ordering to the given select for all relation-based values.\n-     *\n-     * @param elem the related type we're fetching\n-     * @param joins the joins across the relation\n-     */\n-    public void orderRelation(Select sel, ClassMapping elem, Joins joins) {\n-        JDBCOrder[] orders = (JDBCOrder[]) getOrders();\n-        for (int i = 0; i < orders.length; i++)\n-            if (orders[i].isInRelation())\n-                orders[i].order(sel, elem, joins);\n-    }\n-\n-    public Object loadEagerParallel(OpenJPAStateManager sm, JDBCStore store,\n-        JDBCFetchConfiguration fetch, Object res)\n-        throws SQLException {\n-        return assertStrategy().loadEagerParallel(sm, store, fetch, res);\n-    }\n-\n-    public void loadEagerJoin(OpenJPAStateManager sm, JDBCStore store,\n-        JDBCFetchConfiguration fetch, Result res)\n-        throws SQLException {\n-        assertStrategy().loadEagerJoin(sm, store, fetch, res);\n-    }\n-\n-    public void load(OpenJPAStateManager sm, JDBCStore store,\n-        JDBCFetchConfiguration fetch, Result res)\n-        throws SQLException {\n-        assertStrategy().load(sm, store, fetch, res);\n-    }\n-\n-    public void load(OpenJPAStateManager sm, JDBCStore store,\n-        JDBCFetchConfiguration fetch)\n-        throws SQLException {\n-        assertStrategy().load(sm, store, fetch);\n-    }\n-\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\n-        return assertStrategy().toDataStoreValue(val, store);\n-    }\n-\n-    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\n-        return assertStrategy().toKeyDataStoreValue(val, store);\n-    }\n-\n-    public void appendIsEmpty(SQLBuffer sql, Select sel, Joins joins) {\n-        assertStrategy().appendIsEmpty(sql, sel, joins);\n-    }\n-\n-    public void appendIsNotEmpty(SQLBuffer sql, Select sel, Joins joins) {\n-        assertStrategy().appendIsNotEmpty(sql, sel, joins);\n-    }\n-\n-    public void appendIsNull(SQLBuffer sql, Select sel, Joins joins) {\n-        assertStrategy().appendIsNull(sql, sel, joins);\n-    }\n-\n-    public void appendIsNotNull(SQLBuffer sql, Select sel, Joins joins) {\n-        assertStrategy().appendIsNotNull(sql, sel, joins);\n-    }\n-\n-    public void appendSize(SQLBuffer sql, Select sel, Joins joins) {\n-        assertStrategy().appendSize(sql, sel, joins);\n-    }\n-\n-    public Joins join(Joins joins, boolean forceOuter) {\n-        return assertStrategy().join(joins, forceOuter);\n-    }\n-\n-    public Joins joinKey(Joins joins, boolean forceOuter) {\n-        return assertStrategy().joinKey(joins, forceOuter);\n-    }\n-\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\n-        boolean traverse) {\n-        return assertStrategy().joinRelation(joins, forceOuter, traverse);\n-    }\n-\n-    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\n-        boolean traverse) {\n-        return assertStrategy().joinKeyRelation(joins, forceOuter, traverse);\n-    }\n-\n-    /**\n-     * Joins from the owning class' table to the table where this field lies\n-     * using the join foreign key. Utility method for use by mapping strategies.\n-     */\n-    public Joins join(Joins joins, boolean forceOuter, boolean toMany) {\n-        if (_fk == null)\n-            return joins;\n-        if (_outer || forceOuter)\n-            return joins.outerJoin(_fk, true, toMany);\n-        return joins.join(_fk, true, toMany);\n-    }\n-\n-    public Object loadProjection(JDBCStore store, JDBCFetchConfiguration fetch,\n-        Result res, Joins joins)\n-        throws SQLException {\n-    \t// OPENJPA-662: Version fields have NoneFieldStrategy -- hence they\n-    \t// need special treatment\n-    \tif (isVersion()) {\n-    \t\treturn getDefiningMapping().getVersion().load(null, store, res);\n-    \t}\n-        return assertStrategy().loadProjection(store, fetch, res, joins);\n-    }\n-\n-    public Object loadKeyProjection(JDBCStore store,\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\n-        throws SQLException {\n-        return assertStrategy()\n-            .loadKeyProjection(store, fetch, res, joins);\n-    }\n-\n-    public boolean isVersionable() {\n-        return assertStrategy().isVersionable();\n-    }\n-\n-    public void where(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n-        Object prevValue)\n-        throws SQLException {\n-        assertStrategy().where(sm, store, rm, prevValue);\n-    }\n-\n-    private FieldStrategy assertStrategy() {\n-        if (_strategy == null)\n-            throw new InternalException();\n-        return _strategy;\n-    }\n-\n-    ///////////////////////////////\n-    // ValueMapping implementation\n-    ///////////////////////////////\n-\n-    public ValueMappingInfo getValueInfo() {\n-        return _val.getValueInfo();\n-    }\n-\n-    public ValueHandler getHandler() {\n-        return _val.getHandler();\n-    }\n-\n-    public void setHandler(ValueHandler handler) {\n-        _val.setHandler(handler);\n-    }\n-\n-    public FieldMapping getFieldMapping() {\n-        return this;\n-    }\n-\n-    public ClassMapping getTypeMapping() {\n-        return _val.getTypeMapping();\n-    }\n-\n-    public ClassMapping getDeclaredTypeMapping() {\n-        return _val.getDeclaredTypeMapping();\n-    }\n-\n-    public ClassMapping getEmbeddedMapping() {\n-        return _val.getEmbeddedMapping();\n-    }\n-\n-    public FieldMapping getValueMappedByMapping() {\n-        return _val.getValueMappedByMapping();\n-    }\n-\n-    public Column[] getColumns() {\n-        // pcl: 6 July 2007: this seems a bit hacky, but if the mapping is a\n-        // version, it will have a NoneFieldMapping (since the version strategy\n-        // for the class takes care of it's mapping), and NoneFieldStrategies\n-        // do not have columns.\n-        if (isVersion())\n-            return getDeclaringMapping().getVersion().getColumns();\n-        else\n-            return _val.getColumns();\n-    }\n-\n-    public void setColumns(Column[] cols) {\n-        _val.setColumns(cols);\n-    }\n-\n-    public ColumnIO getColumnIO() {\n-        return _val.getColumnIO();\n-    }\n-\n-    public void setColumnIO(ColumnIO io) {\n-        _val.setColumnIO(io);\n-    }\n-\n-    public ForeignKey getForeignKey() {\n-        return _val.getForeignKey();\n-    }\n-\n-    public ForeignKey getForeignKey(ClassMapping target) {\n-        return _val.getForeignKey(target);\n-    }\n-\n-    public void setForeignKey(ForeignKey fk) {\n-        _val.setForeignKey(fk);\n-    }\n-\n-    public int getJoinDirection() {\n-        return _val.getJoinDirection();\n-    }\n-\n-    public void setJoinDirection(int direction) {\n-        _val.setJoinDirection(direction);\n-    }\n-\n-    public void setForeignKey(Row row, OpenJPAStateManager sm)\n-        throws SQLException {\n-        _val.setForeignKey(row, sm);\n-    }\n-\n-    public void whereForeignKey(Row row, OpenJPAStateManager sm)\n-        throws SQLException {\n-        _val.whereForeignKey(row, sm);\n-    }\n-\n-    public ClassMapping[] getIndependentTypeMappings() {\n-        return _val.getIndependentTypeMappings();\n-    }\n-\n-    public int getSelectSubclasses() {\n-        return _val.getSelectSubclasses();\n-    }\n-\n-    public Unique getValueUnique() {\n-        return _val.getValueUnique();\n-    }\n-\n-    public void setValueUnique(Unique unq) {\n-        _val.setValueUnique(unq);\n-    }\n-\n-    public Index getValueIndex() {\n-        return _val.getValueIndex();\n-    }\n-\n-    public void setValueIndex(Index idx) {\n-        _val.setValueIndex(idx);\n-    }\n-\n-    public boolean getUseClassCriteria() {\n-        return _val.getUseClassCriteria();\n-    }\n-\n-    public void setUseClassCriteria(boolean criteria) {\n-        _val.setUseClassCriteria(criteria);\n-    }\n-\n-    public int getPolymorphic() {\n-        return _val.getPolymorphic();\n-    }\n-\n-    public void setPolymorphic(int poly) {\n-        _val.setPolymorphic(poly);\n-    }\n-\n-    public void mapConstraints(String name, boolean adapt) {\n-        _val.mapConstraints(name, adapt);\n-    }\n-\n-    public void copyMappingInfo(ValueMapping vm) {\n-        _val.copyMappingInfo(vm);\n-    }\n-}"},{"sha":"fca07397ed24d48bd4b90dac89711aaf1acf34f6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMappingInfo.java","status":"removed","additions":0,"deletions":397,"changes":397,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMappingInfo.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,397 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ColumnIO;\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\n-import org.apache.openjpa.jdbc.schema.Index;\n-import org.apache.openjpa.jdbc.schema.Schema;\n-import org.apache.openjpa.jdbc.schema.SchemaGroup;\n-import org.apache.openjpa.jdbc.schema.Table;\n-import org.apache.openjpa.jdbc.schema.Unique;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.xml.Commentable;\n-import org.apache.openjpa.meta.JavaTypes;\n-import org.apache.openjpa.meta.MetaDataContext;\n-import org.apache.openjpa.util.MetaDataException;\n-import org.apache.openjpa.util.UserException;\n-\n-/**\n- * Information about the mapping from a field to the schema, in raw form.\n- * The columns and tables used in mapping info will not be part of the\n- * {@link SchemaGroup} used at runtime. Rather, they will be structs\n- * with the relevant pieces of information filled in.\n- *\n- * @author Abe White\n- * @author Pinaki Poddar\n- */\n-public class FieldMappingInfo\n-    extends MappingInfo\n-    implements Commentable {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (FieldMappingInfo.class);\n-\n-    private String _tableName = null;\n-    private boolean _outer = false;\n-    private Column _orderCol = null;\n-    private boolean _canOrderCol = true;\n-    private String[] _comments = null;\n-    private List<Unique> _joinTableUniques; // Unique constraints on the JoinTable\n-\n-    /**\n-     * The user-supplied name of the table for this field.\n-     */\n-    public String getTableName() {\n-        return _tableName;\n-    }\n-\n-    /**\n-     * The user-supplied name of the table for this field.\n-     */\n-    public void setTableName(String tableName) {\n-        _tableName = tableName;\n-    }\n-\n-    /**\n-     * Whether the field's table is joined to the class table through an\n-     * outer join.\n-     */\n-    public boolean isJoinOuter() {\n-        return _outer;\n-    }\n-\n-    /**\n-     * Whether the field's table is joined to the class table through an\n-     * outer join.\n-     */\n-    public void setJoinOuter(boolean outer) {\n-        _outer = outer;\n-    }\n-\n-    /**\n-     * Raw synthetic ordering column.\n-     */\n-    public Column getOrderColumn() {\n-        return _orderCol;\n-    }\n-\n-    /**\n-     * Raw synthetic ordering column.\n-     */\n-    public void setOrderColumn(Column order) {\n-        _orderCol = order;\n-    }\n-\n-    /**\n-     * Whether we can have an ordering column.\n-     */\n-    public boolean canOrderColumn() {\n-        return _canOrderCol;\n-    }\n-\n-    /**\n-     * Whether we can have an ordering column.\n-     */\n-    public void setCanOrderColumn(boolean canOrder) {\n-        _canOrderCol = canOrder;\n-    }\n-\n-    /**\n-     * Return the table for the given field, or null if no table given.\n-     */\n-    public Table getTable(final FieldMapping field, boolean create,\n-        boolean adapt) {\n-        if (_tableName == null && !create)\n-            return null;\n-\n-        Table table = field.getDefiningMapping().getTable();\n-        String schemaName = (table == null) ? null \n-            : table.getSchema().getName();\n-\n-        // if we have no join columns defined, there may be class-level join\n-        // information with a more fully-qualified name for our table\n-        String tableName = _tableName;\n-        if (tableName != null && getColumns().isEmpty())\n-            tableName = field.getDefiningMapping().getMappingInfo().\n-                getSecondaryTableName(tableName);\n-\n-        return createTable(field, new TableDefaults() {\n-            public String get(Schema schema) {\n-                // delay this so that we don't do schema reflection for unique\n-                // table name unless necessary\n-                return field.getMappingRepository().getMappingDefaults().\n-                    getTableName(field, schema);\n-            }\n-        }, schemaName, tableName, adapt);\n-    }\n-\n-    /**\n-     * Return the join from the field table to the owning class table.\n-     */\n-    public ForeignKey getJoin(final FieldMapping field, Table table,\n-        boolean adapt) {\n-        // if we have no join columns defined, check class-level join\n-        List cols = getColumns();\n-        if (cols.isEmpty())\n-            cols = field.getDefiningMapping().getMappingInfo().\n-                getSecondaryTableJoinColumns(_tableName);\n-\n-        ForeignKeyDefaults def = new ForeignKeyDefaults() {\n-            public ForeignKey get(Table local, Table foreign, boolean inverse) {\n-                return field.getMappingRepository().getMappingDefaults().\n-                    getJoinForeignKey(field, local, foreign);\n-            }\n-\n-            public void populate(Table local, Table foreign, Column col,\n-                Object target, boolean inverse, int pos, int cols) {\n-                field.getMappingRepository().getMappingDefaults().\n-                    populateJoinColumn(field, local, foreign, col, target,\n-                        pos, cols);\n-            }\n-        };\n-        ClassMapping cls = field.getDefiningMapping();\n-        return createForeignKey(field, \"join\", cols, def, table, cls, cls,\n-            false, adapt);\n-    }\n-\n-    /**\n-     * Unique constraint on the field join.\n-     */\n-    public Unique getJoinUnique(FieldMapping field, boolean def,\n-        boolean adapt) {\n-        ForeignKey fk = field.getJoinForeignKey();\n-        if (fk == null)\n-            return null;\n-\n-        Unique unq = null;\n-        if (fk.getColumns().length > 0)\n-            unq = field.getMappingRepository().getMappingDefaults().\n-                getJoinUnique(field, fk.getTable(), fk.getColumns());\n-        return createUnique(field, \"join\", unq, fk.getColumns(), adapt);\n-    }\n-    \n-    /**\n-     * Add Unique Constraint to the Join Table.\n-     */\n-    public void addJoinTableUnique(Unique u) {\n-    \tif (_joinTableUniques == null)\n-    \t\t_joinTableUniques = new ArrayList<Unique>();\n-    \t_joinTableUniques.add(u);\n-    }\n-    \n-    /**\n-     * Get the unique constraints associated with the Sequence table.\n-     */\n-    public Unique[] getJoinTableUniques(FieldMapping field, boolean def, \n-    \t\tboolean adapt) {\n-        return getUniques(field, _joinTableUniques, def, adapt);\n-    }   \n-    \n-    private Unique[] getUniques(FieldMapping field, List<Unique> uniques, \n-    \t\tboolean def, boolean adapt) {\n-        if (uniques == null || uniques.isEmpty())\n-            return new Unique[0];\n-        Collection<Unique> result = new ArrayList<Unique>();\n-        for (Unique template : uniques) {\n-            Column[] templateColumns = template.getColumns();\n-            Column[] uniqueColumns = new Column[templateColumns.length];\n-            Table table = getTable(field, true, adapt);\n-            for (int i=0; i<uniqueColumns.length; i++) {\n-                String columnName = templateColumns[i].getName();\n-                Column uniqueColumn = table.getColumn(columnName);\n-                uniqueColumns[i] = uniqueColumn;\n-            }\n-            Unique unique = createUnique(field, \"unique\", template,  \n-                uniqueColumns, adapt);\n-            if (unique != null)\n-                result.add(unique);\n-        }\n-        return result.toArray(new Unique[result.size()]);\n-    }   \n-    \n-   /**\n-     * Index on the field join.\n-     */\n-    public Index getJoinIndex(FieldMapping field, boolean adapt) {\n-        ForeignKey fk = field.getJoinForeignKey();\n-        if (fk == null)\n-            return null;\n-\n-        Index idx = null;\n-        if (fk.getColumns().length > 0)\n-            idx = field.getMappingRepository().getMappingDefaults().\n-                getJoinIndex(field, fk.getTable(), fk.getColumns());\n-        return createIndex(field, \"join\", idx, fk.getColumns(), adapt);\n-    }\n-\n-    /**\n-     * Return the ordering column for this field, or null if none.\n-     */\n-    public Column getOrderColumn(FieldMapping field, Table table,\n-        boolean adapt) {\n-        if (_orderCol != null && field.getOrderDeclaration() != null)\n-            throw new MetaDataException(_loc.get(\"order-conflict\", field));\n-\n-        // reset IO\n-        setColumnIO(null);\n-\n-        // has user has explicitly turned ordering off?\n-        if (!_canOrderCol || field.getOrderDeclaration() != null)\n-            return null;\n-\n-        // if no defaults return null\n-        MappingDefaults def = field.getMappingRepository().\n-            getMappingDefaults();\n-        if (_orderCol == null && (!adapt && !def.defaultMissingInfo()))\n-            return null;\n-\n-        Column tmplate = new Column();\n-        tmplate.setName(\"ordr\");\n-        tmplate.setJavaType(JavaTypes.INT);\n-        if (!def.populateOrderColumns(field, table, new Column[]{ tmplate })\n-            && _orderCol == null)\n-            return null;\n-\n-        if (_orderCol != null && (_orderCol.getFlag(Column.FLAG_UNINSERTABLE)\n-            || _orderCol.getFlag(Column.FLAG_UNUPDATABLE))) {\n-            ColumnIO io = new ColumnIO();\n-            io.setInsertable(0, !_orderCol.getFlag(Column.FLAG_UNINSERTABLE));\n-            io.setUpdatable(0, !_orderCol.getFlag(Column.FLAG_UNUPDATABLE));\n-            setColumnIO(io);\n-        }\n-\n-        return mergeColumn(field, \"order\", tmplate, true, _orderCol, table,\n-            adapt, def.defaultMissingInfo());\n-    }\n-\n-    /**\n-     * Synchronize internal information with the mapping data for the given\n-     * field.\n-     */\n-    public void syncWith(FieldMapping field) {\n-        clear(false);\n-\n-        if (field.getJoinForeignKey() != null)\n-            _tableName = field.getMappingRepository().getDBDictionary().\n-                getFullName(field.getTable(), true);\n-\n-        ClassMapping def = field.getDefiningMapping();\n-        setColumnIO(field.getJoinColumnIO());\n-        if (field.getJoinForeignKey() != null && def.getTable() != null)\n-            syncForeignKey(field, field.getJoinForeignKey(),\n-                field.getTable(), def.getTable());\n-        _outer = field.isJoinOuter();\n-\n-        syncIndex(field, field.getJoinIndex());\n-        syncUnique(field, field.getJoinUnique());\n-        syncJoinTableUniques(field, field.getJoinTableUniques());\n-        syncOrderColumn(field);\n-        syncStrategy(field);\n-    }\n-\n-    /**\n-     * Synchronize internal mapping strategy information with the given field.\n-     */\n-    public void syncStrategy(FieldMapping field) {\n-        setStrategy(null);\n-        if (field.getHandler() != null || field.getStrategy() == null)\n-            return;\n-\n-        // explicit strategy if the strategy isn't the expected default\n-        Strategy strat = field.getMappingRepository().defaultStrategy\n-            (field, false);\n-        if (strat == null || !strat.getAlias().equals(field.getAlias()))\n-            setStrategy(field.getAlias());\n-    }\n-\n-    /**\n-     * Synchronize internal order column information with the given field.\n-     */\n-    public void syncOrderColumn(FieldMapping field) {\n-        if (field.getOrderColumn() != null)\n-            _orderCol = syncColumn(field, field.getOrderColumn(), 1, false,\n-                field.getTable(), null, null, false);\n-        else\n-            _orderCol = null;\n-    }\n-    \n-    /**\n-     * Sets internal constraint information to match given mapped constraint.\n-     */\n-    protected void syncJoinTableUniques(MetaDataContext context, Unique[] unqs) {\n-        if (unqs == null) {\n-            _joinTableUniques = null;\n-            return;\n-        }\n-        _joinTableUniques = new ArrayList<Unique>();\n-        for (Unique unique:unqs) {\n-        \tUnique copy = new Unique();\n-        \tcopy.setName(unique.getName());\n-        \tcopy.setDeferred(unique.isDeferred());\n-        \t_joinTableUniques.add(unique);\n-        }\n-    }\n-\n-\n-    public boolean hasSchemaComponents() {\n-        return super.hasSchemaComponents() || _tableName != null\n-            || _orderCol != null;\n-    }\n-\n-    protected void clear(boolean canFlags) {\n-        super.clear(canFlags);\n-        _tableName = null;\n-        _orderCol = null;\n-        if (canFlags)\n-            _canOrderCol = true;\n-    }\n-\n-    public void copy(MappingInfo info) {\n-        super.copy(info);\n-        if (!(info instanceof FieldMappingInfo))\n-            return;\n-\n-        FieldMappingInfo finfo = (FieldMappingInfo) info;\n-        if (_tableName == null)\n-            _tableName = finfo.getTableName();\n-        if (!_outer)\n-            _outer = finfo.isJoinOuter();\n-        if (_canOrderCol && _orderCol == null)\n-            _canOrderCol = finfo.canOrderColumn();\n-        if (_canOrderCol && finfo.getOrderColumn() != null) {\n-            if (_orderCol == null)\n-                _orderCol = new Column();\n-            _orderCol.copy(finfo.getOrderColumn());\n-        }\n-    }\n-\n-    public String[] getComments() {\n-        return (_comments == null) ? EMPTY_COMMENTS : _comments;\n-    }\n-\n-    public void setComments(String[] comments) {\n-        _comments = comments;\n-    }\n-}"},{"sha":"083a9de95721d5df4152d3863635281be9da6cf4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldStrategy.java","status":"removed","additions":0,"deletions":247,"changes":247,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,247 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.jdbc.sql.RowManager;\n-import org.apache.openjpa.jdbc.sql.SQLBuffer;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.jdbc.sql.SelectExecutor;\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\n-\n-/**\n- * Maps a persistent field to the relational schema.\n- *\n- * @author Abe White\n- * @since 0.4.0\n- */\n-public interface FieldStrategy\n-    extends Strategy {\n-\n-    /**\n-     * Set the class mapping using this strategy. This will be called before\n-     * use.\n-     */\n-    public void setFieldMapping(FieldMapping owner);\n-\n-    /**\n-     * Return whether this mapping can perform the given select type.\n-     * Return 0 if the given type is not supported. If the given type is an\n-     * eager parallel type, return the number of UNIONed selects necessary\n-     * to fetch the data. Otherwise, return any positive number if the type\n-     * is supported. The given state manager may be null if selecting\n-     * multiple instances.\n-     *\n-     * @see Select\n-     */\n-    public int supportsSelect(Select sel, int type, OpenJPAStateManager sm,\n-        JDBCStore store, JDBCFetchConfiguration fetch);\n-\n-    /**\n-     * Fill in parallel eager select for related objects.\n-     *\n-     * @see #select\n-     */\n-    public void selectEagerParallel(SelectExecutor sel, OpenJPAStateManager sm,\n-        JDBCStore store, JDBCFetchConfiguration fetch, int eagerMode);\n-\n-    /**\n-     * Fill in joined select to related objects.\n-     *\n-     * @see #select\n-     */\n-    public void selectEagerJoin(Select sel, OpenJPAStateManager sm,\n-        JDBCStore store, JDBCFetchConfiguration fetch, int eagerMode);\n-\n-    /**\n-     * Whether the eager joins or selects used by this field are to-many.\n-     */\n-    public boolean isEagerSelectToMany();\n-\n-    /**\n-     * Select the virtual row columns of this mapping.\n-     *\n-     * @param sel the select to add to\n-     * @param sm the instance being loaded, or null if not\n-     * initialized yet or selecting for multiple instances\n-     * @param store the current store manager\n-     * @param fetch fetch configuration\n-     * @param eagerMode the eager fetch mode to use; this may be more\n-     * restrictive than the mode of the fetch configuration\n-     * @return &gt; 0 if this mapping requires the selected data\n-     * (if any), 0 if it selected data but does not\n-     * require it, or &lt; 0 if no data was selected\n-     */\n-    public int select(Select sel, OpenJPAStateManager sm, JDBCStore store,\n-        JDBCFetchConfiguration fetch, int eagerMode);\n-\n-    /**\n-     * Load the batched eager result.\n-     *\n-     * @param res originally the {@link Result} to load from, but this\n-     * method may return a processed result form that will be\n-     * passed to subsequent calls\n-     */\n-    public Object loadEagerParallel(OpenJPAStateManager sm, JDBCStore store,\n-        JDBCFetchConfiguration fetch, Object res)\n-        throws SQLException;\n-\n-    /**\n-     * Load the joined eager result.\n-     */\n-    public void loadEagerJoin(OpenJPAStateManager sm, JDBCStore store,\n-        JDBCFetchConfiguration fetch, Result res)\n-        throws SQLException;\n-\n-    /**\n-     * Load virtual row data; the given result is not guaranteed to contain\n-     * data for this field, so the field mapping should make sure the\n-     * result contains its needed column data before loading.\n-     */\n-    public void load(OpenJPAStateManager sm, JDBCStore store,\n-        JDBCFetchConfiguration fetch, Result res)\n-        throws SQLException;\n-\n-    /**\n-     * Load secondary data using a connection from the store manager.\n-     */\n-    public void load(OpenJPAStateManager sm, JDBCStore store,\n-        JDBCFetchConfiguration fetch)\n-        throws SQLException;\n-\n-    ///////////\n-    // Queries\n-    ///////////\n-\n-    /**\n-     * Translate the given external field value to its datastore equivalent.\n-     * If the mapping occupies multiple columns in the datastore, return an\n-     * object array, else return a single object. Simply returns the given\n-     * object by default.\n-     */\n-    public Object toDataStoreValue(Object val, JDBCStore store);\n-\n-    /**\n-     * Translate the given key value to its datastore equivalent. If the\n-     * mapping occupies multiple columns in the datastore, return an object\n-     * array, else return a single object. Simply returns the given object by\n-     * default.\n-     */\n-    public Object toKeyDataStoreValue(Object val, JDBCStore store);\n-\n-    /**\n-     * Append a where clause to the given statement checking if this value\n-     * is empty. Appends impossible-to-satisfy SQL by default.\n-     */\n-    public void appendIsEmpty(SQLBuffer sql, Select sel, Joins joins);\n-\n-    /**\n-     * Append a where clause to the given statement checking if this value\n-     * is not empty. Appends always-satisfied SQL by default.\n-     */\n-    public void appendIsNotEmpty(SQLBuffer sql, Select sel, Joins joins);\n-\n-    /**\n-     * Append a where clause to the given statement checking if this value\n-     * is null.\n-     */\n-    public void appendIsNull(SQLBuffer sql, Select sel, Joins joins);\n-\n-    /**\n-     * Append a where clause to the given statement checking if this value\n-     * is not null.\n-     */\n-    public void appendIsNotNull(SQLBuffer sql, Select sel, Joins joins);\n-\n-    /**\n-     * Append a where clause to the given statement checking the size\n-     * of the value.\n-     */\n-    public void appendSize(SQLBuffer sql, Select sel, Joins joins);\n-\n-    /**\n-     * Join this value to the class table. Does nothing by default.\n-     */\n-    public Joins join(Joins joins, boolean forceOuter);\n-\n-    /**\n-     * Join the key value to the class table. Does nothing by default.\n-     */\n-    public Joins joinKey(Joins joins, boolean forceOuter);\n-\n-    /**\n-     * Join this value's table to the table for the related first class object\n-     * type, if any. Does nothing by default.\n-     *\n-     * @param traverse if true, throw proper exception if it is not\n-     * possible for this mapping to traverse into the related type\n-     */\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\n-        boolean traverse);\n-\n-    /**\n-     * Join this value's table to the table for the related first class object\n-     * key type, if any. Does nothing by default.\n-     *\n-     * @param traverse if true, throw proper exception if it is not\n-     * possible for this mapping to traverse into the related type\n-     */\n-    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\n-        boolean traverse);\n-\n-    /**\n-     * Load this field value using the given result. The result\n-     * will contain the columns from {@link ValueMapping#getColumns}.\n-     */\n-    public Object loadProjection(JDBCStore store, JDBCFetchConfiguration fetch,\n-        Result res, Joins joins)\n-        throws SQLException;\n-\n-    /**\n-     * Load this field's key value using the given result. The result will\n-     * contain the columns from {@link ValueMapping#getColumns}.\n-     */\n-    public Object loadKeyProjection(JDBCStore store,\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\n-        throws SQLException;\n-\n-    //////////////\n-    // Versioning\n-    //////////////\n-\n-    /**\n-     * Return true if this field can be used as part of a state image for\n-     * optimistic locking.\n-     */\n-    public boolean isVersionable();\n-\n-    /**\n-     * Add a WHERE condition to the row for this field such that the field's\n-     * current DB value must equal the given previous value. Only versionable\n-     * mappings must implement this method meaningfully.\n-     */\n-    public void where(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n-        Object prevValue)\n-        throws SQLException;\n-}"},{"sha":"1224cc304bf19fbc8d1b3c7de6b71968eca46bf1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCColumnOrder.java","status":"removed","additions":0,"deletions":87,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCColumnOrder.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCColumnOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCColumnOrder.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,87 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.util.Comparator;\n-\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ColumnIO;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.Select;\n-\n-/**\n- * Order by a synthetic order column.\n- *\n- * @author Abe White\n- */\n-class JDBCColumnOrder\n-    implements JDBCOrder {\n-\n-    private Column _col = null;\n-    private ColumnIO _io = null;\n-\n-    /**\n-     * The synthetic column.\n-     */\n-    public Column getColumn() {\n-        return _col;\n-    }\n-\n-    /**\n-     * The synthetic column.\n-     */\n-    public void setColumn(Column col) {\n-        _col = col;\n-    }\n-\n-    /**\n-     * I/O restrictions for the synthetic column.\n-     */\n-    public ColumnIO getColumnIO() {\n-        return (_io == null) ? ColumnIO.UNRESTRICTED : _io;\n-    }\n-\n-    /**\n-     * I/O restrictions for the synthetic column.\n-     */\n-    public void setColumnIO(ColumnIO io) {\n-        _io = io;\n-    }\n-\n-    public String getName() {\n-        return (_col == null) ? \"\" : _col.getName();\n-    }\n-\n-    public boolean isAscending() {\n-        return true;\n-    }\n-\n-    public Comparator getComparator() {\n-        return null;\n-    }\n-\n-    public boolean isInRelation() {\n-        return false;\n-    }\n-\n-    public void order(Select sel, ClassMapping elem, Joins joins) {\n-        if (_col != null)\n-            sel.orderBy(_col, true, joins, true);\n-    }\n-}"},{"sha":"739fcbf942dec52bd5d1ec572d84d096612a0636","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCOrder.java","status":"removed","additions":0,"deletions":46,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCOrder.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCOrder.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,46 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.meta.Order;\n-\n-/**\n- * Order in the datastore using JDBC.\n- *\n- * @author Abe White\n- */\n-interface JDBCOrder\n-    extends Order {\n-\n-    /**\n-     * Whether the value is a member of the field's related type, rather than\n-     * columns of the field itself.\n-     */\n-    public boolean isInRelation();\n-\n-    /**\n-     * Order by this value.\n-     *\n-     * @param elem if this value has independent mappings, the mapping\n-     * we're selecting\n-     */\n-    public void order(Select sel, ClassMapping elem, Joins joins);\n-}"},{"sha":"427cde0ad867245a51e9ecbd9b64243dac050b40","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCRelatedFieldOrder.java","status":"removed","additions":0,"deletions":72,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCRelatedFieldOrder.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCRelatedFieldOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCRelatedFieldOrder.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,72 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.util.Comparator;\n-\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.util.MetaDataException;\n-\n-/**\n- * Use the database to order by a field in the related type.\n- *\n- * @author Abe White\n- */\n-class JDBCRelatedFieldOrder\n-    implements JDBCOrder {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (JDBCRelatedFieldOrder.class);\n-\n-    private final FieldMapping _fm;\n-    private final boolean _asc;\n-\n-    public JDBCRelatedFieldOrder(FieldMapping owner, FieldMapping rel,\n-        boolean asc) {\n-        if (!rel.isInDefaultFetchGroup() && !rel.isPrimaryKey())\n-            throw new MetaDataException(_loc.get(\"nondfg-field-orderable\",\n-                owner, rel.getName()));\n-\n-        _fm = rel;\n-        _asc = asc;\n-    }\n-\n-    public String getName() {\n-        return _fm.getName();\n-    }\n-\n-    public boolean isAscending() {\n-        return _asc;\n-    }\n-\n-    public Comparator getComparator() {\n-        return null;\n-    }\n-\n-    public boolean isInRelation() {\n-        return true;\n-    }\n-\n-    public void order(Select sel, ClassMapping elem, Joins joins) {\n-        FieldMapping fm = elem.getFieldMapping(_fm.getIndex());\n-        sel.orderBy(fm.getColumns(), _asc, joins, false);\n-    }\n-}"},{"sha":"343a9010a752f931ad241a71035bc157f2a8983d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCValueOrder.java","status":"removed","additions":0,"deletions":67,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCValueOrder.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCValueOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCValueOrder.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,67 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.util.Comparator;\n-\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.Select;\n-import org.apache.openjpa.meta.Order;\n-\n-/**\n- * Order by value columns, which are the primary key columns in the case\n- * of a relation field.\n- *\n- * @author Abe White\n- */\n-class JDBCValueOrder\n-    implements JDBCOrder {\n-\n-    private final FieldMapping _fm;\n-    private final boolean _asc;\n-\n-    public JDBCValueOrder(FieldMapping fm, boolean asc) {\n-        _fm = fm;\n-        _asc = asc;\n-    }\n-\n-    public String getName() {\n-        return Order.ELEMENT;\n-    }\n-\n-    public boolean isAscending() {\n-        return _asc;\n-    }\n-\n-    public Comparator getComparator() {\n-        return null;\n-    }\n-\n-    public boolean isInRelation() {\n-        return _fm.getElement().getTypeMetaData() != null;\n-    }\n-\n-    public void order(Select sel, ClassMapping elem, Joins joins) {\n-        if (elem != null)\n-            sel.orderBy(elem.getPrimaryKeyColumns(), _asc, joins, false);\n-        else\n-            sel.orderBy(_fm.getElementMapping().getColumns(), _asc,\n-                joins, false);\n-    }\n-}"},{"sha":"43f9087c1d8641bc5e4bb8941a58f0651ca6b1b3","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JavaSQLTypes.java","status":"removed","additions":0,"deletions":164,"changes":164,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JavaSQLTypes.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JavaSQLTypes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JavaSQLTypes.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,164 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n-import java.sql.Time;\n-import java.sql.Timestamp;\n-\n-import org.apache.openjpa.meta.JavaTypes;\n-import serp.util.Numbers;\n-\n-/**\n- * Java SQL type constants.\n- *\n- * @author Abe White\n- */\n-public class JavaSQLTypes\n-    extends JavaTypes {\n-\n-    // constants for the sql types that aren't directly supported by\n-    // OpenJPA; make sure these don't conflict with our standard metadata types\n-    public static final int SQL_ARRAY = 1000;\n-    public static final int ASCII_STREAM = 1001;\n-    public static final int BINARY_STREAM = 1002;\n-    public static final int BLOB = 1003;\n-    public static final int BYTES = 1004;\n-    public static final int CHAR_STREAM = 1005;\n-    public static final int CLOB = 1006;\n-    public static final int SQL_DATE = 1007;\n-    public static final int SQL_OBJECT = 1008;\n-    public static final int REF = 1009;\n-    public static final int TIME = 1010;\n-    public static final int TIMESTAMP = 1011;\n-    public static final int JDBC_DEFAULT = 1012;\n-\n-    private static final Byte ZERO_BYTE = new Byte((byte) 0);\n-    private static final Character ZERO_CHAR = new Character((char) 0);\n-    private static final Double ZERO_DOUBLE = new Double(0d);\n-    private static final Float ZERO_FLOAT = new Float(0f);\n-    private static final Short ZERO_SHORT = new Short((short) 0);\n-    private static final BigDecimal ZERO_BIGDECIMAL = new BigDecimal(0d);\n-\n-    private static final Byte NONZERO_BYTE = new Byte((byte) 1);\n-    private static final Character NONZERO_CHAR = new Character((char) 'a');\n-    private static final Double NONZERO_DOUBLE = new Double(1d);\n-    private static final Float NONZERO_FLOAT = new Float(1f);\n-    private static final Short NONZERO_SHORT = new Short((short) 1);\n-    private static final BigInteger NONZERO_BIGINTEGER = new BigInteger(\"1\");\n-    private static final BigDecimal NONZERO_BIGDECIMAL = new BigDecimal(1d);\n-\n-    /**\n-     * Return the proper date typecode.\n-     */\n-    public static int getDateTypeCode(Class dtype) {\n-        if (dtype == java.util.Date.class)\n-            return DATE;\n-        if (dtype == java.sql.Date.class)\n-            return SQL_DATE;\n-        if (dtype == Timestamp.class)\n-            return TIMESTAMP;\n-        if (dtype == Time.class)\n-            return TIME;\n-        return OBJECT;\n-    }\n-\n-    /**\n-     * Return an empty value object for the given type code.\n-     */\n-    public static Object getEmptyValue(int type) {\n-        switch (type) {\n-            case JavaTypes.STRING:\n-                return \"\";\n-            case JavaTypes.BOOLEAN:\n-            case JavaTypes.BOOLEAN_OBJ:\n-                return Boolean.FALSE;\n-            case JavaTypes.BYTE:\n-            case JavaTypes.BYTE_OBJ:\n-                return ZERO_BYTE;\n-            case JavaTypes.CHAR:\n-            case JavaTypes.CHAR_OBJ:\n-                return ZERO_CHAR;\n-            case JavaTypes.DOUBLE:\n-            case JavaTypes.DOUBLE_OBJ:\n-                return ZERO_DOUBLE;\n-            case JavaTypes.FLOAT:\n-            case JavaTypes.FLOAT_OBJ:\n-                return ZERO_FLOAT;\n-            case JavaTypes.INT:\n-            case JavaTypes.INT_OBJ:\n-                return Numbers.valueOf(0);\n-            case JavaTypes.LONG:\n-            case JavaTypes.LONG_OBJ:\n-                return Numbers.valueOf(0L);\n-            case JavaTypes.SHORT:\n-            case JavaTypes.SHORT_OBJ:\n-                return ZERO_SHORT;\n-            case JavaTypes.BIGINTEGER:\n-                return BigInteger.ZERO;\n-            case JavaTypes.BIGDECIMAL:\n-            case JavaTypes.NUMBER:\n-                return ZERO_BIGDECIMAL;\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    /**\n-     * Return a non-empty value object for the given type code.\n-     */\n-    public static Object getNonEmptyValue(int type) {\n-        switch (type) {\n-            case JavaTypes.STRING:\n-                return \"x\";\n-            case JavaTypes.BOOLEAN:\n-            case JavaTypes.BOOLEAN_OBJ:\n-                return Boolean.TRUE;\n-            case JavaTypes.BYTE:\n-            case JavaTypes.BYTE_OBJ:\n-                return NONZERO_BYTE;\n-            case JavaTypes.CHAR:\n-            case JavaTypes.CHAR_OBJ:\n-                return NONZERO_CHAR;\n-            case JavaTypes.DOUBLE:\n-            case JavaTypes.DOUBLE_OBJ:\n-                return NONZERO_DOUBLE;\n-            case JavaTypes.FLOAT:\n-            case JavaTypes.FLOAT_OBJ:\n-                return NONZERO_FLOAT;\n-            case JavaTypes.INT:\n-            case JavaTypes.INT_OBJ:\n-                return Numbers.valueOf(1);\n-            case JavaTypes.LONG:\n-            case JavaTypes.LONG_OBJ:\n-                return Numbers.valueOf(1L);\n-            case JavaTypes.SHORT:\n-            case JavaTypes.SHORT_OBJ:\n-                return NONZERO_SHORT;\n-            case JavaTypes.BIGINTEGER:\n-                return NONZERO_BIGINTEGER;\n-            case JavaTypes.BIGDECIMAL:\n-            case JavaTypes.NUMBER:\n-                return NONZERO_BIGDECIMAL;\n-            default:\n-                return null;\n-        }\n-    }\n-}"},{"sha":"e2142b442c93b109f2cdfad50c4475dfe91a3fbb","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Joinable.java","status":"removed","additions":0,"deletions":91,"changes":91,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Joinable.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Joinable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Joinable.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,91 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.io.Serializable;\n-import java.sql.SQLException;\n-\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.jdbc.sql.Result;\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\n-\n-/**\n- * Represents a value that can be joined to. Any column that a user\n- * joins to must be \"owned\" by an entity that implements this interface.\n- * The system maps columns to joinables to be able to decompose oids and\n- * field values into individual join values on a per-column basis. This\n- * allows us to support joins to only some of the columns of a mapping, and\n- * to be loose with the ordering of foreign key columns relative to the\n- * ordering of the joined-to columns. Having a separate interface for\n- * joinables also allows us to perform tricks such as a vertically-mapped\n- * application identity subclass transparently transforming columns of its\n- * foreign key to the corresponding primary key fields in the base class.\n- *\n- * @author Abe White\n- */\n-public interface Joinable \n-    extends Serializable {\n-\n-    /**\n-     * Return the field index of this joinable, or -1 if not a field.\n-     */\n-    public int getFieldIndex();\n-\n-    /**\n-     * Return the value for this joinable from the given result, using the\n-     * given columns. If the given foreign key is non-null, use the foreign\n-     * key's columns by translating the given columns through\n-     * {@link ForeignKey#getColumn}.\n-     */\n-    public Object getPrimaryKeyValue(Result res, Column[] cols, ForeignKey fk,\n-        JDBCStore store, Joins joins)\n-        throws SQLException;\n-\n-    /**\n-     * The columns managed by this joinable.\n-     */\n-    public Column[] getColumns();\n-\n-    /**\n-     * Return the join value of the given column.\n-     *\n-     * @param val the value of the field for this joinable\n-     * @param col the column of this joinable whose value to return\n-     */\n-    public Object getJoinValue(Object val, Column col, JDBCStore store);\n-\n-    /**\n-     * Return the join value of the given column.\n-     *\n-     * @param sm the instance from which to get the value\n-     * @param col the column whose value to return\n-     */\n-    public Object getJoinValue(OpenJPAStateManager sm, Column col,\n-        JDBCStore store);\n-\n-    /**\n-     * Use the given auto-assigned value to set this join value's field\n-     * on the given instance.\n-     */\n-    public void setAutoAssignedValue(OpenJPAStateManager sm, JDBCStore store,\n-        Column col, Object autogen);\n-}"},{"sha":"d919d536c3a57232c8657e1aaacb47bff363eac9","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaults.java","status":"removed","additions":0,"deletions":307,"changes":307,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaults.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,307 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\n-import org.apache.openjpa.jdbc.schema.Index;\n-import org.apache.openjpa.jdbc.schema.Schema;\n-import org.apache.openjpa.jdbc.schema.Table;\n-import org.apache.openjpa.jdbc.schema.Unique;\n-\n-/**\n- * Generates default names for tables, columns, indexes, constraints, etc.\n- *\n- * @author Abe White\n- */\n-public interface MappingDefaults {\n-\n-    /**\n-     * Whether to fill in missing mapping information at runtime with the\n-     * default values supplied by this plugin. A value of false means that\n-     * all mapping information must be present at runtime.\n-     */\n-    public boolean defaultMissingInfo();\n-\n-    /**\n-     * The default for whether relations use the related object's\n-     * expected class as part of the join criteria.\n-     */\n-    public boolean useClassCriteria();\n-\n-    /**\n-     * Default mapping strategy when there is no explicit strategy\n-     * and no hierarchy strategy given.\n-     *\n-     * @param cls the class; will not be mapped, but superclass and raw\n-     * {@link MappingInfo} will be available\n-     * @param adapt whether we can adapt the mapping or schema\n-     * @return the strategy alias or a strategy instance, or null\n-     */\n-    public Object getStrategy(ClassMapping cls, boolean adapt);\n-\n-    /**\n-     * Default version mapping strategy when there is no explicit strategy.\n-     *\n-     * @param vers the version; will not be mapped, but raw\n-     * {@link MappingInfo} will be available\n-     * @param adapt whether we can adapt the mapping or schema\n-     * @return the strategy alias or a strategy instance, or null\n-     */\n-    public Object getStrategy(Version vers, boolean adapt);\n-\n-    /**\n-     * Default discriminator mapping strategy when there is no explicit\n-     * strategy.\n-     *\n-     * @param disc the discriminator; will not be mapped, but raw\n-     * {@link MappingInfo} will be available\n-     * @param adapt whether we can adapt the mapping or schema\n-     * @return the strategy alias or a strategy instance, or null\n-     */\n-    public Object getStrategy(Discriminator disc, boolean adapt);\n-\n-    /**\n-     * Custom handler or strategy for the given field, or null if none\n-     * has been registered.\n-     *\n-     * @param vm the value mapping; will not be mapped, but raw\n-     * {@link MappingInfo} will be available\n-     * @param type the value type\n-     * @param adapt whether we can adapt the mapping or schema\n-     * @return the handler/strategy alias or instance, or null\n-     */\n-    public Object getStrategy(ValueMapping vm, Class type, boolean adapt);\n-\n-    /**\n-     * Return the default discriminator value for the given instance.\n-     */\n-    public Object getDiscriminatorValue(Discriminator disc, boolean adapt);\n-\n-    /**\n-     * Return the default table name for the given class. This method is\n-     * only called for classes mapped to their own table.\n-     */\n-    public String getTableName(ClassMapping cls, Schema defaultSchema);\n-\n-    /**\n-     * Return the default secondary table name for the given field. This\n-     * method is only called for fields whose strategy requires a secondary\n-     * table.\n-     */\n-    public String getTableName(FieldMapping fm, Schema defaultSchema);\n-\n-    /**\n-     * Fill in default information for the given datastore identity columns.\n-     * The columns' name and Java type will already be populated with generic\n-     * defaults that may be replaced.\n-     */\n-    public void populateDataStoreIdColumns(ClassMapping cls, Table table,\n-        Column[] cols);\n-\n-    /**\n-     * Fill in default information for the given version columns.\n-     * The columns' name and Java type will already be populated with generic\n-     * defaults that may be replaced.\n-     */\n-    public void populateColumns(Version vers, Table table, Column[] cols);\n-\n-    /**\n-     * Fill in default information for the given discriminator columns.\n-     * The columns' name and Java type will already be populated with generic\n-     * defaults that may be replaced.\n-     */\n-    public void populateColumns(Discriminator disc, Table table,\n-        Column[] cols);\n-\n-    /**\n-     * Fill in default information for the given column used to join a class\n-     * to its superclass table. The column will be a clone of the target\n-     * column, or have its name and Java type set in the case of a constant\n-     * target.\n-     *\n-     * @param target the target of this column in the join; may be\n-     * another column or a constant value\n-     * @param pos the index of this column in the logical foreign key\n-     * @param cols the number of columns in the logical foreign key\n-     */\n-    public void populateJoinColumn(ClassMapping cm, Table local, Table foreign,\n-        Column col, Object target, int pos, int cols);\n-\n-    /**\n-     * Fill in default information for the given column used to join a field\n-     * to its defining class' table. The column will be a clone of the target\n-     * column, or have its name and Java type set in the case of a constant\n-     * target.\n-     *\n-     * @param target the target of this column in the join; may be\n-     * another column or a constant value\n-     * @param pos the index of this column in the logical foreign key\n-     * @param cols the number of columns in the logical foreign key\n-     */\n-    public void populateJoinColumn(FieldMapping fm, Table local, Table foreign,\n-        Column col, Object target, int pos, int cols);\n-\n-    /**\n-     * Fill in default information for the given column used to join a value\n-     * to its related type. The column will be a clone of the target\n-     * column, or have its name and Java type set in the case of a constant\n-     * target.\n-     *\n-     * @param name base name for value, as decided by mapping\n-     * @param target the target of this column in the join; may be\n-     * another column or a constant value\n-     * @param inverse whether this is an inverse foreign key\n-     * @param pos the index of this column in the logical foreign key\n-     * @param cols the number of columns in the logical foreign key\n-     */\n-    public void populateForeignKeyColumn(ValueMapping vm, String name,\n-        Table local, Table foreign, Column col, Object target, boolean inverse,\n-        int pos, int cols);\n-\n-    /**\n-     * Fill in default information for the given value columns.\n-     * The columns' name and Java type will already be populated with generic\n-     * defaults that may be replaced.\n-     *\n-     * @param name base name for value, as decided by mapping\n-     */\n-    public void populateColumns(ValueMapping vm, String name, Table table,\n-        Column[] cols);\n-\n-    /**\n-     * Fill in default information for the given order columns.\n-     * The columns' name and Java type will already be populated with generic\n-     * defaults that may be replaced.\n-     *\n-     * @return false if the given field should not have order columns\n-     * by default; fill in default information even when returning\n-     * false in case the user forces ordering\n-     */\n-    public boolean populateOrderColumns(FieldMapping fm, Table table,\n-        Column[] cols);\n-\n-    /**\n-     * Fill in default information for the given null indicator columns.\n-     * The columns' name and Java type will already be populated with generic\n-     * defaults that may be replaced.\n-     *\n-     * @param name base name for value, as decided by mapping\n-     * @return false if the given value should not have null indicator\n-     * columns by default; fill in default information even\n-     * when returning false in case the user forces an indicator\n-     */\n-    public boolean populateNullIndicatorColumns(ValueMapping vm, String name,\n-        Table table, Column[] cols);\n-\n-    /**\n-     * Return a default foreign key for the join from this class' table to its\n-     * superclass' table, or null for a logical foreign key only. Do not\n-     * add columns to the key or add the key to the table; only fill in\n-     * its information such as name, delete action, etc.\n-     */\n-    public ForeignKey getJoinForeignKey(ClassMapping cls, Table local,\n-        Table foreign);\n-\n-    /**\n-     * Return a default foreign key for the join from this field's table to its\n-     * defining class' table, or null for a logical foreign key only. Do not\n-     * add columns to the key or add the key to the table; only fill in\n-     * its information such as name, delete action, etc.\n-     */\n-    public ForeignKey getJoinForeignKey(FieldMapping fm, Table local,\n-        Table foreign);\n-\n-    /**\n-     * Return a default foreign key for the join from this value to its\n-     * related type, or null for a logical foreign key only. Do not\n-     * add columns to the key or add the key to the table; only fill in\n-     * its information such as name, delete action, etc.\n-     *\n-     * @param name base name for value, as decided by mapping\n-     * @param inverse whether this is an inverse key\n-     */\n-    public ForeignKey getForeignKey(ValueMapping vm, String name, Table local,\n-        Table foreign, boolean inverse);\n-\n-    /**\n-     * Return a default index for the join, or null if the\n-     * join columns should not be indexed by default. Do not\n-     * add columns to the index or add the index to the table; only fill in\n-     * its information such as name, uniqueness, etc.\n-     */\n-    public Index getJoinIndex(FieldMapping fm, Table table, Column[] cols);\n-\n-    /**\n-     * Return a default index for the value, or null if the value columns\n-     * should not be indexed by default. Do not add columns to the index or\n-     * add the index to the table; only fill in its information such as name,\n-     * uniqueness, etc.\n-     *\n-     * @param name base name for value, as decided by mapping\n-     */\n-    public Index getIndex(ValueMapping vm, String name, Table table,\n-        Column[] cols);\n-\n-    /**\n-     * Return a default index for the version, or null if the\n-     * version columns should not be indexed by default. Do not\n-     * add columns to the index or add the index to the table; only fill in\n-     * its information such as name, uniqueness, etc.\n-     */\n-    public Index getIndex(Version vers, Table table, Column[] cols);\n-\n-    /**\n-     * Return a default index for the discriminator, or null if the\n-     * discriminator columns should not be indexed by default. Do not\n-     * add columns to the index or add the index to the table; only fill in\n-     * its information such as name, uniqueness, etc.\n-     */\n-    public Index getIndex(Discriminator disc, Table table, Column[] cols);\n-\n-    /**\n-     * Return a default constraint for the join, or null if the join columns\n-     * should not be constrained by default. Do not add columns to the\n-     * constraint or add the constraint to the table; only fill in its\n-     * information such as name, deferrability, etc.\n-     */\n-    public Unique getJoinUnique(FieldMapping fm, Table table, Column[] cols);\n-\n-    /**\n-     * Return a default constraint for the value, or null if the value columns\n-     * should not be constrained by default. Do not add columns to the\n-     * constraint or add the constraint to the table; only fill in its\n-     * information such as name, deferrability, etc.\n-     *\n-     * @param name base name for value, as decided by mapping\n-     */\n-    public Unique getUnique(ValueMapping vm, String name, Table table,\n-        Column[] cols);\n-\n-    /**\n-     * Return the name of the primary key for the table of the given class,\n-     * or null for database default.\n-     */\n-    public String getPrimaryKeyName(ClassMapping cm, Table table);\n-\n-    /**\n-     * If desired, install a primary key on the given secondary table.\n-     */\n-    public void installPrimaryKey(FieldMapping fm, Table table);\n-}"},{"sha":"7f28dadda517aa79a2ae391ba3f8c0b8c34aa0cc","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaultsImpl.java","status":"removed","additions":0,"deletions":775,"changes":775,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaultsImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaultsImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaultsImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,775 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Properties;\n-\n-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n-import org.apache.openjpa.jdbc.meta.strats.UntypedPCValueHandler;\n-import org.apache.openjpa.jdbc.meta.strats.EnumValueHandler;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\n-import org.apache.openjpa.jdbc.schema.Index;\n-import org.apache.openjpa.jdbc.schema.Schema;\n-import org.apache.openjpa.jdbc.schema.Table;\n-import org.apache.openjpa.jdbc.schema.Unique;\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\n-import org.apache.openjpa.lib.conf.Configurable;\n-import org.apache.openjpa.lib.conf.Configuration;\n-import org.apache.openjpa.lib.conf.Configurations;\n-import org.apache.openjpa.lib.util.JavaVersions;\n-import org.apache.openjpa.meta.JavaTypes;\n-import serp.util.Strings;\n-\n-/**\n- * Default implementation of {@link MappingDefaults}.\n- *\n- * @author Abe White\n- */\n-public class MappingDefaultsImpl\n-    implements MappingDefaults, Configurable {\n-\n-    protected transient DBDictionary dict = null;\n-    private String _baseClassStrategy = null;\n-    private String _subclassStrategy = null;\n-    private String _versionStrategy = null;\n-    private String _discStrategy = null;\n-    private final Map _fieldMap = new HashMap();\n-    private boolean _defMissing = false;\n-    private boolean _classCriteria = false;\n-    private int _joinFKAction = ForeignKey.ACTION_NONE;\n-    private int _fkAction = ForeignKey.ACTION_NONE;\n-    private boolean _defer = false;\n-    private boolean _indexFK = true;\n-    private boolean _indexDisc = true;\n-    private boolean _indexVers = false;\n-    private boolean _orderLists = true;\n-    private boolean _addNullInd = false;\n-    private boolean _ordinalEnum = false;\n-    private boolean _stringifyUnmapped = false;\n-    private String _dsIdName = null;\n-    private String _versName = null;\n-    private String _discName = null;\n-    private String _orderName = null;\n-    private String _nullIndName = null;\n-    private boolean _removeHungarianNotation = false;\n-\n-    public boolean isRemoveHungarianNotation() {\n-        return _removeHungarianNotation;\n-    }\n-\n-    public void setRemoveHungarianNotation(boolean removeHungarianNotation) {\n-        this._removeHungarianNotation = removeHungarianNotation;\n-    }\n-\n-    /**\n-     * Default base class strategy alias.\n-     */\n-    public String getBaseClassStrategy() {\n-        return _baseClassStrategy;\n-    }\n-\n-    /**\n-     * Default base class strategy alias.\n-     */\n-    public void setBaseClassStrategy(String baseClassStrategy) {\n-        _baseClassStrategy = baseClassStrategy;\n-    }\n-\n-    /**\n-     * Default subclass strategy alias.\n-     */\n-    public String getSubclassStrategy() {\n-        return _subclassStrategy;\n-    }\n-\n-    /**\n-     * Default subclass strategy alias.\n-     */\n-    public void setSubclassStrategy(String subclassStrategy) {\n-        _subclassStrategy = subclassStrategy;\n-    }\n-\n-    /**\n-     * Default version strategy alias.\n-     */\n-    public String getVersionStrategy() {\n-        return _versionStrategy;\n-    }\n-\n-    /**\n-     * Default version strategy alias.\n-     */\n-    public void setVersionStrategy(String versionStrategy) {\n-        _versionStrategy = versionStrategy;\n-    }\n-\n-    /**\n-     * Default discriminator strategy alias.\n-     */\n-    public String getDiscriminatorStrategy() {\n-        return _discStrategy;\n-    }\n-\n-    /**\n-     * Default discriminator strategy alias.\n-     */\n-    public void setDiscriminatorStrategy(String discStrategy) {\n-        _discStrategy = discStrategy;\n-    }\n-\n-    /**\n-     * Property string mapping field type names to value handler or field\n-     * mapping class names. For auto-configuration.\n-     */\n-    public void setFieldStrategies(String fieldMapString) {\n-        Properties props = Configurations.parseProperties(fieldMapString);\n-        if (props != null)\n-            _fieldMap.putAll(props);\n-    }\n-\n-    /**\n-     * Association of a field value type name with the handler or strategy\n-     * class name.\n-     */\n-    public void setFieldStrategy(String valueType, String handlerType) {\n-        if (handlerType == null)\n-            _fieldMap.remove(valueType);\n-        else\n-            _fieldMap.put(valueType, handlerType);\n-    }\n-\n-    /**\n-     * Association of a field value type name with the handler or strategy\n-     * class name.\n-     */\n-    public String getFieldStrategy(String valueType) {\n-        return (String) _fieldMap.get(valueType);\n-    }\n-\n-    /**\n-     * Whether to store enums as the ordinal value rather than the enum name.\n-     * Defaults to false.\n-     */\n-    public boolean getStoreEnumOrdinal() {\n-        return _ordinalEnum;\n-    }\n-\n-    /**\n-     * Whether to store enums as the ordinal value rather than the enum name.\n-     * Defaults to false.\n-     */\n-    public void setStoreEnumOrdinal(boolean ordinal) {\n-        _ordinalEnum = ordinal;\n-    }\n-\n-    /**\n-     * Whether to store a relation to an unmapped class by stringifying the\n-     * oid of the related object, rather than storing primary key values.\n-     */\n-    public boolean getStoreUnmappedObjectIdString() {\n-        return _stringifyUnmapped;\n-    }\n-\n-    /**\n-     * Whether to store a relation to an unmapped class by stringifying the\n-     * oid of the related object, rather than storing primary key values.\n-     */\n-    public void setStoreUnmappedObjectIdString(boolean stringify) {\n-        _stringifyUnmapped = stringify;\n-    }\n-\n-    /**\n-     * Default foreign key action for join keys. Defaults to logical keys.\n-     */\n-    public int getJoinForeignKeyDeleteAction() {\n-        return _joinFKAction;\n-    }\n-\n-    /**\n-     * Default foreign key action for join keys. Defaults to logical keys.\n-     */\n-    public void setJoinForeignKeyDeleteAction(int joinFKAction) {\n-        _joinFKAction = joinFKAction;\n-    }\n-\n-    /**\n-     * Default foreign key action name for join keys. Used in auto\n-     * configuration.\n-     */\n-    public void setJoinForeignKeyDeleteAction(String joinFKAction) {\n-        _joinFKAction = ForeignKey.getAction(joinFKAction);\n-    }\n-\n-    /**\n-     * Default foreign key action for relation keys. Defaults to logical keys.\n-     */\n-    public int getForeignKeyDeleteAction() {\n-        return _fkAction;\n-    }\n-\n-    /**\n-     * Default foreign key action for relation keys. Defaults to logical keys.\n-     */\n-    public void setForeignKeyDeleteAction(int fkAction) {\n-        _fkAction = fkAction;\n-    }\n-\n-    /**\n-     * Default foreign key action name for relation keys. Used in auto\n-     * configuration.\n-     */\n-    public void setForeignKeyDeleteAction(String fkAction) {\n-        _fkAction = ForeignKey.getAction(fkAction);\n-    }\n-\n-    /**\n-     * Whether to index logical foreign keys by default. Defaults to true.\n-     */\n-    public boolean getIndexLogicalForeignKeys() {\n-        return _indexFK;\n-    }\n-\n-    /**\n-     * Whether to index logical foreign keys by default. Defaults to true.\n-     */\n-    public void setIndexLogicalForeignKeys(boolean indexFK) {\n-        _indexFK = indexFK;\n-    }\n-\n-    /**\n-     * Whether to index discriminator columns by default. Defaults to true.\n-     */\n-    public boolean getIndexDiscriminator() {\n-        return _indexDisc;\n-    }\n-\n-    /**\n-     * Whether to index discriminator columns by default. Defaults to true.\n-     */\n-    public void setIndexDiscriminator(boolean indexDisc) {\n-        _indexDisc = indexDisc;\n-    }\n-\n-    /**\n-     * Whether to index version columns by default. Defaults to true.\n-     */\n-    public boolean getIndexVersion() {\n-        return _indexVers;\n-    }\n-\n-    /**\n-     * Whether to index version columns by default. Defaults to true.\n-     */\n-    public void setIndexVersion(boolean indexVers) {\n-        _indexVers = indexVers;\n-    }\n-\n-    /**\n-     * Whether to order lists and arrays using a dedicated ordering column\n-     * by default.\n-     */\n-    public boolean getOrderLists() {\n-        return _orderLists;\n-    }\n-\n-    /**\n-     * Whether to order lists and arrays using a dedicated ordering column\n-     * by default.\n-     */\n-    public void setOrderLists(boolean orderLists) {\n-        _orderLists = orderLists;\n-    }\n-\n-    /**\n-     * Whether to add a synthetic null indicator column to embedded mappings\n-     * by default.\n-     */\n-    public boolean getAddNullIndicator() {\n-        return _addNullInd;\n-    }\n-\n-    /**\n-     * Whether to add a synthetic null indicator column to embedded mappings\n-     * by default.\n-     */\n-    public void setAddNullIndicator(boolean addNullInd) {\n-        _addNullInd = addNullInd;\n-    }\n-\n-    /**\n-     * Whether to defer constraints by default. Defaults to false.\n-     */\n-    public boolean getDeferConstraints() {\n-        return _defer;\n-    }\n-\n-    /**\n-     * Whether to defer constraints by default. Defaults to false.\n-     */\n-    public void setDeferConstraints(boolean defer) {\n-        _defer = defer;\n-    }\n-\n-    /**\n-     * Default base name for datastore identity columns, or null to the\n-     * mapping's built-in name.\n-     */\n-    public String getDataStoreIdColumnName() {\n-        return _dsIdName;\n-    }\n-\n-    /**\n-     * Default base name for datastore identity columns, or null to the\n-     * mapping's built-in name.\n-     */\n-    public void setDataStoreIdColumnName(String dsIdName) {\n-        _dsIdName = dsIdName;\n-    }\n-\n-    /**\n-     * Default base name for version identity columns, or null to the mapping's\n-     * built-in name.\n-     */\n-    public String getVersionColumnName() {\n-        return _versName;\n-    }\n-\n-    /**\n-     * Default base name for version identity columns, or null to the mapping's\n-     * built-in name.\n-     */\n-    public void setVersionColumnName(String versName) {\n-        _versName = versName;\n-    }\n-\n-    /**\n-     * Default base name for discriminator columns, or null to the mapping's\n-     * built-in name.\n-     */\n-    public String getDiscriminatorColumnName() {\n-        return _discName;\n-    }\n-\n-    /**\n-     * Default base name for discriminator columns, or null to the mapping's\n-     * built-in name.\n-     */\n-    public void setDiscriminatorColumnName(String discName) {\n-        _discName = discName;\n-    }\n-\n-    /**\n-     * Default base name for order columns, or null to the mapping's\n-     * built-in name.\n-     */\n-    public String getOrderColumnName() {\n-        return _orderName;\n-    }\n-\n-    /**\n-     * Default base name for order columns, or null to the mapping's\n-     * built-in name.\n-     */\n-    public void setOrderColumnName(String orderName) {\n-        _orderName = orderName;\n-    }\n-\n-    /**\n-     * Default base name for null indicator columns, or null to the mapping's\n-     * built-in name.\n-     */\n-    public String getNullIndicatorColumnName() {\n-        return _nullIndName;\n-    }\n-\n-    /**\n-     * Default base name for null indicator columns, or null to the mapping's\n-     * built-in name.\n-     */\n-    public void setNullIndicatorColumnName(String nullIndName) {\n-        _nullIndName = nullIndName;\n-    }\n-\n-    public boolean defaultMissingInfo() {\n-        return _defMissing;\n-    }\n-\n-    public void setDefaultMissingInfo(boolean defMissing) {\n-        _defMissing = defMissing;\n-    }\n-\n-    public boolean useClassCriteria() {\n-        return _classCriteria;\n-    }\n-\n-    public void setUseClassCriteria(boolean classCriteria) {\n-        _classCriteria = classCriteria;\n-    }\n-\n-    public Object getStrategy(ClassMapping cls, boolean adapt) {\n-        if (adapt || defaultMissingInfo())\n-            return (cls.getMappedPCSuperclassMapping() == null)\n-                ? _baseClassStrategy : _subclassStrategy;\n-        return null;\n-    }\n-\n-    public Object getStrategy(Version vers, boolean adapt) {\n-        ClassMapping cls = vers.getClassMapping();\n-        if ((adapt || defaultMissingInfo())\n-            && cls.getJoinablePCSuperclassMapping() == null\n-            && cls.getVersionField() == null)\n-            return _versionStrategy;\n-        return null;\n-    }\n-\n-    public Object getStrategy(Discriminator disc, boolean adapt) {\n-        ClassMapping cls = disc.getClassMapping();\n-        if ((adapt || defaultMissingInfo())\n-            && cls.getJoinablePCSuperclassMapping() == null\n-            && disc.getMappingInfo().getValue() == null)\n-            return _discStrategy;\n-        return null;\n-    }\n-\n-    public Object getStrategy(ValueMapping vm, Class type, boolean adapt) {\n-        Object ret = _fieldMap.get(type.getName());\n-        if (ret != null)\n-            return ret;\n-        if (_stringifyUnmapped && vm.getTypeMapping() != null\n-            && !vm.getTypeMapping().isMapped())\n-            return UntypedPCValueHandler.getInstance();\n-        if (type.isEnum() && !vm.isSerialized()) {\n-            EnumValueHandler enumHandler = new EnumValueHandler();\n-            enumHandler.setStoreOrdinal(_ordinalEnum);\n-            return enumHandler;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Provides a default value for the given Discriminator. \n-     * \n-     * <P>\n-     * The type of the object returned relies on the javaType field being set on \n-     * the Discriminator which is provided.\n-     * <TABLE border=\"2\"> \n-     * <TH>JavaType\n-     * <TH>Default value\n-     * <TBODY>\n-     * <TR><TD>{@link JavaTypes.INT}<TD> The hashcode of the entity name</TR>\n-     * <TR><TD>{@link JavaTypes.CHAR}<TD>The first character of the entity name \n-     * </TR>\n-     * <TR><TD>{@link JavaTypes.STRING}<TD>The entity name</TR>\n-     * </TBODY>\n-     * </TABLE>\n-     * \n-     * @param disc The discriminator that needs a default value\n-     * @param adapt \n-     * \n-     * @return A new object containing the generated Discriminator value.\n-     */\n-    public Object getDiscriminatorValue(Discriminator disc, boolean adapt) {\n-        if (!adapt && !defaultMissingInfo())\n-            return null;\n-\n-        // WARNING: CHANGING THIS WILL INVALIDATE EXISTING DATA IF DEFAULTING\n-        // MISSING MAPPING INFO\n-        \n-        String alias = Strings.getClassName(disc.getClassMapping()\n-                .getTypeAlias());\n-        \n-        switch (disc.getJavaType()) {\n-            case JavaTypes.INT:\n-                return new Integer(alias.hashCode());\n-            case JavaTypes.CHAR:\n-                return new Character(alias.charAt(0)); \n-            case JavaTypes.STRING:\n-            default:\n-                return alias;\n-        }\n-    }\n-\n-    public String getTableName(ClassMapping cls, Schema schema) {\n-        String name = Strings.getClassName(cls.getDescribedType()).\n-            replace('$', '_');\n-        if (!_defMissing)\n-            name = dict.getValidTableName(name, schema);\n-        return name;\n-    }\n-\n-    public String getTableName(FieldMapping fm, Schema schema) {\n-        String name = fm.getName();\n-        Table table = fm.getDefiningMapping().getTable();\n-        if (table != null) {\n-            String tableName = table.getName();\n-            if (tableName.length() > 5)\n-                tableName = tableName.substring(0, 5);\n-            name = tableName + \"_\" + name;\n-        }\n-        if (!_defMissing)\n-            name = dict.getValidTableName(name, schema);\n-        return name;\n-    }\n-\n-    public void populateDataStoreIdColumns(ClassMapping cls, Table table,\n-        Column[] cols) {\n-        for (int i = 0; i < cols.length; i++) {\n-            if (_dsIdName != null && cols.length == 1)\n-                cols[i].setName(_dsIdName);\n-            else if (_dsIdName != null)\n-                cols[i].setName(_dsIdName + i);\n-            correctName(table, cols[i]);\n-        }\n-    }\n-\n-    /**\n-     * Correct the given column's name.\n-     */\n-    protected void correctName(Table table, Column col) {\n-        if (!_defMissing || _removeHungarianNotation)\n-        {\n-            String name = col.getName();\n-            if (_removeHungarianNotation)\n-                name = removeHungarianNotation(name);\n-            col.setName(dict.getValidColumnName(name, table));\n-        }\n-    }\n-\n-    protected String removeHungarianNotation(String columnName) {\n-        char[] name = columnName.toCharArray();\n-        int newStart = 0;\n-\n-        for (int i = 0; i < name.length; i++) {\n-            if (Character.isUpperCase(name[i]))\n-            {\n-                newStart = i;\n-                break;\n-            }\n-        }\n-\n-        return columnName.substring(newStart);\n-    }\n-\n-    public void populateColumns(Version vers, Table table, Column[] cols) {\n-        for (int i = 0; i < cols.length; i++) {\n-            if (_versName != null && cols.length == 1)\n-                cols[i].setName(_versName);\n-            else if (_versName != null) {\n-                if (i == 0)\n-                    cols[i].setName(_versName);\n-                else\n-                    cols[i].setName(_versName + \"_\" + i);\n-            } else if (_versName != null)\n-                cols[i].setName(_versName + i);\n-            correctName(table, cols[i]);\n-        }\n-    }\n-\n-    public void populateColumns(Discriminator disc, Table table,\n-        Column[] cols) {\n-        for (int i = 0; i < cols.length; i++) {\n-            if (_discName != null && cols.length == 1)\n-                cols[i].setName(_discName);\n-            else if (_discName != null)\n-                cols[i].setName(_discName + i);\n-            correctName(table, cols[i]);\n-        }\n-    }\n-\n-    public void populateJoinColumn(ClassMapping cm, Table local, Table foreign,\n-        Column col, Object target, int pos, int cols) {\n-        correctName(local, col);\n-    }\n-\n-    public void populateJoinColumn(FieldMapping fm, Table local, Table foreign,\n-        Column col, Object target, int pos, int cols) {\n-        correctName(local, col);\n-    }\n-\n-    public void populateForeignKeyColumn(ValueMapping vm, String name,\n-        Table local, Table foreign, Column col, Object target, boolean inverse,\n-        int pos, int cols) {\n-        if (cols == 1)\n-            col.setName(name);\n-        else if (target instanceof Column)\n-            col.setName(name + \"_\" + ((Column) target).getName());\n-        correctName(local, col);\n-    }\n-\n-    public void populateColumns(ValueMapping vm, String name, Table table,\n-        Column[] cols) {\n-        for (int i = 0; i < cols.length; i++)\n-            correctName(table, cols[i]);\n-    }\n-\n-    public boolean populateOrderColumns(FieldMapping fm, Table table,\n-        Column[] cols) {\n-        for (int i = 0; i < cols.length; i++) {\n-            if (_orderName != null && cols.length == 1)\n-                cols[i].setName(_orderName);\n-            else if (_orderName != null)\n-                cols[i].setName(_orderName + i);\n-            correctName(table, cols[i]);\n-        }\n-        return _orderLists && (JavaTypes.ARRAY == fm.getTypeCode()\n-            || List.class.isAssignableFrom(fm.getType()));\n-    }\n-\n-    public boolean populateNullIndicatorColumns(ValueMapping vm, String name,\n-        Table table, Column[] cols) {\n-        for (int i = 0; i < cols.length; i++) {\n-            if (_nullIndName != null && cols.length == 1)\n-                cols[i].setName(_nullIndName);\n-            else if (_nullIndName != null)\n-                cols[i].setName(_nullIndName + i);\n-            correctName(table, cols[i]);\n-        }\n-        return _addNullInd;\n-    }\n-\n-    public ForeignKey getJoinForeignKey(ClassMapping cls, Table local,\n-        Table foreign) {\n-        if (_joinFKAction == ForeignKey.ACTION_NONE)\n-            return null;\n-        ForeignKey fk = new ForeignKey();\n-        fk.setDeleteAction(_joinFKAction);\n-        fk.setDeferred(_defer);\n-        return fk;\n-    }\n-\n-    public ForeignKey getJoinForeignKey(FieldMapping fm, Table local,\n-        Table foreign) {\n-        if (_joinFKAction == ForeignKey.ACTION_NONE)\n-            return null;\n-        ForeignKey fk = new ForeignKey();\n-        fk.setDeleteAction(_joinFKAction);\n-        fk.setDeferred(_defer);\n-        return fk;\n-    }\n-\n-    public ForeignKey getForeignKey(ValueMapping vm, String name, Table local,\n-        Table foreign, boolean inverse) {\n-        if (_fkAction == ForeignKey.ACTION_NONE)\n-            return null;\n-        ForeignKey fk = new ForeignKey();\n-        fk.setDeleteAction(_fkAction);\n-        fk.setDeferred(_defer);\n-        return fk;\n-    }\n-\n-    public Index getJoinIndex(FieldMapping fm, Table table, Column[] cols) {\n-        if (!_indexFK || fm.getJoinForeignKey() == null\n-            || !fm.getJoinForeignKey().isLogical())\n-            return null;\n-        if (areAllPrimaryKeyColumns(cols))\n-            return null;\n-\n-        Index idx = new Index();\n-        idx.setName(getIndexName(null, table, cols));\n-        return idx;\n-    }\n-\n-    /**\n-     * Return whether all the given columns are primary key columns.\n-     */\n-    protected boolean areAllPrimaryKeyColumns(Column[] cols) {\n-        for (int i = 0; i < cols.length; i++)\n-            if (!cols[i].isPrimaryKey())\n-                return false;\n-        return true;\n-    }\n-\n-    /**\n-     * Generate an index name.\n-     */\n-    protected String getIndexName(String name, Table table, Column[] cols) {\n-        // always use dict for index names because no spec mandates them\n-        // based on defaults\n-        if (name == null)\n-            name = cols[0].getName();\n-\n-        if (_removeHungarianNotation)\n-            name = removeHungarianNotation(name);\n-\n-        return dict.getValidIndexName(name, table);\n-    }\n-\n-    public Index getIndex(ValueMapping vm, String name, Table table,\n-        Column[] cols) {\n-        if (!_indexFK || vm.getForeignKey() == null\n-            || !vm.getForeignKey().isLogical())\n-            return null;\n-        if (areAllPrimaryKeyColumns(cols))\n-            return null;\n-\n-        Index idx = new Index();\n-        idx.setName(getIndexName(name, table, cols));\n-        return idx;\n-    }\n-\n-    public Index getIndex(Version vers, Table table, Column[] cols) {\n-        if (!_indexVers)\n-            return null;\n-        Index idx = new Index();\n-        idx.setName(getIndexName(_versName, table, cols));\n-        return idx;\n-    }\n-\n-    public Index getIndex(Discriminator disc, Table table, Column[] cols) {\n-        if (!_indexDisc)\n-            return null;\n-        Index idx = new Index();\n-        idx.setName(getIndexName(_discName, table, cols));\n-        return idx;\n-    }\n-\n-    public Unique getJoinUnique(FieldMapping fm, Table table, Column[] cols) {\n-        return null;\n-    }\n-\n-    public Unique getUnique(ValueMapping vm, String name, Table table,\n-        Column[] cols) {\n-        return null;\n-    }\n-\n-    public String getPrimaryKeyName(ClassMapping cm, Table table) {\n-        return null;\n-    }\n-\n-    public void installPrimaryKey(FieldMapping fm, Table table) {\n-    }\n-\n-    ///////////////////////////////\n-    // Configurable implementation\n-    ///////////////////////////////\n-\n-    public void setConfiguration(Configuration conf) {\n-        dict = ((JDBCConfiguration) conf).getDBDictionaryInstance();\n-    }\n-\n-    public void startConfiguration() {\n-    }\n-\n-    public void endConfiguration() {\n-    }\n-}"},{"sha":"a0937361d1ad9ce7c2d759b457007e0aa037481d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingInfo.java","status":"removed","additions":0,"deletions":1788,"changes":1788,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingInfo.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,1788 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.io.Serializable;\n-import java.sql.Types;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ColumnIO;\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\n-import org.apache.openjpa.jdbc.schema.Index;\n-import org.apache.openjpa.jdbc.schema.PrimaryKey;\n-import org.apache.openjpa.jdbc.schema.Schema;\n-import org.apache.openjpa.jdbc.schema.SchemaGroup;\n-import org.apache.openjpa.jdbc.schema.Schemas;\n-import org.apache.openjpa.jdbc.schema.Table;\n-import org.apache.openjpa.jdbc.schema.Unique;\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\n-import org.apache.openjpa.lib.log.Log;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.util.Localizer.Message;\n-import org.apache.openjpa.meta.JavaTypes;\n-import org.apache.openjpa.meta.MetaDataContext;\n-import org.apache.openjpa.util.MetaDataException;\n-import serp.util.Strings;\n-\n-/**\n- * Base class storing raw mapping information; defines utility methods for\n- * converting raw mapping information to full mapping to the schema.\n- *\n- * @author Abe White\n- */\n-public abstract class MappingInfo\n-    implements Serializable {\n-\n-    public static final int JOIN_NONE = 0;\n-    public static final int JOIN_FORWARD = 1;\n-    public static final int JOIN_INVERSE = 2;\n-\n-    private static final Object NULL = new Object();\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (MappingInfo.class);\n-\n-    private String _strategy = null;\n-    private List _cols = null;\n-    private Index _idx = null;\n-    private Unique _unq = null;\n-    private ForeignKey _fk = null;\n-    private boolean _canIdx = true;\n-    private boolean _canUnq = true;\n-    private boolean _canFK = true;\n-    private int _join = JOIN_NONE;\n-    private ColumnIO _io = null;\n-\n-    /**\n-     * Mapping strategy name.\n-     */\n-    public String getStrategy() {\n-        return _strategy;\n-    }\n-\n-    /**\n-     * Mapping strategy name.\n-     */\n-    public void setStrategy(String strategy) {\n-        _strategy = strategy;\n-    }\n-\n-    /**\n-     * Raw column data.\n-     */\n-    public List getColumns() {\n-        return (_cols == null) ? Collections.EMPTY_LIST : _cols;\n-    }\n-\n-    /**\n-     * Raw column data.\n-     */\n-    public void setColumns(List cols) {\n-        _cols = cols;\n-    }\n-\n-    /**\n-     * Raw index.\n-     */\n-    public Index getIndex() {\n-        return _idx;\n-    }\n-\n-    /**\n-     * Raw index.\n-     */\n-    public void setIndex(Index idx) {\n-        _idx = idx;\n-    }\n-\n-    /**\n-     * The user can mark columns as explicitly non-indexable.\n-     */\n-    public boolean canIndex() {\n-        return _canIdx;\n-    }\n-\n-    /**\n-     * The user can mark columns as explicitly non-indexable.\n-     */\n-    public void setCanIndex(boolean indexable) {\n-        _canIdx = indexable;\n-    }\n-\n-    /**\n-     * Raw foreign key information.\n-     */\n-    public ForeignKey getForeignKey() {\n-        return _fk;\n-    }\n-\n-    /**\n-     * Raw foreign key information.\n-     */\n-    public void setForeignKey(ForeignKey fk) {\n-        _fk = fk;\n-        if (fk != null && _join == JOIN_NONE)\n-            _join = JOIN_FORWARD;\n-    }\n-\n-    /**\n-     * The user can mark columns as explicitly not having a foreign key.\n-     */\n-    public boolean canForeignKey() {\n-        return _canFK;\n-    }\n-\n-    /**\n-     * The user can mark columns as explicitly not having a foreign key.\n-     */\n-    public void setCanForeignKey(boolean fkable) {\n-        _canFK = fkable;\n-    }\n-\n-    /**\n-     * Raw unique constraint information.\n-     */\n-    public Unique getUnique() {\n-        return _unq;\n-    }\n-\n-    /**\n-     * Raw unique constraint information.\n-     */\n-    public void setUnique(Unique unq) {\n-        _unq = unq;\n-    }\n-\n-    /**\n-     * The user can mark columns as explicitly not having a unique constraint.\n-     */\n-    public boolean canUnique() {\n-        return _canUnq;\n-    }\n-\n-    /**\n-     * The user can mark columns as explicitly not having a unique constraint.\n-     */\n-    public void setCanUnique(boolean uniquable) {\n-        _canUnq = uniquable;\n-    }\n-\n-    /**\n-     * I/O for the columns created by the last call to {@link #createColumns},\n-     * or for the foreign key created by the last call to\n-     * {@link #createForeignKey}. This is also expected to be set correctly\n-     * prior to calls to {@link #syncColumns} and {@link #syncForeignKey}.\n-     */\n-    public ColumnIO getColumnIO() {\n-        return _io;\n-    }\n-\n-    /**\n-     * I/O for the columns created by the last call to {@link #createColumns},\n-     * or for the foreign key created by the last call to\n-     * {@link #createForeignKey}. This is also expected to be set correctly\n-     * prior to calls to {@link #syncColumns} and {@link #syncForeignKey}.\n-     */\n-    public void setColumnIO(ColumnIO io) {\n-        _io = io;\n-    }\n-\n-    /**\n-     * Direction of the join that the columns of this mapping info form. This\n-     * is usually automatically set by {@link #createForeignKey}. This flag\n-     * is also expected to be set correctly prior to calls to\n-     * {@link #syncForeignKey} if the join is inversed.\n-     */\n-    public int getJoinDirection() {\n-        return _join;\n-    }\n-\n-    /**\n-     * Direction of the join that the columns of this mapping info form. This\n-     * is usually automatically set by {@link #createForeignKey}. This flag\n-     * is also expected to be set correctly prior to calls to\n-     * {@link #syncForeignKey} if the join is inversed.\n-     */\n-    public void setJoinDirection(int join) {\n-        _join = join;\n-    }\n-\n-    /**\n-     * Clear all mapping information.\n-     */\n-    public void clear() {\n-        clear(true);\n-    }\n-\n-    /**\n-     * Clear mapping information.\n-     *\n-     * @param canFlags whether to clear information about whether we\n-     * can place indexed, foreign keys, etc on this mapping\n-     */\n-    protected void clear(boolean canFlags) {\n-        _strategy = null;\n-        _cols = null;\n-        _io = null;\n-        _idx = null;\n-        _unq = null;\n-        _fk = null;\n-        _join = JOIN_NONE;\n-        if (canFlags) {\n-            _canIdx = true;\n-            _canFK = true;\n-            _canUnq = true;\n-        }\n-    }\n-\n-    /**\n-     * Copy missing info from the instance to this one.\n-     */\n-    public void copy(MappingInfo info) {\n-        if (_strategy == null)\n-            _strategy = info.getStrategy();\n-        if (_canIdx && _idx == null) {\n-            if (info.getIndex() != null)\n-                _idx = info.getIndex();\n-            else\n-                _canIdx = info.canIndex();\n-        }\n-        if (_canUnq && _unq == null) {\n-            if (info.getUnique() != null)\n-                _unq = info.getUnique();\n-            else\n-                _canUnq = info.canUnique();\n-        }\n-        if (_canFK && _fk == null) {\n-            if (info.getForeignKey() != null)\n-                _fk = info.getForeignKey();\n-            else\n-                _canFK = info.canForeignKey();\n-        }\n-\n-        List cols = getColumns();\n-        List icols = info.getColumns();\n-        if (!icols.isEmpty() && (cols.isEmpty()\n-            || cols.size() == icols.size())) {\n-            if (cols.isEmpty())\n-                cols = new ArrayList(icols.size());\n-            for (int i = 0; i < icols.size(); i++) {\n-                if (cols.size() == i)\n-                    cols.add(new Column());\n-                ((Column) cols.get(i)).copy((Column) icols.get(i));\n-            }\n-            setColumns(cols);\n-        }\n-    }\n-\n-    /**\n-     * Return true if this info has columns, foreign key information, index\n-     * information, etc.\n-     */\n-    public boolean hasSchemaComponents() {\n-        return (_cols != null && !_cols.isEmpty())\n-            || _idx != null\n-            || _unq != null\n-            || _fk != null\n-            || !_canIdx\n-            || !_canFK\n-            || !_canUnq;\n-    }\n-\n-    /**\n-     * Assert that the user did not supply any columns, index, unique\n-     * constraint, or foreign key for this mapping.\n-     */\n-    public void assertNoSchemaComponents(MetaDataContext context, boolean die) {\n-        if (_cols == null || _cols.isEmpty()) {\n-            assertNoIndex(context, die);\n-            assertNoUnique(context, die);\n-            assertNoForeignKey(context, die);\n-            return;\n-        }\n-\n-        Message msg = _loc.get(\"unexpected-cols\", context);\n-        if (die)\n-            throw new MetaDataException(msg);\n-        context.getRepository().getLog().warn(msg);\n-    }\n-\n-    /**\n-     * Assert that this info has the given strategy or no strategy.\n-     */\n-    public void assertStrategy(MetaDataContext context, Object contextStrat,\n-        Object expected, boolean die) {\n-        if (contextStrat == expected)\n-            return;\n-\n-        String strat;\n-        if (contextStrat == null) {\n-            if (_strategy == null)\n-                return;\n-            if (_strategy.equals(expected.getClass().getName()))\n-                return;\n-            if (expected instanceof Strategy\n-                && _strategy.equals(((Strategy) expected).getAlias()))\n-                return;\n-            strat = _strategy;\n-        } else if (contextStrat instanceof Strategy)\n-            strat = ((Strategy) contextStrat).getAlias();\n-        else\n-            strat = contextStrat.getClass().getName();\n-\n-        Message msg = _loc.get(\"unexpected-strategy\", context, expected,\n-            strat);\n-        if (die)\n-            throw new MetaDataException(msg);\n-        context.getRepository().getLog().warn(msg);\n-    }\n-\n-    /**\n-     * Assert that the user did not try to place an index on this mapping.\n-     */\n-    public void assertNoIndex(MetaDataContext context, boolean die) {\n-        if (_idx == null)\n-            return;\n-\n-        Message msg = _loc.get(\"unexpected-index\", context);\n-        if (die)\n-            throw new MetaDataException(msg);\n-        context.getRepository().getLog().warn(msg);\n-    }\n-\n-    /**\n-     * Assert that the user did not try to place a unique constraint on this\n-     * mapping.\n-     */\n-    public void assertNoUnique(MetaDataContext context, boolean die) {\n-        if (_unq == null)\n-            return;\n-\n-        Message msg = _loc.get(\"unexpected-unique\", context);\n-        if (die)\n-            throw new MetaDataException(msg);\n-        context.getRepository().getLog().warn(msg);\n-    }\n-\n-    /**\n-     * Assert that the user did not try to place a foreign key on this mapping.\n-     */\n-    public void assertNoForeignKey(MetaDataContext context, boolean die) {\n-        if (_fk == null)\n-            return;\n-\n-        Message msg = _loc.get(\"unexpected-fk\", context);\n-        if (die)\n-            throw new MetaDataException(msg);\n-        context.getRepository().getLog().warn(msg);\n-    }\n-\n-    /**\n-     * Assert that the user did not try to join.\n-     */\n-    public void assertNoJoin(MetaDataContext context, boolean die) {\n-        boolean join = false;\n-        if (_cols != null) {\n-            Column col;\n-            for (int i = 0; !join && i < _cols.size(); i++) {\n-                col = (Column) _cols.get(i);\n-                if (col.getTarget() != null)\n-                    join = true;\n-            }\n-        }\n-        if (!join)\n-            return;\n-\n-        Message msg = _loc.get(\"unexpected-join\", context);\n-        if (die)\n-            throw new MetaDataException(msg);\n-        context.getRepository().getLog().warn(msg);\n-    }\n-\n-    /**\n-     * Find or generate a table for a mapping.\n-     *\n-     * @param context the mapping that uses the table\n-     * @param def default table name provider\n-     * @param schemaName default schema if known, or null\n-     * @param given given table name\n-     * @param adapt whether we can alter the schema or mappings\n-     */\n-    public Table createTable(MetaDataContext context, TableDefaults def,\n-        String schemaName, String given, boolean adapt) {\n-        MappingRepository repos = (MappingRepository) context.getRepository();\n-        if (given == null && (def == null || (!adapt\n-            && !repos.getMappingDefaults().defaultMissingInfo())))\n-            throw new MetaDataException(_loc.get(\"no-table\", context));\n-\n-        if (schemaName == null)\n-            schemaName = Schemas.getNewTableSchema((JDBCConfiguration)\n-                repos.getConfiguration());\n-\n-        // if no given and adapting or defaulting missing info, use template\n-        SchemaGroup group = repos.getSchemaGroup();\n-        Schema schema = null;\n-        if (given == null) {\n-            schema = group.getSchema(schemaName);\n-            if (schema == null)\n-                schema = group.addSchema(schemaName);\n-            given = def.get(schema);\n-        }\n-\n-        String fullName;\n-        int dotIdx = given.lastIndexOf('.');\n-        if (dotIdx == -1)\n-            fullName = (schemaName == null) ? given : schemaName + \".\" + given;\n-        else {\n-            fullName = given;\n-            schema = null;\n-            schemaName = given.substring(0, dotIdx);\n-            given = given.substring(dotIdx + 1);\n-        }\n-\n-        // look for named table using full name and findTable, which allows\n-        // the dynamic schema factory to create the table if needed\n-        Table table = group.findTable(fullName);\n-        if (table != null)\n-            return table;\n-        if (!adapt)\n-            throw new MetaDataException(_loc.get(\"bad-table\", given, context));\n-\n-        // named table doesn't exist; create it\n-        if (schema == null) {\n-            schema = group.getSchema(schemaName);\n-            if (schema == null)\n-                schema = group.addSchema(schemaName);\n-        }\n-        table = schema.getTable(given);\n-        if (table == null)\n-            table = schema.addTable(given);\n-        return table;\n-    }\n-\n-    /**\n-     * Retrieve/create columns on the given table by merging the given\n-     * template information with any user-provided information.\n-     *\n-     * @param context the mapping we're retrieving columns for\n-     * @param prefix localized error message key prefix\n-     * @param tmplates template columns\n-     * @param table the table for the columns\n-     * @param adapt whether we can modify the existing mapping or schema\n-     */\n-    protected Column[] createColumns(MetaDataContext context, String prefix,\n-        Column[] tmplates, Table table, boolean adapt) {\n-        assertTable(context, table);\n-        if (prefix == null)\n-            prefix = \"generic\";\n-\n-        // the user has to give the right number of expected columns for this\n-        // mapping, or none at all if we're adapting.  can't just given one of\n-        // n columns because we don't know which of the n columns the info\n-        // applies to\n-        List given = getColumns();\n-        boolean fill = ((MappingRepository) context.getRepository()).\n-            getMappingDefaults().defaultMissingInfo();\n-        if ((!given.isEmpty() || (!adapt && !fill))\n-            && given.size() != tmplates.length)\n-            throw new MetaDataException(_loc.get(prefix + \"-num-cols\",\n-                context, String.valueOf(tmplates.length),\n-                String.valueOf(given.size())));\n-\n-        Column[] cols = new Column[tmplates.length];\n-        _io = null;\n-        Column col;\n-        for (int i = 0; i < tmplates.length; i++) {\n-            col = (given.isEmpty()) ? null : (Column) given.get(i);\n-            cols[i] = mergeColumn(context, prefix, tmplates[i], true, col,\n-                table, adapt, fill);\n-            setIOFromColumnFlags(col, i);\n-        }\n-        return cols;\n-    }\n-\n-    /**\n-     * Set the proper internal column I/O metadata for the given column's flags.\n-     */\n-    private void setIOFromColumnFlags(Column col, int i) {\n-        if (col == null || (!col.getFlag(Column.FLAG_UNINSERTABLE)\n-            && !col.getFlag(Column.FLAG_UNUPDATABLE)\n-            && !col.isNotNull()))\n-            return;\n-\n-        if (_io == null)\n-            _io = new ColumnIO();\n-        _io.setInsertable(i, !col.getFlag(Column.FLAG_UNINSERTABLE));\n-        _io.setUpdatable(i, !col.getFlag(Column.FLAG_UNUPDATABLE));\n-        _io.setNullInsertable(i, !col.isNotNull());\n-        _io.setNullUpdatable(i, !col.isNotNull());\n-    }\n-\n-    /**\n-     * Assert that the given table is non-null.\n-     */\n-    private static void assertTable(MetaDataContext context, Table table) {\n-        if (table == null)\n-            throw new MetaDataException(_loc.get(\"unmapped\", context));\n-    }\n-\n-    /**\n-     * Merge the given columns if possible.\n-     *\n-     * @param context the mapping we're retrieving columns for\n-     * @param prefix localized error message key prefix\n-     * @param tmplate template for expected column information\n-     * @param compat whether the existing column type must be compatible\n-     * with the type of the template column\n-     * @param given the given column information from mapping info\n-     * @param table the table for the columns\n-     * @param adapt whether we can modify the existing mapping or schema\n-     * @param fill whether to default missing column information\n-     */\n-    protected static Column mergeColumn(MetaDataContext context, String prefix,\n-        Column tmplate, boolean compat, Column given, Table table,\n-        boolean adapt, boolean fill) {\n-        assertTable(context, table);\n-\n-        // if not adapting must provide column name at a minimum\n-        String colName = (given == null) ? null : given.getName();\n-        if (colName == null && !adapt && !fill)\n-            throw new MetaDataException(_loc.get(prefix + \"-no-col-name\",\n-                context));\n-\n-        // determine the column name based on given info, or template if none;\n-        // also make sure that if the user gave a column name, he didn't try\n-        // to put the column in an unexpected table\n-        if (colName == null)\n-            colName = tmplate.getName();\n-        int dotIdx = colName.lastIndexOf('.');\n-        if (dotIdx == 0)\n-            colName = colName.substring(1);\n-        else if (dotIdx != -1) {\n-            findTable(context, colName.substring(0, dotIdx), table,\n-                null, null);\n-            colName = colName.substring(dotIdx + 1);\n-        }\n-\n-        // find existing column\n-        Column col = table.getColumn(colName);\n-        if (col == null && !adapt)\n-            throw new MetaDataException(_loc.get(prefix + \"-bad-col-name\",\n-                context, colName, table));\n-\n-        MappingRepository repos = (MappingRepository) context.getRepository();\n-        DBDictionary dict = repos.getDBDictionary();\n-\n-        // use information from template column by default, allowing any\n-        // user-given specifics to override it\n-        int type = tmplate.getType();\n-        int size = tmplate.getSize();\n-        if (type == Types.OTHER)\n-            type = dict.getJDBCType(tmplate.getJavaType(), size == -1);\n-        boolean ttype = true;\n-        int otype = type;\n-        String typeName = tmplate.getTypeName();\n-        Boolean notNull = null;\n-        if (tmplate.isNotNullExplicit())\n-            notNull = (tmplate.isNotNull()) ? Boolean.TRUE : Boolean.FALSE;\n-        int decimals = tmplate.getDecimalDigits();\n-        String defStr = tmplate.getDefaultString();\n-        boolean autoAssign = tmplate.isAutoAssigned();\n-        boolean relationId = tmplate.isRelationId();\n-        String targetField = tmplate.getTargetField();\n-        if (given != null) {\n-            // use given type if provided, but warn if it isn't compatible with\n-            // the expected column type\n-            if (given.getType() != Types.OTHER) {\n-                ttype = false;\n-                if (compat && !given.isCompatible(type, typeName, size, \n-                    decimals)) {\n-                    Log log = repos.getLog();\n-                    if (log.isWarnEnabled())\n-                        log.warn(_loc.get(prefix + \"-incompat-col\",\n-                            context, colName, Schemas.getJDBCName(type)));\n-                }\n-                otype = given.getType();\n-                type = dict.getPreferredType(otype);\n-            }\n-            typeName = given.getTypeName();\n-            size = given.getSize();\n-            decimals = given.getDecimalDigits();\n-\n-            // leave this info as the template defaults unless the user\n-            // explicitly turns it on in the given column\n-            if (given.isNotNullExplicit())\n-                notNull = (given.isNotNull()) ? Boolean.TRUE : Boolean.FALSE;\n-            if (given.getDefaultString() != null)\n-                defStr = given.getDefaultString();\n-            if (given.isAutoAssigned())\n-                autoAssign = true;\n-            if (given.isRelationId())\n-                relationId = true;\n-        }\n-\n-        // default char column size if original type is char (test original\n-        // type rather than final type because orig might be clob, translated\n-        // to an unsized varchar, which is supported by some dbs)\n-        if (size == 0 && (otype == Types.VARCHAR || otype == Types.CHAR))\n-            size = dict.characterColumnSize;\n-\n-        // create column, or make sure existing column matches expected type\n-        if (col == null) {\n-            col = table.addColumn(colName);\n-            col.setType(type);\n-        } else if ((compat || !ttype) && !col.isCompatible(type, typeName, \n-            size, decimals)) {\n-            // if existing column isn't compatible with desired type, die if\n-            // can't adapt, else warn and change the existing column type\n-            Message msg = _loc.get(prefix + \"-bad-col\", context,\n-                Schemas.getJDBCName(type), col.getDescription());\n-            if (!adapt)\n-                throw new MetaDataException(msg);\n-            Log log = repos.getLog();\n-            if (log.isWarnEnabled())\n-                log.warn(msg);\n-\n-            col.setType(type);\n-        } else if (given != null && given.getType() != Types.OTHER) {\n-            // as long as types are compatible, set column to expected type\n-            col.setType(type);\n-        }\n-\n-        // always set the java type and autoassign to expected values, even on\n-        // an existing column, since we don't get this from the DB\n-        if (compat)\n-            col.setJavaType(tmplate.getJavaType());\n-        else if (col.getJavaType() == JavaTypes.OBJECT) {\n-            if (given != null && given.getJavaType() != JavaTypes.OBJECT)\n-                col.setJavaType(given.getJavaType());\n-            else\n-                col.setJavaType(JavaTypes.getTypeCode\n-                    (Schemas.getJavaType(col.getType(), col.getSize(),\n-                        col.getDecimalDigits())));\n-        }\n-        col.setAutoAssigned(autoAssign);\n-        col.setRelationId(relationId);\n-        col.setTargetField(targetField);\n-\n-        // we need this for runtime, and the dynamic schema factory might\n-        // not know it, so set it even if not adapting\n-        if (defStr != null)\n-            col.setDefaultString(defStr);\n-        if (notNull != null)\n-            col.setNotNull(notNull.booleanValue());\n-\n-        // add other details if adapting\n-        if (adapt) {\n-            if (typeName != null)\n-                col.setTypeName(typeName);\n-            if (size != 0)\n-                col.setSize(size);\n-            if (decimals != 0)\n-                col.setDecimalDigits(decimals);\n-        }\n-\n-        if (tmplate.hasComment())\n-            col.setComment(tmplate.getComment());\n-        return col;\n-    }\n-\n-    /**\n-     * Find the table named by a column or target.\n-     *\n-     * @param context context for error messages, etc.\n-     * @param name the table name, possibly including schema\n-     * @param expected the expected table; may be null\n-     * @param inverse the possible inverse table; may be null\n-     * @param rel if we're finding the target table of a join, the\n-     * joined-to type; allows us to also look in its superclass tables\n-     */\n-    private static Table findTable(MetaDataContext context, String name,\n-        Table expected, Table inverse, ClassMapping rel) {\n-        // is this the expected table?\n-        if (expected == null && rel != null)\n-            expected = rel.getTable();\n-        if (expected != null && isTableName(name, expected))\n-            return expected;\n-\n-        // check for inverse\n-        if (inverse != null && isTableName(name, inverse))\n-            return inverse;\n-\n-        // superclass table?\n-        if (rel != null)\n-            rel = rel.getJoinablePCSuperclassMapping();\n-        while (rel != null) {\n-            if (isTableName(name, rel.getTable()))\n-                return rel.getTable();\n-            rel = rel.getJoinablePCSuperclassMapping();\n-        }\n-\n-        // none of the possible tables\n-        throw new MetaDataException(_loc.get(\"col-wrong-table\", context,\n-            expected, name));\n-    }\n-\n-    /**\n-     * Return whether the given name matches the given table.\n-     */\n-    private static boolean isTableName(String name, Table table) {\n-        return name.equalsIgnoreCase(table.getName())\n-            || name.equalsIgnoreCase(table.getFullName());\n-    }\n-\n-    /**\n-     * Retrieve/create an index on the given columns by merging the given\n-     * template information with any user-provided information.\n-     *\n-     * @param context the mapping we're retrieving an index for\n-     * @param prefix localized error message key prefix\n-     * @param tmplate template for expected index information\n-     * @param cols the indexed columns\n-     * @param adapt whether we can modify the existing mapping or schema\n-     */\n-    protected Index createIndex(MetaDataContext context, String prefix,\n-        Index tmplate, Column[] cols, boolean adapt) {\n-        if (prefix == null)\n-            prefix = \"generic\";\n-\n-        // can't create an index if there are no cols\n-        if (cols == null || cols.length == 0) {\n-            if (_idx != null)\n-                throw new MetaDataException(_loc.get(prefix\n-                    + \"-no-index-cols\", context));\n-            return null;\n-        }\n-\n-        // look for an existing index on these columns\n-        Table table = cols[0].getTable();\n-        Index[] idxs = table.getIndexes();\n-        Index exist = null;\n-        for (int i = 0; i < idxs.length; i++) {\n-            if (idxs[i].columnsMatch(cols)) {\n-                exist = idxs[i];\n-                break;\n-            }\n-        }\n-\n-        // remove existing index?\n-        if (!_canIdx) {\n-            if (exist == null)\n-                return null;\n-            if (!adapt)\n-                throw new MetaDataException(_loc.get(prefix + \"-index-exists\",\n-                    context));\n-            table.removeIndex(exist);\n-            return null;\n-        }\n-\n-        // if we have an existing index, merge given info into it\n-        if (exist != null) {\n-            if (_idx != null && _idx.isUnique() && !exist.isUnique()) {\n-                if (!adapt)\n-                    throw new MetaDataException(_loc.get(prefix\n-                        + \"-index-not-unique\", context));\n-                exist.setUnique(true);\n-            }\n-            return exist;\n-        }\n-\n-        // if no defaults return null\n-        MappingRepository repos = (MappingRepository) context.getRepository();\n-        boolean fill = repos.getMappingDefaults().defaultMissingInfo();\n-        if (_idx == null && (tmplate == null || (!adapt && !fill)))\n-            return null;\n-\n-        String name = null;\n-        boolean unq;\n-        if (_idx != null) {\n-            name = _idx.getName();\n-            unq = _idx.isUnique();\n-            // preserve multiple columns if they are specified in the index\n-            if (_idx.getColumns() != null && _idx.getColumns().length > 1)\n-                cols = _idx.getColumns();\n-        } else\n-            unq = tmplate.isUnique();\n-\n-        // if no name provided by user info, make one\n-        if (name == null) {\n-            if (tmplate != null)\n-                name = tmplate.getName();\n-            else {\n-                name = cols[0].getName();\n-                name = repos.getDBDictionary().getValidIndexName(name, table);\n-            }\n-        }\n-\n-        Index idx = table.addIndex(name);\n-        idx.setUnique(unq);\n-        idx.setColumns(cols);\n-        return idx;\n-    }\n-\n-    /**\n-     * Retrieve/create a unique constraint on the given columns by merging the\n-     * given template information with any user-provided information.\n-     *\n-     * @param context the mapping we're retrieving a constraint for\n-     * @param prefix localized error message key prefix\n-     * @param tmplate template for expected unique information\n-     * @param cols the constraint columns\n-     * @param adapt whether we can modify the existing mapping or schema\n-     */\n-    protected Unique createUnique(MetaDataContext context, String prefix,\n-        Unique tmplate, Column[] cols, boolean adapt) {\n-        if (prefix == null)\n-            prefix = \"generic\";\n-\n-        // can't create a constraint if there are no cols\n-        if (cols == null || cols.length == 0) {\n-            if (_unq != null || tmplate != null)\n-                throw new MetaDataException(_loc.get(prefix\n-                    + \"-no-unique-cols\", context));\n-            return null;\n-        }\n-\n-        // look for an existing constraint on these columns\n-        Table table = cols[0].getTable();\n-        Unique[] unqs = table.getUniques();\n-        Unique exist = null;\n-        for (int i = 0; i < unqs.length; i++) {\n-            if (unqs[i].columnsMatch(cols)) {\n-                exist = unqs[i];\n-                break;\n-            }\n-        }\n-\n-        // remove existing unique?\n-        if (!_canUnq) {\n-            if (exist == null)\n-                return null;\n-            if (!adapt)\n-                throw new MetaDataException(_loc.get(prefix\n-                    + \"-unique-exists\", context));\n-            table.removeUnique(exist);\n-            return null;\n-        }\n-\n-        // no defaults; return existing constraint (if any)\n-        if (tmplate == null && _unq == null)\n-            return exist;\n-\n-        MappingRepository repos = (MappingRepository) context.getRepository();\n-        if (exist != null) {\n-            if (_unq != null && _unq.isDeferred() && !exist.isDeferred()) {\n-                Log log = repos.getLog();\n-                if (log.isWarnEnabled())\n-                    log.warn(_loc.get(prefix + \"-defer-unique\", context));\n-            }\n-            return exist;\n-        }\n-\n-        // dict can't handle unique constraints?\n-        DBDictionary dict = repos.getDBDictionary();\n-        if (_unq != null && !dict.supportsUniqueConstraints) {\n-            Log log = repos.getLog();\n-            if (log.isWarnEnabled())\n-                log.warn(_loc.get(prefix + \"-unique-support\", context));\n-            return null;\n-        }\n-\n-        boolean fill = repos.getMappingDefaults().defaultMissingInfo();\n-        if (!adapt && !fill && _unq == null)\n-            return null;\n-\n-        String name;\n-        boolean deferred;\n-        if (_unq != null) {\n-            name = _unq.getName();\n-            deferred = _unq.isDeferred();\n-        } else {\n-            name = tmplate.getName();\n-            deferred = tmplate.isDeferred();\n-        }\n-\n-        if (deferred && !dict.supportsDeferredConstraints) {\n-            Log log = repos.getLog();\n-            if (log.isWarnEnabled())\n-                log.warn(_loc.get(prefix + \"-create-defer-unique\",\n-                    context, dict.platform));\n-            deferred = false;\n-        }\n-        \n-        if (StringUtils.isEmpty(name)) {\n-        \tname = cols[0].getName();\n-        \tname = repos.getDBDictionary().getValidUniqueName(name, table);\n-        }\n-        \n-        Unique unq = table.addUnique(name);\n-        unq.setDeferred(deferred);\n-        unq.setColumns(cols);\n-        return unq;\n-    }\n-\n-    /**\n-     * Retrieve/create a foreign key (possibly logical) on the given columns\n-     * by merging the given template information with any user-provided\n-     * information.\n-     *\n-     * @param context the mapping we're retrieving a key for\n-     * @param prefix localized error message key prefix\n-     * @param given the columns given by the user\n-     * @param def defaults provider\n-     * @param table the table for the key\n-     * @param cls type we're joining from\n-     * @param rel target type we're joining to\n-     * @param inversable whether the foreign key can be inversed\n-     * @param adapt whether we can modify the existing mapping or schema\n-     */\n-    protected ForeignKey createForeignKey(MetaDataContext context,\n-        String prefix, List given, ForeignKeyDefaults def, Table table,\n-        ClassMapping cls, ClassMapping rel, boolean inversable, boolean adapt) {\n-        assertTable(context, table);\n-        if (prefix == null)\n-            prefix = \"generic\";\n-\n-        // collect the foreign key columns and their targets\n-        Object[][] joins = createJoins(context, prefix, table, cls, rel,\n-            given, def, inversable, adapt);\n-        _join = JOIN_FORWARD;\n-\n-        // establish local table using any join between two columns; if we only\n-        // find constant joins, then keep default local table (directionless)\n-        Table local = table;\n-        Table foreign = rel.getTable();\n-        Table tmp;\n-        boolean constant = false;\n-        boolean localSet = false;\n-        for (int i = 0; i < joins.length; i++) {\n-            if (joins[i][1]instanceof Column) {\n-                tmp = ((Column) joins[i][0]).getTable();\n-                if (!localSet) {\n-                    local = tmp;\n-                    localSet = true;\n-                } else if (tmp != local)\n-                    throw new MetaDataException(_loc.get(prefix\n-                        + \"-mult-fk-tables\", context, local, tmp));\n-                foreign = ((Column) joins[i][1]).getTable();\n-\n-                if (joins[i][2] == Boolean.TRUE)\n-                    _join = JOIN_INVERSE;\n-            } else\n-                constant = true;\n-        }\n-\n-        // if this is not a constant join, look for existing foreign key\n-        // on local columns\n-        ForeignKey exist = null;\n-        if (!constant && local.getForeignKeys().length > 0) {\n-            Column[] cols = new Column[joins.length];\n-            Column[] pks = new Column[joins.length];\n-            for (int i = 0; i < joins.length; i++) {\n-                cols[i] = (Column) joins[i][0];\n-                pks[i] = (Column) joins[i][1];\n-            }\n-\n-            ForeignKey[] fks = local.getForeignKeys();\n-            for (int i = 0; i < fks.length; i++) {\n-                if (fks[i].getConstantColumns().length == 0\n-                    && fks[i].getConstantPrimaryKeyColumns().length == 0\n-                    && fks[i].columnsMatch(cols, pks)) {\n-                    exist = fks[i];\n-                    break;\n-                }\n-            }\n-        }\n-\n-        MappingRepository repos = (MappingRepository) context.getRepository();\n-        DBDictionary dict = repos.getDBDictionary();\n-        if (exist != null) {\n-            // make existing key logical?\n-            if (!_canFK) {\n-                if (exist.getDeleteAction() != exist.ACTION_NONE && !adapt)\n-                    throw new MetaDataException(_loc.get(prefix\n-                        + \"-fk-exists\", context));\n-                exist.setDeleteAction(exist.ACTION_NONE);\n-            }\n-\n-            if (_fk != null && _fk.isDeferred() && !exist.isDeferred()) {\n-                Log log = repos.getLog();\n-                if (log.isWarnEnabled())\n-                    log.warn(_loc.get(prefix + \"-defer-fk\", context));\n-            }\n-\n-            // allow user-given info to override existing key if we're adapting;\n-            // template info cannot override existing key\n-            if (adapt && _fk != null) {\n-                if (_fk.getUpdateAction() != ForeignKey.ACTION_NONE)\n-                    exist.setUpdateAction(_fk.getUpdateAction());\n-                if (_fk.getDeleteAction() != ForeignKey.ACTION_NONE)\n-                    exist.setDeleteAction(_fk.getDeleteAction());\n-            }\n-            setIOFromJoins(exist, joins);\n-            return exist;\n-        }\n-\n-        String name = null;\n-        int delAction = ForeignKey.ACTION_NONE;\n-        int upAction = ForeignKey.ACTION_NONE;\n-        boolean deferred = false;\n-        boolean fill = repos.getMappingDefaults().defaultMissingInfo();\n-        ForeignKey tmplate = (def == null) ? null\n-            : def.get(local, foreign, _join == JOIN_INVERSE);\n-        if (_fk != null && (tmplate == null || (!adapt && !fill))) {\n-            // if not adapting or no template info use given data\n-            name = _fk.getName();\n-            delAction = _fk.getDeleteAction();\n-            upAction = _fk.getUpdateAction();\n-            deferred = _fk.isDeferred();\n-        } else if (_canFK && (adapt || fill)) {\n-            if (_fk == null && tmplate != null) {\n-                // no user given info; use template data\n-                name = tmplate.getName();\n-                delAction = tmplate.getDeleteAction();\n-                upAction = tmplate.getUpdateAction();\n-                deferred = tmplate.isDeferred();\n-            } else if (_fk != null && tmplate != null) {\n-                // merge user and template data, always letting user info win\n-                name = _fk.getName();\n-                if (name == null && tmplate.getName() != null)\n-                    name = tmplate.getName();\n-                delAction = _fk.getDeleteAction();\n-                if (delAction == ForeignKey.ACTION_NONE)\n-                    delAction = tmplate.getDeleteAction();\n-                upAction = _fk.getUpdateAction();\n-                if (upAction == ForeignKey.ACTION_NONE)\n-                    upAction = tmplate.getUpdateAction();\n-                deferred = _fk.isDeferred();\n-            }\n-        }\n-\n-        if (!dict.supportsDeleteAction(delAction)\n-            || !dict.supportsUpdateAction(upAction)) {\n-            Log log = repos.getLog();\n-            if (log.isWarnEnabled())\n-                log.warn(_loc.get(prefix + \"-unsupported-fk-action\", context));\n-            delAction = ForeignKey.ACTION_NONE;\n-            upAction = ForeignKey.ACTION_NONE;\n-        }\n-        if (deferred && !dict.supportsDeferredConstraints) {\n-            Log log = repos.getLog();\n-            if (log.isWarnEnabled())\n-                log.warn(_loc.get(prefix + \"-create-defer-fk\",\n-                    context, dict.platform));\n-            deferred = false;\n-        }\n-\n-        // create foreign key with merged info\n-        ForeignKey fk = local.addForeignKey(name);\n-        fk.setDeleteAction(delAction);\n-        fk.setUpdateAction(upAction);\n-        fk.setDeferred(deferred);\n-\n-        // add joins to key\n-        Column col;\n-        for (int i = 0; i < joins.length; i++) {\n-            col = (Column) joins[i][0];\n-            if (joins[i][1]instanceof Column)\n-                fk.join(col, (Column) joins[i][1]);\n-            else if ((joins[i][2] == Boolean.TRUE) != (_join == JOIN_INVERSE))\n-                fk.joinConstant(joins[i][1], col);\n-            else\n-                fk.joinConstant(col, joins[i][1]);\n-        }\n-        setIOFromJoins(fk, joins);\n-        return fk;\n-    }\n-\n-    /**\n-     * Use the join information to populate our internal column I/O data.\n-     */\n-    private void setIOFromJoins(ForeignKey fk, Object[][] joins) {\n-        List cols = getColumns();\n-        _io = null;\n-        if (cols.isEmpty())\n-            return;\n-\n-        int constIdx = 0;\n-        int idx;\n-        for (int i = 0; i < joins.length; i++) {\n-            // const columns are indexed after std join columns in fk IO\n-            if (joins[i][1]instanceof Column)\n-                idx = i - constIdx;\n-            else if ((joins[i][2] == Boolean.TRUE) == (_join == JOIN_INVERSE))\n-                idx = fk.getColumns().length + constIdx++;\n-            else\n-                continue;\n-            setIOFromColumnFlags((Column) cols.get(i), idx);\n-        }\n-    }\n-\n-    /**\n-     * Create or retrieve the foreign key joins.\n-     *\n-     * @param context the mapping we're retrieving a key for\n-     * @param prefix localized error message key prefix\n-     * @param table the table for the key\n-     * @param cls type we're joining from, if applicable\n-     * @param rel target type we're joining to\n-     * @param given the columns given by the user\n-     * @param def foreign key defaults provider\n-     * @param inversable whether the foreign key can be inversed\n-     * @param adapt whether we can modify the existing mapping or schema\n-     * @return array of tuples where the first element is the\n-     * local column (or in the case of a constant join the\n-     * sole column), the second is the target column (or\n-     * constant), and the third is {@link Boolean#TRUE} if\n-     * this is an inverse join\n-     */\n-    private Object[][] createJoins(MetaDataContext context,\n-        String prefix, Table table, ClassMapping cls, ClassMapping rel,\n-        List given, ForeignKeyDefaults def, boolean inversable, boolean adapt) {\n-        MappingRepository repos = (MappingRepository) context.getRepository();\n-        boolean fill = repos.getMappingDefaults().defaultMissingInfo();\n-        Object[][] joins;\n-\n-        // if no columns given, just create mirrors of target columns\n-        if (given.isEmpty()) {\n-            if (!adapt && !fill)\n-                throw new MetaDataException(_loc.get(prefix + \"-no-fk-cols\",\n-                    context));\n-\n-            Column[] targets = rel.getPrimaryKeyColumns();\n-            joins = new Object[targets.length][3];\n-            Column tmplate;\n-            for (int i = 0; i < targets.length; i++) {\n-                tmplate = new Column();\n-                tmplate.setName(targets[i].getName());\n-                tmplate.setJavaType(targets[i].getJavaType());\n-                tmplate.setType(targets[i].getType());\n-                tmplate.setTypeName(targets[i].getTypeName());\n-                tmplate.setSize(targets[i].getSize());\n-                tmplate.setDecimalDigits(targets[i].getDecimalDigits());\n-\n-                if (def != null)\n-                    def.populate(table, rel.getTable(), tmplate, targets[i],\n-                        false, i, targets.length);\n-                joins[i][0] = mergeColumn(context, prefix, tmplate, true,\n-                    null, table, adapt, fill);\n-                joins[i][1] = targets[i];\n-            }\n-            return joins;\n-        }\n-\n-        // use given columns to create join.  we don't try to use any of the\n-        // template columns, even if the user doesn't give a column linking to\n-        // every primary key of the target type -- users are allowed to create\n-        // partial joins.  this means, though, that if a user wants to specify\n-        // info for one join column, he has to at least create elements for\n-        // all of them\n-\n-        joins = new Object[given.size()][3];\n-        Column col;\n-        for (int i = 0; i < joins.length; i++) {\n-            col = (Column) given.get(i);\n-            mergeJoinColumn(context, prefix, col, joins, i, table, cls, rel,\n-                def, inversable && !col.getFlag(Column.FLAG_PK_JOIN), adapt,\n-                fill);\n-        }\n-        return joins;\n-    }\n-\n-    /**\n-     * Create or retrieve a foreign key column for a join.\n-     *\n-     * @param context the mapping we're retrieving a key for\n-     * @param prefix localized error message key prefix\n-     * @param given the given local foreign key column\n-     * @param joins array of joins\n-     * @param idx index of the join array to populate\n-     * @param table the table for the key\n-     * @param cls the type we're joining from\n-     * @param rel target type we're joining to\n-     * @param def foreign key defaults provider;\n-     * use null to mirror target column names\n-     * @param inversable whether the foreign key can be inversed\n-     * @param adapt whether we can modify the existing mapping or schema\n-     * @param fill whether to default missing column information\n-     */\n-    private void mergeJoinColumn(MetaDataContext context, String prefix,\n-        Column given, Object[][] joins, int idx, Table table, ClassMapping cls,\n-        ClassMapping rel, ForeignKeyDefaults def, boolean inversable,\n-        boolean adapt, boolean fill) {\n-        // default to the primary key column name if this is a pk join\n-        String name = given.getName();\n-        if (name == null && given != null\n-            && given.getFlag(Column.FLAG_PK_JOIN) && cls != null) {\n-            Column[] pks = cls.getPrimaryKeyColumns();\n-            if (pks.length == 1)\n-                name = pks[0].getName();\n-        }\n-\n-        // if we can't adapt, then the user must at least give a column name\n-        if (name == null && !adapt && !fill)\n-            throw new MetaDataException(_loc.get(prefix + \"-no-fkcol-name\",\n-                context));\n-\n-        // check to see if the column isn't in the expected table; it might\n-        // be an inverse join or a join to a base class of the target type\n-        Table local = table;\n-        Table foreign = rel.getTable();\n-        boolean fullName = false;\n-        boolean inverse = false;\n-        if (name != null) {\n-            int dotIdx = name.lastIndexOf('.');\n-            if (dotIdx != -1) {\n-                // allow use of '.' without prefix to mean \"use expected\n-                // foreign table\"\n-                if (dotIdx == 0)\n-                    local = foreign;\n-                else\n-                    local = findTable(context, name.substring(0, dotIdx),\n-                        local, foreign, null);\n-                fullName = true;\n-                name = name.substring(dotIdx + 1);\n-\n-                // if inverse join, then swap local and foreign tables\n-                if (local != table) {\n-                    foreign = table;\n-                    inverse = true;\n-                }\n-            }\n-        }\n-        boolean forceInverse = !fullName && _join == JOIN_INVERSE;\n-        if (forceInverse) {\n-            local = foreign;\n-            foreign = table;\n-            inverse = true;\n-        }\n-\n-        // determine target\n-        String targetName = given.getTarget();\n-        Object target = null;\n-        Table ttable = null;\n-        boolean constant = false;\n-        boolean fullTarget = false;\n-        if (targetName == null && given.getTargetField() != null) {\n-            ClassMapping tcls = (inverse) ? cls : rel;\n-            String fieldName = given.getTargetField();\n-            int dotIdx = fieldName.lastIndexOf('.');\n-            fullTarget = dotIdx != -1;\n-\n-            if (dotIdx == 0) {\n-                // allow use of '.' without prefix to mean \"use expected local\n-                // cls\"; but if we already inversed no need to switch again\n-                if (!inverse)\n-                    tcls = cls;\n-                fieldName = fieldName.substring(1);\n-            } else if (dotIdx > 0) {\n-                // must be class + field name\n-                tcls = findClassMapping(context, fieldName.substring\n-                    (0, dotIdx), cls, rel);\n-                fieldName = fieldName.substring(dotIdx + 1);\n-            }\n-            if (tcls == null)\n-                throw new MetaDataException(_loc.get(prefix\n-                    + \"-bad-fktargetcls\", context, fieldName, name));\n-\n-            FieldMapping field = tcls.getFieldMapping(fieldName);\n-            if (field == null)\n-                throw new MetaDataException(_loc.get(prefix\n-                    + \"-bad-fktargetfield\", new Object[]{ context, fieldName,\n-                    name, tcls }));\n-            if (field.getColumns().length != 1)\n-                throw new MetaDataException(_loc.get(prefix\n-                    + \"-fktargetfield-cols\", context, fieldName, name));\n-            ttable = (field.getJoinForeignKey() != null) ? field.getTable()\n-                : field.getDefiningMapping().getTable();\n-            targetName = field.getColumns()[0].getName();\n-        } else if (targetName != null) {\n-            if (targetName.charAt(0) == '\\'') {\n-                constant = true;\n-                target = targetName.substring(1, targetName.length() - 1);\n-            } else if (targetName.charAt(0) == '-'\n-                || targetName.charAt(0) == '.'\n-                || Character.isDigit(targetName.charAt(0))) {\n-                constant = true;\n-                try {\n-                    if (targetName.indexOf('.') == -1)\n-                        target = new Integer(targetName);\n-                    else\n-                        target = new Double(targetName);\n-                } catch (RuntimeException re) {\n-                    throw new MetaDataException(_loc.get(prefix\n-                        + \"-bad-fkconst\", context, targetName, name));\n-                }\n-            } else if (\"null\".equalsIgnoreCase(targetName))\n-                constant = true;\n-            else {\n-                int dotIdx = targetName.lastIndexOf('.');\n-                fullTarget = dotIdx != -1;\n-                if (dotIdx == 0) {\n-                    // allow use of '.' without prefix to mean \"use expected\n-                    // local table\", but ignore if we're already inversed\n-                    if (!inverse)\n-                        ttable = local;\n-                    targetName = targetName.substring(1);\n-                } else if (dotIdx != -1) {\n-                    ttable = findTable(context, targetName.substring(0,\n-                        dotIdx), foreign, local, (inverse) ? cls : rel);\n-                    targetName = targetName.substring(dotIdx + 1);\n-                }\n-            }\n-        }\n-\n-        // use explicit target table if available\n-        if (ttable == local && local != foreign) {\n-            // swap, unless user gave incompatible table in column name\n-            if (fullName)\n-                throw new MetaDataException(_loc.get(prefix\n-                    + \"-bad-fktarget-inverse\", new Object[]{ context, name,\n-                    foreign, ttable }));\n-            local = foreign;\n-            foreign = ttable;\n-        } else if (ttable != null) {\n-            // ttable might be a table of a base class of the target\n-            foreign = ttable;\n-        }\n-\n-        // check to see if we inversed; if this is a same-table join, then\n-        // consider it an implicit inverse if the user includes the table name\n-        // in the column name, but not in the column target, or if the user\n-        // gives no column name but a full target name\n-        inverse = inverse || local != table || (local == foreign\n-            && ((fullName && !fullTarget) || (name == null && fullTarget)));\n-        if (!inversable && !constant && inverse) {\n-            if (local == foreign)\n-                throw new MetaDataException(_loc.get(prefix\n-                    + \"-bad-fk-self-inverse\", context, local));\n-            throw new MetaDataException(_loc.get(prefix + \"-bad-fk-inverse\",\n-                context, local, table));\n-        }\n-        if (name == null && constant)\n-            throw new MetaDataException(_loc.get(prefix\n-                + \"-no-fkcol-name-adapt\", context));\n-\n-        if (name == null && targetName == null) {\n-            // if no name or target is provided and there's more than one likely\n-            // join possibility, too ambiguous\n-            PrimaryKey pk = foreign.getPrimaryKey();\n-            if (joins.length != 1 || pk == null || pk.getColumns().length != 1)\n-                throw new MetaDataException(_loc.get(prefix\n-                    + \"-no-fkcol-name-adapt\", context));\n-\n-            // assume target is pk column\n-            targetName = pk.getColumns()[0].getName();\n-        } else if (name != null && targetName == null) {\n-            // if one primary key column use it for target; if multiple joins\n-            // look for a foreign column with same name as local column\n-            PrimaryKey pk = foreign.getPrimaryKey();\n-            if (joins.length == 1 && pk != null && pk.getColumns().length == 1)\n-                targetName = pk.getColumns()[0].getName();\n-            else if (foreign.getColumn(name) != null)\n-                targetName = name;\n-            else\n-                throw new MetaDataException(_loc.get(prefix\n-                    + \"-no-fkcol-target-adapt\", context, name));\n-        }\n-\n-        // find the target column, and create template for local column based\n-        // on it\n-        Column tmplate = new Column();\n-        tmplate.setName(name);\n-        if (!constant) {\n-            Column tcol = foreign.getColumn(targetName);\n-            if (tcol == null)\n-                throw new MetaDataException(_loc.get(prefix + \"-bad-fktarget\",\n-                    new Object[]{ context, targetName, name, foreign }));\n-\n-            if (name == null)\n-                tmplate.setName(tcol.getName());\n-            tmplate.setJavaType(tcol.getJavaType());\n-            tmplate.setType(tcol.getType());\n-            tmplate.setTypeName(tcol.getTypeName());\n-            tmplate.setSize(tcol.getSize());\n-            tmplate.setDecimalDigits(tcol.getDecimalDigits());\n-            target = tcol;\n-        } else if (target instanceof String)\n-            tmplate.setJavaType(JavaTypes.STRING);\n-        else if (target instanceof Integer)\n-            tmplate.setJavaType(JavaTypes.INT);\n-        else if (target instanceof Double)\n-            tmplate.setJavaType(JavaTypes.DOUBLE);\n-\n-        // populate template, but let user-given name override default name\n-        if (def != null)\n-            def.populate(local, foreign, tmplate, target, inverse, idx,\n-                joins.length);\n-        if (name != null)\n-            tmplate.setName(name);\n-\n-        // create or merge local column\n-        Column col = mergeColumn(context, prefix, tmplate, true, given, local,\n-            adapt, fill);\n-\n-        joins[idx][0] = col;\n-        joins[idx][1] = target;\n-        if (inverse)\n-            joins[idx][2] = Boolean.TRUE;\n-    }\n-\n-    /**\n-     * Find the target class mapping given the user's class name.\n-     *\n-     * @param context for error messages\n-     * @param clsName class name given by user\n-     * @param cls original source mapping\n-     * @param rel original target mapping\n-     */\n-    private static ClassMapping findClassMapping(MetaDataContext context,\n-        String clsName, ClassMapping cls, ClassMapping rel) {\n-        if (isClassMappingName(clsName, cls))\n-            return cls;\n-        if (isClassMappingName(clsName, rel))\n-            return rel;\n-        throw new MetaDataException(_loc.get(\"target-wrong-cls\", new Object[]\n-            { context, clsName, cls, rel }));\n-    }\n-\n-    /**\n-     * Return whether the given name matches the given mapping.\n-     */\n-    private static boolean isClassMappingName(String name, ClassMapping cls) {\n-        if (cls == null)\n-            return false;\n-        if (name.equals(cls.getDescribedType().getName())\n-            || name.equals(Strings.getClassName(cls.getDescribedType())))\n-            return true;\n-        return isClassMappingName(name, cls.getPCSuperclassMapping());\n-    }\n-\n-    /**\n-     * Sets internal column information to match the given mapped columns.\n-     *\n-     * @param forceJDBCType whether to force the jdbc-type of the columns\n-     * to be set, even when it matches the default for the columns' java type\n-     */\n-    protected void syncColumns(MetaDataContext context, Column[] cols,\n-        boolean forceJDBCType) {\n-        if (cols == null || cols.length == 0)\n-            _cols = null;\n-        else {\n-            _cols = new ArrayList(cols.length);\n-            Column col;\n-            for (int i = 0; i < cols.length; i++) {\n-                col = syncColumn(context, cols[i], cols.length,\n-                    forceJDBCType, cols[i].getTable(), null, null, false);\n-                setColumnFlagsFromIO(col, i);\n-                _cols.add(col);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Set I/O flags on the column.\n-     */\n-    private void setColumnFlagsFromIO(Column col, int i) {\n-        if (_io == null)\n-            return;\n-        col.setFlag(Column.FLAG_UNUPDATABLE, !_io.isUpdatable(i, false));\n-        col.setFlag(Column.FLAG_UNINSERTABLE, !_io.isInsertable(i, false));\n-    }\n-\n-    /**\n-     * Sets internal index information to match given mapped index.\n-     */\n-    protected void syncIndex(MetaDataContext context, Index idx) {\n-        if (idx == null) {\n-            _idx = null;\n-            return;\n-        }\n-\n-        _canIdx = true;\n-        _idx = new Index();\n-        _idx.setName(idx.getName());\n-        _idx.setUnique(idx.isUnique());\n-        if (idx.getColumns() != null && idx.getColumns().length > 1)\n-            _idx.setColumns(idx.getColumns());\n-    }\n-\n-    /**\n-     * Sets internal constraint information to match given mapped constraint.\n-     */\n-    protected void syncUnique(MetaDataContext context, Unique unq) {\n-        if (unq == null) {\n-            _unq = null;\n-            return;\n-        }\n-\n-        _canUnq = true;\n-        _unq = new Unique();\n-        _unq.setName(unq.getName());\n-        _unq.setDeferred(unq.isDeferred());\n-    }\n-    \n-    /**\n-     * Sets internal constraint and column information to match given mapped\n-     * constraint.\n-     *\n-     * @param local default local table\n-     * @param target default target table\n-     */\n-    protected void syncForeignKey(MetaDataContext context, ForeignKey fk,\n-        Table local, Table target) {\n-        if (fk == null) {\n-            _fk = null;\n-            _cols = null;\n-            _join = JOIN_NONE;\n-            return;\n-        }\n-        if (_join == JOIN_NONE)\n-            _join = JOIN_FORWARD;\n-\n-        if (fk.isLogical())\n-            _fk = null;\n-        else {\n-            _canFK = true;\n-            _fk = new ForeignKey();\n-            _fk.setName(fk.getName());\n-            _fk.setDeleteAction(fk.getDeleteAction());\n-            _fk.setUpdateAction(fk.getUpdateAction());\n-            _fk.setDeferred(fk.isDeferred());\n-        }\n-\n-        Column[] cols = fk.getColumns();\n-        Column[] pkCols = fk.getPrimaryKeyColumns();\n-        Column[] ccols = fk.getConstantColumns();\n-        Object[] cs = fk.getConstants();\n-        Column[] cpkCols = fk.getConstantPrimaryKeyColumns();\n-        Object[] cpks = fk.getPrimaryKeyConstants();\n-\n-        int size = cols.length + ccols.length + cpkCols.length;\n-        _cols = new ArrayList(size);\n-        Column col;\n-        for (int i = 0; i < cols.length; i++) {\n-            col = syncColumn(context, cols[i], size, false, local,\n-                target, pkCols[i], _join == JOIN_INVERSE);\n-            setColumnFlagsFromIO(col, i);\n-            _cols.add(col);\n-        }\n-        Object constant;\n-        for (int i = 0; i < ccols.length; i++) {\n-            constant = (cs[i] == null) ? NULL : cs[i];\n-            col = syncColumn(context, ccols[i], size, false, local,\n-                target, constant, _join == JOIN_INVERSE);\n-            setColumnFlagsFromIO(col, cols.length + i);\n-            _cols.add(col);\n-        }\n-        for (int i = 0; i < cpkCols.length; i++) {\n-            constant = (cpks[i] == null) ? NULL : cpks[i];\n-            _cols.add(syncColumn(context, cpkCols[i], size, false, target,\n-                local, constant, _join != JOIN_INVERSE));\n-        }\n-    }\n-\n-    /**\n-     * Create a copy of the given column with the raw mapping information\n-     * set correctly, and without settings that match defaults.\n-     *\n-     * @param num the number of columns for this mapping\n-     * @param forceJDBCType whether the jdbc-type of the created column\n-     * should be set, even if it matches the default\n-     * for the given column's java type\n-     * @param colTable expected table for the column\n-     * @param targetTable expected target table for join column\n-     * @param target target column or object for join column; for a\n-     * constant null target, use {@link #NULL}\n-     * @param inverse whether join column is for inverse join\n-     */\n-    protected static Column syncColumn(MetaDataContext context, Column col,\n-        int num, boolean forceJDBCType, Table colTable, Table targetTable,\n-        Object target, boolean inverse) {\n-        // use full name for cols that aren't in the expected table, or that\n-        // are inverse joins\n-        DBDictionary dict = ((MappingRepository) context.getRepository()).\n-            getDBDictionary();\n-        Column copy = new Column();\n-        if (col.getTable() != colTable || inverse)\n-            copy.setName(dict.getFullName(col.getTable(), true)\n-                + \".\" + col.getName());\n-        else\n-            copy.setName(col.getName());\n-\n-        // set target if not default\n-        if (target != null) {\n-            if (target == NULL)\n-                copy.setTarget(\"null\");\n-            else if (target instanceof Column) {\n-                Column tcol = (Column) target;\n-                if ((!inverse && tcol.getTable() != targetTable)\n-                    || (inverse && tcol.getTable() != colTable))\n-                    copy.setTarget(dict.getFullName(tcol.getTable(), true)\n-                        + \".\" + tcol.getName());\n-                else if (!defaultTarget(col, tcol, num))\n-                    copy.setTarget(tcol.getName());\n-            } else if (target instanceof Number)\n-                copy.setTarget(target.toString());\n-            else\n-                copy.setTarget(\"'\" + target + \"'\");\n-        } else if (num > 1)\n-            copy.setTargetField(col.getTargetField());\n-\n-        if (col.getSize() != 0 && col.getSize() != dict.characterColumnSize\n-            && (col.getSize() != -1 || !col.isLob()))\n-            copy.setSize(col.getSize());\n-        if (col.getDecimalDigits() != 0)\n-            copy.setDecimalDigits(col.getDecimalDigits());\n-        if (col.getDefaultString() != null)\n-            copy.setDefaultString(col.getDefaultString());\n-        if (col.isNotNull() && !col.isPrimaryKey()\n-            && (!isPrimitive(col.getJavaType()) || isForeignKey(col)))\n-            copy.setNotNull(true);\n-\n-        // set type name if not default\n-        String typeName = col.getTypeName();\n-        if (typeName != null || copy.getSize() != 0\n-            || copy.getDecimalDigits() != 0) {\n-            // is this the dict default type? have to ensure jdbc-type set\n-            // prior to finding dict default\n-            copy.setType(col.getType());\n-            String defName = dict.getTypeName(copy);\n-            copy.setType(Types.OTHER);\n-\n-            // copy should not have size info set if it isn't used in type name\n-            boolean defSized = defName.indexOf('(') != -1;\n-            if (!defSized) {\n-                if (copy.getSize() > 0)\n-                    copy.setSize(0);\n-                copy.setDecimalDigits(0);\n-            }\n-\n-            if (typeName != null) {\n-                // make sure to strip size for comparison\n-                if (typeName.indexOf('(') == -1 && defSized)\n-                    defName = defName.substring(0, defName.indexOf('('));\n-                if (!typeName.equalsIgnoreCase(defName))\n-                    copy.setTypeName(typeName);\n-            }\n-        }\n-\n-        // set jdbc-type if not default or if forced\n-        if (forceJDBCType\n-            || (target != null && !(target instanceof Column)\n-            && col.getType() != Types.VARCHAR)\n-            || dict.getJDBCType(col.getJavaType(), false) != col.getType())\n-            copy.setType(col.getType());\n-\n-        return copy;\n-    }\n-\n-    /** \n-     * Return whether the given column belongs to a foreign key.\n-     */ \n-    private static boolean isForeignKey(Column col) \n-    {       \n-        if (col.getTable() == null)\n-            return false;\n-        ForeignKey[] fks = col.getTable().getForeignKeys();\n-        for (int i = 0; i < fks.length; i++) \n-            if (fks[i].containsColumn(col) \n-                || fks[i].containsConstantColumn(col))\n-                return true;\n-        return false;\n-    }\n-\n-    /**\n-     * Return true if the given type code represents a primitive.\n-     */\n-    private static boolean isPrimitive(int type) {\n-        switch (type) {\n-            case JavaTypes.BOOLEAN:\n-            case JavaTypes.BYTE:\n-            case JavaTypes.CHAR:\n-            case JavaTypes.DOUBLE:\n-            case JavaTypes.FLOAT:\n-            case JavaTypes.INT:\n-            case JavaTypes.LONG:\n-            case JavaTypes.SHORT:\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    /**\n-     * Return true if the given target column matches the default.\n-     * If there is only one column involved in the join and it links to the\n-     * single target table pk column, or if the column name is the same as\n-     * the target column name, then the target is the default.\n-     */\n-    private static boolean defaultTarget(Column col, Column targetCol,\n-        int num) {\n-        if (col.getName().equals(targetCol.getName()))\n-            return true;\n-        if (num > 1)\n-            return false;\n-\n-        PrimaryKey pk = targetCol.getTable().getPrimaryKey();\n-        if (pk == null || pk.getColumns().length != 1)\n-            return false;\n-        return targetCol == pk.getColumns()[0];\n-    }\n-\n-    /**\n-     * Supplies default table information.\n-     */\n-    public static interface TableDefaults {\n-\n-        /**\n-         * Return the default table name.\n-         */\n-        public String get(Schema schema);\n-    }\n-\n-    /**\n-     * Supplies default foreign key information.\n-     */\n-    public static interface ForeignKeyDefaults {\n-\n-        /**\n-         * Return a default foreign key for the given tables, or null to\n-         * create a logical foreign key only. Do not fill in the columns of\n-         * the foreign key, only attributes like its name, delete action, etc.\n-         * Do not add the foreign key to the table.\n-         */\n-        public ForeignKey get(Table local, Table foreign, boolean inverse);\n-\n-        /**\n-         * Populate the given foreign key column with defaults.\n-         *\n-         * @param target the target column or constant value\n-         * @param pos the index of this column in the foreign key\n-         * @param cols the number of columns in the foreign key\n-         */\n-        public void populate(Table local, Table foreign, Column col,\n-            Object target, boolean inverse, int pos, int cols);\n-\t}\n-}"},{"sha":"bbd7ef52637c9fc04b9d1e00427ef8c4fd3642cf","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","status":"removed","additions":0,"deletions":1347,"changes":1347,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,1347 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.lang.reflect.Modifier;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.sql.Types;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-\n-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n-import org.apache.openjpa.jdbc.meta.strats.BlobValueHandler;\n-import org.apache.openjpa.jdbc.meta.strats.ByteArrayValueHandler;\n-import org.apache.openjpa.jdbc.meta.strats.CharArrayStreamValueHandler;\n-import org.apache.openjpa.jdbc.meta.strats.CharArrayValueHandler;\n-import org.apache.openjpa.jdbc.meta.strats.ClassNameDiscriminatorStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.ClobValueHandler;\n-import org.apache.openjpa.jdbc.meta.strats.ElementEmbedValueHandler;\n-import org.apache.openjpa.jdbc.meta.strats.EmbedFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.EmbeddedClassStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.FlatClassStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.FullClassStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.HandlerCollectionTableFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.HandlerFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.HandlerHandlerMapTableFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.HandlerRelationMapTableFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.ImmutableValueHandler;\n-import org.apache.openjpa.jdbc.meta.strats.LobFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.MaxEmbeddedBlobFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.MaxEmbeddedByteArrayFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.MaxEmbeddedCharArrayFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.MaxEmbeddedClobFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.NanoPrecisionTimestampVersionStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.NoneClassStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.NoneDiscriminatorStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.NoneFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.NoneVersionStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.NumberVersionStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.ObjectIdClassStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.ObjectIdValueHandler;\n-import org.apache.openjpa.jdbc.meta.strats.PrimitiveFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.RelationCollectionInverseKeyFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.RelationCollectionTableFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.RelationFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.RelationHandlerMapTableFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.RelationMapInverseKeyFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.RelationMapTableFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.RelationRelationMapTableFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.StateComparisonVersionStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.StringFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.SubclassJoinDiscriminatorStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.SuperclassDiscriminatorStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.SuperclassVersionStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.TimestampVersionStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.UntypedPCValueHandler;\n-import org.apache.openjpa.jdbc.meta.strats.ValueMapDiscriminatorStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.VerticalClassStrategy;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.SchemaGroup;\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\n-import org.apache.openjpa.jdbc.sql.JoinSyntaxes;\n-import org.apache.openjpa.lib.conf.Configurable;\n-import org.apache.openjpa.lib.conf.Configurations;\n-import org.apache.openjpa.lib.util.J2DoPrivHelper;\n-import org.apache.openjpa.lib.util.JavaVersions;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.meta.FieldMetaData;\n-import org.apache.openjpa.meta.JavaTypes;\n-import org.apache.openjpa.meta.MetaDataRepository;\n-import org.apache.openjpa.meta.Order;\n-import org.apache.openjpa.meta.SequenceMetaData;\n-import org.apache.openjpa.meta.ValueMetaData;\n-import org.apache.openjpa.util.MetaDataException;\n-\n-/**\n- * Repository of object/relational mapping information.\n- *\n- * @author Abe White\n- */\n-public class MappingRepository\n-    extends MetaDataRepository {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (MappingRepository.class);\n-\n-    private transient DBDictionary _dict = null;\n-    private transient MappingDefaults _defaults = null;\n-    \n-    private Map _results = new HashMap(); // object->queryresultmapping\n-    private SchemaGroup _schema = null;\n-    private StrategyInstaller _installer = null;\n-\n-    /**\n-     * Default constructor.  Configure via \n-     * {@link org.apache.openjpa.lib.conf.Configurable}.\n-     */\n-    public MappingRepository() {\n-        setValidate(VALIDATE_MAPPING, true);\n-    }\n-\n-    /**\n-     * Convenient access to dictionary for mappings.\n-     */\n-    public DBDictionary getDBDictionary() {\n-        return _dict;\n-    }\n-\n-    /**\n-     * Mapping defaults.\n-     */\n-    public MappingDefaults getMappingDefaults() {\n-        return _defaults;\n-    }\n-\n-    /**\n-     * Mapping default.\n-     */\n-    public void setMappingDefaults(MappingDefaults defaults) {\n-        _defaults = defaults;\n-    }\n-\n-    /**\n-     * Representation of the database schema.\n-     */\n-    public synchronized SchemaGroup getSchemaGroup() {\n-        if (_schema == null)\n-            _schema = ((JDBCConfiguration) getConfiguration()).\n-                getSchemaFactoryInstance().readSchema();\n-        return _schema;\n-    }\n-\n-    /**\n-     * Representation of the database schema.\n-     */\n-    public synchronized void setSchemaGroup(SchemaGroup schema) {\n-        _schema = schema;\n-    }\n-\n-    /**\n-     * Installs mapping strategies on components.\n-     */\n-    public synchronized StrategyInstaller getStrategyInstaller() {\n-        if (_installer == null)\n-            _installer = new RuntimeStrategyInstaller(this);\n-        return _installer;\n-    }\n-\n-    /**\n-     * Installs mapping strategies on components.\n-     */\n-    public synchronized void setStrategyInstaller(StrategyInstaller installer) {\n-        _installer = installer;\n-    }\n-\n-    /**\n-     * Return the query result mapping for the given name.\n-     */\n-    public synchronized QueryResultMapping getQueryResultMapping(Class cls,\n-        String name, ClassLoader envLoader, boolean mustExist) {\n-        QueryResultMapping res = getQueryResultMappingInternal(cls, name,\n-            envLoader);\n-        if (res == null && mustExist)\n-            throw new MetaDataException(_loc.get(\"no-query-res\", cls, name));\n-        return res;\n-    }\n-\n-    /**\n-     * Returned the query result mapping with the given name.\n-     */\n-    private QueryResultMapping getQueryResultMappingInternal(Class cls,\n-        String name, ClassLoader envLoader) {\n-        if (name == null)\n-            return null;\n-\n-        // check cache\n-        Object key = getQueryResultKey(cls, name);\n-        QueryResultMapping res = (QueryResultMapping) _results.get(key);\n-        if (res != null)\n-            return res;\n-\n-        // get metadata for class, which will find results in metadata file\n-        if (cls != null && getMetaData(cls, envLoader, false) != null) {\n-            res = (QueryResultMapping) _results.get(key);\n-            if (res != null)\n-                return res;\n-        }\n-        if ((getSourceMode() & MODE_QUERY) == 0)\n-            return null;\n-\n-        if (cls == null)\n-            cls = getMetaDataFactory()\n-                    .getResultSetMappingScope(name, envLoader);\n-        // not in cache; load\n-        getMetaDataFactory().load(cls, MODE_META | MODE_MAPPING, envLoader);\n-        return (QueryResultMapping) _results.get(key);\n-    }\n-\n-    /**\n-     * Return all cached query result mappings.\n-     */\n-    public synchronized QueryResultMapping[] getQueryResultMappings() {\n-        Collection values = _results.values();\n-        return (QueryResultMapping[]) values.toArray\n-            (new QueryResultMapping[values.size()]);\n-    }\n-\n-    /**\n-     * Return the cached query result mapping with the given name, or null if\n-     * none.\n-     */\n-    public synchronized QueryResultMapping getCachedQueryResultMapping\n-        (Class cls, String name) {\n-        return (QueryResultMapping) _results.get(getQueryResultKey(cls, name));\n-    }\n-\n-    /**\n-     * Add a query result mapping.\n-     */\n-    public synchronized QueryResultMapping addQueryResultMapping(Class cls,\n-        String name) {\n-        QueryResultMapping res = new QueryResultMapping(name, this);\n-        res.setDefiningType(cls);\n-        _results.put(getQueryResultKey(res), res);\n-        return res;\n-    }\n-\n-    /**\n-     * Remove a query result mapping.\n-     */\n-    public synchronized boolean removeQueryResultMapping\n-        (QueryResultMapping res) {\n-        return _results.remove(getQueryResultKey(res)) != null;\n-    }\n-\n-    /**\n-     * Remove a query result mapping.\n-     */\n-    public synchronized boolean removeQueryResultMapping(Class cls,\n-        String name) {\n-        if (name == null)\n-            return false;\n-        return _results.remove(getQueryResultKey(cls, name)) != null;\n-    }\n-\n-    /**\n-     * Return a unique key for the given mapping.\n-     */\n-    private static Object getQueryResultKey(QueryResultMapping res) {\n-        if (res == null)\n-            return null;\n-        return getQueryResultKey(res.getDefiningType(), res.getName());\n-    }\n-\n-    /**\n-     * Return a unique key for the given class / name. The class argument\n-     * can be null.\n-     */\n-    private static Object getQueryResultKey(Class cls, String name) {\n-        return getQueryKey(cls, name);\n-    }\n-\n-    public ClassMapping getMapping(Class cls, ClassLoader envLoader,\n-        boolean mustExist) {\n-        return (ClassMapping) super.getMetaData(cls, envLoader, mustExist);\n-    }\n-\n-    public ClassMapping[] getMappings() {\n-        return (ClassMapping[]) super.getMetaDatas();\n-    }\n-\n-    public ClassMapping getMapping(Object oid, ClassLoader envLoader,\n-        boolean mustExist) {\n-        return (ClassMapping) super.getMetaData(oid, envLoader, mustExist);\n-    }\n-\n-    public ClassMapping[] getImplementorMappings(Class cls,\n-        ClassLoader envLoader, boolean mustExist) {\n-        return (ClassMapping[]) super.getImplementorMetaDatas(cls, envLoader,\n-            mustExist);\n-    }\n-\n-    public synchronized void clear() {\n-        super.clear();\n-        _schema = null;\n-        _results.clear();\n-    }\n-\n-    protected void prepareMapping(ClassMetaData meta) {\n-        // make sure superclass resolved first; resolving superclass may have\n-        // resolved this mapping\n-        ClassMapping mapping = (ClassMapping) meta;\n-        ClassMapping sup = mapping.getPCSuperclassMapping();\n-        if (sup != null && (mapping.getResolve() & MODE_MAPPING) != 0)\n-            return;\n-        \n-        // if this mapping is not for a managed interface, ensure that if \n-        // we have an inheritance hierarchy there is a default strategy\n-        // applied to the root class\n-        if (!mapping.getDescribedType().isInterface() &&\n-            !mapping.isEmbeddedOnly()) {\n-            // if an inheritance strategy has not been set on this mapping\n-            // determine if needs one and if so, set it\n-            if (!hasInheritanceStrategy(mapping)) {\n-                ClassMapping baseMapping = findBaseClassMapping(mapping); \n-                if (baseMapping != null)\n-                    setDefaultInheritanceStrategy(baseMapping);\n-            }            \n-        }\n-\n-        // define superclass fields after mapping class, so we can tell whether\n-        // the class is mapped and needs to redefine abstract superclass fields\n-        getStrategyInstaller().installStrategy(mapping);\n-        mapping.defineSuperclassFields(mapping.getJoinablePCSuperclassMapping()\n-            == null);\n-\n-        // resolve everything that doesn't involve relations to allow relation\n-        // mappings to use the others as joinables\n-        mapping.resolveNonRelationMappings();\n-    }\n-\n-    protected ClassMetaData newClassMetaData(Class type) {\n-        return new ClassMapping(type, this);\n-    }\n-\n-    protected ClassMetaData[] newClassMetaDataArray(int length) {\n-        return new ClassMapping[length];\n-    }\n-\n-    protected FieldMetaData newFieldMetaData(String name, Class type,\n-        ClassMetaData owner) {\n-        return new FieldMapping(name, type, (ClassMapping) owner);\n-    }\n-\n-    protected FieldMetaData[] newFieldMetaDataArray(int length) {\n-        return new FieldMapping[length];\n-    }\n-\n-    protected ClassMetaData newEmbeddedClassMetaData(ValueMetaData owner) {\n-        return new ClassMapping(owner);\n-    }\n-\n-    protected ValueMetaData newValueMetaData(FieldMetaData owner) {\n-        return new ValueMappingImpl((FieldMapping) owner);\n-    }\n-\n-    protected SequenceMetaData newSequenceMetaData(String name) {\n-        return new SequenceMapping(name, this);\n-    }\n-\n-    protected Order newValueOrder(FieldMetaData owner, boolean asc) {\n-        return new JDBCValueOrder((FieldMapping) owner, asc);\n-    }\n-\n-    protected Order newRelatedFieldOrder(FieldMetaData owner,\n-        FieldMetaData rel, boolean asc) {\n-        return new JDBCRelatedFieldOrder((FieldMapping) owner,\n-            (FieldMapping) rel, asc);\n-    }\n-\n-    protected Order[] newOrderArray(int size) {\n-        return new JDBCOrder[size];\n-    }\n-\n-    /**\n-     * Create version metadata for the given class.\n-     */\n-    protected Version newVersion(ClassMapping cls) {\n-        return new Version(cls);\n-    }\n-\n-    /**\n-     * Create discriminator metadata for the given class.\n-     */\n-    protected Discriminator newDiscriminator(ClassMapping cls) {\n-        return new Discriminator(cls);\n-    }\n-\n-    /**\n-     * Create raw mapping info for the given instance.\n-     */\n-    protected ClassMappingInfo newMappingInfo(ClassMapping cls) {\n-        ClassMappingInfo info = new ClassMappingInfo();\n-        info.setClassName(cls.getDescribedType().getName());\n-        return info;\n-    }\n-\n-    /**\n-     * Create raw mapping info for the given instance.\n-     */\n-    protected FieldMappingInfo newMappingInfo(FieldMapping fm) {\n-        return new FieldMappingInfo();\n-    }\n-\n-    /**\n-     * Create raw mapping info for the given instance.\n-     */\n-    protected ValueMappingInfo newMappingInfo(ValueMapping vm) {\n-        return new ValueMappingInfo();\n-    }\n-\n-    /**\n-     * Create raw mapping info for the given instance.\n-     */\n-    protected VersionMappingInfo newMappingInfo(Version version) {\n-        return new VersionMappingInfo();\n-    }\n-\n-    /**\n-     * Create raw mapping info for the given instance.\n-     */\n-    protected DiscriminatorMappingInfo newMappingInfo(Discriminator disc) {\n-        return new DiscriminatorMappingInfo();\n-    }\n-\n-    /**\n-     * Instantiate the given class' named strategy, or return null if no\n-     * named strategy.\n-     */\n-    protected ClassStrategy namedStrategy(ClassMapping cls) {\n-        String name = cls.getMappingInfo().getStrategy();\n-        return instantiateClassStrategy(name, cls);\n-    }\n-\n-    /**\n-     * Return the strategy for the given name.\n-     */\n-    protected ClassStrategy instantiateClassStrategy(String name,\n-        ClassMapping cls) {\n-        if (name == null)\n-            return null;\n-        if (NoneClassStrategy.ALIAS.equals(name))\n-            return NoneClassStrategy.getInstance();\n-\n-        String props = Configurations.getProperties(name);\n-        name = Configurations.getClassName(name);\n-        Class strat = null;\n-\n-        // base and vertical strategies use same alias; differentiate on join\n-        if (FullClassStrategy.ALIAS.equals(name))\n-            strat = FullClassStrategy.class;\n-        else if (FlatClassStrategy.ALIAS.equals(name))\n-            strat = FlatClassStrategy.class;\n-        else if (VerticalClassStrategy.ALIAS.equals(name))\n-            strat = VerticalClassStrategy.class;\n-        try {\n-            if (strat == null)\n-                strat = JavaTypes.classForName(name, cls,\n-                    (ClassLoader) AccessController.doPrivileged(\n-                        J2DoPrivHelper.getClassLoaderAction(\n-                            ClassStrategy.class)));\n-            ClassStrategy strategy = \n-                (ClassStrategy) AccessController.doPrivileged(\n-                    J2DoPrivHelper.newInstanceAction(strat));\n-            Configurations.configureInstance(strategy, getConfiguration(),\n-                props);\n-            return strategy;\n-        } catch (Exception e) {\n-            if (e instanceof PrivilegedActionException)\n-                e = ((PrivilegedActionException) e).getException();\n-            throw new MetaDataException(_loc.get(\"bad-cls-strategy\",\n-                cls, name), e);\n-        }\n-    }\n-\n-    /**\n-     * Instantiate the given field's named strategy, or return null if no\n-     * named strategy.\n-     */\n-    protected FieldStrategy namedStrategy(FieldMapping field,\n-        boolean installHandlers) {\n-        String name = field.getMappingInfo().getStrategy();\n-        if (name == null)\n-            return null;\n-\n-        if (NoneFieldStrategy.ALIAS.equals(name))\n-            return NoneFieldStrategy.getInstance();\n-\n-        String props = Configurations.getProperties(name);\n-        name = Configurations.getClassName(name);\n-        try {\n-            Class c = JavaTypes.classForName(name, field,\n-                (ClassLoader) AccessController.doPrivileged(\n-                    J2DoPrivHelper.getClassLoaderAction(FieldStrategy.class)));\n-            if (FieldStrategy.class.isAssignableFrom(c)) {\n-                FieldStrategy strat = (FieldStrategy)\n-                    AccessController.doPrivileged(\n-                        J2DoPrivHelper.newInstanceAction(c));\n-                Configurations.configureInstance(strat, getConfiguration(),\n-                    props);\n-                return strat;\n-            }\n-\n-            // must be named handler\n-            if (installHandlers) {\n-                ValueHandler vh = (ValueHandler) AccessController.doPrivileged(\n-                    J2DoPrivHelper.newInstanceAction(c));\n-                Configurations.configureInstance(vh, getConfiguration(),\n-                    props);\n-                field.setHandler(vh);\n-            }\n-            return new HandlerFieldStrategy();\n-        } catch (Exception e) {\n-            if (e instanceof PrivilegedActionException)\n-                e = ((PrivilegedActionException) e).getException();\n-            throw new MetaDataException(_loc.get(\"bad-field-strategy\",\n-                field, name), e);\n-        }\n-    }\n-\n-    /**\n-     * Instantiate the given discriminator's named strategy, or return null\n-     * if no named strategy.\n-     */\n-    protected DiscriminatorStrategy namedStrategy(Discriminator discrim) {\n-        String name = discrim.getMappingInfo().getStrategy();\n-        if (name == null)\n-            return null;\n-\n-        // if there is a named strategy present, discard it if it matches\n-        // the base strategy, so that we won't create an independent instance\n-        ClassMapping cls = discrim.getClassMapping();\n-        while (cls.getJoinablePCSuperclassMapping() != null)\n-            cls = cls.getJoinablePCSuperclassMapping();\n-        Discriminator base = cls.getDiscriminator();\n-        if (base != discrim && base.getStrategy() != null\n-            && name.equals(base.getStrategy().getAlias()))\n-            return null;\n-\n-        return instantiateDiscriminatorStrategy(name, discrim);\n-    }\n-\n-    /**\n-     * Instantiate the given discriminator strategy.\n-     */\n-    protected DiscriminatorStrategy instantiateDiscriminatorStrategy\n-        (String name, Discriminator discrim) {\n-        if (NoneDiscriminatorStrategy.ALIAS.equals(name))\n-            return NoneDiscriminatorStrategy.getInstance();\n-\n-        String props = Configurations.getProperties(name);\n-        name = Configurations.getClassName(name);\n-        Class strat = null;\n-\n-        if (ClassNameDiscriminatorStrategy.ALIAS.equals(name))\n-            strat = ClassNameDiscriminatorStrategy.class;\n-        else if (ValueMapDiscriminatorStrategy.ALIAS.equals(name))\n-            strat = ValueMapDiscriminatorStrategy.class;\n-        else if (SubclassJoinDiscriminatorStrategy.ALIAS.equals(name))\n-            strat = SubclassJoinDiscriminatorStrategy.class;\n-\n-        try {\n-            if (strat == null)\n-                strat = JavaTypes.classForName(name,\n-                    discrim.getClassMapping(),\n-                    (ClassLoader) AccessController.doPrivileged(\n-                        J2DoPrivHelper.getClassLoaderAction(\n-                            DiscriminatorStrategy.class)));\n-            DiscriminatorStrategy strategy = (DiscriminatorStrategy)\n-                AccessController.doPrivileged(\n-                    J2DoPrivHelper.newInstanceAction(strat));\n-            Configurations.configureInstance(strategy, getConfiguration(),\n-                props);\n-            return strategy;\n-        } catch (Exception e) {\n-            if (e instanceof PrivilegedActionException)\n-                e = ((PrivilegedActionException) e).getException();\n-            throw new MetaDataException(_loc.get(\"bad-discrim-strategy\",\n-                discrim.getClassMapping(), name), e);\n-        }\n-    }\n-\n-    /**\n-     * Instantiate the given version's named strategy, or return null\n-     * if no named strategy.\n-     */\n-    protected VersionStrategy namedStrategy(Version version) {\n-        String name = version.getMappingInfo().getStrategy();\n-        if (name == null)\n-            return null;\n-\n-        // if there is a named strategy present, discard it if it matches\n-        // the base strategy, so that we won't create an independent instance\n-        ClassMapping cls = version.getClassMapping();\n-        while (cls.getJoinablePCSuperclassMapping() != null)\n-            cls = cls.getJoinablePCSuperclassMapping();\n-        Version base = cls.getVersion();\n-        if (base != version && base.getStrategy() != null\n-            && name.equals(base.getStrategy().getAlias()))\n-            return null;\n-\n-        return instantiateVersionStrategy(name, version);\n-    }\n-\n-    /**\n-     * Instantiate the given version strategy.\n-     */\n-    protected VersionStrategy instantiateVersionStrategy(String name,\n-        Version version) {\n-        if (NoneVersionStrategy.ALIAS.equals(name))\n-            return NoneVersionStrategy.getInstance();\n-\n-        String props = Configurations.getProperties(name);\n-        name = Configurations.getClassName(name);\n-        Class strat = null;\n-\n-        if (NumberVersionStrategy.ALIAS.equals(name))\n-            strat = NumberVersionStrategy.class;\n-        else if (TimestampVersionStrategy.ALIAS.equals(name))\n-            strat = TimestampVersionStrategy.class;\n-        else if (NanoPrecisionTimestampVersionStrategy.ALIAS.equals(name))\n-            strat = NanoPrecisionTimestampVersionStrategy.class;\n-        else if (StateComparisonVersionStrategy.ALIAS.equals(name))\n-            strat = StateComparisonVersionStrategy.class;\n-\n-        try {\n-            if (strat == null)\n-                strat = JavaTypes.classForName(name,\n-                    version.getClassMapping(),\n-                    (ClassLoader) AccessController.doPrivileged(\n-                        J2DoPrivHelper.getClassLoaderAction(\n-                            VersionStrategy.class)));\n-        } catch (Exception e) {\n-            throw new MetaDataException(_loc.get(\"bad-version-strategy\",\n-                version.getClassMapping(), name), e);\n-        }\n-\n-        return instantiateVersionStrategy(strat, version, props);\n-    }\n-\n-    /**\n-     * Instantiate the given version strategy.\n-     */\n-    protected VersionStrategy instantiateVersionStrategy(Class strat,\n-        Version version, String props) {\n-        try {\n-            VersionStrategy strategy = (VersionStrategy)\n-                AccessController.doPrivileged(\n-                    J2DoPrivHelper.newInstanceAction(strat));\n-            Configurations.configureInstance(strategy, getConfiguration(),\n-                props);\n-            return strategy;\n-        } catch (Exception e) {\n-            if (e instanceof PrivilegedActionException)\n-                e = ((PrivilegedActionException) e).getException();\n-            throw new MetaDataException(_loc.get(\"bad-version-strategy\",\n-                version.getClassMapping(), strat + \"\"), e);\n-        }\n-    }\n-\n-    /**\n-     * Determine the default strategy to use for the given class. Does\n-     * not take into account the current strategy, if any.\n-     */\n-    protected ClassStrategy defaultStrategy(ClassMapping cls) {\n-        return defaultStrategy(cls, getStrategyInstaller().isAdapting());\n-    }\n-\n-    /**\n-     * Determine the default strategy to use for the given class. Does\n-     * not take into account the current strategy, if any.\n-     */\n-    protected ClassStrategy defaultStrategy(ClassMapping cls,\n-        boolean adapting) {\n-        ValueMapping embed = cls.getEmbeddingMapping();\n-        if (embed != null) {\n-            // superclass of embedded class isn't mapped\n-            if (embed.getType() != cls.getDescribedType()\n-                || embed.getFieldMapping().getStrategy()\n-                == NoneFieldStrategy.getInstance())\n-                return NoneClassStrategy.getInstance();\n-            if (embed.getTypeCode() == JavaTypes.OID)\n-                return new ObjectIdClassStrategy();\n-            return new EmbeddedClassStrategy();\n-        }\n-        if (cls.isEmbeddedOnly())\n-            return NoneClassStrategy.getInstance();\n-\n-        Object strat = _defaults.getStrategy(cls, adapting);\n-        if (strat instanceof String)\n-            return instantiateClassStrategy((String) strat, cls);\n-        if (strat != null)\n-            return (ClassStrategy) strat;\n-        \n-        // see if there is a declared hierarchy strategy\n-        ClassStrategy hstrat = null;\n-        for (ClassMapping base = cls; base != null && hstrat == null;) {\n-            hstrat = instantiateClassStrategy(base.getMappingInfo().\n-                getHierarchyStrategy(), cls);\n-            base = base.getMappedPCSuperclassMapping();\n-        }\n-\n-        // the full strategy as applied to a hierarchy is a\n-        // table-per-concrete-class strategy, so don't map abstract types\n-        if (hstrat instanceof FullClassStrategy\n-            && !cls.isManagedInterface()\n-            && Modifier.isAbstract(cls.getDescribedType().getModifiers()))\n-            return NoneClassStrategy.getInstance();\n-        \n-        ClassMapping sup = cls.getMappedPCSuperclassMapping();\n-        if (sup == null)\n-            return new FullClassStrategy();\n-        if (hstrat != null)\n-            return hstrat;\n-        return new FlatClassStrategy();\n-    }\n-\n-    /**\n-     * Determine the default strategy to use for the given field. Does\n-     * not take into account the named or current strategy, if any. If a\n-     * non-null strategy is returned, this method may as a side effect install\n-     * value handlers on the field's value mappings.\n-     */\n-    protected FieldStrategy defaultStrategy(FieldMapping field,\n-        boolean installHandlers) {\n-        return defaultStrategy(field, installHandlers,\n-            getStrategyInstaller().isAdapting());\n-    }\n-\n-    /**\n-     * Determine the default strategy to use for the given field. Does\n-     * not take into account the named or current strategy, if any. If a\n-     * non-null strategy is returned, this method may as a side effect install\n-     * value handlers on the field's value mappings.\n-     */\n-    protected FieldStrategy defaultStrategy(FieldMapping field,\n-        boolean installHandlers, boolean adapting) {\n-        // not persistent?\n-        if (field.getManagement() != field.MANAGE_PERSISTENT\n-            || field.isVersion())\n-            return NoneFieldStrategy.getInstance();\n-        if (field.getDefiningMapping().getStrategy() ==\n-            NoneClassStrategy.getInstance())\n-            return NoneFieldStrategy.getInstance();\n-\n-        // check for named handler first\n-        ValueHandler handler = namedHandler(field);\n-        if (handler != null) {\n-            if (installHandlers)\n-                field.setHandler(handler);\n-            return new HandlerFieldStrategy();\n-        }\n-\n-        if (field.isSerialized()) {\n-            if (_dict.maxEmbeddedBlobSize != -1)\n-                return new MaxEmbeddedBlobFieldStrategy();\n-        } else {\n-            // check for mapped strategy\n-            Object strat = mappedStrategy(field, field.getType(), adapting);\n-            if (strat instanceof FieldStrategy)\n-                return (FieldStrategy) strat;\n-            if (strat != null) {\n-                if (installHandlers)\n-                    field.setHandler((ValueHandler) strat);\n-                return new HandlerFieldStrategy();\n-            }\n-        }\n-\n-        // check for known field strategies\n-        if (!field.isSerialized() && (field.getType() == byte[].class\n-            || field.getType() == Byte[].class)) {\n-            if (_dict.maxEmbeddedBlobSize != -1)\n-                return new MaxEmbeddedByteArrayFieldStrategy();\n-        } else if (!field.isSerialized()\n-            && (field.getType() == char[].class\n-            || field.getType() == Character[].class)) {\n-            if (_dict.maxEmbeddedClobSize != -1 && isClob(field, false))\n-                return new MaxEmbeddedCharArrayFieldStrategy();\n-        } else if (!field.isSerialized()) {\n-            FieldStrategy strat = defaultTypeStrategy(field, installHandlers,\n-                adapting);\n-            if (strat != null)\n-                return strat;\n-        }\n-\n-        // check for default handler\n-        handler = defaultHandler(field, adapting);\n-        if (handler != null) {\n-            if (installHandlers)\n-                field.setHandler(handler);\n-            return new HandlerFieldStrategy();\n-        }\n-\n-        // default to blob\n-        if (installHandlers) {\n-            if (getLog().isWarnEnabled())\n-                getLog().warn(_loc.get(\"no-field-strategy\", field));\n-            field.setSerialized(true);\n-        }\n-        if (_dict.maxEmbeddedBlobSize == -1) {\n-            if (installHandlers)\n-                field.setHandler(BlobValueHandler.getInstance());\n-            return new HandlerFieldStrategy();\n-        }\n-        return new MaxEmbeddedBlobFieldStrategy();\n-    }\n-\n-    /**\n-     * Return the built-in strategy for the field's type, or null if none.\n-     */\n-    protected FieldStrategy defaultTypeStrategy(FieldMapping field,\n-        boolean installHandlers, boolean adapting) {\n-        switch (field.getTypeCode()) {\n-            case JavaTypes.BOOLEAN:\n-            case JavaTypes.BYTE:\n-            case JavaTypes.CHAR:\n-            case JavaTypes.DOUBLE:\n-            case JavaTypes.FLOAT:\n-            case JavaTypes.INT:\n-            case JavaTypes.LONG:\n-            case JavaTypes.SHORT:\n-                return new PrimitiveFieldStrategy();\n-            case JavaTypes.STRING:\n-                if (!isClob(field, false))\n-                    return new StringFieldStrategy();\n-                if (_dict.maxEmbeddedClobSize != -1)\n-                    return new MaxEmbeddedClobFieldStrategy();\n-                break;\n-            case JavaTypes.PC:\n-                if (field.isEmbeddedPC())\n-                    return new EmbedFieldStrategy();\n-                if (field.getTypeMapping().isMapped()\n-                    || !useUntypedPCHandler(field))\n-                    return new RelationFieldStrategy();\n-                break;\n-            case JavaTypes.ARRAY:\n-            case JavaTypes.COLLECTION:\n-                ValueMapping elem = field.getElementMapping();\n-                ValueHandler ehandler = namedHandler(elem);\n-                if (ehandler == null)\n-                    ehandler = defaultHandler(elem);\n-                if (ehandler != null)\n-                    return handlerCollectionStrategy(field, ehandler, \n-                        installHandlers);\n-                if (elem.getTypeCode() == JavaTypes.PC\n-                    && !elem.isSerialized() && !elem.isEmbeddedPC()) {\n-                    if (useInverseKeyMapping(field))\n-                        return new RelationCollectionInverseKeyFieldStrategy();\n-                    return new RelationCollectionTableFieldStrategy();\n-                }\n-                break;\n-            case JavaTypes.MAP:\n-                ValueMapping key = field.getKeyMapping();\n-                ValueHandler khandler = namedHandler(key);\n-                if (khandler == null)\n-                    khandler = defaultHandler(key);\n-                ValueMapping val = field.getElementMapping();\n-                ValueHandler vhandler = namedHandler(val);\n-                if (vhandler == null)\n-                    vhandler = defaultHandler(val);\n-                boolean krel = khandler == null \n-                    && key.getTypeCode() == JavaTypes.PC\n-                    && !key.isSerialized() && !key.isEmbeddedPC();\n-                boolean vrel = vhandler == null \n-                    && val.getTypeCode() == JavaTypes.PC\n-                    && !val.isSerialized() && !val.isEmbeddedPC();\n-                if (!krel && vrel && key.getValueMappedBy() != null) {\n-                    if (useInverseKeyMapping(field))\n-                        return new RelationMapInverseKeyFieldStrategy();\n-                    return new RelationMapTableFieldStrategy();\n-                }\n-                if (!krel && khandler == null)\n-                    break;\n-                if (!vrel && vhandler == null)\n-                    break;\n-                return handlerMapStrategy(field, khandler, vhandler, krel,\n-                    vrel, installHandlers);\n-            case JavaTypes.INPUT_STREAM:\n-            case JavaTypes.INPUT_READER:\n-                return new LobFieldStrategy();\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Return the collection strategy for the given element handler, or null\n-     * if none.\n-     */\n-    protected FieldStrategy handlerCollectionStrategy(FieldMapping field, \n-        ValueHandler ehandler, boolean installHandlers) {\n-        if (getConfiguration().getCompatibilityInstance()\n-            .getStoreMapCollectionInEntityAsBlob())\n-            return null;\n-        if (installHandlers)\n-            field.getElementMapping().setHandler(ehandler);\n-        return new HandlerCollectionTableFieldStrategy();\n-    }\n-\n-    /**\n-     * Return the map strategy for the given key and value handlers / relations,\n-     * or null if none.\n-     */\n-    protected FieldStrategy handlerMapStrategy(FieldMapping field, \n-        ValueHandler khandler, ValueHandler vhandler, boolean krel, \n-        boolean vrel,  boolean installHandlers) {\n-        if (getConfiguration().getCompatibilityInstance()\n-            .getStoreMapCollectionInEntityAsBlob())\n-            return null;\n-        if (installHandlers) {\n-            field.getKeyMapping().setHandler(khandler);\n-            field.getElementMapping().setHandler(vhandler);\n-        }\n-        if (!krel && !vrel)\n-            return new HandlerHandlerMapTableFieldStrategy();\n-        if (!krel && vrel)\n-            return new HandlerRelationMapTableFieldStrategy();\n-        if (krel && !vrel)\n-            return new RelationHandlerMapTableFieldStrategy();\n-        return new RelationRelationMapTableFieldStrategy();\n-    }\n-\n-    /**\n-     * Use hints in mapping data to figure out whether the given relation\n-     * field should use an inverse foreign key or an association table mapping.\n-     */\n-    private boolean useInverseKeyMapping(FieldMapping field) {\n-        FieldMapping mapped = field.getMappedByMapping();\n-        if (mapped != null) {\n-            if (mapped.getTypeCode() == JavaTypes.PC)\n-                return true;\n-            if (mapped.getElement().getTypeCode() == JavaTypes.PC)\n-                return false;\n-            throw new MetaDataException(_loc.get(\"bad-mapped-by\", field,\n-                mapped));\n-        }\n-\n-        // without a mapped-by, we have to look for clues as to the mapping.\n-        // we assume that anything with element foreign key columns but no join\n-        // columns or table uses an inverse foreign key, and anything else uses\n-        // an association table\n-        FieldMappingInfo info = field.getMappingInfo();\n-        ValueMapping elem = field.getElementMapping();\n-        return info.getTableName() == null && info.getColumns().isEmpty()\n-            && !elem.getValueInfo().getColumns().isEmpty();\n-    }\n-\n-    /**\n-     * Check the given value against mapped strategies.\n-     */\n-    private Object mappedStrategy(ValueMapping val, Class type,\n-        boolean adapting) {\n-        if (type == null || type == Object.class)\n-            return null;\n-\n-        Object strat = _defaults.getStrategy(val, type, adapting);\n-\n-        // recurse on superclass so that, for example, a registered handler\n-        // for java.lang.Enum will work on all enums\n-        if (strat == null)\n-            return mappedStrategy(val, type.getSuperclass(), adapting);\n-        if (!(strat instanceof String))\n-            return strat;\n-\n-        String name = (String) strat;\n-        if (NoneFieldStrategy.ALIAS.equals(name))\n-            return NoneFieldStrategy.getInstance();\n-\n-        String props = Configurations.getProperties(name);\n-        name = Configurations.getClassName(name);\n-        try {\n-            Class c = JavaTypes.classForName(name, val,\n-                (ClassLoader) AccessController.doPrivileged(\n-                    J2DoPrivHelper.getClassLoaderAction(FieldStrategy.class)));\n-            Object o = AccessController.doPrivileged(\n-                J2DoPrivHelper.newInstanceAction(c));\n-            Configurations.configureInstance(o, getConfiguration(), props);\n-            return o;\n-        } catch (Exception e) {\n-            if (e instanceof PrivilegedActionException)\n-                e = ((PrivilegedActionException) e).getException();\n-            throw new MetaDataException(_loc.get(\"bad-mapped-strategy\",\n-                val, name), e);\n-        }\n-    }\n-\n-    /**\n-     * Instantiate the given value's named handler, or return null if no\n-     * named handler.\n-     */\n-    protected ValueHandler namedHandler(ValueMapping val) {\n-        String name = val.getValueInfo().getStrategy();\n-        if (name == null)\n-            return null;\n-\n-        String props = Configurations.getProperties(name);\n-        name = Configurations.getClassName(name);\n-        try {\n-            Class c = JavaTypes.classForName(name, val,\n-                (ClassLoader) AccessController.doPrivileged(\n-                    J2DoPrivHelper.getClassLoaderAction(ValueHandler.class)));\n-            if (ValueHandler.class.isAssignableFrom(c)) {\n-                ValueHandler vh = (ValueHandler) AccessController.doPrivileged(\n-                    J2DoPrivHelper.newInstanceAction(c));\n-                Configurations.configureInstance(vh, getConfiguration(),\n-                    props);\n-                return vh;\n-            }\n-            return null; // named field strategy\n-        } catch (Exception e) {\n-            if (e instanceof PrivilegedActionException)\n-                e = ((PrivilegedActionException) e).getException();\n-            throw new MetaDataException(_loc.get(\"bad-value-handler\",\n-                val, name), e);\n-        }\n-    }\n-\n-    /**\n-     * Determine the default handler to use for the given value. Does\n-     * not take into account the named handler, if any.\n-     */\n-    protected ValueHandler defaultHandler(ValueMapping val) {\n-        return defaultHandler(val, getStrategyInstaller().isAdapting());\n-    }\n-\n-    /**\n-     * Determine the default handler to use for the given value. Does\n-     * not take into account the named handler, if any.\n-     */\n-    protected ValueHandler defaultHandler(ValueMapping val, boolean adapting) {\n-        if (val.isSerialized()) {\n-            if (_dict.maxEmbeddedBlobSize != -1)\n-                warnMaxEmbedded(val, _dict.maxEmbeddedBlobSize);\n-            return BlobValueHandler.getInstance();\n-        }\n-\n-        Object handler = mappedStrategy(val, val.getType(), adapting);\n-        if (handler instanceof ValueHandler)\n-            return (ValueHandler) handler;\n-\n-        if (val.getType() == byte[].class \n-            || val.getType() == Byte[].class) {\n-            if (_dict.maxEmbeddedBlobSize != -1)\n-                warnMaxEmbedded(val, _dict.maxEmbeddedBlobSize);\n-            return ByteArrayValueHandler.getInstance();\n-        }\n-        if (val.getType() == char[].class\n-            || val.getType() == Character[].class) {\n-            if (isClob(val, true))\n-                return CharArrayStreamValueHandler.getInstance();\n-            return CharArrayValueHandler.getInstance();\n-        }\n-\n-        switch (val.getTypeCode()) {\n-            case JavaTypes.BOOLEAN:\n-            case JavaTypes.BYTE:\n-            case JavaTypes.CHAR:\n-            case JavaTypes.DOUBLE:\n-            case JavaTypes.FLOAT:\n-            case JavaTypes.INT:\n-            case JavaTypes.LONG:\n-            case JavaTypes.SHORT:\n-            case JavaTypes.BOOLEAN_OBJ:\n-            case JavaTypes.BYTE_OBJ:\n-            case JavaTypes.CHAR_OBJ:\n-            case JavaTypes.DOUBLE_OBJ:\n-            case JavaTypes.FLOAT_OBJ:\n-            case JavaTypes.INT_OBJ:\n-            case JavaTypes.LONG_OBJ:\n-            case JavaTypes.SHORT_OBJ:\n-            case JavaTypes.BIGINTEGER:\n-            case JavaTypes.BIGDECIMAL:\n-            case JavaTypes.NUMBER:\n-            case JavaTypes.DATE:\n-            case JavaTypes.CALENDAR:\n-            case JavaTypes.LOCALE:\n-                return ImmutableValueHandler.getInstance();\n-            case JavaTypes.STRING:\n-                if (isClob(val, true))\n-                    return ClobValueHandler.getInstance();\n-                return ImmutableValueHandler.getInstance();\n-            case JavaTypes.PC:\n-                if (!val.getTypeMapping().isMapped()\n-                    && useUntypedPCHandler(val)) \n-                    return UntypedPCValueHandler.getInstance();\n-                break;\n-            case JavaTypes.PC_UNTYPED:\n-                return UntypedPCValueHandler.getInstance();\n-            case JavaTypes.OID:\n-                return new ObjectIdValueHandler();\n-        }\n-        if (!getConfiguration().getCompatibilityInstance()\n-            .getStoreMapCollectionInEntityAsBlob()\n-            && val.isEmbeddedPC())\n-            return new ElementEmbedValueHandler();\n-        return null;\n-    }\n-\n-    /**\n-     * Return true if we should use the generic untyped PC handler for the\n-     * given unmapped relation.\n-     */\n-    private boolean useUntypedPCHandler(ValueMapping val) {\n-        ClassMapping rel = val.getTypeMapping();\n-        return rel.getIdentityType() == ClassMapping.ID_UNKNOWN\n-            || (rel.getIdentityType() == ClassMapping.ID_APPLICATION\n-            && (rel.getPrimaryKeyFields().length == 0\n-            || (!rel.isOpenJPAIdentity() && Modifier.isAbstract\n-            (rel.getObjectIdType().getModifiers()))));\n-    }\n-\n-    /**\n-     * Checks for hints as to whether the given column is a CLOB.\n-     */\n-    private boolean isClob(ValueMapping val, boolean warn) {\n-        List cols = val.getValueInfo().getColumns();\n-        if (cols.size() != 1)\n-            return false;\n-\n-        Column col = (Column) cols.get(0);\n-        if (col.getSize() != -1 && col.getType() != Types.CLOB)\n-            return false;\n-\n-        if (_dict.getPreferredType(Types.CLOB) != Types.CLOB)\n-            return false;\n-\n-        if (warn && _dict.maxEmbeddedClobSize != -1)\n-            warnMaxEmbedded(val, _dict.maxEmbeddedClobSize);\n-        return true;\n-    }\n-\n-    /**\n-     * Warn that the given value is being mapped to a handler that will not\n-     * be able to store large lobs.\n-     */\n-    private void warnMaxEmbedded(ValueMapping val, int size) {\n-        if (getLog().isWarnEnabled())\n-            getLog().warn(_loc.get(\"max-embed-lob\", val,\n-                String.valueOf(size)));\n-    }\n-\n-    /**\n-     * Determine the default strategy to use for the given discriminator.\n-     * Does not take into account the current strategy, if any.\n-     */\n-    protected DiscriminatorStrategy defaultStrategy(Discriminator discrim) {\n-        return defaultStrategy(discrim, getStrategyInstaller().isAdapting());\n-    }\n-\n-    /**\n-     * Determine the default strategy to use for the given discriminator.\n-     * Does not take into account the current strategy, if any.\n-     */\n-    protected DiscriminatorStrategy defaultStrategy(Discriminator discrim,\n-        boolean adapting) {\n-        ClassMapping cls = discrim.getClassMapping();\n-        if (cls.getEmbeddingMetaData() != null)\n-            return NoneDiscriminatorStrategy.getInstance();\n-        if (cls.getJoinablePCSuperclassMapping() == null\n-            && (cls.getStrategy() == NoneClassStrategy.getInstance()\n-            || Modifier.isFinal(discrim.getClassMapping().getDescribedType().\n-            getModifiers())))\n-            return NoneDiscriminatorStrategy.getInstance();\n-\n-        Object strat = _defaults.getStrategy(discrim, adapting);\n-        if (strat instanceof String)\n-            return instantiateDiscriminatorStrategy((String) strat, discrim);\n-        if (strat != null)\n-            return (DiscriminatorStrategy) strat;\n-\n-        if (cls.getJoinablePCSuperclassMapping() != null)\n-            return new SuperclassDiscriminatorStrategy();\n-        if (discrim.getMappingInfo().getValue() != null)\n-            return new ValueMapDiscriminatorStrategy();\n-        if (cls.getMappedPCSuperclassMapping() != null)\n-            return NoneDiscriminatorStrategy.getInstance();\n-        if (adapting || _defaults.defaultMissingInfo())\n-            return new ClassNameDiscriminatorStrategy();\n-        DBDictionary dict = ((JDBCConfiguration) getConfiguration()).\n-            getDBDictionaryInstance();\n-        if (dict.joinSyntax == JoinSyntaxes.SYNTAX_TRADITIONAL)\n-            return NoneDiscriminatorStrategy.getInstance();\n-        return new SubclassJoinDiscriminatorStrategy();\n-    }\n-\n-    /**\n-     * Determine the default strategy to use for the given version.\n-     * Does not take into account the current strategy, if any.\n-     */\n-    protected VersionStrategy defaultStrategy(Version version) {\n-        return defaultStrategy(version, getStrategyInstaller().isAdapting());\n-    }\n-\n-    /**\n-     * Determine the default strategy to use for the given version.\n-     * Does not take into account the current strategy, if any.\n-     */\n-    protected VersionStrategy defaultStrategy(Version version,\n-        boolean adapting) {\n-        ClassMapping cls = version.getClassMapping();\n-        if (cls.getEmbeddingMetaData() != null)\n-            return NoneVersionStrategy.getInstance();\n-        if (cls.getJoinablePCSuperclassMapping() == null\n-            && cls.getStrategy() == NoneClassStrategy.getInstance())\n-            return NoneVersionStrategy.getInstance();\n-\n-        Object strat = _defaults.getStrategy(version, adapting);\n-        if (strat instanceof String)\n-            return instantiateVersionStrategy((String) strat, version);\n-        if (strat != null)\n-            return (VersionStrategy) strat;\n-\n-        if (cls.getJoinablePCSuperclassMapping() != null)\n-            return new SuperclassVersionStrategy();\n-\n-        FieldMapping vfield = version.getClassMapping().\n-            getVersionFieldMapping();\n-        if (vfield != null)\n-            return defaultStrategy(version, vfield);\n-        if (adapting || _defaults.defaultMissingInfo())\n-            return new NumberVersionStrategy();\n-        return NoneVersionStrategy.getInstance();\n-    }\n-\n-    /**\n-     * Return the default version strategy, given a version field.\n-     */\n-    protected VersionStrategy defaultStrategy(Version vers,\n-        FieldMapping vfield) {\n-        switch (vfield.getTypeCode()) {\n-            case JavaTypes.DATE:\n-            case JavaTypes.CALENDAR:\n-                return (JavaVersions.VERSION >= 5) \n-                    ? new NanoPrecisionTimestampVersionStrategy()\n-                    : new TimestampVersionStrategy();\n-            case JavaTypes.BYTE:\n-            case JavaTypes.INT:\n-            case JavaTypes.LONG:\n-            case JavaTypes.SHORT:\n-            case JavaTypes.BYTE_OBJ:\n-            case JavaTypes.INT_OBJ:\n-            case JavaTypes.LONG_OBJ:\n-            case JavaTypes.SHORT_OBJ:\n-            case JavaTypes.NUMBER:\n-                return new NumberVersionStrategy();\n-            default:\n-                return NoneVersionStrategy.getInstance();\n-        }\n-    }\n-    \n-    public void endConfiguration()\n-    {\n-        super.endConfiguration();\n-\n-        JDBCConfiguration conf = (JDBCConfiguration) getConfiguration();\n-        _dict = conf.getDBDictionaryInstance();\n-        if (_defaults == null)\n-            _defaults = conf.getMappingDefaultsInstance();\n-        if (_schema != null && _schema instanceof Configurable) {\n-            ((Configurable) _schema).setConfiguration(conf);\n-            ((Configurable) _schema).startConfiguration();\n-            ((Configurable) _schema).endConfiguration();\n-        }            \n-    }\n-    \n-    /**\n-     * Finds the base class mapping for the specified mapping.  Loads all\n-     * persistent types if necessary, since all persistent subclasses of this\n-     * mapping may not have been resolved before this method is called.\n-     */\n-    protected ClassMapping findBaseClassMapping(ClassMapping mapping) {        \n-        ClassMapping baseMapping = null;\n-        ClassMapping sup = mapping.getPCSuperclassMapping();\n-        if (sup == null) {\n-            // no superclass metadata was provided.  check to see if this class\n-            // has any persistent subclasses.\n-            if (mapping.getPCSubclasses().length > 0)\n-                baseMapping = mapping;\n-            else {\n-                // persistent subclasses may not have been resolved yet.  \n-                // run through the persistent types to see if any of them \n-                // or their superclass is a subclass of this class.\n-                Collection classes = loadPersistentTypes(false, \n-                        mapping.getEnvClassLoader());\n-                Class cls;\n-                for (Iterator itr = classes.iterator(); itr.hasNext();) {\n-                    cls = (Class) itr.next();\n-                    Class supcl = cls.getSuperclass();\n-                    while (supcl != null && \n-                           !supcl.getClass().equals(java.lang.Object.class)) {\n-                        if (!supcl.isInterface() &&\n-                            supcl.equals(mapping.getDescribedType())) {\n-                            baseMapping = mapping;    \n-                            break;\n-                        }\n-                        supcl = supcl.getSuperclass();\n-                    }\n-                    if (baseMapping != null) break;\n-                }\n-            }\n-        } else if (!sup.getDescribedType().isInterface()) {\n-            // if the superclass is not a managed interface, find the root\n-            // superclass and get its mapping info\n-            ClassMapping supcm = sup;\n-            while (supcm != null && \n-                    !supcm.getDescribedType().isInterface() &&\n-                    !supcm.isEmbeddedOnly()) {\n-                ClassMapping supcm2 = supcm.getPCSuperclassMapping();\n-                if (supcm2 == null)\n-                    baseMapping = supcm;\n-                supcm = supcm2;\n-            }\n-        }\n-        return baseMapping;\n-    }\n-   \n-    /**\n-     * If an inheritance strategy has not been set on this mapping, set it\n-     * to the default (flat).  This method should be called before strategies\n-     * are created for the specified mapping.\n-     */\n-    protected void setDefaultInheritanceStrategy(ClassMapping mapping) {\n-        ClassMappingInfo info = mapping.getMappingInfo();\n-        if (info != null && info.getHierarchyStrategy() == null)\n-            info.setHierarchyStrategy(FlatClassStrategy.ALIAS);        \n-    } \n-    \n-    /**\n-     * Determines whether an inhertance strategy has been set on the\n-     * specified mapping.\n-     */\n-    protected boolean hasInheritanceStrategy(ClassMapping mapping) {\n-        ClassMappingInfo info = mapping.getMappingInfo();\n-        if (info != null && info.getHierarchyStrategy() != null)\n-            return true;\n-        return false;        \n-    }\n-}"},{"sha":"d790cf7d8db15f5c2f93e2cb8fa0d7f3e48ec6d6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingStrategyInstaller.java","status":"removed","additions":0,"deletions":71,"changes":71,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingStrategyInstaller.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingStrategyInstaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingStrategyInstaller.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,71 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-/**\n- * Installer used during mapping that attempts to use the given mapping\n- * information (if any), and fails if it does not work.\n- *\n- * @author Abe White\n- * @nojavadoc\n- * @since 0.4.0\n- */\n-public class MappingStrategyInstaller\n-    extends StrategyInstaller {\n-\n-    /**\n-     * Constructor; supply configuration.\n-     */\n-    public MappingStrategyInstaller(MappingRepository repos) {\n-        super(repos);\n-    }\n-\n-    public boolean isAdapting() {\n-        return true;\n-    }\n-\n-    public void installStrategy(ClassMapping cls) {\n-        ClassStrategy strat = repos.namedStrategy(cls);\n-        if (strat == null)\n-            strat = repos.defaultStrategy(cls, true);\n-        cls.setStrategy(strat, Boolean.TRUE);\n-        cls.setSourceMode(cls.MODE_MAPPING, true);\n-    }\n-\n-    public void installStrategy(FieldMapping field) {\n-        FieldStrategy strategy = repos.namedStrategy(field, true);\n-        if (strategy == null)\n-            strategy = repos.defaultStrategy(field, true, true);\n-        field.setStrategy(strategy, Boolean.TRUE);\n-    }\n-\n-    public void installStrategy(Version version) {\n-        VersionStrategy strat = repos.namedStrategy(version);\n-        if (strat == null)\n-            strat = repos.defaultStrategy(version, true);\n-        version.setStrategy(strat, Boolean.TRUE);\n-    }\n-\n-    public void installStrategy(Discriminator discrim) {\n-        DiscriminatorStrategy strat = repos.namedStrategy(discrim);\n-        if (strat == null)\n-            strat = repos.defaultStrategy(discrim, true);\n-        discrim.setStrategy(strat, Boolean.TRUE);\n-    }\n-}"},{"sha":"d9ac176dc72903732003876e55b7b1bd33ee7cbc","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingTool.java","status":"removed","additions":0,"deletions":1143,"changes":1143,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingTool.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingTool.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,1143 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.Writer;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.sql.SQLException;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\n-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n-import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n-import org.apache.openjpa.jdbc.kernel.JDBCSeq;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.DynamicSchemaFactory;\n-import org.apache.openjpa.jdbc.schema.LazySchemaFactory;\n-import org.apache.openjpa.jdbc.schema.Schema;\n-import org.apache.openjpa.jdbc.schema.SchemaGenerator;\n-import org.apache.openjpa.jdbc.schema.SchemaGroup;\n-import org.apache.openjpa.jdbc.schema.SchemaSerializer;\n-import org.apache.openjpa.jdbc.schema.SchemaTool;\n-import org.apache.openjpa.jdbc.schema.Table;\n-import org.apache.openjpa.jdbc.schema.XMLSchemaSerializer;\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\n-import org.apache.openjpa.kernel.Seq;\n-import org.apache.openjpa.lib.conf.Configurations;\n-import org.apache.openjpa.lib.log.Log;\n-import org.apache.openjpa.lib.meta.ClassArgParser;\n-import org.apache.openjpa.lib.util.Files;\n-import org.apache.openjpa.lib.util.J2DoPrivHelper;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.util.Options;\n-import org.apache.openjpa.lib.util.Services;\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.meta.FieldMetaData;\n-import org.apache.openjpa.meta.JavaTypes;\n-import org.apache.openjpa.meta.MetaDataFactory;\n-import org.apache.openjpa.meta.MetaDataModes;\n-import org.apache.openjpa.meta.QueryMetaData;\n-import org.apache.openjpa.meta.SequenceMetaData;\n-import org.apache.openjpa.meta.ValueStrategies;\n-import org.apache.openjpa.util.GeneralException;\n-import org.apache.openjpa.util.InternalException;\n-import org.apache.openjpa.util.MetaDataException;\n-\n-/**\n- * Tool for manipulating class mappings and associated schema.\n- *\n- * @author Abe White\n- */\n-public class MappingTool\n-    implements MetaDataModes {\n-\n-    public static final String SCHEMA_ACTION_NONE = \"none\";\n-\n-    public static final String ACTION_ADD = \"add\";\n-    public static final String ACTION_REFRESH = \"refresh\";\n-    public static final String ACTION_BUILD_SCHEMA = \"buildSchema\";\n-    public static final String ACTION_DROP = \"drop\";\n-    public static final String ACTION_VALIDATE = \"validate\";\n-    public static final String ACTION_EXPORT = \"export\";\n-    public static final String ACTION_IMPORT = \"import\";\n-\n-    public static final String[] ACTIONS = new String[]{\n-        ACTION_ADD,\n-        ACTION_REFRESH,\n-        ACTION_BUILD_SCHEMA,\n-        ACTION_DROP,\n-        ACTION_VALIDATE,\n-        ACTION_EXPORT,\n-        ACTION_IMPORT,\n-    };\n-\n-    private static final Localizer _loc =\n-        Localizer.forPackage(MappingTool.class);\n-\n-    private final JDBCConfiguration _conf;\n-    private final Log _log;\n-    private final String _action;\n-    private final boolean _meta;\n-    private final int _mode;\n-    private final DBDictionary _dict;\n-\n-    private MappingRepository _repos = null;\n-    private SchemaGroup _schema = null;\n-    private SchemaTool _schemaTool = null;\n-    private String _schemaActions = SchemaTool.ACTION_ADD;\n-    private boolean _readSchema = false;\n-    private boolean _pks = false;\n-    private boolean _fks = false;\n-    private boolean _indexes = false;\n-    private boolean _seqs = true;\n-    private boolean _dropUnused = true;\n-    private boolean _ignoreErrors = false;\n-    private File _file = null;\n-    private Writer _mappingWriter = null;\n-    private Writer _schemaWriter = null;\n-\n-    // buffer metadatas to be dropped\n-    private Set _dropCls = null;\n-    private Set _dropMap = null;\n-    private boolean _flush = false;\n-    private boolean _flushSchema = false;\n-\n-    /**\n-     * Constructor. Supply configuration and action.\n-     */\n-    public MappingTool(JDBCConfiguration conf, String action, boolean meta) {\n-        _conf = conf;\n-        _log = conf.getLog(JDBCConfiguration.LOG_METADATA);\n-        _meta = meta;\n-\n-        if (action == null)\n-            _action = ACTION_REFRESH;\n-        else if (!Arrays.asList(ACTIONS).contains(action))\n-            throw new IllegalArgumentException(\"action == \" + action);\n-        else\n-            _action = action;\n-\n-        if (meta && ACTION_ADD.equals(_action))\n-            _mode = MODE_META;\n-        else if (meta && ACTION_DROP.equals(_action))\n-            _mode = MODE_META | MODE_MAPPING | MODE_QUERY;\n-        else\n-            _mode = MODE_MAPPING;\n-\n-        _dict = _conf.getDBDictionaryInstance();\n-    }\n-\n-    /**\n-     * The action supplied on construction.\n-     */\n-    public String getAction() {\n-        return _action;\n-    }\n-\n-    /**\n-     * Whether the action works on metadata as well as mappings.\n-     */\n-    public boolean isMetaDataAction() {\n-        return _meta;\n-    }\n-\n-    /**\n-     * The schema modification policy, or <code>none</code>. See the\n-     * ACTION constants in {@link SchemaTool}. May be a comma-separated\n-     * list of values. Defaults to {@link SchemaTool#ACTION_ADD}.\n-     */\n-    public String getSchemaAction() {\n-        return _schemaActions;\n-    }\n-\n-    /**\n-     * The schema modification policy, or <code>none</code>. See the\n-     * ACTION constants in {@link SchemaTool}. May be a comma-separated\n-     * list of values. Defaults to {@link SchemaTool#ACTION_ADD}.\n-     */\n-    public void setSchemaAction(String schemaAction) {\n-        _schemaActions = schemaAction;\n-    }\n-\n-    /**\n-     * Set to true to read the entire schema before mapping.\n-     * Leaving this option false saves time, but is dangerous when adding\n-     * new mappings, because without full knowledge of the existing schema the\n-     * mapping tool might create tables or indexes that conflict with\n-     * existing components.\n-     */\n-    public boolean getReadSchema() {\n-        return _readSchema;\n-    }\n-\n-    /**\n-     * Set to true to read the entire schema before mapping.\n-     * Leaving this option false saves time, but is dangerous when adding\n-     * new mappings, because without full knowledge of the existing schema the\n-     * mapping tool might create tables or indexes that conflict with\n-     * existing components.\n-     */\n-    public void setReadSchema(boolean readSchema) {\n-        _readSchema = readSchema;\n-    }\n-\n-    /**\n-     * Whether to manipulate sequences. Defaults to true.\n-     */\n-    public boolean getSequences() {\n-        return _seqs;\n-    }\n-\n-    /**\n-     * Whether to manipulate sequences. Defaults to true.\n-     */\n-    public void setSequences(boolean seqs) {\n-        _seqs = seqs;\n-    }\n-\n-    /**\n-     * Whether indexes on existing tables should be manipulated.\n-     * Defaults to false.\n-     */\n-    public boolean getIndexes() {\n-        return _indexes;\n-    }\n-\n-    /**\n-     * Whether indexes on existing tables should be manipulated.\n-     * Defaults to false.\n-     */\n-    public void setIndexes(boolean indexes) {\n-        _indexes = indexes;\n-    }\n-\n-    /**\n-     * Whether foreign keys on existing tables should be manipulated.\n-     * Defaults to false.\n-     */\n-    public boolean getForeignKeys() {\n-        return _fks;\n-    }\n-\n-    /**\n-     * Whether foreign keys on existing tables should be manipulated.\n-     * Defaults to false.\n-     */\n-    public void setForeignKeys(boolean fks) {\n-        _fks = fks;\n-    }\n-\n-    /**\n-     * Whether primary keys on existing tables should be manipulated.\n-     * Defaults to false.\n-     */\n-    public boolean getPrimaryKeys() {\n-        return _pks;\n-    }\n-\n-    /**\n-     * Whether primary keys on existing tables should be manipulated.\n-     * Defaults to false.\n-     */\n-    public void setPrimaryKeys(boolean pks) {\n-        _pks = pks;\n-    }\n-\n-    /**\n-     * Whether schema components that are unused by any mapping will be\n-     * dropped from this tool's {@link SchemaGroup}, and, depending on\n-     * the schema action, from the database. Defaults to true.\n-     */\n-    public boolean getDropUnusedComponents() {\n-        return _dropUnused;\n-    }\n-\n-    /**\n-     * Whether schema components that are unused by any mapping will be\n-     * dropped from this tool's {@link SchemaGroup}, and, depending on\n-     * the schema action, from the database. Defaults to true.\n-     */\n-    public void setDropUnusedComponents(boolean dropUnused) {\n-        _dropUnused = dropUnused;\n-    }\n-\n-    /**\n-     * Whether and SQL errors should cause a failure or just issue a warning.\n-     */\n-    public void setIgnoreErrors(boolean ignoreErrors) {\n-        _ignoreErrors = ignoreErrors;\n-    }\n-\n-    /**\n-     * Whether and SQL errors should cause a failure or just issue a warning.\n-     */\n-    public boolean getIgnoreErrors() {\n-        return _ignoreErrors;\n-    }\n-\n-    /**\n-     * Return the schema tool to use for schema modification.\n-     */\n-    private SchemaTool newSchemaTool(String action) {\n-        if (SCHEMA_ACTION_NONE.equals(action))\n-            action = null;\n-        SchemaTool tool = new SchemaTool(_conf, action);\n-        tool.setIgnoreErrors(getIgnoreErrors());\n-        tool.setPrimaryKeys(getPrimaryKeys());\n-        tool.setForeignKeys(getForeignKeys());\n-        tool.setIndexes(getIndexes());\n-        tool.setSequences(getSequences());\n-        return tool;\n-    }\n-\n-    /**\n-     * Set the schema tool to use for schema modification.\n-     */\n-    public void setSchemaTool(SchemaTool tool) {\n-        _schemaTool = tool;\n-    }\n-\n-    /**\n-     * The stream to export the planned schema to as an XML document.\n-     * If non-null, then the database schema will not be altered.\n-     */\n-    public Writer getSchemaWriter() {\n-        return _schemaWriter;\n-    }\n-\n-    /**\n-     * The stream to export the planned schema to as an XML document.\n-     * If non-null, then the database schema will not be altered.\n-     */\n-    public void setSchemaWriter(Writer schemaWriter) {\n-        _schemaWriter = schemaWriter;\n-    }\n-\n-    /**\n-     * The stream to export the planned mappings to as an XML document.\n-     * If non-null, then the mapping repository will not be altered.\n-     */\n-    public Writer getMappingWriter() {\n-        return _mappingWriter;\n-    }\n-\n-    /**\n-     * The stream to export the planned mappings to as an XML document.\n-     * If non-null, then the mapping repository will not be altered.\n-     */\n-    public void setMappingWriter(Writer mappingWriter) {\n-        _mappingWriter = mappingWriter;\n-    }\n-\n-    /**\n-     * If adding metadata, the metadata file to add to.\n-     */\n-    public File getMetaDataFile() {\n-        return _file;\n-    }\n-\n-    /**\n-     * If adding metadata, the metadata file to add to.\n-     */\n-    public void setMetaDataFile(File file) {\n-        _file = file;\n-    }\n-\n-    /**\n-     * Return the repository to use to access mapping information.\n-     * Defaults to a new {@link MappingRepository}.\n-     */\n-    public MappingRepository getRepository() {\n-        if (_repos == null) {\n-            _repos = _conf.newMappingRepositoryInstance();\n-            _repos.setSchemaGroup(getSchemaGroup());\n-            _repos.setValidate(_repos.VALIDATE_UNENHANCED, false);\n-        }\n-        return _repos;\n-    }\n-\n-    /**\n-     * Set the repository to use to access mapping information.\n-     */\n-    public void setRepository(MappingRepository repos) {\n-        _repos = repos;\n-    }\n-\n-    /**\n-     * Return the schema group to use in mapping. If none has been set, the\n-     * schema will be generated from the database.\n-     */\n-    public SchemaGroup getSchemaGroup() {\n-        if (_schema == null) {\n-            if (_action.indexOf(ACTION_BUILD_SCHEMA) != -1) {\n-                DynamicSchemaFactory factory = new DynamicSchemaFactory();\n-                factory.setConfiguration(_conf);\n-                _schema = factory;\n-            } else if (_readSchema \n-                || contains(_schemaActions,SchemaTool.ACTION_RETAIN)\n-                || contains(_schemaActions,SchemaTool.ACTION_REFRESH)) {\n-                _schema = (SchemaGroup) newSchemaTool(null).getDBSchemaGroup().\n-                    clone();\n-            } else {\n-                // with this we'll just read tables as different mappings\n-                // look for them\n-                LazySchemaFactory factory = new LazySchemaFactory();\n-                factory.setConfiguration(_conf);\n-                factory.setPrimaryKeys(getPrimaryKeys());\n-                factory.setForeignKeys(getForeignKeys());\n-                factory.setIndexes(getIndexes());\n-                _schema = factory;\n-            }\n-\n-            if (_schema.getSchemas().length == 0)\n-                _schema.addSchema();\n-        }\n-        return _schema;\n-    }\n-\n-    /**\n-     * Set the schema to use in mapping.\n-     */\n-    public void setSchemaGroup(SchemaGroup schema) {\n-        _schema = schema;\n-    }\n-\n-    /**\n-     * Reset the internal repository. This is called automatically after\n-     * every {@link #record}.\n-     */\n-    public void clear() {\n-        _repos = null;\n-        _schema = null;\n-        _schemaTool = null;\n-        _flush = false;\n-        _flushSchema = false;\n-        if (_dropCls != null)\n-            _dropCls.clear();\n-        if (_dropMap != null)\n-            _dropMap.clear();\n-    }\n-\n-    /**\n-     * Records the changes that have been made to both the mappings and the\n-     * associated schema, and clears the tool for further use. This also\n-     * involves clearing the internal mapping repository.\n-     */\n-    public void record() {\n-        record(null);\n-    }\n-    \n-    private void record(MappingTool.Flags flags) {\n-        MappingRepository repos = getRepository();\n-        MetaDataFactory io = repos.getMetaDataFactory();\n-        ClassMapping[] mappings;\n-        if (!ACTION_DROP.equals(_action))\n-            mappings = repos.getMappings();\n-        else if (_dropMap != null)\n-            mappings = (ClassMapping[]) _dropMap.toArray\n-                (new ClassMapping[_dropMap.size()]);\n-        else\n-            mappings = new ClassMapping[0];\n-\n-        try {\n-            if (_dropCls != null && !_dropCls.isEmpty()) {\n-                Class[] cls = (Class[]) _dropCls.toArray\n-                    (new Class[_dropCls.size()]);\n-                if (!io.drop(cls, _mode, null))\n-                    _log.warn(_loc.get(\"bad-drop\", _dropCls));\n-            }\n-\n-            if (_flushSchema) {\n-                // drop portions of the known schema that no mapping uses, and\n-                // add sequences used for value generation\n-                if (_dropUnused)\n-                    dropUnusedSchemaComponents(mappings);\n-                addSequenceComponents(mappings);\n-\n-                // now run the schematool as long as we're doing some schema\n-                // action and the user doesn't just want an xml output\n-                String[] schemaActions = _schemaActions.split(\",\");\n-                for (int i = 0; i < schemaActions.length; i++) {\n-                    if (!SCHEMA_ACTION_NONE.equals(schemaActions[i])\n-                        && (_schemaWriter == null || (_schemaTool != null\n-                            && _schemaTool.getWriter() != null))) {\n-                        SchemaTool tool = newSchemaTool(schemaActions[i]);\n-\n-                        // configure the tool with additional settings\n-                        if (flags != null) {\n-                            tool.setDropTables(flags.dropTables);\n-                            tool.setDropSequences(flags.dropSequences);\n-                            tool.setWriter(flags.sqlWriter);\n-                            tool.setOpenJPATables(flags.openjpaTables);\n-                        }\n-\n-                        tool.setSchemaGroup(getSchemaGroup());\n-                        tool.run();\n-                        tool.record();\n-                    }\n-                }\n-\n-                // xml output of schema?\n-                if (_schemaWriter != null) {\n-                    // serialize the planned schema to the stream\n-                    SchemaSerializer ser = new XMLSchemaSerializer(_conf);\n-                    ser.addAll(getSchemaGroup());\n-                    ser.serialize(_schemaWriter, ser.PRETTY);\n-                    _schemaWriter.flush();\n-                }\n-            }\n-            if (!_flush)\n-                return;\n-\n-            QueryMetaData[] queries = repos.getQueryMetaDatas();\n-            SequenceMetaData[] seqs = repos.getSequenceMetaDatas();\n-            Map output = null;\n-\n-            // if we're outputting to stream, set all metas to same file so\n-            // they get placed in single string\n-            if (_mappingWriter != null) {\n-                output = new HashMap();\n-                File tmp = new File(\"openjpatmp\");\n-                for (int i = 0; i < mappings.length; i++)\n-                    mappings[i].setSource(tmp, mappings[i].SRC_OTHER);\n-                for (int i = 0; i < queries.length; i++)\n-                    queries[i].setSource(tmp, queries[i].getSourceScope(),\n-                        queries[i].SRC_OTHER);\n-                for (int i = 0; i < seqs.length; i++)\n-                    seqs[i].setSource(tmp, seqs[i].getSourceScope(),\n-                        seqs[i].SRC_OTHER);\n-            }\n-\n-            // store\n-            if (!io.store(mappings, queries, seqs, _mode, output))\n-                throw new MetaDataException(_loc.get(\"bad-store\"));\n-\n-            // write to stream\n-            if (_mappingWriter != null) {\n-                PrintWriter out = new PrintWriter(_mappingWriter);\n-                for (Iterator itr = output.values().iterator();\n-                    itr.hasNext();)\n-                    out.println((String) itr.next());\n-                out.flush();\n-            }\n-        }\n-        catch (RuntimeException re) {\n-            throw re;\n-        } catch (Exception e) {\n-            throw new GeneralException(e);\n-        } finally {\n-            clear();\n-        }\n-    }\n-\n-    /**\n-     * Drops schema components that appear to be unused from the local\n-     * copy of the schema group.\n-     */\n-    private void dropUnusedSchemaComponents(ClassMapping[] mappings) {\n-        FieldMapping[] fields;\n-        for (int i = 0; i < mappings.length; i++) {\n-            mappings[i].refSchemaComponents();\n-            mappings[i].getDiscriminator().refSchemaComponents();\n-            mappings[i].getVersion().refSchemaComponents();\n-            fields = mappings[i].getDefinedFieldMappings();\n-            for (int j = 0; j < fields.length; j++)\n-                fields[j].refSchemaComponents();\n-        }\n-\n-        // also allow the dbdictionary to ref any schema components that\n-        // it adds apart from mappings\n-        SchemaGroup group = getSchemaGroup();\n-        Schema[] schemas = group.getSchemas();\n-        Table[] tables;\n-        for (int i = 0; i < schemas.length; i++) {\n-            tables = schemas[i].getTables();\n-            for (int j = 0; j < tables.length; j++)\n-                _dict.refSchemaComponents(tables[j]);\n-        }\n-\n-        group.removeUnusedComponents();\n-    }\n-\n-    /**\n-     * Add tables used by sequences to the given schema.\n-     */\n-    private void addSequenceComponents(ClassMapping[] mappings) {\n-        SchemaGroup group = getSchemaGroup();\n-        for (int i = 0; i < mappings.length; i++)\n-            addSequenceComponents(mappings[i], group);\n-    }\n-\n-    /**\n-     * Add tables used by sequences to the given schema.\n-     */\n-    private void addSequenceComponents(ClassMapping mapping,\n-        SchemaGroup group) {\n-        SequenceMetaData smd = mapping.getIdentitySequenceMetaData();\n-        Seq seq = null;\n-        if (smd != null)\n-            seq = smd.getInstance(null);\n-        else if (mapping.getIdentityStrategy() == ValueStrategies.NATIVE\n-            || (mapping.getIdentityStrategy() == ValueStrategies.NONE\n-            && mapping.getIdentityType() == ClassMapping.ID_DATASTORE))\n-            seq = _conf.getSequenceInstance();\n-\n-        if (seq instanceof JDBCSeq)\n-            ((JDBCSeq) seq).addSchema(mapping, group);\n-\n-        FieldMapping[] fmds;\n-        if (mapping.getEmbeddingMetaData() == null)\n-            fmds = mapping.getDefinedFieldMappings();\n-        else\n-            fmds = mapping.getFieldMappings();\n-        for (int i = 0; i < fmds.length; i++) {\n-            smd = fmds[i].getValueSequenceMetaData();\n-            if (smd != null) {\n-                seq = smd.getInstance(null);\n-                if (seq instanceof JDBCSeq)\n-                    ((JDBCSeq) seq).addSchema(mapping, group);\n-            } else if (fmds[i].getEmbeddedMapping() != null)\n-                addSequenceComponents(fmds[i].getEmbeddedMapping(), group);\n-        }\n-    }\n-\n-    ///////////\n-    // Actions\n-    ///////////\n-\n-    /**\n-     * Run the configured action on the given instance.\n-     */\n-    public void run(Class cls) {\n-        if (ACTION_ADD.equals(_action)) {\n-            if (_meta)\n-                addMeta(cls);\n-            else\n-                add(cls);\n-        } else if (ACTION_REFRESH.equals(_action))\n-            refresh(cls);\n-        else if (ACTION_BUILD_SCHEMA.equals(_action))\n-            buildSchema(cls);\n-        else if (ACTION_DROP.equals(_action))\n-            drop(cls);\n-        else if (ACTION_VALIDATE.equals(_action))\n-            validate(cls);\n-    }\n-\n-    /**\n-     * Add the mapping for the given instance.\n-     */\n-    private void add(Class cls) {\n-        if (cls == null)\n-            return;\n-\n-        MappingRepository repos = getRepository();\n-        repos.setStrategyInstaller(new MappingStrategyInstaller(repos));\n-        if (getMapping(repos, cls, true) != null) {\n-            _flush = true;\n-            _flushSchema = true;\n-        }\n-    }\n-\n-    /**\n-     * Return the mapping for the given type, or null if the type is\n-     * persistence-aware.\n-     */\n-    private static ClassMapping getMapping(MappingRepository repos, Class cls,\n-        boolean validate) {\n-        // this will parse all possible metadata rsrcs looking for cls, so\n-        // will detect if p-aware\n-        ClassMapping mapping = repos.getMapping(cls, null, false);\n-        if (mapping != null)\n-            return mapping;\n-        if (!validate || cls.isInterface() \n-            || repos.getPersistenceAware(cls) != null)\n-            return null;\n-        throw new MetaDataException(_loc.get(\"no-meta\", cls));\n-    }\n-\n-    /**\n-     * Create a metadata for the given instance.\n-     */\n-    private void addMeta(Class cls) {\n-        if (cls == null)\n-            return;\n-\n-        _flush = true;\n-        MappingRepository repos = getRepository();\n-        repos.setResolve(MODE_MAPPING, false);\n-        MetaDataFactory factory = repos.getMetaDataFactory();\n-        factory.getDefaults().setIgnoreNonPersistent(false);\n-        factory.setStoreMode(MetaDataFactory.STORE_VERBOSE);\n-\n-        ClassMetaData meta = repos.addMetaData(cls);\n-        FieldMetaData[] fmds = meta.getDeclaredFields();\n-        for (int i = 0; i < fmds.length; i++) {\n-            if (fmds[i].getDeclaredTypeCode() == JavaTypes.OBJECT\n-                && fmds[i].getDeclaredType() != Object.class)\n-                fmds[i].setDeclaredTypeCode(JavaTypes.PC);\n-        }\n-        meta.setSource(_file, meta.getSourceType());\n-        meta.setResolve(MODE_META, true);\n-    }\n-\n-    /**\n-     * Refresh or add the mapping for the given instance.\n-     */\n-    private void refresh(Class cls) {\n-        if (cls == null)\n-            return;\n-\n-        MappingRepository repos = getRepository();\n-        repos.setStrategyInstaller(new RefreshStrategyInstaller(repos));\n-        if (getMapping(repos, cls, true) != null) {\n-            _flush = true;\n-            _flushSchema = true;\n-        }\n-    }\n-\n-    /**\n-     * Validate the mappings for the given class and its fields.\n-     */\n-    private void validate(Class cls) {\n-        if (cls == null)\n-            return;\n-\n-        MappingRepository repos = getRepository();\n-        repos.setStrategyInstaller(new RuntimeStrategyInstaller(repos));\n-        if (getMapping(repos, cls, true) != null)\n-            _flushSchema = !contains(_schemaActions,SCHEMA_ACTION_NONE)\n-                && !contains(_schemaActions,SchemaTool.ACTION_ADD);\n-    }\n-\n-    /**\n-     * Create the schema using the mapping for the given instance.\n-     */\n-    private void buildSchema(Class cls) {\n-        if (cls == null)\n-            return;\n-\n-        MappingRepository repos = getRepository();\n-        repos.setStrategyInstaller(new RuntimeStrategyInstaller(repos));\n-        if (getMapping(repos, cls, true) == null)\n-            return;\n-\n-        // set any logical pks to non-logical so they get flushed\n-        _flushSchema = true;\n-        Schema[] schemas = _schema.getSchemas();\n-        Table[] tables;\n-        Column[] cols;\n-        for (int i = 0; i < schemas.length; i++) {\n-            tables = schemas[i].getTables();\n-            for (int j = 0; j < tables.length; j++) {\n-                if (tables[j].getPrimaryKey() == null)\n-                    continue;\n-\n-                tables[j].getPrimaryKey().setLogical(false);\n-                cols = tables[j].getPrimaryKey().getColumns();\n-                for (int k = 0; k < cols.length; k++)\n-                    cols[k].setNotNull(true);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Drop mapping for given class.\n-     */\n-    private void drop(Class cls) {\n-        if (cls == null)\n-            return;\n-\n-        if (_dropCls == null)\n-            _dropCls = new HashSet();\n-        _dropCls.add(cls);\n-        if (!contains(_schemaActions,SchemaTool.ACTION_DROP))\n-            return;\n-\n-        MappingRepository repos = getRepository();\n-        repos.setStrategyInstaller(new RuntimeStrategyInstaller(repos));\n-        ClassMapping mapping = null;\n-        try {\n-            mapping = repos.getMapping(cls, null, false);\n-        } catch (Exception e) {\n-        }\n-\n-        if (mapping != null) {\n-            _flushSchema = true;\n-            if (_dropMap == null)\n-                _dropMap = new HashSet();\n-            _dropMap.add(mapping);\n-        } else\n-            _log.warn(_loc.get(\"no-drop-meta\", cls));\n-    }\n-\n-    ////////\n-    // Main\n-    ////////\n-\n-    /**\n-     * Usage: java org.apache.openjpa.jdbc.meta.MappingTool [option]* \n-     * [-action/-a &lt;refresh | add | buildSchema | drop | validate | import \n-     * | export&gt;] &lt;class name | .java file | .class file | .jdo file&gt;*\n-     * Where the following options are recognized.\n-     * <ul>\n-     * <li><i>-properties/-p &lt;properties file or resource&gt;</i>: The\n-     * path or resource name of a OpenJPA properties file containing\n-     * information as outlined in {@link OpenJPAConfiguration}. Optional.</li>\n-     * <li><i>-&lt;property name&gt; &lt;property value&gt;</i>: All bean\n-     * properties of the OpenJPA {@link JDBCConfiguration} can be set by\n-     * using their\tnames and supplying a value. For example:\n-     * <code>-licenseKey adslfja83r3lkadf</code></li>\n-     * <li><i>-file/-f &lt;stdout | output file or resource&gt;</i>: Use\n-     * this option to write the planned mappings to an XML document rather\n-     * than store them in the repository. This option also specifies the\n-     * metadata file to write to if using the <code>add</code> action with\n-     * the <code>-meta true</code> flag, or the file to dump to if using\n-     * the <code>export</code> action.</li>\n-     * <li><i>-schemaAction/-sa &lt;schema action | none&gt;</i>: The\n-     * {@link SchemaTool} defines the actions possible. The actions will\n-     * apply to all schema components used by the mappings involved.\n-     * Unless you are running the mapping tool on all of your persistent\n-     * types at once, be careful running schema actions that can drop data.\n-     * It is possible to accidentally drop schema components that are\n-     * used by classes you aren't currently running the tool over. The\n-     * action defaults to <code>add</code>.</li>\n-     * <li><i>-schemaFile/-sf &lt;stdout | output file or resource&gt;</i>: Use\n-     * this option to write the planned schema to an XML document rather\n-     * than modify the data store.</li>\n-     * <li><i>-sqlFile/-sql &lt;stdout | output file or resource&gt;</i>: Use\n-     * this option to write the planned schema changes as a SQL\n-     * script rather than modifying the data store.</li>\n-     * <li><i>-dropTables/-dt &lt;true/t | false/f&gt;</i>: Corresponds to the\n-     * same-named option in the {@link SchemaTool}.</li>\n-     * <li><i>-dropSequences/-dsq &lt;true/t | false/f&gt;</i>: Corresponds\n-     * to the same-named option in the {@link SchemaTool}.</li>\n-     * <li><i>-openjpaTables/-kt &lt;true/t | false/f&gt;</i>: Corresponds to\n-     * the same-named option in the {@link SchemaTool}.</li>\n-     * <li><i>-ignoreErrors/-i &lt;true/t | false/f&gt;</i>: Corresponds to the\n-     * same-named option in the {@link SchemaTool}.</li>\n-     * <li><i>-readSchema/-rs &lt;true/t | false/f&gt;</i>: Set this to true\n-     * to read the entire existing schema (even when false the parts of\n-     * the schema used by classes the tool is run on will still be read).\n-     * Turning on schema reading can ensure that no naming conflicts will\n-     * occur, but it can take a long time.</li>\n-     * <li><i>-primaryKeys/-pk &lt;true/t | false/f&gt;</i>: Whether primary\n-     * keys on existing tables are manipulated. Defaults to false.</li>\n-     * <li><i>-foreignKeys/-fk &lt;true/t | false/f&gt;</i>: Whether foreign\n-     * keys on existing tables are manipulated. Defaults to false.</li>\n-     * <li><i>-indexes/-ix &lt;true/t | false/f&gt;</i>: Whether indexes on\n-     * existing tables are manipulated. Defaults to false.</li>\n-     * <li><i>-sequences/-sq &lt;true/t | false/f&gt;</i>: Whether sequences\n-     * are manipulated. Defaults to true.</li>\n-     * <li><i>-schemas/-s &lt;schema and table names&gt;</i>: A list of schemas\n-     * and/or tables to read. Corresponds to the\n-     * same-named option in the {@link SchemaGenerator}. This option\n-     * is ignored if <code>readSchema</code> is false.</li>\n-     * <li><i>-meta/-m &lt;true/t | false/f&gt;</i>: Whether the given action\n-     * applies to metadata as well as mappings.</li>\n-     * </ul>\n-     *  The various actions are as follows.\n-     * <ul>\n-     * <li><i>refresh</i>: Bring the mapping information up-to-date\n-     * with the class definitions. OpenJPA will attempt to use any provided\n-     * mapping information, and fill in missing information. If the\n-     * provided information conflicts with the class definition, the\n-     * conflicting information will be discarded and the class/field will\n-     * be re-mapped to new columns/tables. This is the default action.</li>\n-     * <li><i>add</i>: If used with the <code>-meta</code> option, adds new\n-     * default metadata for the given class(es). Otherwise, brings the\n-     * mapping information up-to-date with the class\n-     * definitions. OpenJPA will attempt to use any provided mapping\n-     * information, and fill in missing information. OpenJPA will fail if\n-     * the provided information conflicts with the class definition.</li>\n-     * <li><i>buildSchema</i>: Create the schema matching the existing\n-     * mappings for the given class(es). Any invalid mapping information\n-     * will cause an exception.</li>\n-     * <li><i>drop</i>: Delete mappings for the given classes. If used with\n-     * the <code>-meta</code> option, also deletes metadata.</li>\n-     * <li><i>validate</i>: Validate the given mappings. The mapping\n-     * repository and schema will not be affected.</li>\n-     * <li><i>import</i>: Import mappings from an XML document and store\n-     * them as the current system mappings.</li>\n-     * <li><i>export</i>: Dump the current mappings for the given classes to\n-     * an XML document specified by the <code>file</code> option.</li>\n-     * If used with the <code>-meta</code> option, the metadata will be\n-     * included in the export.\n-     * </ul>\n-     *  Each class supplied as an argument must have valid metadata. If\n-     * no class arguments are given, the tool runs on all metadata files in\n-     * the CLASSPATH.\n-     *  Examples:\n-     * <ul>\n-     * <li>Refresh the mappings for given package, without dropping any\n-     * schema components:<br />\n-     * <code>java org.apache.openjpa.jdbc.meta.MappingTool \n-     *      mypackage.jdo</code></li>\n-     * <li>Refresh the mappings for all persistent classes in the classpath,\n-     * dropping any unused columns and even tables:<br />\n-     * <code>java org.apache.openjpa.jdbc.meta.MappingTool -sa refresh\n-     * -dt true</code></li>\n-     * <li>Make sure the mappings you've created by hand match the object\n-     * featureSelection and schema:<br />\n-     * <code>java org.apache.openjpa.jbdc.meta.MappingTool\n-     * -a validate Person.java</code></li>\n-     * <li>Remove the recorded mapping for a given class:<br />\n-     * <code>java org.apache.openjpa.jbdc.meta.MappingTool\n-     * -a drop Person.java</code></li>\n-     * <li>Record the current mappings in an XML file:<br />\n-     * <code>java org.apache.openjpa.jdbc.meta.MappingTool\n-     * -f mypackage.orm -a export mypackage.jdo</code></li>\n-     * </ul>\n-     */\n-    public static void main(String[] arguments)\n-        throws IOException, SQLException {\n-        Options opts = new Options();\n-        final String[] args = opts.setFromCmdLine(arguments);\n-        boolean ret = Configurations.runAgainstAllAnchors(opts,\n-            new Configurations.Runnable() {\n-            public boolean run(Options opts) throws IOException, SQLException {\n-                JDBCConfiguration conf = new JDBCConfigurationImpl();\n-                try {\n-                    return MappingTool.run(conf, args, opts);\n-                } finally {\n-                    conf.close();\n-                }\n-            }\n-        });\n-        if (!ret)\n-            System.err.println(_loc.get(\"tool-usage\"));\n-    }\n-\n-    /**\n-     * Run the tool. Returns false if invalid options are given.\n-     *\n-     * @see #main\n-     */\n-    public static boolean run(JDBCConfiguration conf, String[] args,\n-        Options opts)\n-        throws IOException, SQLException {\n-        // flags\n-        Flags flags = new Flags();\n-        flags.action = opts.removeProperty(\"action\", \"a\", flags.action);\n-        flags.schemaAction = opts.removeProperty(\"schemaAction\", \"sa\",\n-            flags.schemaAction);\n-        flags.dropTables = opts.removeBooleanProperty\n-            (\"dropTables\", \"dt\", flags.dropTables);\n-        flags.openjpaTables = opts.removeBooleanProperty\n-            (\"openjpaTables\", \"ot\", flags.openjpaTables);\n-        flags.dropSequences = opts.removeBooleanProperty\n-            (\"dropSequences\", \"dsq\", flags.dropSequences);\n-        flags.readSchema = opts.removeBooleanProperty\n-            (\"readSchema\", \"rs\", flags.readSchema);\n-        flags.primaryKeys = opts.removeBooleanProperty\n-            (\"primaryKeys\", \"pk\", flags.primaryKeys);\n-        flags.indexes = opts.removeBooleanProperty(\"indexes\", \"ix\",\n-            flags.indexes);\n-        flags.foreignKeys = opts.removeBooleanProperty(\"foreignKeys\", \"fk\",\n-            flags.foreignKeys);\n-        flags.sequences = opts.removeBooleanProperty(\"sequences\", \"sq\",\n-            flags.sequences);\n-        flags.ignoreErrors = opts.removeBooleanProperty\n-            (\"ignoreErrors\", \"i\", flags.ignoreErrors);\n-        flags.meta = opts.removeBooleanProperty(\"meta\", \"m\", flags.meta);\n-        String fileName = opts.removeProperty(\"file\", \"f\", null);\n-        String schemaFileName = opts.removeProperty(\"schemaFile\", \"sf\", null);\n-        String sqlFileName = opts.removeProperty(\"sqlFile\", \"sql\", null);\n-        String schemas = opts.removeProperty(\"s\");\n-        if (schemas != null)\n-            opts.setProperty(\"schemas\", schemas);\n-\n-        Configurations.populateConfiguration(conf, opts);\n-        ClassLoader loader = conf.getClassResolverInstance().\n-            getClassLoader(MappingTool.class, null);\n-        if (flags.meta && ACTION_ADD.equals(flags.action))\n-            flags.metaDataFile = Files.getFile(fileName, loader);\n-        else\n-            flags.mappingWriter = Files.getWriter(fileName, loader);\n-        flags.schemaWriter = Files.getWriter(schemaFileName, loader);\n-        flags.sqlWriter = Files.getWriter(sqlFileName, loader);\n-\n-        return run(conf, args, flags, loader);\n-    }\n-\n-    /**\n-     * Run the tool. Return false if an invalid option was given.\n-     */\n-    public static boolean run(JDBCConfiguration conf, String[] args,\n-        Flags flags, ClassLoader loader)\n-        throws IOException, SQLException {\n-        // default action based on whether the mapping defaults fills in\n-        // missing info\n-        if (flags.action == null) {\n-            if (conf.getMappingDefaultsInstance().defaultMissingInfo())\n-                flags.action = ACTION_BUILD_SCHEMA;\n-            else\n-                flags.action = ACTION_REFRESH;\n-        }\n-\n-        // collect the classes to act on\n-        Log log = conf.getLog(OpenJPAConfiguration.LOG_TOOL);\n-        Collection classes = null;\n-        if (args.length == 0) {\n-            if (ACTION_IMPORT.equals(flags.action))\n-                return false;\n-            log.info(_loc.get(\"running-all-classes\"));\n-            classes = conf.getMappingRepositoryInstance().\n-                loadPersistentTypes(true, loader);\n-        } else {\n-            classes = new HashSet();\n-            ClassArgParser classParser = conf.getMetaDataRepositoryInstance().\n-                getMetaDataFactory().newClassArgParser();\n-            classParser.setClassLoader(loader);\n-            Class[] parsed;\n-            for (int i = 0; args != null && i < args.length; i++) {\n-                parsed = classParser.parseTypes(args[i]);\n-                classes.addAll(Arrays.asList(parsed));\n-            }\n-        }\n-\n-        Class[] act = (Class[]) classes.toArray(new Class[classes.size()]);\n-        if (ACTION_EXPORT.equals(flags.action)) {\n-            // run exports until the first export succeeds\n-            ImportExport[] instances = newImportExports();\n-            for (int i = 0; i < instances.length; i++) {\n-                if (instances[i].exportMappings(conf, act, flags.meta, log,\n-                    flags.mappingWriter))\n-                    return true;\n-            }\n-            return false;\n-        }\n-        if (ACTION_IMPORT.equals(flags.action)) {\n-            // run exports until the first export succeeds\n-            ImportExport[] instances = newImportExports();\n-            for (int i = 0; i < instances.length; i++) {\n-                if (instances[i].importMappings(conf, act, args, flags.meta,\n-                    log, loader))\n-                    return true;\n-            }\n-            return false;\n-        }\n-\n-        MappingTool tool;\n-        try {\n-            tool = new MappingTool(conf, flags.action, flags.meta);\n-        } catch (IllegalArgumentException iae) {\n-            return false;\n-        }\n-\n-        // setup the tool\n-        tool.setIgnoreErrors(flags.ignoreErrors);\n-        tool.setMetaDataFile(flags.metaDataFile);\n-        tool.setMappingWriter(flags.mappingWriter);\n-        tool.setSchemaAction(flags.schemaAction);\n-        tool.setSchemaWriter(flags.schemaWriter);\n-        tool.setReadSchema(flags.readSchema\n-            && !ACTION_VALIDATE.equals(flags.action));\n-        tool.setPrimaryKeys(flags.primaryKeys);\n-        tool.setForeignKeys(flags.foreignKeys);\n-        tool.setIndexes(flags.indexes);\n-        tool.setSequences(flags.sequences || flags.dropSequences);\n-\n-        // and run the action\n-        for (int i = 0; i < act.length; i++) {\n-            log.info(_loc.get(\"tool-running\", act[i], flags.action));\n-            if (i == 0 && flags.readSchema)\n-                log.info(_loc.get(\"tool-time\"));\n-            tool.run(act[i]);\n-        }\n-        log.info(_loc.get(\"tool-record\"));\n-        tool.record(flags);\n-        return true;\n-    }\n-\n-    /**\n-     * Create an {@link ImportExport} instance.\n-     */\n-    private static ImportExport[] newImportExports() {\n-        try {\n-            Class[] types = Services.getImplementorClasses(ImportExport.class);\n-            ImportExport[] instances = new ImportExport[types.length];\n-            for (int i = 0; i < types.length; i++)\n-                instances[i] = (ImportExport) AccessController.doPrivileged(\n-                    J2DoPrivHelper.newInstanceAction(types[i]));\n-            return instances;\n-        } catch (Throwable t) {\n-            if (t instanceof PrivilegedActionException)\n-                t = ((PrivilegedActionException) t).getException();\n-            throw new InternalException(_loc.get(\"importexport-instantiate\"),t);\n-        }\n-    }\n-    \n-    private static boolean contains(String list, String key) {\n-    \treturn (list == null) ? false : list.indexOf(key) != -1;\n-    }\n-\n-    /**\n-     * Run flags.\n-     */\n-    public static class Flags {\n-\n-        public String action = null;\n-        public boolean meta = false;\n-        public String schemaAction = SchemaTool.ACTION_ADD;\n-        public File metaDataFile = null;\n-        public Writer mappingWriter = null;\n-        public Writer schemaWriter = null;\n-        public Writer sqlWriter = null;\n-        public boolean ignoreErrors = false;\n-        public boolean readSchema = false;\n-        public boolean dropTables = false;\n-        public boolean openjpaTables = false;\n-        public boolean dropSequences = false;\n-        public boolean sequences = true;\n-        public boolean primaryKeys = false;\n-        public boolean foreignKeys = false;\n-        public boolean indexes = false;\n-    }\n-\n-    /**\n-     * Helper used to import and export mapping data.\n-     */\n-    public static interface ImportExport {\n-\n-        /**\n-         * Import mappings for the given classes based on the given arguments.\n-         */\n-        public boolean importMappings(JDBCConfiguration conf, Class[] act,\n-            String[] args, boolean meta, Log log, ClassLoader loader)\n-            throws IOException;\n-\n-        /**\n-         * Export mappings for the given classes based on the given arguments.\n-         */\n-        public boolean exportMappings(JDBCConfiguration conf, Class[] act,\n-            boolean meta, Log log, Writer writer)\n-            throws IOException;\n-    }\n-}"},{"sha":"1b2bec007c1d9e47512059d1a845406df816ee3e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MetaDataPlusMappingFactory.java","status":"removed","additions":0,"deletions":142,"changes":142,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MetaDataPlusMappingFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MetaDataPlusMappingFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MetaDataPlusMappingFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,142 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.io.File;\n-import java.util.Collection;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import org.apache.openjpa.meta.ClassMetaData;\n-import org.apache.openjpa.meta.DelegatingMetaDataFactory;\n-import org.apache.openjpa.meta.MetaDataFactory;\n-import org.apache.openjpa.meta.MetaDataRepository;\n-import org.apache.openjpa.meta.QueryMetaData;\n-import org.apache.openjpa.meta.SequenceMetaData;\n-\n-/**\n- * Combines two internal {@link MetaDataFactory} instances -- one for\n- * metadata, one for mappings -- into a single {@link MetaDataFactory} facade.\n- *\n- * @author Abe White\n- * @nojavadoc\n- */\n-public class MetaDataPlusMappingFactory\n-    extends DelegatingMetaDataFactory {\n-\n-    private final MetaDataFactory _map;\n-\n-    /**\n-     * Constructor; supply delegates.\n-     */\n-    public MetaDataPlusMappingFactory(MetaDataFactory meta,\n-        MetaDataFactory map) {\n-        super(meta);\n-        _map = map;\n-\n-        meta.setStrict(true);\n-        map.setStrict(true);\n-    }\n-\n-    /**\n-     * Mapping factory delegate.\n-     */\n-    public MetaDataFactory getMappingDelegate() {\n-        return _map;\n-    }\n-\n-    /**\n-     * Innermost mapping delegate.\n-     */\n-    public MetaDataFactory getInnermostMappingDelegate() {\n-        if (_map instanceof DelegatingMetaDataFactory)\n-            return ((DelegatingMetaDataFactory) _map).getInnermostDelegate();\n-        return _map;\n-    }\n-\n-    public void setRepository(MetaDataRepository repos) {\n-        super.setRepository(repos);\n-        _map.setRepository(repos);\n-    }\n-\n-    public void setStoreDirectory(File dir) {\n-        super.setStoreDirectory(dir);\n-        _map.setStoreDirectory(dir);\n-    }\n-\n-    public void setStoreMode(int store) {\n-        super.setStoreMode(store);\n-        _map.setStoreMode(store);\n-    }\n-\n-    public void setStrict(boolean strict) {\n-        // always in strict mode\n-    }\n-\n-    public void load(Class cls, int mode, ClassLoader envLoader) {\n-        if ((mode & ~MODE_MAPPING) != MODE_NONE)\n-            super.load(cls, mode & ~MODE_MAPPING, envLoader);\n-        if (cls != null && (mode & MODE_MAPPING) != 0)\n-            _map.load(cls, mode & ~MODE_META, envLoader);\n-    }\n-\n-    public boolean store(ClassMetaData[] metas, QueryMetaData[] queries,\n-        SequenceMetaData[] seqs, int mode, Map output) {\n-        boolean store = true;\n-        if ((mode & ~MODE_MAPPING) != MODE_NONE)\n-            store &= super.store(metas, queries, seqs, mode & ~MODE_MAPPING,\n-                output);\n-        if ((mode & MODE_MAPPING) != 0)\n-            store &= _map.store(metas, queries, seqs, mode & ~MODE_META,\n-                output);\n-        return store;\n-    }\n-\n-    public boolean drop(Class[] cls, int mode, ClassLoader envLoader) {\n-        boolean drop = true;\n-        if ((mode & ~MODE_MAPPING) != MODE_NONE)\n-            drop &= super.drop(cls, mode & ~MODE_MAPPING, envLoader);\n-        if ((mode & MODE_MAPPING) != 0)\n-            drop &= _map.drop(cls, mode & ~MODE_META, envLoader);\n-        return drop;\n-    }\n-\n-    public Set getPersistentTypeNames(boolean classpath,\n-        ClassLoader envLoader) {\n-        Set names = super.getPersistentTypeNames(classpath, envLoader);\n-        if (names != null && !names.isEmpty())\n-            return names;\n-        return _map.getPersistentTypeNames(classpath, envLoader);\n-    }\n-\n-    public void clear() {\n-        super.clear();\n-        _map.clear();\n-    }\n-\n-    public void addClassExtensionKeys(Collection exts) {\n-        super.addClassExtensionKeys(exts);\n-        _map.addClassExtensionKeys(exts);\n-    }\n-\n-    public void addFieldExtensionKeys(Collection exts) {\n-        super.addFieldExtensionKeys(exts);\n-        _map.addFieldExtensionKeys(exts);\n-    }\n-}"},{"sha":"dd86475665ca6f1e11032aed1d06ce355e5bbc7c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneMappingDefaults.java","status":"removed","additions":0,"deletions":167,"changes":167,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneMappingDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneMappingDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneMappingDefaults.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,167 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\n-import org.apache.openjpa.jdbc.schema.Index;\n-import org.apache.openjpa.jdbc.schema.Schema;\n-import org.apache.openjpa.jdbc.schema.Table;\n-import org.apache.openjpa.jdbc.schema.Unique;\n-\n-import serp.util.Strings;\n-\n-/**\n- * No-op mapping defaults.\n- *\n- * @author Abe White\n- * @nojavadoc\n- */\n-public class NoneMappingDefaults\n-    implements MappingDefaults {\n-\n-    private static final NoneMappingDefaults _instance =\n-        new NoneMappingDefaults();\n-\n-    public static NoneMappingDefaults getInstance() {\n-        return _instance;\n-    }\n-\n-    public boolean defaultMissingInfo() {\n-        return false;\n-    }\n-\n-    public boolean useClassCriteria() {\n-        return false;\n-    }\n-\n-    public Object getStrategy(ClassMapping cls, boolean adapt) {\n-        return null;\n-    }\n-\n-    public Object getStrategy(Version vers, boolean adapt) {\n-        return null;\n-    }\n-\n-    public Object getStrategy(Discriminator disc, boolean adapt) {\n-        return null;\n-    }\n-\n-    public Object getStrategy(ValueMapping vm, Class type, boolean adapt) {\n-        return null;\n-    }\n-\n-    public Object getDiscriminatorValue(Discriminator disc, boolean adapt) {\n-        return null;\n-    }\n-\n-    public String getTableName(ClassMapping cls, Schema schema) {\n-        return Strings.getClassName(cls.getDescribedType()).replace('$', '_');\n-    }\n-\n-    public String getTableName(FieldMapping fm, Schema schema) {\n-        return fm.getName();\n-    }\n-\n-    public void populateDataStoreIdColumns(ClassMapping cls, Table table,\n-        Column[] cols) {\n-    }\n-\n-    public void populateColumns(Version vers, Table table, Column[] cols) {\n-    }\n-\n-    public void populateColumns(Discriminator disc, Table table,\n-        Column[] cols) {\n-    }\n-\n-    public void populateJoinColumn(ClassMapping cm, Table local, Table foreign,\n-        Column col, Object target, int pos, int cols) {\n-    }\n-\n-    public void populateJoinColumn(FieldMapping fm, Table local, Table foreign,\n-        Column col, Object target, int pos, int cols) {\n-    }\n-\n-    public void populateForeignKeyColumn(ValueMapping vm, String name,\n-        Table local, Table foreign, Column col, Object target, boolean inverse,\n-        int pos, int cols) {\n-    }\n-\n-    public void populateColumns(ValueMapping vm, String name, Table table,\n-        Column[] cols) {\n-    }\n-\n-    public boolean populateOrderColumns(FieldMapping fm, Table table,\n-        Column[] cols) {\n-        return false;\n-    }\n-\n-    public boolean populateNullIndicatorColumns(ValueMapping vm, String name,\n-        Table table, Column[] cols) {\n-        return false;\n-    }\n-\n-    public ForeignKey getJoinForeignKey(ClassMapping cls, Table local,\n-        Table foreign) {\n-        return null;\n-    }\n-\n-    public ForeignKey getJoinForeignKey(FieldMapping fm, Table local,\n-        Table foreign) {\n-        return null;\n-    }\n-\n-    public ForeignKey getForeignKey(ValueMapping vm, String name, Table local,\n-        Table foreign, boolean inverse) {\n-        return null;\n-    }\n-\n-    public Index getJoinIndex(FieldMapping fm, Table table, Column[] cols) {\n-        return null;\n-    }\n-\n-    public Index getIndex(ValueMapping vm, String name, Table table,\n-        Column[] cols) {\n-        return null;\n-    }\n-\n-    public Index getIndex(Version vers, Table table, Column[] cols) {\n-        return null;\n-    }\n-\n-    public Index getIndex(Discriminator disc, Table table, Column[] cols) {\n-        return null;\n-    }\n-\n-    public Unique getJoinUnique(FieldMapping fm, Table table, Column[] cols) {\n-        return null;\n-    }\n-\n-    public Unique getUnique(ValueMapping vm, String name, Table table,\n-        Column[] cols) {\n-        return null;\n-    }\n-\n-    public String getPrimaryKeyName(ClassMapping cm, Table table) {\n-        return null;\n-    }\n-\n-    public void installPrimaryKey(FieldMapping fm, Table table) {\n-    }\n-}"},{"sha":"070b796072352148d3de7bb4de572ebb5068b485","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneStrategyInstaller.java","status":"removed","additions":0,"deletions":63,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneStrategyInstaller.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneStrategyInstaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneStrategyInstaller.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,63 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import org.apache.openjpa.jdbc.meta.strats.NoneClassStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.NoneDiscriminatorStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.NoneFieldStrategy;\n-import org.apache.openjpa.jdbc.meta.strats.NoneVersionStrategy;\n-\n-/**\n- * Clears all mapping information from classes and installs none strategies.\n- *\n- * @author Abe White\n- * @nojavadoc\n- * @since 0.4.0\n- */\n-public class NoneStrategyInstaller\n-    extends StrategyInstaller {\n-\n-    /**\n-     * Constructor; supply configuration.\n-     */\n-    public NoneStrategyInstaller(MappingRepository repos) {\n-        super(repos);\n-    }\n-\n-    public void installStrategy(ClassMapping cls) {\n-        cls.clearMapping();\n-        cls.setStrategy(NoneClassStrategy.getInstance(), null);\n-        cls.setSourceMode(cls.MODE_MAPPING, true);\n-    }\n-\n-    public void installStrategy(FieldMapping field) {\n-        field.clearMapping();\n-        field.setStrategy(NoneFieldStrategy.getInstance(), null);\n-    }\n-\n-    public void installStrategy(Version version) {\n-        version.clearMapping();\n-        version.setStrategy(NoneVersionStrategy.getInstance(), null);\n-    }\n-\n-    public void installStrategy(Discriminator discrim) {\n-        discrim.clearMapping();\n-        discrim.setStrategy(NoneDiscriminatorStrategy.getInstance(), null);\n-    }\n-}"},{"sha":"608c0a8d5d01ef1c5ba187cf9c2f1b52ab924f33","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/PropertiesReverseCustomizer.java","status":"removed","additions":0,"deletions":230,"changes":230,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/PropertiesReverseCustomizer.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/PropertiesReverseCustomizer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/PropertiesReverseCustomizer.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,230 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.util.Properties;\n-import java.util.Set;\n-import java.util.TreeSet;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\n-import org.apache.openjpa.jdbc.schema.Table;\n-import org.apache.openjpa.lib.util.Localizer;\n-import serp.util.Strings;\n-\n-/**\n- * Simple {@link ReverseCustomizer} that uses a properties file to\n- * to allow customization of basic class and field properties. The\n- * customizer uses the following keys:\n- * <ul>\n- * <li><i>&lt;table name&gt;.table-type</i>: Override the default type of the\n- * given table. Legal values are: <code>base, secondary,\n- * secondary-outer, association, subclass, none</code>. See\n- * the TABLE_XXX constants in {@link ReverseMappingTool} for descriptions.</li>\n- * <li><i>&lt;class name&gt;.rename</i>: Override the tool-generated class name\n- * with the given value. Use full class names, including package. Use a\n- * value of <code>none</code> to reject the class and leave the\n- * corresponding table unmapped.</li>\n- * <li><i>&lt;table name&gt;.class-name</i>: Assign the given fully-qualified\n- * class name to the type created from the given table. Use a value of\n- * <code>none</code> to prevent mapping this table. This property can be\n- * used in place of the <code>rename</code> property.\n- * <li><i>&lt;class name&gt;.identity</i>: Set this property to\n- * <code>datastore</code>, <code>builtin</code>, or the desired\n- * fully-qualified application identity class name to override the\n- * reverse mapping tool's default identity settings. If the class has been\n- * renamed, use the new name.</li>\n- * <li><i>&lt;class name&gt;.&lt;field name&gt;.rename</i>: Override the\n- * tool-generated field name with the given value. Use the field owner's\n- * full class name in the property key. The property value should be the\n- * new field name, without the preceding class name. Use a value of\n- * <code>none</code> to reject the generated mapping.</li>\n- * <li><i>&lt;table name&gt;.&lt;column name&gt;.field-name</i>: Assign the\n- * field name to use for the mapping of a particular column. If this is\n- * a multi-column mapping, any one of the columns can be used. Use a value\n- * of <code>none</code> to prevent the column (and associated columns)\n- * from being mapped. This property can be used in place of the\n- * <code>rename</code> property.\n- * <li><i>&lt;class name&gt;.&lt;field name&gt;.type</i>: The class name of\n- * the type to give the named field. Use full class names. If the field\n- * has been renamed, use the new name.</li>\n- * <li><i>&lt;class name&gt;.&lt;field name&gt;.value</i>: The initial value\n- * for the named field. The given string will be placed as-is in the\n- * generated Java code, so be sure to add quotes to strings, etc. If the\n- * field has been renamed, use the new name.</li>\n- * </ul> All keys are optional; if not specified, the customizer keeps the\n- * default value generated by the reverse mapping tool.\n- */\n-public class PropertiesReverseCustomizer\n-    implements ReverseCustomizer {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (PropertiesReverseCustomizer.class);\n-\n-    protected ReverseMappingTool tool = null;\n-    private Properties _props = null;\n-    private Set _unaccessed = null;\n-\n-    public void setConfiguration(Properties props) {\n-        _props = props;\n-        _unaccessed = new TreeSet(props.keySet());\n-    }\n-\n-    public void setTool(ReverseMappingTool tool) {\n-        this.tool = tool;\n-    }\n-\n-    public int getTableType(Table table, int defaultType) {\n-        String type = getProperty(table.getName() + \".table-type\");\n-        if (type == null && table.getSchemaName() != null)\n-            type = getProperty(table.getFullName() + \".table-type\");\n-        if (type == null)\n-            return defaultType;\n-        if (\"none\".equals(type))\n-            return ReverseMappingTool.TABLE_NONE;\n-        if (\"base\".equals(type))\n-            return ReverseMappingTool.TABLE_BASE;\n-        if (\"secondary\".equals(type))\n-            return ReverseMappingTool.TABLE_SECONDARY;\n-        if (\"secondary-outer\".equals(type))\n-            return ReverseMappingTool.TABLE_SECONDARY_OUTER;\n-        if (\"association\".equals(type))\n-            return ReverseMappingTool.TABLE_ASSOCIATION;\n-        if (\"subclass\".equals(type))\n-            return ReverseMappingTool.TABLE_SUBCLASS;\n-        throw new IllegalArgumentException(table.getName() + \".table-type: \"\n-            + type);\n-    }\n-\n-    public String getClassName(Table table, String defaultName) {\n-        // check for a rename property or a table-naming property\n-        String name = getProperty(defaultName + \".rename\");\n-        if (name == null) {\n-            name = getProperty(table.getName() + \".class-name\");\n-            if (name == null && table.getSchemaName() != null)\n-                name = getProperty(table.getFullName() + \".class-name\");\n-        }\n-\n-        if (name == null) {\n-            if (tool.getLog().isTraceEnabled())\n-                tool.getLog().trace(_loc.get(\"custom-no-class\",\n-                    defaultName, table));\n-            return defaultName;\n-        }\n-\n-        if (\"none\".equals(name)) {\n-            if (tool.getLog().isInfoEnabled())\n-                tool.getLog().info(_loc.get(\"custom-rm-class\",\n-                    defaultName, table));\n-            return null;\n-        }\n-\n-        if (tool.getLog().isInfoEnabled())\n-            tool.getLog().info(_loc.get(\"custom-class\", defaultName, name));\n-        return name;\n-    }\n-\n-    public void customize(ClassMapping cls) {\n-        // customize identity type\n-        String id = getProperty(cls.getDescribedType().getName()\n-            + \".identity\");\n-        if (\"datastore\".equals(id)) {\n-            cls.setObjectIdType(null, false);\n-            cls.setIdentityType(ClassMapping.ID_DATASTORE);\n-        } else if (\"builtin\".equals(id)) {\n-            cls.setObjectIdType(null, false);\n-            cls.setIdentityType(ClassMapping.ID_APPLICATION);\n-        } else if (id != null)\n-            cls.setObjectIdType(tool.generateClass(id, null), false);\n-    }\n-\n-    public String getClassCode(ClassMapping mapping) {\n-        return null;\n-    }\n-\n-    public void customize(FieldMapping field) {\n-        String type = getProperty(field.getFullName(false) + \".type\");\n-        if (type != null)\n-            field.setDeclaredType(Strings.toClass(type, null));\n-    }\n-\n-    public String getFieldName(ClassMapping dec, Column[] cols, ForeignKey fk,\n-        String defaultName) {\n-        // check for a rename property or a column-naming property\n-        String name = getProperty(dec.getDescribedType().getName() + \".\"\n-            + defaultName + \".rename\");\n-        for (int i = 0; name == null && i < cols.length; i++) {\n-            name = getProperty(cols[i].getTableName() + \".\"\n-                + cols[i].getName() + \".\" + \"field-name\");\n-            if (name == null && cols[i].getTable().getSchemaName() != null)\n-                name = getProperty(cols[i].getTable().getFullName()\n-                    + \".\" + cols[i].getName() + \".\" + \"field-name\");\n-        }\n-\n-        if (name == null) {\n-            if (tool.getLog().isTraceEnabled())\n-                tool.getLog().trace(_loc.get(\"custom-no-field\", defaultName,\n-                    dec));\n-            return defaultName;\n-        }\n-\n-        if (\"none\".equals(name)) {\n-            if (tool.getLog().isInfoEnabled())\n-                tool.getLog().info(_loc.get(\"custom-rm-field\", defaultName,\n-                    dec));\n-            return null;\n-        }\n-\n-        if (tool.getLog().isInfoEnabled())\n-            tool.getLog().info(_loc.get(\"custom-field\", defaultName, dec,\n-                name));\n-        return name;\n-    }\n-\n-    public String getInitialValue(FieldMapping field) {\n-        return getProperty(field.getFullName(false) + \".value\");\n-    }\n-\n-    public String getDeclaration(FieldMapping field) {\n-        return null;\n-    }\n-\n-    public String getFieldCode(FieldMapping field) {\n-        return null;\n-    }\n-\n-    public boolean unmappedTable(Table table) {\n-        return false;\n-    }\n-\n-    public void close() {\n-        if (!_unaccessed.isEmpty() && tool.getLog().isTraceEnabled())\n-            tool.getLog().trace(_loc.get(\"custom-unused-props\", _unaccessed));\n-    }\n-\n-    /**\n-     * Return the property value for the given key, or null if none.\n-     */\n-    protected String getProperty(String key) {\n-        String val = StringUtils.trimToNull(_props.getProperty(key));\n-        _unaccessed.remove(key);\n-        return val;\n-    }\n-}"},{"sha":"b724ae6931b5e12565558230d3edffea87c258d2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/QueryResultMapping.java","status":"removed","additions":0,"deletions":629,"changes":629,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/QueryResultMapping.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/QueryResultMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/QueryResultMapping.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,629 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.io.File;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.BitSet;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-\n-import org.apache.commons.lang.StringUtils;\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.sql.Joins;\n-import org.apache.openjpa.lib.meta.SourceTracker;\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.lib.xml.Commentable;\n-import org.apache.openjpa.meta.JavaTypes;\n-import org.apache.openjpa.meta.MetaDataModes;\n-import org.apache.openjpa.util.MetaDataException;\n-import serp.util.Strings;\n-\n-/**\n- * Mapping of a query result set to scalar and/or persistence-capable\n- * object-level values.\n- *\n- * @author Pinaki Poddar\n- * @author Abe White\n- */\n-public class QueryResultMapping\n-    implements MetaDataModes, SourceTracker, Commentable {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (QueryResultMapping.class);\n-\n-    private final String _name;\n-    private final MappingRepository _repos;\n-    private File _file = null;\n-    private Object _scope = null;\n-    private int _srcType = SRC_OTHER;\n-    private int _lineNum = 0;  \n-    private int _colNum = 0;  \n-    private int _mode = MODE_QUERY;\n-    private Class _class = null;\n-    private int _idx = 0;\n-    private String[] _comments = null;\n-    private List _colList = null;\n-    private List _pcList = null;\n-\n-    private PCResult[] _pcs = null;\n-    private Object[] _cols = null;\n-\n-    /**\n-     * Construct with the given name.\n-     */\n-    QueryResultMapping(String name, MappingRepository repos) {\n-        _name = name;\n-        _repos = repos;\n-    }\n-\n-    /**\n-     * Return the name for this query result.\n-     */\n-    public String getName() {\n-        return _name;\n-    }\n-\n-    /**\n-     * The class that defines this query result, or null if none.\n-     */\n-    public Class getDefiningType() {\n-        return _class;\n-    }\n-\n-    /**\n-     * The class that defines this query result, or null if none.\n-     */\n-    public void setDefiningType(Class cls) {\n-        _class = cls;\n-    }\n-\n-    /**\n-     * Ids of mapped scalar columns in the result. These will typically be\n-     * column names.\n-     *\n-     * @see org.apache.openjpa.jdbc.sql.Result\n-     */\n-    public Object[] getColumnResults() {\n-        if (_cols == null) {\n-            Object[] cols;\n-            if (_colList == null)\n-                cols = new Object[0];\n-            else\n-                cols = _colList.toArray();\n-            _cols = cols;\n-        }\n-        return _cols;\n-    }\n-\n-    /**\n-     * Add the id of a mapped column in the query result. This will typically\n-     * be a column name.\n-     *\n-     * @see org.apache.openjpa.jdbc.sql.Result\n-     */\n-    public void addColumnResult(Object id) {\n-        _cols = null;\n-        if (_colList == null)\n-            _colList = new ArrayList();\n-        _colList.add(id);\n-    }\n-\n-    /**\n-     * Return the mapped persistence-capable types in the query result.\n-     */\n-    public PCResult[] getPCResults() {\n-        if (_pcs == null) {\n-            PCResult[] pcs;\n-            if (_pcList == null)\n-                pcs = new PCResult[0];\n-            else\n-                pcs = (PCResult[]) _pcList.toArray\n-                    (new PCResult[_pcList.size()]);\n-            _pcs = pcs;\n-        }\n-        return _pcs;\n-    }\n-\n-    /**\n-     * Add a mapped persistence-capable result with the given candidate type.\n-     */\n-    public PCResult addPCResult(Class candidate) {\n-        _pcs = null;\n-        PCResult pc = new PCResult(candidate);\n-        if (_pcList == null)\n-            _pcList = new ArrayList();\n-        _pcList.add(pc);\n-        return pc;\n-    }\n-\n-    /**\n-     * The source mode of this query result.\n-     */\n-    public int getSourceMode() {\n-        return _mode;\n-    }\n-\n-    /**\n-     * The source mode of this query result.\n-     */\n-    public void setSourceMode(int mode) {\n-        _mode = mode;\n-    }\n-\n-    /**\n-     * Relative order of result mapping in metadata.\n-     */\n-    public int getListingIndex() {\n-        return _idx;\n-    }\n-\n-    /**\n-     * Relative order of result mapping in metadata.\n-     */\n-    public void setListingIndex(int idx) {\n-        _idx = idx;\n-    }\n-\n-    public String toString() {\n-        return _name;\n-    }\n-\n-    ///////////////\n-    // Commentable\n-    ///////////////\n-\n-    public String[] getComments() {\n-        return (_comments == null) ? EMPTY_COMMENTS : _comments;\n-    }\n-\n-    public void setComments(String[] comments) {\n-        _comments = comments;\n-    }\n-\n-    ////////////////////////////////\n-    // SourceTracker implementation\n-    ////////////////////////////////\n-\n-    public File getSourceFile() {\n-        return _file;\n-    }\n-\n-    public Object getSourceScope() {\n-        return _scope;\n-    }\n-\n-    public int getSourceType() {\n-        return _srcType;\n-    }\n-\n-    public void setSource(File file, Object scope, int srcType) {\n-        _file = file;\n-        _scope = scope;\n-        _srcType = srcType;\n-    }\n-\n-    public String getResourceName() {\n-        return (_class == null) ? _name : _class.getName() + \":\" + _name;\n-    }\n-    \n-    public int getLineNumber() {\n-        return _lineNum;\n-    }\n-\n-    public void setLineNumber(int lineNum) {\n-        _lineNum = lineNum;\n-    }\n-\n-    public int getColNumber() {\n-        return _colNum;\n-    }\n-\n-    public void setColNumber(int colNum) {\n-        _colNum = colNum;\n-    }\n-\n-    /**\n-     * A persistence-capable result.\n-     */\n-    public class PCResult {\n-\n-        /**\n-         * Path token to represent a discriminator.\n-         */\n-        public static final String DISCRIMINATOR = \"<discriminator>\";\n-\n-        private final Class _candidate;\n-        private ClassMapping _candidateMap = null;\n-        private Map _rawMappings = null; // string->object\n-        private Map _mappings = null; // list->columnmap\n-        private Map _eager = null; // list->fetchinfo\n-        private FetchInfo _fetchInfo = null; // for top-level\n-\n-        /**\n-         * Supply candidate type on construction.\n-         */\n-        private PCResult(Class candidate) {\n-            _candidate = candidate;\n-        }\n-\n-        /**\n-         * The result candidate class.\n-         */\n-        public Class getCandidateType() {\n-            return _candidate;\n-        }\n-\n-        /**\n-         * Candidate mapping.\n-         */\n-        public ClassMapping getCandidateTypeMapping() {\n-            if (_candidateMap == null)\n-                _candidateMap = _repos.getMapping(_candidate, null, true);\n-            return _candidateMap;\n-        }\n-\n-        /**\n-         * Return the raw mapping paths supplied with {@link #addMapping}, or\n-         * empty array if none.\n-         */\n-        public String[] getMappingPaths() {\n-            if (_rawMappings == null)\n-                return new String[0];\n-            Collection keys = _rawMappings.keySet();\n-            return (String[]) keys.toArray(new String[keys.size()]);\n-        }\n-\n-        /**\n-         * Return the mapping id for the given path supplied with\n-         * {@link #addMapping}, or null if none.\n-         */\n-        public Object getMapping(String path) {\n-            return (_rawMappings == null) ? null : _rawMappings.get(path);\n-        }\n-\n-        /**\n-         * Map the given path to the given result id.\n-         */\n-        public void addMapping(String path, Object id) {\n-            if (StringUtils.isEmpty(path))\n-                throw new MetaDataException(_loc.get(\"null-path\",\n-                    QueryResultMapping.this, _candidate));\n-\n-            _mappings = null;\n-            _eager = null;\n-            _fetchInfo = null;\n-            if (_rawMappings == null)\n-                _rawMappings = new HashMap();\n-            _rawMappings.put(path, id);\n-        }\n-\n-        /**\n-         * Map the given request onto a result id.\n-         *\n-         * @param path stack of data requests (see\n-         * {@link org.apache.openjpa.jdbc.sql.Result#startDataRequest})\n-         * @param id requested id or column (see\n-         * {@link org.apache.openjpa.jdbc.sql.Result} APIs)\n-         * @param joins requested joins, or null\n-         * @return the id or column to fetch from the result\n-         * (typically a column name)\n-         */\n-        public Object map(List path, Object id, Joins joins) {\n-            if (_rawMappings == null || !(id instanceof Column))\n-                return id;\n-\n-            resolve();\n-            ColumnMap cm = (ColumnMap) _mappings.get(path);\n-            return (cm == null) ? id : cm.map((Column) id);\n-        }\n-\n-        /**\n-         * Return true if the mapped result contains eager data for the given\n-         * field at the given path.\n-         *\n-         * @param path stack of data requests (see\n-         * {@link org.apache.openjpa.jdbc.sql.Result#startDataRequest})\n-         */\n-        public boolean hasEager(List path, FieldMapping field) {\n-            if (_rawMappings == null)\n-                return false;\n-\n-            resolve();\n-            if (path.isEmpty())\n-                return _fetchInfo.eager.get(field.getIndex());\n-            if (_eager == null)\n-                return false;\n-            FetchInfo info = (FetchInfo) _eager.get(path);\n-            return info != null && info.eager.get(field.getIndex());\n-        }\n-\n-        /**\n-         * Return the field indexes to exclude when loading data for the\n-         * given path.\n-         */\n-        public BitSet getExcludes(List path) {\n-            if (_rawMappings == null)\n-                return null;\n-\n-            resolve();\n-            if (path.isEmpty())\n-                return _fetchInfo.excludes;\n-            if (_eager == null)\n-                return null;\n-            FetchInfo info = (FetchInfo) _eager.get(path);\n-            return (info == null) ? null : info.excludes;\n-        }\n-\n-        /**\n-         * Resolve internal datastructures from raw mappings.\n-         */\n-        private synchronized void resolve() {\n-            if (_rawMappings == null || _mappings != null)\n-                return;\n-\n-            _mappings = new HashMap();\n-            _fetchInfo = new FetchInfo(getCandidateTypeMapping());\n-\n-            Map.Entry entry;\n-            for (Iterator itr = _rawMappings.entrySet().iterator();\n-                itr.hasNext();) {\n-                entry = (Map.Entry) itr.next();\n-                resolveMapping((String) entry.getKey(), entry.getValue());\n-            }\n-        }\n-\n-        /**\n-         * Resolve the given mapping path.\n-         */\n-        private void resolveMapping(String path, Object id) {\n-            // build up path to second-to-last token\n-            String[] tokens = Strings.split(path, \".\", 0);\n-            List rpath = new ArrayList(tokens.length);\n-            ClassMapping candidate = getCandidateTypeMapping();\n-            FieldMapping fm = null;\n-            for (int i = 0; i < tokens.length - 1; i++) {\n-                fm = candidate.getFieldMapping(tokens[i]);\n-                if (fm == null)\n-                    throw new MetaDataException(_loc.get(\"bad-path\",\n-                        QueryResultMapping.this, _candidate, path));\n-\n-                if (fm.getEmbeddedMapping() != null) {\n-                    recordIncluded(candidate, rpath, fm);\n-                    candidate = fm.getEmbeddedMapping();\n-                } else\n-                    candidate = fm.getTypeMapping();\n-                if (candidate == null)\n-                    throw new MetaDataException(_loc.get(\"untraversable-path\",\n-                        QueryResultMapping.this, _candidate, path));\n-                rpath.add(fm);\n-            }\n-\n-            String lastToken = tokens[tokens.length - 1];\n-            if (DISCRIMINATOR.equals(lastToken)) {\n-                Discriminator discrim = candidate.getDiscriminator();\n-                rpath.add(discrim);\n-                assertSingleColumn(discrim.getColumns(), path);\n-                _mappings.put(rpath, new SingleColumnMap(id));\n-            } else {\n-                FieldMapping last = candidate.getFieldMapping(lastToken);\n-                if (last == null)\n-                    throw new MetaDataException(_loc.get(\"untraversable-path\",\n-                        QueryResultMapping.this, _candidate, path));\n-                Column[] cols = last.getColumns();\n-                assertSingleColumn(cols, path);\n-                Column col = cols[0];\n-                \n-                // special-case oid fields, since path lists supplied for\n-                // them at runtime don't include the embedded fields\n-                if (fm != null && fm.getDeclaredTypeCode() == JavaTypes.OID) {\n-                    addComplexColumnMapping(fm, rpath, col, id);\n-                    return;\n-                }\n-\n-                if (fm != null && fm.getForeignKey() != null) {\n-                    // if the last field is one of the joinables used in the\n-                    // relation's foreign key, map to relation field path.\n-                    // otherwise, record that we have an eager result\n-                    Column fkCol = fm.getForeignKey().getColumn(col);\n-                    if (fkCol != null)\n-                        addComplexColumnMapping(fm, new ArrayList(rpath),\n-                            fkCol, id);\n-                    else {\n-                        recordEager(candidate, rpath, fm);\n-                        recordIncluded(candidate, rpath, last);\n-                    }\n-                } else\n-                    recordIncluded(candidate, rpath, last);\n-\n-                // map to related field path. because the SingleColumnMap\n-                // doesn't test the requested column, it will accept\n-                // requests for both the fk col or the related field col\n-                rpath.add(last);\n-                _mappings.put(rpath, new SingleColumnMap(id));\n-            }\n-        }\n-\n-        /**\n-         * Create an appropriate column mapping for the given field.\n-         */\n-        private void addComplexColumnMapping(FieldMapping fm, List rpath,\n-            Column col, Object id) {\n-            if (fm.getColumns().length == 1)\n-                _mappings.put(rpath, new SingleColumnMap(id));\n-            else {\n-                MultiColumnMap mcm = (MultiColumnMap) _mappings.get(rpath);\n-                if (mcm == null) {\n-                    mcm = new MultiColumnMap(fm.getColumns());\n-                    _mappings.put(rpath, mcm);\n-                }\n-                mcm.set(col, id);\n-            }\n-        }\n-\n-        /**\n-         * For now, we only allow mappings with a single column. In the\n-         * future we might introduce a syntax to map multiple columns.\n-         */\n-        private void assertSingleColumn(Column[] cols, String path) {\n-            if (cols.length != 1)\n-                throw new MetaDataException(_loc.get(\"num-cols-path\",\n-                    QueryResultMapping.this, _candidate, path));\n-        }\n-\n-        /**\n-         * Record that there may be eager data for the given field at the given\n-         * path.\n-         */\n-        private void recordEager(ClassMapping candidate, List path,\n-            FieldMapping fm) {\n-            if (path.size() == 1) {\n-                _fetchInfo.eager.set(fm.getIndex());\n-                _fetchInfo.excludes.clear(fm.getIndex());\n-            } else {\n-                // record at previous path\n-                List copy = new ArrayList(path.size() - 1);\n-                for (int i = 0; i < copy.size(); i++)\n-                    copy.add(path.get(i));\n-\n-                if (_eager == null)\n-                    _eager = new HashMap();\n-                FetchInfo info = (FetchInfo) _eager.get(copy);\n-                if (info == null) {\n-                    info = new FetchInfo(candidate);\n-                    _eager.put(copy, info);\n-                }\n-                info.eager.set(fm.getIndex());\n-                info.excludes.clear(fm.getIndex());\n-            }\n-        }\n-\n-        /**\n-         * Record that the field at the given path is included in the results.\n-         */\n-        private void recordIncluded(ClassMapping candidate, List path,\n-            FieldMapping fm) {\n-            if (path.isEmpty())\n-                _fetchInfo.excludes.clear(fm.getIndex());\n-            else {\n-                if (_eager == null)\n-                    _eager = new HashMap();\n-                FetchInfo info = (FetchInfo) _eager.get(path);\n-                if (info == null) {\n-                    info = new FetchInfo(candidate);\n-                    _eager.put(new ArrayList(path), info);\n-                }\n-                info.excludes.clear(fm.getIndex());\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Fetch information.\n-     */\n-    private static class FetchInfo {\n-\n-        /**\n-         * Indexes of fields to exclude from loading.\n-         */\n-        public final BitSet excludes;\n-\n-        /**\n-         * Indexes of eager fields.\n-         */\n-        public final BitSet eager;\n-\n-        public FetchInfo(ClassMapping type) {\n-            FieldMapping[] fms = type.getFieldMappings();\n-            eager = new BitSet(fms.length);\n-            excludes = new BitSet(fms.length);\n-            for (int i = 0; i < fms.length; i++)\n-                if (!fms[i].isPrimaryKey())\n-                    excludes.set(i);\n-        }\n-    }\n-\n-    /**\n-     * Mapping of columns to result ids.\n-     */\n-    private static interface ColumnMap {\n-\n-        /**\n-         * Return the result id for the given column, or the given colum\n-         * if none.\n-         */\n-        public Object map(Column col);\n-    }\n-\n-    /**\n-     * {@link ColumnMap} specialized for a single column.\n-     */\n-    private static class SingleColumnMap\n-        implements ColumnMap {\n-\n-        private final Object _id;\n-\n-        public SingleColumnMap(Object id) {\n-            _id = id;\n-        }\n-\n-        public Object map(Column col) {\n-            return _id;\n-        }\n-\n-        public String toString() {\n-            return _id.toString();\n-        }\n-    }\n-\n-    /**\n-     * {@link ColumnMap} specialized for a multiple columns.\n-     * Maps columns in linear time.\n-     */\n-    private static class MultiColumnMap\n-        implements ColumnMap {\n-\n-        private final List _cols;\n-        private final Object[] _ids;\n-\n-        public MultiColumnMap(Column[] cols) {\n-            _cols = Arrays.asList(cols);\n-            _ids = new Object[cols.length];\n-        }\n-\n-        public Object map(Column col) {\n-            int idx = _cols.indexOf(col);\n-            return (idx == -1) ? col : _ids[idx];\n-        }\n-\n-        public void set(Column col, Object id) {\n-            int idx = _cols.indexOf(col);\n-            if (idx != -1)\n-                _ids[idx] = id;\n-        }\n-\n-        public String toString() {\n-            return _cols + \"=\" + Arrays.asList(_ids);\n-        }\n-    }\n-}"},{"sha":"5c5edff2657983d69e124c2a0556895c3d4b818d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RefreshStrategyInstaller.java","status":"removed","additions":0,"deletions":138,"changes":138,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RefreshStrategyInstaller.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RefreshStrategyInstaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RefreshStrategyInstaller.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,138 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.util.MetaDataException;\n-\n-/**\n- * Attempts to install using the given mapping information. If that\n- * fails, clears the mapping information and constructs new mappings.\n- *\n- * @author Abe White\n- * @nojavadoc\n- * @since 0.4.0\n- */\n-public class RefreshStrategyInstaller\n-    extends StrategyInstaller {\n-\n-    private static final Localizer _loc = Localizer.forPackage\n-        (RefreshStrategyInstaller.class);\n-\n-    /**\n-     * Constructor; supply configuration.\n-     */\n-    public RefreshStrategyInstaller(MappingRepository repos) {\n-        super(repos);\n-    }\n-\n-    public boolean isAdapting() {\n-        return true;\n-    }\n-\n-    public void installStrategy(ClassMapping cls) {\n-        ClassStrategy strat = repos.namedStrategy(cls);\n-        if (strat == null)\n-            strat = repos.defaultStrategy(cls, true);\n-        try {\n-            cls.setStrategy(strat, Boolean.TRUE);\n-        } catch (MetaDataException mde) {\n-            // if this is a custom strategy, don't attempt to override\n-            if (isCustomStrategy(strat))\n-                throw mde;\n-\n-            repos.getLog().warn(_loc.get(\"fatal-change\", cls,\n-                mde.getMessage()));\n-            cls.clearMapping();\n-            cls.setStrategy(repos.defaultStrategy(cls, true), Boolean.TRUE);\n-        }\n-        cls.setSourceMode(cls.MODE_MAPPING, true);\n-    }\n-\n-    public void installStrategy(FieldMapping field) {\n-        FieldStrategy strategy = repos.namedStrategy(field, true);\n-        if (strategy == null)\n-            strategy = repos.defaultStrategy(field, true, true);\n-        try {\n-            field.setStrategy(strategy, Boolean.TRUE);\n-        } catch (MetaDataException mde) {\n-            // if this is a custom strategy, don't override\n-            if (isCustomStrategy(strategy))\n-                throw mde;\n-\n-            repos.getLog().warn(_loc.get(\"fatal-change\", field,\n-                mde.getMessage()));\n-            field.clearMapping();\n-            field.setHandler(null);\n-            field.getKeyMapping().setHandler(null);\n-            field.getElementMapping().setHandler(null);\n-            field.setStrategy(repos.defaultStrategy(field, true, true),\n-                Boolean.TRUE);\n-        }\n-    }\n-\n-    public void installStrategy(Version version) {\n-        VersionStrategy strat = repos.namedStrategy(version);\n-        if (strat == null)\n-            strat = repos.defaultStrategy(version, true);\n-        try {\n-            version.setStrategy(strat, Boolean.TRUE);\n-        } catch (MetaDataException mde) {\n-            // if this is a custom strategy, don't attempt to override\n-            if (isCustomStrategy(strat))\n-                throw mde;\n-\n-            repos.getLog().warn(_loc.get(\"fatal-change\", version,\n-                mde.getMessage()));\n-            version.clearMapping();\n-            version.setStrategy(repos.defaultStrategy(version, true),\n-                Boolean.TRUE);\n-        }\n-    }\n-\n-    public void installStrategy(Discriminator discrim) {\n-        DiscriminatorStrategy strat = repos.namedStrategy(discrim);\n-        if (strat == null)\n-            strat = repos.defaultStrategy(discrim, true);\n-        try {\n-            discrim.setStrategy(strat, Boolean.TRUE);\n-        } catch (MetaDataException mde) {\n-            // if this is a custom strategy, don't attempt to override\n-            if (isCustomStrategy(strat))\n-                throw mde;\n-\n-            repos.getLog().warn(_loc.get(\"fatal-change\", discrim,\n-                mde.getMessage()));\n-\n-            // retain old discriminator version, if any\n-            String val = discrim.getMappingInfo().getValue();\n-            discrim.clearMapping();\n-            discrim.getMappingInfo().setValue(val);\n-            discrim.setStrategy(repos.defaultStrategy(discrim, true),\n-                Boolean.TRUE);\n-        }\n-    }\n-\n-    /**\n-     * Return true if the given strategy is not a built-in type.\n-     */\n-    private static boolean isCustomStrategy(Strategy strat) {\n-        return !strat.getClass().getName().startsWith(\"org.apache.openjpa.\");\n-    }\n-}"},{"sha":"80c09f5b177e72468b479cb343b5429720bb737a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RelationId.java","status":"removed","additions":0,"deletions":38,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RelationId.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RelationId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RelationId.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,38 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\n-\n-/**\n- * Callback to store a relation after the object id has been assigned.\n- *\n- * @author Abe White\n- * @since 0.4.0\n- */\n-public interface RelationId {\n-\n-    /**\n-     * Return the serialized value for the given related object, now that\n-     * its id has been assigned.\n-     */\n-    public Object toRelationDataStoreValue(OpenJPAStateManager sm, Column col);\n-}\n-"},{"sha":"5780172a74aa58bb00120352b63aec8c74e84a3f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseCustomizer.java","status":"removed","additions":0,"deletions":163,"changes":163,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseCustomizer.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseCustomizer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseCustomizer.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -1,163 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.    \n- */\n-package org.apache.openjpa.jdbc.meta;\n-\n-import java.util.Properties;\n-\n-import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\n-import org.apache.openjpa.jdbc.schema.Table;\n-import org.apache.openjpa.lib.util.Closeable;\n-\n-/**\n- * Plugin in interface to customize the output of the\n- * {@link ReverseMappingTool}.\n- *\n- * @author Abe White\n- */\n-public interface ReverseCustomizer\n-    extends Closeable {\n-\n-    /**\n-     * Set configuration properties given by the user.\n-     */\n-    public void setConfiguration(Properties props);\n-\n-    /**\n-     * Set the reverse mapping tool using this customizer. You can use\n-     * the tool to see how it is configured, or to use utility methods the\n-     * tool provides.\n-     */\n-    public void setTool(ReverseMappingTool tool);\n-\n-    /**\n-     * Return the type of the given table, or the given default type.\n-     * See the TABLE_XXX constants in {@link ReverseMappingTool}.\n-     */\n-    public int getTableType(Table table, int defaultType);\n-\n-    /**\n-     * Return the fully-qualified class name to generate for the given table.\n-     * Return null to prevent the table from being mapped. Return the given\n-     * default name if it is acceptable.\n-     */\n-    public String getClassName(Table table, String defaultName);\n-\n-    /**\n-     * Customize the given class information produced by the reverse mapping\n-     * tool. To change the application identity class, use\n-     * {@link ReverseMappingTool#generateClass} to creat the new class object.\n-     * The class will not have any fields at the time of this call.\n-     */\n-    public void customize(ClassMapping cls);\n-\n-    /**\n-     * Return a code template for the given class, or null to use the standard\n-     * system-generated Java code. To facilitate template reuse, the\n-     * following parameters can appear in your template; the proper values\n-     * will be subtituted by the system:\n-     * <ul>\n-     * <li>${packageDec}: The package declaration, in the form\n-     * \"package &lt;package name &gt;;\", or empty string if no package.</li>\n-     * <li>${imports}: Imports for the packages used by the declared\n-     * field types.</li>\n-     * <li>${className}: The name of the class, without package.</li>\n-     * <li>${extendsDec}: Extends declaration, in the form\n-     * \"extends &lt;superclass&gt;\", or empty string if no superclass.</li>\n-     * <li>${constructor}: A constructor that takes in all primary key fields\n-     * of the class, or empty string if the class uses datastore identity.</li>\n-     * <li>${fieldDecs}: Declarations of all the generated fields.</li>\n-     * <li>${fieldCode}: Get/set methods for all the generated fields.</li>\n-     * </ul>\n-     */\n-    public String getClassCode(ClassMapping mapping);\n-\n-    /**\n-     * Return the field name used to map the given columns, or null to prevent\n-     * the columns from being mapped. Return the given default if it is\n-     * acceptable.\n-     *\n-     * @param dec the class that will declare this field\n-     * @param cols the column(s) this field will represent\n-     * @param fk for relation fields, the foreign key to the related type\n-     */\n-    public String getFieldName(ClassMapping dec, Column[] cols, ForeignKey fk,\n-        String defaultName);\n-\n-    /**\n-     * Customize the given field information produced by the reverse mapping\n-     * tool.\n-     */\n-    public void customize(FieldMapping field);\n-\n-    /**\n-     * Return code for the initial value for the given field, or null to use\n-     * the default generated by the system.\n-     */\n-    public String getInitialValue(FieldMapping field);\n-\n-    /**\n-     * Return a code template for the declaration of the given field, or null\n-     * to use the system-generated default Java code.\n-     * To facilitate template reuse, the following parameters can appear in\n-     * your template; the proper values will be subtituted by the system:\n-     * <ul>\n-     * <li>${fieldName}: The name of the field.</li>\n-     * <li>${capFieldName}: The capitalized field name.</li>\n-     * <li>${propertyName}: The field name without leading '_', if any.</li>\n-     * <li>${fieldType}: The field's type name.</li>\n-     * <li>${fieldValue}: The field's initial value, in the form\n-     * \" = &lt;value&gt;\", or empty string if none.</li>\n-     * </ul>\n-     */\n-    public String getDeclaration(FieldMapping field);\n-\n-    /**\n-     * Return a code template for the get/set methods of the given field, or\n-     * null to use the system-generated default Java code.\n-     * To facilitate template reuse, the following parameters can appear in\n-     * your template; the proper values will be subtituted by the system:\n-     * <ul>\n-     * <li>${fieldName}: The name of the field.</li>\n-     * <li>${capFieldName}: The capitalized field name.</li>\n-     * <li>${propertyName}: The field name without leading '_', if any.</li>\n-     * <li>${fieldType}: The field's type name.</li>\n-     * <li>${fieldValue}: The field's initial value, in the form\n-     * \"= &lt;value&gt;\", or empty string if none.</li>\n-     * </ul>\n-     */\n-    public String getFieldCode(FieldMapping field);\n-\n-    /**\n-     * Notification that a table has gone unmapped. You can map the table\n-     * yourself using this method. When mapping, use\n-     * {@link ReverseMappingTool#generateClass} to create the class,\n-     * {@link ReverseMappingTool#newClassMapping} to create the class metadata,\n-     * and then {@link ClassMapping#addDeclaredFieldMapping} to add field\n-     * metadata.\n-     *\n-     * @return true if you map the table, false otherwise\n-     */\n-    public boolean unmappedTable(Table table);\n-\n-    /**\n-     * Invoked when the customizer is no longer needed.\n-     */\n-    public void close();\n-}"},{"sha":"c418bcebfbe8c5a71f05f220bee62691b321a593","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseMappingTool.java","status":"removed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseMappingTool.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseMappingTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseMappingTool.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"425ed86cb004e716e303912f94d0e756b1dc6af1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RuntimeStrategyInstaller.java","status":"removed","additions":0,"deletions":96,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RuntimeStrategyInstaller.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RuntimeStrategyInstaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/RuntimeStrategyInstaller.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"981d4ae060957632b7e4b17704e982f48591dab0","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/SequenceMapping.java","status":"removed","additions":0,"deletions":173,"changes":173,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/SequenceMapping.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/SequenceMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/SequenceMapping.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"62a6989042c22af681d480a6384f312941c5838d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Strategy.java","status":"removed","additions":0,"deletions":136,"changes":136,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Strategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Strategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Strategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8dd43c50c24b1e146f557236612655b0bfba13c1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/StrategyInstaller.java","status":"removed","additions":0,"deletions":69,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/StrategyInstaller.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/StrategyInstaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/StrategyInstaller.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"11e3c54316098f6a2aa36a700153f5ca27407c98","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueHandler.java","status":"removed","additions":0,"deletions":104,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueHandler.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"e5330cdc16941de83acb16cba802aac02112f78e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMapping.java","status":"removed","additions":0,"deletions":269,"changes":269,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMapping.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMapping.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"17f396bb30c16603a7b0ffd9f7092a41687dbff5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingImpl.java","status":"removed","additions":0,"deletions":544,"changes":544,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"4807bb52f65f89185ce8b65e89d94188166deed6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingInfo.java","status":"removed","additions":0,"deletions":321,"changes":321,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingInfo.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7a60a2d72c1179e8f6993d8ffaf9a33fb1baf868","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Version.java","status":"removed","additions":0,"deletions":379,"changes":379,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Version.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Version.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Version.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"709f07ab1527eedbe3ee7e4aa54d9a7221fbe016","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionMappingInfo.java","status":"removed","additions":0,"deletions":89,"changes":89,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionMappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionMappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionMappingInfo.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"425e44c01bff5f8aa33e25e30571c3107b95b076","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionStrategy.java","status":"removed","additions":0,"deletions":87,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"154094cb24a360f273f7ea35b2d6ae898856e300","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/package.html","status":"removed","additions":0,"deletions":28,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/package.html","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/package.html?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"db60cbdf5b828681227879e170e25b83376fae86","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractClassStrategy.java","status":"removed","additions":0,"deletions":82,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractClassStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"0b9973a8f4559596d82c1b37ef028dea6a35dd7b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractDiscriminatorStrategy.java","status":"removed","additions":0,"deletions":96,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractDiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractDiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractDiscriminatorStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"49e168d0e8255b762c896113942a049deb37ead7","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractFieldStrategy.java","status":"removed","additions":0,"deletions":176,"changes":176,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"016d3898961c049cc9506d095b377be62d828c5e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractStrategy.java","status":"removed","additions":0,"deletions":81,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b75d31b98d05f6cf1d1609e26fe809b7b914796d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractValueHandler.java","status":"removed","additions":0,"deletions":61,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractValueHandler.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"426e2231e6455653e549182416dd597a1497cb69","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractVersionStrategy.java","status":"removed","additions":0,"deletions":77,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/AbstractVersionStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7f8b29a7531e61c0f9131b9609b6cde5da95a97f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/BlobValueHandler.java","status":"removed","additions":0,"deletions":51,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/BlobValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/BlobValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/BlobValueHandler.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"1b163561cf5de6ae80dbaaa66a48e671b7c108a6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ByteArrayValueHandler.java","status":"removed","additions":0,"deletions":62,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ByteArrayValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ByteArrayValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ByteArrayValueHandler.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b85c93cef537f7768a7723c965e58401b23b26fb","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayStreamValueHandler.java","status":"removed","additions":0,"deletions":83,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayStreamValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayStreamValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayStreamValueHandler.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"30d1360c37c95f82dcafae82fa8f7a67dde2aad6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayValueHandler.java","status":"removed","additions":0,"deletions":66,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayValueHandler.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"2b9cac70295c76a4e213cfcc668ce98bbd80f1a4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClassNameDiscriminatorStrategy.java","status":"removed","additions":0,"deletions":127,"changes":127,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClassNameDiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClassNameDiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClassNameDiscriminatorStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"ea4a0ef72b5991b6bd1e386ccb1f61ddae81e9d1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClobValueHandler.java","status":"removed","additions":0,"deletions":51,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClobValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClobValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClobValueHandler.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b23c9164989350068e7e9d6b9318b7cd922e2ed4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ColumnVersionStrategy.java","status":"removed","additions":0,"deletions":270,"changes":270,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ColumnVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ColumnVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ColumnVersionStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"617ac6c064a8e106c2f3406dfe0e896caa8b0ca0","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ContainerFieldStrategy.java","status":"removed","additions":0,"deletions":133,"changes":133,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ContainerFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ContainerFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ContainerFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"be1449419d0cf0aa5e559df818b3050ba3d64820","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java","status":"removed","additions":0,"deletions":183,"changes":183,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"57232a4bc772ea16b0d5bdd503b91afe1177d629","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedFieldStrategy.java","status":"removed","additions":0,"deletions":1584,"changes":1584,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"60cfbb54bed4a0eee8fd34718a7218f97f0c9d3b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedValueHandler.java","status":"removed","additions":0,"deletions":172,"changes":172,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedValueHandler.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"f46c5454f87a24c5aac32ef570f0a5d8036bf41f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbeddedClassStrategy.java","status":"removed","additions":0,"deletions":95,"changes":95,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbeddedClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbeddedClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbeddedClassStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"4d2cf63d6190ff0ce877b670c3ebb3ad141d04f4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EnumValueHandler.java","status":"removed","additions":0,"deletions":103,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EnumValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EnumValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EnumValueHandler.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3b0e012cc531c0e37a2e49eb09db06c2ed9ebc15","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FlatClassStrategy.java","status":"removed","additions":0,"deletions":68,"changes":68,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FlatClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FlatClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FlatClassStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d39d24c6216f5fdc985f8f54390fb89dbcfb794e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FullClassStrategy.java","status":"removed","additions":0,"deletions":137,"changes":137,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FullClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FullClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FullClassStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"21861e4509dfc3a3c36072592b3c5cd03e834767","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java","status":"removed","additions":0,"deletions":250,"changes":250,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"ef1aceeba0814aa5fd9a0fe8de9d5d4764f6c1c1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerFieldStrategy.java","status":"removed","additions":0,"deletions":418,"changes":418,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"e7859a2c4dcf9600b45aebb58e0af1584b12b435","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","status":"removed","additions":0,"deletions":246,"changes":246,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"a931b4c0c85a92ea3551190ba2be7a1583c7670b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","status":"removed","additions":0,"deletions":315,"changes":315,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"12f04c3752ca424fa2453185af23d749cff88e57","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerStrategies.java","status":"removed","additions":0,"deletions":272,"changes":272,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerStrategies.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerStrategies.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerStrategies.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"fdb04ec24f89d6011804c77634022e5a71cb7ad4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/IdentityJoinable.java","status":"removed","additions":0,"deletions":87,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/IdentityJoinable.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/IdentityJoinable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/IdentityJoinable.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"ce3293ba2bca061036489f81f0077fc1203cb924","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ImmutableValueHandler.java","status":"removed","additions":0,"deletions":98,"changes":98,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ImmutableValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ImmutableValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ImmutableValueHandler.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d105060dd0197b49187204efa192ac67b30e4b5c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/InValueDiscriminatorStrategy.java","status":"removed","additions":0,"deletions":163,"changes":163,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/InValueDiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/InValueDiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/InValueDiscriminatorStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"99440396b0afbc25bf7e416e6e1f6bcd1b9d10fd","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSCollectionFieldStrategy.java","status":"removed","additions":0,"deletions":99,"changes":99,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSCollectionFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSCollectionFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSCollectionFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"2af54a93779840b952156fa5192d2d1dda9f8863","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSMapFieldStrategy.java","status":"removed","additions":0,"deletions":152,"changes":152,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSMapFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSMapFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSMapFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"a4af5d31ee9f321bc0a95d420f783d43df99e12b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSProxyCollection.java","status":"removed","additions":0,"deletions":232,"changes":232,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSProxyCollection.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSProxyCollection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSProxyCollection.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"67dcc15753be22610c54bf6ed162ac8b3a1f691a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSProxyMap.java","status":"removed","additions":0,"deletions":423,"changes":423,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSProxyMap.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSProxyMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LRSProxyMap.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"9a1a0ad24cb6e5cea86dc0c8e12d647e9c7500cc","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java","status":"removed","additions":0,"deletions":219,"changes":219,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"4a7598ebce12af810eb381f79eea1f79d65a1193","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","status":"removed","additions":0,"deletions":176,"changes":176,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7eda87247d162f52552f46708491b6a890b6948e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedBlobFieldStrategy.java","status":"removed","additions":0,"deletions":107,"changes":107,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedBlobFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedBlobFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedBlobFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"988bcf98d294cb06b83c4a284208336aae6f7e88","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedByteArrayFieldStrategy.java","status":"removed","additions":0,"deletions":96,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedByteArrayFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedByteArrayFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedByteArrayFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"16e962cefc9839ea432ef4b3148c2c341a757088","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedCharArrayFieldStrategy.java","status":"removed","additions":0,"deletions":113,"changes":113,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedCharArrayFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedCharArrayFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedCharArrayFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"9982c921c277e66c989d58061fa02f1f87c9587b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedClobFieldStrategy.java","status":"removed","additions":0,"deletions":83,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedClobFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedClobFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedClobFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"e5cf3a6b335b2ffaa2a1807f5bf6e9642fd68600","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedLobFieldStrategy.java","status":"removed","additions":0,"deletions":262,"changes":262,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedLobFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedLobFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedLobFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"89ba3c5835c489508db8409058b4afde830a0f48","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NanoPrecisionTimestampVersionStrategy.java","status":"removed","additions":0,"deletions":41,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NanoPrecisionTimestampVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NanoPrecisionTimestampVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NanoPrecisionTimestampVersionStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"604f11b0f4c7167b40359f3f3cb199e098327f9e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneClassStrategy.java","status":"removed","additions":0,"deletions":89,"changes":89,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneClassStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8c6c0e2b3295175383b385f2e7ae985c9e7f39df","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneDiscriminatorStrategy.java","status":"removed","additions":0,"deletions":58,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneDiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneDiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneDiscriminatorStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"a6dd310abb8031fbf743f5ba6e314cd3eeb7fb1b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneFieldStrategy.java","status":"removed","additions":0,"deletions":54,"changes":54,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8b5d47947ad2b68321bf252235da9e327ea162ec","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneVersionStrategy.java","status":"removed","additions":0,"deletions":55,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NoneVersionStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"2f2d8e22448c00003eb3a22259e6a63eb3a834d0","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NumberVersionStrategy.java","status":"removed","additions":0,"deletions":75,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NumberVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NumberVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NumberVersionStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"73db5a88d6f56f1a86500bdd06c5472a59992a63","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdClassStrategy.java","status":"removed","additions":0,"deletions":49,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdClassStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"90174635c2ebd44e6bd132c0d6d8c8748163db54","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdValueHandler.java","status":"removed","additions":0,"deletions":84,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdValueHandler.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"f2e8ec6f17b50616056d867e3c8a684c834f78d8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveFieldStrategy.java","status":"removed","additions":0,"deletions":403,"changes":403,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"61aa40a2a44ebce75c687aefc82ec4236d7f2953","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveWrapperArrays.java","status":"removed","additions":0,"deletions":88,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveWrapperArrays.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveWrapperArrays.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveWrapperArrays.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"5320940be2281483c7a73f1584327dc13afc75eb","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationCollectionInverseKeyFieldStrategy.java","status":"removed","additions":0,"deletions":97,"changes":97,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationCollectionInverseKeyFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationCollectionInverseKeyFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationCollectionInverseKeyFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"518dd32e1646250705b91676a9759128da21d105","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationCollectionTableFieldStrategy.java","status":"removed","additions":0,"deletions":96,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationCollectionTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationCollectionTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationCollectionTableFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"5980871a5c8a73888eeb05c339d3bc7068c181c9","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","status":"removed","additions":0,"deletions":985,"changes":985,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"cc2c1eb5834beda96e35fb9a77cf0431b4710493","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationHandlerMapTableFieldStrategy.java","status":"removed","additions":0,"deletions":290,"changes":290,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationHandlerMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationHandlerMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationHandlerMapTableFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"9ed5caf9158059123979ceebe985e43561969dc1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationMapInverseKeyFieldStrategy.java","status":"removed","additions":0,"deletions":170,"changes":170,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationMapInverseKeyFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationMapInverseKeyFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationMapInverseKeyFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3c50a40549018a0dbcdaa946d9ccc094ccf5d8db","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationMapTableFieldStrategy.java","status":"removed","additions":0,"deletions":170,"changes":170,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationMapTableFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"60770b6cfeb3ecb2f617e29636c7aa95c7ba0261","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","status":"removed","additions":0,"deletions":375,"changes":375,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"51db4ca39c5b7c7ac3228858a2bd246faeb477ee","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationStrategies.java","status":"removed","additions":0,"deletions":218,"changes":218,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationStrategies.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationStrategies.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationStrategies.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7a3bec02fece2146ec986ca18ab01c0eb8880fe9","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyInverseKeyFieldStrategy.java","status":"removed","additions":0,"deletions":349,"changes":349,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyInverseKeyFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyInverseKeyFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyInverseKeyFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"4cf621b5107c7613b91ee3466f45e84dc650c2aa","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyTableFieldStrategy.java","status":"removed","additions":0,"deletions":270,"changes":270,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationToManyTableFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"e71657c527172a9cd38341052f862e331a9f6acf","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StateComparisonVersionStrategy.java","status":"removed","additions":0,"deletions":330,"changes":330,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StateComparisonVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StateComparisonVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StateComparisonVersionStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"52a72d33dd1edb81eaf76f7164deafe7fad7021b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StoreCollectionFieldStrategy.java","status":"removed","additions":0,"deletions":603,"changes":603,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StoreCollectionFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StoreCollectionFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StoreCollectionFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b55f70924e22d06d4feed54028c3838943dc8aef","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StringFieldStrategy.java","status":"removed","additions":0,"deletions":259,"changes":259,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StringFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StringFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StringFieldStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"dea031dcdb2351231965e204615dd36118715157","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SubclassJoinDiscriminatorStrategy.java","status":"removed","additions":0,"deletions":169,"changes":169,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SubclassJoinDiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SubclassJoinDiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SubclassJoinDiscriminatorStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d20d37d01d7d5f013bb08fbbd28a9dc4b632a92f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SuperclassDiscriminatorStrategy.java","status":"removed","additions":0,"deletions":77,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SuperclassDiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SuperclassDiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SuperclassDiscriminatorStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b73e77bb81217f7c4012f38ddf31576c7313ba64","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SuperclassVersionStrategy.java","status":"removed","additions":0,"deletions":57,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SuperclassVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SuperclassVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/SuperclassVersionStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"ed91d13a68a7a4456c393aa41dcb25059e989248","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/TimestampVersionStrategy.java","status":"removed","additions":0,"deletions":59,"changes":59,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/TimestampVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/TimestampVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/TimestampVersionStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"4ae7cdaa5740e2359c64f007204d845b0d8bec7a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/UntypedPCValueHandler.java","status":"removed","additions":0,"deletions":124,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/UntypedPCValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/UntypedPCValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/UntypedPCValueHandler.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"86f8320ffc40bb7c0fe85d5ccd23fe5ed5a6adeb","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ValueMapDiscriminatorStrategy.java","status":"removed","additions":0,"deletions":133,"changes":133,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ValueMapDiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ValueMapDiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ValueMapDiscriminatorStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"fed5b547dc19e34e14d3cb8d4db53d1707d50bdc","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/VerticalClassStrategy.java","status":"removed","additions":0,"deletions":154,"changes":154,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/VerticalClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/VerticalClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/VerticalClassStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7008ec062300ae41a88ab8d1d2b35dea9ff52082","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/XMLValueHandler.java","status":"removed","additions":0,"deletions":96,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/XMLValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/XMLValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/XMLValueHandler.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"85a17bef4ac0d759577d534e75b22133e6c72b11","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/package.html","status":"removed","additions":0,"deletions":27,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/package.html","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/package.html?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"45dedec18f7173217fd4e3fd6d196dcca3f62c5f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Column.java","status":"removed","additions":0,"deletions":749,"changes":749,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Column.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Column.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Column.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"2f181c7195148cc39b4a2c3545cf450f66b2c534","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ColumnIO.java","status":"removed","additions":0,"deletions":308,"changes":308,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ColumnIO.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ColumnIO.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ColumnIO.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3a6e7e6af3405f0019a6b0941e5ef7698c094252","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Constraint.java","status":"removed","additions":0,"deletions":188,"changes":188,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Constraint.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Constraint.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Constraint.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"90f5ae93be1031d13b5840e7a1c76e0eec0a043b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DataSourceFactory.java","status":"removed","additions":0,"deletions":313,"changes":313,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DataSourceFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DataSourceFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DataSourceFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"f25f2ff0b16a09b14e35388f91399ba830becbbf","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DriverDataSource.java","status":"removed","additions":0,"deletions":111,"changes":111,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DriverDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DriverDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DriverDataSource.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"eb19597b5dd22f743d5acde372176bcbac7d3ec0","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DynamicSchemaFactory.java","status":"removed","additions":0,"deletions":151,"changes":151,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DynamicSchemaFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DynamicSchemaFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DynamicSchemaFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"88fae0ba52427678f9e6bba0226f2ffe7fb95bcb","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/FileSchemaFactory.java","status":"removed","additions":0,"deletions":106,"changes":106,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/FileSchemaFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/FileSchemaFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/FileSchemaFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"40df305eadc2f9951ba53d02b66afaed44acc9cc","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","status":"removed","additions":0,"deletions":741,"changes":741,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"86433c0a61cf9dee8319a758a5202dde7777adf2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Index.java","status":"removed","additions":0,"deletions":85,"changes":85,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Index.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Index.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Index.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"e531408cf53588dc1fe6e9d2d505773758333580","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LazySchemaFactory.java","status":"removed","additions":0,"deletions":194,"changes":194,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LazySchemaFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LazySchemaFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LazySchemaFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"57f0a74a29bedb386443f0587152bd3236886c1d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LocalConstraint.java","status":"removed","additions":0,"deletions":187,"changes":187,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LocalConstraint.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LocalConstraint.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LocalConstraint.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"a3cc7c2a64ab75710358c8267c57110185fcb840","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/NameSet.java","status":"removed","additions":0,"deletions":80,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/NameSet.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/NameSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/NameSet.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"9d66d3cb2c1c9102457d4b2b423ea7f33685ca5c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/PrimaryKey.java","status":"removed","additions":0,"deletions":85,"changes":85,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/PrimaryKey.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/PrimaryKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/PrimaryKey.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b355ce0fb8ae592d87d19bb78a8c6a6a4f6d5b12","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ReferenceCounter.java","status":"removed","additions":0,"deletions":45,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ReferenceCounter.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ReferenceCounter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ReferenceCounter.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"490fd4179de36223c25d6117dc31f501d71ea01c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schema.java","status":"removed","additions":0,"deletions":263,"changes":263,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schema.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schema.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schema.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"46e8b82cbdd32812653a4b7e22378aa30a81d2ad","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaFactory.java","status":"removed","additions":0,"deletions":42,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"f7c0b40483f84333c9f32a4efad32ae7fc939a58","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java","status":"removed","additions":0,"deletions":942,"changes":942,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"a5d7fd3f3deb485ad9caf1df1db0183492d8a3d6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGroup.java","status":"removed","additions":0,"deletions":468,"changes":468,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGroup.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGroup.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGroup.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"e3ef0b6bd50638b5f84a70976eba868f989a2011","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaParser.java","status":"removed","additions":0,"deletions":65,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaParser.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaParser.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"f7a11d9d6a94fb090b9d0ad19a82bf905e41423e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaSerializer.java","status":"removed","additions":0,"deletions":81,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaSerializer.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"e500de0977fbc8df1612135fe648fc2d77a0fa6b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java","status":"removed","additions":0,"deletions":1527,"changes":1527,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"dab4f1c60571df68d20b2e3fa9485d533440e03c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schemas.java","status":"removed","additions":0,"deletions":235,"changes":235,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schemas.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schemas.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schemas.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"cde443b99b0e04c8cbaafbb0f7040e93f3967d61","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Sequence.java","status":"removed","additions":0,"deletions":227,"changes":227,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Sequence.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Sequence.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Sequence.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"06a82cb26f92bb0741b5243ec59c0ab0fb87fdd5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SimpleDriverDataSource.java","status":"removed","additions":0,"deletions":199,"changes":199,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SimpleDriverDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SimpleDriverDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SimpleDriverDataSource.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"1f834b9600d9bd0269bbf183a61ff23e75545b69","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java","status":"removed","additions":0,"deletions":739,"changes":739,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"df21bcf4ba369d3f9032fb1906fe84282752055f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/TableSchemaFactory.java","status":"removed","additions":0,"deletions":499,"changes":499,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/TableSchemaFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/TableSchemaFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/TableSchemaFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3c87191435cf79c021b5631ddab5578b2e16e48f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Unique.java","status":"removed","additions":0,"deletions":124,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Unique.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Unique.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Unique.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c2d293215d9a8a9c20a0ed8f170cc77494caca06","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaParser.java","status":"removed","additions":0,"deletions":618,"changes":618,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaParser.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaParser.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"37dc91d3112f598d1869dc89b97bf55fdfa84a7a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaSerializer.java","status":"removed","additions":0,"deletions":446,"changes":446,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaSerializer.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"6cda3f5014beebb49a87a756d35e59b55af4c73d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/package.html","status":"removed","additions":0,"deletions":34,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/package.html","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/package.html?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"af138d57a1327bb52de4cfa23f0cad144551fa66","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","status":"removed","additions":0,"deletions":125,"changes":125,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"6e6f3edfead2b7735f5ef0ea71b66ba1d827a7f3","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractResult.java","status":"removed","additions":0,"deletions":888,"changes":888,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractResult.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractResult.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractResult.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"fffef75b9f4685038a0cb1f5ef9d1324ab2ffa63","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractSQLServerDictionary.java","status":"removed","additions":0,"deletions":155,"changes":155,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractSQLServerDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractSQLServerDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractSQLServerDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"735c9d499485dce0f6bc6510a893fd6af3ae07f5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AccessDictionary.java","status":"removed","additions":0,"deletions":81,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AccessDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AccessDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AccessDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"87dddb784a3724171533e62e2771f72aa58470f4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/CacheDictionary.java","status":"removed","additions":0,"deletions":45,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/CacheDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/CacheDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/CacheDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"15a2f4d4394fcd0608dd0617766cb6eb55b2435b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Calendard.java","status":"removed","additions":0,"deletions":38,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Calendard.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Calendard.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Calendard.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"69091419f75113f3dfd8e0774d2043abb8d32e9a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","status":"removed","additions":0,"deletions":831,"changes":831,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"ce8f050a6d11685101ebca2d8b0c64b11c03b337","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","status":"removed","additions":0,"deletions":4543,"changes":4543,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"aa67411190c4b9331070eb00bdec2da96cf22575","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionaryFactory.java","status":"removed","additions":0,"deletions":615,"changes":615,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionaryFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionaryFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionaryFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8453fe020408c2453acf6046648eb066572ab5c7","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java","status":"removed","additions":0,"deletions":103,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"4e753881e26aa70350ceea73223483b7a38b8d3a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/EmpressDictionary.java","status":"removed","additions":0,"deletions":174,"changes":174,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/EmpressDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/EmpressDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/EmpressDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3a4ba872a88ce60451f7141a6fc4c162b9c11daa","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FirebirdDictionary.java","status":"removed","additions":0,"deletions":61,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FirebirdDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FirebirdDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FirebirdDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"414942cf21675a7ce25076ff9d7aa34c6c8d6830","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FoxProDictionary.java","status":"removed","additions":0,"deletions":162,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FoxProDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FoxProDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FoxProDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"75a6b6ed38ad8a379381c3621453343fa3f7f9da","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/H2Dictionary.java","status":"removed","additions":0,"deletions":211,"changes":211,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/H2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/H2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/H2Dictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"6914b21cf10e3c3c461271eebf2463676adc47d9","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/HSQLDictionary.java","status":"removed","additions":0,"deletions":300,"changes":300,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/HSQLDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/HSQLDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/HSQLDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"66dfb884ffc92507764441fab2d2db42c6e1499d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java","status":"removed","additions":0,"deletions":304,"changes":304,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8b3b52e1c3b7937df5a3309777c02a7238069e26","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InterbaseDictionary.java","status":"removed","additions":0,"deletions":118,"changes":118,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InterbaseDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InterbaseDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InterbaseDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3e789219ed279438885129c3d20d55ba02b2e749","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JDataStoreDictionary.java","status":"removed","additions":0,"deletions":115,"changes":115,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JDataStoreDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JDataStoreDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JDataStoreDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"2ace5d99da2967ff5bc4d437181b21eca37dc0bb","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Join.java","status":"removed","additions":0,"deletions":193,"changes":193,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Join.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Join.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Join.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b10c47f8fb87816392725379e41ace8bd78d7c1c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSet.java","status":"removed","additions":0,"deletions":406,"changes":406,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSet.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSet.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3c114e29e6dab59cf5d24183ff8571641a885286","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSyntaxes.java","status":"removed","additions":0,"deletions":42,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSyntaxes.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSyntaxes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSyntaxes.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"75ee7170290da3f30d18d6ea1647dcad9c9202f9","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Joins.java","status":"removed","additions":0,"deletions":80,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Joins.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Joins.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Joins.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"9f28b9bb13d9e98902564a5a3646aad86d262fb1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java","status":"removed","additions":0,"deletions":980,"changes":980,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"2702aab559ebb8c25a3142c191d18dbe02ec8ded","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MergedResult.java","status":"removed","additions":0,"deletions":557,"changes":557,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MergedResult.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MergedResult.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MergedResult.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d3e98abb404827ddd18aa74ba177195e3aee6d20","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MySQLDictionary.java","status":"removed","additions":0,"deletions":265,"changes":265,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MySQLDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MySQLDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MySQLDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"2714a84482e17fc4b69d6b9b2f1be8a467bd6987","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","status":"removed","additions":0,"deletions":1127,"changes":1127,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"6162a54537794b818c1e6ac14fb8fc12decda438","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PointbaseDictionary.java","status":"removed","additions":0,"deletions":127,"changes":127,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PointbaseDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PointbaseDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PointbaseDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"2aaf95d3b2d8984a788ae13d9fd242c4c0601ea6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java","status":"removed","additions":0,"deletions":551,"changes":551,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3a0be1ba78da408fbcae3bef3247f18b90fb40ce","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PrimaryRow.java","status":"removed","additions":0,"deletions":438,"changes":438,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PrimaryRow.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PrimaryRow.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PrimaryRow.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"240926fd30868bcee61ca9b78bc24feebb8750e6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Raw.java","status":"removed","additions":0,"deletions":38,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Raw.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Raw.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Raw.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8f5c729f4c762ea3a24e0a1c24a91a3dfa7bce14","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Result.java","status":"removed","additions":0,"deletions":607,"changes":607,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Result.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Result.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Result.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"2398c7fd0a8cdf6617c65ab13b3631150246568e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java","status":"removed","additions":0,"deletions":512,"changes":512,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7e77eb4c63c97afd418895c2fc2891a4b876efc1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Row.java","status":"removed","additions":0,"deletions":523,"changes":523,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Row.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Row.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Row.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b59a47c531612cf92cf22d742f26a08e264bb62d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java","status":"removed","additions":0,"deletions":963,"changes":963,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"fd8417a9526d9fae0625335dce915bee1bd06e1f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManager.java","status":"removed","additions":0,"deletions":74,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"47a0b513661698ef82acaa6cf49d648b87a90650","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManagerImpl.java","status":"removed","additions":0,"deletions":294,"changes":294,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManagerImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"a4d4c22490edb4e7e791ac39b4941e0f9d64e6b8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","status":"removed","additions":0,"deletions":700,"changes":700,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"5ed844a4b8b6f4957a240bd5cc173f0f8d165ca5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","status":"removed","additions":0,"deletions":155,"changes":155,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"cfd6934e850041581b4003afc13f5c7e22e846a8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLExceptions.java","status":"removed","additions":0,"deletions":120,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLExceptions.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLExceptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLExceptions.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"4233acf9108ccee9632322d738486c212b62a1b1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactory.java","status":"removed","additions":0,"deletions":46,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"28f97c6015445b7c67c438afc0711e73af4e225c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactoryImpl.java","status":"removed","additions":0,"deletions":63,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactoryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactoryImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"18ac7cc65cb0d2ec3b27c5400d7857bed8446d1f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","status":"removed","additions":0,"deletions":241,"changes":241,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7195c46003d89877ddd0c754067bfa43dea8de2e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SecondaryRow.java","status":"removed","additions":0,"deletions":191,"changes":191,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SecondaryRow.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SecondaryRow.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SecondaryRow.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"14a0d5e0820dc4dd7ae56b4fbd43e4238a1fc020","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java","status":"removed","additions":0,"deletions":723,"changes":723,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"72aa438bf701368e89c5fcf0cf5af84da832b8b8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectExecutor.java","status":"removed","additions":0,"deletions":153,"changes":153,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectExecutor.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectExecutor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectExecutor.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3237a97a482d66ac1a390c879bab81dacbe31b94","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","status":"removed","additions":0,"deletions":3135,"changes":3135,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"68420e72cb6188058d563e20b86b2f9a056001af","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Sized.java","status":"removed","additions":0,"deletions":36,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Sized.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Sized.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Sized.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"81464d5dc75a7b7dfc0b0a10e6701e00a61446a0","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java","status":"removed","additions":0,"deletions":323,"changes":323,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"614994c0f72e3e5c8b0fe4428739fa00d5b345d9","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Union.java","status":"removed","additions":0,"deletions":65,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Union.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Union.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Union.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7bd28ce668ec6c1ebc3b62ca7ffd484328337fe7","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/package.html","status":"removed","additions":0,"deletions":27,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/package.html","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/package.html?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"23a89461afcc0a221109c5801f499e374fa1c91f","filename":"openjpa-jdbc/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ProductDerivation","status":"removed","additions":0,"deletions":17,"changes":17,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ProductDerivation","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ProductDerivation","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ProductDerivation?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"6384f36cc27312f07886e2707e1f4f927702321a","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/antlib.xml","status":"removed","additions":0,"deletions":28,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/antlib.xml","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/antlib.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/antlib.xml?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"13c497cbd3fe08523966d5f5f13b1489dd376a8b","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/localizer.properties","status":"removed","additions":0,"deletions":19,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/localizer.properties?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"401cd51bb487eb55df3421efe5ddec8347194ad7","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/conf/localizer.properties","status":"removed","additions":0,"deletions":246,"changes":246,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/conf/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/conf/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/conf/localizer.properties?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"9a1d91c4616d59241e60d9598a65a52b289b4523","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/exps/localizer.properties","status":"removed","additions":0,"deletions":28,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/exps/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/exps/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/exps/localizer.properties?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"5c918cd85318cbd7821ef97cce57a87f0a12d686","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","status":"removed","additions":0,"deletions":117,"changes":117,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b5111fcc26b6e5dde5fd4a887bc4d76857974994","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/java-keywords.rsrc","status":"removed","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/java-keywords.rsrc","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/java-keywords.rsrc","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/java-keywords.rsrc?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"815e939edec7e7db2414e3469b1709a01f0dde82","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/localizer.properties","status":"removed","additions":0,"deletions":417,"changes":417,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/localizer.properties?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7a12b9fb29e6afd0efaf3565849a65f7a9d1655f","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/strats/localizer.properties","status":"removed","additions":0,"deletions":139,"changes":139,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/strats/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/strats/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/strats/localizer.properties?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"cab55e1bef5782aabf0393cddd2d999ea85c868b","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/localizer.properties","status":"removed","additions":0,"deletions":153,"changes":153,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/localizer.properties?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"82dd2693311ef4c98da3a7a1ee92bc52a134bcc5","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/schemas-doctype.rsrc","status":"removed","additions":0,"deletions":47,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/schemas-doctype.rsrc","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/schemas-doctype.rsrc","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/schemas-doctype.rsrc?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"1c8b9f7a1893281c714b4ae528d4f17d4f43801a","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","status":"removed","additions":0,"deletions":179,"changes":179,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"5a532772390880a8e0e9252db7efd7004b08724c","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-error-state-codes.xml","status":"removed","additions":0,"deletions":146,"changes":146,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-error-state-codes.xml","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-error-state-codes.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-error-state-codes.xml?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"952ae4c0d56976010a2d31e92226fa940b654aad","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-keywords.rsrc","status":"removed","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-keywords.rsrc","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-keywords.rsrc","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-keywords.rsrc?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d35d9f7b00913a3e01f8a1496d87aab51e270b75","filename":"openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java","status":"removed","additions":0,"deletions":882,"changes":882,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8b9def9fd5ea58433272f3a5470ef36a84486893","filename":"openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar","status":"removed","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"1ff224476d5e273eebfde43fb16df720381ce931","filename":"openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar.md5","status":"removed","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar.md5","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar.md5","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar.md5?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"dc1ea7a1720b73971f008e74c9eed948bfd36e32","filename":"openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar.sha1","status":"removed","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar.sha1","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar.sha1","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar.sha1?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c045dd729f1c7cca7745777cb3bbb8e4b6bfbbcb","filename":"openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom","status":"removed","additions":0,"deletions":45,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3dc4f3a4b73c2ff3bafabc131b6d75fca1e6f72d","filename":"openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom.md5","status":"removed","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom.md5","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom.md5","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom.md5?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c90336c33b456a1e63aff8391fec721283ecc386","filename":"openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom.sha1","status":"removed","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom.sha1","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom.sha1","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom.sha1?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"a474011bd0cb268bb0baa0f6be30633bf8b6b4c4","filename":"openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml","status":"removed","additions":0,"deletions":11,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"73b10622e4e5c51e6eb114cd092203c908569426","filename":"openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml.md5","status":"removed","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml.md5","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml.md5","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml.md5?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b7520c252188a305299346309522424c70399da4","filename":"openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml.sha1","status":"removed","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml.sha1","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml.sha1","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml.sha1?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c42a685aebfca6eb13421ceee197157a5836cba2","filename":"openjpa-kernel/pom.xml","status":"removed","additions":0,"deletions":166,"changes":166,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/pom.xml?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7851de74d54f24496e54917077a160d25aab09b3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreBrokerFactory.java","status":"removed","additions":0,"deletions":148,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreBrokerFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"258fd8145e3036d977055824bda89cb3494fa568","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java","status":"removed","additions":0,"deletions":520,"changes":520,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"5382c2b4376fa1484d998cf78ae4d14bedd92e47","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/package.html","status":"removed","additions":0,"deletions":77,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/package.html","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/package.html?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"9232004a1c829eaea3b2e91ed7a9c1ed9fe540f2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ant/ApplicationIdToolTask.java","status":"removed","additions":0,"deletions":112,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/ant/ApplicationIdToolTask.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/ant/ApplicationIdToolTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ant/ApplicationIdToolTask.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"28aebb58c56f76d17366b2fa53e1999e6d83f811","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ant/MetaDataToolTask.java","status":"removed","additions":0,"deletions":90,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/ant/MetaDataToolTask.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/ant/MetaDataToolTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ant/MetaDataToolTask.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"f82fda0ca76450ed727863695bf86323a0441a70","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ant/PCEnhancerTask.java","status":"removed","additions":0,"deletions":91,"changes":91,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/ant/PCEnhancerTask.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/ant/PCEnhancerTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ant/PCEnhancerTask.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"bc1d862d7d6816a24fd9e433b221584da8e37175","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/ant/package.html","status":"removed","additions":0,"deletions":27,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/ant/package.html","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/ant/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/ant/package.html?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8b1c09c448ae89cb086f0022af2e290ebe43e29a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/AutoDetachValue.java","status":"removed","additions":0,"deletions":88,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/AutoDetachValue.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/AutoDetachValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/AutoDetachValue.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d70a112d1af14c17f02ade564cb8817fa02f657e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerFactoryValue.java","status":"removed","additions":0,"deletions":87,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerFactoryValue.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerFactoryValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerFactoryValue.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"ee0db6ca06c1bc12aba1d8d5f5e108fde3bae2ef","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerValue.java","status":"removed","additions":0,"deletions":83,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerValue.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerValue.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7d6c43d2a8ea953f6f8c7ab72889bc8ebf7cf055","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java","status":"removed","additions":0,"deletions":92,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c552ccd6d0a21b694f65acfb82ebeb9e0b39ad62","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java","status":"removed","additions":0,"deletions":253,"changes":253,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c1276f97d1687ea1f79c1ae5d342e309186e23d4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java","status":"removed","additions":0,"deletions":121,"changes":121,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c054895ecb40c7a907af6da793301a412dde9dc3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","status":"removed","additions":0,"deletions":272,"changes":272,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"11abd55613b3bbba6b701160eaf64178d8c6a712","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/DetachOptions.java","status":"removed","additions":0,"deletions":160,"changes":160,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/DetachOptions.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/DetachOptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/DetachOptions.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"6762bd9614112d55a14eecc0dfca8bd8126dd486","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java","status":"removed","additions":0,"deletions":202,"changes":202,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"10f6a2198df8e48f2a5e3808c3afcf10ed86190a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","status":"removed","additions":0,"deletions":74,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"af9e39019ec4629b8b97125bd1f68fb6a37177e8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java","status":"removed","additions":0,"deletions":48,"changes":48,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"a21de1125daa504788dacc3669cff889c1f225e4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfiguration.java","status":"removed","additions":0,"deletions":1513,"changes":1513,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfiguration.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"917d6c48e6391cdc3f93eb466a05a753f6624302","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","status":"removed","additions":0,"deletions":1447,"changes":1447,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c0676b180e65a0eb872f404ffc3ff044cfa65b74","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","status":"removed","additions":0,"deletions":43,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"}]}

