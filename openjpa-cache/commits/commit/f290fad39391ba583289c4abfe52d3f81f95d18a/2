{"sha":"f290fad39391ba583289c4abfe52d3f81f95d18a","node_id":"MDY6Q29tbWl0MjA2MzY0OmYyOTBmYWQzOTM5MWJhNTgzMjg5YzRhYmZlNTJkM2Y4MWY5NWQxOGE=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-12T00:53:24Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-12T00:53:24Z"},"message":"Creating 1.2.1 tag\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/tags/1.2.1@752732 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"9e70e22978192e69c0226f5039af58d37b107914","url":"https://api.github.com/repos/apache/openjpa/git/trees/9e70e22978192e69c0226f5039af58d37b107914"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/f290fad39391ba583289c4abfe52d3f81f95d18a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/f290fad39391ba583289c4abfe52d3f81f95d18a","html_url":"https://github.com/apache/openjpa/commit/f290fad39391ba583289c4abfe52d3f81f95d18a","comments_url":"https://api.github.com/repos/apache/openjpa/commits/f290fad39391ba583289c4abfe52d3f81f95d18a/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"82164a8c3bcd281532692875dbb05797c1b5bb76","url":"https://api.github.com/repos/apache/openjpa/commits/82164a8c3bcd281532692875dbb05797c1b5bb76","html_url":"https://github.com/apache/openjpa/commit/82164a8c3bcd281532692875dbb05797c1b5bb76"}],"stats":{"total":447552,"additions":447552,"deletions":0},"files":[{"sha":"1f834b9600d9bd0269bbf183a61ff23e75545b69","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java","status":"added","additions":739,"deletions":0,"changes":739,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,739 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.schema;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.LinkedHashMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.lib.meta.SourceTracker;\n+\n+/**\n+ * Represents a database table.\n+ *\n+ * @author Abe White\n+ * @author Stephen Kim\n+ */\n+public class Table\n+    extends NameSet\n+    implements Comparable, SourceTracker {\n+\n+    private String _name = null;\n+    private String _schemaName = null;\n+    private Map _colMap = null;\n+    private Map _idxMap = null;\n+    private Collection _fkList = null;\n+    private Collection _unqList = null;\n+    private Schema _schema = null;\n+    private PrimaryKey _pk = null;\n+\n+    // keep track of source\n+    private File _source = null;\n+    private int _srcType = SRC_OTHER;\n+\n+    // cache\n+    private String _fullName = null;\n+    private Column[] _cols = null;\n+    private Column[] _autoAssign = null;\n+    private Column[] _rels = null;\n+    private ForeignKey[] _fks = null;\n+    private Index[] _idxs = null;\n+    private Unique[] _unqs = null;\n+    private String _comment = null;\n+    private int _lineNum = 0;  \n+    private int _colNum = 0;  \n+\n+    /**\n+     * Default constructor.\n+     */\n+    public Table() {\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param name the table name\n+     * @param schema the table schema\n+     */\n+    public Table(String name, Schema schema) {\n+        setName(name);\n+        addName(name, true);\n+        if (schema != null)\n+            setSchemaName(schema.getName());\n+        _schema = schema;\n+    }\n+\n+    /**\n+     * Called when the table is removed from its schema. Removes all table\n+     * members, and invalidates the table.\n+     */\n+    void remove() {\n+        ForeignKey[] fks = getForeignKeys();\n+        for (int i = 0; i < fks.length; i++)\n+            removeForeignKey(fks[i]);\n+        Index[] idxs = getIndexes();\n+        for (int i = 0; i < idxs.length; i++)\n+            removeIndex(idxs[i]);\n+        Unique[] unqs = getUniques();\n+        for (int i = 0; i < unqs.length; i++)\n+            removeUnique(unqs[i]);\n+        removePrimaryKey();\n+        Column[] cols = getColumns();\n+        for (int i = 0; i < cols.length; i++)\n+            removeColumn(cols[i]);\n+        _schema = null;\n+        _schemaName = null;\n+        _fullName = null;\n+    }\n+\n+    /**\n+     * Return the schema for the table.\n+     */\n+    public Schema getSchema() {\n+        return _schema;\n+    }\n+\n+    /**\n+     * The table's schema name.\n+     */\n+    public String getSchemaName() {\n+        return _schemaName;\n+    }\n+\n+    /**\n+     * The table's schema name. You can only call this method on tables\n+     * whose schema object is not set.\n+     */\n+    public void setSchemaName(String name) {\n+        if (getSchema() != null)\n+            throw new IllegalStateException();\n+        _schemaName = name;\n+        _fullName = null;\n+    }\n+\n+    /**\n+     * Return the name of the table.\n+     */\n+    public String getName() {\n+        return _name;\n+    }\n+\n+    /**\n+     * Set the name of the table. This method can only be called on tables\n+     * that are not part of a schema.\n+     */\n+    public void setName(String name) {\n+        if (getSchema() != null)\n+            throw new IllegalStateException();\n+        _name = name;\n+        _fullName = null;\n+    }\n+\n+    /**\n+     * Return the table name, including schema, using '.' as the\n+     * catalog separator.\n+     */\n+    public String getFullName() {\n+        if (_fullName == null) {\n+            Schema schema = getSchema();\n+            if (schema == null || schema.getName() == null)\n+                _fullName = getName();\n+            else\n+                _fullName = schema.getName() + \".\" + getName();\n+        }\n+        return _fullName;\n+    }\n+\n+    public File getSourceFile() {\n+        return _source;\n+    }\n+\n+    public Object getSourceScope() {\n+        return null;\n+    }\n+\n+    public int getSourceType() {\n+        return _srcType;\n+    }\n+\n+    public void setSource(File source, int srcType) {\n+        _source = source;\n+        _srcType = srcType;\n+    }\n+\n+    public String getResourceName() {\n+        return getFullName();\n+    }\n+\n+    /**\n+     * Return the table's columns, in alphabetical order.\n+     */\n+    public Column[] getColumns() {\n+        if (_cols == null) {\n+            if (_colMap == null)\n+                _cols = Schemas.EMPTY_COLUMNS;\n+            else {\n+                Column[] cols = new Column[_colMap.size()];\n+                Iterator itr = _colMap.values().iterator();\n+                for (int i = 0; itr.hasNext(); i++) {\n+                    cols[i] = (Column) itr.next();\n+                    cols[i].setIndex(i);\n+                }\n+                _cols = cols;\n+            }\n+        }\n+        return _cols;\n+    }\n+\n+    /**\n+     * Return this table's auto-assigned columns.\n+     */\n+    public Column[] getAutoAssignedColumns() {\n+        if (_autoAssign == null) {\n+            if (_colMap == null)\n+                _autoAssign = Schemas.EMPTY_COLUMNS;\n+            else {\n+                Collection autos = null;\n+                Column[] cols = getColumns();\n+                for (int i = 0; i < cols.length; i++) {\n+                    if (cols[i].isAutoAssigned()) {\n+                        if (autos == null)\n+                            autos = new ArrayList(3);\n+                        autos.add(cols[i]);\n+                    }\n+                }\n+                _autoAssign = (autos == null) ? Schemas.EMPTY_COLUMNS\n+                    : (Column[]) autos.toArray(new Column[autos.size()]);\n+            }\n+        }\n+        return _autoAssign;\n+    }\n+\n+    /**\n+     * Return this table's relation id columns.\n+     */\n+    public Column[] getRelationIdColumns() {\n+        if (_rels == null) {\n+            if (_colMap == null)\n+                _rels = Schemas.EMPTY_COLUMNS;\n+            else {\n+                Collection rels = null;\n+                Column[] cols = getColumns();\n+                for (int i = 0; i < cols.length; i++) {\n+                    if (cols[i].isRelationId()) {\n+                        if (rels == null)\n+                            rels = new ArrayList(3);\n+                        rels.add(cols[i]);\n+                    }\n+                }\n+                _rels = (rels == null) ? Schemas.EMPTY_COLUMNS\n+                    : (Column[]) rels.toArray(new Column[rels.size()]);\n+            }\n+        }\n+        return _rels;\n+    }\n+\n+    public String[] getColumnNames() {\n+    \treturn _colMap == null ? new String[0] : \n+    \t\t(String[])_colMap.keySet().toArray(new String[_colMap.size()]);\n+    }\n+    \n+    /**\n+     * Return the column with the given name, or null if none.\n+     */\n+    public Column getColumn(String name) {\n+        if (name == null || _colMap == null)\n+            return null;\n+        return (Column) _colMap.get(name.toUpperCase());\n+    }\n+    \n+    /**\n+     * Affirms if this table contains the column of the given name without any \n+     * side-effect. \n+     * @see Table#getColumn(String) can have side-effect of creating a column\n+     * for dynamic table implementation.\n+     */\n+    public boolean containsColumn(String name) {\n+    \treturn name != null && _colMap != null \n+    \t\t&& _colMap.containsKey(name.toUpperCase());\n+    }\n+\n+    /**\n+     * Add a column to the table.\n+     */\n+    public Column addColumn(String name) {\n+        addName(name, true);\n+        Schema schema = getSchema();\n+        Column col;\n+        if (schema != null && schema.getSchemaGroup() != null)\n+            col = schema.getSchemaGroup().newColumn(name, this);\n+        else\n+            col = new Column(name, this);\n+        if (_colMap == null)\n+            _colMap = new LinkedHashMap();\n+        _colMap.put(name.toUpperCase(), col);\n+        _cols = null;\n+        return col;\n+    }\n+\n+    /**\n+     * Remove the given column from the table.\n+     *\n+     * @return true if the column was removed, false if not in the table\n+     */\n+    public boolean removeColumn(Column col) {\n+        if (col == null || _colMap == null)\n+            return false;\n+\n+        Column cur = (Column) _colMap.get(col.getName().toUpperCase());\n+        if (!col.equals(cur))\n+            return false;\n+\n+        removeName(col.getName());\n+        _colMap.remove(col.getName().toUpperCase());\n+        _cols = null;\n+        if (col.isAutoAssigned())\n+            _autoAssign = null;\n+        if (col.isRelationId())\n+            _rels = null;\n+        col.remove();\n+        return true;\n+    }\n+\n+    /**\n+     * Import a column from another table.\n+     */\n+    public Column importColumn(Column col) {\n+        if (col == null)\n+            return null;\n+\n+        Column copy = addColumn(col.getName());\n+        copy.setType(col.getType());\n+        copy.setTypeName(col.getTypeName());\n+        copy.setJavaType(col.getJavaType());\n+        copy.setNotNull(col.isNotNull());\n+        copy.setDefaultString(col.getDefaultString());\n+        copy.setSize(col.getSize());\n+        copy.setDecimalDigits(col.getDecimalDigits());\n+        copy.setAutoAssigned(col.isAutoAssigned());\n+        return copy;\n+    }\n+\n+    /**\n+     * Return the primary key for the table, if any.\n+     */\n+    public PrimaryKey getPrimaryKey() {\n+        return _pk;\n+    }\n+\n+    /**\n+     * Set the primary key for the table.\n+     */\n+    public PrimaryKey addPrimaryKey() {\n+        return addPrimaryKey(null);\n+    }\n+\n+    /**\n+     * Set the primary key for the table.\n+     */\n+    public PrimaryKey addPrimaryKey(String name) {\n+        Schema schema = getSchema();\n+        if (schema != null && schema.getSchemaGroup() != null) {\n+            schema.getSchemaGroup().addName(name, false);\n+            _pk = schema.getSchemaGroup().newPrimaryKey(name, this);\n+        } else\n+            _pk = new PrimaryKey(name, this);\n+        return _pk;\n+    }\n+\n+    /**\n+     * Remove the primary key from this table.\n+     *\n+     * @return true if there was a pk to remove, false otherwise\n+     */\n+    public boolean removePrimaryKey() {\n+        boolean rem = _pk != null;\n+        if (rem) {\n+            Schema schema = getSchema();\n+            if (schema != null && schema.getSchemaGroup() != null)\n+                schema.getSchemaGroup().removeName(_pk.getName());\n+            _pk.remove();\n+        }\n+        _pk = null;\n+        return rem;\n+    }\n+\n+    /**\n+     * Import a primary key; column names must match columns of this table.\n+     */\n+    public PrimaryKey importPrimaryKey(PrimaryKey pk) {\n+        if (pk == null)\n+            return null;\n+\n+        PrimaryKey copy = addPrimaryKey(pk.getName());\n+        copy.setLogical(pk.isLogical());\n+        Column[] cols = pk.getColumns();\n+        for (int i = 0; i < cols.length; i++)\n+            copy.addColumn(getColumn(cols[i].getName()));\n+        return copy;\n+    }\n+\n+    /**\n+     * Return the foreign key with the given name. If multiple foreign keys\n+     * have the name, the first match is returned.\n+     */\n+    public ForeignKey getForeignKey(String name) {\n+        ForeignKey[] fks = getForeignKeys();\n+        for (int i = 0; i < fks.length; i++)\n+            if (StringUtils.equalsIgnoreCase(name, fks[i].getName()))\n+                return fks[i];\n+        return null;\n+    }\n+\n+    /**\n+     * Return all foreign keys for the table.\n+     */\n+    public ForeignKey[] getForeignKeys() {\n+        if (_fks == null) {\n+            if (_fkList == null)\n+                _fks = Schemas.EMPTY_FOREIGN_KEYS;\n+            else {\n+                ForeignKey[] fks = new ForeignKey[_fkList.size()];\n+                Iterator itr = _fkList.iterator();\n+                for (int i = 0; itr.hasNext(); i++) {\n+                    fks[i] = (ForeignKey) itr.next();\n+                    fks[i].setIndex(i);\n+                }\n+                _fks = fks;\n+            }\n+        }\n+        return _fks;\n+    }\n+\n+    /**\n+     * Add a foreign key to the table.\n+     */\n+    public ForeignKey addForeignKey() {\n+        return addForeignKey(null);\n+    }\n+\n+    /**\n+     * Add a foreign key to the table. Duplicate key names are not allowed.\n+     */\n+    public ForeignKey addForeignKey(String name) {\n+        Schema schema = getSchema();\n+        ForeignKey fk;\n+        if (schema != null && schema.getSchemaGroup() != null) {\n+            schema.getSchemaGroup().addName(name, false);\n+            fk = schema.getSchemaGroup().newForeignKey(name, this);\n+        } else\n+            fk = new ForeignKey(name, this);\n+        if (_fkList == null)\n+            _fkList = new ArrayList(3);\n+        _fkList.add(fk);\n+        _fks = null;\n+        return fk;\n+    }\n+\n+    /**\n+     * Remove the given foreign key from the table.\n+     *\n+     * @return true if the key was removed, false if not in the table\n+     */\n+    public boolean removeForeignKey(ForeignKey fk) {\n+        if (fk == null || _fkList == null)\n+            return false;\n+\n+        if (!_fkList.remove(fk))\n+            return false;\n+\n+        Schema schema = getSchema();\n+        if (schema != null && schema.getSchemaGroup() != null)\n+            schema.getSchemaGroup().removeName(fk.getName());\n+        _fks = null;\n+        fk.remove();\n+        return true;\n+    }\n+\n+    /**\n+     * Import a foreign key; column names must match columns of this table.\n+     */\n+    public ForeignKey importForeignKey(ForeignKey fk) {\n+        if (fk == null)\n+            return null;\n+\n+        ForeignKey copy = addForeignKey(fk.getName());\n+        copy.setDeleteAction(fk.getDeleteAction());\n+\n+        Schema schema = getSchema();\n+        if (schema != null && schema.getSchemaGroup() != null) {\n+            Column[] pks = fk.getPrimaryKeyColumns();\n+            Table joined = null;\n+            if (pks.length > 0)\n+                joined = schema.getSchemaGroup().findTable(pks[0].getTable());\n+\n+            Column[] cols = fk.getColumns();\n+            for (int i = 0; i < cols.length; i++)\n+                copy.join(getColumn(cols[i].getName()),\n+                    joined.getColumn(pks[i].getName()));\n+\n+            cols = fk.getConstantColumns();\n+            for (int i = 0; i < cols.length; i++)\n+                copy.joinConstant(getColumn(cols[i].getName()),\n+                    fk.getPrimaryKeyConstant(cols[i]));\n+\n+            pks = fk.getConstantPrimaryKeyColumns();\n+            if (joined == null && pks.length > 0)\n+                joined = schema.getSchemaGroup().findTable(pks[0].getTable());\n+            for (int i = 0; i < pks.length; i++)\n+                copy.joinConstant(fk.getConstant(pks[i]),\n+                    joined.getColumn(pks[i].getName()));\n+        }\n+        return copy;\n+    }\n+\n+    /**\n+     * Return the table's indexes.\n+     */\n+    public Index[] getIndexes() {\n+        if (_idxs == null || _idxs.length == 0)\n+            _idxs = (_idxMap == null) ? Schemas.EMPTY_INDEXES : (Index[])\n+                _idxMap.values().toArray(new Index[_idxMap.size()]);\n+        return _idxs;\n+    }\n+\n+    /**\n+     * Return the index with the given name, or null if none.\n+     */\n+    public Index getIndex(String name) {\n+        if (name == null || _idxMap == null)\n+            return null;\n+        return (Index) _idxMap.get(name.toUpperCase());\n+    }\n+\n+    /**\n+     * Add an index to the table.\n+     */\n+    public Index addIndex(String name) {\n+        Schema schema = getSchema();\n+        Index idx;\n+        if (schema != null && schema.getSchemaGroup() != null) {\n+            schema.getSchemaGroup().addName(name, true);\n+            idx = schema.getSchemaGroup().newIndex(name, this);\n+        } else\n+            idx = new Index(name, this);\n+        if (_idxMap == null)\n+            _idxMap = new TreeMap();\n+        _idxMap.put(name.toUpperCase(), idx);\n+        _idxs = null;\n+        return idx;\n+    }\n+\n+    /**\n+     * Remove the given index from the table.\n+     *\n+     * @return true if the index was removed, false if not in the table\n+     */\n+    public boolean removeIndex(Index idx) {\n+        if (idx == null || _idxMap == null)\n+            return false;\n+\n+        Index cur = (Index) _idxMap.get(idx.getName().toUpperCase());\n+        if (!idx.equals(cur))\n+            return false;\n+\n+        _idxMap.remove(idx.getName().toUpperCase());\n+        Schema schema = getSchema();\n+        if (schema != null && schema.getSchemaGroup() != null)\n+            schema.getSchemaGroup().removeName(idx.getName());\n+        idx.remove();\n+        _idxs = null;\n+        return true;\n+    }\n+\n+    /**\n+     * Import an index; column names must match columns of this table.\n+     */\n+    public Index importIndex(Index idx) {\n+        if (idx == null)\n+            return null;\n+\n+        Index copy = addIndex(idx.getName());\n+        copy.setUnique(idx.isUnique());\n+\n+        Column[] cols = idx.getColumns();\n+        for (int i = 0; i < cols.length; i++)\n+            copy.addColumn(getColumn(cols[i].getName()));\n+        return copy;\n+    }\n+\n+    /**\n+     * Return the table's unique constraints.\n+     */\n+    public Unique[] getUniques() {\n+        if (_unqs == null)\n+            _unqs = (_unqList == null) ? Schemas.EMPTY_UNIQUES : (Unique[])\n+                _unqList.toArray(new Unique[_unqList.size()]);\n+        return _unqs;\n+    }\n+\n+    /**\n+     * Return the unique constraint with the given name, or null if none.\n+     */\n+    public Unique getUnique(String name) {\n+        Unique[] unqs = getUniques();\n+        for (int i = 0; i < unqs.length; i++)\n+            if (StringUtils.equalsIgnoreCase(name, unqs[i].getName()))\n+                return unqs[i];\n+        return null;\n+    }\n+\n+    /**\n+     * Add a unique constraint to the table.\n+     */\n+    public Unique addUnique(String name) {\n+        Schema schema = getSchema();\n+        Unique unq;\n+        if (schema != null && schema.getSchemaGroup() != null) {\n+            schema.getSchemaGroup().addName(name, false);\n+            unq = schema.getSchemaGroup().newUnique(name, this);\n+        } else\n+            unq = new Unique(name, this);\n+        if (_unqList == null)\n+            _unqList = new ArrayList(3);\n+        _unqList.add(unq);\n+        _unqs = null;\n+        return unq;\n+    }\n+\n+    /**\n+     * Remove the given unique constraint from the table.\n+     *\n+     * @return true if the constraint was removed, false if not in the table\n+     */\n+    public boolean removeUnique(Unique unq) {\n+        if (unq == null || _unqList == null)\n+            return false;\n+\n+        if (!_unqList.remove(unq))\n+            return false;\n+\n+        Schema schema = getSchema();\n+        if (schema != null && schema.getSchemaGroup() != null)\n+            schema.getSchemaGroup().removeName(unq.getName());\n+        _unqs = null;\n+        unq.remove();\n+        return true;\n+    }\n+\n+    /**\n+     * Import a constraint; column names must match columns of this table.\n+     */\n+    public Unique importUnique(Unique unq) {\n+        if (unq == null)\n+            return null;\n+\n+        Unique copy = addUnique(unq.getName());\n+        copy.setDeferred(unq.isDeferred());\n+\n+        Column[] cols = unq.getColumns();\n+        for (int i = 0; i < cols.length; i++)\n+            copy.addColumn(getColumn(cols[i].getName()));\n+        return copy;\n+    }\n+\n+    /**\n+     * Called by columns to ensure that all columns are properly indexed\n+     * before returning that information to the user.\n+     */\n+    void indexColumns() {\n+        getColumns();\n+    }\n+\n+    /**\n+     * Called by foreign keys to ensure that all fks are properly indexed\n+     * before returning that information to the user.\n+     */\n+    void indexForeignKeys() {\n+        getForeignKeys();\n+    }\n+\n+    /**\n+     * Called by columns when their auto increment status changes.\n+     */\n+    void changeAutoAssigned(Column col) {\n+        _autoAssign = null;\n+    }\n+\n+    /**\n+     * Called by columns when their relation id status changes.\n+     */\n+    void changeRelationId(Column col) {\n+        _rels = null;\n+    }\n+\n+    public int compareTo(Object other) {\n+        String name = getFullName();\n+        String otherName = ((Table) other).getFullName();\n+        if (name == null && otherName == null)\n+            return 0;\n+        if (name == null)\n+            return 1;\n+        if (otherName == null)\n+            return -1;\n+        return name.compareTo(otherName);\n+    }\n+\n+    public String toString() {\n+        return getFullName();\n+    }\n+\n+    public boolean hasComment() {\n+        return _comment != null && !_comment.equalsIgnoreCase(_name);\n+    }\n+\n+    public String getComment() {\n+        return _comment;\n+    }\n+\n+    public void setComment(String comment) {\n+        _comment = comment;\n+    }\n+    \n+    public int getLineNumber() {\n+        return _lineNum;\n+    }\n+\n+    public void setLineNumber(int lineNum) {\n+        _lineNum = lineNum;\n+    }\n+\n+    public int getColNumber() {\n+        return _colNum;\n+    }\n+\n+    public void setColNumber(int colNum) {\n+        _colNum = colNum;\n+    }\n+}"},{"sha":"df21bcf4ba369d3f9032fb1906fe84282752055f","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/TableSchemaFactory.java","status":"added","additions":499,"deletions":0,"changes":499,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/TableSchemaFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/TableSchemaFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/TableSchemaFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,499 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.schema;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.SQLBuffer;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Options;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.GeneralException;\n+import serp.util.Numbers;\n+import serp.util.Strings;\n+\n+/**\n+ * Factory that uses an XML schema definition stored in a database table\n+ * to record the system schema.\n+ *\n+ * @author Abe White\n+ */\n+public class TableSchemaFactory\n+    implements SchemaFactory, Configurable {\n+\n+    public static final String ACTION_ADD = \"add\";\n+    public static final String ACTION_DROP = \"drop\";\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (TableSchemaFactory.class);\n+    private static boolean _refreshedTable = false;\n+\n+    private JDBCConfiguration _conf = null;\n+    private Log _log = null;\n+    private String _table = \"OPENJPA_SCHEMA\";\n+    private String _pkColumnName = \"ID\";\n+    private String _schemaColumnName = \"SCHEMA_DEF\";\n+    private Column _pkColumn = null;\n+    private Column _schemaColumn = null;\n+\n+    /**\n+     * The name of the schema definition table. Defaults to\n+     * <code>OPENJPA_SCHEMA</code>.\n+     */\n+    public String getTable() {\n+        return _table;\n+    }\n+\n+    /**\n+     * The name of the schema definition table. Defaults to\n+     * <code>OPENJPA_SCHEMA</code>.\n+     */\n+    public void setTable(String name) {\n+        _table = name;\n+    }\n+\n+    /**\n+     * @deprecated Use {@link #setTable}. Retained for\n+     * backwards-compatible auto-configuration.\n+     */\n+    public void setTableName(String name) {\n+        setTable(name);\n+    }\n+\n+    /**\n+     * The name of the primary key column on the schema definition table.\n+     * Defaults to <code>ID</code>.\n+     */\n+    public void setPrimaryKeyColumn(String name) {\n+        _pkColumnName = name;\n+    }\n+\n+    /**\n+     * The name of the primary key column on the schema definition table.\n+     * Defaults to <code>ID</code>.\n+     */\n+    public String getPrimaryKeyColumn() {\n+        return _pkColumnName;\n+    }\n+\n+    /**\n+     * The name of the schema column on the schema definition table.\n+     * Defaults to <code>SCHEMA_DEF</code>.\n+     */\n+    public void setSchemaColumn(String name) {\n+        _schemaColumnName = name;\n+    }\n+\n+    /**\n+     * The name of the schema column on the schema definition table.\n+     * Defaults to <code>SCHEMA_DEF</code>.\n+     */\n+    public String getSchemaColumn() {\n+        return _schemaColumnName;\n+    }\n+\n+    public JDBCConfiguration getConfiguration() {\n+        return _conf;\n+    }\n+\n+    public void setConfiguration(Configuration conf) {\n+        _conf = (JDBCConfiguration) conf;\n+        _log = _conf.getLog(JDBCConfiguration.LOG_SCHEMA);\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+        buildTable();\n+    }\n+\n+    public synchronized SchemaGroup readSchema() {\n+        String schema = null;\n+        try {\n+            schema = readSchemaColumn();\n+        } catch (SQLException se) {\n+            if (_log.isWarnEnabled())\n+                _log.warn(_loc.get(\"bad-sch-read\", se));\n+        }\n+        if (schema == null)\n+            return new SchemaGroup();\n+\n+        XMLSchemaParser parser = new XMLSchemaParser(_conf);\n+        try {\n+            parser.parse(new StringReader(schema),\n+                _schemaColumn.getFullName());\n+        } catch (IOException ioe) {\n+            throw new GeneralException(ioe);\n+        }\n+        return parser.getSchemaGroup();\n+    }\n+\n+    public void storeSchema(SchemaGroup schema) {\n+        XMLSchemaSerializer ser = new XMLSchemaSerializer(_conf);\n+        ser.addAll(schema);\n+        Writer writer = new StringWriter();\n+        try {\n+            ser.serialize(writer, ser.COMPACT);\n+        } catch (IOException ioe) {\n+            throw new GeneralException(ioe);\n+        }\n+\n+        String schemaStr = writer.toString();\n+        try {\n+            writeSchemaColumn(schemaStr);\n+        } catch (SQLException se) {\n+            if (_log.isWarnEnabled())\n+                _log.warn(_loc.get(\"bad-sch-write-1\", se));\n+\n+            // maybe the update failed b/c the sequence table doesn't\n+            // exist yet; create it now; note that though we synchronize\n+            // here, other JVMs can still be trying to create the table at\n+            // the same time (unlikely, since this is a dev-tool op)\n+            synchronized (TableSchemaFactory.class) {\n+                if (!_refreshedTable) {\n+                    _refreshedTable = true;\n+                    try {\n+                        refreshTable();\n+                    } catch (Exception e) {\n+                        if (_log.isWarnEnabled())\n+                            _log.warn(_loc.get(\"bad-sch-ref\", e));\n+                    }\n+                }\n+\n+                try {\n+                    writeSchemaColumn(schemaStr);\n+                } catch (Exception e) {\n+                    if (_log.isWarnEnabled())\n+                        _log.warn(_loc.get(\"bad-sch-write-2\"));\n+\n+                    // throw original exception\n+                    throw SQLExceptions.getStore(se,\n+                        _conf.getDBDictionaryInstance());\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates the schema table in the DB.\n+     */\n+    public void refreshTable()\n+        throws SQLException {\n+        if (_log.isInfoEnabled())\n+            _log.info(_loc.get(\"make-sch-table\"));\n+\n+        // create the table\n+        SchemaTool tool = new SchemaTool(_conf);\n+        tool.setIgnoreErrors(true);\n+        tool.createTable(_pkColumn.getTable());\n+\n+        // insert an empty schema\n+        Connection conn = getConnection();\n+        PreparedStatement stmnt = null;\n+        boolean wasAuto = true;\n+        try {\n+            wasAuto = conn.getAutoCommit();\n+            if (!wasAuto)\n+                conn.setAutoCommit(true);\n+\n+            DBDictionary dict = _conf.getDBDictionaryInstance();\n+            stmnt = conn.prepareStatement(\"INSERT INTO \"\n+                + dict.getFullName(_pkColumn.getTable(), false)\n+                + \" (\" + _pkColumn + \", \" + _schemaColumn + \") VALUES (?, ?)\");\n+            dict.setInt(stmnt, 1, 1, _pkColumn);\n+            dict.setNull(stmnt, 2, _schemaColumn.getType(), _schemaColumn);\n+\n+            stmnt.executeUpdate();\n+        } finally {\n+            if (stmnt != null)\n+                try {\n+                    stmnt.close();\n+                } catch (SQLException se) {\n+                }\n+            if (!wasAuto)\n+                conn.setAutoCommit(false);\n+            try {\n+                conn.close();\n+            } catch (SQLException se) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Drops the sequence table in the DB.\n+     */\n+    public void dropTable()\n+        throws SQLException {\n+        if (_log.isInfoEnabled())\n+            _log.info(_loc.get(\"drop-sch-table\"));\n+\n+        // drop the table\n+        SchemaTool tool = new SchemaTool(_conf);\n+        tool.setIgnoreErrors(true);\n+        tool.dropTable(_pkColumn.getTable());\n+    }\n+\n+    /**\n+     * Returns the schema as an XML string.\n+     */\n+    public String readSchemaColumn()\n+        throws SQLException {\n+        DBDictionary dict = _conf.getDBDictionaryInstance();\n+        SQLBuffer sel = new SQLBuffer(dict).append(_schemaColumn);\n+        SQLBuffer where = new SQLBuffer(dict).append(_pkColumn).append(\" = \").\n+            appendValue(Numbers.valueOf(1), _pkColumn);\n+        SQLBuffer tables = new SQLBuffer(dict).append(_pkColumn.getTable());\n+\n+        SQLBuffer select = dict.toSelect(sel, null, tables, where, null,\n+            null, null, false, false, 0, Long.MAX_VALUE);\n+\n+        Connection conn = getConnection();\n+        PreparedStatement stmnt = null;\n+        ResultSet rs = null;\n+        boolean wasAuto = true;\n+        try {\n+            wasAuto = conn.getAutoCommit();\n+            if (!wasAuto)\n+                conn.setAutoCommit(true);\n+\n+            stmnt = select.prepareStatement(conn);\n+            rs = stmnt.executeQuery();\n+            rs.next();\n+            String schema = (_schemaColumn.getType() == Types.CLOB) ?\n+                dict.getClobString(rs, 1) : dict.getString(rs, 1);\n+            return schema;\n+        } finally {\n+            if (rs != null)\n+                try {\n+                    rs.close();\n+                } catch (SQLException se) {\n+                }\n+            if (stmnt != null)\n+                try {\n+                    stmnt.close();\n+                } catch (SQLException se) {\n+                }\n+            if (!wasAuto)\n+                conn.setAutoCommit(false);\n+            try {\n+                conn.close();\n+            } catch (SQLException se) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Writes the schema as a string to the database.\n+     */\n+    public void writeSchemaColumn(String schema)\n+        throws SQLException {\n+        // always use special clob handling when dict has max embedded size;\n+        // for some reason optimizing for string length causes errors\n+        DBDictionary dict = _conf.getDBDictionaryInstance();\n+        boolean embedded = dict.maxEmbeddedClobSize == -1;\n+        String update;\n+        if (embedded)\n+            update = \"UPDATE \" + dict.getFullName(_pkColumn.getTable(), false)\n+                + \" SET \" + _schemaColumn + \" = ?  WHERE \" + _pkColumn + \" = ?\";\n+        else\n+            update = \"SELECT \" + _schemaColumn + \" FROM \"\n+                + dict.getFullName(_pkColumn.getTable(), false)\n+                + \" WHERE \" + _pkColumn + \" = ?\";\n+\n+        Connection conn = getConnection();\n+        PreparedStatement stmnt = null;\n+        ResultSet rs = null;\n+        boolean wasAuto = true;\n+        try {\n+            // if embedded we want autocommit true, else false\n+            wasAuto = conn.getAutoCommit();\n+            if (wasAuto != embedded)\n+                conn.setAutoCommit(embedded);\n+\n+            if (embedded) {\n+                stmnt = conn.prepareStatement(update);\n+                if (schema == null)\n+                    dict.setNull(stmnt, 1, _schemaColumn.getType(),\n+                        _schemaColumn);\n+                else if (_schemaColumn.getType() == Types.CLOB)\n+                    dict.setClobString(stmnt, 1, schema, _schemaColumn);\n+                else\n+                    dict.setString(stmnt, 1, schema, _schemaColumn);\n+                dict.setInt(stmnt, 2, 1, _pkColumn);\n+                stmnt.executeUpdate();\n+            } else {\n+                stmnt = conn.prepareStatement(update,\n+                    ResultSet.TYPE_SCROLL_INSENSITIVE,\n+                    ResultSet.CONCUR_UPDATABLE);\n+                dict.setInt(stmnt, 1, 1, _pkColumn);\n+                rs = stmnt.executeQuery();\n+                rs.next();\n+                dict.putString(rs.getClob(1), schema);\n+                conn.commit();\n+            }\n+        }\n+        finally {\n+            if (rs != null)\n+                try {\n+                    rs.close();\n+                } catch (SQLException se) {\n+                }\n+            if (stmnt != null)\n+                try {\n+                    stmnt.close();\n+                } catch (SQLException se) {\n+                }\n+            if (wasAuto != embedded)\n+                conn.setAutoCommit(wasAuto);\n+            try {\n+                conn.close();\n+            } catch (SQLException se) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates the object-level representation of the sequence table.\n+     */\n+    private void buildTable() {\n+        String tableName = Strings.getClassName(_table);\n+        String schemaName = Strings.getPackageName(_table);\n+        if (schemaName.length() == 0)\n+            schemaName = Schemas.getNewTableSchema(_conf);\n+\n+        // build the table in one of the designated schemas\n+        SchemaGroup group = new SchemaGroup();\n+        Schema schema = group.addSchema(schemaName);\n+\n+        Table table = schema.addTable(tableName);\n+        PrimaryKey pk = table.addPrimaryKey();\n+\n+        DBDictionary dict = _conf.getDBDictionaryInstance();\n+        _pkColumn = table.addColumn(dict.getValidColumnName\n+            (_pkColumnName, table));\n+        _pkColumn.setType(dict.getPreferredType(Types.TINYINT));\n+        _pkColumn.setJavaType(JavaTypes.INT);\n+        pk.addColumn(_pkColumn);\n+\n+        _schemaColumn = table.addColumn(dict.getValidColumnName\n+            (_schemaColumnName, table));\n+        _schemaColumn.setType(dict.getPreferredType(Types.CLOB));\n+        _schemaColumn.setJavaType(JavaTypes.STRING);\n+    }\n+\n+    /**\n+     * Return a connection to use.\n+     */\n+    private Connection getConnection()\n+        throws SQLException {\n+        return _conf.getDataSource2(null).getConnection();\n+    }\n+\n+    /////////\n+    // Main\n+    /////////\n+\n+    /**\n+     * Usage: java org.apache.openjpa.jdbc.schema.TableSchemaFactory\n+     * [option]* -action/-a &lt;add | drop&gt;\n+     *  Where the following options are recognized.\n+     * <ul>\n+     * <li><i>-properties/-p &lt;properties file or resource&gt;</i>: The\n+     * path or resource name of a OpenJPA properties file containing\n+     * information such as the license key\tand connection data as\n+     * outlined in {@link JDBCConfiguration}. Optional.</li>\n+     * <li><i>-&lt;property name&gt; &lt;property value&gt;</i>: All bean\n+     * properties of the OpenJPA {@link JDBCConfiguration} can be set by\n+     * using their\tnames and supplying a value. For example:\n+     * <code>-licenseKey adslfja83r3lkadf</code></li>\n+     * </ul>\n+     *  The various actions are as follows.\n+     * <ul>\n+     * <li><i>add</i>: Create the schema table.</li>\n+     * <li><i>drop</i>: Drop the schema table.</li>\n+     * </ul>\n+     */\n+    public static void main(String[] args)\n+        throws IOException, SQLException {\n+        Options opts = new Options();\n+        final String[] arguments = opts.setFromCmdLine(args);\n+        boolean ret = Configurations.runAgainstAllAnchors(opts,\n+            new Configurations.Runnable() {\n+            public boolean run(Options opts) throws Exception {\n+                JDBCConfiguration conf = new JDBCConfigurationImpl();\n+                try {\n+                    return TableSchemaFactory.run(conf, arguments, opts);\n+                } finally {\n+                    conf.close();\n+                }\n+            }\n+        });\n+        if (!ret)\n+            System.out.println(_loc.get(\"sch-usage\"));\n+    }\n+\n+    /**\n+     * Run the tool. Returns false if invalid options were given.\n+     *\n+     * @see #main\n+     */\n+    public static boolean run(JDBCConfiguration conf, String[] args,\n+        Options opts)\n+        throws IOException, SQLException {\n+        String action = opts.removeProperty(\"action\", \"a\", null);\n+        Configurations.populateConfiguration(conf, opts);\n+        return run(conf, action);\n+    }\n+\n+    /**\n+     * Run the tool.\n+     */\n+    public static boolean run(JDBCConfiguration conf, String action)\n+        throws IOException, SQLException {\n+        // run the action\n+        TableSchemaFactory factory = new TableSchemaFactory();\n+        String props = Configurations.getProperties(conf.getSchemaFactory());\n+        Configurations.configureInstance(factory, conf, props);\n+\n+        if (ACTION_DROP.equals(action))\n+            factory.dropTable();\n+        else if (ACTION_ADD.equals(action))\n+            factory.refreshTable();\n+        else\n+            return false;\n+        return true;\n+    }\n+}"},{"sha":"3c87191435cf79c021b5631ddab5578b2e16e48f","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Unique.java","status":"added","additions":124,"deletions":0,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Unique.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Unique.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Unique.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.schema;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+/**\n+ * Represents a unique constraint. It can also represent a partial constraint.\n+ *\n+ * @author Abe White\n+ * @author Pinaki Poddar\n+ */\n+public class Unique\n+    extends LocalConstraint {\n+\tprivate boolean _autoNaming = false;\n+    \n+\t/**\n+     * Default constructor without a name.\n+     * Implies that this constraint will auto-generate its name from the names \n+     * of its columns, unless later the name is set explicitly.\n+     */\n+    public Unique() {\n+    \t_autoNaming = true;\n+    }\n+\n+    /**\n+     * Construct with given name.\n+     * Implies that this constraint will not auto-generate its name.\n+     * \n+     * @param name the name of the constraint, if any\n+     * @param table the table of the constraint\n+     */\n+    public Unique(String name, Table table) {\n+        super(name, table);\n+    \t_autoNaming = false;\n+    }\n+\n+    public boolean isLogical() {\n+        return false;\n+    }\n+    \n+    /**\n+     * Adds the given column. \n+     * The added column is set to non-nullable because a unique constraint\n+     * on the database requires that its constituent columns are NOT NULL. \n+     * @see Column#setNotNull(boolean)\n+     */\n+    public void addColumn(Column col) {\n+    \tsuper.addColumn(col);\n+    \tcol.setNotNull(true);\n+    }\n+    \n+    /**\n+     * Set the name of the constraint. This method cannot be called if the\n+     * constraint already belongs to a table. Calling this method also has the\n+     * side-effect of implying that the instance will not auto-generate its\n+     * name.\n+     */\n+    public void setName(String name) {\n+        super.setName(name);\n+        _autoNaming = false;\n+    }\n+    \n+    /**\n+     * Gets the name of the constraint. If no name has been set by the user\n+     * then this method has the side-effect of auto-generating a name from\n+     * the name of its columns.\n+     */\n+    public String getName() {\n+    \tif (getTable() == null && _autoNaming) {\n+    \t\tsetName(createAutoName());\n+    \t\t_autoNaming = true;\n+    \t}\n+    \treturn super.getName();\n+    }\n+\n+    /**\n+     * Return true if the structure of this primary key matches that of\n+     * the given one (same table, same columns).\n+     */\n+    public boolean equalsUnique(Unique unq) {\n+        return equalsLocalConstraint(unq);\n+    }\n+\n+    /*\n+     * Affirms if this instance is currently generating its own name. No \n+     * mutator because auto-naming is switched off as side-effect of user \n+     * calling setName() directly. \n+     */\n+\tpublic boolean isAutoNaming() {\n+\t\treturn _autoNaming;\n+\t}\n+\t\n+\tprivate String createAutoName() {\n+\t\tColumn[] columns = getColumns();\n+\t\tint l = 32/Math.max(columns.length,1);\n+\t\tStringBuffer autoName = new StringBuffer(\"UNQ_\");\n+\t\tfor (Column column : columns)\n+\t\t\tautoName.append(chop(column.getName(),l));\n+\t\treturn autoName.toString();\n+\t}\n+\t\n+    private String chop(String name, int head) {\n+    \tif (StringUtils.isEmpty(name))\n+    \t\treturn name;\n+    \treturn name.substring(0, Math.min(Math.max(1,head), name.length()));\n+    }\n+}"},{"sha":"c2d293215d9a8a9c20a0ed8f170cc77494caca06","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaParser.java","status":"added","additions":618,"deletions":0,"changes":618,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaParser.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaParser.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.schema;\n+\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+\n+import org.xml.sax.Attributes;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.lib.meta.XMLMetaDataParser;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Localizer.Message;\n+import org.apache.openjpa.util.UserException;\n+\n+import serp.util.Numbers;\n+\n+/**\n+ * Custom SAX parser used to parse {@link Schema} objects. The parser\n+ * will place all parsed schemas into the current {@link SchemaGroup}, set\n+ * via the {@link #setSchemaGroup} method. This allows parsing of\n+ * multiple files into a single schema group.\n+ *  The parser deserializes from the following XML format:<br />\n+ * <code> &lt;!ELEMENT schemas (schema)+&gt;<br />\n+ * &lt;!ELEMENT schema (table|sequence)+&gt;<br />\n+ * &lt;!ATTLIST schema name CDATA #IMPLIED&gt;<br />\n+ * &lt;!ELEMENT table (column|index|pk|fk|unique)+&gt;<br />\n+ * &lt;!ATTLIST table name CDATA #REQUIRED&gt;<br />\n+ * &lt;!ELEMENT column EMPTY&gt;<br />\n+ * &lt;!ATTLIST column name CDATA #REQUIRED&gt;<br />\n+ * &lt;!ATTLIST column type (array|bigint|binary|bit|blob|char|clob\n+ * |date|decimal|distinct|double|float|integer|java_object\n+ * |longvarbinary|longvarchar|null|numeric|other|real|ref|smallint|struct\n+ * |time|timstamp|tinyint|varbinary|varchar) #REQUIRED&gt;<br />\n+ * &lt;!ATTLIST column type-name CDATA #IMPLIED&gt;<br />\n+ * &lt;!ATTLIST column size CDATA #IMPLIED&gt;<br />\n+ * &lt;!ATTLIST column decimal-digits CDATA #IMPLIED&gt;<br />\n+ * &lt;!ATTLIST column not-null (true|false) \"false\"&gt;<br />\n+ * &lt;!ATTLIST column default CDATA #IMPLIED&gt;<br />\n+ * &lt;!ATTLIST column auto-assign (true|false) \"false\"&gt;<br />\n+ * &lt;!ELEMENT index (on)*&gt;<br />\n+ * &lt;!ATTLIST index name CDATA #REQUIRED&gt;<br />\n+ * &lt;!ATTLIST index column CDATA #IMPLIED&gt;<br />\n+ * &lt;!ATTLIST index unique (true|false) \"false\"&gt;<br />\n+ * &lt;!ELEMENT on EMPTY&gt;<br />\n+ * &lt;!ATTLIST on column CDATA #REQUIRED&gt;<br />\n+ * &lt;!ELEMENT pk (on)*&gt;<br /> &lt;!ATTLIST pk name CDATA #IMPLIED&gt;<br />\n+ * &lt;!ATTLIST pk column CDATA #IMPLIED&gt;<br />\n+ * &lt;!ELEMENT fk (join)*&gt;<br />\n+ * &lt;!ATTLIST fk name CDATA #IMPLIED&gt;<br />\n+ * &lt;!ATTLIST fk deferred (true|false) \"false\"&gt;<br />\n+ * &lt;!ATTLIST fk column CDATA #IMPLIED&gt;<br />\n+ * &lt;!ATTLIST fk to-table CDATA #REQUIRED&gt;<br />\n+ * &lt;!ATTLIST fk delete-action (cascade|default|restrict|none|null)\n+ * \"none\"&gt;<br />\n+ * &lt;!ATTLIST fk update-action (cascade|default|restrict|none|null)\n+ * \"none\"&gt;<br /> &lt;!ELEMENT unique (on)*&gt;<br />\n+ * &lt;!ATTLIST unique name CDATA #IMPLIED&gt;<br />\n+ * &lt;!ATTLIST unique column CDATA #IMPLIED&gt;<br />\n+ * &lt;!ATTLIST unique deferred (true|false) \"false\"&gt;<br />\n+ * &lt;!ELEMENT join EMPTY&gt;<br />\n+ * &lt;!ATTLIST join column CDATA #IMPLIED&gt;<br />\n+ * &lt;!ATTLIST join value CDATA #IMPLIED&gt;<br />\n+ * &lt;!ATTLIST join to-column CDATA #REQUIRED&gt;<br />\n+ * &lt;!ELEMENT sequence EMPTY&gt;<br />\n+ * &lt;!ATTLIST sequence name CDATA #REQUIRED&gt;<br />\n+ * &lt;!ATTLIST sequence initial-value CDATA #IMPLIED&gt;<br />\n+ * &lt;!ATTLIST sequence increment CDATA #IMPLIED&gt;<br />\n+ * &lt;!ATTLIST sequence allocate CDATA #IMPLIED&gt;<br />\n+ * </code>\n+ *  Schema parsers are not threadsafe.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class XMLSchemaParser\n+    extends XMLMetaDataParser\n+    implements SchemaParser {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (XMLSchemaParser.class);\n+\n+    private final DBDictionary _dict;\n+\n+    // state for current parse\n+    private SchemaGroup _group = null;\n+    private Schema _schema = null;\n+    private Table _table = null;\n+    private PrimaryKeyInfo _pk = null;\n+    private IndexInfo _index = null;\n+    private UniqueInfo _unq = null;\n+    private ForeignKeyInfo _fk = null;\n+    private boolean _delay = false;\n+\n+    // used to collect info on schema elements before they're resolved\n+    private final Collection _pkInfos = new LinkedList();\n+    private final Collection _indexInfos = new LinkedList();\n+    private final Collection _unqInfos = new LinkedList();\n+    private final Collection _fkInfos = new LinkedList();\n+\n+    /**\n+     * Constructor. Supply configuration.\n+     */\n+    public XMLSchemaParser(JDBCConfiguration conf) {\n+        _dict = conf.getDBDictionaryInstance();\n+        setLog(conf.getLog(JDBCConfiguration.LOG_SCHEMA));\n+        setParseText(false);\n+        setSuffix(\".schema\");\n+    }\n+\n+    public boolean getDelayConstraintResolve() {\n+        return _delay;\n+    }\n+\n+    public void setDelayConstraintResolve(boolean delay) {\n+        _delay = delay;\n+    }\n+\n+    public void resolveConstraints() {\n+        resolvePrimaryKeys();\n+        resolveIndexes();\n+        resolveForeignKeys();\n+        resolveUniques();\n+        clearConstraintInfo();\n+    }\n+\n+    /**\n+     * Clear constraint infos.\n+     */\n+    private void clearConstraintInfo() {\n+        _pkInfos.clear();\n+        _indexInfos.clear();\n+        _fkInfos.clear();\n+        _unqInfos.clear();\n+    }\n+\n+    public SchemaGroup getSchemaGroup() {\n+        if (_group == null)\n+            _group = new SchemaGroup();\n+        return _group;\n+    }\n+\n+    public void setSchemaGroup(SchemaGroup group) {\n+        _group = group;\n+    }\n+\n+    /**\n+     * Parse the schema relating to the given class. The schemas will\n+     * be added to the current schema group.\n+     */\n+    protected void finish() {\n+        // now resolve pk, idx, fk info\n+        super.finish();\n+        if (!_delay)\n+            resolveConstraints();\n+    }\n+\n+    /**\n+     * Transforms the collected primary key information into actual\n+     * primary keys on the schema tables.\n+     */\n+    private void resolvePrimaryKeys() {\n+        PrimaryKeyInfo pkInfo;\n+        String colName;\n+        Column col;\n+        for (Iterator itr = _pkInfos.iterator(); itr.hasNext();) {\n+            pkInfo = (PrimaryKeyInfo) itr.next();\n+            for (Iterator cols = pkInfo.cols.iterator(); cols.hasNext();) {\n+                colName = (String) cols.next();\n+                col = pkInfo.pk.getTable().getColumn(colName);\n+                if (col == null)\n+                    throwUserException(_loc.get(\"pk-resolve\", new Object[]\n+                        { colName, pkInfo.pk.getTable() }));\n+                pkInfo.pk.addColumn(col);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Transforms the collected index information into actual\n+     * indexes on the schema tables.\n+     */\n+    private void resolveIndexes() {\n+        IndexInfo indexInfo;\n+        String colName;\n+        Column col;\n+        for (Iterator itr = _indexInfos.iterator(); itr.hasNext();) {\n+            indexInfo = (IndexInfo) itr.next();\n+            for (Iterator cols = indexInfo.cols.iterator(); cols.hasNext();) {\n+                colName = (String) cols.next();\n+                col = indexInfo.index.getTable().getColumn(colName);\n+                if (col == null)\n+                    throwUserException(_loc.get(\"index-resolve\", new Object[]\n+                        { indexInfo.index, colName,\n+                            indexInfo.index.getTable() }));\n+                indexInfo.index.addColumn(col);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Transforms the collected foreign key information into actual\n+     * foreign keys on the schema tables.\n+     */\n+    private void resolveForeignKeys() {\n+        ForeignKeyInfo fkInfo;\n+        Table toTable;\n+        Column col;\n+        String colName;\n+        Column pkCol;\n+        String pkColName;\n+        PrimaryKey pk;\n+        Iterator pks;\n+        Iterator cols;\n+        for (Iterator itr = _fkInfos.iterator(); itr.hasNext();) {\n+            fkInfo = (ForeignKeyInfo) itr.next();\n+            toTable = _group.findTable(fkInfo.toTable);\n+            if (toTable == null || toTable.getPrimaryKey() == null)\n+                throwUserException(_loc.get(\"fk-totable\", new Object[]\n+                    { fkInfo.fk, fkInfo.toTable, fkInfo.fk.getTable() }));\n+\n+            // check if only one fk column listed using shortcut\n+            pk = toTable.getPrimaryKey();\n+            if (fkInfo.cols.size() == 1 && fkInfo.pks.size() == 0)\n+                fkInfo.pks.add(pk.getColumns()[0].getName());\n+\n+            // make joins\n+            pks = fkInfo.pks.iterator();\n+            for (cols = fkInfo.cols.iterator(); cols.hasNext();) {\n+                colName = (String) cols.next();\n+                col = fkInfo.fk.getTable().getColumn(colName);\n+                if (col == null)\n+                    throwUserException(_loc.get(\"fk-nocol\",\n+                        fkInfo.fk, colName, fkInfo.fk.getTable()));\n+\n+                pkColName = (String) pks.next();\n+                pkCol = toTable.getColumn(pkColName);\n+                if (pkCol == null)\n+                    throwUserException(_loc.get(\"fk-nopkcol\", new Object[]\n+                        { fkInfo.fk, pkColName, toTable,\n+                            fkInfo.fk.getTable() }));\n+\n+                fkInfo.fk.join(col, pkCol);\n+            }\n+\n+            // make constant joins\n+            cols = fkInfo.constCols.iterator();\n+            for (Iterator vals = fkInfo.consts.iterator(); vals.hasNext();) {\n+                colName = (String) cols.next();\n+                col = fkInfo.fk.getTable().getColumn(colName);\n+                if (col == null)\n+                    throwUserException(_loc.get(\"fk-nocol\",\n+                        fkInfo.fk, colName, fkInfo.fk.getTable()));\n+\n+                fkInfo.fk.joinConstant(col, vals.next());\n+            }\n+\n+            pks = fkInfo.constColsPK.iterator();\n+            for (Iterator vals = fkInfo.constsPK.iterator(); vals.hasNext();) {\n+                pkColName = (String) pks.next();\n+                pkCol = toTable.getColumn(pkColName);\n+                if (pkCol == null)\n+                    throwUserException(_loc.get(\"fk-nopkcol\", new Object[]\n+                        { fkInfo.fk, pkColName, toTable,\n+                            fkInfo.fk.getTable() }));\n+\n+                fkInfo.fk.joinConstant(vals.next(), pkCol);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Transforms the collected unique constraint information into actual\n+     * constraints on the schema tables.\n+     */\n+    private void resolveUniques() {\n+        UniqueInfo unqInfo;\n+        String colName;\n+        Column col;\n+        for (Iterator itr = _unqInfos.iterator(); itr.hasNext();) {\n+            unqInfo = (UniqueInfo) itr.next();\n+            for (Iterator cols = unqInfo.cols.iterator(); cols.hasNext();) {\n+                colName = (String) cols.next();\n+                col = unqInfo.unq.getTable().getColumn(colName);\n+                if (col == null)\n+                    throwUserException(_loc.get(\"unq-resolve\", new Object[]\n+                        { unqInfo.unq, colName, unqInfo.unq.getTable() }));\n+                unqInfo.unq.addColumn(col);\n+            }\n+        }\n+    }\n+\n+    protected void reset() {\n+        _schema = null;\n+        _table = null;\n+        _pk = null;\n+        _index = null;\n+        _fk = null;\n+        _unq = null;\n+        if (!_delay)\n+            clearConstraintInfo();\n+    }\n+\n+    protected Reader getDocType()\n+        throws IOException {\n+        return new InputStreamReader(XMLSchemaParser.class\n+            .getResourceAsStream(\"schemas-doctype.rsrc\"));\n+    }\n+\n+    protected boolean startElement(String name, Attributes attrs)\n+        throws SAXException {\n+        switch (name.charAt(0)) {\n+            case's':\n+                if (\"schema\".equals(name))\n+                    startSchema(attrs);\n+                else if (\"sequence\".equals(name))\n+                    startSequence(attrs);\n+                return true;\n+            case't':\n+                startTable(attrs);\n+                return true;\n+            case'c':\n+                startColumn(attrs);\n+                return true;\n+            case'p':\n+                startPrimaryKey(attrs);\n+                return true;\n+            case'i':\n+                startIndex(attrs);\n+                return true;\n+            case'u':\n+                startUnique(attrs);\n+                return true;\n+            case'f':\n+                startForeignKey(attrs);\n+                return true;\n+            case'o':\n+                startOn(attrs);\n+                return true;\n+            case'j':\n+                startJoin(attrs);\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    protected void endElement(String name) {\n+        switch (name.charAt(0)) {\n+            case's':\n+                if (\"schema\".equals(name))\n+                    endSchema();\n+                break;\n+            case't':\n+                endTable();\n+                break;\n+            case'p':\n+                endPrimaryKey();\n+                break;\n+            case'i':\n+                endIndex();\n+                break;\n+            case'u':\n+                endUnique();\n+                break;\n+            case'f':\n+                endForeignKey();\n+                break;\n+        }\n+    }\n+\n+    private void startSchema(Attributes attrs) {\n+        // creates group if not set\n+        SchemaGroup group = getSchemaGroup();\n+\n+        String name = attrs.getValue(\"name\");\n+        _schema = group.getSchema(name);\n+        if (_schema == null)\n+            _schema = group.addSchema(name);\n+    }\n+\n+    private void endSchema() {\n+        _schema = null;\n+    }\n+\n+    private void startSequence(Attributes attrs) {\n+        Sequence seq = _schema.addSequence(attrs.getValue(\"name\"));\n+        Locator locator = getLocation().getLocator();\n+        if (locator != null) {\n+            seq.setLineNumber(Numbers.valueOf(locator.getLineNumber()));\n+            seq.setColNumber(Numbers.valueOf(locator.getColumnNumber()));\n+        }\n+        seq.setSource(getSourceFile(), seq.SRC_XML);\n+        try {\n+            String val = attrs.getValue(\"initial-value\");\n+            if (val != null)\n+                seq.setInitialValue(Integer.parseInt(val));\n+            val = attrs.getValue(\"increment\");\n+            if (val != null)\n+                seq.setIncrement(Integer.parseInt(val));\n+            val = attrs.getValue(\"allocate\");\n+            if (val != null)\n+                seq.setAllocate(Integer.parseInt(val));\n+        } catch (NumberFormatException nfe) {\n+            throwUserException(_loc.get(\"bad-seq-num\", seq.getFullName()));\n+        }\n+    }\n+\n+    private void startTable(Attributes attrs) {\n+        _table = _schema.addTable(attrs.getValue(\"name\"));\n+        _table.setSource(getSourceFile(), _table.SRC_XML);\n+        Locator locator = getLocation().getLocator();\n+        if (locator != null) {\n+            _table.setLineNumber(Numbers.valueOf(locator.getLineNumber()));\n+            _table.setColNumber(Numbers.valueOf(locator.getColumnNumber()));\n+        }\n+    }\n+\n+    private void endTable() {\n+        _table = null;\n+    }\n+\n+    private void startColumn(Attributes attrs) {\n+        Column col = _table.addColumn(attrs.getValue(\"name\"));\n+        col.setType(_dict.getPreferredType(Schemas.getJDBCType\n+            (attrs.getValue(\"type\"))));\n+        col.setTypeName(attrs.getValue(\"type-name\"));\n+        String val = attrs.getValue(\"size\");\n+        if (val != null)\n+            col.setSize(Integer.parseInt(val));\n+        val = attrs.getValue(\"decimal-digits\");\n+        if (val != null)\n+            col.setDecimalDigits(Integer.parseInt(val));\n+        col.setNotNull(\"true\".equals(attrs.getValue(\"not-null\")));\n+        col.setAutoAssigned(\"true\".equals(attrs.getValue(\"auto-assign\"))\n+            || \"true\".equals(attrs.getValue(\"auto-increment\"))); // old attr\n+        col.setDefaultString(attrs.getValue(\"default\"));\n+    }\n+\n+    private void startPrimaryKey(Attributes attrs) {\n+        _pk = new PrimaryKeyInfo();\n+        _pk.pk = _table.addPrimaryKey(attrs.getValue(\"name\"));\n+        _pk.pk.setLogical(\"true\".equals(attrs.getValue(\"logical\")));\n+\n+        String val = attrs.getValue(\"column\");\n+        if (val != null)\n+            _pk.cols.add(val);\n+    }\n+\n+    private void endPrimaryKey() {\n+        _pkInfos.add(_pk);\n+        _pk = null;\n+    }\n+\n+    private void startIndex(Attributes attrs) {\n+        _index = new IndexInfo();\n+        _index.index = _table.addIndex(attrs.getValue(\"name\"));\n+        _index.index.setUnique(\"true\".equals(attrs.getValue(\"unique\")));\n+\n+        String val = attrs.getValue(\"column\");\n+        if (val != null)\n+            _index.cols.add(val);\n+    }\n+\n+    private void endIndex() {\n+        _indexInfos.add(_index);\n+        _index = null;\n+    }\n+\n+    private void startUnique(Attributes attrs) {\n+        _unq = new UniqueInfo();\n+        _unq.unq = _table.addUnique(attrs.getValue(\"name\"));\n+        _unq.unq.setDeferred(\"true\".equals(attrs.getValue(\"deferred\")));\n+\n+        String val = attrs.getValue(\"column\");\n+        if (val != null)\n+            _unq.cols.add(val);\n+    }\n+\n+    private void endUnique() {\n+        _unqInfos.add(_unq);\n+        _unq = null;\n+    }\n+\n+    private void startForeignKey(Attributes attrs) {\n+        _fk = new ForeignKeyInfo();\n+        _fk.fk = _table.addForeignKey(attrs.getValue(\"name\"));\n+\n+        if (\"true\".equals(attrs.getValue(\"deferred\")))\n+            _fk.fk.setDeferred(true);\n+\n+        // set update action before delete action in case user incorrectly\n+        // sets update-action to \"none\" when there is a delete-action; otherwise\n+        // setting the update-action to \"none\" will also automatically set the\n+        // delete-action to \"none\", since FKs cannot have one actio be none and\n+        // the other be non-none\n+        String action = attrs.getValue(\"update-action\");\n+        if (action != null)\n+            _fk.fk.setUpdateAction(ForeignKey.getAction(action));\n+        action = attrs.getValue(\"delete-action\");\n+        if (action != null)\n+            _fk.fk.setDeleteAction(ForeignKey.getAction(action));\n+\n+        _fk.toTable = attrs.getValue(\"to-table\");\n+        String val = attrs.getValue(\"column\");\n+        if (val != null)\n+            _fk.cols.add(val);\n+    }\n+\n+    private void endForeignKey() {\n+        _fkInfos.add(_fk);\n+        _fk = null;\n+    }\n+\n+    private void startOn(Attributes attrs) {\n+        String col = attrs.getValue(\"column\");\n+        if (_pk != null)\n+            _pk.cols.add(col);\n+        else if (_index != null)\n+            _index.cols.add(col);\n+        else\n+            _unq.cols.add(col);\n+    }\n+\n+    private void startJoin(Attributes attrs) {\n+        String col = attrs.getValue(\"column\");\n+        String toCol = attrs.getValue(\"to-column\");\n+        String val = attrs.getValue(\"value\");\n+        if (val == null) {\n+            _fk.cols.add(col);\n+            _fk.pks.add(toCol);\n+        } else if (col == null) {\n+            _fk.constsPK.add(convertConstant(val));\n+            _fk.constColsPK.add(toCol);\n+        } else {\n+            _fk.consts.add(convertConstant(val));\n+            _fk.constCols.add(col);\n+        }\n+    }\n+\n+    private static Object convertConstant(String val) {\n+        if (\"null\".equals(val))\n+            return null;\n+        if (val.startsWith(\"'\"))\n+            return val.substring(1, val.length() - 1);\n+        if (val.indexOf('.') == -1)\n+            return new Long(val);\n+        return new Double(val);\n+    }\n+\n+    private void throwUserException(Message msg) {\n+        throw new UserException(getSourceName() + \": \" + msg.getMessage());\n+    }\n+\n+    /**\n+     * Used to hold primary key info before it is resolved.\n+     */\n+    private static class PrimaryKeyInfo {\n+\n+        public PrimaryKey pk = null;\n+        public Collection cols = new LinkedList();\n+    }\n+\n+    /**\n+     * Used to hold index info before it is resolved.\n+     */\n+    private static class IndexInfo {\n+\n+        public Index index = null;\n+        public Collection cols = new LinkedList();\n+    }\n+\n+    /**\n+     * Used to hold unique constraint info before it is resolved.\n+     */\n+    public static class UniqueInfo {\n+\n+        public Unique unq = null;\n+        public Collection cols = new LinkedList();\n+    }\n+\n+    /**\n+     * Used to hold foreign key info before it is resolved.\n+     */\n+    private static class ForeignKeyInfo {\n+\n+        public ForeignKey fk = null;\n+        public String toTable = null;\n+        public Collection cols = new LinkedList();\n+        public Collection pks = new LinkedList();\n+        public Collection consts = new LinkedList();\n+        public Collection constCols = new LinkedList();\n+        public Collection constsPK = new LinkedList();\n+        public Collection constColsPK = new LinkedList();\n+    }\n+}"},{"sha":"37dc91d3112f598d1869dc89b97bf55fdfa84a7a","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaSerializer.java","status":"added","additions":446,"deletions":0,"changes":446,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaSerializer.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,446 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.schema;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.lib.meta.XMLMetaDataSerializer;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.xml.sax.SAXException;\n+\n+/**\n+ * Serializes {@link Schema}s to XML matching the document\n+ * type definition defined by the {@link XMLSchemaParser}. The serializer\n+ * actually works at the fine-grained table level to allow you to split\n+ * schemas among multiple files.\n+ *  Serializers are not thread safe.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class XMLSchemaSerializer\n+    extends XMLMetaDataSerializer\n+    implements SchemaSerializer {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (XMLSchemaSerializer.class);\n+\n+    private final Collection _tables = new TreeSet();\n+    private final Collection _seqs = new TreeSet();\n+\n+    /**\n+     * Constructor. Supply configuration.\n+     */\n+    public XMLSchemaSerializer(JDBCConfiguration conf) {\n+        setLog(conf.getLog(JDBCConfiguration.LOG_SCHEMA));\n+    }\n+\n+    public Table[] getTables() {\n+        return (Table[]) _tables.toArray(new Table[_tables.size()]);\n+    }\n+\n+    public void addTable(Table table) {\n+        if (table != null)\n+            _tables.add(table);\n+    }\n+\n+    public boolean removeTable(Table table) {\n+        return _tables.remove(table);\n+    }\n+\n+    public Sequence[] getSequences() {\n+        return (Sequence[]) _seqs.toArray(new Sequence[_seqs.size()]);\n+    }\n+\n+    public void addSequence(Sequence seq) {\n+        if (seq != null)\n+            _seqs.add(seq);\n+    }\n+\n+    public boolean removeSequence(Sequence seq) {\n+        return _seqs.remove(seq);\n+    }\n+\n+    public void addAll(Schema schema) {\n+        if (schema == null)\n+            return;\n+        Table[] tables = schema.getTables();\n+        for (int i = 0; i < tables.length; i++)\n+            addTable(tables[i]);\n+        Sequence[] seqs = schema.getSequences();\n+        for (int i = 0; i < seqs.length; i++)\n+            addSequence(seqs[i]);\n+    }\n+\n+    public void addAll(SchemaGroup group) {\n+        if (group == null)\n+            return;\n+        Schema[] schemas = group.getSchemas();\n+        for (int i = 0; i < schemas.length; i++)\n+            addAll(schemas[i]);\n+    }\n+\n+    public boolean removeAll(Schema schema) {\n+        if (schema == null)\n+            return false;\n+\n+        boolean removed = false;\n+        Table[] tables = schema.getTables();\n+        for (int i = 0; i < tables.length; i++)\n+            removed |= removeTable(tables[i]);\n+        Sequence[] seqs = schema.getSequences();\n+        for (int i = 0; i < seqs.length; i++)\n+            removed |= removeSequence(seqs[i]);\n+        return removed;\n+    }\n+\n+    public boolean removeAll(SchemaGroup group) {\n+        if (group == null)\n+            return false;\n+\n+        boolean removed = false;\n+        Schema[] schemas = group.getSchemas();\n+        for (int i = 0; i < schemas.length; i++)\n+            removed |= removeAll(schemas[i]);\n+        return removed;\n+    }\n+\n+    public void clear() {\n+        _tables.clear();\n+        _seqs.clear();\n+    }\n+\n+    protected Collection getObjects() {\n+        if (_seqs.isEmpty())\n+            return _tables;\n+        if (_tables.isEmpty())\n+            return _seqs;\n+        List all = new ArrayList(_seqs.size() + _tables.size());\n+        all.addAll(_seqs);\n+        all.addAll(_tables);\n+        return all;\n+    }\n+\n+    protected void serialize(Collection objs)\n+        throws SAXException {\n+        // group the objects by schema\n+        Map schemas = new HashMap();\n+        String schemaName;\n+        Collection schemaObjs;\n+        Object obj;\n+        for (Iterator itr = objs.iterator(); itr.hasNext();) {\n+            obj = itr.next();\n+            if (obj instanceof Table)\n+                schemaName = ((Table) obj).getSchemaName();\n+            else\n+                schemaName = ((Sequence) obj).getSchemaName();\n+            schemaObjs = (Collection) schemas.get(schemaName);\n+            if (schemaObjs == null) {\n+                schemaObjs = new LinkedList();\n+                schemas.put(schemaName, schemaObjs);\n+            }\n+            schemaObjs.add(obj);\n+        }\n+\n+        startElement(\"schemas\");\n+        Map.Entry entry;\n+        for (Iterator itr = schemas.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            serializeSchema((String) entry.getKey(), (Collection)\n+                entry.getValue());\n+        }\n+        endElement(\"schemas\");\n+    }\n+\n+    /**\n+     * Serializes the given objects together into the current schema.\n+     */\n+    private void serializeSchema(String name, Collection objs)\n+        throws SAXException {\n+        if (objs.isEmpty())\n+            return;\n+\n+        if (getLog().isTraceEnabled())\n+            getLog().trace(_loc.get(\"ser-schema\", name));\n+\n+        if (name != null)\n+            addAttribute(\"name\", name);\n+        startElement(\"schema\");\n+\n+        // tables and seqs\n+        Object obj;\n+        for (Iterator itr = objs.iterator(); itr.hasNext();) {\n+            obj = itr.next();\n+            if (obj instanceof Table)\n+                serializeTable((Table) obj);\n+            else\n+                serializeSequence((Sequence) obj);\n+        }\n+\n+        endElement(\"schema\");\n+    }\n+\n+    /**\n+     * Serialize the given sequence.\n+     */\n+    private void serializeSequence(Sequence seq)\n+        throws SAXException {\n+        addAttribute(\"name\", seq.getName());\n+        if (seq.getInitialValue() != 1)\n+            addAttribute(\"initial-value\",\n+                String.valueOf(seq.getInitialValue()));\n+        if (seq.getIncrement() > 1)\n+            addAttribute(\"increment\", String.valueOf(seq.getIncrement()));\n+        if (seq.getAllocate() > 1)\n+            addAttribute(\"allocate\", String.valueOf(seq.getAllocate()));\n+        startElement(\"sequence\");\n+        endElement(\"sequence\");\n+    }\n+\n+    /**\n+     * Serializes the given table.\n+     */\n+    private void serializeTable(Table table)\n+        throws SAXException {\n+        addAttribute(\"name\", table.getName());\n+        startElement(\"table\");\n+\n+        // primary key\n+        PrimaryKey pk = table.getPrimaryKey();\n+        if (pk != null)\n+            serializePrimaryKey(pk);\n+\n+        // columns\n+        Column[] cols = table.getColumns();\n+        for (int i = 0; i < cols.length; i++)\n+            serializeColumn(cols[i]);\n+\n+        // foreign keys\n+        ForeignKey[] fks = table.getForeignKeys();\n+        for (int i = 0; i < fks.length; i++)\n+            serializeForeignKey(fks[i]);\n+\n+        // indexes\n+        Index[] idxs = table.getIndexes();\n+        for (int i = 0; i < idxs.length; i++)\n+            serializeIndex(idxs[i]);\n+\n+        // unique constraints\n+        Unique[] unqs = table.getUniques();\n+        for (int i = 0; i < unqs.length; i++)\n+            serializeUnique(unqs[i]);\n+\n+        endElement(\"table\");\n+    }\n+\n+    /**\n+     * Serializes the given column.\n+     */\n+    private void serializeColumn(Column col)\n+        throws SAXException {\n+        addAttribute(\"name\", col.getName());\n+        addAttribute(\"type\", Schemas.getJDBCName(col.getType()));\n+        if (!StringUtils.isEmpty(col.getTypeName())\n+            && !col.getTypeName().equalsIgnoreCase\n+            (Schemas.getJDBCName(col.getType())))\n+            addAttribute(\"type-name\", col.getTypeName());\n+        if (col.isNotNull())\n+            addAttribute(\"not-null\", \"true\");\n+        if (col.isAutoAssigned())\n+            addAttribute(\"auto-assign\", \"true\");\n+        if (col.getDefaultString() != null)\n+            addAttribute(\"default\", col.getDefaultString());\n+        if (col.getSize() != 0)\n+            addAttribute(\"size\", String.valueOf(col.getSize()));\n+        if (col.getDecimalDigits() != 0)\n+            addAttribute(\"decimal-digits\", String.valueOf\n+                (col.getDecimalDigits()));\n+        startElement(\"column\");\n+        endElement(\"column\");\n+    }\n+\n+    /**\n+     * Serializes the given primary key.\n+     */\n+    private void serializePrimaryKey(PrimaryKey pk)\n+        throws SAXException {\n+        if (pk.getName() != null)\n+            addAttribute(\"name\", pk.getName());\n+        if (pk.isLogical())\n+            addAttribute(\"logical\", \"true\");\n+\n+        Column[] cols = pk.getColumns();\n+        if (cols.length == 1)\n+            addAttribute(\"column\", cols[0].getName());\n+        startElement(\"pk\");\n+\n+        // columns\n+        if (cols.length > 1)\n+            for (int i = 0; i < cols.length; i++)\n+                serializeOn(cols[i]);\n+\n+        endElement(\"pk\");\n+    }\n+\n+    /**\n+     * Serializes the given index.\n+     */\n+    private void serializeIndex(Index idx)\n+        throws SAXException {\n+        addAttribute(\"name\", idx.getName());\n+        if (idx.isUnique())\n+            addAttribute(\"unique\", \"true\");\n+        Column[] cols = idx.getColumns();\n+        if (cols.length == 1)\n+            addAttribute(\"column\", cols[0].getName());\n+        startElement(\"index\");\n+\n+        // columns\n+        if (cols.length > 1)\n+            for (int i = 0; i < cols.length; i++)\n+                serializeOn(cols[i]);\n+\n+        endElement(\"index\");\n+    }\n+\n+    /**\n+     * Serializes the given constraint.\n+     */\n+    private void serializeUnique(Unique unq)\n+        throws SAXException {\n+        if (unq.getName() != null)\n+            addAttribute(\"name\", unq.getName());\n+        if (unq.isDeferred())\n+            addAttribute(\"deferred\", \"true\");\n+        Column[] cols = unq.getColumns();\n+        if (cols.length == 1)\n+            addAttribute(\"column\", cols[0].getName());\n+        startElement(\"unique\");\n+\n+        // columns\n+        if (cols.length > 1)\n+            for (int i = 0; i < cols.length; i++)\n+                serializeOn(cols[i]);\n+\n+        endElement(\"unique\");\n+    }\n+\n+    /**\n+     * Serializes the given foreign key.\n+     */\n+    private void serializeForeignKey(ForeignKey fk)\n+        throws SAXException {\n+        if (fk.getName() != null)\n+            addAttribute(\"name\", fk.getName());\n+\n+        if (fk.isDeferred())\n+            addAttribute(\"deferred\", \"true\");\n+\n+        if (fk.getDeleteAction() != ForeignKey.ACTION_NONE)\n+            addAttribute(\"delete-action\", ForeignKey.getActionName\n+                (fk.getDeleteAction()));\n+        if (fk.getUpdateAction() != ForeignKey.ACTION_NONE\n+            && fk.getUpdateAction() != ForeignKey.ACTION_RESTRICT)\n+            addAttribute(\"update-action\", ForeignKey.getActionName\n+                (fk.getUpdateAction()));\n+\n+        Column[] cols = fk.getColumns();\n+        Column[] pks = fk.getPrimaryKeyColumns();\n+        Column[] consts = fk.getConstantColumns();\n+        Column[] constsPK = fk.getConstantPrimaryKeyColumns();\n+        addAttribute(\"to-table\", fk.getPrimaryKeyTable().getFullName());\n+        if (cols.length == 1 && consts.length == 0 && constsPK.length == 0)\n+            addAttribute(\"column\", cols[0].getName());\n+        startElement(\"fk\");\n+\n+        // columns\n+        if (cols.length > 1 || consts.length > 0 || constsPK.length > 0)\n+            for (int i = 0; i < cols.length; i++)\n+                serializeJoin(cols[i], pks[i]);\n+        for (int i = 0; i < consts.length; i++)\n+            serializeJoin(consts[i], fk.getConstant(consts[i]));\n+        for (int i = 0; i < constsPK.length; i++)\n+            serializeJoin(fk.getPrimaryKeyConstant(constsPK[i]), constsPK[i]);\n+\n+        endElement(\"fk\");\n+    }\n+\n+    /**\n+     * Serializes the given column to an 'on' element.\n+     */\n+    private void serializeOn(Column col)\n+        throws SAXException {\n+        addAttribute(\"column\", col.getName());\n+        startElement(\"on\");\n+        endElement(\"on\");\n+    }\n+\n+    /**\n+     * Serializes the given columns to a 'join' element.\n+     */\n+    private void serializeJoin(Column col, Column pk)\n+        throws SAXException {\n+        addAttribute(\"column\", col.getName());\n+        addAttribute(\"to-column\", pk.getName());\n+        startElement(\"join\");\n+        endElement(\"join\");\n+    }\n+\n+    /**\n+     * Serializes the given values to a 'join' element.\n+     */\n+    private void serializeJoin(Object val, Column pk)\n+        throws SAXException {\n+        addAttribute(\"value\", stringifyConstant(val));\n+        addAttribute(\"to-column\", pk.getName());\n+        startElement(\"join\");\n+        endElement(\"join\");\n+    }\n+\n+    /**\n+     * Serializes the given values to a 'join' element.\n+     */\n+    private void serializeJoin(Column col, Object val)\n+        throws SAXException {\n+        addAttribute(\"column\", col.getName());\n+        addAttribute(\"value\", stringifyConstant(val));\n+        startElement(\"join\");\n+        endElement(\"join\");\n+    }\n+\n+    /**\n+     * Stringify the given constant value.\n+     */\n+    private static String stringifyConstant(Object val) {\n+        if (val == null)\n+            return \"null\";\n+        if (val instanceof String)\n+            return \"'\" + val + \"'\";\n+        return val.toString();\n+    }\n+}"},{"sha":"6cda3f5014beebb49a87a756d35e59b55af4c73d","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/package.html","status":"added","additions":34,"deletions":0,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/package.html","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/package.html?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,34 @@\n+<!--\n+ Licensed to the Apache Software Foundation (ASF) under one\n+ or more contributor license agreements.  See the NOTICE file\n+ distributed with this work for additional information\n+ regarding copyright ownership.  The ASF licenses this file\n+ to you under the Apache License, Version 2.0 (the\n+ \"License\"); you may not use this file except in compliance\n+ with the License.  You may obtain a copy of the License at\n+ \n+ http://www.apache.org/licenses/LICENSE-2.0\n+ \n+ Unless required by applicable law or agreed to in writing,\n+ software distributed under the License is distributed on an\n+ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ KIND, either express or implied.  See the License for the\n+ specific language governing permissions and limitations\n+ under the License.   \n+-->\n+<html>\n+<body>\n+<p><strong>OpenJPA-JDBC Schema Management</strong></p>\n+\n+<p>\n+    This package provides utilities for managing the schema of\n+    persistent objects stored in a relational database.\n+</p>\n+\n+<p>\n+    Schema components themselves are little more than standard Java beans.\n+    Helper classes are responsible for added functionality such as XML\n+    serialization/deserialization, etc.\n+</p>\n+</body>\n+</html>"},{"sha":"af138d57a1327bb52de4cfa23f0cad144551fa66","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","status":"added","additions":125,"deletions":0,"changes":125,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+\n+/**\n+ * Base dictionary for the IBM DB2 family of databases.\n+ */\n+public abstract class AbstractDB2Dictionary\n+    extends DBDictionary {\n+\n+    public int varcharCastLength = 1000;\n+\n+    public AbstractDB2Dictionary() {\n+        numericTypeName = \"DOUBLE\";\n+        bitTypeName = \"SMALLINT\";\n+        smallintTypeName = \"SMALLINT\";\n+        tinyintTypeName = \"SMALLINT\";\n+        longVarbinaryTypeName = \"BLOB\";\n+        varbinaryTypeName = \"BLOB\";\n+\n+        // DB2-based databases have restrictions on having uncast parameters\n+        // in string functions\n+        toUpperCaseFunction = \"UPPER(CAST({0} AS VARCHAR(\" + varcharCastLength\n+            + \")))\";\n+        toLowerCaseFunction = \"LOWER(CAST({0} AS VARCHAR(\" + varcharCastLength\n+            + \")))\";\n+        stringLengthFunction = \"LENGTH({0})\";\n+        concatenateFunction = \"(CAST({0} AS VARCHAR(\" + varcharCastLength\n+            + \")))||(CAST({1} AS VARCHAR(1000)))\";\n+\n+        trimLeadingFunction = \"LTRIM({0})\";\n+        trimTrailingFunction = \"RTRIM({0})\";\n+        trimBothFunction = \"LTRIM(RTRIM({0}))\";\n+\n+        // in DB2, \"for update\" seems to be ignored with isolation\n+        // levels below REPEATABLE_READ... force isolation to behave like RR\n+        forUpdateClause = \"FOR UPDATE WITH RR\";\n+\n+        supportsLockingWithDistinctClause = false;\n+        supportsLockingWithMultipleTables = false;\n+        supportsLockingWithOrderClause = false;\n+        supportsLockingWithOuterJoin = false;\n+        supportsLockingWithInnerJoin = false;\n+        supportsLockingWithSelectRange = true;\n+\n+        requiresAutoCommitForMetaData = true;\n+        requiresAliasForSubselect = true;\n+\n+        supportsAutoAssign = true;\n+        autoAssignClause = \"GENERATED BY DEFAULT AS IDENTITY\";\n+        lastGeneratedKeyQuery = \"VALUES(IDENTITY_VAL_LOCAL())\";\n+\n+        // DB2 doesn't understand \"X CROSS JOIN Y\", but it does understand\n+        // the equivalent \"X JOIN Y ON 1 = 1\"\n+        crossJoinClause = \"JOIN\";\n+        requiresConditionForCrossJoin = true;\n+    }\n+\n+    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n+        FilterValue start) {\n+        buf.append(\"(LOCATE(CAST((\");\n+        find.appendTo(buf);\n+        buf.append(\") AS VARCHAR(\").append(Integer.toString(varcharCastLength))\n+            .append(\")), CAST((\");\n+        str.appendTo(buf);\n+        buf.append(\") AS VARCHAR(\").append(Integer.toString(varcharCastLength))\n+            .append(\"))\");\n+        if (start != null) {\n+            buf.append(\", CAST((\");\n+            start.appendTo(buf);\n+            buf.append(\") AS INTEGER) + 1\");\n+        }\n+        buf.append(\") - 1)\");\n+    }\n+\n+    public void substring(SQLBuffer buf, FilterValue str, FilterValue start,\n+        FilterValue end) {\n+        buf.append(\"SUBSTR(CAST((\");\n+        str.appendTo(buf);\n+        buf.append(\") AS VARCHAR(\").append(Integer.toString(varcharCastLength))\n+            .append(\")), \");\n+        if (start.getValue() instanceof Number) {\n+            long startLong = toLong(start);\n+            buf.append(Long.toString(startLong + 1));\n+        } else {\n+            buf.append(\"CAST((\");\n+            start.appendTo(buf);\n+            buf.append(\") AS INTEGER) + 1\");\n+        }\n+        if (end != null) {\n+            buf.append(\", \");\n+            if (start.getValue() instanceof Number\n+                && end.getValue() instanceof Number) {\n+                long startLong = toLong(start);\n+                long endLong = toLong(end);\n+                buf.append(Long.toString(endLong - startLong));\n+            } else {\n+                buf.append(\"CAST((\");\n+                end.appendTo(buf);\n+                buf.append(\") AS INTEGER) - CAST((\");\n+                start.appendTo(buf);\n+                buf.append(\") AS INTEGER)\");\n+            }\n+        }\n+        buf.append(\")\");\n+    }\n+}"},{"sha":"6e6f3edfead2b7735f5ef0ea71b66ba1d827a7f3","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractResult.java","status":"added","additions":888,"deletions":0,"changes":888,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractResult.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractResult.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractResult.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,888 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Ref;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.kernel.JDBCStoreManager;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.lib.util.Closeable;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.UnsupportedException;\n+\n+import serp.util.Strings;\n+\n+/**\n+ * A {@link Result} implementation designed to be subclassed easily by\n+ * implementations. All <code>get&lt;type&gt;</code> calls are delegated to\n+ * the {@link #getObjectInternal(Object,int,Object,Joins)} method, which\n+ * should be implemented by subclasses along with {@link #nextInternal},\n+ * {@link #containsInternal}, and {@link Result#size}.\n+ *  Most of the methods of this class will accept return values from\n+ * {@link #getObjectInternal(Object,int,Object,Joins)} that are not exactly\n+ * the right type. For example, any numeric type can be returned as any\n+ * {@link Number} type, and dates, locales, characters, and booleans can be\n+ * returned as strings.\n+ *\n+ * @author Abe White\n+ * @see ResultSetResult\n+ */\n+public abstract class AbstractResult\n+    implements Result {\n+\n+    private static final Joins JOINS = new NoOpJoins();\n+\n+    private Map _eager = null;\n+    private ClassMapping _base = null;\n+    private int _index = 0;\n+    private boolean _gotEager = false;\n+    private boolean _wasNull = false;\n+    private boolean _locking = false;\n+    private boolean _ignoreNext = false;\n+    private boolean _last = false;\n+    private FieldMapping _mappedByFieldMapping = null;\n+    private Object _mappedByValue = null;\n+\n+    public Object getEager(FieldMapping key) {\n+        Map map = getEagerMap(true);\n+        return (map == null) ? null : map.get(key);\n+    }\n+\n+    public void putEager(FieldMapping key, Object res) {\n+        Map map = getEagerMap(false);\n+        if (map == null) {\n+            map = new HashMap();\n+            setEagerMap(map);\n+        }\n+        map.put(key, res);\n+    }\n+\n+    /**\n+     * Raw eager information. May be null.\n+     *\n+     * @param client whether the client is accessing eager information\n+     */\n+    protected Map getEagerMap(boolean client) {\n+        if (client)\n+            _gotEager = true;\n+        return _eager;\n+    }\n+\n+    /**\n+     * Raw eager information.\n+     */\n+    protected void setEagerMap(Map eager) {\n+        _eager = eager;\n+    }\n+\n+    /**\n+     * Closes all eager results.\n+     */\n+    public void close() {\n+        closeEagerMap(_eager);\n+        _mappedByFieldMapping = null;\n+        _mappedByValue = null;\n+    }\n+\n+    /**\n+     * Close all results in eager map.\n+     */\n+    protected void closeEagerMap(Map eager) {\n+        if (eager != null) {\n+            Object res;\n+            for (Iterator itr = eager.values().iterator(); itr.hasNext();) {\n+                res = itr.next();\n+                if (res != this && res instanceof Closeable)\n+                    try {\n+                        ((Closeable) res).close();\n+                    } catch (Exception e) {\n+                    }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns false by default.\n+     */\n+    public boolean supportsRandomAccess()\n+        throws SQLException {\n+        return false;\n+    }\n+\n+    public boolean absolute(int row)\n+        throws SQLException {\n+        _gotEager = false;\n+        return absoluteInternal(row);\n+    }\n+\n+    /**\n+     * Throws an exception by default.\n+     */\n+    protected boolean absoluteInternal(int row)\n+        throws SQLException {\n+        throw new UnsupportedException();\n+    }\n+\n+    public boolean next()\n+        throws SQLException {\n+        _gotEager = false;\n+        if (_ignoreNext) {\n+            _ignoreNext = false;\n+            return _last;\n+        }\n+        _last = nextInternal();\n+        return _last;\n+    }\n+\n+    /**\n+     * Advance this row.\n+     */\n+    protected abstract boolean nextInternal()\n+        throws SQLException;\n+\n+    public void pushBack()\n+        throws SQLException {\n+        _ignoreNext = true;\n+    }\n+\n+    /**\n+     * Returns a no-op joins object by default.\n+     */\n+    public Joins newJoins() {\n+        return JOINS;\n+    }\n+\n+    public boolean contains(Object obj)\n+        throws SQLException {\n+        return containsInternal(obj, null);\n+    }\n+\n+    public boolean containsAll(Object[] objs)\n+        throws SQLException {\n+        return containsAllInternal(objs, null);\n+    }\n+\n+    public boolean contains(Column col, Joins joins)\n+        throws SQLException {\n+        return containsInternal(col, joins);\n+    }\n+\n+    public boolean containsAll(Column[] cols, Joins joins)\n+        throws SQLException {\n+        return containsAllInternal(cols, joins);\n+    }\n+\n+    /**\n+     * Return whether this result contains data for the given id or column.\n+     * The id or column has not beed passed through {@link #translate}.\n+     */\n+    protected abstract boolean containsInternal(Object obj, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return whether this result contains data for all the given ids or\n+     * columns. The ids or columns have not been passed through\n+     * {@link #translate}. Delegates to {@link #containsInternal} by default.\n+     */\n+    protected boolean containsAllInternal(Object[] objs, Joins joins)\n+        throws SQLException {\n+        for (int i = 0; i < objs.length; i++)\n+            if (!containsInternal(objs[i], joins))\n+                return false;\n+        return true;\n+    }\n+\n+    public ClassMapping getBaseMapping() {\n+        // if we've returned an eager result this call might be for that eager\n+        // result instead of our primary mapping, so return null\n+        return (_gotEager) ? null : _base;\n+    }\n+\n+    public void setBaseMapping(ClassMapping base) {\n+        _base = base;\n+    }\n+\n+    public FieldMapping getMappedByFieldMapping() {\n+        return _mappedByFieldMapping;\n+    }\n+\n+    public void setMappedByFieldMapping(FieldMapping fieldMapping) {\n+        _mappedByFieldMapping = fieldMapping;\n+    }\n+\n+    public Object getMappedByValue() {\n+        return _mappedByValue;\n+    }\n+\n+    public void setMappedByValue(Object mappedByValue) {\n+        _mappedByValue = mappedByValue;\n+    }\n+\n+    public int indexOf() {\n+        return _index;\n+    }\n+\n+    public void setIndexOf(int idx) {\n+        _index = idx;\n+    }\n+\n+    public Object load(ClassMapping mapping, JDBCStore store,\n+        JDBCFetchConfiguration fetch)\n+        throws SQLException {\n+        return load(mapping, store, fetch, null);\n+    }\n+\n+    public Object load(ClassMapping mapping, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Joins joins)\n+        throws SQLException {\n+        return ((JDBCStoreManager) store).load(mapping, fetch, null, this);\n+    }\n+\n+    public Array getArray(Object obj)\n+        throws SQLException {\n+        return getArrayInternal(translate(obj, null), null);\n+    }\n+\n+    public Array getArray(Column col, Joins joins)\n+        throws SQLException {\n+        return getArrayInternal(translate(col, joins), joins);\n+    }\n+\n+    protected Array getArrayInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return (Array) checkNull(getObjectInternal(obj,\n+            JavaSQLTypes.SQL_ARRAY, null, joins));\n+    }\n+\n+    public InputStream getAsciiStream(Object obj)\n+        throws SQLException {\n+        return getAsciiStreamInternal(translate(obj, null), null);\n+    }\n+\n+    public InputStream getAsciiStream(Column col, Joins joins)\n+        throws SQLException {\n+        return getAsciiStreamInternal(translate(col, joins), joins);\n+    }\n+\n+    protected InputStream getAsciiStreamInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return (InputStream) checkNull(getObjectInternal(obj,\n+            JavaSQLTypes.ASCII_STREAM, null, joins));\n+    }\n+\n+    public BigDecimal getBigDecimal(Object obj)\n+        throws SQLException {\n+        return getBigDecimalInternal(translate(obj, null), null);\n+    }\n+\n+    public BigDecimal getBigDecimal(Column col, Joins joins)\n+        throws SQLException {\n+        return getBigDecimalInternal(translate(col, joins), joins);\n+    }\n+\n+    protected BigDecimal getBigDecimalInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        Object val = checkNull(getObjectInternal(obj,\n+            JavaTypes.BIGDECIMAL, null, joins));\n+        if (val == null)\n+            return null;\n+        if (val instanceof BigDecimal)\n+            return (BigDecimal) val;\n+        return new BigDecimal(val.toString());\n+    }\n+\n+    public BigInteger getBigInteger(Object obj)\n+        throws SQLException {\n+        return getBigIntegerInternal(translate(obj, null), null);\n+    }\n+\n+    public BigInteger getBigInteger(Column col, Joins joins)\n+        throws SQLException {\n+        return getBigIntegerInternal(translate(col, joins), joins);\n+    }\n+\n+    protected BigInteger getBigIntegerInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        Object val = checkNull(getObjectInternal(obj,\n+            JavaTypes.BIGINTEGER, null, joins));\n+        if (val == null)\n+            return null;\n+        if (val instanceof BigInteger)\n+            return (BigInteger) val;\n+        return new BigInteger(val.toString());\n+    }\n+\n+    public InputStream getBinaryStream(Object obj)\n+        throws SQLException {\n+        return getBinaryStreamInternal(translate(obj, null), null);\n+    }\n+\n+    public InputStream getBinaryStream(Column col, Joins joins)\n+        throws SQLException {\n+        return getBinaryStreamInternal(translate(col, joins), joins);\n+    }\n+\n+    public InputStream getLOBStream(JDBCStore store, Object obj)\n+        throws SQLException {\n+        return getLOBStreamInternal(store, translate(obj, null), null);\n+    }\n+\n+    protected InputStream getBinaryStreamInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return (InputStream) checkNull(getObjectInternal(obj,\n+            JavaSQLTypes.BINARY_STREAM, null, joins));\n+    }\n+\n+    protected InputStream getLOBStreamInternal(JDBCStore store, Object obj,\n+        Joins joins) throws SQLException {\n+        return (InputStream) checkNull(getStreamInternal(store, obj,\n+            JavaSQLTypes.BINARY_STREAM, null, joins));\n+    }\n+    \n+    public Blob getBlob(Object obj)\n+        throws SQLException {\n+        return getBlobInternal(translate(obj, null), null);\n+    }\n+\n+    public Blob getBlob(Column col, Joins joins)\n+        throws SQLException {\n+        return getBlobInternal(translate(col, joins), joins);\n+    }\n+\n+    protected Blob getBlobInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return (Blob) checkNull(getObjectInternal(obj, JavaSQLTypes.BLOB,\n+            null, joins));\n+    }\n+\n+    public boolean getBoolean(Object obj)\n+        throws SQLException {\n+        return getBooleanInternal(translate(obj, null), null);\n+    }\n+\n+    public boolean getBoolean(Column col, Joins joins)\n+        throws SQLException {\n+        return getBooleanInternal(translate(col, joins), joins);\n+    }\n+\n+    protected boolean getBooleanInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        Object val = checkNull(getObjectInternal(obj, JavaTypes.BOOLEAN,\n+            null, joins));\n+        if (val == null)\n+            return false;\n+        return Boolean.valueOf(val.toString()).booleanValue();\n+    }\n+\n+    public byte getByte(Object obj)\n+        throws SQLException {\n+        return getByteInternal(translate(obj, null), null);\n+    }\n+\n+    public byte getByte(Column col, Joins joins)\n+        throws SQLException {\n+        return getByteInternal(translate(col, joins), joins);\n+    }\n+\n+    protected byte getByteInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        Number val = (Number) checkNull(getObjectInternal(obj,\n+            JavaTypes.BYTE, null, joins));\n+        return (val == null) ? 0 : val.byteValue();\n+    }\n+\n+    public byte[] getBytes(Object obj)\n+        throws SQLException {\n+        return getBytesInternal(translate(obj, null), null);\n+    }\n+\n+    public byte[] getBytes(Column col, Joins joins)\n+        throws SQLException {\n+        return getBytesInternal(translate(col, joins), joins);\n+    }\n+\n+    protected byte[] getBytesInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return (byte[]) checkNull(getObjectInternal(obj,\n+            JavaSQLTypes.BYTES, null, joins));\n+    }\n+\n+    public Calendar getCalendar(Object obj)\n+        throws SQLException {\n+        return getCalendarInternal(translate(obj, null), null);\n+    }\n+\n+    public Calendar getCalendar(Column col, Joins joins)\n+        throws SQLException {\n+        return getCalendarInternal(translate(col, joins), joins);\n+    }\n+\n+    protected Calendar getCalendarInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        Object val = checkNull(getObjectInternal(obj, JavaTypes.CALENDAR,\n+            null, joins));\n+        if (val == null)\n+            return null;\n+        if (val instanceof Calendar)\n+            return (Calendar) val;\n+\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date(val.toString()));\n+        return cal;\n+    }\n+\n+    public char getChar(Object obj)\n+        throws SQLException {\n+        return getCharInternal(translate(obj, null), null);\n+    }\n+\n+    public char getChar(Column col, Joins joins)\n+        throws SQLException {\n+        return getCharInternal(translate(col, joins), joins);\n+    }\n+\n+    protected char getCharInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        Object val = checkNull(getObjectInternal(obj, JavaTypes.CHAR,\n+            null, joins));\n+        if (val == null)\n+            return 0;\n+        if (val instanceof Character)\n+            return ((Character) val).charValue();\n+\n+        String str = val.toString();\n+        return (str.length() == 0) ? 0 : str.charAt(0);\n+    }\n+\n+    public Reader getCharacterStream(Object obj)\n+        throws SQLException {\n+        return getCharacterStreamInternal(translate(obj, null), null);\n+    }\n+\n+    public Reader getCharacterStream(Column col, Joins joins)\n+        throws SQLException {\n+        return getCharacterStreamInternal(translate(col, joins), joins);\n+    }\n+\n+    protected Reader getCharacterStreamInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        Object val = checkNull(getObjectInternal(obj,\n+            JavaSQLTypes.CHAR_STREAM, null, joins));\n+        if (val == null)\n+            return null;\n+        if (val instanceof Reader)\n+            return (Reader) val;\n+        return new StringReader(val.toString());\n+    }\n+\n+    public Clob getClob(Object obj)\n+        throws SQLException {\n+        return getClobInternal(translate(obj, null), null);\n+    }\n+\n+    public Clob getClob(Column col, Joins joins)\n+        throws SQLException {\n+        return getClobInternal(translate(col, joins), joins);\n+    }\n+\n+    protected Clob getClobInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return (Clob) checkNull(getObjectInternal(obj, JavaSQLTypes.CLOB,\n+            null, joins));\n+    }\n+\n+    public Date getDate(Object obj)\n+        throws SQLException {\n+        return getDateInternal(translate(obj, null), null);\n+    }\n+\n+    public Date getDate(Column col, Joins joins)\n+        throws SQLException {\n+        return getDateInternal(translate(col, joins), joins);\n+    }\n+\n+    protected Date getDateInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        Object val = checkNull(getObjectInternal(obj, JavaTypes.DATE,\n+            null, joins));\n+        if (val == null)\n+            return null;\n+        if (val instanceof Date)\n+            return (Date) val;\n+        return new Date(val.toString());\n+    }\n+\n+    public java.sql.Date getDate(Object obj, Calendar cal)\n+        throws SQLException {\n+        return getDateInternal(translate(obj, null), cal, null);\n+    }\n+\n+    public java.sql.Date getDate(Column col, Calendar cal, Joins joins)\n+        throws SQLException {\n+        return getDateInternal(translate(col, joins), cal, joins);\n+    }\n+\n+    protected java.sql.Date getDateInternal(Object obj, Calendar cal,\n+        Joins joins)\n+        throws SQLException {\n+        return (java.sql.Date) checkNull(getObjectInternal(obj,\n+            JavaSQLTypes.SQL_DATE, cal, joins));\n+    }\n+\n+    public double getDouble(Object obj)\n+        throws SQLException {\n+        return getDoubleInternal(translate(obj, null), null);\n+    }\n+\n+    public double getDouble(Column col, Joins joins)\n+        throws SQLException {\n+        return getDoubleInternal(translate(col, joins), joins);\n+    }\n+\n+    protected double getDoubleInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        Number val = (Number) checkNull(getObjectInternal(obj,\n+            JavaTypes.DOUBLE, null, joins));\n+        return (val == null) ? 0 : val.doubleValue();\n+    }\n+\n+    public float getFloat(Object obj)\n+        throws SQLException {\n+        return getFloatInternal(translate(obj, null), null);\n+    }\n+\n+    public float getFloat(Column col, Joins joins)\n+        throws SQLException {\n+        return getFloatInternal(translate(col, joins), joins);\n+    }\n+\n+    protected float getFloatInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        Number val = (Number) checkNull(getObjectInternal(obj,\n+            JavaTypes.FLOAT, null, joins));\n+        return (val == null) ? 0 : val.floatValue();\n+    }\n+\n+    public int getInt(Object obj)\n+        throws SQLException {\n+        return getIntInternal(translate(obj, null), null);\n+    }\n+\n+    public int getInt(Column col, Joins joins)\n+        throws SQLException {\n+        return getIntInternal(translate(col, joins), joins);\n+    }\n+\n+    protected int getIntInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        Number val = (Number) checkNull(getObjectInternal(obj,\n+            JavaTypes.INT, null, joins));\n+        return (val == null) ? 0 : val.intValue();\n+    }\n+\n+    public Locale getLocale(Object obj)\n+        throws SQLException {\n+        return getLocaleInternal(translate(obj, null), null);\n+    }\n+\n+    public Locale getLocale(Column col, Joins joins)\n+        throws SQLException {\n+        return getLocaleInternal(translate(col, joins), joins);\n+    }\n+\n+    protected Locale getLocaleInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        Object val = checkNull(getObjectInternal(obj, JavaTypes.LOCALE,\n+            null, joins));\n+        if (val == null)\n+            return null;\n+        if (val instanceof Locale)\n+            return (Locale) val;\n+        String[] vals = Strings.split(val.toString(), \"_\", 0);\n+        if (vals.length < 2)\n+            throw new SQLException(val.toString());\n+        if (vals.length == 2)\n+            return new Locale(vals[0], vals[1]);\n+        return new Locale(vals[0], vals[1], vals[2]);\n+    }\n+\n+    public long getLong(Object obj)\n+        throws SQLException {\n+        return getLongInternal(translate(obj, null), null);\n+    }\n+\n+    public long getLong(Column col, Joins joins)\n+        throws SQLException {\n+        return getLongInternal(translate(col, joins), joins);\n+    }\n+\n+    protected long getLongInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        Number val = (Number) checkNull(getObjectInternal(obj,\n+            JavaTypes.INT, null, joins));\n+        return (val == null) ? 0 : val.intValue();\n+    }\n+\n+    public Number getNumber(Object obj)\n+        throws SQLException {\n+        return getNumberInternal(translate(obj, null), null);\n+    }\n+\n+    public Number getNumber(Column col, Joins joins)\n+        throws SQLException {\n+        return getNumberInternal(translate(col, joins), joins);\n+    }\n+\n+    protected Number getNumberInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        Object val = checkNull(getObjectInternal(obj,\n+            JavaTypes.NUMBER, null, joins));\n+        if (val == null)\n+            return null;\n+        if (val instanceof Number)\n+            return (Number) val;\n+        return new BigDecimal(val.toString());\n+    }\n+\n+    public Object getObject(Object obj, int metaType, Object arg)\n+        throws SQLException {\n+        return getObjectInternal(translate(obj, null), metaType, arg, null);\n+    }\n+\n+    public Object getObject(Column col, Object arg, Joins joins)\n+        throws SQLException {\n+        return getObjectInternal(translate(col, joins), col.getJavaType(),\n+            arg, joins);\n+    }\n+\n+    /**\n+     * Return the value stored in the given id or column.\n+     */\n+    protected abstract Object getObjectInternal(Object obj, int metaType,\n+        Object arg, Joins joins)\n+        throws SQLException;\n+\n+    protected abstract Object getStreamInternal(JDBCStore store, Object obj,\n+            int metaType, Object arg, Joins joins) throws SQLException;\n+    \n+    public Object getSQLObject(Object obj, Map map)\n+        throws SQLException {\n+        return getSQLObjectInternal(translate(obj, null), map, null);\n+    }\n+\n+    public Object getSQLObject(Column col, Map map, Joins joins)\n+        throws SQLException {\n+        return getSQLObjectInternal(translate(col, joins), map, joins);\n+    }\n+\n+    protected Object getSQLObjectInternal(Object obj, Map map, Joins joins)\n+        throws SQLException {\n+        return checkNull(getObjectInternal(obj, JavaSQLTypes.SQL_OBJECT,\n+            map, joins));\n+    }\n+\n+    public Ref getRef(Object obj, Map map)\n+        throws SQLException {\n+        return getRefInternal(translate(obj, null), map, null);\n+    }\n+\n+    public Ref getRef(Column col, Map map, Joins joins)\n+        throws SQLException {\n+        return getRefInternal(translate(col, joins), map, joins);\n+    }\n+\n+    protected Ref getRefInternal(Object obj, Map map, Joins joins)\n+        throws SQLException {\n+        return (Ref) checkNull(getObjectInternal(obj, JavaSQLTypes.REF,\n+            map, joins));\n+    }\n+\n+    public short getShort(Object obj)\n+        throws SQLException {\n+        return getShortInternal(translate(obj, null), null);\n+    }\n+\n+    public short getShort(Column col, Joins joins)\n+        throws SQLException {\n+        return getShortInternal(translate(col, joins), joins);\n+    }\n+\n+    protected short getShortInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        Number val = (Number) checkNull(getObjectInternal(obj,\n+            JavaTypes.SHORT, null, joins));\n+        return (val == null) ? 0 : val.shortValue();\n+    }\n+\n+    public String getString(Object obj)\n+        throws SQLException {\n+        return getStringInternal(translate(obj, null), null);\n+    }\n+\n+    public String getString(Column col, Joins joins)\n+        throws SQLException {\n+        return getStringInternal(translate(col, joins), joins);\n+    }\n+\n+    protected String getStringInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        Object val = checkNull(getObjectInternal(obj, JavaTypes.STRING,\n+            null, joins));\n+        return (val == null) ? null : val.toString();\n+    }\n+\n+    public Time getTime(Object obj, Calendar cal)\n+        throws SQLException {\n+        return getTimeInternal(translate(obj, null), cal, null);\n+    }\n+\n+    public Time getTime(Column col, Calendar cal, Joins joins)\n+        throws SQLException {\n+        return getTimeInternal(translate(col, joins), cal, joins);\n+    }\n+\n+    protected Time getTimeInternal(Object obj, Calendar cal, Joins joins)\n+        throws SQLException {\n+        return (Time) checkNull(getObjectInternal(obj, JavaSQLTypes.TIME,\n+            cal, joins));\n+    }\n+\n+    public Timestamp getTimestamp(Object obj, Calendar cal)\n+        throws SQLException {\n+        return getTimestampInternal(translate(obj, null), cal, null);\n+    }\n+\n+    public Timestamp getTimestamp(Column col, Calendar cal, Joins joins)\n+        throws SQLException {\n+        return getTimestampInternal(translate(col, joins), cal, joins);\n+    }\n+\n+    protected Timestamp getTimestampInternal(Object obj, Calendar cal,\n+        Joins joins)\n+        throws SQLException {\n+        return (Timestamp) checkNull(getObjectInternal(obj,\n+            JavaSQLTypes.TIMESTAMP, cal, joins));\n+    }\n+\n+    public boolean wasNull()\n+        throws SQLException {\n+        return _wasNull;\n+    }\n+\n+    protected Object checkNull(Object val) {\n+        _wasNull = (val == null);\n+        return val;\n+    }\n+\n+    public void setLocking(boolean locking) {\n+        _locking = locking;\n+    }\n+\n+    public boolean isLocking() {\n+        return _locking;\n+    }\n+\n+    public void startDataRequest(Object mapping) {\n+    }\n+\n+    public void endDataRequest() {\n+    }\n+\n+    /**\n+     * Translate the user-given id or column. This method is called before\n+     * delegating to any <code>get*Internal</code> methods. Return the\n+     * original value by default.\n+     */\n+    protected Object translate(Object obj, Joins joins)\n+        throws SQLException {\n+        return obj;\n+    }\n+\n+    /**\n+     * Do-nothing joins implementation.\n+     */\n+    private static class NoOpJoins\n+        implements Joins {\n+\n+        public boolean isEmpty() {\n+            return true;\n+        }\n+\n+        public boolean isOuter() {\n+            return false;\n+        }\n+\n+        public Joins crossJoin(Table localTable, Table foreignTable) {\n+            return this;\n+        }\n+\n+        public Joins join(ForeignKey fk, boolean inverse, boolean toMany) {\n+            return this;\n+        }\n+\n+        public Joins outerJoin(ForeignKey fk, boolean inverse, boolean toMany) {\n+            return this;\n+        }\n+\n+        public Joins joinRelation(String name, ForeignKey fk, \n+            ClassMapping target, int subs, boolean inverse, boolean toMany) {\n+            return this;\n+        }\n+\n+        public Joins outerJoinRelation(String name, ForeignKey fk,\n+            ClassMapping target, int subs, boolean inverse, boolean toMany) {\n+            return this;\n+        }\n+\n+        public Joins setVariable(String var) {\n+            return this;\n+        }\n+\n+        public Joins setSubselect(String alias) {\n+            return this;\n+        }\n+\n+        public void appendTo(SQLBuffer buf) {\n+        }\n+    }\n+}"},{"sha":"fffef75b9f4685038a0cb1f5ef9d1324ab2ffa63","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractSQLServerDictionary.java","status":"added","additions":155,"deletions":0,"changes":155,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractSQLServerDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractSQLServerDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractSQLServerDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.Arrays;\n+\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Index;\n+\n+/**\n+ * Dictionary for the SQL Server databases (Sybase and MS SQL Server).\n+ */\n+public abstract class AbstractSQLServerDictionary\n+    extends DBDictionary {\n+\n+    public AbstractSQLServerDictionary() {\n+        reservedWordSet.addAll(Arrays.asList(new String[]{ \"FILE\", \"INDEX\" }));\n+        systemTableSet.add(\"DTPROPERTIES\");\n+        validationSQL = \"SELECT GETDATE()\";\n+        rangePosition = RANGE_POST_DISTINCT;\n+\n+        supportsDeferredConstraints = false;\n+        supportsSelectEndIndex = true;\n+        allowsAliasInBulkClause = false;\n+\n+        supportsAutoAssign = true;\n+        autoAssignClause = \"IDENTITY\";\n+        lastGeneratedKeyQuery = \"SELECT @@IDENTITY\";\n+\n+        trimLeadingFunction = \"LTRIM({0})\";\n+        trimTrailingFunction = \"RTRIM({0})\";\n+        trimBothFunction = \"LTRIM(RTRIM({0}))\";\n+        concatenateFunction = \"({0}+{1})\";\n+        supportsModOperator = true;\n+\n+        currentDateFunction = \"GETDATE()\";\n+        currentTimeFunction = \"GETDATE()\";\n+        currentTimestampFunction = \"GETDATE()\";\n+\n+        useGetStringForClobs = true;\n+        useSetStringForClobs = true;\n+        useGetBytesForBlobs = true;\n+        useSetBytesForBlobs = true;\n+        binaryTypeName = \"BINARY\";\n+        blobTypeName = \"IMAGE\";\n+        longVarbinaryTypeName = \"IMAGE\";\n+        clobTypeName = \"TEXT\";\n+        longVarcharTypeName = \"TEXT\";\n+        dateTypeName = \"DATETIME\";\n+        timeTypeName = \"DATETIME\";\n+        timestampTypeName = \"DATETIME\";\n+        floatTypeName = \"FLOAT(16)\";\n+        doubleTypeName = \"FLOAT(32)\";\n+        integerTypeName = \"INT\";\n+        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\n+            \"IMAGE\", \"TEXT\", \"NTEXT\", \"MONEY\", \"SMALLMONEY\", \"INT\",\n+            \"DOUBLE PRECISION\", \"DATETIME\", \"SMALLDATETIME\",\n+            \"EXTENDED TYPE\", \"SYSNAME\", \"SQL_VARIANT\", \"INDEX\",\n+        }));\n+    }\n+\n+    public Column[] getColumns(DatabaseMetaData meta, String catalog,\n+        String schemaName, String tableName, String colName, Connection conn)\n+        throws SQLException {\n+        Column[] cols = super.getColumns(meta, catalog, schemaName, tableName,\n+            colName, conn);\n+        for (int i = 0; cols != null && i < cols.length; i++)\n+            if (cols[i].getType() == Types.LONGVARCHAR)\n+                cols[i].setType(Types.CLOB);\n+        return cols;\n+    }\n+\n+    public String getFullName(Index idx) {\n+        return getFullName(idx.getTable(), false) + \".\" + idx.getName();\n+    }\n+\n+    public void setNull(PreparedStatement stmnt, int idx, int colType,\n+        Column col)\n+        throws SQLException {\n+        // SQLServer has some problems with setNull on lobs\n+        if (colType == Types.CLOB)\n+            stmnt.setString(idx, null);\n+        else if (colType == Types.BLOB)\n+            stmnt.setBytes(idx, null);\n+        else\n+            super.setNull(stmnt, idx, colType, col);\n+    }\n+\n+    protected void appendSelectRange(SQLBuffer buf, long start, long end,\n+        boolean subselect) {\n+        // cannot use a value here, since SQLServer does not support\n+        // bound parameters in a \"TOP\" clause\n+        buf.append(\" TOP \").append(Long.toString(end));\n+    }\n+\n+    public void substring(SQLBuffer buf, FilterValue str, FilterValue start,\n+        FilterValue end) {\n+        if (end != null)\n+            super.substring(buf, str, start, end);\n+        else {\n+            // ### it would be good to change this logic as in DBDictionary to\n+            // ### simplify the generated SQL\n+            buf.append(\"SUBSTRING(\");\n+            str.appendTo(buf);\n+            buf.append(\", \");\n+            start.appendTo(buf);\n+            buf.append(\" + 1, \");\n+            buf.append(\"LEN(\");\n+            str.appendTo(buf);\n+            buf.append(\")\");\n+            buf.append(\" - (\");\n+            start.appendTo(buf);\n+            buf.append(\"))\");\n+        }\n+    }\n+\n+    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n+        FilterValue start) {\n+        buf.append(\"(CHARINDEX(\");\n+        find.appendTo(buf);\n+        buf.append(\", \");\n+        if (start != null)\n+            substring(buf, str, start, null);\n+        else\n+            str.appendTo(buf);\n+        buf.append(\") - 1\");\n+        if (start != null) {\n+            buf.append(\" + \");\n+            start.appendTo(buf);\n+        }\n+        buf.append(\")\");\n+    }\n+}"},{"sha":"735c9d499485dce0f6bc6510a893fd6af3ae07f5","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AccessDictionary.java","status":"added","additions":81,"deletions":0,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AccessDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AccessDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AccessDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.jdbc.schema.Column;\n+\n+/**\n+ * Dictionary for Access via DataDirect SequeLink and DataDirect ODBC\n+ * FoxPro driver. This will not work with any other combination of JDBC/ODBC\n+ * server and ODBC driver.\n+ */\n+public class AccessDictionary\n+    extends DBDictionary {\n+\n+    public AccessDictionary() {\n+        platform = \"Microsoft Access\";\n+        joinSyntax = SYNTAX_TRADITIONAL;\n+        validationSQL = \"SELECT 1\";\n+        reservedWordSet.add(\"VALUE\");\n+\n+        supportsAutoAssign = true;\n+        autoAssignTypeName = \"COUNTER\";\n+        lastGeneratedKeyQuery = \"SELECT @@identity\";\n+        maxTableNameLength = 64;\n+        maxColumnNameLength = 64;\n+        maxIndexNameLength = 64;\n+        maxConstraintNameLength = 64;\n+\n+        useGetBytesForBlobs = true;\n+        useGetBestRowIdentifierForPrimaryKeys = true;\n+\n+        binaryTypeName = \"LONGBINARY\";\n+        blobTypeName = \"LONGBINARY\";\n+        longVarbinaryTypeName = \"LONGBINARY\";\n+        clobTypeName = \"LONGCHAR\";\n+        longVarcharTypeName = \"LONGCHAR\";\n+        bigintTypeName = \"REAL\";\n+        numericTypeName = \"REAL\";\n+        integerTypeName = \"INTEGER\";\n+        smallintTypeName = \"SMALLINT\";\n+        tinyintTypeName = \"SMALLINT\";\n+\n+        supportsForeignKeys = false;\n+        supportsDeferredConstraints = false;\n+        maxIndexesPerTable = 32;\n+\n+        substringFunctionName = \"MID\";\n+    }\n+\n+    public void setLong(PreparedStatement stmnt, int idx, long val, Column col)\n+        throws SQLException {\n+        // the access driver disallows setLong for some reason; use\n+        // setInt if possible, otherwise use setDouble\n+\n+        if (val < Integer.MAX_VALUE && val > Integer.MIN_VALUE)\n+            stmnt.setInt(idx, (int) val);\n+        else\n+            stmnt.setDouble(idx, val);\n+    }\n+}\n+"},{"sha":"87dddb784a3724171533e62e2771f72aa58470f4","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/CacheDictionary.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/CacheDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/CacheDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/CacheDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+/**\n+ * Dictionary for Intersystems Cache.\n+ */\n+public class CacheDictionary\n+    extends DBDictionary {\n+\n+    public CacheDictionary() {\n+        platform = \"Intersystems Cache\";\n+        supportsDeferredConstraints = false;\n+        supportsSelectForUpdate = true;\n+        validationSQL = \"SET OPTION DUMMY=DUMMY\";\n+\n+        bigintTypeName = \"NUMERIC\";\n+        numericTypeName = \"NUMERIC\";\n+        clobTypeName = \"LONGVARCHAR\";\n+        blobTypeName = \"LONGVARBINARY\";\n+\n+        // use Cache's objectscript for assigning auto-assigned values\n+        autoAssignClause = \"DEFAULT OBJECTSCRIPT '$INCREMENT(^LogNumber)'\";\n+\n+        // there is no built-in function for getting the last generated\n+        // key in Cache; using MAX will have to suffice\n+        lastGeneratedKeyQuery = \"SELECT MAX({0}) FROM {1}\";\n+    }\n+}"},{"sha":"15a2f4d4394fcd0608dd0617766cb6eb55b2435b","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Calendard.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Calendard.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Calendard.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Calendard.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.util.Calendar;\n+\n+/**\n+ * A calendar-modified value. Used to represent both a value and its\n+ * calendar for calls to {@link Row#setObject}.\n+ *\n+ * @author Abe White\n+ */\n+public class Calendard {\n+\n+    public final Object value;\n+    public final Calendar calendar;\n+\n+    public Calendard(Object value, Calendar calendar) {\n+        this.value = value;\n+        this.calendar = calendar;\n+    }\n+}"},{"sha":"69091419f75113f3dfd8e0774d2043abb8d32e9a","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","status":"added","additions":831,"deletions":0,"changes":831,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,831 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.    \r\n+ */\r\n+package org.apache.openjpa.jdbc.sql;\r\n+\r\n+import java.lang.reflect.Method;\r\n+import java.sql.Connection;\r\n+import java.sql.DatabaseMetaData;\r\n+import java.sql.SQLException;\r\n+import java.sql.Types;\r\n+import java.util.Arrays;\r\n+import java.util.StringTokenizer;\r\n+\r\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\r\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\r\n+import org.apache.openjpa.jdbc.kernel.exps.Lit;\r\n+import org.apache.openjpa.jdbc.kernel.exps.Param;\r\n+import org.apache.openjpa.jdbc.kernel.exps.Val;\r\n+import org.apache.openjpa.jdbc.schema.Column;\r\n+import org.apache.openjpa.jdbc.schema.Index;\r\n+import org.apache.openjpa.jdbc.schema.Schema;\r\n+import org.apache.openjpa.jdbc.schema.Sequence;\r\n+import org.apache.openjpa.jdbc.schema.Table;\r\n+import org.apache.openjpa.kernel.Filters;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.meta.JavaTypes;\r\n+import org.apache.openjpa.util.OpenJPAException;\r\n+import org.apache.openjpa.util.UnsupportedException;\r\n+\r\n+import serp.util.Strings;\r\n+\r\n+/**\r\n+ * Dictionary for IBM DB2 database.\r\n+ */\r\n+public class DB2Dictionary\r\n+    extends AbstractDB2Dictionary {\r\n+    private static final Localizer _loc = Localizer.forPackage\r\n+        (DB2Dictionary.class);\r\n+\r\n+    public String optimizeClause = \"optimize for\";\r\n+    public String rowClause = \"row\";\r\n+    protected int db2ServerType = 0;\r\n+    public static final int db2ISeriesV5R3OrEarlier = 1;\r\n+    public static final int db2UDBV81OrEarlier = 2;\r\n+    public static final int db2ZOSV8xOrLater = 3;\r\n+    public static final int db2UDBV82OrLater = 4;\r\n+    public static final int db2ISeriesV5R4OrLater = 5;\r\n+\tprotected static final String forUpdate = \"FOR UPDATE\";\r\n+    protected static final String withURClause = \"WITH UR\";\r\n+    protected static final String withCSClause = \"WITH CS\";\r\n+    protected static final String withRSClause = \"WITH RS\";\r\n+    protected static final String withRRClause = \"WITH RR\";\r\n+    protected static final String useKeepShareLockClause\r\n+        = \"USE AND KEEP SHARE LOCKS\";\r\n+    protected static final String useKeepUpdateLockClause\r\n+        = \"USE AND KEEP UPDATE LOCKS\";\r\n+    protected static final String useKeepExclusiveLockClause\r\n+        = \"USE AND KEEP EXCLUSIVE LOCKS\";\r\n+    protected static final String forReadOnlyClause = \"FOR READ ONLY\";\r\n+    protected String databaseProductName = \"\";\r\n+    protected String databaseProductVersion = \"\";\r\n+    protected int maj = 0;\r\n+    protected int min = 0;\r\n+    \r\n+    private int defaultBatchLimit = 100;\r\n+\r\n+    public DB2Dictionary() {\r\n+        platform = \"DB2\";\r\n+        validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\r\n+            + \"SYSIBM.SYSTABLES\";\r\n+        supportsSelectEndIndex = true;\r\n+\r\n+        nextSequenceQuery = \"VALUES NEXTVAL FOR {0}\";\r\n+\r\n+        sequenceSQL = \"SELECT SEQSCHEMA AS SEQUENCE_SCHEMA, \"\r\n+            + \"SEQNAME AS SEQUENCE_NAME FROM SYSCAT.SEQUENCES\";\r\n+        sequenceSchemaSQL = \"SEQSCHEMA = ?\";\r\n+        sequenceNameSQL = \"SEQNAME = ?\";\r\n+        characterColumnSize = 254;\r\n+\r\n+        binaryTypeName = \"BLOB(1M)\";\r\n+        longVarbinaryTypeName = \"BLOB(1M)\";\r\n+        varbinaryTypeName = \"BLOB(1M)\";\r\n+        clobTypeName = \"CLOB(1M)\";\r\n+        longVarcharTypeName = \"LONG VARCHAR\";\r\n+        datePrecision = MICRO;\r\n+        storeCharsAsNumbers = false;\r\n+\r\n+        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\r\n+            \"LONG VARCHAR FOR BIT DATA\", \"LONG VARCHAR\", \"LONG VARGRAPHIC\",\r\n+        }));\r\n+        systemSchemas = new String(\r\n+                \"SYSCAT,SYSIBM,SYSSTAT,SYSIBMADM,SYSTOOLS\");\r\n+        maxConstraintNameLength = 18;\r\n+        maxIndexNameLength = 18;\r\n+        maxColumnNameLength = 30;\r\n+        supportsDeferredConstraints = false;\r\n+        supportsDefaultDeleteAction = false;\r\n+        supportsAlterTableWithDropColumn = false;\r\n+\r\n+        supportsNullTableForGetColumns = false;\r\n+        requiresCastForMathFunctions = true;\r\n+        requiresCastForComparisons = true;\r\n+\r\n+        reservedWordSet.addAll(Arrays.asList(new String[]{\r\n+            \"AFTER\", \"ALIAS\", \"ALLOW\", \"APPLICATION\", \"ASSOCIATE\", \"ASUTIME\",\r\n+            \"AUDIT\", \"AUX\", \"AUXILIARY\", \"BEFORE\", \"BINARY\", \"BUFFERPOOL\",\r\n+            \"CACHE\", \"CALL\", \"CALLED\", \"CAPTURE\", \"CARDINALITY\", \"CCSID\",\r\n+            \"CLUSTER\", \"COLLECTION\", \"COLLID\", \"COMMENT\", \"CONCAT\",\r\n+            \"CONDITION\", \"CONTAINS\", \"COUNT_BIG\", \"CURRENT_LC_CTYPE\",\r\n+            \"CURRENT_PATH\", \"CURRENT_SERVER\", \"CURRENT_TIMEZONE\", \"CYCLE\",\r\n+            \"DATA\", \"DATABASE\", \"DAYS\", \"DB2GENERAL\", \"DB2GENRL\", \"DB2SQL\",\r\n+            \"DBINFO\", \"DEFAULTS\", \"DEFINITION\", \"DETERMINISTIC\", \"DISALLOW\",\r\n+            \"DO\", \"DSNHATTR\", \"DSSIZE\", \"DYNAMIC\", \"EACH\", \"EDITPROC\", \"ELSEIF\",\r\n+            \"ENCODING\", \"END-EXEC1\", \"ERASE\", \"EXCLUDING\", \"EXIT\", \"FENCED\",\r\n+            \"FIELDPROC\", \"FILE\", \"FINAL\", \"FREE\", \"FUNCTION\", \"GENERAL\",\r\n+            \"GENERATED\", \"GRAPHIC\", \"HANDLER\", \"HOLD\", \"HOURS\", \"IF\",\r\n+            \"INCLUDING\", \"INCREMENT\", \"INDEX\", \"INHERIT\", \"INOUT\", \"INTEGRITY\",\r\n+            \"ISOBID\", \"ITERATE\", \"JAR\", \"JAVA\", \"LABEL\", \"LC_CTYPE\", \"LEAVE\",\r\n+            \"LINKTYPE\", \"LOCALE\", \"LOCATOR\", \"LOCATORS\", \"LOCK\", \"LOCKMAX\",\r\n+            \"LOCKSIZE\", \"LONG\", \"LOOP\", \"MAXVALUE\", \"MICROSECOND\",\r\n+            \"MICROSECONDS\", \"MINUTES\", \"MINVALUE\", \"MODE\", \"MODIFIES\", \"MONTHS\",\r\n+            \"NEW\", \"NEW_TABLE\", \"NOCACHE\", \"NOCYCLE\", \"NODENAME\", \"NODENUMBER\",\r\n+            \"NOMAXVALUE\", \"NOMINVALUE\", \"NOORDER\", \"NULLS\", \"NUMPARTS\", \"OBID\",\r\n+            \"OLD\", \"OLD_TABLE\", \"OPTIMIZATION\", \"OPTIMIZE\", \"OUT\", \"OVERRIDING\",\r\n+            \"PACKAGE\", \"PARAMETER\", \"PART\", \"PARTITION\", \"PATH\", \"PIECESIZE\",\r\n+            \"PLAN\", \"PRIQTY\", \"PROGRAM\", \"PSID\", \"QUERYNO\", \"READS\", \"RECOVERY\",\r\n+            \"REFERENCING\", \"RELEASE\", \"RENAME\", \"REPEAT\", \"RESET\", \"RESIGNAL\",\r\n+            \"RESTART\", \"RESULT\", \"RESULT_SET_LOCATOR\", \"RETURN\", \"RETURNS\",\r\n+            \"ROUTINE\", \"ROW\", \"RRN\", \"RUN\", \"SAVEPOINT\", \"SCRATCHPAD\",\r\n+            \"SECONDS\", \"SECQTY\", \"SECURITY\", \"SENSITIVE\", \"SIGNAL\", \"SIMPLE\",\r\n+            \"SOURCE\", \"SPECIFIC\", \"SQLID\", \"STANDARD\", \"START\", \"STATIC\",\r\n+            \"STAY\", \"STOGROUP\", \"STORES\", \"STYLE\", \"SUBPAGES\", \"SYNONYM\",\r\n+            \"SYSFUN\", \"SYSIBM\", \"SYSPROC\", \"SYSTEM\", \"TABLESPACE\", \"TRIGGER\",\r\n+            \"TYPE\", \"UNDO\", \"UNTIL\", \"VALIDPROC\", \"VARIABLE\", \"VARIANT\", \"VCAT\",\r\n+            \"VOLUMES\", \"WHILE\", \"WLM\", \"YEARS\",\r\n+        }));\r\n+        \r\n+        super.setBatchLimit(defaultBatchLimit);\r\n+        \r\n+        selectWordSet.add(\"WITH\");\r\n+    }\r\n+\r\n+    public boolean supportsRandomAccessResultSet(Select sel,\r\n+        boolean forUpdate) {\r\n+        return !forUpdate\r\n+            && super.supportsRandomAccessResultSet(sel, forUpdate);\r\n+    }\r\n+\r\n+    protected void appendSelectRange(SQLBuffer buf, long start, long end,\r\n+        boolean subselect) {\r\n+        // appends the literal range string, since DB2 is unable to handle\r\n+        // a bound parameter for it\r\n+        // do not generate FETCH FIRST clause for subselect\r\n+        if (!subselect)\r\n+            buf.append(\" FETCH FIRST \").append(Long.toString(end)).\r\n+                append(\" ROWS ONLY\");\r\n+    }\r\n+\r\n+    protected void appendSelect(SQLBuffer selectSQL, Object alias, Select sel,\r\n+        int idx) {\r\n+        // if this is a literal value, add a cast...\r\n+        Object val = sel.getSelects().get(idx);\r\n+        if (val instanceof Lit)\r\n+            selectSQL.append(\"CAST(\");\r\n+\r\n+        // ... and add the select per super's behavior...\r\n+        super.appendSelect(selectSQL, alias, sel, idx);\r\n+\r\n+        // ... and finish the cast\r\n+        if (val instanceof Lit) {\r\n+            Class c = ((Lit) val).getType();\r\n+            int javaTypeCode = JavaTypes.getTypeCode(c);\r\n+            int jdbcTypeCode = getJDBCType(javaTypeCode, false);\r\n+            String typeName = getTypeName(jdbcTypeCode);\r\n+            selectSQL.append(\" AS \" + typeName);\r\n+\r\n+            // if the literal is a string, use the default char col size\r\n+            // in the cast statement.\r\n+            if (String.class.equals(c))\r\n+                selectSQL.append(\"(\" + characterColumnSize + \")\");\r\n+\r\n+            selectSQL.append(\")\");\r\n+        }\r\n+    }\r\n+\r\n+    public String[] getCreateSequenceSQL(Sequence seq) {\r\n+        String[] sql = super.getCreateSequenceSQL(seq);\r\n+        if (seq.getAllocate() > 1)\r\n+            sql[0] += \" CACHE \" + seq.getAllocate();\r\n+        return sql;\r\n+    }\r\n+\r\n+    protected String getSequencesSQL(String schemaName, String sequenceName) {\r\n+        StringBuffer buf = new StringBuffer();\r\n+        buf.append(sequenceSQL);\r\n+        if (schemaName != null || sequenceName != null)\r\n+            buf.append(\" WHERE \");\r\n+        if (schemaName != null) {\r\n+            buf.append(sequenceSchemaSQL);\r\n+            if (sequenceName != null)\r\n+                buf.append(\" AND \");\r\n+        }\r\n+        if (sequenceName != null)\r\n+            buf.append(sequenceNameSQL);\r\n+        return buf.toString();\r\n+    }\r\n+\r\n+    public Connection decorate(Connection conn)\r\n+        throws SQLException {\r\n+        // some versions of the DB2 driver seem to default to\r\n+        // READ_UNCOMMITTED, which will prevent locking from working\r\n+        // (multiple SELECT ... FOR UPDATE statements are allowed on\r\n+        // the same instance); if we have not overridden the\r\n+        // transaction isolation in the configuration, default to\r\n+        // TRANSACTION_READ_COMMITTED\r\n+        conn = super.decorate(conn);\r\n+\r\n+        if (conf.getTransactionIsolationConstant() == -1\r\n+            && conn.getTransactionIsolation() < conn.TRANSACTION_READ_COMMITTED)\r\n+            conn.setTransactionIsolation(conn.TRANSACTION_READ_COMMITTED);\r\n+\r\n+        return conn;\r\n+    }\r\n+\r\n+    public void connectedConfiguration(Connection conn) throws SQLException {\r\n+    \tsuper.connectedConfiguration(conn);\r\n+\r\n+    \tDatabaseMetaData metaData = conn.getMetaData();\r\n+        databaseProductName = nullSafe(metaData.getDatabaseProductName());\r\n+        databaseProductVersion = nullSafe(metaData.getDatabaseProductVersion());\r\n+        \r\n+        // Determine the type of DB2 database\r\n+        // First check for AS/400\r\n+        getProductVersionMajorMinorForISeries();\r\n+\r\n+        if (maj > 0) {\r\n+            if (isDB2ISeriesV5R3OrEarlier())\r\n+                db2ServerType = db2ISeriesV5R3OrEarlier;\r\n+            else if (isDB2ISeriesV5R4OrLater())\r\n+                db2ServerType = db2ISeriesV5R4OrLater;\r\n+        }\r\n+        \r\n+    \tif (db2ServerType == 0) {\r\n+    \t    if (isJDBC3) {\r\n+    \t        maj = metaData.getDatabaseMajorVersion();\r\n+    \t        min = metaData.getDatabaseMinorVersion();\r\n+    \t    }\r\n+    \t    else\r\n+    \t        getProductVersionMajorMinor();\r\n+\r\n+    \t    // Determine the type of DB2 database for ZOS & UDB\r\n+    \t    if (isDB2UDBV81OrEarlier())\r\n+    \t        db2ServerType = db2UDBV81OrEarlier;\r\n+    \t    else if (isDB2ZOSV8xOrLater())\r\n+    \t        db2ServerType = db2ZOSV8xOrLater;\r\n+    \t    else if (isDB2UDBV82OrLater())\r\n+    \t        db2ServerType = db2UDBV82OrLater;\r\n+        }\r\n+\r\n+        // verify that databae product is supported\r\n+        if (db2ServerType == 0 || maj == 0)\r\n+            throw new UnsupportedException(_loc.get(\"db-not-supported\",\r\n+                new Object[] {databaseProductName, databaseProductVersion }));                    \r\n+\r\n+    \tif (maj >= 9 || (maj == 8 && min >= 2)) {\r\n+    \t    supportsLockingWithMultipleTables = true;\r\n+    \t    supportsLockingWithInnerJoin = true;\r\n+    \t    supportsLockingWithOuterJoin = true;\r\n+    \t    forUpdateClause = \"WITH RR USE AND KEEP UPDATE LOCKS\";\r\n+    \t    if (maj >=9)\r\n+    \t        supportsXMLColumn = true;\r\n+    \t}\r\n+\r\n+        // platform specific settings\r\n+        switch (db2ServerType) {\r\n+        case  db2ZOSV8xOrLater:\r\n+            // DB2 Z/OS \r\n+            characterColumnSize = 255;\r\n+            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\r\n+                + \"SYSIBM.SYSDUMMY1\";\r\n+            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\r\n+                + \"SYSIBM.SYSDUMMY1\";\r\n+            sequenceSQL = \"SELECT SCHEMA AS SEQUENCE_SCHEMA, \"\r\n+                + \"NAME AS SEQUENCE_NAME FROM SYSIBM.SYSSEQUENCES\";\r\n+            sequenceSchemaSQL = \"SCHEMA = ?\";\r\n+            sequenceNameSQL = \"NAME = ?\";\r\n+            if (maj == 8)\r\n+                // DB2 Z/OS Version 8: no bigint support, hence map Java\r\n+                // long to decimal\r\n+                bigintTypeName = \"DECIMAL(31,0)\";\r\n+            break;\r\n+        case db2ISeriesV5R3OrEarlier:\r\n+        case db2ISeriesV5R4OrLater:\r\n+            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\r\n+                + \"SYSIBM.SYSDUMMY1\";\r\n+            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\r\n+                + \"SYSIBM.SYSDUMMY1\";\r\n+            validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\r\n+                + \"QSYS2.SYSTABLES\";\r\n+            sequenceSQL = \"SELECT SEQUENCE_SCHEMA, \"\r\n+                + \"SEQUENCE_NAME FROM QSYS2.SYSSEQUENCES\";\r\n+            sequenceSchemaSQL = \"SEQUENCE_SCHEMA = ?\";\r\n+            sequenceNameSQL = \"SEQUENCE_NAME = ?\";\r\n+            break;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the update clause for the query based on the\r\n+     * updateClause and isolationLevel hints\r\n+     */\r\n+    protected String getForUpdateClause(JDBCFetchConfiguration fetch,\r\n+        boolean isForUpdate, Select sel) {\r\n+        int isolationLevel;\r\n+        // For db2UDBV81OrEarlier and db2ISeriesV5R3OrEarlier:\r\n+        // \"optimize for\" clause appears before \"for update\" clause.\r\n+        StringBuffer forUpdateString = new StringBuffer(\r\n+            getOptimizeClause(sel));\r\n+        try {\r\n+            // Determine the isolationLevel; the fetch\r\n+            // configuration data overrides the persistence.xml value\r\n+            if (fetch != null && fetch.getIsolation() != -1)\r\n+                isolationLevel = fetch.getIsolation();\r\n+            else\r\n+                isolationLevel = conf.getTransactionIsolationConstant();\r\n+\r\n+            if (isForUpdate) {\r\n+                switch(db2ServerType) {\r\n+                case db2ISeriesV5R3OrEarlier:\r\n+                case db2UDBV81OrEarlier:\r\n+                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE)\r\n+                        forUpdateString.append(\" \").append(forUpdateClause);\r\n+                    else \r\n+                        forUpdateString.append(\" \").append(forUpdate)\r\n+                            .append(\" \").append(withRSClause);\r\n+                    break;\r\n+                case db2ZOSV8xOrLater:\r\n+                case db2UDBV82OrLater:\r\n+                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\r\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n+                            .append(\" \").append(withRRClause)\r\n+                            .append(\" \").append(useKeepUpdateLockClause);   \r\n+                    } else {\r\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n+                            .append(\" \").append(withRSClause)\r\n+                            .append(\" \").append(useKeepUpdateLockClause);                            \r\n+                    }\r\n+                    break;\r\n+                case db2ISeriesV5R4OrLater:\r\n+                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\r\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n+                            .append(\" \").append(withRRClause)\r\n+                            .append(\" \").append(useKeepExclusiveLockClause);       \r\n+                    } else {\r\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n+                            .append(\" \").append(withRSClause)\r\n+                            .append(\" \").append(useKeepExclusiveLockClause);\r\n+                    }\r\n+                    break;\r\n+                }\r\n+            }\r\n+        }\r\n+        catch (Exception e) {\r\n+            if (log.isTraceEnabled())\r\n+                log.error(e.toString(),e);\r\n+        }\r\n+        return forUpdateString.toString();\r\n+    }\r\n+\r\n+    public boolean isDB2UDBV82OrLater() {\r\n+        return (databaseProductVersion.indexOf(\"SQL\") != -1\r\n+             || databaseProductName.indexOf(\"DB2/\") != -1)\r\n+             && ((maj == 8 && min >= 2) || (maj >= 9));\r\n+    }\r\n+\r\n+    public boolean isDB2ZOSV8xOrLater() {\r\n+       return (databaseProductVersion.indexOf(\"DSN\") != -1\r\n+            || databaseProductName.indexOf(\"DB2/\") == -1)\r\n+            && maj >= 8;\r\n+           \r\n+    }\r\n+\r\n+    public boolean isDB2ISeriesV5R3OrEarlier() {\r\n+       return (databaseProductName.indexOf(\"AS\") != -1\r\n+           && ((maj == 5 && min <=3) || maj < 5));\r\n+    }\r\n+\r\n+    public boolean isDB2ISeriesV5R4OrLater() {\r\n+       return databaseProductName.indexOf(\"AS\") != -1\r\n+           && (maj >=6 || (maj == 5 && min >=4));\r\n+    }\r\n+\r\n+    public boolean isDB2UDBV81OrEarlier() {\r\n+        return (databaseProductVersion.indexOf(\"SQL\") != -1 \r\n+            || databaseProductName.indexOf(\"DB2/\") != -1) \r\n+            && ((maj == 8 && min <= 1) || maj < 8);\r\n+    }\r\n+\r\n+    /** Get the version Major/Minor for the ISeries\r\n+     */\r\n+    private void getProductVersionMajorMinorForISeries() {\r\n+        // ISeries    DBProdName                 DB2 UDB for AS/400\r\n+        //   (Toolbox)DBProdVersion              05.04.0000 V5R4m0\r\n+        // ISeries                               DB2 UDB for AS/400\r\n+        //   (Native)                            V5R4M0\r\n+        // new jcc    DBProdVersion              QSQ05040 or QSQ06010\r\n+        if (databaseProductName.indexOf(\"AS\") != -1) {\r\n+            // default to V5R4\r\n+            maj = 5;\r\n+            min = 4;\r\n+            int index = databaseProductVersion.indexOf('V');\r\n+            if (index != -1) {\r\n+                String s = databaseProductVersion.substring(index);\r\n+                s = s.toUpperCase();\r\n+\r\n+                StringTokenizer stringtokenizer = new StringTokenizer(s, \"VRM\"\r\n+                    , false);\r\n+                if (stringtokenizer.countTokens() == 3) {\r\n+                    String s1 = stringtokenizer.nextToken();\r\n+                    maj = Integer.parseInt(s1);\r\n+                    String s2 =  stringtokenizer.nextToken();\r\n+                    min = Integer.parseInt(s2);\r\n+                }\r\n+            } else {\r\n+                index = databaseProductVersion.indexOf('0');\r\n+                if (index != -1) {\r\n+                    String s = databaseProductVersion.substring(index);\r\n+                    s = s.toUpperCase();\r\n+\r\n+                    StringTokenizer stringtokenizer = new StringTokenizer(s, \"0\"\r\n+                        , false);                    \r\n+                    if (stringtokenizer.countTokens() == 2) {\r\n+                        String s1 = stringtokenizer.nextToken();\r\n+                        maj = Integer.parseInt(s1);\r\n+                        String s2 =  stringtokenizer.nextToken();\r\n+                        min = Integer.parseInt(s2);\r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+    \r\n+    private void getProductVersionMajorMinor() {\r\n+        // Incase JDBC driver version is lower than 3\r\n+        // use following info to determine Major and Minor \r\n+        //                        CLI    vs      JCC\r\n+        // ZDBV8 DBProdName       DB2            DB2\r\n+        //       DBProdVersion    08.01.0005     DSN08015\r\n+        // ZDBV9                  DB2            DB2\r\n+        //                        09.01.0005     DSN09015\r\n+        // WinV9                  DB2/NT         DB2/NT\r\n+        //                        09.01.0000     SQL09010\r\n+        // SolarisV9                             DB2/SUN64\r\n+        //                                       SQL0901\r\n+        // Linux                  DB2/LINUX      DB2/LINUX\r\n+        //                        09.01.0000     SQL0901\r\n+        if (databaseProductVersion.indexOf(\"09\") != -1) {\r\n+            maj = 9;\r\n+            if (databaseProductVersion.indexOf(\"01\") != -1) {\r\n+                min = 1;\r\n+            }\r\n+        } else if (databaseProductVersion.indexOf(\"08\") != -1) {\r\n+            maj = 8;\r\n+            min = 2;\r\n+            if (databaseProductVersion.indexOf(\"01\") != -1) {\r\n+                min = 1;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    protected String getOptimizeClause(Select sel) {\r\n+        if (sel != null && sel.getExpectedResultCount() > 0) {\r\n+            StringBuffer buf = new StringBuffer();\r\n+            buf.append(\" \").append(optimizeClause).append(\" \")\r\n+                .append(String.valueOf(sel.getExpectedResultCount()))\r\n+                .append(\" \").append(rowClause);\r\n+            return buf.toString();\r\n+        }\r\n+\r\n+        return \"\";\r\n+    }\r\n+\r\n+    public OpenJPAException newStoreException(String msg, SQLException[] causes,\r\n+        Object failed) {\r\n+        if (causes != null && causes.length > 0)\r\n+            msg = appendExtendedExceptionMsg(msg, causes[0]);\r\n+        return super.newStoreException(msg, causes, failed);\r\n+    }\r\n+\r\n+    /**\r\n+     *  Append exception information from SQLCA to the exsisting\r\n+     *  exception meassage\r\n+     */\r\n+    private String appendExtendedExceptionMsg(String msg, SQLException sqle){\r\n+       final String GETSQLCA =\"getSqlca\";\r\n+       String exceptionMsg = new String();\r\n+       try {\r\n+            Method sqlcaM2 = sqle.getNextException().getClass()\r\n+                             .getMethod(GETSQLCA,null);\r\n+            Object sqlca = sqlcaM2.invoke(sqle.getNextException(),\r\n+                                          new Object[] {});\r\n+            Method  getSqlErrpMethd = sqlca.getClass().\r\n+            getMethod(\"getSqlErrp\", null);\r\n+            Method  getSqlWarnMethd = sqlca.getClass().\r\n+            getMethod(\"getSqlWarn\", null);\r\n+            Method  getSqlErrdMethd = sqlca.getClass().\r\n+            getMethod(\"getSqlErrd\", null);\r\n+            StringBuffer errdStr = new StringBuffer();\r\n+\r\n+            int[] errds = (int[]) getSqlErrdMethd.invoke(sqlca, new Object[]{});\r\n+            for (int i = 0; i < errds.length; i++)\r\n+                errdStr.append(errdStr.length() > 0 ? \", \" : \"\").\r\n+                    append(errds[i]);\r\n+            exceptionMsg = exceptionMsg.concat( \"SQLCA OUTPUT\" +\r\n+                    \"[Errp=\" + getSqlErrpMethd.invoke(sqlca, new Object[]{})\r\n+                    + \", Errd=\" + errdStr);\r\n+\r\n+            String Warn = new String((char[]) getSqlWarnMethd.\r\n+                    invoke(sqlca, new Object[]{}));\r\n+            if (Warn.trim().length() != 0)\r\n+                exceptionMsg = exceptionMsg.concat(\", Warn=\" +Warn + \"]\" );\r\n+            else\r\n+                exceptionMsg = exceptionMsg.concat( \"]\" );\r\n+            msg = msg.concat(exceptionMsg);\r\n+            \r\n+            // for batched execution failures, SQLExceptions are nested\r\n+            SQLException sqle2 = sqle.getNextException();\r\n+            while (sqle2 != null) {                \r\n+                msg = msg.concat(\"\\n\" + sqle2.getMessage());\r\n+                sqle2 = sqle2.getNextException();\r\n+            }\r\n+            \r\n+            return msg;\r\n+        } catch (Throwable t) {\r\n+            return sqle.getMessage();\r\n+        }\r\n+    }\r\n+\r\n+    public int getDb2ServerType() {\r\n+        return db2ServerType;\r\n+    }\r\n+    \r\n+    protected void appendLength(SQLBuffer buf, int type) {\r\n+        if (type == Types.VARCHAR)\r\n+            buf.append(\"(\").append(Integer.toString(characterColumnSize)).\r\n+                append(\")\");\r\n+    }\r\n+\r\n+    /**\r\n+     * If this dictionary supports XML type,\r\n+     * use this method to append xml predicate.\r\n+     * \r\n+     * @param buf the SQL buffer to write the comparison\r\n+     * @param op the comparison operation to perform\r\n+     * @param lhs the left hand side of the comparison\r\n+     * @param rhs the right hand side of the comparison\r\n+     * @param lhsxml indicates whether the left operand maps to xml\r\n+     * @param rhsxml indicates whether the right operand maps to xml\r\n+     */\r\n+    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\r\n+        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\r\n+        super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\r\n+        if (lhsxml && rhsxml)\r\n+            appendXmlComparison2(buf, op, lhs, rhs);\r\n+        else if (lhsxml)\r\n+            appendXmlComparison1(buf, op, lhs, rhs);\r\n+        else \r\n+            appendXmlComparison1(buf, op, rhs, lhs);\r\n+    }\r\n+\r\n+    /**\r\n+     * Append an xml comparison predicate.\r\n+     *\r\n+     * @param buf the SQL buffer to write the comparison\r\n+     * @param op the comparison operation to perform\r\n+     * @param lhs the left hand side of the comparison (maps to xml column)\r\n+     * @param rhs the right hand side of the comparison\r\n+     */\r\n+    private void appendXmlComparison1(SQLBuffer buf, String op, \r\n+            FilterValue lhs, FilterValue rhs) {\r\n+        boolean castrhs = false;\r\n+        Class rc = Filters.wrap(rhs.getType());\r\n+        int type = 0;\r\n+        if (rhs.isConstant()) {\r\n+            type = getJDBCType(JavaTypes.getTypeCode(rc), false);\r\n+            castrhs = true;\r\n+        }\r\n+        \r\n+        appendXmlExists(buf, lhs);\r\n+\r\n+        buf.append(\" \").append(op).append(\" \");\r\n+        \r\n+        buf.append(\"$\");\r\n+        if (castrhs)\r\n+            buf.append(\"Parm\");\r\n+        else\r\n+            rhs.appendTo(buf);\r\n+        \r\n+        buf.append(\"]' PASSING \");\r\n+        appendXmlVar(buf, lhs);\r\n+        buf.append(\", \");\r\n+        \r\n+        if (castrhs)\r\n+            appendCast(buf, rhs, type);\r\n+        else\r\n+            rhs.appendTo(buf);\r\n+        \r\n+        buf.append(\" AS \\\"\");\r\n+        if (castrhs)\r\n+            buf.append(\"Parm\");\r\n+        else\r\n+            rhs.appendTo(buf);\r\n+        buf.append(\"\\\")\");\r\n+    }\r\n+    \r\n+    /**\r\n+     * Append an xml comparison predicate. (both operands map to xml column)\r\n+     *\r\n+     * @param buf the SQL buffer to write the comparison\r\n+     * @param op the comparison operation to perform\r\n+     * @param lhs the left hand side of the comparison (maps to xml column)\r\n+     * @param rhs the right hand side of the comparison (maps to xml column)\r\n+     */\r\n+    private void appendXmlComparison2(SQLBuffer buf, String op, \r\n+            FilterValue lhs, FilterValue rhs) {\r\n+        appendXmlExists(buf, lhs);\r\n+        \r\n+        buf.append(\" \").append(op).append(\" \");\r\n+        \r\n+        buf.append(\"$\").append(rhs.getColumnAlias(\r\n+            rhs.getFieldMapping().getColumns()[0])).\r\n+            append(\"/*/\");\r\n+        rhs.appendTo(buf);\r\n+        \r\n+        buf.append(\"]' PASSING \");\r\n+        appendXmlVar(buf, lhs);\r\n+        buf.append(\", \");\r\n+        appendXmlVar(buf, rhs);\r\n+        buf.append(\")\");\r\n+    }\r\n+    \r\n+    private void appendXmlVar(SQLBuffer buf, FilterValue val) {\r\n+        buf.append(val.getColumnAlias(\r\n+            val.getFieldMapping().getColumns()[0])).\r\n+            append(\" AS \").\r\n+            append(\"\\\"\").append(val.getColumnAlias(\r\n+            val.getFieldMapping().getColumns()[0])).\r\n+            append(\"\\\"\");        \r\n+    }\r\n+    \r\n+    private void appendXmlExists(SQLBuffer buf, FilterValue val) {\r\n+        buf.append(\"XMLEXISTS('\");\r\n+        buf.append(\"$\").append(val.getColumnAlias(\r\n+            val.getFieldMapping().getColumns()[0])).\r\n+            append(\"/*[\");\r\n+        val.appendTo(buf);        \r\n+    }\r\n+    \r\n+    /**\r\n+     * add CAST for a scalar function where operand is a param\r\n+     * \r\n+     * @param func original string\r\n+     * @param target substring to look for\r\n+     * @param asString \r\n+     * @return updated string (func)\r\n+     */\r\n+    private String addCastAsString(String func, String target, \r\n+            String asString) {\r\n+        String fstring = func;\r\n+        if (func.indexOf(target) != -1)\r\n+            fstring = Strings.replace(\r\n+                func, target, \"CAST(\" + target + asString + \")\");\r\n+        return fstring;\r\n+    }\r\n+\r\n+    /**\r\n+     * add CAST for a function operator where operand is a param\r\n+     * \r\n+     * @param func function name\r\n+     * @param val type\r\n+     * @return updated string (func)\r\n+     */\r\n+    public String addCastAsType(String func, Val val) {\r\n+        String fstring = null;\r\n+        String type = getTypeName(getJDBCType(JavaTypes.getTypeCode(val\r\n+            .getType()), false));\r\n+        if (String.class.equals(val.getType()))\r\n+            type = type + \"(\" + characterColumnSize + \")\";\r\n+        fstring = \"CAST(? AS \" + type + \")\";\r\n+        return fstring;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the batch limit. If the batchLimit is -1, change it to 100 for\r\n+     * best performance\r\n+     */\r\n+    public int getBatchLimit() {\r\n+        int limit = super.getBatchLimit();\r\n+        if (limit == UNLIMITED) {\r\n+            limit = defaultBatchLimit;\r\n+            if (log.isTraceEnabled())\r\n+                log.trace(_loc.get(\"batch_unlimit\", String.valueOf(limit)));\r\n+        }\r\n+        return limit;\r\n+    }\r\n+\r\n+    /**\r\n+     * Return the correct CAST function syntax\r\n+     * \r\n+     * @param val operand of cast\r\n+     * @param func original string\r\n+     * @return a String with the correct CAST function syntax\r\n+     */\r\n+    public String getCastFunction(Val val, String func) {\r\n+        if (val instanceof Lit || val instanceof Param)\r\n+            if (func.indexOf(\"VARCHAR\") == -1)\r\n+                func = addCastAsString(func, \"{0}\", \" AS VARCHAR(1000)\");\r\n+        return func;\r\n+    }\r\n+\r\n+    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\r\n+            FilterValue start) {\r\n+        if (find.getValue() != null) { // non constants\r\n+            buf.append(\"(LOCATE(CAST((\");\r\n+            find.appendTo(buf);\r\n+            buf.append(\") AS VARCHAR(1000)), \");\r\n+        } else {\r\n+            // this is a constant\r\n+            buf.append(\"(LOCATE(\");\r\n+            find.appendTo(buf);\r\n+            buf.append(\", \");\r\n+        }\r\n+        if (str.getValue() != null) {\r\n+            buf.append(\"CAST((\");\r\n+            str.appendTo(buf);\r\n+            buf.append(\") AS VARCHAR(1000))\");\r\n+        } else {\r\n+            str.appendTo(buf);\r\n+        }\r\n+        if (start != null) {\r\n+            if (start.getValue() == null) {\r\n+                buf.append(\", CAST((\");\r\n+                start.appendTo(buf);\r\n+                buf.append(\") AS INTEGER) + 1\");\r\n+            } else {\r\n+                buf.append(\", \");\r\n+                start.appendTo(buf);\r\n+            }\r\n+        }\r\n+        buf.append(\") - 1)\");\r\n+    }\r\n+    \r\n+    /** \r\n+     * Cast the specified value to the specified type.\r\n+     *\r\n+     * @param buf the buffer to append the cast to\r\n+     * @param val the value to cast\r\n+     * @param type the type of the case, e.g. {@link Types#NUMERIC}\r\n+     */\r\n+    public void appendCast(SQLBuffer buf, FilterValue val, int type) {\r\n+\r\n+        // Convert the cast function: \"CAST({0} AS {1})\"\r\n+        int firstParam = castFunction.indexOf(\"{0}\");\r\n+        String pre = castFunction.substring(0, firstParam); // \"CAST(\"\r\n+        String mid = castFunction.substring(firstParam + 3);\r\n+        int secondParam = mid.indexOf(\"{1}\");\r\n+        String post;\r\n+        if (secondParam > -1) {\r\n+            post = mid.substring(secondParam + 3); // \")\"\r\n+            mid = mid.substring(0, secondParam); // \" AS \"\r\n+        } else\r\n+            post = \"\";\r\n+\r\n+        // No need to add CAST if the value is a constant\r\n+        if (val instanceof Lit || val instanceof Param) {\r\n+            buf.append(pre);\r\n+            val.appendTo(buf);\r\n+            buf.append(mid);\r\n+            buf.append(getTypeName(type));\r\n+            appendLength(buf, type);\r\n+            buf.append(post);\r\n+        } else {\r\n+            val.appendTo(buf);\r\n+            String sqlString = buf.getSQL(false);\r\n+            if (sqlString.endsWith(\"?\")) {\r\n+                // case \"(?\" - convert to \"CAST(? AS type\"\r\n+                String typeName = getTypeName(type);\r\n+                if (String.class.equals(val.getType()))\r\n+                    typeName = typeName + \"(\" + characterColumnSize + \")\";\r\n+                String str = \"CAST(? AS \" + typeName + \")\";\r\n+                buf.replaceSqlString(sqlString.length() - 1,\r\n+                        sqlString.length(), str);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Create an index if necessary for some database tables\r\n+     */\r\n+    public void createIndexIfNecessary(Schema schema, String table,\r\n+            Column pkColumn) {\r\n+        if (isDB2ZOSV8xOrLater()) {\r\n+            // build the index for the sequence tables\r\n+            // the index name will the fully qualified table name + _IDX\r\n+            Table tab = schema.getTable(table);\r\n+            Index idx = tab.addIndex(tab.getFullName() + \"_IDX\");\r\n+            idx.setUnique(true);\r\n+            idx.addColumn(pkColumn);\r\n+        }\r\n+    }\r\n+    \r\n+    String nullSafe(String s) {\r\n+    \treturn s == null ? \"\" : s;\r\n+    }\r\n+}\r"},{"sha":"ce8f050a6d11685101ebca2d8b0c64b11c03b337","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","status":"added","additions":4543,"deletions":0,"changes":4543,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"aa67411190c4b9331070eb00bdec2da96cf22575","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionaryFactory.java","status":"added","additions":615,"deletions":0,"changes":615,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionaryFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionaryFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionaryFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,615 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.SQLException;\n+import javax.sql.DataSource;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.StoreException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Factory class to instantiate a dictionary. It will use\n+ * the following heuristic:\n+ * <ul>\n+ * <li>Check to see if there is a DictionaryClass property,\n+ * and if so, use that to instantiate the dictionary.</li>\n+ * <li>Check the URL in the JDBCConfiguration against a list\n+ * of pre-defined URLs for various dictionaries.</li>\n+ * <li>Check the driver in the JDBCConfiguration against a list of known\n+ * patterns.</li>\n+ * <li>Acquire a connection and check its database metadata.</li>\n+ * <li>Return an instance of the generic DBDictionary.</li>\n+ * </ul>\n+ *\n+ * @author Marc Prud'hommeaux\n+ * @nojavadoc\n+ */\n+public class DBDictionaryFactory {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (DBDictionaryFactory.class);\n+\n+    /**\n+     * Create the dictionary for the given class name and properties.\n+     */\n+    public static DBDictionary newDBDictionary(JDBCConfiguration conf,\n+        String dclass, String props) {\n+        return newDBDictionary(conf, dclass, props, null);\n+    }\n+\n+    /**\n+     * Attempt to create the dictionary from the given connection URL and\n+     * driver name, either or both of which may be null. If the dictionary\n+     * cannot be calculated, returns null.\n+     */\n+    public static DBDictionary calculateDBDictionary(JDBCConfiguration conf,\n+        String url, String driver, String props) {\n+        String dclass = dictionaryClassForString(url, conf);\n+        if (dclass == null)\n+            dclass = dictionaryClassForString(driver, conf);\n+        if (dclass == null)\n+            return null;\n+        return newDBDictionary(conf, dclass, props);\n+    }\n+\n+    /**\n+     * Create the dictionary using connection metadata to determine its type.\n+     */\n+    public static DBDictionary newDBDictionary(JDBCConfiguration conf,\n+        DataSource ds, String props) {\n+        Connection conn = null;\n+        try {\n+            conn = ds.getConnection();\n+            DatabaseMetaData meta = conn.getMetaData();\n+            String dclass = dictionaryClassForString(meta.getURL(), conf);\n+            if (dclass == null)\n+                dclass = dictionaryClassForString\n+                    (meta.getDatabaseProductName(), conf);\n+            if (dclass == null)\n+                dclass = DBDictionary.class.getName();\n+            return newDBDictionary(conf, dclass, props, conn);\n+        } catch (SQLException se) {\n+            throw new StoreException(se).setFatal(true);\n+        } finally {\n+            if (conn != null)\n+                try {\n+                    conn.close();\n+                } catch (SQLException se) {\n+                }\n+        }\n+    }\n+\n+    /**\n+     * Create the dictionary using the given class name and properties; the\n+     * connection may be null if not supplied to the factory.\n+     */\n+    private static DBDictionary newDBDictionary(JDBCConfiguration conf,\n+        String dclass, String props, Connection conn) {\n+        DBDictionary dict = null;\n+        try {\n+            Class c = Class.forName(dclass, true,\n+                (ClassLoader) AccessController.doPrivileged(\n+                    J2DoPrivHelper.getClassLoaderAction(\n+                        DBDictionary.class)));\n+            dict = (DBDictionary) AccessController.doPrivileged(\n+                J2DoPrivHelper.newInstanceAction(c));\n+        } catch (Exception e) {\n+            if (e instanceof PrivilegedActionException)\n+                e = ((PrivilegedActionException) e).getException();\n+            throw new UserException(e).setFatal(true);\n+        }\n+\n+        // warn if we could not locate the appropriate dictionary\n+        Log log = conf.getLog(JDBCConfiguration.LOG_JDBC);\n+        if (log.isWarnEnabled() && dict.getClass() == DBDictionary.class)\n+            log.warn(_loc.get(\"warn-generic\"));\n+\n+        if (log.isInfoEnabled()) {\n+            String infoString = \"\";\n+            if (conn != null) {\n+                try {\n+                    DatabaseMetaData meta = conn.getMetaData();\n+                    infoString = \" (\" + meta.getDatabaseProductName() + \" \"\n+                        + meta.getDatabaseProductVersion() + \" ,\"\n+                        + meta.getDriverName() + \" \"\n+                        + meta.getDriverVersion() + \")\";\n+                } catch (SQLException se) {\n+                    if (log.isTraceEnabled())\n+                        log.trace(se.toString(), se);\n+                }\n+            }\n+\n+            log.info(_loc.get(\"using-dict\", dclass, infoString));\n+        }\n+\n+        // set the dictionary's metadata\n+        Configurations.configureInstance(dict, conf, props, \"DBDictionary\");\n+        if (conn != null) {\n+            try {\n+                dict.connectedConfiguration(conn);\n+            } catch (SQLException se) {\n+                throw new StoreException(se).setFatal(true);\n+            }\n+        }\n+        return dict;\n+    }\n+\n+    /**\n+     * Guess the dictionary class name to use based on the product string.\n+     */\n+    private static String dictionaryClassForString(String prod\n+        , JDBCConfiguration conf) {\n+        if (StringUtils.isEmpty(prod))\n+            return null;\n+        prod = prod.toLowerCase();\n+\n+        PluginValue dbdictionaryPlugin = ((JDBCConfigurationImpl) conf)\n+            .dbdictionaryPlugin;\n+\n+        if (prod.indexOf(\"oracle\") != -1)\n+            return dbdictionaryPlugin.unalias(\"oracle\");\n+        if (prod.indexOf(\"sqlserver\") != -1)\n+            return dbdictionaryPlugin.unalias(\"sqlserver\");\n+        if (prod.indexOf(\"jsqlconnect\") != -1)\n+            return dbdictionaryPlugin.unalias(\"sqlserver\");\n+        if (prod.indexOf(\"mysql\") != -1)\n+            return dbdictionaryPlugin.unalias(\"mysql\");\n+        if (prod.indexOf(\"postgres\") != -1)\n+            return dbdictionaryPlugin.unalias(\"postgres\");\n+        if (prod.indexOf(\"sybase\") != -1)\n+            return dbdictionaryPlugin.unalias(\"sybase\");\n+        if (prod.indexOf(\"adaptive server\") != -1)\n+            return dbdictionaryPlugin.unalias(\"sybase\");\n+        if (prod.indexOf(\"informix\") != -1)\n+            return dbdictionaryPlugin.unalias(\"informix\");\n+        if (prod.indexOf(\"hsql\") != -1)\n+            return dbdictionaryPlugin.unalias(\"hsql\");\n+        if (prod.indexOf(\"foxpro\") != -1)\n+            return dbdictionaryPlugin.unalias(\"foxpro\");\n+        if (prod.indexOf(\"interbase\") != -1)\n+            return InterbaseDictionary.class.getName();\n+        if (prod.indexOf(\"jdatastore\") != -1)\n+            return JDataStoreDictionary.class.getName();\n+        if (prod.indexOf(\"borland\") != -1)\n+            return JDataStoreDictionary.class.getName();\n+        if (prod.indexOf(\"access\") != -1)\n+            return dbdictionaryPlugin.unalias(\"access\");\n+        if (prod.indexOf(\"pointbase\") != -1)\n+            return dbdictionaryPlugin.unalias(\"pointbase\");\n+        if (prod.indexOf(\"empress\") != -1)\n+            return dbdictionaryPlugin.unalias(\"empress\");\n+        if (prod.indexOf(\"firebird\") != -1)\n+            return FirebirdDictionary.class.getName();\n+        if (prod.indexOf(\"cache\") != -1)\n+            return CacheDictionary.class.getName();\n+        if (prod.indexOf(\"derby\") != -1)\n+            return dbdictionaryPlugin.unalias(\"derby\");\n+        // test h2 in a special way, because there's a decent chance the string \n+        // h2 could appear in the URL of another database\n+        if (prod.indexOf(\"jdbc:h2:\") != -1)\n+            return dbdictionaryPlugin.unalias(\"h2\");\n+        if (prod.indexOf(\"h2 database\") != -1)\n+            return dbdictionaryPlugin.unalias(\"h2\");\n+        // test db2 last, because there's a decent chance this string could\n+        // appear in the URL of another database (like if the db is named\n+        // \"testdb2\" or something)\n+        if (prod.indexOf(\"db2\") != -1 || prod.indexOf(\"as400\") != -1)\n+            return dbdictionaryPlugin.unalias(\"db2\");\n+\n+        // known dbs that we don't support\n+        if (prod.indexOf(\"cloudscape\") != -1)\n+            return DBDictionary.class.getName();\n+        if (prod.indexOf(\"daffodil\") != -1)\n+            return DBDictionary.class.getName();\n+        if (prod.indexOf(\"sapdb\") != -1)\n+            return DBDictionary.class.getName();\n+        if (prod.indexOf(\"idb\") != -1) // instantdb\n+            return DBDictionary.class.getName();\n+\n+        String prodClassName = dbdictionaryPlugin.unalias(prod);\n+        if (!StringUtils.equals(prod, prodClassName))\n+            return prodClassName;\n+        \n+        // give up\n+        return null;\n+    }\n+\n+    /**\n+     * Return a string containing all the property values of the given\n+     * database metadata.\n+     */\n+    public static String toString(DatabaseMetaData meta)\n+        throws SQLException {\n+        String lineSep = J2DoPrivHelper.getLineSeparator();\n+        StringBuffer buf = new StringBuffer();\n+        try {\n+            buf.append(\"catalogSeparator: \")\n+                .append(meta.getCatalogSeparator())\n+                .append(lineSep)\n+                .append(\"catalogTerm: \")\n+                .append(meta.getCatalogTerm())\n+                .append(lineSep)\n+                .append(\"databaseProductName: \")\n+                .append(meta.getDatabaseProductName())\n+                .append(lineSep)\n+                .append(\"databaseProductVersion: \")\n+                .append(meta.getDatabaseProductVersion())\n+                .append(lineSep)\n+                .append(\"driverName: \")\n+                .append(meta.getDriverName())\n+                .append(lineSep)\n+                .append(\"driverVersion: \")\n+                .append(meta.getDriverVersion())\n+                .append(lineSep)\n+                .append(\"extraNameCharacters: \")\n+                .append(meta.getExtraNameCharacters())\n+                .append(lineSep)\n+                .append(\"identifierQuoteString: \")\n+                .append(meta.getIdentifierQuoteString())\n+                .append(lineSep)\n+                .append(\"numericFunctions: \")\n+                .append(meta.getNumericFunctions())\n+                .append(lineSep)\n+                .append(\"procedureTerm: \")\n+                .append(meta.getProcedureTerm())\n+                .append(lineSep)\n+                .append(\"schemaTerm: \")\n+                .append(meta.getSchemaTerm())\n+                .append(lineSep)\n+                .append(\"searchStringEscape: \")\n+                .append(meta.getSearchStringEscape())\n+                .append(lineSep)\n+                .append(\"sqlKeywords: \")\n+                .append(meta.getSQLKeywords())\n+                .append(lineSep)\n+                .append(\"stringFunctions: \")\n+                .append(meta.getStringFunctions())\n+                .append(lineSep)\n+                .append(\"systemFunctions: \")\n+                .append(meta.getSystemFunctions())\n+                .append(lineSep)\n+                .append(\"timeDateFunctions: \")\n+                .append(meta.getTimeDateFunctions())\n+                .append(lineSep)\n+                .append(\"url: \")\n+                .append(meta.getURL())\n+                .append(lineSep)\n+                .append(\"userName: \")\n+                .append(meta.getUserName())\n+                .append(lineSep)\n+                .append(\"defaultTransactionIsolation: \")\n+                .append(meta.getDefaultTransactionIsolation())\n+                .append(lineSep)\n+                .append(\"driverMajorVersion: \")\n+                .append(meta.getDriverMajorVersion())\n+                .append(lineSep)\n+                .append(\"driverMinorVersion: \")\n+                .append(meta.getDriverMinorVersion())\n+                .append(lineSep)\n+                .append(\"maxBinaryLiteralLength: \")\n+                .append(meta.getMaxBinaryLiteralLength())\n+                .append(lineSep)\n+                .append(\"maxCatalogNameLength: \")\n+                .append(meta.getMaxCatalogNameLength())\n+                .append(lineSep)\n+                .append(\"maxCharLiteralLength: \")\n+                .append(meta.getMaxCharLiteralLength())\n+                .append(lineSep)\n+                .append(\"maxColumnNameLength: \")\n+                .append(meta.getMaxColumnNameLength())\n+                .append(lineSep)\n+                .append(\"maxColumnsInGroupBy: \")\n+                .append(meta.getMaxColumnsInGroupBy())\n+                .append(lineSep)\n+                .append(\"maxColumnsInIndex: \")\n+                .append(meta.getMaxColumnsInIndex())\n+                .append(lineSep)\n+                .append(\"maxColumnsInOrderBy: \")\n+                .append(meta.getMaxColumnsInOrderBy())\n+                .append(lineSep)\n+                .append(\"maxColumnsInSelect: \")\n+                .append(meta.getMaxColumnsInSelect())\n+                .append(lineSep)\n+                .append(\"maxColumnsInTable: \")\n+                .append(meta.getMaxColumnsInTable())\n+                .append(lineSep)\n+                .append(\"maxConnections: \")\n+                .append(meta.getMaxConnections())\n+                .append(lineSep)\n+                .append(\"maxCursorNameLength: \")\n+                .append(meta.getMaxCursorNameLength())\n+                .append(lineSep)\n+                .append(\"maxIndexLength: \")\n+                .append(meta.getMaxIndexLength())\n+                .append(lineSep)\n+                .append(\"maxProcedureNameLength: \")\n+                .append(meta.getMaxProcedureNameLength())\n+                .append(lineSep)\n+                .append(\"maxRowSize: \")\n+                .append(meta.getMaxRowSize())\n+                .append(lineSep)\n+                .append(\"maxSchemaNameLength: \")\n+                .append(meta.getMaxSchemaNameLength())\n+                .append(lineSep)\n+                .append(\"maxStatementLength: \")\n+                .append(meta.getMaxStatementLength())\n+                .append(lineSep)\n+                .append(\"maxStatements: \")\n+                .append(meta.getMaxStatements())\n+                .append(lineSep)\n+                .append(\"maxTableNameLength: \")\n+                .append(meta.getMaxTableNameLength())\n+                .append(lineSep)\n+                .append(\"maxTablesInSelect: \")\n+                .append(meta.getMaxTablesInSelect())\n+                .append(lineSep)\n+                .append(\"maxUserNameLength: \")\n+                .append(meta.getMaxUserNameLength())\n+                .append(lineSep)\n+                .append(\"isCatalogAtStart: \")\n+                .append(meta.isCatalogAtStart())\n+                .append(lineSep)\n+                .append(\"isReadOnly: \")\n+                .append(meta.isReadOnly())\n+                .append(lineSep)\n+                .append(\"nullPlusNonNullIsNull: \")\n+                .append(meta.nullPlusNonNullIsNull())\n+                .append(lineSep)\n+                .append(\"nullsAreSortedAtEnd: \")\n+                .append(meta.nullsAreSortedAtEnd())\n+                .append(lineSep)\n+                .append(\"nullsAreSortedAtStart: \")\n+                .append(meta.nullsAreSortedAtStart())\n+                .append(lineSep)\n+                .append(\"nullsAreSortedHigh: \")\n+                .append(meta.nullsAreSortedHigh())\n+                .append(lineSep)\n+                .append(\"nullsAreSortedLow: \")\n+                .append(meta.nullsAreSortedLow())\n+                .append(lineSep)\n+                .append(\"storesLowerCaseIdentifiers: \")\n+                .append(meta.storesLowerCaseIdentifiers())\n+                .append(lineSep)\n+                .append(\"storesLowerCaseQuotedIdentifiers: \")\n+                .append(meta.storesLowerCaseQuotedIdentifiers())\n+                .append(lineSep)\n+                .append(\"storesMixedCaseIdentifiers: \")\n+                .append(meta.storesMixedCaseIdentifiers())\n+                .append(lineSep)\n+                .append(\"storesMixedCaseQuotedIdentifiers: \")\n+                .append(meta.storesMixedCaseQuotedIdentifiers())\n+                .append(lineSep)\n+                .append(\"storesUpperCaseIdentifiers: \")\n+                .append(meta.storesUpperCaseIdentifiers())\n+                .append(lineSep)\n+                .append(\"storesUpperCaseQuotedIdentifiers: \")\n+                .append(meta.storesUpperCaseQuotedIdentifiers())\n+                .append(lineSep)\n+                .append(\"supportsAlterTableWithAddColumn: \")\n+                .append(meta.supportsAlterTableWithAddColumn())\n+                .append(lineSep)\n+                .append(\"supportsAlterTableWithDropColumn: \")\n+                .append(meta.supportsAlterTableWithDropColumn())\n+                .append(lineSep)\n+                .append(\"supportsANSI92EntryLevelSQL: \")\n+                .append(meta.supportsANSI92EntryLevelSQL())\n+                .append(lineSep)\n+                .append(\"supportsANSI92FullSQL: \")\n+                .append(meta.supportsANSI92FullSQL())\n+                .append(lineSep)\n+                .append(\"supportsANSI92IntermediateSQL: \")\n+                .append(meta.supportsANSI92IntermediateSQL())\n+                .append(lineSep)\n+                .append(\"supportsCatalogsInDataManipulation: \")\n+                .append(meta.supportsCatalogsInDataManipulation())\n+                .append(lineSep)\n+                .append(\"supportsCatalogsInIndexDefinitions: \")\n+                .append(meta.supportsCatalogsInIndexDefinitions())\n+                .append(lineSep)\n+                .append(\"supportsCatalogsInPrivilegeDefinitions: \")\n+                .append(meta.supportsCatalogsInPrivilegeDefinitions())\n+                .append(lineSep)\n+                .append(\"supportsCatalogsInProcedureCalls: \")\n+                .append(meta.supportsCatalogsInProcedureCalls())\n+                .append(lineSep)\n+                .append(\"supportsCatalogsInTableDefinitions: \")\n+                .append(meta.supportsCatalogsInTableDefinitions())\n+                .append(lineSep)\n+                .append(\"supportsColumnAliasing: \")\n+                .append(meta.supportsColumnAliasing())\n+                .append(lineSep)\n+                .append(\"supportsConvert: \")\n+                .append(meta.supportsConvert())\n+                .append(lineSep)\n+                .append(\"supportsCoreSQLGrammar: \")\n+                .append(meta.supportsCoreSQLGrammar())\n+                .append(lineSep)\n+                .append(\"supportsCorrelatedSubqueries: \")\n+                .append(meta.supportsCorrelatedSubqueries())\n+                .append(lineSep)\n+                .append(\n+                    \"supportsDataDefinitionAndDataManipulationTransactions: \")\n+                .append(meta.\n+                    supportsDataDefinitionAndDataManipulationTransactions())\n+                .append(lineSep)\n+                .append(\"supportsDataManipulationTransactionsOnly: \")\n+                .append(meta.supportsDataManipulationTransactionsOnly())\n+                .append(lineSep)\n+                .append(\"supportsDifferentTableCorrelationNames: \")\n+                .append(meta.supportsDifferentTableCorrelationNames())\n+                .append(lineSep)\n+                .append(\"supportsExpressionsInOrderBy: \")\n+                .append(meta.supportsExpressionsInOrderBy())\n+                .append(lineSep)\n+                .append(\"supportsExtendedSQLGrammar: \")\n+                .append(meta.supportsExtendedSQLGrammar())\n+                .append(lineSep)\n+                .append(\"supportsFullOuterJoins: \")\n+                .append(meta.supportsFullOuterJoins())\n+                .append(lineSep)\n+                .append(\"supportsGroupBy: \")\n+                .append(meta.supportsGroupBy())\n+                .append(lineSep)\n+                .append(\"supportsGroupByBeyondSelect: \")\n+                .append(meta.supportsGroupByBeyondSelect())\n+                .append(lineSep)\n+                .append(\"supportsGroupByUnrelated: \")\n+                .append(meta.supportsGroupByUnrelated())\n+                .append(lineSep)\n+                .append(\"supportsIntegrityEnhancementFacility: \")\n+                .append(meta.supportsIntegrityEnhancementFacility())\n+                .append(lineSep)\n+                .append(\"supportsLikeEscapeClause: \")\n+                .append(meta.supportsLikeEscapeClause())\n+                .append(lineSep)\n+                .append(\"supportsLimitedOuterJoins: \")\n+                .append(meta.supportsLimitedOuterJoins())\n+                .append(lineSep)\n+                .append(\"supportsMinimumSQLGrammar: \")\n+                .append(meta.supportsMinimumSQLGrammar())\n+                .append(lineSep)\n+                .append(\"supportsMixedCaseIdentifiers: \")\n+                .append(meta.supportsMixedCaseIdentifiers())\n+                .append(lineSep)\n+                .append(\"supportsMixedCaseQuotedIdentifiers: \")\n+                .append(meta.supportsMixedCaseQuotedIdentifiers())\n+                .append(lineSep)\n+                .append(\"supportsMultipleResultSets: \")\n+                .append(meta.supportsMultipleResultSets())\n+                .append(lineSep)\n+                .append(\"supportsMultipleTransactions: \")\n+                .append(meta.supportsMultipleTransactions())\n+                .append(lineSep)\n+                .append(\"supportsNonNullableColumns: \")\n+                .append(meta.supportsNonNullableColumns())\n+                .append(lineSep)\n+                .append(\"supportsOpenCursorsAcrossCommit: \")\n+                .append(meta.supportsOpenCursorsAcrossCommit())\n+                .append(lineSep)\n+                .append(\"supportsOpenCursorsAcrossRollback: \")\n+                .append(meta.supportsOpenCursorsAcrossRollback())\n+                .append(lineSep)\n+                .append(\"supportsOpenStatementsAcrossCommit: \")\n+                .append(meta.supportsOpenStatementsAcrossCommit())\n+                .append(lineSep)\n+                .append(\"supportsOpenStatementsAcrossRollback: \")\n+                .append(meta.supportsOpenStatementsAcrossRollback())\n+                .append(lineSep)\n+                .append(\"supportsOrderByUnrelated: \")\n+                .append(meta.supportsOrderByUnrelated())\n+                .append(lineSep)\n+                .append(\"supportsOuterJoins: \")\n+                .append(meta.supportsOuterJoins())\n+                .append(lineSep)\n+                .append(\"supportsPositionedDelete: \")\n+                .append(meta.supportsPositionedDelete())\n+                .append(lineSep)\n+                .append(\"supportsPositionedUpdate: \")\n+                .append(meta.supportsPositionedUpdate())\n+                .append(lineSep)\n+                .append(\"supportsSchemasInDataManipulation: \")\n+                .append(meta.supportsSchemasInDataManipulation())\n+                .append(lineSep)\n+                .append(\"supportsSchemasInIndexDefinitions: \")\n+                .append(meta.supportsSchemasInIndexDefinitions())\n+                .append(lineSep)\n+                .append(\"supportsSchemasInPrivilegeDefinitions: \")\n+                .append(meta.supportsSchemasInPrivilegeDefinitions())\n+                .append(lineSep)\n+                .append(\"supportsSchemasInProcedureCalls: \")\n+                .append(meta.supportsSchemasInProcedureCalls())\n+                .append(lineSep)\n+                .append(\"supportsSchemasInTableDefinitions: \")\n+                .append(meta.supportsSchemasInTableDefinitions())\n+                .append(lineSep)\n+                .append(\"supportsSelectForUpdate: \")\n+                .append(meta.supportsSelectForUpdate())\n+                .append(lineSep)\n+                .append(\"supportsStoredProcedures: \")\n+                .append(meta.supportsStoredProcedures())\n+                .append(lineSep)\n+                .append(\"supportsSubqueriesInComparisons: \")\n+                .append(meta.supportsSubqueriesInComparisons())\n+                .append(lineSep)\n+                .append(\"supportsSubqueriesInExists: \")\n+                .append(meta.supportsSubqueriesInExists())\n+                .append(lineSep)\n+                .append(\"supportsSubqueriesInIns: \")\n+                .append(meta.supportsSubqueriesInIns())\n+                .append(lineSep)\n+                .append(\"supportsSubqueriesInQuantifieds: \")\n+                .append(meta.supportsSubqueriesInQuantifieds())\n+                .append(lineSep)\n+                .append(\"supportsTableCorrelationNames: \")\n+                .append(meta.supportsTableCorrelationNames())\n+                .append(lineSep)\n+                .append(\"supportsTransactions: \")\n+                .append(meta.supportsTransactions())\n+                .append(lineSep)\n+                .append(\"supportsUnion: \")\n+                .append(meta.supportsUnion())\n+                .append(lineSep)\n+                .append(\"supportsUnionAll: \")\n+                .append(meta.supportsUnionAll())\n+                .append(lineSep)\n+                .append(\"usesLocalFilePerTable: \")\n+                .append(meta.usesLocalFilePerTable())\n+                .append(lineSep)\n+                .append(\"usesLocalFiles: \")\n+                .append(meta.usesLocalFiles())\n+                .append(lineSep)\n+                .append(\"allProceduresAreCallable: \")\n+                .append(meta.allProceduresAreCallable())\n+                .append(lineSep)\n+                .append(\"allTablesAreSelectable: \")\n+                .append(meta.allTablesAreSelectable())\n+                .append(lineSep)\n+                .append(\"dataDefinitionCausesTransactionCommit: \")\n+                .append(meta.dataDefinitionCausesTransactionCommit())\n+                .append(lineSep)\n+                .append(\"dataDefinitionIgnoredInTransactions: \")\n+                .append(meta.dataDefinitionIgnoredInTransactions())\n+                .append(lineSep)\n+                .append(\"doesMaxRowSizeIncludeBlobs: \")\n+                .append(meta.doesMaxRowSizeIncludeBlobs())\n+                .append(lineSep)\n+                .append(\"supportsBatchUpdates: \")\n+                .append(meta.supportsBatchUpdates());\n+        } catch (Throwable t) {\n+            // maybe abstract method error for jdbc 3 metadata method, or\n+            // other error\n+            buf.append(lineSep).append(\"Caught throwable: \").append(t);\n+        }\n+\n+        return buf.toString();\n+    }\n+}"},{"sha":"8453fe020408c2453acf6046648eb066572ab5c7","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java","status":"added","additions":103,"deletions":0,"changes":103,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.sql.DataSource;\n+\n+import org.apache.openjpa.util.StoreException;\n+\n+/**\n+ * Dictionary for Apache Derby (formerly Cloudscape).\n+ */\n+public class DerbyDictionary\n+    extends AbstractDB2Dictionary {\n+\n+    /**\n+     * If true, we will shutdown the embedded database when closing\n+     * the DataSource.\n+     */\n+    public boolean shutdownOnClose = true;\n+\n+    public DerbyDictionary() {\n+        platform = \"Apache Derby\";\n+        validationSQL = \"VALUES(1)\";\n+        stringLengthFunction = \"LENGTH({0})\";\n+        substringFunctionName = \"SUBSTR\";\n+\n+        maxConstraintNameLength = 18;\n+        maxIndexNameLength = 128;\n+        maxColumnNameLength = 30;\n+        maxTableNameLength = 128;\n+\n+        useGetBytesForBlobs = true;\n+        useSetBytesForBlobs = true;\n+\n+        allowsAliasInBulkClause = false;\n+        supportsDeferredConstraints = false;\n+        supportsSelectForUpdate = true;\n+        supportsDefaultDeleteAction = false;\n+        requiresCastForMathFunctions = true;\n+        requiresCastForComparisons = true;\n+\n+        supportsComments = true;\n+\n+        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\n+            \"BIGINT\", \"INTEGER\",\n+        }));\n+        reservedWordSet.addAll(Arrays.asList(new String[]{\n+            \"ALIAS\", \"BIGINT\", \"BOOLEAN\", \"CALL\", \"CLASS\",\n+            \"COPY\", \"DB2J_DEBUG\", \"EXECUTE\", \"EXPLAIN\",\n+            \"FILE\", \"FILTER\", \"GETCURRENTCONNECTION\", \"INDEX\",\n+            \"INSTANCEOF\", \"KEY\", \"METHOD\", \"NEW\", \"OFF\", \"OUT\", \"PROPERTIES\",\n+            \"PUBLICATION\", \"RECOMPILE\", \"REFRESH\", \"RENAME\",\n+            \"RUNTIMESTATISTICS\", \"STATEMENT\", \"STATISTICS\",\n+            \"TIMING\", \"WAIT\", \"XML\",\n+        }));\n+    }\n+\n+    public void closeDataSource(DataSource dataSource) {\n+        super.closeDataSource(dataSource);\n+\n+        if (!shutdownOnClose)\n+            return;\n+\n+        // as well as closing the DataSource, we also need to\n+        // shut down the instance if we are using an embedded database, which\n+        // can only be done by connecting to the same URL with the\n+        // \";shutdown=true\" string appended to the end\n+        // see: http://db.apache.org/derby/docs/dev/devguide/tdevdvlp40464.html\n+        if (conf != null && conf.getConnectionDriverName() != null &&\n+            conf.getConnectionDriverName().indexOf(\"EmbeddedDriver\") != -1) {\n+            try {\n+                DriverManager.getConnection(conf.getConnectionURL()\n+                    + \";shutdown=true\");\n+            } catch (SQLException e) {\n+                // we actuall expect a SQLException to be thrown here:\n+                // Derby strangely uses that as a mechanism to report\n+                // a successful shutdown\n+            }\n+        }\n+    }\n+}"},{"sha":"4e753881e26aa70350ceea73223483b7a38b8d3a","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/EmpressDictionary.java","status":"added","additions":174,"deletions":0,"changes":174,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/EmpressDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/EmpressDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/EmpressDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Table;\n+\n+/**\n+ * Dictionary for Empress using ODBC server combined with their\n+ * type 2 driver. This dictionary may issues with other\n+ * driver/topology configurations.\n+ *  Empress does not allow multiple connections to read rows\n+ * read in a transaction, effectively forcing pessimistic transactions\n+ * regardless of the Optimistic setting. To allow users to use\n+ * optimistic transactions in a multi-connection evironment, you\n+ * must set the AllowConcurrentRead setting to true in addition\n+ * to standard options.\n+ *  Empress has the following additional limitations:\n+ * <ul>\n+ * <li>Foreign keys are quite limited in Empress and it is recommended\n+ * that these be created by hand.</li>\n+ * <li>Batching can be unreliable. Using BatchLimit=0 is strongly\n+ * recommended.</li>\n+ * <li>Using AllowConcurrentRead should be accompanied by\n+ * SimulateLocking=true</li>\n+ * <li>Connections should be rolled back on return to ensure locks\n+ * are released (see OpenJPA default DataSource documentation.</li>\n+ * <li>Certain outer joins requiring parameters in a subselect is not\n+ * supported by Empress and may under certain configurations cause\n+ * size () calls on query results and LRS fields to throw an exception.</li>\n+ * <li>Certain aggregate functions are not supported.</li>\n+ * </ul>\n+ */\n+public class EmpressDictionary\n+    extends DBDictionary {\n+\n+    /**\n+     * This setting inserts \"BYPASS\" after every \"SELECT\". This\n+     * allows for multiple transactional reads of the same row\n+     * from different connections at the expense of loss of\n+     * pessimistic locking. Defaults to false.\n+     */\n+    public boolean allowConcurrentRead = false;\n+\n+    public EmpressDictionary() {\n+        platform = \"Empress\";\n+\n+        validationSQL = \"SELECT DISTINCT today FROM sys_tables\";\n+        joinSyntax = SYNTAX_TRADITIONAL;\n+        toUpperCaseFunction = \"TOUPPER({0})\";\n+        toLowerCaseFunction = \"TOLOWER({0})\";\n+\n+        supportsDeferredConstraints = false;\n+        requiresAliasForSubselect = true;\n+        maxTableNameLength = 28;\n+        maxColumnNameLength = 28;\n+        maxIndexNameLength = 28;\n+        maxConstraintNameLength = 28;\n+        schemaCase = SCHEMA_CASE_PRESERVE;\n+\n+        useGetBytesForBlobs = true;\n+        useSetBytesForBlobs = true;\n+        useGetStringForClobs = true;\n+        useSetStringForClobs = true;\n+\n+        clobTypeName = \"TEXT\";\n+        blobTypeName = \"BULK\";\n+        realTypeName = \"FLOAT(8)\";\n+        bigintTypeName = \"DECIMAL(38)\";\n+        timestampTypeName = \"DATE\";\n+        varcharTypeName = \"CHARACTER\";\n+        tinyintTypeName = \"DOUBLE PRECISION\";\n+        doubleTypeName = \"SMALLINT\";\n+        bitTypeName = \"SMALLINT\";\n+\n+        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\n+            \"TEXT\", \"BULK\", \"LONGFLOAT\", \"INTEGER64\", \"SHORTINTEGER\",\n+            \"LONGINTEGER\",\n+        }));\n+    }\n+\n+    public boolean isSystemIndex(String name, Table table) {\n+        return name.toUpperCase().startsWith(\"SYS_\");\n+    }\n+\n+    public SQLBuffer toSelect(SQLBuffer selects, JDBCFetchConfiguration fetch,\n+        SQLBuffer from, SQLBuffer where, SQLBuffer group,\n+        SQLBuffer having, SQLBuffer order,\n+        boolean distinct, boolean forUpdate, long startIdx, long endIdx) {\n+        if (!allowConcurrentRead)\n+            return super.toSelect(selects, fetch, from, where, group,\n+                having, order, distinct, forUpdate, startIdx, endIdx);\n+\n+        // override to allow a \"BYPASS\" to be inserted post-\"select\"\n+        // depending on allowConcurrentRead setting\n+        SQLBuffer buf = new SQLBuffer(this);\n+        buf.append(\"SELECT BYPASS \");\n+        if (distinct)\n+            buf.append(\"DISTINCT \");\n+        buf.append(selects).append(\" FROM \").append(from);\n+\n+        if (where != null && !where.isEmpty())\n+            buf.append(\" WHERE \").append(where);\n+        if (group != null && !group.isEmpty())\n+            buf.append(\" GROUP BY \").append(group);\n+        if (having != null && !having.isEmpty())\n+            buf.append(\" HAVING \").append(having);\n+        if (order != null && !order.isEmpty())\n+            buf.append(\" ORDER BY \").append(order);\n+        return buf;\n+    }\n+\n+    public String[] getDropColumnSQL(Column column) {\n+        // empress wants dropped columns in the form: ALTER TABLE foo\n+        // DELETE columnToDrop\n+        return new String[]{ \"ALTER TABLE \"\n+            + getFullName(column.getTable(), false) + \" DELETE \" + column };\n+    }\n+\n+    public void setFloat(PreparedStatement stmnt, int idx, float val,\n+        Column col)\n+        throws SQLException {\n+        // empress seems to allow INFINITY to be stored, but not retrieved,\n+        // which can prove to be difficult to handle\n+        if (val == Float.POSITIVE_INFINITY) {\n+            val = Float.MAX_VALUE;\n+            storageWarning(new Float(Float.POSITIVE_INFINITY),\n+                new Float(val));\n+        } else if (val == Float.NEGATIVE_INFINITY) {\n+            val = Float.MIN_VALUE + 1;\n+            storageWarning(new Float(Float.NEGATIVE_INFINITY),\n+                new Float(val));\n+        }\n+        super.setFloat(stmnt, idx, val, col);\n+    }\n+\n+    public void setDouble(PreparedStatement stmnt, int idx, double val,\n+        Column col)\n+        throws SQLException {\n+        // empress seems to allow INFINITY to be stored, but not retrieved,\n+        // which can prove to be difficult to handle\n+        if (val == Double.POSITIVE_INFINITY) {\n+            val = Double.MAX_VALUE;\n+            storageWarning(new Double(Double.POSITIVE_INFINITY),\n+                new Double(val));\n+        } else if (val == Double.NEGATIVE_INFINITY) {\n+            val = Double.MIN_VALUE + 1;\n+            storageWarning(new Double(Double.NEGATIVE_INFINITY),\n+                new Double(val));\n+        }\n+        super.setDouble(stmnt, idx, val, col);\n+    }\n+}"},{"sha":"3a4ba872a88ce60451f7141a6fc4c162b9c11daa","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FirebirdDictionary.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FirebirdDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FirebirdDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FirebirdDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.jdbc.schema.Column;\n+\n+/**\n+ * Dictionary for Firebird.\n+ */\n+public class FirebirdDictionary\n+    extends InterbaseDictionary {\n+\n+    public FirebirdDictionary() {\n+        platform = \"Firebird\";\n+\n+        // Firebird 1.5+ locking statement\n+        supportsLockingWithMultipleTables = false;\n+        forUpdateClause = \"FOR UPDATE WITH LOCK\";\n+    }\n+\n+    public String getPlaceholderValueString(Column col) {\n+        return super.getPlaceholderValueString(col)\n+            + \" AS \" + getTypeName(col);\n+    }\n+\n+    public void substring(SQLBuffer buf, FilterValue str, FilterValue start,\n+        FilterValue end) {\n+        // SUBSTRING in Firebird is of the form:\n+        // SELECT SUBSTRING(SOME_COLUMN FROM 1 FOR 5)\n+        buf.append(\"SUBSTRING(\");\n+        str.appendTo(buf);\n+        buf.append(\" FROM \");\n+        start.appendTo(buf);\n+        buf.append(\" + 1\");\n+        if (end != null) {\n+            buf.append(\" FOR \");\n+            end.appendTo(buf);\n+            buf.append(\" - (\");\n+            start.appendTo(buf);\n+            buf.append(\")\");\n+        }\n+        buf.append(\")\");\n+    }\n+}"},{"sha":"414942cf21675a7ce25076ff9d7aa34c6c8d6830","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FoxProDictionary.java","status":"added","additions":162,"deletions":0,"changes":162,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FoxProDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FoxProDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FoxProDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Index;\n+import org.apache.openjpa.jdbc.schema.PrimaryKey;\n+\n+/**\n+ * Dictionary for Visual FoxPro via DataDirect SequeLink\n+ * and DataDirect ODBC FoxPro driver. This will not\n+ * work with any other combination of JDBC/ODBC server and ODBC driver.\n+ *  FoxPro has the following limitations:\n+ * <ul>\n+ * <li>Primary Keys and indexes cannot be created via JDBC</li>\n+ * <li>Only has fixed-length char fields: all strings must be\n+ * trimmed in result sets</li>\n+ * <li>Does not have sufficient support for foreign keys</li>\n+ * <li>ODBC driver cannot handle certain Aggregate functions.</li>\n+ * <li>Locking is extremeley unreliable. Multiple clients\n+ * accessing single datastore may result in concurrency\n+ * data validity errors.</li>\n+ * </ul>\n+ */\n+public class FoxProDictionary\n+    extends DBDictionary {\n+\n+    public FoxProDictionary() {\n+        platform = \"Visual FoxPro\";\n+        joinSyntax = SYNTAX_TRADITIONAL;\n+\n+        supportsForeignKeys = false;\n+        supportsDeferredConstraints = false;\n+        maxTableNameLength = 30;\n+        maxColumnNameLength = 30;\n+        maxIndexNameLength = 8;\n+        maxConstraintNameLength = 8;\n+\n+        binaryTypeName = \"GENERAL\";\n+        blobTypeName = \"GENERAL\";\n+        longVarbinaryTypeName = \"GENERAL\";\n+        clobTypeName = \"MEMO\";\n+        longVarcharTypeName = \"MEMO\";\n+        dateTypeName = \"TIMESTAMP\";\n+        timeTypeName = \"TIMESTAMP\";\n+        varcharTypeName = \"CHARACTER{0}\";\n+        bigintTypeName = \"DOUBLE\";\n+        numericTypeName = \"INTEGER\";\n+        smallintTypeName = \"INTEGER\";\n+        bitTypeName = \"NUMERIC(1)\";\n+        integerTypeName = \"INTEGER\";\n+        tinyintTypeName = \"INTEGER\";\n+        decimalTypeName = \"DOUBLE\";\n+        doubleTypeName = \"DOUBLE\";\n+        realTypeName = \"DOUBLE\";\n+        floatTypeName = \"NUMERIC(19,16)\";\n+\n+        // the max character literal length is actually 254, but for primary\n+        // keys, it is 240; default to that length so users can add PKs later\n+        characterColumnSize = 240;\n+    }\n+\n+    public String getString(ResultSet rs, int column)\n+        throws SQLException {\n+        // foxpro doesn't auto-truncate values.\n+        String str = rs.getString(column);\n+        if (str != null)\n+            str = str.trim();\n+        return str;\n+    }\n+\n+    public void setNull(PreparedStatement stmnt, int idx, int colType,\n+        Column col)\n+        throws SQLException {\n+        // ensure that blob/clob is handled with safe methods.\n+        switch (colType) {\n+            case Types.BLOB:\n+                stmnt.setBytes(idx, null);\n+                break;\n+            case Types.CLOB:\n+                stmnt.setString(idx, null);\n+                break;\n+            default:\n+                super.setNull(stmnt, idx, colType, col);\n+        }\n+    }\n+\n+    protected String appendSize(Column col, String typeName) {\n+        // foxpro does not like unsized column declarations.\n+        if (col.getSize() == 0) {\n+            if (\"CHARACTER\".equals(typeName))\n+                col.setSize(240);\n+            else if (\"NUMERIC\".equals(typeName))\n+                col.setSize(19);\n+        }\n+        return super.appendSize(col, typeName);\n+    }\n+\n+    protected String getPrimaryKeyConstraintSQL(PrimaryKey pk) {\n+        // this foxpro driver combination does not support primary keys\n+        return null;\n+    }\n+\n+    public String[] getCreateIndexSQL(Index index) {\n+        // foxpro JDBC access does not allow the creation of indexes\n+        return new String[0];\n+    }\n+\n+    public Column[] getColumns(DatabaseMetaData meta, String catalog,\n+        String schemaName, String tableName, String columnName, Connection conn)\n+        throws SQLException {\n+        try {\n+            Column[] cols = super.getColumns(meta, catalog, schemaName,\n+                tableName, columnName, conn);\n+            for (int i = 0; cols != null && i < cols.length; i++) {\n+                // foxpro returns an odd type \"11\" code for DATETIME fields\n+                if (cols[i].getType() == 11)\n+                    cols[i].setType(Types.TIMESTAMP);\n+                    // MEMO maps to LONGVARCHAR during reverse analysis\n+                else if (\"MEMO\".equals(cols[i].getTypeName()))\n+                    cols[i].setType(Types.CLOB);\n+            }\n+            return cols;\n+        } catch (SQLException se) {\n+            // foxpro throws an exception if the table specified in the\n+            // column list is not found\n+            if (se.getErrorCode() == 562)\n+                return null;\n+            throw se;\n+        }\n+    }\n+\n+    public PrimaryKey[] getPrimaryKeys(DatabaseMetaData meta, String catalog,\n+        String schemaName, String tableName, Connection conn)\n+        throws SQLException {\n+        // this combination does not reliably return PK information\n+        return null;\n+    }\n+}"},{"sha":"75a6b6ed38ad8a379381c3621453343fa3f7f9da","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/H2Dictionary.java","status":"added","additions":211,"deletions":0,"changes":211,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/H2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/H2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/H2Dictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.math.BigDecimal;\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.Arrays;\n+import java.util.Locale;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.PrimaryKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.schema.Unique;\n+import org.apache.openjpa.meta.JavaTypes;\n+\n+/**\n+ * Support for the H2 database ({@link http://www.h2database.com}).\n+ *\n+ * @since 0.9.7\n+ */\n+public class H2Dictionary extends DBDictionary {\n+\n+    public H2Dictionary() {\n+        platform = \"H2\";\n+        validationSQL = \"CALL 1\";\n+        closePoolSQL = \"SHUTDOWN\";\n+\n+        supportsAutoAssign = true;\n+        lastGeneratedKeyQuery = \"CALL IDENTITY()\";\n+        autoAssignClause = \"IDENTITY\";\n+        autoAssignTypeName = \"INTEGER\";\n+        nextSequenceQuery = \"CALL NEXT VALUE FOR {0}\";\n+\n+        // CROSS JOIN is currently not supported\n+        crossJoinClause = \"JOIN\";\n+        requiresConditionForCrossJoin = true;\n+        stringLengthFunction = \"LENGTH({0})\";\n+        trimLeadingFunction = \"LTRIM({0})\";\n+        trimTrailingFunction = \"RTRIM({0})\";\n+        trimBothFunction = \"TRIM({0})\";\n+\n+        useSchemaName = true;\n+        supportsSelectForUpdate = true;\n+        supportsSelectStartIndex = true;\n+        supportsSelectEndIndex = true;\n+        rangePosition = RANGE_POST_LOCK;\n+        supportsDeferredConstraints = false;\n+\n+        blobTypeName = \"BLOB\";\n+        doubleTypeName = \"DOUBLE\";\n+\n+        supportsNullTableForGetPrimaryKeys = true;\n+        supportsNullTableForGetIndexInfo = true;\n+\n+        requiresCastForMathFunctions = false;\n+        requiresCastForComparisons = false;\n+\n+        reservedWordSet.addAll(Arrays.asList(new String[] {\n+            \"CURRENT_TIMESTAMP\", \"CURRENT_TIME\", \"CURRENT_DATE\", \"CROSS\",\n+            \"DISTINCT\", \"EXCEPT\", \"EXISTS\", \"FROM\", \"FOR\", \"FALSE\", \"FULL\",\n+            \"GROUP\", \"HAVING\", \"INNER\", \"INTERSECT\", \"IS\", \"JOIN\", \"LIKE\",\n+            \"MINUS\", \"NATURAL\", \"NOT\", \"NULL\", \"ON\", \"ORDER\", \"PRIMARY\",\n+            \"ROWNUM\", \"SELECT\", \"SYSDATE\", \"SYSTIME\", \"SYSTIMESTAMP\", \"TODAY\",\n+            \"TRUE\", \"UNION\", \"WHERE\" \n+            }));\n+    }\n+\n+    public int getJDBCType(int metaTypeCode, boolean lob) {\n+        int type = super.getJDBCType(metaTypeCode, lob);\n+        switch (type) {\n+        case Types.BIGINT:\n+            if (metaTypeCode == JavaTypes.BIGINTEGER)\n+                return Types.NUMERIC;\n+            break;\n+        }\n+        return type;\n+    }\n+\n+    public int getPreferredType(int type) {\n+        return super.getPreferredType(type);\n+    }\n+\n+    public String[] getAddPrimaryKeySQL(PrimaryKey pk) {\n+        return new String[0];\n+    }\n+\n+    public String[] getDropPrimaryKeySQL(PrimaryKey pk) {\n+        return new String[0];\n+    }\n+\n+    public String[] getAddColumnSQL(Column column) {\n+        return new String[] { \n+            \"ALTER TABLE \" + getFullName(column.getTable(), false) \n+                + \" ADD COLUMN \" + getDeclareColumnSQL(column, true) \n+        };\n+    }\n+\n+    public String[] getCreateTableSQL(Table table) {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"CREATE TABLE \").append(getFullName(table, false))\n+            .append(\" (\");\n+\n+        Column[] cols = table.getColumns();\n+        for (int i = 0; i < cols.length; i++) {\n+            if (i > 0)\n+                buf.append(\", \");\n+            buf.append(getDeclareColumnSQL(cols[i], false));\n+        }\n+\n+        PrimaryKey pk = table.getPrimaryKey();\n+        String pkStr;\n+        if (pk != null) {\n+            pkStr = getPrimaryKeyConstraintSQL(pk);\n+            if (!StringUtils.isEmpty(pkStr))\n+                buf.append(\", \").append(pkStr);\n+        }\n+\n+        Unique[] unqs = table.getUniques();\n+        String unqStr;\n+        for (int i = 0; i < unqs.length; i++) {\n+            unqStr = getUniqueConstraintSQL(unqs[i]);\n+            if (unqStr != null)\n+                buf.append(\", \").append(unqStr);\n+        }\n+\n+        buf.append(\")\");\n+        return new String[] { buf.toString() };\n+    }\n+\n+    protected String getPrimaryKeyConstraintSQL(PrimaryKey pk) {\n+        Column[] cols = pk.getColumns();\n+        if (cols.length == 1 && cols[0].isAutoAssigned())\n+            return null;\n+        return super.getPrimaryKeyConstraintSQL(pk);\n+    }\n+\n+    public boolean isSystemIndex(String name, Table table) {\n+        return name.toUpperCase(Locale.ENGLISH).startsWith(\"SYSTEM_\");\n+    }\n+\n+    protected String getSequencesSQL(String schemaName, String sequenceName) {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"SELECT SEQUENCE_SCHEMA, SEQUENCE_NAME FROM \")\n+            .append(\"INFORMATION_SCHEMA.SEQUENCES\");\n+        if (schemaName != null || sequenceName != null)\n+            buf.append(\" WHERE \");\n+        if (schemaName != null) {\n+            buf.append(\"SEQUENCE_SCHEMA = ?\");\n+            if (sequenceName != null)\n+                buf.append(\" AND \");\n+        }\n+        if (sequenceName != null)\n+            buf.append(\"SEQUENCE_NAME = ?\");\n+        return buf.toString();\n+    }\n+\n+    public Column[] getColumns(DatabaseMetaData meta, String catalog,\n+        String schemaName, String tableName, String columnName, Connection conn)\n+        throws SQLException {\n+        Column[] cols = super.getColumns(meta, catalog, schemaName, tableName, \n+            columnName, conn);\n+        return cols;\n+    }\n+\n+    protected void appendSelectRange(SQLBuffer buf, long start, long end,\n+        boolean subselect) {\n+        if (end != Long.MAX_VALUE)\n+            buf.append(\" LIMIT \").appendValue(end - start);\n+        if (start != 0)\n+            buf.append(\" OFFSET \").appendValue(start);\n+    }\n+\n+    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n+        FilterValue start) {\n+        buf.append(\"(POSITION(\");\n+        find.appendTo(buf);\n+        buf.append(\" IN \");\n+        if (start != null)\n+            substring(buf, str, start, null);\n+        else\n+            str.appendTo(buf);\n+        buf.append(\") - 1\");\n+        if (start != null) {\n+            buf.append(\" + \");\n+            start.appendTo(buf);\n+        }\n+        buf.append(\")\");\n+    }\n+}"},{"sha":"6914b21cf10e3c3c461271eebf2463676adc47d9","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/HSQLDictionary.java","status":"added","additions":300,"deletions":0,"changes":300,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/HSQLDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/HSQLDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/HSQLDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.math.BigDecimal;\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.Arrays;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.hsqldb.Trace;\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.PrimaryKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.schema.Unique;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.ReferentialIntegrityException;\n+\n+/**\n+ * Dictionary for Hypersonic SQL database.\n+ */\n+public class HSQLDictionary\n+    extends DBDictionary {\n+\n+    /**\n+     * Sets whether HSQL should use \"CREATED CACHED TABLE\" rather than\n+     * \"CREATE TABLE\", which allows disk-based database operations.\n+     */\n+    public boolean cacheTables = false;\n+\n+    private SQLBuffer _oneBuffer = new SQLBuffer(this).append(\"1\");\n+\n+    public HSQLDictionary() {\n+        platform = \"HSQL\";\n+        validationSQL = \"CALL 1\";\n+        closePoolSQL = \"SHUTDOWN\";\n+\n+        supportsAutoAssign = true;\n+        lastGeneratedKeyQuery = \"CALL IDENTITY()\";\n+        autoAssignClause = \"IDENTITY\";\n+        autoAssignTypeName = \"INTEGER\";\n+        nextSequenceQuery = \"SELECT NEXT VALUE FOR {0} FROM\"\n+            + \" INFORMATION_SCHEMA.SYSTEM_SEQUENCES\";\n+        crossJoinClause = \"JOIN\";\n+        requiresConditionForCrossJoin = true;\n+        stringLengthFunction = \"LENGTH({0})\";\n+        trimLeadingFunction = \"LTRIM({0})\";\n+        trimTrailingFunction = \"RTRIM({0})\";\n+        trimBothFunction = \"LTRIM(RTRIM({0}))\";\n+\n+        // HSQL 1.8.0 does support schema names in the table (\"schema.table\"),\n+        // but doesn't support it for columns references (\"schema.table.column\")\n+        useSchemaName = false;\n+        supportsSelectForUpdate = false;\n+        supportsSelectStartIndex = true;\n+        supportsSelectEndIndex = true;\n+        rangePosition = RANGE_PRE_DISTINCT;\n+        supportsDeferredConstraints = false;\n+\n+        useGetObjectForBlobs = true;\n+        blobTypeName = \"VARBINARY\";\n+        doubleTypeName = \"NUMERIC\";\n+\n+        supportsNullTableForGetPrimaryKeys = true;\n+        supportsNullTableForGetIndexInfo = true;\n+\n+        requiresCastForMathFunctions = true;\n+        requiresCastForComparisons = true;\n+\n+        reservedWordSet.addAll(Arrays.asList(new String[]{\n+            \"BEFORE\", \"BIGINT\", \"BINARY\", \"CACHED\", \"DATETIME\", \"LIMIT\",\n+            \"LONGVARBINARY\", \"LONGVARCHAR\", \"OBJECT\", \"OTHER\",\n+            \"SAVEPOINT\", \"TEMP\", \"TEXT\", \"TRIGGER\", \"TINYINT\",\n+            \"VARBINARY\", \"VARCHAR_IGNORECASE\",\n+        }));\n+    }\n+\n+    public int getJDBCType(int metaTypeCode, boolean lob) {\n+        int type = super.getJDBCType(metaTypeCode, lob);\n+        switch (type) {\n+            case Types.BIGINT:\n+                if (metaTypeCode == JavaTypes.BIGINTEGER)\n+                    return Types.NUMERIC;\n+                break;\n+        }\n+        return type;\n+    }\n+\n+    public int getPreferredType(int type) {\n+        switch (type) {\n+            case Types.CLOB:\n+                return Types.VARCHAR;\n+            case Types.BLOB:\n+                return Types.VARBINARY;\n+            default:\n+                return super.getPreferredType(type);\n+        }\n+    }\n+\n+    public String[] getAddPrimaryKeySQL(PrimaryKey pk) {\n+        return new String[0];\n+    }\n+\n+    public String[] getDropPrimaryKeySQL(PrimaryKey pk) {\n+        return new String[0];\n+    }\n+\n+    public String[] getAddColumnSQL(Column column) {\n+        return new String[]{ \"ALTER TABLE \"\n+            + getFullName(column.getTable(), false)\n+            + \" ADD COLUMN \" + getDeclareColumnSQL(column, true) };\n+    }\n+\n+    public String[] getCreateTableSQL(Table table) {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"CREATE \");\n+        if (cacheTables)\n+            buf.append(\"CACHED \");\n+        buf.append(\"TABLE \").append(getFullName(table, false)).append(\" (\");\n+\n+        Column[] cols = table.getColumns();\n+        for (int i = 0; i < cols.length; i++) {\n+            if (i > 0)\n+                buf.append(\", \");\n+            buf.append(getDeclareColumnSQL(cols[i], false));\n+        }\n+\n+        PrimaryKey pk = table.getPrimaryKey();\n+        String pkStr;\n+        if (pk != null) {\n+            pkStr = getPrimaryKeyConstraintSQL(pk);\n+            if (!StringUtils.isEmpty(pkStr))\n+                buf.append(\", \").append(pkStr);\n+        }\n+\n+        Unique[] unqs = table.getUniques();\n+        String unqStr;\n+        for (int i = 0; i < unqs.length; i++) {\n+            unqStr = getUniqueConstraintSQL(unqs[i]);\n+            if (unqStr != null)\n+                buf.append(\", \").append(unqStr);\n+        }\n+\n+        buf.append(\")\");\n+        return new String[]{ buf.toString() };\n+    }\n+\n+    protected String getPrimaryKeyConstraintSQL(PrimaryKey pk) {\n+        Column[] cols = pk.getColumns();\n+        if (cols.length == 1 && cols[0].isAutoAssigned())\n+            return null;\n+        return super.getPrimaryKeyConstraintSQL(pk);\n+    }\n+\n+    public boolean isSystemIndex(String name, Table table) {\n+        return name.toUpperCase().startsWith(\"SYS_\");\n+    }\n+\n+    protected String getSequencesSQL(String schemaName, String sequenceName) {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"SELECT SEQUENCE_SCHEMA, SEQUENCE_NAME FROM \").\n+            append(\"INFORMATION_SCHEMA.SYSTEM_SEQUENCES\");\n+        if (schemaName != null || sequenceName != null)\n+            buf.append(\" WHERE \");\n+        if (schemaName != null) {\n+            buf.append(\"SEQUENCE_SCHEMA = ?\");\n+            if (sequenceName != null)\n+                buf.append(\" AND \");\n+        }\n+        if (sequenceName != null)\n+            buf.append(\"SEQUENCE_NAME = ?\");\n+        return buf.toString();\n+    }\n+\n+    public SQLBuffer toOperation(String op, SQLBuffer selects,\n+        SQLBuffer from, SQLBuffer where, SQLBuffer group, SQLBuffer having,\n+        SQLBuffer order, boolean distinct, long start, long end,\n+        String forUpdateClause) {\n+        // hsql requires ordering when limit is used\n+        if ((start != 0 || end != Long.MAX_VALUE)\n+            && (order == null || order.isEmpty()))\n+            order = _oneBuffer;\n+        return super.toOperation(op, selects, from, where, group, having,\n+            order, distinct, start, end, forUpdateClause);\n+    }\n+\n+    public Column[] getColumns(DatabaseMetaData meta, String catalog,\n+        String schemaName, String tableName, String columnName, Connection conn)\n+        throws SQLException {\n+        Column[] cols = super.getColumns(meta, catalog, schemaName, tableName,\n+            columnName, conn);\n+\n+        for (int i = 0; cols != null && i < cols.length; i++)\n+            if (\"BOOLEAN\".equalsIgnoreCase(cols[i].getTypeName()))\n+                cols[i].setType(Types.BIT);\n+        return cols;\n+    }\n+\n+    public void setDouble(PreparedStatement stmnt, int idx, double val,\n+        Column col)\n+        throws SQLException {\n+        // HSQL has a bug where it cannot store a double if it is\n+        // exactly the same as Long.MAX_VALUE or MIN_VALUE\n+        if (val == Long.MAX_VALUE || val == Long.MIN_VALUE) {\n+            stmnt.setLong(idx, (long) val);\n+        } else  {\n+            super.setDouble(stmnt, idx, val, col);\n+        }\n+    }\n+\n+    public void setBigDecimal(PreparedStatement stmnt, int idx, BigDecimal val,\n+        Column col)\n+        throws SQLException {\n+        // hsql can't compare a BigDecimal equal to any other type, so try\n+        // to set type based on column\n+        int type = (val == null || col == null) ? JavaTypes.BIGDECIMAL\n+            : col.getJavaType();\n+        switch (type) {\n+            case JavaTypes.DOUBLE:\n+            case JavaTypes.DOUBLE_OBJ:\n+                setDouble(stmnt, idx, val.doubleValue(), col);\n+                break;\n+            case JavaTypes.FLOAT:\n+            case JavaTypes.FLOAT_OBJ:\n+                setDouble(stmnt, idx, val.floatValue(), col);\n+                break;\n+            default:\n+                super.setBigDecimal(stmnt, idx, val, col);\n+        }\n+    }\n+\n+    protected void appendSelectRange(SQLBuffer buf, long start, long end,\n+        boolean subselect) {\n+        // HSQL doesn't parameters in range\n+        buf.append(\" LIMIT \").append(String.valueOf(start)).append(\" \");\n+        if (end == Long.MAX_VALUE)\n+            buf.append(String.valueOf(0));\n+        else\n+            buf.append(String.valueOf(end - start));\n+    }\n+\n+    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n+        FilterValue start) {\n+        buf.append(\"(LOCATE(\");\n+        find.appendTo(buf);\n+        buf.append(\", \");\n+        str.appendTo(buf);\n+        if (start != null) {\n+            buf.append(\", (\");\n+            start.appendTo(buf);\n+            buf.append(\" + 1)\");\n+        }\n+        buf.append(\") - 1)\");\n+    }\n+\n+    public String getPlaceholderValueString(Column col) {\n+        String type = getTypeName(col.getType());\n+        int idx = type.indexOf(\"{0}\");\n+        if (idx != -1) {\n+            String pre = type.substring(0, idx);\n+            if (type.length() > idx + 3)\n+                type = pre + type.substring(idx + 3);\n+            else\n+                type = pre;\n+        }\n+        return \"NULL AS \" + type;\n+    }\n+\n+    public OpenJPAException newStoreException(String msg, SQLException[] causes,\n+        Object failed) {\n+        OpenJPAException ke = super.newStoreException(msg, causes, failed);\n+        if (ke instanceof ReferentialIntegrityException\n+            && causes[0].getErrorCode() == -Trace.VIOLATION_OF_UNIQUE_INDEX) {\n+            ((ReferentialIntegrityException) ke).setIntegrityViolation\n+                (ReferentialIntegrityException.IV_UNIQUE);\n+        }\n+        return ke;\n+    }\n+}"},{"sha":"66dfb884ffc92507764441fab2d2db42c6e1499d","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java","status":"added","additions":304,"deletions":0,"changes":304,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,304 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Types;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Index;\n+import org.apache.openjpa.jdbc.schema.PrimaryKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.ReferenceHashSet;\n+import org.apache.openjpa.util.UnsupportedException;\n+\n+/**\n+ * Dictionary for Informix database. Notable features:\n+ * <ul>\n+ * <li>Informix does not allow pessimistic locking on scrollable result\n+ * sets.</li>\n+ * <li>SET LOCK MODE TO WAIT N statements are issued to wait on locks. See\n+ * {@link #lockWaitSeconds} and {@link #lockModeEnabled}.</li>\n+ * <li>LOCK MODE ROW is used by default for table creation to allow the\n+ * maximum concurrency.</li>\n+ * </ul>\n+ */\n+public class InformixDictionary\n+    extends DBDictionary {\n+\n+    /**\n+     * If true, then we will issue a \"SET LOCK MODE TO WAIT N\"\n+     * statement whenever we create a {@link Connection}, in order\n+     * allow waiting on locks.\n+     */\n+    public boolean lockModeEnabled = false;\n+\n+    /**\n+     * If {@link #lockModeEnabled} is <code>true</code>, then this\n+     * parameter specifies the number of seconds we will wait to\n+     * obtain a lock for inserts and pessimistic locking.\n+     */\n+    public int lockWaitSeconds = 30;\n+\n+    /**\n+     * Informix JDBC metadata for all known drivers returns with the\n+     * table catalog and the table schema name swapped. A <code>true</code>\n+     * value for this property indicates that they should be reversed.\n+     */\n+    public boolean swapSchemaAndCatalog = true;\n+\n+    // weak set of connections we've already executed lock mode sql on\n+    private final Collection _seenConnections = new ReferenceHashSet\n+        (ReferenceHashSet.WEAK);\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (InformixDictionary.class);\n+\n+    public InformixDictionary() {\n+        platform = \"Informix\";\n+        validationSQL = \"SELECT FIRST 1 CURRENT TIMESTAMP \"\n+            + \"FROM informix.systables\";\n+\n+        supportsAutoAssign = true;\n+        autoAssignTypeName = \"serial\";\n+        lastGeneratedKeyQuery = \"SELECT FIRST 1 DBINFO('sqlca.sqlerrd1') \"\n+            + \"FROM informix.systables\";\n+\n+        // informix actually does support deferred constraints, but not\n+        // in the table definition; deferred constraints can be activated by\n+        // invoking \"set constraints all deferred\" on the connection, which\n+        // we don't do yet\n+        supportsDeferredConstraints = false;\n+        constraintNameMode = CONS_NAME_AFTER;\n+\n+        // informix supports \"CLOB\" type, but any attempt to insert\n+        // into them raises: \"java.sql.SQLException: Can't convert fromnull\"\n+        useGetStringForClobs = true;\n+        longVarcharTypeName = \"TEXT\";\n+        clobTypeName = \"TEXT\";\n+        smallintTypeName = \"INT8\";\n+        tinyintTypeName = \"INT8\";\n+        floatTypeName = \"FLOAT\";\n+        bitTypeName = \"BOOLEAN\";\n+        blobTypeName = \"BYTE\";\n+        doubleTypeName = \"NUMERIC(32,20)\";\n+        dateTypeName = \"DATE\";\n+        timeTypeName = \"DATETIME HOUR TO SECOND\";\n+        timestampTypeName = \"DATETIME YEAR TO FRACTION(3)\";\n+        doubleTypeName = \"NUMERIC(32,20)\";\n+        floatTypeName = \"REAL\";\n+        bigintTypeName = \"NUMERIC(32,0)\";\n+        doubleTypeName = \"DOUBLE PRECISION\";\n+        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\n+            \"BYTE\", \"DOUBLE PRECISION\", \"INTERVAL\", \"SMALLFLOAT\", \"TEXT\",\n+            \"INT8\",\n+        }));\n+\n+        supportsQueryTimeout = false;\n+        supportsLockingWithDistinctClause = false;\n+        supportsLockingWithMultipleTables = false;\n+        supportsLockingWithOrderClause = false;\n+\n+        // the informix JDBC drivers have problems with using the\n+        // schema name in reflection on columns and tables\n+        supportsSchemaForGetColumns = false;\n+        supportsSchemaForGetTables = false;\n+\n+        // Informix doesn't support aliases in deletes if the table has an index\n+        allowsAliasInBulkClause = false;\n+        \n+        // Informix doesn't understand \"X CROSS JOIN Y\", but it does understand\n+        // the equivalent \"X JOIN Y ON 1 = 1\"\n+        crossJoinClause = \"JOIN\";\n+        requiresConditionForCrossJoin = true;\n+\n+        concatenateFunction = \"CONCAT({0},{1})\";\n+        nextSequenceQuery = \"SELECT {0}.NEXTVAL FROM SYSTABLES WHERE TABID=1\";\n+        supportsCorrelatedSubselect = false;\n+        swapSchemaAndCatalog = false;\n+        \n+        // Informix does not support foreign key delete action NULL or DEFAULT\n+        supportsNullDeleteAction = false;\n+        supportsDefaultDeleteAction = false;\n+        \n+        trimSchemaName = true;\n+    }\n+\n+    public void connectedConfiguration(Connection conn)\n+        throws SQLException {\n+        super.connectedConfiguration(conn);\n+        if (driverVendor == null) {\n+            DatabaseMetaData meta = conn.getMetaData();\n+            if (\"Informix\".equalsIgnoreCase(meta.getDriverName()))\n+                driverVendor = VENDOR_DATADIRECT;\n+            else\n+                driverVendor = VENDOR_OTHER;\n+        }\n+        if (isJDBC3) {\n+            conn.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n+            if (log.isTraceEnabled())\n+                log.trace(_loc.get(\"connection-defaults\", new Object[]{\n+                    conn.getAutoCommit(), conn.getHoldability(),\n+                    conn.getTransactionIsolation()}));\n+        }\n+    }\n+\n+    public Column[] getColumns(DatabaseMetaData meta, String catalog,\n+        String schemaName, String tableName, String columnName, Connection conn)\n+        throws SQLException {\n+        Column[] cols = super.getColumns(meta, catalog, schemaName, tableName,\n+            columnName, conn);\n+\n+        // treat logvarchar as clob\n+        for (int i = 0; cols != null && i < cols.length; i++)\n+            if (cols[i].getType() == Types.LONGVARCHAR)\n+                cols[i].setType(Types.CLOB);\n+        return cols;\n+    }\n+\n+    public Column newColumn(ResultSet colMeta)\n+        throws SQLException {\n+        Column col = super.newColumn(colMeta);\n+        if (swapSchemaAndCatalog)\n+            col.setSchemaName(colMeta.getString(\"TABLE_CAT\"));\n+        return col;\n+    }\n+\n+    public PrimaryKey newPrimaryKey(ResultSet pkMeta)\n+        throws SQLException {\n+        PrimaryKey pk = super.newPrimaryKey(pkMeta);\n+        if (swapSchemaAndCatalog)\n+            pk.setSchemaName(pkMeta.getString(\"TABLE_CAT\"));\n+        return pk;\n+    }\n+\n+    public Index newIndex(ResultSet idxMeta)\n+        throws SQLException {\n+        Index idx = super.newIndex(idxMeta);\n+        if (swapSchemaAndCatalog)\n+            idx.setSchemaName(idxMeta.getString(\"TABLE_CAT\"));\n+        return idx;\n+    }\n+\n+    public void setBoolean(PreparedStatement stmnt, int idx, boolean val,\n+        Column col)\n+        throws SQLException {\n+        // informix actually requires that a boolean be set: it cannot\n+        // handle a numeric argument\n+        stmnt.setString(idx, val ? \"t\" : \"f\");\n+    }\n+\n+    public String[] getCreateTableSQL(Table table) {\n+        String[] create = super.getCreateTableSQL(table);\n+        create[0] = create[0] + \" LOCK MODE ROW\";\n+        return create;\n+    }\n+\n+    public String[] getAddPrimaryKeySQL(PrimaryKey pk) {\n+        String pksql = getPrimaryKeyConstraintSQL(pk);\n+        if (pksql == null)\n+            return new String[0];\n+        return new String[]{ \"ALTER TABLE \"\n+            + getFullName(pk.getTable(), false) + \" ADD CONSTRAINT \" + pksql };\n+    }\n+\n+    public String[] getAddForeignKeySQL(ForeignKey fk) {\n+        String fksql = getForeignKeyConstraintSQL(fk);\n+        if (fksql == null)\n+            return new String[0];\n+        return new String[]{ \"ALTER TABLE \"\n+            + getFullName(fk.getTable(), false) + \" ADD CONSTRAINT \" + fksql };\n+    }\n+\n+    public boolean supportsRandomAccessResultSet(Select sel,\n+        boolean forUpdate) {\n+        return !forUpdate && !sel.isLob()\n+            && super.supportsRandomAccessResultSet(sel, forUpdate);\n+    }\n+\n+    public Connection decorate(Connection conn)\n+        throws SQLException {\n+        conn = super.decorate(conn);\n+        if (isJDBC3 && conn.getHoldability() != \n+            ResultSet.HOLD_CURSORS_OVER_COMMIT) {\n+            conn.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n+            if (log.isTraceEnabled()) {                    \n+                log.trace(_loc.get(\"connection-defaults\", new Object[]{\n+                    conn.getAutoCommit(), conn.getHoldability(),\n+                    conn.getTransactionIsolation()}));\n+            }\n+        }\n+\n+        // if we haven't already done so, initialize the lock mode of the\n+        // connection\n+        if (lockModeEnabled && _seenConnections.add(conn)) {\n+            String sql = \"SET LOCK MODE TO WAIT\";\n+            if (lockWaitSeconds > 0)\n+                sql = sql + \" \" + lockWaitSeconds;\n+\n+            Statement stmnt = null;\n+            try {\n+                stmnt = conn.createStatement();\n+                stmnt.executeUpdate(sql);\n+            } catch (SQLException se) {\n+                throw SQLExceptions.getStore(se, this);\n+            } finally {\n+                if (stmnt != null)\n+                    try {\n+                        stmnt.close();\n+                    } catch (SQLException se) {\n+                    }\n+            }\n+        }\n+\n+        // the datadirect driver requires that we issue a rollback before using\n+        // each connection\n+        if (VENDOR_DATADIRECT.equalsIgnoreCase(driverVendor))\n+            try {\n+                conn.rollback();\n+            } catch (SQLException se) {\n+            }\n+        return conn;\n+    }\n+\n+    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n+        FilterValue start) {\n+        throw new UnsupportedException(_loc.get(\"function-not-supported\",\n+                getClass(), \"LOCATE\"));\n+    }\n+\n+    public boolean needsToCreateIndex(Index idx, Table table) {\n+       // Informix will automatically create a unique index for the \n+       // primary key, so don't create another index again\n+       PrimaryKey pk = table.getPrimaryKey();\n+       if (pk != null && idx.columnsMatch(pk.getColumns()))\n+           return false;\n+       return true;\n+    }\n+}\n\\ No newline at end of file"},{"sha":"8b3b52e1c3b7937df5a3309777c02a7238069e26","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InterbaseDictionary.java","status":"added","additions":118,"deletions":0,"changes":118,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InterbaseDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InterbaseDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InterbaseDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.Types;\n+\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Index;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.StoreException;\n+\n+/**\n+ * Dictionary for Borland Interbase.\n+ */\n+public class InterbaseDictionary\n+    extends DBDictionary {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (InterbaseDictionary.class);\n+\n+    public InterbaseDictionary() {\n+        platform = \"Borland Interbase\";\n+        validationSQL = \"SELECT 1 FROM RDB$DATABASE\";\n+        supportsDeferredConstraints = false;\n+\n+        useGetStringForClobs = true;\n+        useSetStringForClobs = true;\n+        useGetBytesForBlobs = true;\n+        useSetBytesForBlobs = true;\n+\n+        // the JDBC driver claims 31, but that causes exceptions\n+        maxTableNameLength = 30;\n+\n+        bigintTypeName = \"NUMERIC(18,0)\";\n+        integerTypeName = \"INTEGER\";\n+        doubleTypeName = \"DOUBLE PRECISION\";\n+        charTypeName = \"CHAR(1)\";\n+        blobTypeName = \"BLOB\";\n+        clobTypeName = \"BLOB SUB_TYPE 1\";\n+        bitTypeName = \"SMALLINT\";\n+        smallintTypeName = \"SMALLINT\";\n+        tinyintTypeName = \"SMALLINT\";\n+\n+        // no support for lower-casing or finding the length of strings\n+        // (although it can be added to the database; see\n+        // http://bdn.borland.com/article/0,1410,27563,00.html )\n+        toLowerCaseFunction = null;\n+        stringLengthFunction = null;\n+    }\n+\n+    protected String getTableNameForMetadata(String tableName) {\n+        return (tableName == null) ? \"%\"\n+            : super.getTableNameForMetadata(tableName);\n+    }\n+\n+    protected String getColumnNameForMetadata(String columnName) {\n+        return (columnName == null) ? \"%\"\n+            : super.getColumnNameForMetadata(columnName);\n+    }\n+\n+    protected String appendSize(Column col, String typeName) {\n+        if (col.isPrimaryKey() && col.getType() == Types.VARCHAR) {\n+            // reduce size of varchar primary key cols proportional to the\n+            // number of cols, because interbase caps the total pk size\n+            int numKeys = 1;\n+            if (col.getTable() != null\n+                && col.getTable().getPrimaryKey() != null)\n+                numKeys = col.getTable().getPrimaryKey().getColumns().length;\n+            col.setSize(Math.min(col.getSize(), 200 / numKeys));\n+        } else if (col.getType() == Types.VARCHAR && col.getSize() > 200\n+            && col.getTable() != null) {\n+            // indexed varchar cols have to be <= 250 chars\n+            Index[] idx = col.getTable().getIndexes();\n+            for (int i = 0; i < idx.length; i++) {\n+                if (idx[i].containsColumn(col)) {\n+                    col.setSize(Math.min(col.getSize(), 200));\n+                    break;\n+                }\n+            }\n+        }\n+        return super.appendSize(col, typeName);\n+    }\n+\n+    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n+        FilterValue start) {\n+        throw new StoreException(_loc.get(\"indexof-not-supported\", platform));\n+    }\n+\n+    public void substring(SQLBuffer buf, FilterValue str, FilterValue start,\n+        FilterValue end) {\n+        throw new StoreException(_loc.get(\"substring-not-supported\",\n+            platform));\n+    }\n+\n+    public String[] getDropColumnSQL(Column column) {\n+        // Interbase uses \"ALTER TABLE DROP <COLUMN_NAME>\" rather than the\n+        // usual \"ALTER TABLE DROP COLUMN <COLUMN_NAME>\"\n+        return new String[]{ \"ALTER TABLE \"\n+            + getFullName(column.getTable(), false) + \" DROP \" + column };\n+    }\n+}"},{"sha":"3e789219ed279438885129c3d20d55ba02b2e749","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JDataStoreDictionary.java","status":"added","additions":115,"deletions":0,"changes":115,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JDataStoreDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JDataStoreDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JDataStoreDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.ReferentialIntegrityException;\n+\n+/**\n+ * Dictionary for Borland JDataStore\n+ */\n+public class JDataStoreDictionary\n+    extends DBDictionary {\n+\n+    public JDataStoreDictionary() {\n+        platform = \"Borland JDataStore\";\n+        joinSyntax = SYNTAX_TRADITIONAL;\n+\n+        supportsDeferredConstraints = false;\n+        allowsAliasInBulkClause = false;\n+\n+        maxTableNameLength = 31;\n+        maxColumnNameLength = 31;\n+        maxIndexNameLength = 31;\n+        maxConstraintNameLength = 31;\n+\n+        useGetStringForClobs = true;\n+        useSetStringForClobs = true;\n+        useGetBytesForBlobs = true;\n+        blobTypeName = \"VARBINARY\";\n+        clobTypeName = \"VARCHAR\";\n+\n+        // it is possible to use a FOR UPDATE clause with JDataStore,\n+        // but the actual row won't wind up being locked\n+        supportsLockingWithDistinctClause = false;\n+        supportsQueryTimeout = false;\n+\n+        // there is no build-in function for getting the last generated\n+        // key in JDataStore; using MAX will have to suffice\n+        supportsAutoAssign = true;\n+        lastGeneratedKeyQuery = \"SELECT MAX({0}) FROM {1}\";\n+        autoAssignClause = \"AUTOINCREMENT\";\n+\n+        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\n+            \"SHORT\", \"INT\", \"LONG\", \"DOUBLE PRECISION\", \"BOOLEAN\",\n+        }));\n+\n+        searchStringEscape = \"\";\n+    }\n+\n+    public void substring(SQLBuffer buf, FilterValue str, FilterValue start,\n+        FilterValue end) {\n+        buf.append(\"SUBSTRING(\");\n+        str.appendTo(buf);\n+        buf.append(\" FROM (\");\n+        start.appendTo(buf);\n+        buf.append(\" + 1) FOR (\");\n+        if (end == null) {\n+            buf.append(\"CHAR_LENGTH(\");\n+            str.appendTo(buf);\n+            buf.append(\")\");\n+        } else\n+            end.appendTo(buf);\n+        buf.append(\" - (\");\n+        start.appendTo(buf);\n+        buf.append(\")))\");\n+    }\n+\n+    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n+        FilterValue start) {\n+        buf.append(\"(POSITION(\");\n+        find.appendTo(buf);\n+        buf.append(\" IN \");\n+        if (start != null)\n+            substring(buf, str, start, null);\n+        else\n+            str.appendTo(buf);\n+        buf.append(\") - 1\");\n+        if (start != null) {\n+            buf.append(\" + \");\n+            start.appendTo(buf);\n+        }\n+        buf.append(\")\");\n+    }\n+\n+    public OpenJPAException newStoreException(String msg, SQLException[] causes,\n+        Object failed) {\n+        OpenJPAException ke = super.newStoreException(msg, causes, failed);\n+        if (ke instanceof ReferentialIntegrityException\n+            && causes[0].getMessage().indexOf(\"Duplicate key value for\") > -1) {\n+            ((ReferentialIntegrityException) ke).setIntegrityViolation\n+                (ReferentialIntegrityException.IV_UNIQUE);\n+        }\n+        return ke;\n+    }\n+}"},{"sha":"2ace5d99da2967ff5bc4d437181b21eca37dc0bb","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Join.java","status":"added","additions":193,"deletions":0,"changes":193,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Join.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Join.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Join.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,193 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+\n+/**\n+ * Represents a SQL join.\n+ *\n+ * @author Abe White\n+ */\n+public class Join\n+    implements Cloneable, JoinSyntaxes {\n+\n+    public static final int TYPE_INNER = 0;\n+    public static final int TYPE_OUTER = 1;\n+    public static final int TYPE_CROSS = 2;\n+\n+    private int _type = TYPE_INNER;\n+\n+    private int _alias1;\n+    private int _alias2;\n+    private Table _table1;\n+    private Table _table2;\n+    private ForeignKey _fk;\n+    private ClassMapping _target;\n+    private int _subs;\n+    private Joins _joins;\n+    private boolean _inverse;\n+\n+    /**\n+     * Constructor for inner and outer joins.\n+     */\n+    Join(Table table1, int alias1, Table table2, int alias2, ForeignKey fk,\n+        boolean inverse) {\n+        _table1 = table1;\n+        _alias1 = alias1;\n+        _table2 = table2;\n+        _alias2 = alias2;\n+        _fk = fk;\n+        _inverse = inverse;\n+    }\n+\n+    /**\n+     * Private default constructor.\n+     */\n+    private Join() {\n+    }\n+\n+    public int getType() {\n+        return _type;\n+    }\n+\n+    public void setType(int type) {\n+        _type = type;\n+    }\n+\n+    public String getAlias1() {\n+        return SelectImpl.toAlias(_alias1);\n+    }\n+\n+    public String getAlias2() {\n+        return SelectImpl.toAlias(_alias2);\n+    }\n+\n+    int getIndex1() {\n+        return _alias1;\n+    }\n+\n+    int getIndex2() {\n+        return _alias2;\n+    }\n+\n+    public Table getTable1() {\n+        return _table1;\n+    }\n+\n+    public Table getTable2() {\n+        return _table2;\n+    }\n+\n+    public ForeignKey getForeignKey() {\n+        return _fk;\n+    }\n+\n+    public boolean isForeignKeyInversed() {\n+        return _inverse;\n+    }\n+\n+    /**\n+     * If joining a relation, the target type.  \n+     */\n+    public ClassMapping getRelationTarget() {\n+        return _target;\n+    }\n+\n+    /**\n+     * If joining a relation, how to deal with subclasses.  See subclass\n+     * constants in {@link Select}.\n+     */\n+    public int getSubclasses() {\n+        return _subs;\n+    }\n+\n+    /**\n+     * If joining a relation, the joins leading to the relation.\n+     */\n+    public Joins getRelationJoins() {\n+        return _joins;\n+    }\n+\n+    /**\n+     * When joining a relation, set target type and how to deal with\n+     * subclasses.  See subclass constants in {@link #Select}.\n+     */\n+    public void setRelation(ClassMapping target, int subs, Joins joins) {\n+        _target = target;\n+        _subs = subs;\n+        _joins = joins;\n+    }\n+\n+    /**\n+     * Return a join that is this join in reverse.\n+     */\n+    public Join reverse() {\n+        Join join = new Join();\n+        join._type = _type;\n+        join._table1 = _table2;\n+        join._alias1 = _alias2;\n+        join._table2 = _table1;\n+        join._alias2 = _alias1;\n+        join._inverse = !_inverse;\n+        join._fk = _fk;\n+        join._target = _target;\n+        join._subs = _subs;\n+        join._joins = _joins;\n+        return join;\n+    }\n+\n+    public int hashCode() {\n+        return _alias1 ^ _alias2;\n+    }\n+\n+    public boolean equals(Object other) {\n+        if (other == this)\n+            return true;\n+        if (!(other instanceof Join))\n+            return false;\n+\n+        Join j = (Join) other;\n+        return (_alias1 == j._alias1 && _alias2 == j._alias2)\n+            || (_alias1 == j._alias2 && _alias2 == j._alias1);\n+    }\n+\n+    public String toString() {\n+        String typeString;\n+        if (_type == TYPE_CROSS)\n+            typeString = \"cross\";\n+        else if (_type == TYPE_INNER)\n+            typeString = \"inner\";\n+        else\n+            typeString = \"outer\";\n+        return \"<\" + System.identityHashCode(this) + \"> t\"\n+            + _alias1 + \"->t\" + _alias2 + \" (\" + typeString + \")\";\n+    }\n+\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (Exception e) {\n+            return null;\n+        }\n+    }\n+}\n+"},{"sha":"b10c47f8fb87816392725379e41ace8bd78d7c1c","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSet.java","status":"added","additions":406,"deletions":0,"changes":406,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSet.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSet.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,406 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.lang.ObjectUtils;\n+\n+/**\n+ * Set type that recognizes that inner joins should take precedence\n+ * over otherwise equal outer joins.\n+ *\n+ * @author Abe White\n+ */\n+class JoinSet {\n+\n+    // the joins are stored as an adjacency list graph.  it's a reasonably\n+    // efficient representation with O(1) lookup, add, remove operations for\n+    // typical sets of joins, and it means we'd have to create a graph anyway\n+    // when joinIterator() is called\n+    private final List _graph = new ArrayList();\n+    private int _size = 0;\n+    private List _sorted = null;\n+\n+    public JoinSet() {\n+    }\n+\n+    public JoinSet(JoinSet copy) {\n+        for (int i = 0; i < copy._graph.size(); i++) {\n+            if (copy._graph.get(i) == null)\n+                _graph.add(null);\n+            else\n+                _graph.add(((Node) copy._graph.get(i)).clone());\n+        }\n+        _size = copy._size;\n+        _sorted = copy._sorted;\n+    }\n+\n+    /**\n+     * Return the recorded join matching the given join's aliases.\n+     */\n+    public Join getRecordedJoin(Join join) {\n+        if (join == null)\n+            return null;\n+        Node node = getNode(join, join.getIndex1());\n+        return (node == null) ? null : node.join;\n+    }\n+\n+    /**\n+     * Return the node for the specified join and index.\n+     */\n+    private Node getNode(Join join, int idx) {\n+        if (_graph.size() <= idx)\n+            return null;\n+        Node node = (Node) _graph.get(idx);\n+        for (; node != null; node = node.next)\n+            if (node.join.equals(join))\n+                return node;\n+        return null;\n+    }\n+\n+    /**\n+     * Return the logical last join.\n+     */\n+    public Join last() {\n+        if (_size == 0)\n+            return null;\n+        Node node = (Node) _graph.get(_graph.size() - 1);\n+        while (node.next != null)\n+            node = node.next;\n+        return node.join;\n+    }\n+\n+    /**\n+     * Iterator over joins that prepares them for SQL translation.\n+     */\n+    public Iterator joinIterator() {\n+        if (_size < 2)\n+            return iterator();\n+        if (_sorted != null)\n+            return _sorted.iterator();\n+\n+        List sorted = new ArrayList(_size);\n+        LinkedList queue = new LinkedList();\n+        BitSet seen = new BitSet(_graph.size() * _graph.size()\n+            + _graph.size());\n+\n+        // traverse graph\n+        Node n;\n+        int idx, sidx;\n+        for (int i = 0; i < _graph.size(); i++) {\n+            // seed queue with next set of disconnected joins\n+            for (n = (Node) _graph.get(i); n != null; n = n.next) {\n+                sidx = getSeenIndex(n.join);\n+                if (!seen.get(sidx)) {\n+                    seen.set(sidx);\n+                    queue.add(n);\n+                }\n+            }\n+            if (queue.isEmpty())\n+                continue;\n+\n+            // traverse from those joins to reachables\n+            while (!queue.isEmpty()) {\n+                n = (Node) queue.removeFirst();\n+\n+                // don't repeat a join to a table we've already joined, but\n+                // do traverse through it in the graph (the first indexes of\n+                // the seeen bitset are reserved for joined-to tables)\n+                idx = (n.forward) ? n.join.getIndex2() : n.join.getIndex1();\n+                if (!seen.get(idx)) {\n+                    sorted.add((n.forward) ? n.join : n.join.reverse());\n+                    seen.set(idx);\n+                }\n+\n+                for (n = (Node) _graph.get(idx); n != null; n = n.next) {\n+                    sidx = getSeenIndex(n.join);\n+                    if (!seen.get(sidx)) {\n+                        seen.set(sidx);\n+                        queue.add(n);\n+                    }\n+                }\n+            }\n+        }\n+        _sorted = sorted;\n+        return _sorted.iterator();\n+    }\n+\n+    /**\n+     * We create a unique index for recording seen nodes by\n+     * treating the joined indexes as a base (max-index) number.\n+     */\n+    private int getSeenIndex(Join join) {\n+        // we reserve indexes 0..._graph.size() for joined tables\n+        return join.getIndex1() * _graph.size() + join.getIndex2()\n+            + _graph.size();\n+    }\n+\n+    public boolean add(Join join) {\n+        if (join.getType() == Join.TYPE_OUTER) {\n+            // outer shouldn't override any other join type\n+            if (!contains(join)) {\n+                addNode(join);\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        // replace any existing join with this one\n+        Node node = getNode(join, join.getIndex1());\n+        if (node != null) {\n+            node.join = join;\n+            getNode(join, join.getIndex2()).join = join;\n+            _sorted = null;\n+        } else\n+            addNode(join);\n+        return true;\n+    }\n+\n+    public boolean addAll(JoinSet js) {\n+        if (js.isEmpty())\n+            return false;\n+\n+        boolean added = false;\n+        for (Iterator itr = js.iterator(); itr.hasNext();)\n+            added = add((Join) itr.next()) || added;\n+        return added;\n+    }\n+\n+    /**\n+     * Add the give join to our graph.\n+     */\n+    private void addNode(Join join) {\n+        _sorted = null;\n+\n+        int size = Math.max(join.getIndex1(), join.getIndex2()) + 1;\n+        while (_graph.size() < size)\n+            _graph.add(null);\n+\n+        Node node = (Node) _graph.get(join.getIndex1());\n+        if (node == null)\n+            _graph.set(join.getIndex1(), new Node(join, true));\n+        else {\n+            while (node.next != null)\n+                node = node.next;\n+            node.next = new Node(join, true);\n+        }\n+\n+        node = (Node) _graph.get(join.getIndex2());\n+        if (node == null)\n+            _graph.set(join.getIndex2(), new Node(join, false));\n+        else {\n+            while (node.next != null)\n+                node = node.next;\n+            node.next = new Node(join, false);\n+        }\n+        _size++;\n+    }\n+\n+    public Iterator iterator() {\n+        return new Iterator() {\n+            private Node _next = null;\n+            private int _idx = -1;\n+\n+            public boolean hasNext() {\n+                if (_next != null)\n+                    return true;\n+\n+                while (++_idx < _graph.size()) {\n+                    _next = (Node) _graph.get(_idx);\n+                    while (_next != null && !_next.forward)\n+                        _next = _next.next;\n+                    if (_next != null)\n+                        return true;\n+                }\n+                return false;\n+            }\n+\n+            public Object next() {\n+                if (!hasNext())\n+                    throw new NoSuchElementException();\n+                Join j = _next.join;\n+                do {\n+                    _next = _next.next;\n+                } while (_next != null && !_next.forward);\n+                return j;\n+            }\n+\n+            public void remove() {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+    }\n+\n+    public boolean remove(Join join) {\n+        if (join == null || _graph.size() <= join.getIndex1())\n+            return false;\n+        if (remove(join, join.getIndex1())) {\n+            _size--;\n+            return remove(join, join.getIndex2());\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Each join is recorded one at its first index and once at its second;\n+     * remove the join at one of its indexes.\n+     */\n+    private boolean remove(Join join, int idx) {\n+        Node node = (Node) _graph.get(idx);\n+        for (Node prev = null; node != null; prev = node, node = node.next) {\n+            if (!node.join.equals(join))\n+                continue;\n+\n+            if (prev != null)\n+                prev.next = node.next;\n+            else {\n+                _graph.set(idx, node.next);\n+                // trim to size\n+                while (!_graph.isEmpty() && _graph.get(idx) == null\n+                    && idx == _graph.size() - 1)\n+                    _graph.remove(idx--);\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean removeAll(JoinSet js) {\n+        boolean remd = false;\n+        for (Iterator itr = js.iterator(); itr.hasNext();)\n+            remd = remove((Join) itr.next()) || remd;\n+        return remd;\n+    }\n+\n+    public boolean retainAll(JoinSet js) {\n+        boolean remd = false;\n+        Join join;\n+        for (Iterator itr = iterator(); itr.hasNext();) {\n+            join = (Join) itr.next();\n+            if (!js.contains(join))\n+                remd = remove(join);\n+        }\n+        return remd;\n+    }\n+\n+    public void clear() {\n+        _graph.clear();\n+        _sorted = null;\n+        _size = 0;\n+    }\n+\n+    public boolean contains(Join join) {\n+        return getRecordedJoin(join) != null;\n+    }\n+\n+    public boolean containsAll(JoinSet js) {\n+        if (js._size > _size || js._graph.size() > _graph.size())\n+            return false;\n+        for (Iterator itr = js.iterator(); itr.hasNext();)\n+            if (!contains((Join) itr.next()))\n+                return false;\n+        return true;\n+    }\n+\n+    public boolean isEmpty() {\n+        return _size == 0;\n+    }\n+\n+    public int size() {\n+        return _size;\n+    }\n+\n+    public boolean equals(Object other) {\n+        if (other == this)\n+            return true;\n+        if (!(other instanceof JoinSet))\n+            return false;\n+        return _graph.equals(((JoinSet) other)._graph);\n+    }\n+\n+    public int hashCode() {\n+        return _graph.hashCode();\n+    }\n+\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"[\");\n+        for (Iterator itr = iterator(); itr.hasNext();) {\n+            buf.append(\"<\").append(itr.next()).append(\">\");\n+            if (itr.hasNext())\n+                buf.append(\", \");\n+        }\n+        return buf.append(\"]\").toString();\n+    }\n+\n+    /**\n+     * A graph node.\n+     */\n+    private static class Node\n+        implements Cloneable {\n+\n+        public Join join;\n+        public Node next;\n+        public boolean forward;\n+\n+        public Node(Join join, boolean forward) {\n+            this.join = join;\n+            this.forward = forward;\n+        }\n+\n+        public int hashCode() {\n+            int rs = 17;\n+            rs = 37 * rs + join.hashCode();\n+            if (next != null)\n+                rs = 37 * rs + next.hashCode();\n+            return rs;\n+        }\n+\n+        public boolean equals(Object other) {\n+            if (!(other instanceof Node))\n+                return false;\n+            Node node = (Node) other;\n+            return ObjectUtils.equals(join, node.join)\n+                && ObjectUtils.equals(next, node.next);\n+        }\n+\n+        public Object clone() {\n+            try {\n+                Node node = (Node) super.clone();\n+                if (node.next != null)\n+                    node.next = (Node) node.next.clone();\n+                return node;\n+            } catch (CloneNotSupportedException cnse) {\n+                // can't happen\n+                return null;\n+            }\n+        }\n+\n+        public String toString() {\n+            return join + \"(\" + ((forward) ? \"forward\" : \"backward\") + \")\"\n+                + \"; next: \" + next;\n+        }\n+    }\n+}\t"},{"sha":"3c114e29e6dab59cf5d24183ff8571641a885286","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSyntaxes.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSyntaxes.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSyntaxes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JoinSyntaxes.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+/**\n+ * Constants for ways of describing joins in SQL.\n+ *\n+ * @author Abe White\n+ */\n+public interface JoinSyntaxes {\n+\n+    /**\n+     * ANSI SQL 92 join syntax; outer joins are supported.\n+     */\n+    public static final int SYNTAX_SQL92 = 0;\n+\n+    /**\n+     * Traditional join syntax; outer joins are not supported.\n+     */\n+    public static final int SYNTAX_TRADITIONAL = 1;\n+\n+    /**\n+     * Native database join syntax; outer joins are supported.\n+     */\n+    public static final int SYNTAX_DATABASE = 2;\n+}"},{"sha":"75ee7170290da3f30d18d6ea1647dcad9c9202f9","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Joins.java","status":"added","additions":80,"deletions":0,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Joins.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Joins.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Joins.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+\n+/**\n+ * Tracks joins made when traversing relations in a select.\n+ *\n+ * @author Abe White\n+ */\n+public interface Joins {\n+\n+    /**\n+     * Whether we have any joins.\n+     */\n+    public boolean isEmpty();\n+\n+    /**\n+     * Whether this joins path results in outer joins.\n+     */\n+    public boolean isOuter();\n+\n+    /**\n+     * Perform a cross join on the given tables.\n+     */\n+    public Joins crossJoin(Table localTable, Table foreignTable);\n+\n+    /**\n+     * Join the columns of the given foreign key.\n+     */\n+    public Joins join(ForeignKey fk, boolean inverse, boolean toMany);\n+\n+    /**\n+     * Join the columns of the given foreign key.\n+     */\n+    public Joins outerJoin(ForeignKey fk, boolean inverse, boolean toMany);\n+\n+    /**\n+     * Join the columns of the given foreign key, which represents a relation\n+     * via the given field name.\n+     */\n+    public Joins joinRelation(String name, ForeignKey fk, ClassMapping target,\n+        int subclasses, boolean inverse, boolean toMany);\n+\n+    /**\n+     * Join the columns of the given foreign key, which represents a relation\n+     * via the given field name.\n+     */\n+    public Joins outerJoinRelation(String name, ForeignKey fk, \n+        ClassMapping target, int subclasses, boolean inverse, boolean toMany);\n+\n+    /**\n+     * Set the variable name being traversed into with the next join.\n+     */\n+    public Joins setVariable(String var);\n+\n+    /**\n+     * Set the subquery alias.\n+     */\n+    public Joins setSubselect(String alias);\n+}"},{"sha":"9f28b9bb13d9e98902564a5a3646aad86d262fb1","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java","status":"added","additions":980,"deletions":0,"changes":980,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,980 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.UnsupportedException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * A logical union made up of multiple distinct selects whose results are\n+ * combined in memory.\n+ *\n+ * @author Abe White\n+ */\n+public class LogicalUnion\n+    implements Union {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (LogicalUnion.class);\n+\n+    protected final UnionSelect[] sels;\n+    protected final DBDictionary dict;\n+    protected final ClassMapping[] mappings;\n+    protected final BitSet desc = new BitSet();\n+    private boolean _distinct = true;\n+   \n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param conf system configuration\n+     * @param sels the number of SQL selects to union together\n+     */\n+    public LogicalUnion(JDBCConfiguration conf, int sels) {\n+        this(conf, sels, null);\n+    }\n+\n+    /**\n+     * Constructor used to seed the internal selects.\n+     */\n+    public LogicalUnion(JDBCConfiguration conf, Select[] seeds) {\n+        this(conf, seeds.length, seeds);\n+    }\n+\n+    /**\n+     * Delegate constructor.\n+     */\n+    protected LogicalUnion(JDBCConfiguration conf, int sels, Select[] seeds) {\n+        if (sels == 0)\n+            throw new InternalException(\"sels == 0\");\n+\n+        dict = conf.getDBDictionaryInstance();\n+        mappings = new ClassMapping[sels];\n+        this.sels = new UnionSelect[sels];\n+\n+        SelectImpl seed;\n+        for (int i = 0; i < sels; i++) {\n+            seed = (seeds == null)\n+                ? (SelectImpl) conf.getSQLFactoryInstance().newSelect()\n+                : (SelectImpl) seeds[i];\n+            this.sels[i] = newUnionSelect(seed, i);\n+        }\n+    }\n+\n+    /**\n+     * Create a new union select with the given delegate and union position.\n+     */\n+    protected UnionSelect newUnionSelect(SelectImpl seed, int pos) {\n+        return new UnionSelect(seed, pos);\n+    }\n+\n+    public Select[] getSelects() {\n+        return sels;\n+    }\n+   \n+    public boolean isUnion() {\n+        return false;\n+    }\n+\n+    public void abortUnion() {\n+    }\n+\n+    public String getOrdering() {\n+        return null;\n+    }\n+\n+    public JDBCConfiguration getConfiguration() {\n+        return sels[0].getConfiguration();\n+    }\n+\n+    public DBDictionary getDBDictionary() {\n+        return dict;\n+    }\n+\n+    public SQLBuffer toSelect(boolean forUpdate, JDBCFetchConfiguration fetch) {\n+        return dict.toSelect(sels[0], forUpdate, fetch);\n+    }\n+\n+    public SQLBuffer toSelectCount() {\n+        return dict.toSelectCount(sels[0]);\n+    }\n+\n+    public boolean getAutoDistinct() {\n+        return sels[0].getAutoDistinct();\n+    }\n+\n+    public void setAutoDistinct(boolean distinct) {\n+        for (int i = 0; i < sels.length; i++)\n+            sels[i].setAutoDistinct(distinct);\n+    }\n+\n+    public boolean isDistinct() {\n+        return _distinct;\n+    }\n+\n+    public void setDistinct(boolean distinct) {\n+        _distinct = distinct;\n+    }\n+\n+    public boolean isLRS() {\n+        return sels[0].isLRS();\n+    }\n+\n+    public void setLRS(boolean lrs) {\n+        for (int i = 0; i < sels.length; i++)\n+            sels[i].setLRS(lrs);\n+    }\n+\n+    public int getExpectedResultCount() {\n+        return sels[0].getExpectedResultCount();\n+    }\n+    \n+    public void setExpectedResultCount(int expectedResultCount,\n+        boolean force) {\n+        for (int i = 0; i < sels.length; i++)\n+            sels[i].setExpectedResultCount(expectedResultCount, force);\n+    }\n+\n+    public int getJoinSyntax() {\n+        return sels[0].getJoinSyntax();\n+    }\n+\n+    public void setJoinSyntax(int syntax) {\n+        for (int i = 0; i < sels.length; i++)\n+            sels[i].setJoinSyntax(syntax);\n+    }\n+\n+    public boolean supportsRandomAccess(boolean forUpdate) {\n+        if (sels.length == 1)\n+            return sels[0].supportsRandomAccess(forUpdate);\n+        return false;\n+    }\n+\n+    public boolean supportsLocking() {\n+        if (sels.length == 1)\n+            return sels[0].supportsLocking();\n+        for (int i = 0; i < sels.length; i++)\n+            if (!sels[i].supportsLocking())\n+                return false;\n+        return true;\n+    }\n+\n+    public int getCount(JDBCStore store)\n+        throws SQLException {\n+        int count = 0;\n+        for (int i = 0; i < sels.length; i++)\n+            count += sels[i].getCount(store);\n+        return count;\n+    }\n+\n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch)\n+            throws SQLException {\n+        return execute(store, fetch, null);\n+    }    \n+\n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n+        int lockLevel)\n+        throws SQLException {\n+        return execute(store, fetch, lockLevel, null);\n+    }\n+    \n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch, \n+        List params)\n+        throws SQLException {\n+        if (fetch == null)\n+            fetch = store.getFetchConfiguration();\n+        return execute(store, fetch, fetch.getReadLockLevel(), params);\n+    }\n+\n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n+        int lockLevel, List params)\n+        throws SQLException {\n+        if (fetch == null)\n+            fetch = store.getFetchConfiguration();\n+\n+        if (sels.length == 1) {\n+            Result res = sels[0].execute(store, fetch, lockLevel, params);\n+            ((AbstractResult) res).setBaseMapping(mappings[0]);\n+            return res;\n+        }\n+\n+        if (getExpectedResultCount() == 1) {\n+            AbstractResult res;\n+            for (int i = 0; i < sels.length; i++) {\n+                res = (AbstractResult) sels[i].execute(store, fetch,\n+                    lockLevel, params);\n+                res.setBaseMapping(mappings[i]);\n+                res.setIndexOf(i);\n+\n+                // if we get to the last select, just return its result\n+                if (i == sels.length - 1)\n+                    return res;\n+\n+                // return the first result that has a row\n+                try {\n+                    if (!res.next())\n+                        res.close();\n+                    else {\n+                        res.pushBack();\n+                        return res;\n+                    }\n+                }\n+                catch (SQLException se) {\n+                    res.close();\n+                    throw se;\n+                }\n+            }\n+        }\n+\n+        // create a single result from each select in our fake union, merging\n+        // them as needed\n+        AbstractResult[] res = new AbstractResult[sels.length];\n+        List[] orderIdxs = null;\n+        try {\n+            List l;\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = (AbstractResult) sels[i].execute(store, fetch,\n+                    lockLevel, params);\n+                res[i].setBaseMapping(mappings[i]);\n+                res[i].setIndexOf(i);\n+\n+                l = sels[i].getSelectedOrderIndexes();\n+                if (l != null) {\n+                    if (orderIdxs == null)\n+                        orderIdxs = new List[sels.length];\n+                    orderIdxs[i] = l;\n+                }\n+            }\n+        } catch (SQLException se) {\n+            for (int i = 0; res[i] != null; i++)\n+                res[i].close();\n+            throw se;\n+        }\n+\n+        // if multiple selects have ordering, use a comparator to collate\n+        ResultComparator comp = null;\n+        if (orderIdxs != null)\n+            comp = new ResultComparator(orderIdxs, desc, dict);\n+        return new MergedResult(res, comp);\n+    }\n+\n+    public void select(Union.Selector selector) {\n+        for (int i = 0; i < sels.length; i++)\n+            selector.select(sels[i], i);\n+    }\n+\n+    public String toString() {\n+        return toSelect(false, null).getSQL();\n+    }\n+\n+    /**\n+     * A callback used to create the selects in a SQL union.\n+     */\n+    public static interface Selector {\n+\n+        /**\n+         * Populate the <code>i</code>th select in the union.\n+         */\n+        public void select(Select sel, int i);\n+    }\n+\n+    /**\n+     * A select that is part of a logical union.\n+     */\n+    public class UnionSelect\n+        implements Select {\n+\n+        protected final SelectImpl sel;\n+        protected final int pos;\n+        protected int orders = 0;\n+        protected List orderIdxs = null;\n+       \n+        public UnionSelect(SelectImpl sel, int pos) {\n+            this.sel = sel;\n+            this.pos = pos;\n+            sel.setRecordOrderedIndexes(true);\n+        }\n+\n+        /**\n+         * Delegate select.\n+         */\n+        public SelectImpl getDelegate() {\n+            return sel;\n+        }\n+\n+        /**\n+         * Return the indexes of the data in the select clause this query is\n+         * ordered by.\n+         */\n+        public List getSelectedOrderIndexes() {\n+            if (orderIdxs == null)\n+                orderIdxs = sel.getOrderedIndexes();\n+            return orderIdxs;\n+        }\n+\n+        public JDBCConfiguration getConfiguration() {\n+            return sel.getConfiguration();\n+        }\n+\n+        public int indexOf() {\n+            return pos;\n+        }\n+\n+        public SQLBuffer toSelect(boolean forUpdate,\n+            JDBCFetchConfiguration fetch) {\n+            return sel.toSelect(forUpdate, fetch);\n+        }\n+\n+        public SQLBuffer toSelectCount() {\n+            return sel.toSelectCount();\n+        }\n+\n+        public boolean getAutoDistinct() {\n+            return sel.getAutoDistinct();\n+        }\n+\n+        public void setAutoDistinct(boolean distinct) {\n+            sel.setAutoDistinct(distinct);\n+        }\n+\n+        public boolean isDistinct() {\n+            return sel.isDistinct();\n+        }\n+\n+        public void setDistinct(boolean distinct) {\n+            sel.setDistinct(distinct);\n+        }\n+\n+        public boolean isLRS() {\n+            return sel.isLRS();\n+        }\n+\n+        public void setLRS(boolean lrs) {\n+            sel.setLRS(lrs);\n+        }\n+\n+        public int getJoinSyntax() {\n+            return sel.getJoinSyntax();\n+        }\n+\n+        public void setJoinSyntax(int joinSyntax) {\n+            sel.setJoinSyntax(joinSyntax);\n+        }\n+\n+        public boolean supportsRandomAccess(boolean forUpdate) {\n+            return sel.supportsRandomAccess(forUpdate);\n+        }\n+\n+        public boolean supportsLocking() {\n+            return sel.supportsLocking();\n+        }\n+\n+        public int getCount(JDBCStore store)\n+            throws SQLException {\n+            return sel.getCount(store);\n+        }\n+\n+        public Result execute(JDBCStore store, JDBCFetchConfiguration fetch, \n+            List params)\n+            throws SQLException {\n+            return sel.execute(store, fetch, params);\n+        }\n+\n+        public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n+            int lockLevel, List params)\n+            throws SQLException {\n+            return sel.execute(store, fetch, lockLevel, params);\n+        }\n+\n+        public Result execute(JDBCStore store, JDBCFetchConfiguration fetch)\n+            throws SQLException {\n+            return sel.execute(store, fetch);\n+        }\n+\n+        public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n+            int lockLevel)\n+            throws SQLException {\n+            return sel.execute(store, fetch, lockLevel);\n+        }\n+        \n+        public List getSubselects() {\n+            return Collections.EMPTY_LIST;\n+        }\n+\n+        public Select getParent() {\n+            return null;\n+        }\n+\n+        public String getSubselectPath() {\n+            return null;\n+        }\n+\n+        public void setParent(Select parent, String path) {\n+            throw new UnsupportedException(_loc.get(\"union-element\"));\n+        }\n+\n+        public Select getFromSelect() {\n+            return null;\n+        }\n+\n+        public void setFromSelect(Select sel) {\n+            throw new UnsupportedException(_loc.get(\"union-element\"));\n+        }\n+\n+        public boolean hasEagerJoin(boolean toMany) {\n+            return sel.hasEagerJoin(toMany);\n+        }\n+\n+        public boolean hasJoin(boolean toMany) {\n+            return sel.hasJoin(toMany);\n+        }\n+\n+        public boolean isSelected(Table table) {\n+            return sel.isSelected(table);\n+        }\n+\n+        public Collection getTableAliases() {\n+            return sel.getTableAliases();\n+        }\n+\n+        public List getSelects() {\n+            return sel.getSelects();\n+        }\n+\n+        public List getSelectAliases() {\n+            return sel.getSelectAliases();\n+        }\n+\n+        public List getIdentifierAliases() {\n+            return sel.getIdentifierAliases();\n+        }\n+\n+        public SQLBuffer getOrdering() {\n+            return sel.getOrdering();\n+        }\n+\n+        public SQLBuffer getGrouping() {\n+            return sel.getGrouping();\n+        }\n+\n+        public SQLBuffer getWhere() {\n+            return sel.getWhere();\n+        }\n+\n+        public SQLBuffer getHaving() {\n+            return sel.getHaving();\n+        }\n+\n+        public SQLBuffer getSQL() {\n+            return sel.getSQL();\n+        }\n+        \n+        public void setSQL(JDBCStore store, JDBCFetchConfiguration fetch) {\n+            sel.setSQL(store, fetch);\n+        }\n+        \n+        public void addJoinClassConditions() {\n+            sel.addJoinClassConditions();\n+        }\n+\n+        public Joins getJoins() {\n+            return sel.getJoins();\n+        }\n+\n+        public Iterator getJoinIterator() {\n+            return sel.getJoinIterator();\n+        }\n+\n+        public long getStartIndex() {\n+            return sel.getStartIndex();\n+        }\n+\n+        public long getEndIndex() {\n+            return sel.getEndIndex();\n+        }\n+\n+        public void setRange(long start, long end) {\n+            sel.setRange(start, end);\n+        }\n+\n+        public String getColumnAlias(Column col) {\n+            return sel.getColumnAlias(col);\n+        }\n+\n+        public String getColumnAlias(Column col, Joins joins) {\n+            return sel.getColumnAlias(col, joins);\n+        }\n+\n+        public String getColumnAlias(String col, Table table) {\n+            return sel.getColumnAlias(col, table);\n+        }\n+\n+        public String getColumnAlias(String col, Table table, Joins joins) {\n+            return sel.getColumnAlias(col, table, joins);\n+        }\n+\n+        public boolean isAggregate() {\n+            return sel.isAggregate();\n+        }\n+\n+        public void setAggregate(boolean agg) {\n+            sel.setAggregate(agg);\n+        }\n+\n+        public boolean isLob() {\n+            return sel.isLob();\n+        }\n+\n+        public void setLob(boolean lob) {\n+            sel.setLob(lob);\n+        }\n+\n+        public void selectPlaceholder(String sql) {\n+            sel.selectPlaceholder(sql);\n+        }\n+\n+        public void clearSelects() {\n+            sel.clearSelects();\n+        }\n+\n+        public boolean select(SQLBuffer sql, Object id) {\n+            return sel.select(sql, id);\n+        }\n+\n+        public boolean select(SQLBuffer sql, Object id, Joins joins) {\n+            return sel.select(sql, id, joins);\n+        }\n+\n+        public boolean select(String sql, Object id) {\n+            return sel.select(sql, id);\n+        }\n+\n+        public boolean select(String sql, Object id, Joins joins) {\n+            return sel.select(sql, id, joins);\n+        }\n+\n+        public boolean select(Column col) {\n+            return sel.select(col);\n+        }\n+\n+        public boolean select(Column col, Joins joins) {\n+            return sel.select(col, joins);\n+        }\n+\n+        public int select(Column[] cols) {\n+            return sel.select(cols);\n+        }\n+\n+        public int select(Column[] cols, Joins joins) {\n+            return sel.select(cols, joins);\n+        }\n+\n+        public void select(ClassMapping mapping, int subclasses,\n+            JDBCStore store, JDBCFetchConfiguration fetch, int eager) {\n+            select(mapping, subclasses, store, fetch, eager, null, false);\n+        }\n+\n+        public void select(ClassMapping mapping, int subclasses,\n+            JDBCStore store, JDBCFetchConfiguration fetch, int eager,\n+            Joins joins) {\n+            select(mapping, subclasses, store, fetch, eager, joins, false);\n+        }\n+\n+        private void select(ClassMapping mapping, int subclasses,\n+            JDBCStore store, JDBCFetchConfiguration fetch, int eager,\n+            Joins joins, boolean identifier) {\n+            // if this is the first (primary) mapping selected for this\n+            // SELECT, record it so we can figure out what the result type is\n+            // since the discriminator might not be selected\n+            if (mappings[pos] == null)\n+                mappings[pos] = mapping;\n+\n+            sel.select(this, mapping, subclasses, store, fetch, eager,\n+                joins, identifier);\n+        }\n+\n+        public boolean selectIdentifier(Column col) {\n+            return sel.selectIdentifier(col);\n+        }\n+\n+        public boolean selectIdentifier(Column col, Joins joins) {\n+            return sel.selectIdentifier(col, joins);\n+        }\n+\n+        public int selectIdentifier(Column[] cols) {\n+            return sel.selectIdentifier(cols);\n+        }\n+\n+        public int selectIdentifier(Column[] cols, Joins joins) {\n+            return sel.selectIdentifier(cols, joins);\n+        }\n+\n+        public void selectIdentifier(ClassMapping mapping, int subclasses,\n+            JDBCStore store, JDBCFetchConfiguration fetch, int eager) {\n+            select(mapping, subclasses, store, fetch, eager, null, true);\n+        }\n+\n+        public void selectIdentifier(ClassMapping mapping, int subclasses,\n+            JDBCStore store, JDBCFetchConfiguration fetch, int eager,\n+            Joins joins) {\n+            select(mapping, subclasses, store, fetch, eager, joins, true);\n+        }\n+\n+        public int selectPrimaryKey(ClassMapping mapping) {\n+            return sel.selectPrimaryKey(mapping);\n+        }\n+\n+        public int selectPrimaryKey(ClassMapping mapping, Joins joins) {\n+            return sel.selectPrimaryKey(mapping, joins);\n+        }\n+\n+        public int orderByPrimaryKey(ClassMapping mapping, boolean asc,\n+            boolean select) {\n+            return orderByPrimaryKey(mapping, asc, null, select);\n+        }\n+\n+        public int orderByPrimaryKey(ClassMapping mapping, boolean asc,\n+            Joins joins, boolean select) {\n+            ClassMapping pks = mapping;\n+            while (!pks.isPrimaryKeyObjectId(true))\n+                pks = pks.getJoinablePCSuperclassMapping();\n+            Column[] cols = pks.getPrimaryKeyColumns();\n+            recordOrderColumns(cols, asc);\n+            return sel.orderByPrimaryKey(mapping, asc, joins, select,\n+                isUnion());\n+        }\n+\n+        /**\n+         * Record that we're ordering by a SQL expression.\n+         */\n+        protected void recordOrder(Object ord, boolean asc) {\n+            if (ord == null)\n+                return;\n+            orderIdxs = null;\n+\n+            int idx = orders++;\n+            if (desc.get(idx) && asc)\n+                throw new UserException(_loc.get(\"incompat-ordering\"));\n+            if (!asc)\n+                desc.set(idx);\n+        }\n+\n+        /**\n+         * Record that we're ordering by the given columns.\n+         */\n+        protected void recordOrderColumns(Column[] cols, boolean asc) {\n+            for (int i = 0; i < cols.length; i++)\n+                recordOrder(cols[i], asc);\n+        }\n+\n+        public boolean orderBy(Column col, boolean asc, boolean select) {\n+            return orderBy(col, asc, null, select);\n+        }\n+\n+        public boolean orderBy(Column col, boolean asc, Joins joins,\n+            boolean select) {\n+            recordOrder(col, asc);\n+            return sel.orderBy(col, asc, joins, select, isUnion());\n+        }\n+\n+        public int orderBy(Column[] cols, boolean asc, boolean select) {\n+            return orderBy(cols, asc, null, select);\n+        }\n+\n+        public int orderBy(Column[] cols, boolean asc, Joins joins,\n+            boolean select) {\n+            recordOrderColumns(cols, asc);\n+            return sel.orderBy(cols, asc, joins, select, isUnion());\n+        }\n+\n+        public boolean orderBy(SQLBuffer sql, boolean asc, boolean select) {\n+            return orderBy(sql, asc, null, select);\n+        }\n+\n+        public boolean orderBy(SQLBuffer sql, boolean asc, Joins joins,\n+            boolean select) {\n+            recordOrder(sql.getSQL(false), asc);\n+            return sel.orderBy(sql, asc, joins, select, isUnion());\n+        }\n+\n+        public boolean orderBy(String sql, boolean asc, boolean select) {\n+            return orderBy(sql, asc, null, select);\n+        }\n+\n+        public boolean orderBy(String sql, boolean asc, Joins joins,\n+            boolean select) {\n+            recordOrder(sql, asc);\n+            return sel.orderBy(sql, asc, joins, select, isUnion());\n+        }\n+\n+        public void clearOrdering() {\n+            sel.clearOrdering();\n+        }\n+\n+        public void wherePrimaryKey(Object oid, ClassMapping mapping,\n+            JDBCStore store) {\n+            sel.wherePrimaryKey(oid, mapping, store);\n+        }\n+        \n+        public int wherePrimaryKey(ClassMapping mapping, Column[] toCols, \n+            Column[] fromCols, Object oid, JDBCStore store, PathJoins pj,\n+            SQLBuffer buf, List parmList) {\n+            return sel.wherePrimaryKey(mapping, toCols, fromCols, oid, store, pj, \n+                buf, parmList);\n+        }\n+        \n+        \n+\n+        public void whereForeignKey(ForeignKey fk, Object oid,\n+            ClassMapping mapping, JDBCStore store) {\n+            sel.whereForeignKey(fk, oid, mapping, store);\n+        }\n+\n+        public void where(Joins joins) {\n+            sel.where(joins);\n+        }\n+\n+        public void where(SQLBuffer sql) {\n+            sel.where(sql);\n+        }\n+\n+        public void where(SQLBuffer sql, Joins joins) {\n+            sel.where(sql, joins);\n+        }\n+\n+        public void where(String sql) {\n+            sel.where(sql);\n+        }\n+\n+        public void where(String sql, Joins joins) {\n+            sel.where(sql, joins);\n+        }\n+\n+        public void having(SQLBuffer sql) {\n+            sel.having(sql);\n+        }\n+\n+        public void having(SQLBuffer sql, Joins joins) {\n+            sel.having(sql, joins);\n+        }\n+\n+        public void having(String sql) {\n+            sel.having(sql);\n+        }\n+\n+        public void having(String sql, Joins joins) {\n+            sel.having(sql, joins);\n+        }\n+\n+        public void groupBy(SQLBuffer sql) {\n+            sel.groupBy(sql);\n+        }\n+\n+        public void groupBy(SQLBuffer sql, Joins joins) {\n+            sel.groupBy(sql, joins);\n+        }\n+\n+        public void groupBy(String sql) {\n+            sel.groupBy(sql);\n+        }\n+\n+        public void groupBy(String sql, Joins joins) {\n+            sel.groupBy(sql, joins);\n+        }\n+\n+        public void groupBy(Column col) {\n+            sel.groupBy(col);\n+        }\n+\n+        public void groupBy(Column col, Joins joins) {\n+            sel.groupBy(col, joins);\n+        }\n+\n+        public void groupBy(Column[] cols) {\n+            sel.groupBy(cols);\n+        }\n+\n+        public void groupBy(Column[] cols, Joins joins) {\n+            sel.groupBy(cols, joins);\n+        }\n+\n+        public void groupBy(ClassMapping mapping, int subclasses, \n+            JDBCStore store, JDBCFetchConfiguration fetch) {\n+            sel.groupBy(mapping, subclasses, store, fetch);\n+        }\n+\n+        public void groupBy(ClassMapping mapping, int subclasses, \n+            JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n+            sel.groupBy(mapping, subclasses, store, fetch, joins);\n+        }\n+\n+        public SelectExecutor whereClone(int sels) {\n+            return sel.whereClone(sels);\n+        }\n+\n+        public SelectExecutor fullClone(int sels) {\n+            return sel.fullClone(sels);\n+        }\n+\n+        public SelectExecutor eagerClone(FieldMapping key, int eagerType,\n+            boolean toMany, int sels) {\n+            SelectExecutor ex = sel.eagerClone(key, eagerType, toMany, sels);\n+            return (ex == sel) ? this : ex;\n+        }\n+\n+        public SelectExecutor getEager(FieldMapping key) {\n+            SelectExecutor ex = sel.getEager(key);\n+            return (ex == sel) ? this : ex;\n+        }\n+\n+        public Joins newJoins() {\n+            return sel.newJoins();\n+        }\n+\n+        public Joins newOuterJoins() {\n+            return sel.newOuterJoins();\n+        }\n+\n+        public void append(SQLBuffer buf, Joins joins) {\n+            sel.append(buf, joins);\n+        }\n+\n+        public Joins and(Joins joins1, Joins joins2) {\n+            return sel.and(joins1, joins2);\n+        }\n+\n+        public Joins or(Joins joins1, Joins joins2) {\n+            return sel.or(joins1, joins2);\n+        }\n+\n+        public Joins outer(Joins joins) {\n+            return sel.outer(joins);\n+        }\n+\n+        public String toString() {\n+            return sel.toString();\n+        }\n+\n+        public int getExpectedResultCount() {\n+            return sel.getExpectedResultCount();\n+        }\n+\n+        public void setExpectedResultCount(int expectedResultCount, \n+            boolean force) {\n+            sel.setExpectedResultCount(expectedResultCount, force);\n+        }\n+    }\n+\n+    /**\n+     * Comparator for collating ordered results when faking a union.\n+     */\n+    private static class ResultComparator\n+        implements MergedResult.ResultComparator {\n+\n+        private final List[] _orders;\n+        private final BitSet _desc;\n+        private final DBDictionary _dict;\n+\n+        public ResultComparator(List[] orders, BitSet desc, DBDictionary dict) {\n+            _orders = orders;\n+            _desc = desc;\n+            _dict = dict;\n+        }\n+\n+        public Object getOrderingValue(Result res, int idx) {\n+            // if one value just return it\n+            ResultSet rs = ((ResultSetResult) res).getResultSet();\n+            if (_orders[idx].size() == 1)\n+                return getOrderingValue(rs, _orders[idx].get(0));\n+\n+            // return array of values\n+            Object[] vals = new Object[_orders[idx].size()];\n+            for (int i = 0; i < vals.length; i++)\n+                vals[i] = getOrderingValue(rs, _orders[idx].get(i));\n+            return vals;\n+        }\n+\n+        /**\n+         * Extract value at given index from result set.\n+         */\n+        private Object getOrderingValue(ResultSet rs, Object i) {\n+            try {\n+                return _dict.getObject(rs, ((Integer) i).intValue() + 1, null);\n+            } catch (SQLException se) {\n+                throw SQLExceptions.getStore(se, _dict);\n+            }\n+        }\n+\n+        public int compare(Object o1, Object o2) {\n+            if (o1 == o2)\n+                return 0;\n+            if (o1 == null)\n+                return (_desc.get(0)) ? -1 : 1;\n+            if (o2 == null)\n+                return (_desc.get(0)) ? 1 : -1;\n+\n+            int cmp;\n+            if (!(o1 instanceof Object[])) {\n+                if (!(o2 instanceof Object[])) {\n+                    cmp = ((Comparable) o1).compareTo(o2);\n+                    return (_desc.get(0)) ? -cmp : cmp;\n+                }\n+\n+                cmp = ((Comparable) o1).compareTo(((Object[]) o2)[0]);\n+                if (cmp != 0)\n+                    return (_desc.get(0)) ? -cmp : cmp;\n+                return -1;\n+            }\n+\n+            if (!(o2 instanceof Object[])) {\n+                cmp = ((Comparable) ((Object[]) o1)[0]).compareTo(o2);\n+                if (cmp != 0)\n+                    return (_desc.get(0)) ? -cmp : cmp;\n+                return 1;\n+            }\n+\n+            Object[] a1 = (Object[]) o1;\n+            Object[] a2 = (Object[]) o2;\n+            for (int i = 0; i < a1.length; i++) {\n+                cmp = ((Comparable) a1[i]).compareTo(a2[i]);\n+                if (cmp != 0)\n+                    return (_desc.get(i)) ? -cmp : cmp;\n+            }\n+            return a1.length - a2.length;\n+        }\n+    }\n+}"},{"sha":"2702aab559ebb8c25a3142c191d18dbe02ec8ded","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MergedResult.java","status":"added","additions":557,"deletions":0,"changes":557,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MergedResult.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MergedResult.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MergedResult.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,557 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Ref;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.util.Calendar;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.util.UnsupportedException;\n+\n+/**\n+ * Result that merges multiple result delegates. Support exists for\n+ * maintaining ordering of the internally-held results, provided that each\n+ * of the individual results is itself ordered.\n+ *\n+ * @author Abe White\n+ */\n+public class MergedResult\n+    implements Result {\n+\n+    private static final byte NEXT = 0;\n+    private static final byte CURRENT = 1;\n+    private static final byte DONE = 2;\n+\n+    private final Result[] _res;\n+    private final byte[] _status;\n+    private final ResultComparator _comp;\n+    private final Object[] _order;\n+    private int _idx = 0;\n+    private boolean _pushedBack = false;\n+\n+    /**\n+     * Constructor; supply delegates.\n+     */\n+    public MergedResult(Result[] res) {\n+        this(res, null);\n+    }\n+\n+    /**\n+     * Constructor; supply delegates and comparator for ordering results.\n+     */\n+    public MergedResult(Result[] res, ResultComparator comp) {\n+        _res = res;\n+        _comp = comp;\n+        _order = (comp == null) ? null : new Object[res.length];\n+        _status = (comp == null) ? null : new byte[res.length];\n+    }\n+\n+    public Object getEager(FieldMapping key) {\n+        return _res[_idx].getEager(key);\n+    }\n+\n+    public void putEager(FieldMapping key, Object res) {\n+        _res[_idx].putEager(key, res);\n+    }\n+\n+    public Joins newJoins() {\n+        return _res[_idx].newJoins();\n+    }\n+\n+    public void close() {\n+        for (int i = 0; i < _res.length; i++)\n+            _res[i].close();\n+    }\n+\n+    public boolean isLocking() {\n+        return _res[_idx].isLocking();\n+    }\n+\n+    public boolean supportsRandomAccess()\n+        throws SQLException {\n+        return false;\n+    }\n+\n+    public boolean absolute(int row)\n+        throws SQLException {\n+        throw new UnsupportedException();\n+    }\n+\n+    public boolean next()\n+        throws SQLException {\n+        if (_pushedBack) {\n+            _pushedBack = false;\n+            return true;\n+        }\n+\n+        if (_comp == null) {\n+            while (!_res[_idx].next()) {\n+                if (_idx == _res.length - 1)\n+                    return false;\n+                _idx++;\n+            }\n+            return true;\n+        }\n+\n+        // ordering is involved; extract order values from each result\n+        boolean hasValue = false;\n+        for (int i = 0; i < _status.length; i++) {\n+            switch (_status[i]) {\n+                case NEXT:\n+                    if (_res[i].next()) {\n+                        hasValue = true;\n+                        _status[i] = CURRENT;\n+                        _order[i] = _comp.getOrderingValue(_res[i], i);\n+                    } else\n+                        _status[i] = DONE;\n+                    break;\n+                case CURRENT:\n+                    hasValue = true;\n+                    break;\n+            }\n+        }\n+\n+        // all results exhausted\n+        if (!hasValue)\n+            return false;\n+\n+        // for all results with values, find the 'least' one according to\n+        // the comparator\n+        int least = -1;\n+        Object orderVal = null;\n+        for (int i = 0; i < _order.length; i++) {\n+            if (_status[i] != CURRENT)\n+                continue;\n+            if (least == -1 || _comp.compare(_order[i], orderVal) < 0) {\n+                least = i;\n+                orderVal = _order[i];\n+            }\n+        }\n+\n+        // make the current result the one with the least value, and clear\n+        // the cached value for that result\n+        _idx = least;\n+        _order[least] = null;\n+        _status[least] = NEXT;\n+        return true;\n+    }\n+\n+    public void pushBack()\n+        throws SQLException {\n+        _pushedBack = true;\n+    }\n+\n+    public int size()\n+        throws SQLException {\n+        int size = 0;\n+        for (int i = 0; i < _res.length; i++)\n+            size += _res[i].size();\n+        return size;\n+    }\n+\n+    public boolean contains(Object obj)\n+        throws SQLException {\n+        return _res[_idx].contains(obj);\n+    }\n+\n+    public boolean containsAll(Object[] objs)\n+        throws SQLException {\n+        return _res[_idx].containsAll(objs);\n+    }\n+\n+    public boolean contains(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].contains(col, joins);\n+    }\n+\n+    public boolean containsAll(Column[] cols, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].containsAll(cols, joins);\n+    }\n+\n+    public ClassMapping getBaseMapping() {\n+        return _res[_idx].getBaseMapping();\n+    }\n+\n+    public void setBaseMapping(ClassMapping mapping) {\n+        _res[_idx].setBaseMapping(mapping);\n+    }\n+\n+    public FieldMapping getMappedByFieldMapping() {\n+        return _res[_idx].getMappedByFieldMapping();\n+    }\n+\n+    public void setMappedByFieldMapping(FieldMapping fieldMapping) {\n+        _res[_idx].setMappedByFieldMapping(fieldMapping);\n+    }\n+\n+    public Object getMappedByValue() {\n+        return _res[_idx].getMappedByValue();\n+    }\n+\n+    public void setMappedByValue(Object mappedByValue) {\n+        _res[_idx].setMappedByValue(mappedByValue);\n+    }\n+\n+    public int indexOf() {\n+        return _res[_idx].indexOf();\n+    }\n+\n+    public Object load(ClassMapping mapping, JDBCStore store,\n+        JDBCFetchConfiguration fetch)\n+        throws SQLException {\n+        return _res[_idx].load(mapping, store, fetch);\n+    }\n+\n+    public Object load(ClassMapping mapping, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].load(mapping, store, fetch, joins);\n+    }\n+\n+    public Array getArray(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getArray(obj);\n+    }\n+\n+    public InputStream getAsciiStream(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getAsciiStream(obj);\n+    }\n+\n+    public BigDecimal getBigDecimal(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getBigDecimal(obj);\n+    }\n+\n+    public BigInteger getBigInteger(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getBigInteger(obj);\n+    }\n+\n+    public InputStream getBinaryStream(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getBinaryStream(obj);\n+    }\n+\n+    public InputStream getLOBStream(JDBCStore store, Object obj)\n+        throws SQLException {\n+        return _res[_idx].getLOBStream(store, obj);\n+    }\n+    \n+    public Blob getBlob(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getBlob(obj);\n+    }\n+\n+    public boolean getBoolean(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getBoolean(obj);\n+    }\n+\n+    public byte getByte(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getByte(obj);\n+    }\n+\n+    public byte[] getBytes(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getBytes(obj);\n+    }\n+\n+    public Calendar getCalendar(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getCalendar(obj);\n+    }\n+\n+    public char getChar(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getChar(obj);\n+    }\n+\n+    public Reader getCharacterStream(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getCharacterStream(obj);\n+    }\n+\n+    public Clob getClob(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getClob(obj);\n+    }\n+\n+    public Date getDate(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getDate(obj);\n+    }\n+\n+    public java.sql.Date getDate(Object obj, Calendar cal)\n+        throws SQLException {\n+        return _res[_idx].getDate(obj, cal);\n+    }\n+\n+    public double getDouble(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getDouble(obj);\n+    }\n+\n+    public float getFloat(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getFloat(obj);\n+    }\n+\n+    public int getInt(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getInt(obj);\n+    }\n+\n+    public Locale getLocale(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getLocale(obj);\n+    }\n+\n+    public long getLong(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getLong(obj);\n+    }\n+\n+    public Number getNumber(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getNumber(obj);\n+    }\n+\n+    public Object getObject(Object obj, int metaType, Object arg)\n+        throws SQLException {\n+        return _res[_idx].getObject(obj, metaType, arg);\n+    }\n+\n+    public Object getSQLObject(Object obj, Map map)\n+        throws SQLException {\n+        return _res[_idx].getSQLObject(obj, map);\n+    }\n+\n+    public Ref getRef(Object obj, Map map)\n+        throws SQLException {\n+        return _res[_idx].getRef(obj, map);\n+    }\n+\n+    public short getShort(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getShort(obj);\n+    }\n+\n+    public String getString(Object obj)\n+        throws SQLException {\n+        return _res[_idx].getString(obj);\n+    }\n+\n+    public Time getTime(Object obj, Calendar cal)\n+        throws SQLException {\n+        return _res[_idx].getTime(obj, cal);\n+    }\n+\n+    public Timestamp getTimestamp(Object obj, Calendar cal)\n+        throws SQLException {\n+        return _res[_idx].getTimestamp(obj, cal);\n+    }\n+\n+    public Array getArray(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getArray(col, joins);\n+    }\n+\n+    public InputStream getAsciiStream(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getAsciiStream(col, joins);\n+    }\n+\n+    public BigDecimal getBigDecimal(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getBigDecimal(col, joins);\n+    }\n+\n+    public BigInteger getBigInteger(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getBigInteger(col, joins);\n+    }\n+\n+    public InputStream getBinaryStream(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getBinaryStream(col, joins);\n+    }\n+\n+    public Blob getBlob(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getBlob(col, joins);\n+    }\n+\n+    public boolean getBoolean(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getBoolean(col, joins);\n+    }\n+\n+    public byte getByte(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getByte(col, joins);\n+    }\n+\n+    public byte[] getBytes(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getBytes(col, joins);\n+    }\n+\n+    public Calendar getCalendar(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getCalendar(col, joins);\n+    }\n+\n+    public char getChar(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getChar(col, joins);\n+    }\n+\n+    public Reader getCharacterStream(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getCharacterStream(col, joins);\n+    }\n+\n+    public Clob getClob(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getClob(col, joins);\n+    }\n+\n+    public Date getDate(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getDate(col, joins);\n+    }\n+\n+    public java.sql.Date getDate(Column col, Calendar cal, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getDate(col, cal, joins);\n+    }\n+\n+    public double getDouble(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getDouble(col, joins);\n+    }\n+\n+    public float getFloat(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getFloat(col, joins);\n+    }\n+\n+    public int getInt(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getInt(col, joins);\n+    }\n+\n+    public Locale getLocale(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getLocale(col, joins);\n+    }\n+\n+    public long getLong(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getLong(col, joins);\n+    }\n+\n+    public Number getNumber(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getNumber(col, joins);\n+    }\n+\n+    public Object getObject(Column col, Object arg, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getObject(col, arg, joins);\n+    }\n+\n+    public Object getSQLObject(Column col, Map map, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getSQLObject(col, map, joins);\n+    }\n+\n+    public Ref getRef(Column col, Map map, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getRef(col, map, joins);\n+    }\n+\n+    public short getShort(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getShort(col, joins);\n+    }\n+\n+    public String getString(Column col, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getString(col, joins);\n+    }\n+\n+    public Time getTime(Column col, Calendar cal, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getTime(col, cal, joins);\n+    }\n+\n+    public Timestamp getTimestamp(Column col, Calendar cal, Joins joins)\n+        throws SQLException {\n+        return _res[_idx].getTimestamp(col, cal, joins);\n+    }\n+\n+    public boolean wasNull()\n+        throws SQLException {\n+        return _res[_idx].wasNull();\n+    }\n+\n+    public void startDataRequest(Object mapping) {\n+        for (int i = 0; i < _res.length; i++)\n+            _res[i].startDataRequest(mapping);\n+    }\n+\n+    public void endDataRequest() {\n+        for (int i = 0; i < _res.length; i++)\n+            _res[i].endDataRequest();\n+    }\n+\n+    /**\n+     * Comparator for ordering result rows.\n+     */\n+    public static interface ResultComparator\n+        extends Comparator {\n+\n+        /**\n+         * Return the ordering value of the current row of the given result.\n+         */\n+        public Object getOrderingValue(Result res, int idx);\n+    }\n+}"},{"sha":"d3e98abb404827ddd18aa74ba177195e3aee6d20","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MySQLDictionary.java","status":"added","additions":265,"deletions":0,"changes":265,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MySQLDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MySQLDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MySQLDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.Arrays;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Index;\n+import org.apache.openjpa.jdbc.schema.PrimaryKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+\n+/**\n+ * Dictionary for MySQL.\n+ */\n+public class MySQLDictionary\n+    extends DBDictionary {\n+\n+    /**\n+     * The MySQL table type to use when creating tables; defaults to innodb.\n+     */\n+    public String tableType = \"innodb\";\n+\n+    /**\n+     * Whether to use clobs. Some older versions of MySQL do not handle\n+     * clobs properly so we default to false here.\n+     */\n+    public boolean useClobs = true;\n+\n+    /**\n+     * Whether the driver automatically deserializes blobs.\n+     */\n+    public boolean driverDeserializesBlobs = false;\n+\n+    /**\n+     * Whether to inline multi-table bulk-delete operations into MySQL's \n+     * combined <code>DELETE FROM foo, bar, baz</code> syntax. \n+     * Defaults to false, since this may fail in the presence of InnoDB tables\n+     * with foreign keys.\n+     * @see http://dev.mysql.com/doc/refman/5.0/en/delete.html\n+     */\n+    public boolean optimizeMultiTableDeletes = false;\n+\n+    public MySQLDictionary() {\n+        platform = \"MySQL\";\n+        validationSQL = \"SELECT NOW()\";\n+        distinctCountColumnSeparator = \",\";\n+\n+        supportsDeferredConstraints = false;\n+        constraintNameMode = CONS_NAME_MID;\n+        supportsMultipleNontransactionalResultSets = false;\n+        requiresAliasForSubselect = true; // new versions\n+        requiresTargetForDelete = true;\n+        supportsSelectStartIndex = true;\n+        supportsSelectEndIndex = true;\n+\n+        concatenateFunction = \"CONCAT({0},{1})\";\n+\n+        maxTableNameLength = 64;\n+        maxColumnNameLength = 64;\n+        maxIndexNameLength = 64;\n+        maxConstraintNameLength = 64;\n+        maxIndexesPerTable = 32;\n+        schemaCase = SCHEMA_CASE_PRESERVE;\n+\n+        supportsAutoAssign = true;\n+        lastGeneratedKeyQuery = \"SELECT LAST_INSERT_ID()\";\n+        autoAssignClause = \"AUTO_INCREMENT\";\n+\n+        clobTypeName = \"TEXT\";\n+        longVarcharTypeName = \"TEXT\";\n+        longVarbinaryTypeName = \"LONG VARBINARY\";\n+        timestampTypeName = \"DATETIME\";\n+        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\n+            \"BOOL\", \"LONG VARBINARY\", \"MEDIUMBLOB\", \"LONGBLOB\",\n+            \"TINYBLOB\", \"LONG VARCHAR\", \"MEDIUMTEXT\", \"LONGTEXT\", \"TEXT\",\n+            \"TINYTEXT\", \"DOUBLE PRECISION\", \"ENUM\", \"SET\", \"DATETIME\",\n+        }));\n+        reservedWordSet.addAll(Arrays.asList(new String[]{\n+            \"INT1\", \"INT2\", \"INT4\", \"FLOAT1\", \"FLOAT2\", \"FLOAT4\",\n+            \"AUTO_INCREMENT\", \"BINARY\", \"BLOB\", \"CHANGE\", \"ENUM\", \"INFILE\",\n+            \"LOAD\", \"MEDIUMINT\", \"OPTION\", \"OUTFILE\", \"REPLACE\",\n+            \"SET\", \"STARTING\", \"TEXT\", \"UNSIGNED\", \"ZEROFILL\",\n+        }));\n+\n+        // MySQL requires double-escape for strings\n+        searchStringEscape = \"\\\\\\\\\";\n+\n+        typeModifierSet.addAll(Arrays.asList(new String[] { \"UNSIGNED\",\n+            \"ZEROFILL\" }));\n+    }\n+\n+    public void connectedConfiguration(Connection conn) throws SQLException {\n+        super.connectedConfiguration(conn);\n+\n+        DatabaseMetaData metaData = conn.getMetaData();\n+        // The product version looks like 4.1.3-nt\n+        String productVersion = metaData.getDatabaseProductVersion();\n+        // The driver version looks like mysql-connector-java-3.1.11 (...)\n+        String driverVersion = metaData.getDriverVersion();\n+\n+        try {\n+            int[] versions = getMajorMinorVersions(productVersion);\n+            int maj = versions[0];\n+            int min = versions[1];\n+            if (maj < 4 || (maj == 4 && min < 1)) {\n+                supportsSubselect = false;\n+                allowsAliasInBulkClause = false;\n+            }\n+\n+            versions = getMajorMinorVersions(driverVersion);\n+            maj = versions[0];\n+            if (maj < 5) {\n+                driverDeserializesBlobs = true;\n+            }\n+        } catch (IllegalArgumentException e) {\n+            // we don't understand the version format.\n+            // That is ok. We just take the default values.\n+        }\n+    }\n+\n+    private static int[] getMajorMinorVersions(String versionStr)\n+        throws IllegalArgumentException {\n+        int beginIndex = 0;\n+        int endIndex = 0;\n+\n+        versionStr = versionStr.trim();\n+        char[] charArr = versionStr.toCharArray();\n+        for (int i = 0; i < charArr.length; i++) {\n+            if (Character.isDigit(charArr[i])) {\n+                beginIndex = i;\n+                break;\n+            }\n+        }\n+\n+        for (int i = beginIndex+1; i < charArr.length; i++) {\n+            if (charArr[i] != '.' && !Character.isDigit(charArr[i])) {\n+                endIndex = i;\n+                break;\n+            }\n+        }\n+\n+        if (endIndex < beginIndex)\n+            throw new IllegalArgumentException();\n+\n+        String[] arr = versionStr.substring(beginIndex, endIndex).split(\"\\\\.\");\n+        if (arr.length < 2)\n+            throw new IllegalArgumentException();\n+\n+        int maj = Integer.parseInt(arr[0]);\n+        int min = Integer.parseInt(arr[1]);\n+        return new int[]{maj, min};\n+    }\n+\n+    public String[] getCreateTableSQL(Table table) {\n+        String[] sql = super.getCreateTableSQL(table);\n+        if (!StringUtils.isEmpty(tableType))\n+            sql[0] = sql[0] + \" TYPE = \" + tableType;\n+        return sql;\n+    }\n+\n+    public String[] getDropIndexSQL(Index index) {\n+        return new String[]{ \"DROP INDEX \" + getFullName(index) + \" ON \"\n+            + getFullName(index.getTable(), false) };\n+    }\n+\n+    public String[] getAddPrimaryKeySQL(PrimaryKey pk) {\n+        String[] sql = super.getAddPrimaryKeySQL(pk);\n+\n+        // mysql requires that a column be declared NOT NULL before\n+        // it can be made a primary key.\n+        Column[] cols = pk.getColumns();\n+        String[] ret = new String[cols.length + sql.length];\n+        for (int i = 0; i < cols.length; i++) {\n+            ret[i] = \"ALTER TABLE \" + getFullName(cols[i].getTable(), false)\n+                + \" CHANGE \" + cols[i].getName()\n+                + \" \" + cols[i].getName() // name twice\n+                + \" \" + getTypeName(cols[i]) + \" NOT NULL\";\n+        }\n+\n+        System.arraycopy(sql, 0, ret, cols.length, sql.length);\n+        return ret;\n+    }\n+\n+    protected String getForeignKeyConstraintSQL(ForeignKey fk) {\n+        // mysql does not support composite foreign keys\n+        if (fk.getColumns().length > 1)\n+            return null;\n+        return super.getForeignKeyConstraintSQL(fk);\n+    }\n+    \n+    public String[] getDeleteTableContentsSQL(Table[] tables) {\n+        // mysql >= 4 supports more-optimal delete syntax\n+        if (!optimizeMultiTableDeletes)\n+            return super.getDeleteTableContentsSQL(tables);\n+        else {\n+            StringBuffer buf = new StringBuffer(tables.length * 8);\n+            buf.append(\"DELETE FROM \");\n+            for (int i = 0; i < tables.length; i++) {\n+                buf.append(tables[i].getFullName());\n+                if (i < tables.length - 1)\n+                    buf.append(\", \");\n+            }\n+            return new String[] { buf.toString() };\n+        }\n+    }\n+\n+    protected void appendSelectRange(SQLBuffer buf, long start, long end,\n+        boolean subselect) {\n+        buf.append(\" LIMIT \").appendValue(start).append(\", \");\n+        if (end == Long.MAX_VALUE)\n+            buf.appendValue(Long.MAX_VALUE);\n+        else\n+            buf.appendValue(end - start);\n+    }\n+\n+    protected Column newColumn(ResultSet colMeta)\n+        throws SQLException {\n+        Column col = super.newColumn(colMeta);\n+        if (col.isNotNull() && \"0\".equals(col.getDefaultString()))\n+            col.setDefaultString(null);\n+        return col;\n+    }\n+\n+    public Object getBlobObject(ResultSet rs, int column, JDBCStore store)\n+        throws SQLException {\n+        // if the user has set a get-blob strategy explicitly or the driver\n+        // does not automatically deserialize, delegate to super\n+        if (useGetBytesForBlobs || useGetObjectForBlobs\n+            || !driverDeserializesBlobs)\n+            return super.getBlobObject(rs, column, store);\n+\n+        // most mysql drivers deserialize on getObject\n+        return rs.getObject(column);\n+    }\n+\n+    public int getPreferredType(int type) {\n+        if (type == Types.CLOB && !useClobs)\n+            return Types.LONGVARCHAR;\n+        return super.getPreferredType(type);\n+    }\n+}"},{"sha":"2714a84482e17fc4b69d6b9b2f1be8a467bd6987","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","status":"added","additions":1127,"deletions":0,"changes":1127,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,1127 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.security.AccessController;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Index;\n+import org.apache.openjpa.jdbc.schema.PrimaryKey;\n+import org.apache.openjpa.jdbc.schema.Sequence;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.lib.jdbc.DelegatingDatabaseMetaData;\n+import org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement;\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.StoreException;\n+import org.apache.openjpa.util.UserException;\n+\n+import serp.util.Numbers;\n+\n+/**\n+ * Dictionary for Oracle.\n+ */\n+public class OracleDictionary\n+    extends DBDictionary {\n+\n+    public static final String SELECT_HINT = \"openjpa.hint.OracleSelectHint\";\n+    public static final String VENDOR_ORACLE = \"oracle\";\n+\n+    private static final int BEHAVE_OTHER = 0;\n+    private static final int BEHAVE_ORACLE = 1;\n+    private static final int BEHAVE_DATADIRECT31 = 2;\n+\n+    private static Blob EMPTY_BLOB = null;\n+    private static Clob EMPTY_CLOB = null;\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (OracleDictionary.class);\n+\n+    /**\n+     * If true, then simulate auto-assigned values in Oracle by\n+     * using a trigger that inserts a sequence value into the\n+     * primary key value when a row is inserted.\n+     */\n+    public boolean useTriggersForAutoAssign = false;\n+\n+    /**\n+     * The global sequence name to use for autoassign simulation.\n+     */\n+    public String autoAssignSequenceName = null;\n+\n+    /**\n+     * Flag to use OpenJPA 0.3 style naming for auto assign sequence name and\n+     * trigger name for backwards compatibility.\n+     */\n+    public boolean openjpa3GeneratedKeyNames = false;\n+\n+    /**\n+     * If true, then OpenJPA will attempt to use the special\n+     * OraclePreparedStatement.setFormOfUse method to\n+     * configure statements that it detects are operating on unicode fields.\n+     */\n+    public boolean useSetFormOfUseForUnicode = true;\n+\n+    // some oracle drivers have problems with select for update; warn the\n+    // first time locking is attempted\n+    private boolean _checkedUpdateBug = false;\n+    private boolean _warnedCharColumn = false;\n+    private boolean _warnedNcharColumn = false;\n+    private int _driverBehavior = -1;\n+\n+    // cache lob methods\n+    private Method _putBytes = null;\n+    private Method _putString = null;\n+    private Method _putChars = null;\n+    \n+    // batch limit\n+    private int defaultBatchLimit = 100;\n+\n+    public OracleDictionary() {\n+        platform = \"Oracle\";\n+        validationSQL = \"SELECT SYSDATE FROM DUAL\";\n+        nextSequenceQuery = \"SELECT {0}.NEXTVAL FROM DUAL\";\n+        stringLengthFunction = \"LENGTH({0})\";\n+        joinSyntax = SYNTAX_DATABASE;\n+        maxTableNameLength = 30;\n+        maxColumnNameLength = 30;\n+        maxIndexNameLength = 30;\n+        maxConstraintNameLength = 30;\n+        maxEmbeddedBlobSize = 4000;\n+        maxEmbeddedClobSize = 4000;\n+        inClauseLimit = 1000;\n+\n+        supportsDeferredConstraints = true;\n+        supportsLockingWithDistinctClause = false;\n+        supportsSelectStartIndex = true;\n+        supportsSelectEndIndex = true;\n+\n+        systemSchemaSet.addAll(Arrays.asList(new String[]{\n+            \"CTXSYS\", \"MDSYS\", \"SYS\", \"SYSTEM\", \"WKSYS\", \"WMSYS\", \"XDB\",\n+        }));\n+\n+        supportsXMLColumn = true;\n+        xmlTypeName = \"XMLType\";\n+        bigintTypeName = \"NUMBER{0}\";\n+        bitTypeName = \"NUMBER{0}\";\n+        decimalTypeName = \"NUMBER{0}\";\n+        doubleTypeName = \"NUMBER{0}\";\n+        integerTypeName = \"NUMBER{0}\";\n+        numericTypeName = \"NUMBER{0}\";\n+        smallintTypeName = \"NUMBER{0}\";\n+        tinyintTypeName = \"NUMBER{0}\";\n+        longVarcharTypeName = \"LONG\";\n+        binaryTypeName = \"BLOB\";\n+        varbinaryTypeName = \"BLOB\";\n+        longVarbinaryTypeName = \"BLOB\";\n+        timeTypeName = \"DATE\";\n+        varcharTypeName = \"VARCHAR2{0}\";\n+        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\n+            \"LONG RAW\", \"RAW\", \"LONG\", \"REF\",\n+        }));\n+        reservedWordSet.addAll(Arrays.asList(new String[]{\n+            \"ACCESS\", \"AUDIT\", \"CLUSTER\", \"COMMENT\", \"COMPRESS\", \"EXCLUSIVE\",\n+            \"FILE\", \"IDENTIFIED\", \"INCREMENT\", \"INDEX\", \"INITIAL\", \"LOCK\",\n+            \"LONG\", \"MAXEXTENTS\", \"MINUS\", \"MODE\", \"NOAUDIT\", \"NOCOMPRESS\",\n+            \"NOWAIT\", \"OFFLINE\", \"ONLINE\", \"PCTFREE\", \"ROW\",\n+        }));\n+\n+        substringFunctionName = \"SUBSTR\";\n+        super.setBatchLimit(defaultBatchLimit);\n+        selectWordSet.add(\"WITH\");\n+        reportsSuccessNoInfoOnBatchUpdates = true;\n+    }\n+\n+    public void endConfiguration() {\n+        super.endConfiguration();\n+        if (useTriggersForAutoAssign)\n+            supportsAutoAssign = true;\n+    }\n+\n+    public void connectedConfiguration(Connection conn)\n+        throws SQLException {\n+        super.connectedConfiguration(conn);\n+        if (driverVendor == null) {\n+            DatabaseMetaData meta = conn.getMetaData();\n+            String url = (meta.getURL() == null) ? \"\" : meta.getURL();\n+            String driverName = meta.getDriverName();\n+            String metadataClassName;\n+            if (meta instanceof DelegatingDatabaseMetaData)\n+                metadataClassName = ((DelegatingDatabaseMetaData) meta).\n+                    getInnermostDelegate().getClass().getName();\n+            else\n+                metadataClassName = meta.getClass().getName();\n+\n+            // check both the driver class name and the URL for known patterns\n+            if (metadataClassName.startsWith(\"oracle.\")\n+                || url.indexOf(\"jdbc:oracle:\") != -1\n+                || \"Oracle JDBC driver\".equals(driverName)) {\n+                driverVendor = VENDOR_ORACLE + meta.getDriverMajorVersion()\n+                    + meta.getDriverMinorVersion();\n+\n+                String productVersion = meta.getDatabaseProductVersion()\n+                    .split(\"Release \",0)[1].split(\"\\\\.\",0)[0];\n+                int release = Integer.parseInt(productVersion);\n+                \n+                // warn sql92\n+                if (release <= 8) {\n+                    if (joinSyntax == SYNTAX_SQL92 && log.isWarnEnabled())\n+                        log.warn(_loc.get(\"oracle-syntax\"));\n+                    joinSyntax = SYNTAX_DATABASE;\n+                    dateTypeName = \"DATE\"; // added oracle 9\n+                    timestampTypeName = \"DATE\"; // added oracle 9\n+                    supportsXMLColumn = false;\n+                }\n+                    // select of an xml column requires \".getStringVal()\"\n+                    // suffix. eg. t0.xmlcol.getStringVal()\n+                    getStringVal = \".getStringVal()\";\n+            } else if (metadataClassName.startsWith(\"com.ddtek.\")\n+                || url.indexOf(\"jdbc:datadirect:oracle:\") != -1\n+                || \"Oracle\".equals(driverName)) {\n+                driverVendor = VENDOR_DATADIRECT + meta.getDriverMajorVersion()\n+                    + meta.getDriverMinorVersion();\n+            } else\n+                driverVendor = VENDOR_OTHER;\n+        }\n+        cacheDriverBehavior(driverVendor);\n+    }\n+\n+    /**\n+     * Cache constant for drivers with behaviors we have to deal with.\n+     */\n+    private void cacheDriverBehavior(String driverVendor) {\n+        if (_driverBehavior != -1)\n+            return;\n+\n+        driverVendor = driverVendor.toLowerCase();\n+        if (driverVendor.startsWith(VENDOR_ORACLE))\n+            _driverBehavior = BEHAVE_ORACLE;\n+        else if (driverVendor.equals(VENDOR_DATADIRECT + \"30\")\n+            || driverVendor.equals(VENDOR_DATADIRECT + \"31\"))\n+            _driverBehavior = BEHAVE_DATADIRECT31;\n+        else\n+            _driverBehavior = BEHAVE_OTHER;\n+    }\n+\n+    /**\n+     * Ensure that the driver vendor has been set, and if not, set it now.\n+     */\n+    public void ensureDriverVendor() {\n+        if (driverVendor != null) {\n+            cacheDriverBehavior(driverVendor);\n+            return;\n+        }\n+\n+        if (log.isInfoEnabled())\n+            log.info(_loc.get(\"oracle-connecting-for-driver\"));\n+        Connection conn = null;\n+        try {\n+            conn = conf.getDataSource2(null).getConnection();\n+            connectedConfiguration(conn);\n+        } catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, this);\n+        } finally {\n+            if (conn != null)\n+                try {\n+                    conn.close();\n+                } catch (SQLException se) {\n+                }\n+        }\n+    }\n+\n+    public boolean supportsLocking(Select sel) {\n+        if (!super.supportsLocking(sel))\n+            return false;\n+        return !requiresSubselectForRange(sel.getStartIndex(),\n+            sel.getEndIndex(), sel.isDistinct(), sel.getOrdering());\n+    }\n+\n+    protected SQLBuffer getSelects(Select sel, boolean distinctIdentifiers,\n+        boolean forUpdate) {\n+        // if range doesn't require a subselect can use super\n+        if (!requiresSubselectForRange(sel.getStartIndex(),\n+            sel.getEndIndex(), sel.isDistinct(), sel.getOrdering()))\n+            return super.getSelects(sel, distinctIdentifiers, forUpdate);\n+\n+        // if there are no joins involved or we're using a from select so\n+        // that all cols already have unique aliases, can use super\n+        if (sel.getFromSelect() != null || sel.getTableAliases().size() < 2)\n+            return super.getSelects(sel, distinctIdentifiers, forUpdate);\n+\n+        // since none of the conditions above were met, we're dealing with\n+        // a select that uses joins and requires subselects to select the\n+        // proper range; alias all column values so that they are unique within\n+        // the subselect\n+        SQLBuffer selectSQL = new SQLBuffer(this);\n+        List aliases;\n+        if (distinctIdentifiers)\n+            aliases = sel.getIdentifierAliases();\n+        else\n+            aliases = sel.getSelectAliases();\n+\n+        Object alias;\n+        int i = 0;\n+        for (Iterator itr = aliases.iterator(); itr.hasNext(); i++) {\n+            alias = itr.next();\n+            if (alias instanceof SQLBuffer)\n+                selectSQL.append((SQLBuffer) alias);\n+            else\n+                selectSQL.append(alias.toString());\n+            selectSQL.append(\" AS c\").append(String.valueOf(i));\n+            if (itr.hasNext())\n+                selectSQL.append(\", \");\n+        }\n+        return selectSQL;\n+    }\n+\n+    public boolean canOuterJoin(int syntax, ForeignKey fk) {\n+        if (!super.canOuterJoin(syntax, fk))\n+            return false;\n+        if (fk != null && syntax == SYNTAX_DATABASE) {\n+            if (fk.getConstants().length > 0)\n+                return false;\n+            if (fk.getPrimaryKeyConstants().length > 0)\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    public SQLBuffer toNativeJoin(Join join) {\n+        if (join.getType() != Join.TYPE_OUTER)\n+            return toTraditionalJoin(join);\n+\n+        ForeignKey fk = join.getForeignKey();\n+        if (fk == null)\n+            return null;\n+\n+        boolean inverse = join.isForeignKeyInversed();\n+        Column[] from = (inverse) ? fk.getPrimaryKeyColumns()\n+            : fk.getColumns();\n+        Column[] to = (inverse) ? fk.getColumns()\n+            : fk.getPrimaryKeyColumns();\n+\n+        // do column joins\n+        SQLBuffer buf = new SQLBuffer(this);\n+        int count = 0;\n+        for (int i = 0; i < from.length; i++, count++) {\n+            if (count > 0)\n+                buf.append(\" AND \");\n+            buf.append(join.getAlias1()).append(\".\").append(from[i]);\n+            buf.append(\" = \");\n+            buf.append(join.getAlias2()).append(\".\").append(to[i]);\n+            buf.append(\"(+)\");\n+        }\n+\n+        // check constant joins\n+        if (fk.getConstantColumns().length > 0)\n+            throw new StoreException(_loc.get(\"oracle-constant\",\n+                join.getTable1(), join.getTable2())).setFatal(true);\n+\n+        if (fk.getConstantPrimaryKeyColumns().length > 0)\n+            throw new StoreException(_loc.get(\"oracle-constant\",\n+                join.getTable1(), join.getTable2())).setFatal(true);\n+        return buf;\n+    }\n+\n+    public SQLBuffer toSelect(SQLBuffer select, JDBCFetchConfiguration fetch,\n+        SQLBuffer tables, SQLBuffer where, SQLBuffer group,\n+        SQLBuffer having, SQLBuffer order,\n+        boolean distinct, boolean forUpdate, long start, long end,\n+        Select sel) {\n+        if (!_checkedUpdateBug) {\n+            ensureDriverVendor();\n+            if (forUpdate && _driverBehavior == BEHAVE_DATADIRECT31)\n+                log.warn(_loc.get(\"dd-lock-bug\"));\n+            _checkedUpdateBug = true;\n+        }\n+\n+        // if no range, use standard select\n+        if (start == 0 && end == Long.MAX_VALUE)\n+            return super.toSelect(select, fetch, tables, where, group, having,\n+                order, distinct, forUpdate, 0, Long.MAX_VALUE, sel);\n+\n+        // if no skip, ordering, or distinct can use rownum directly\n+        SQLBuffer buf = new SQLBuffer(this);\n+        if (!requiresSubselectForRange(start, end, distinct, order)) {\n+            if (where != null && !where.isEmpty())\n+                buf.append(where).append(\" AND \");\n+            buf.append(\"ROWNUM <= \").appendValue(end);\n+            return super.toSelect(select, fetch, tables, buf, group, having,\n+                order, distinct, forUpdate, 0, Long.MAX_VALUE, sel);\n+        }\n+\n+        // if there is ordering, skip, or distinct we have to use subselects\n+        SQLBuffer newsel = super.toSelect(select, fetch, tables, where,\n+            group, having, order, distinct, forUpdate, 0, Long.MAX_VALUE,\n+            sel);\n+\n+        // if no skip, can use single nested subselect\n+        if (start == 0) {\n+            buf.append(getSelectOperation(fetch) + \" * FROM (\");\n+            buf.append(newsel);\n+            buf.append(\") WHERE ROWNUM <= \").appendValue(end);\n+            return buf;\n+        }\n+\n+        // with a skip, we have to use a double-nested subselect to put\n+        // where conditions on the rownum\n+        buf.append(getSelectOperation(fetch)\n+            + \" * FROM (SELECT r.*, ROWNUM RNUM FROM (\");\n+        buf.append(newsel);\n+        buf.append(\") r\");\n+        if (end != Long.MAX_VALUE)\n+            buf.append(\" WHERE ROWNUM <= \").appendValue(end);\n+        buf.append(\") WHERE RNUM > \").appendValue(start);\n+        return buf;\n+    }\n+\n+    /**\n+     * Return true if the select with the given parameters needs a\n+     * subselect to apply a range.\n+     */\n+    private boolean requiresSubselectForRange(long start, long end,\n+        boolean distinct, SQLBuffer order) {\n+        if (start == 0 && end == Long.MAX_VALUE)\n+            return false;\n+        return start != 0 || distinct || (order != null && !order.isEmpty());\n+    }\n+\n+    /**\n+     * Check to see if we have set the {@link #SELECT_HINT} in the\n+     * fetch configuraiton, and if so, append the Orache hint after the\n+     * \"SELECT\" part of the query.\n+     */\n+    public String getSelectOperation(JDBCFetchConfiguration fetch) {\n+        Object hint = fetch == null ? null : fetch.getHint(SELECT_HINT);\n+        String select = \"SELECT\";\n+        if (hint != null)\n+            select += \" \" + hint;\n+        return select;\n+    }\n+\n+    public void setString(PreparedStatement stmnt, int idx, String val,\n+        Column col)\n+        throws SQLException {\n+        // oracle NCHAR/NVARCHAR/NCLOB unicode columns require some\n+        // special handling to configure them correctly; see:\n+        // http://www.oracle.com/technology/sample_code/tech/java/\n+        // sqlj_jdbc/files/9i_jdbc/NCHARsupport4UnicodeSample/Readme.html\n+        String typeName = (col == null) ? null : col.getTypeName();\n+        if (useSetFormOfUseForUnicode && typeName != null &&\n+            (typeName.toLowerCase().startsWith(\"nvarchar\") ||\n+                typeName.toLowerCase().startsWith(\"nchar\") ||\n+                typeName.toLowerCase().startsWith(\"nclob\"))) {\n+            Statement inner = stmnt;\n+            if (inner instanceof DelegatingPreparedStatement)\n+                inner = ((DelegatingPreparedStatement) inner).\n+                    getInnermostDelegate();\n+            if (isOraclePreparedStatement(inner)) {\n+                try {\n+                    inner.getClass().getMethod(\"setFormOfUse\",\n+                        new Class[]{ int.class, short.class }).\n+                        invoke(inner,\n+                            new Object[]{\n+                                new Integer(idx),\n+                                Class.forName\n+                                    (\"oracle.jdbc.OraclePreparedStatement\").\n+                                    getField(\"FORM_NCHAR\").get(null)\n+                            });\n+                } catch (Exception e) {\n+                    log.warn(e);\n+                }\n+            } else if (!_warnedNcharColumn && log.isWarnEnabled()) {\n+                _warnedNcharColumn = true;\n+                log.warn(_loc.get(\"unconfigured-nchar-cols\"));\n+            }\n+        }\n+\n+        // call setFixedCHAR for fixed width character columns to get padding\n+        // semantics\n+        if (col != null && col.getType() == Types.CHAR\n+            && val != null && val.length() != col.getSize()) {\n+            Statement inner = stmnt;\n+            if (inner instanceof DelegatingPreparedStatement)\n+                inner = ((DelegatingPreparedStatement) inner).\n+                    getInnermostDelegate();\n+            if (isOraclePreparedStatement(inner)) {\n+                try {\n+                    inner.getClass().getMethod(\"setFixedCHAR\",\n+                        new Class[]{ int.class, String.class }).\n+                        invoke(inner, new Object[]{ new Integer(idx), val });\n+                    return;\n+                } catch (Exception e) {\n+                    log.warn(e);\n+                }\n+            }\n+\n+            if (!_warnedCharColumn && log.isWarnEnabled()) {\n+                _warnedCharColumn = true;\n+                log.warn(_loc.get(\"unpadded-char-cols\"));\n+            }\n+        }\n+        super.setString(stmnt, idx, val, col);\n+    }\n+\n+    public void setNull(PreparedStatement stmnt, int idx, int colType,\n+        Column col)\n+        throws SQLException {\n+        if ((colType == Types.CLOB || colType == Types.BLOB) && col.isNotNull())\n+            throw new UserException(_loc.get(\"null-blob-in-not-nullable\", col\n+                .getFullName()));\n+        if (colType == Types.BLOB && _driverBehavior == BEHAVE_ORACLE)\n+            stmnt.setBlob(idx, getEmptyBlob());\n+        else if (colType == Types.CLOB && _driverBehavior == BEHAVE_ORACLE\n+            && !col.isXML())\n+            stmnt.setClob(idx, getEmptyClob());\n+        else if ((colType == Types.STRUCT || colType == Types.OTHER)\n+            && col != null && col.getTypeName() != null)\n+            stmnt.setNull(idx, Types.STRUCT, col.getTypeName());\n+            // some versions of the Oracle JDBC driver will fail if calling\n+            // setNull with DATE; see bug #1171\n+        else if (colType == Types.DATE)\n+            super.setNull(stmnt, idx, Types.TIMESTAMP, col);\n+        // the Oracle driver does not support Types.OTHER with setNull\n+        else if (colType == Types.OTHER || col.isXML())\n+            super.setNull(stmnt, idx, Types.NULL, col);\n+        else\n+            super.setNull(stmnt, idx, colType, col);\n+    }\n+\n+    public String getClobString(ResultSet rs, int column)\n+        throws SQLException {\n+        if (_driverBehavior != BEHAVE_ORACLE)\n+            return super.getClobString(rs, column);\n+\n+        Clob clob = getClob(rs, column);\n+        if (clob == null)\n+            return null;\n+        if (clob.getClass().getName().equals(\"oracle.sql.CLOB\")) {\n+            try {\n+                if (((Boolean) Class.forName(\"oracle.sql.CLOB\").\n+                    getMethod(\"isEmptyLob\", new Class[0]).\n+                    invoke(clob, new Object[0])).\n+                    booleanValue())\n+                    return null;\n+            } catch (Exception e) {\n+                // possibly different version of the driver\n+            }\n+        }\n+        if (clob.length() == 0)\n+            return null;\n+\n+        // unlikely that we'll have strings over 4 billion chars\n+        return clob.getSubString(1, (int) clob.length());\n+    }\n+\n+    public Timestamp getTimestamp(ResultSet rs, int column, Calendar cal)\n+        throws SQLException {\n+        if (cal == null) {\n+            try {\n+                return super.getTimestamp(rs, column, cal);\n+            } catch (ArrayIndexOutOfBoundsException ae) {\n+                // CR295604: issue a warning this this bug can be gotten\n+                // around with SupportsTimestampNanos=false\n+                log.warn(_loc.get(\"oracle-timestamp-bug\"), ae);\n+                throw ae;\n+            }\n+        }\n+\n+        // handle Oracle bug where nanos not returned from call with Calendar\n+        // parameter\n+        Timestamp ts = rs.getTimestamp(column, cal);\n+        if (ts != null && ts.getNanos() == 0)\n+            ts.setNanos(rs.getTimestamp(column).getNanos());\n+        return ts;\n+    }\n+\n+    public Object getObject(ResultSet rs, int column, Map map)\n+        throws SQLException {\n+        // recent oracle drivers return oracle-specific types for timestamps\n+        // and dates\n+        Object obj = super.getObject(rs, column, map);\n+        if (obj == null)\n+            return null;\n+        if (\"oracle.sql.DATE\".equals(obj.getClass().getName()))\n+            obj = convertFromOracleType(obj, \"dateValue\");\n+        else if (\"oracle.sql.TIMESTAMP\".equals(obj.getClass().getName()))\n+            obj = convertFromOracleType(obj, \"timestampValue\");\n+        return obj;\n+    }\n+\n+    /**\n+     * Convert an object from its proprietary Oracle type to the standard\n+     * Java type.\n+     */\n+    private static Object convertFromOracleType(Object obj,\n+        String convertMethod)\n+        throws SQLException {\n+        try {\n+            Method m = obj.getClass().getMethod(convertMethod, (Class[]) null);\n+            return m.invoke(obj, (Object[]) null);\n+        } catch (Throwable t) {\n+            if (t instanceof InvocationTargetException)\n+                t = ((InvocationTargetException) t).getTargetException();\n+            if (t instanceof SQLException)\n+                throw(SQLException) t;\n+            throw new SQLException(t.getMessage());\n+        }\n+    }\n+\n+    public Column[] getColumns(DatabaseMetaData meta, String catalog,\n+        String schemaName, String tableName, String columnName, Connection conn)\n+        throws SQLException {\n+        Column[] cols = super.getColumns(meta, catalog, schemaName, tableName,\n+            columnName, conn);\n+\n+        for (int i = 0; cols != null && i < cols.length; i++) {\n+            if (cols[i].getTypeName() == null)\n+                continue;\n+            if (cols[i].getTypeName().toUpperCase().startsWith(\"TIMESTAMP\"))\n+                cols[i].setType(Types.TIMESTAMP);\n+            else if (\"BLOB\".equalsIgnoreCase(cols[i].getTypeName()))\n+                cols[i].setType(Types.BLOB);\n+            else if (\"CLOB\".equalsIgnoreCase(cols[i].getTypeName())\n+                || \"NCLOB\".equalsIgnoreCase(cols[i].getTypeName()))\n+                cols[i].setType(Types.CLOB);\n+            else if (\"FLOAT\".equalsIgnoreCase(cols[i].getTypeName()))\n+                cols[i].setType(Types.FLOAT);\n+            else if (\"NVARCHAR\".equalsIgnoreCase(cols[i].getTypeName()))\n+                cols[i].setType(Types.VARCHAR);\n+            else if (\"NCHAR\".equalsIgnoreCase(cols[i].getTypeName()))\n+                cols[i].setType(Types.CHAR);\n+        }\n+        return cols;\n+    }\n+\n+    public PrimaryKey[] getPrimaryKeys(DatabaseMetaData meta,\n+        String catalog, String schemaName, String tableName, Connection conn)\n+        throws SQLException {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"SELECT t0.OWNER AS TABLE_SCHEM, \").\n+            append(\"t0.TABLE_NAME AS TABLE_NAME, \").\n+            append(\"t0.COLUMN_NAME AS COLUMN_NAME, \").\n+            append(\"t0.CONSTRAINT_NAME AS PK_NAME \").\n+            append(\"FROM ALL_CONS_COLUMNS t0, ALL_CONSTRAINTS t1 \").\n+            append(\"WHERE t0.OWNER = t1.OWNER \").\n+            append(\"AND t0.CONSTRAINT_NAME = t1.CONSTRAINT_NAME \").\n+            append(\"AND t1.CONSTRAINT_TYPE = 'P'\");\n+        if (schemaName != null)\n+            buf.append(\" AND t0.OWNER = ?\");\n+        if (tableName != null)\n+            buf.append(\" AND t0.TABLE_NAME = ?\");\n+\n+        PreparedStatement stmnt = conn.prepareStatement(buf.toString());\n+        ResultSet rs = null;\n+        try {\n+            int idx = 1;\n+            if (schemaName != null)\n+                setString(stmnt, idx++, schemaName.toUpperCase(), null);\n+            if (tableName != null)\n+                setString(stmnt, idx++, tableName.toUpperCase(), null);\n+\n+            rs = stmnt.executeQuery();\n+            List pkList = new ArrayList();\n+            while (rs != null && rs.next())\n+                pkList.add(newPrimaryKey(rs));\n+            return (PrimaryKey[]) pkList.toArray\n+                (new PrimaryKey[pkList.size()]);\n+        } finally {\n+            if (rs != null)\n+                try {\n+                    rs.close();\n+                } catch (Exception e) {\n+                }\n+            try {\n+                stmnt.close();\n+            } catch (Exception e) {\n+            }\n+        }\n+    }\n+\n+    public Index[] getIndexInfo(DatabaseMetaData meta, String catalog,\n+        String schemaName, String tableName, boolean unique, boolean approx,\n+        Connection conn)\n+        throws SQLException {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"SELECT t0.INDEX_OWNER AS TABLE_SCHEM, \").\n+            append(\"t0.TABLE_NAME AS TABLE_NAME, \").\n+            append(\"DECODE(t1.UNIQUENESS, 'UNIQUE', 0, 'NONUNIQUE', 1) \").\n+            append(\"AS NON_UNIQUE, \").\n+            append(\"t0.INDEX_NAME AS INDEX_NAME, \").\n+            append(\"t0.COLUMN_NAME AS COLUMN_NAME \").\n+            append(\"FROM ALL_IND_COLUMNS t0, ALL_INDEXES t1 \").\n+            append(\"WHERE t0.INDEX_OWNER = t1.OWNER \").\n+            append(\"AND t0.INDEX_NAME = t1.INDEX_NAME\");\n+        if (schemaName != null)\n+            buf.append(\" AND t0.TABLE_OWNER = ?\");\n+        if (tableName != null)\n+            buf.append(\" AND t0.TABLE_NAME = ?\");\n+\n+        PreparedStatement stmnt = conn.prepareStatement(buf.toString());\n+        ResultSet rs = null;\n+        try {\n+            int idx = 1;\n+            if (schemaName != null)\n+                setString(stmnt, idx++, schemaName.toUpperCase(), null);\n+            if (tableName != null)\n+                setString(stmnt, idx++, tableName.toUpperCase(), null);\n+\n+            rs = stmnt.executeQuery();\n+            List idxList = new ArrayList();\n+            while (rs != null && rs.next())\n+                idxList.add(newIndex(rs));\n+            return (Index[]) idxList.toArray(new Index[idxList.size()]);\n+        } finally {\n+            if (rs != null)\n+                try {\n+                    rs.close();\n+                } catch (Exception e) {\n+                }\n+            try {\n+                stmnt.close();\n+            } catch (Exception e) {\n+            }\n+        }\n+    }\n+\n+    public ForeignKey[] getImportedKeys(DatabaseMetaData meta, String catalog,\n+        String schemaName, String tableName, Connection conn)\n+        throws SQLException {\n+        StringBuffer delAction = new StringBuffer(\"DECODE(t1.DELETE_RULE\").\n+            append(\", 'NO ACTION', \").append(meta.importedKeyNoAction).\n+            append(\", 'RESTRICT', \").append(meta.importedKeyRestrict).\n+            append(\", 'CASCADE', \").append(meta.importedKeyCascade).\n+            append(\", 'SET NULL', \").append(meta.importedKeySetNull).\n+            append(\", 'SET DEFAULT', \").append(meta.importedKeySetDefault).\n+            append(\")\");\n+\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"SELECT t2.OWNER AS PKTABLE_SCHEM, \").\n+            append(\"t2.TABLE_NAME AS PKTABLE_NAME, \").\n+            append(\"t2.COLUMN_NAME AS PKCOLUMN_NAME, \").\n+            append(\"t0.OWNER AS FKTABLE_SCHEM, \").\n+            append(\"t0.TABLE_NAME AS FKTABLE_NAME, \").\n+            append(\"t0.COLUMN_NAME AS FKCOLUMN_NAME, \").\n+            append(\"t0.POSITION AS KEY_SEQ, \").\n+            append(delAction).append(\" AS DELETE_RULE, \").\n+            append(\"t0.CONSTRAINT_NAME AS FK_NAME, \").\n+            append(\"DECODE(t1.DEFERRED, 'DEFERRED', \").\n+            append(meta.importedKeyInitiallyDeferred).\n+            append(\", 'IMMEDIATE', \").\n+            append(meta.importedKeyInitiallyImmediate).\n+            append(\") AS DEFERRABILITY \").\n+            append(\"FROM ALL_CONS_COLUMNS t0, ALL_CONSTRAINTS t1, \").\n+            append(\"ALL_CONS_COLUMNS t2 \").\n+            append(\"WHERE t0.OWNER = t1.OWNER \").\n+            append(\"AND t0.CONSTRAINT_NAME = t1.CONSTRAINT_NAME \").\n+            append(\"AND t1.CONSTRAINT_TYPE = 'R' \").\n+            append(\"AND t1.R_OWNER = t2.OWNER \").\n+            append(\"AND t1.R_CONSTRAINT_NAME = t2.CONSTRAINT_NAME \").\n+            append(\"AND t0.POSITION = t2.POSITION\");\n+        if (schemaName != null)\n+            buf.append(\" AND t0.OWNER = ?\");\n+        if (tableName != null)\n+            buf.append(\" AND t0.TABLE_NAME = ?\");\n+        buf.append(\" ORDER BY t2.OWNER, t2.TABLE_NAME, t0.POSITION\");\n+\n+        PreparedStatement stmnt = conn.prepareStatement(buf.toString());\n+        ResultSet rs = null;\n+        try {\n+            int idx = 1;\n+            if (schemaName != null)\n+                setString(stmnt, idx++, schemaName.toUpperCase(), null);\n+            if (tableName != null)\n+                setString(stmnt, idx++, tableName.toUpperCase(), null);\n+\n+            rs = stmnt.executeQuery();\n+            List fkList = new ArrayList();\n+            while (rs != null && rs.next())\n+                fkList.add(newForeignKey(rs));\n+            return (ForeignKey[]) fkList.toArray\n+                (new ForeignKey[fkList.size()]);\n+        } finally {\n+            if (rs != null)\n+                try {\n+                    rs.close();\n+                } catch (Exception e) {\n+                }\n+            try {\n+                stmnt.close();\n+            } catch (Exception e) {\n+            }\n+        }\n+    }\n+\n+    public String[] getCreateTableSQL(Table table) {\n+        // only override if we are simulating auto-incremenet with triggers\n+        String[] create = super.getCreateTableSQL(table);\n+        if (!useTriggersForAutoAssign)\n+            return create;\n+\n+        Column[] cols = table.getColumns();\n+        List seqs = null;\n+        String seq, trig;\n+        for (int i = 0; cols != null && i < cols.length; i++) {\n+            if (!cols[i].isAutoAssigned())\n+                continue;\n+            if (seqs == null)\n+                seqs = new ArrayList(4);\n+\n+            seq = autoAssignSequenceName;\n+            if (seq == null) {\n+                if (openjpa3GeneratedKeyNames)\n+                    seq = getOpenJPA3GeneratedKeySequenceName(cols[i]);\n+                else\n+                    seq = getGeneratedKeySequenceName(cols[i]);\n+                seqs.add(\"CREATE SEQUENCE \" + seq + \" START WITH 1\");\n+            }\n+            if (openjpa3GeneratedKeyNames)\n+                trig = getOpenJPA3GeneratedKeyTriggerName(cols[i]);\n+            else\n+                trig = getGeneratedKeyTriggerName(cols[i]);\n+\n+            // create the trigger that will insert new values into\n+            // the table whenever a row is created\n+            seqs.add(\"CREATE OR REPLACE TRIGGER \" + trig\n+                + \" BEFORE INSERT ON \" + table.getName()\n+                + \" FOR EACH ROW BEGIN SELECT \" + seq + \".nextval INTO \"\n+                + \":new.\" + cols[i].getName() + \" FROM DUAL; \"\n+                + \"END \" + trig + \";\");\n+        }\n+        if (seqs == null)\n+            return create;\n+\n+        // combine create table sql and create seqences sql\n+        String[] sql = new String[create.length + seqs.size()];\n+        System.arraycopy(create, 0, sql, 0, create.length);\n+        for (int i = 0; i < seqs.size(); i++)\n+            sql[create.length + i] = (String) seqs.get(i);\n+        return sql;\n+    }\n+\n+    public String[] getCreateSequenceSQL(Sequence seq) {\n+        String[] sql = super.getCreateSequenceSQL(seq);\n+        if (seq.getAllocate() > 1)\n+            sql[0] += \" CACHE \" + seq.getAllocate();\n+        return sql;\n+    }\n+\n+    protected String getSequencesSQL(String schemaName, String sequenceName) {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"SELECT SEQUENCE_OWNER AS SEQUENCE_SCHEMA, \").\n+            append(\"SEQUENCE_NAME FROM ALL_SEQUENCES\");\n+        if (schemaName != null || sequenceName != null)\n+            buf.append(\" WHERE \");\n+        if (schemaName != null) {\n+            buf.append(\"SEQUENCE_OWNER = ?\");\n+            if (sequenceName != null)\n+                buf.append(\" AND \");\n+        }\n+        if (sequenceName != null)\n+            buf.append(\"SEQUENCE_NAME = ?\");\n+        return buf.toString();\n+    }\n+\n+    public boolean isSystemSequence(String name, String schema,\n+        boolean targetSchema) {\n+        if (super.isSystemSequence(name, schema, targetSchema))\n+            return true;\n+\n+        // filter out generated sequences used for auto-assign\n+        return (autoAssignSequenceName != null\n+            && name.equalsIgnoreCase(autoAssignSequenceName))\n+            || (autoAssignSequenceName == null\n+            && name.toUpperCase().startsWith(\"ST_\"));\n+    }\n+\n+    public Object getGeneratedKey(Column col, Connection conn)\n+        throws SQLException {\n+        if (!useTriggersForAutoAssign)\n+            return Numbers.valueOf(0L);\n+\n+        // if we simulate auto-assigned columns using triggers and\n+        // sequences, then return the current value of the sequence\n+        // from autoAssignSequenceName\n+        String seq = autoAssignSequenceName;\n+        if (seq == null && openjpa3GeneratedKeyNames)\n+            seq = getOpenJPA3GeneratedKeySequenceName(col);\n+        else if (seq == null)\n+            seq = getGeneratedKeySequenceName(col);\n+        PreparedStatement stmnt = conn.prepareStatement(\"SELECT \" + seq\n+            + \".currval FROM DUAL\");\n+        ResultSet rs = null;\n+        try {\n+            rs = stmnt.executeQuery();\n+            rs.next();\n+            return Numbers.valueOf(rs.getLong(1));\n+        } finally {\n+            if (rs != null)\n+                try { rs.close(); } catch (SQLException se) {}\n+            try { stmnt.close(); } catch (SQLException se) {}\n+        }\n+    }\n+\n+    /**\n+     * Trigger name for simulating auto-assign values on the given column.\n+     */\n+    protected String getGeneratedKeyTriggerName(Column col) {\n+        // replace trailing _SEQ with _TRG\n+        String seqName = getGeneratedKeySequenceName(col);\n+        return seqName.substring(0, seqName.length() - 3) + \"TRG\";\n+    }\n+\n+    /**\n+     * Returns a OpenJPA 3-compatible name for an auto-assign sequence.\n+     */\n+    protected String getOpenJPA3GeneratedKeySequenceName(Column col) {\n+        Table table = col.getTable();\n+        return makeNameValid(\"SEQ_\" + table.getName(), table.getSchema().\n+            getSchemaGroup(), maxTableNameLength, NAME_ANY);\n+    }\n+\n+    /**\n+     * Returns a OpenJPA 3-compatible name for an auto-assign trigger.\n+     */\n+    protected String getOpenJPA3GeneratedKeyTriggerName(Column col) {\n+        Table table = col.getTable();\n+        return makeNameValid(\"TRIG_\" + table.getName(), table.getSchema().\n+            getSchemaGroup(), maxTableNameLength, NAME_ANY);\n+    }\n+\n+    /**\n+     * Invoke Oracle's <code>putBytes</code> method on the given BLOB object.\n+     * Uses reflection in case the blob is wrapped in another\n+     * vendor-specific class; for example Weblogic wraps oracle thin driver\n+     * lobs in its own interfaces with the same methods.\n+     */\n+    public void putBytes(Object blob, byte[] data)\n+        throws SQLException {\n+        if (blob == null)\n+            return;\n+        if (_putBytes == null) {\n+            try {\n+                _putBytes = blob.getClass().getMethod(\"putBytes\",\n+                    new Class[]{ long.class, byte[].class });\n+            } catch (Exception e) {\n+                throw new StoreException(e);\n+            }\n+        }\n+        invokePutLobMethod(_putBytes, blob, data);\n+    }\n+\n+    /**\n+     * Invoke Oracle's <code>putString</code> method on the given CLOB object.\n+     * Uses reflection in case the clob is wrapped in another\n+     * vendor-specific class; for example Weblogic wraps oracle thin driver\n+     * lobs in its own interfaces with the same methods.\n+     */\n+    public void putString(Object clob, String data)\n+        throws SQLException {\n+        if (_putString == null) {\n+            try {\n+                _putString = clob.getClass().getMethod(\"putString\",\n+                    new Class[]{ long.class, String.class });\n+            } catch (Exception e) {\n+                throw new StoreException(e);\n+            }\n+        }\n+        invokePutLobMethod(_putString, clob, data);\n+    }\n+\n+    /**\n+     * Invoke Oracle's <code>putChars</code> method on the given CLOB\n+     * object. Uses reflection in case the clob is wrapped in another\n+     * vendor-specific class; for example Weblogic wraps oracle thin driver\n+     * lobs in its own interfaces with the same methods.\n+     */\n+    public void putChars(Object clob, char[] data)\n+        throws SQLException {\n+        if (_putChars == null) {\n+            try {\n+                _putChars = clob.getClass().getMethod(\"putChars\",\n+                    new Class[]{ long.class, char[].class });\n+            } catch (Exception e) {\n+                throw new StoreException(e);\n+            }\n+        }\n+        invokePutLobMethod(_putChars, clob, data);\n+    }\n+\n+    /**\n+     * Invoke the given LOB method on the given target with the given data.\n+     */\n+    private static void invokePutLobMethod(Method method, Object target,\n+        Object data)\n+        throws SQLException {\n+        try {\n+            method.invoke(target, new Object[]{ Numbers.valueOf(1L), data });\n+        } catch (InvocationTargetException ite) {\n+            Throwable t = ite.getTargetException();\n+            if (t instanceof SQLException)\n+                throw(SQLException) t;\n+            throw new StoreException(t);\n+        } catch (Exception e) {\n+            throw new StoreException(e);\n+        }\n+    }\n+\n+    private Clob getEmptyClob()\n+        throws SQLException {\n+        if (EMPTY_CLOB != null)\n+            return EMPTY_CLOB;\n+        try {\n+            return EMPTY_CLOB = (Clob) Class.forName(\"oracle.sql.CLOB\",true, \n+                    AccessController.doPrivileged(J2DoPrivHelper\n+                            .getContextClassLoaderAction())).\n+                getMethod(\"empty_lob\", new Class[0]).\n+                invoke(null, new Object[0]);\n+        } catch (Exception e) {\n+            throw new SQLException(e.getMessage());\n+        }\n+    }\n+\n+    private Blob getEmptyBlob()\n+        throws SQLException {\n+        if (EMPTY_BLOB != null)\n+            return EMPTY_BLOB;\n+        try {\n+            return EMPTY_BLOB = (Blob) Class.forName(\"oracle.sql.BLOB\",true, \n+                    AccessController.doPrivileged(J2DoPrivHelper\n+                            .getContextClassLoaderAction())).\n+                getMethod(\"empty_lob\", new Class[0]).\n+                invoke(null, new Object[0]);\n+        } catch (Exception e) {\n+            throw new SQLException(e.getMessage());\n+        }\n+    }\n+\n+    private static boolean isOraclePreparedStatement(Statement stmnt) {\n+        try {\n+            return Class.forName(\"oracle.jdbc.OraclePreparedStatement\").\n+                isInstance(stmnt);\n+        } catch (Exception e) {\n+            return false;\n+        }\n+    }\n+    \n+    /**\n+     * If this dictionary supports XML type,\n+     * use this method to append xml predicate.\n+     * \n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison\n+     * @param rhs the right hand side of the comparison\n+     */\n+    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\n+        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\n+        super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\n+        if (lhsxml && rhsxml)\n+            appendXmlComparison2(buf, op, lhs, rhs);\n+        else if (lhsxml)\n+            appendXmlComparison1(buf, op, lhs, rhs);\n+        else \n+            appendXmlComparison1(buf, op, rhs, lhs);\n+    }\n+    \n+    /**\n+     * Append an xml comparison predicate\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison\n+     */\n+    private void appendXmlComparison1(SQLBuffer buf, String op,\n+        FilterValue lhs, FilterValue rhs) {\n+        appendXmlExtractValue(buf, lhs);\n+        buf.append(\" \").append(op).append(\" \");\n+        rhs.appendTo(buf);\n+    }\n+    \n+    /**\n+     * Append an xml comparison predicate (both operands map to xml column)\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison (maps to xml column)\n+     */\n+    private void appendXmlComparison2(SQLBuffer buf, String op, \n+        FilterValue lhs, FilterValue rhs) {\n+        appendXmlExtractValue(buf, lhs);\n+        buf.append(\" \").append(op).append(\" \");\n+        appendXmlExtractValue(buf, rhs);\n+    }\n+    \n+    private void appendXmlExtractValue(SQLBuffer buf, FilterValue val) {\n+        buf.append(\"extractValue(\").\n+            append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\",'/*/\");\n+        val.appendTo(buf);\n+        buf.append(\"')\");\n+    }\n+    \n+    public void insertBlobForStreamingLoad(Row row, Column col, Object ob)\n+        throws SQLException {\n+        if (ob == null)\n+            col.setType(Types.OTHER);\n+        row.setNull(col);\n+    }\n+    \n+    public void insertClobForStreamingLoad(Row row, Column col, Object ob)\n+        throws SQLException {\n+        if (ob == null)\n+            col.setType(Types.OTHER);\n+        row.setNull(col);\n+    }\n+\n+    public int getBatchUpdateCount(PreparedStatement ps) throws SQLException {\n+        int updateSuccessCnt = 0;\n+        if (batchLimit != 0 && ps != null) {\n+            updateSuccessCnt = ps.getUpdateCount();\n+            if (log.isTraceEnabled())\n+                log.trace(_loc.get(\"batch-update-success-count\",\n+                    updateSuccessCnt));\n+        }\n+        return updateSuccessCnt;\n+    }\n+}"},{"sha":"6162a54537794b818c1e6ac14fb8fc12decda438","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PointbaseDictionary.java","status":"added","additions":127,"deletions":0,"changes":127,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PointbaseDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PointbaseDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PointbaseDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,127 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Index;\n+\n+/**\n+ * Dictionary for Pointbase Embedded.\n+ */\n+public class PointbaseDictionary\n+    extends DBDictionary {\n+\n+    public PointbaseDictionary() {\n+        platform = \"Pointbase Embedded\";\n+        supportsDeferredConstraints = false;\n+        supportsMultipleNontransactionalResultSets = false;\n+        requiresAliasForSubselect = true;\n+\n+        supportsLockingWithDistinctClause = false;\n+        supportsLockingWithMultipleTables = false;\n+        supportsLockingWithDistinctClause = false;\n+\n+        bitTypeName = \"TINYINT\";\n+        blobTypeName = \"BLOB(1M)\";\n+        longVarbinaryTypeName = \"BLOB(1M)\";\n+        charTypeName = \"CHARACTER{0}\";\n+        clobTypeName = \"CLOB(1M)\";\n+        doubleTypeName = \"DOUBLE PRECISION\";\n+        floatTypeName = \"FLOAT\";\n+        bigintTypeName = \"BIGINT\";\n+        integerTypeName = \"INTEGER\";\n+        realTypeName = \"REAL\";\n+        smallintTypeName = \"SMALLINT\";\n+        tinyintTypeName = \"TINYINT\";\n+\n+        // there is no build-in function for getting the last generated\n+        // key in Pointbase; using MAX will have to suffice\n+        supportsAutoAssign = true;\n+        lastGeneratedKeyQuery = \"SELECT MAX({0}) FROM {1}\";\n+        autoAssignTypeName = \"BIGINT IDENTITY\";\n+    }\n+\n+    public int getPreferredType(int type) {\n+        switch (type) {\n+            case Types.LONGVARCHAR:\n+                return Types.CLOB;\n+            default:\n+                return super.getPreferredType(type);\n+        }\n+    }\n+\n+    public Column[] getColumns(DatabaseMetaData meta, String catalog,\n+        String schemaName, String tableName, String columnName, Connection conn)\n+        throws SQLException {\n+        Column[] cols = super.getColumns(meta, catalog, schemaName, tableName,\n+            columnName, conn);\n+\n+        // pointbase reports the type for a CLOB field as VARCHAR: override it\n+        for (int i = 0; cols != null && i < cols.length; i++)\n+            if (cols[i].getTypeName().toUpperCase().startsWith(\"CLOB\"))\n+                cols[i].setType(Types.CLOB);\n+        return cols;\n+    }\n+\n+    public String getFullName(Index index) {\n+        return getFullName(index.getTable(), false) + \".\" + index.getName();\n+    }\n+\n+    public void substring(SQLBuffer buf, FilterValue str, FilterValue start,\n+        FilterValue end) {\n+        // SUBSTRING in Pointbase is of the form:\n+        // SELECT SUBSTRING(SOME_COLUMN FROM 1 FOR 5)\n+        buf.append(\"SUBSTRING(\");\n+        str.appendTo(buf);\n+        buf.append(\" FROM \");\n+        start.appendTo(buf);\n+        buf.append(\" + 1\");\n+        if (end != null) {\n+            buf.append(\" FOR \");\n+            end.appendTo(buf);\n+            buf.append(\" - (\");\n+            start.appendTo(buf);\n+            buf.append(\")\");\n+        }\n+        buf.append(\")\");\n+    }\n+\n+    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n+        FilterValue start) {\n+        buf.append(\"(POSITION(\");\n+        find.appendTo(buf);\n+        buf.append(\" IN \");\n+        if (start != null)\n+            substring(buf, str, start, null);\n+        else\n+            str.appendTo(buf);\n+        buf.append(\") - 1\");\n+        if (start != null) {\n+            buf.append(\" + \");\n+            start.appendTo(buf);\n+        }\n+        buf.append(\")\");\n+    }\n+}"},{"sha":"2aaf95d3b2d8984a788ae13d9fd242c4c0601ea6","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java","status":"added","additions":551,"deletions":0,"changes":551,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,551 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Types;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Date;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Sequence;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.lib.jdbc.DelegatingConnection;\n+import org.apache.openjpa.lib.jdbc.DelegatingPreparedStatement;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.StoreException;\n+import org.postgresql.PGConnection;\n+import org.postgresql.largeobject.LargeObject;\n+import org.postgresql.largeobject.LargeObjectManager;\n+\n+/**\n+ * Dictionary for Postgres.\n+ */\n+public class PostgresDictionary\n+    extends DBDictionary {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (PostgresDictionary.class);\n+\n+    /**\n+     * SQL statement to load all sequence schema,name pairs from all schemas.\n+     */\n+    public String allSequencesSQL = \"SELECT NULL AS SEQUENCE_SCHEMA, relname \" +\n+        \"AS SEQUENCE_NAME FROM pg_class WHERE relkind='S'\";\n+\n+    /**\n+     * SQL statement to load schema,name pairs for all sequences with a\n+     * certain name from all schemas.\n+     */\n+    public String namedSequencesFromAllSchemasSQL = \"SELECT NULL AS \" +\n+        \"SEQUENCE_SCHEMA, relname AS SEQUENCE_NAME FROM pg_class \" +\n+        \"WHERE relkind='S' AND relname = ?\";\n+\n+    /**\n+     * SQL statement to load schema,name pairs from a named schema.\n+     */\n+    public String allSequencesFromOneSchemaSQL = \"SELECT NULL AS \" +\n+        \"SEQUENCE_SCHEMA, relname AS SEQUENCE_NAME FROM pg_class, \" +\n+        \"pg_namespace WHERE relkind='S' AND pg_class.relnamespace = \" +\n+        \"pg_namespace.oid AND nspname = ?\";\n+\n+    /**\n+     * SQL statement to load a sequence's schema,name pair from one schema.\n+     */\n+    public String namedSequenceFromOneSchemaSQL = \"SELECT NULL AS \" +\n+        \"SEQUENCE_SCHEMA, relname AS SEQUENCE_NAME FROM pg_class, \" +\n+        \"pg_namespace WHERE relkind='S' AND pg_class.relnamespace = \" +\n+        \"pg_namespace.oid AND relname = ? AND nspname = ?\";\n+\n+    /**\n+     * Some Postgres drivers do not support the {@link Statement#setFetchSize}\n+     * method.\n+     */\n+    public boolean supportsSetFetchSize = true;\n+\n+    public PostgresDictionary() {\n+        platform = \"PostgreSQL\";\n+        validationSQL = \"SELECT NOW()\";\n+        datePrecision = CENTI;\n+        supportsAlterTableWithDropColumn = false;\n+        supportsDeferredConstraints = true;\n+        supportsSelectStartIndex = true;\n+        supportsSelectEndIndex = true;\n+\n+        // PostgreSQL requires double-escape for strings\n+        searchStringEscape = \"\\\\\\\\\";\n+\n+        maxTableNameLength = 63;\n+        maxColumnNameLength = 63;\n+        maxIndexNameLength = 63;\n+        maxConstraintNameLength = 63;\n+        maxAutoAssignNameLength = 63;\n+        schemaCase = SCHEMA_CASE_LOWER;\n+        rangePosition = RANGE_POST_LOCK;\n+        requiresAliasForSubselect = true;\n+        allowsAliasInBulkClause = false;\n+\n+        // {2} is the result of getGeneratedKeySequenceName; the\n+        // single-quote escape will result in SELECT CURVAL('mysequence')\n+        lastGeneratedKeyQuery = \"SELECT CURRVAL(''{2}'')\";\n+        supportsAutoAssign = true;\n+        autoAssignTypeName = \"BIGSERIAL\";\n+        nextSequenceQuery = \"SELECT NEXTVAL(''{0}'')\";\n+\n+        useGetBytesForBlobs = true;\n+        useSetBytesForBlobs = true;\n+        useGetStringForClobs = true;\n+        useSetStringForClobs = true;\n+        bitTypeName = \"BOOL\";\n+        smallintTypeName = \"SMALLINT\";\n+        realTypeName = \"FLOAT8\";\n+        tinyintTypeName = \"SMALLINT\";\n+        binaryTypeName = \"BYTEA\";\n+        blobTypeName = \"BYTEA\";\n+        longVarbinaryTypeName = \"BYTEA\";\n+        varbinaryTypeName = \"BYTEA\";\n+        clobTypeName = \"TEXT\";\n+        longVarcharTypeName = \"TEXT\";\n+        doubleTypeName = \"DOUBLE PRECISION\";\n+        varcharTypeName = \"VARCHAR{0}\";\n+        timestampTypeName = \"ABSTIME\";\n+        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\n+            \"BOOL\", \"BYTEA\", \"NAME\", \"INT8\", \"INT2\", \"INT2VECTOR\", \"INT4\",\n+            \"REGPROC\", \"TEXT\", \"OID\", \"TID\", \"XID\", \"CID\", \"OIDVECTOR\",\n+            \"SET\", \"FLOAT4\", \"FLOAT8\", \"ABSTIME\", \"RELTIME\", \"TINTERVAL\",\n+            \"MONEY\",\n+        }));\n+\n+        supportsLockingWithDistinctClause = false;\n+        supportsLockingWithOuterJoin = false;\n+        supportsNullTableForGetImportedKeys = true;\n+\n+        reservedWordSet.addAll(Arrays.asList(new String[]{\n+            \"ABORT\", \"ACL\", \"AGGREGATE\", \"APPEND\", \"ARCHIVE\", \"ARCH_STORE\",\n+            \"BACKWARD\", \"BINARY\", \"CHANGE\", \"CLUSTER\", \"COPY\", \"DATABASE\",\n+            \"DELIMITER\", \"DELIMITERS\", \"DO\", \"EXPLAIN\", \"EXTEND\",\n+            \"FORWARD\", \"HEAVY\", \"INDEX\", \"INHERITS\", \"ISNULL\", \"LIGHT\",\n+            \"LISTEN\", \"LOAD\", \"MERGE\", \"NOTHING\", \"NOTIFY\", \"NOTNULL\",\n+            \"OID\", \"OIDS\", \"PURGE\", \"RECIPE\", \"RENAME\", \"REPLACE\",\n+            \"RETRIEVE\", \"RETURNS\", \"RULE\", \"SETOF\", \"STDIN\", \"STDOUT\",\n+            \"STORE\", \"VACUUM\", \"VERBOSE\", \"VERSION\",\n+        }));\n+    }\n+\n+    public Date getDate(ResultSet rs, int column)\n+        throws SQLException {\n+        try {\n+            return super.getDate(rs, column);\n+        } catch (StringIndexOutOfBoundsException sioobe) {\n+            // there is a bug in some versions of the postgres JDBC\n+            // driver such that a date with not enough numbers in it\n+            // will throw a parsing exception: this tries to work\n+            // around it. The bug only occurs when there is a trailing\n+            // millisecond missing from the end. E.g., when the date is\n+            // like:\n+            // 2066-10-19 22:08:32.83\n+            // rather than what the driver expects:\n+            // 2066-10-19 22:08:32.830\n+            String dateStr = rs.getString(column);\n+            SimpleDateFormat fmt = new SimpleDateFormat(\n+                \"yyyy-MM-dd hh:mm:ss.SS\");\n+            try {\n+                return fmt.parse(dateStr);\n+            } catch (ParseException pe) {\n+                throw new SQLException(pe.toString());\n+            }\n+        }\n+    }\n+\n+    public byte getByte(ResultSet rs, int column)\n+        throws SQLException {\n+        // postgres does not perform automatic conversions, so attempting to\n+        // get a whole number out of a decimal will throw an exception.\n+        // fall back to performing manual conversion if the initial get fails\n+        try {\n+            return super.getByte(rs, column);\n+        } catch (SQLException sqle) {\n+            return super.getBigDecimal(rs, column).byteValue();\n+        }\n+    }\n+\n+    public short getShort(ResultSet rs, int column)\n+        throws SQLException {\n+        // postgres does not perform automatic conversions, so attempting to\n+        // get a whole number out of a decimal will throw an exception.\n+        // fall back to performing manual conversion if the initial get fails\n+        try {\n+            return super.getShort(rs, column);\n+        } catch (SQLException sqle) {\n+            return super.getBigDecimal(rs, column).shortValue();\n+        }\n+    }\n+\n+    public int getInt(ResultSet rs, int column)\n+        throws SQLException {\n+        // postgres does not perform automatic conversions, so attempting to\n+        // get a whole number out of a decimal will throw an exception.\n+        // fall back to performing manual conversion if the initial get fails\n+        try {\n+            return super.getInt(rs, column);\n+        } catch (SQLException sqle) {\n+            return super.getBigDecimal(rs, column).intValue();\n+        }\n+    }\n+\n+    public long getLong(ResultSet rs, int column)\n+        throws SQLException {\n+        // postgres does not perform automatic conversions, so attempting to\n+        // get a whole number out of a decimal will throw an exception.\n+        // fall back to performing manual conversion if the initial get fails\n+        try {\n+            return super.getLong(rs, column);\n+        } catch (SQLException sqle) {\n+            return super.getBigDecimal(rs, column).longValue();\n+        }\n+    }\n+\n+    public void setBoolean(PreparedStatement stmnt, int idx, boolean val,\n+        Column col)\n+        throws SQLException {\n+        // postgres actually requires that a boolean be set: it cannot\n+        // handle a numeric argument.\n+        stmnt.setBoolean(idx, val);\n+    }\n+\n+    public void setNull(PreparedStatement stmnt, int idx, int colType,\n+        Column col)\n+        throws SQLException {\n+        // OPENJPA-\n+        if (colType == Types.BLOB)\n+            colType = Types.BINARY;\n+        stmnt.setNull(idx, colType);\n+    }\n+\n+    protected void appendSelectRange(SQLBuffer buf, long start, long end,\n+        boolean subselect) {\n+        if (end != Long.MAX_VALUE)\n+            buf.append(\" LIMIT \").appendValue(end - start);\n+        if (start != 0)\n+            buf.append(\" OFFSET \").appendValue(start);\n+    }\n+\n+    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n+        FilterValue start) {\n+        buf.append(\"(POSITION(\");\n+        find.appendTo(buf);\n+        buf.append(\" IN \");\n+        if (start != null)\n+            substring(buf, str, start, null);\n+        else\n+            str.appendTo(buf);\n+        buf.append(\") - 1\");\n+        if (start != null) {\n+            buf.append(\" + \");\n+            start.appendTo(buf);\n+        }\n+        buf.append(\")\");\n+    }\n+\n+    public String[] getCreateSequenceSQL(Sequence seq) {\n+        String[] sql = super.getCreateSequenceSQL(seq);\n+        if (seq.getAllocate() > 1)\n+            sql[0] += \" CACHE \" + seq.getAllocate();\n+        return sql;\n+    }\n+\n+    protected boolean supportsDeferredUniqueConstraints() {\n+        // Postgres only supports deferred foreign key constraints.\n+        return false;\n+    }\n+\n+    protected String getSequencesSQL(String schemaName, String sequenceName) {\n+        if (schemaName == null && sequenceName == null)\n+            return allSequencesSQL;\n+        else if (schemaName == null)\n+            return namedSequencesFromAllSchemasSQL;\n+        else if (sequenceName == null)\n+            return allSequencesFromOneSchemaSQL;\n+        else\n+            return namedSequenceFromOneSchemaSQL;\n+    }\n+\n+    public boolean isSystemSequence(String name, String schema,\n+        boolean targetSchema) {\n+        if (super.isSystemSequence(name, schema, targetSchema))\n+            return true;\n+\n+        // filter out generated sequences used for bigserial cols, which are\n+        // of the form <table>_<col>_seq\n+        int idx = name.indexOf('_');\n+        return idx != -1 && idx != name.length() - 4\n+            && name.toUpperCase().endsWith(\"_SEQ\");\n+    }\n+\n+    public boolean isSystemTable(String name, String schema,\n+        boolean targetSchema) {\n+        // names starting with \"pg_\" are reserved for Postgresql internal use\n+        return super.isSystemTable(name, schema, targetSchema)\n+            || (name != null && name.toLowerCase().startsWith(\"pg_\"));\n+    }\n+\n+    public boolean isSystemIndex(String name, Table table) {\n+        // names starting with \"pg_\" are reserved for Postgresql internal use\n+        return super.isSystemIndex(name, table)\n+            || (name != null && name.toLowerCase().startsWith(\"pg_\"));\n+    }\n+\n+    public Connection decorate(Connection conn)\n+        throws SQLException {\n+        return new PostgresConnection(super.decorate(conn), this);\n+    }\n+\n+    public InputStream getLOBStream(JDBCStore store, ResultSet rs,\n+        int column) throws SQLException {\n+        DelegatingConnection conn = (DelegatingConnection)store\n+            .getConnection();\n+        conn.setAutoCommit(false);\n+        LargeObjectManager lom = ((PGConnection)conn.getInnermostDelegate())\n+        .getLargeObjectAPI();\n+        if (rs.getInt(column) != -1) {\n+            LargeObject lo = lom.open(rs.getInt(column));\n+            return lo.getInputStream();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public void insertBlobForStreamingLoad(Row row, Column col, \n+        JDBCStore store, Object ob, Select sel) throws SQLException {\n+        if (row.getAction() == Row.ACTION_INSERT) {\n+            insertPostgresBlob(row, col, store, ob);\n+        } else if (row.getAction() == Row.ACTION_UPDATE) {\n+            updatePostgresBlob(row, col, store, ob, sel);\n+        }\n+    }\n+\n+    private void insertPostgresBlob(Row row, Column col, JDBCStore store,\n+        Object ob) throws SQLException {\n+        if (ob != null) {\n+            col.setType(Types.INTEGER);\n+            DelegatingConnection conn = (DelegatingConnection)store\n+            .getConnection();\n+            try {\n+                conn.setAutoCommit(false);\n+                PGConnection pgconn = (PGConnection) conn.getInnermostDelegate();\n+                LargeObjectManager lom = pgconn.getLargeObjectAPI();\n+                // The create method is valid in versions previous 8.3\n+                // in 8.3 this methos is deprecated, use createLO\n+                int oid = lom.create();\n+                LargeObject lo = lom.open(oid, LargeObjectManager.WRITE);\n+                OutputStream os = lo.getOutputStream();\n+                copy((InputStream)ob, os);\n+                lo.close();\n+                row.setInt(col, oid);\n+            } catch (IOException ioe) {\n+                throw new StoreException(ioe);\n+            } finally {\n+                conn.close();\n+            }\n+        } else {\n+            row.setInt(col, -1);\n+        }\n+    }\n+    \n+    private void updatePostgresBlob(Row row, Column col, JDBCStore store,\n+        Object ob, Select sel) throws SQLException {\n+        SQLBuffer sql = sel.toSelect(true, store.getFetchConfiguration());\n+        ResultSet res = null;\n+        DelegatingConnection conn = \n+            (DelegatingConnection) store.getConnection();\n+        PreparedStatement stmnt = null;\n+        try {\n+            stmnt = sql.prepareStatement(conn, store.getFetchConfiguration(),\n+                ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n+            res = stmnt.executeQuery();\n+            if (!res.next()) {\n+                throw new InternalException(_loc.get(\"stream-exception\"));\n+            }\n+            int oid = res.getInt(1);\n+            if (oid != -1) {\n+                conn.setAutoCommit(false);\n+                PGConnection pgconn = (PGConnection)conn\n+                    .getInnermostDelegate();\n+                LargeObjectManager lom = pgconn.getLargeObjectAPI();\n+                if (ob != null) {\n+                    LargeObject lo = lom.open(oid, LargeObjectManager.WRITE);\n+                    OutputStream os = lo.getOutputStream();\n+                    copy((InputStream)ob, os);\n+                    lo.close();\n+                } else {\n+                    lom.delete(oid);\n+                    row.setInt(col, -1);\n+                }\n+            } else {\n+                if (ob != null) {\n+                    conn.setAutoCommit(false);\n+                    PGConnection pgconn = (PGConnection)conn\n+                        .getInnermostDelegate();\n+                    LargeObjectManager lom = pgconn.getLargeObjectAPI();\n+                    oid = lom.create();\n+                    LargeObject lo = lom.open(oid, LargeObjectManager.WRITE);\n+                    OutputStream os = lo.getOutputStream();\n+                    copy((InputStream)ob, os);\n+                    lo.close();\n+                    row.setInt(col, oid);\n+                }\n+            }\n+\n+        } catch (IOException ioe) {\n+            throw new StoreException(ioe);\n+        } finally {\n+            if (res != null)\n+                try { res.close (); } catch (SQLException e) {}\n+            if (stmnt != null)\n+                try { stmnt.close (); } catch (SQLException e) {}\n+            if (conn != null)\n+                try { conn.close (); } catch (SQLException e) {}\n+        }\n+\n+    }\n+    \n+    public void updateBlob(Select sel, JDBCStore store, InputStream is)\n+        throws SQLException {\n+        //Do nothing\n+    }\n+\n+    public void deleteStream(JDBCStore store, Select sel) throws SQLException {\n+        SQLBuffer sql = sel.toSelect(true, store.getFetchConfiguration());\n+        ResultSet res = null;\n+        DelegatingConnection conn = \n+            (DelegatingConnection) store.getConnection();\n+        PreparedStatement stmnt = null;\n+        try {\n+            stmnt = sql.prepareStatement(conn, store.getFetchConfiguration(),\n+                ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n+            res = stmnt.executeQuery();\n+            if (!res.next()) {\n+                throw new InternalException(_loc.get(\"stream-exception\"));\n+            }\n+            int oid = res.getInt(1);\n+            if (oid != -1) {\n+                conn.setAutoCommit(false);\n+                PGConnection pgconn = (PGConnection)conn\n+                    .getInnermostDelegate();\n+                LargeObjectManager lom = pgconn.getLargeObjectAPI();\n+                lom.delete(oid);\n+            }\n+        } finally {\n+            if (res != null)\n+                try { res.close (); } catch (SQLException e) {}\n+            if (stmnt != null)\n+                try { stmnt.close (); } catch (SQLException e) {}\n+            if (conn != null)\n+                try { conn.close (); } catch (SQLException e) {}\n+        }\n+    }\n+    \n+    /**\n+     * Connection wrapper to work around the postgres empty result set bug.\n+     */\n+    private static class PostgresConnection\n+        extends DelegatingConnection {\n+\n+        private final PostgresDictionary _dict;\n+\n+        public PostgresConnection(Connection conn, PostgresDictionary dict) {\n+            super(conn);\n+            _dict = dict;\n+        }\n+\n+        protected PreparedStatement prepareStatement(String sql, boolean wrap)\n+            throws SQLException {\n+            return new PostgresPreparedStatement(super.prepareStatement\n+                (sql, false), this, _dict);\n+        }\n+\n+        protected PreparedStatement prepareStatement(String sql, int rsType,\n+            int rsConcur, boolean wrap)\n+            throws SQLException {\n+            return new PostgresPreparedStatement(super.prepareStatement\n+                (sql, rsType, rsConcur, false), this, _dict);\n+        }\n+    }\n+\n+    /**\n+     * Statement wrapper to work around the postgres empty result set bug.\n+     */\n+    private static class PostgresPreparedStatement\n+        extends DelegatingPreparedStatement {\n+\n+        private final PostgresDictionary _dict;\n+\n+        public PostgresPreparedStatement(PreparedStatement ps,\n+            Connection conn, PostgresDictionary dict) {\n+            super(ps, conn);\n+            _dict = dict;\n+        }\n+\n+        protected ResultSet executeQuery(boolean wrap)\n+            throws SQLException {\n+            try {\n+                return super.executeQuery(wrap);\n+            } catch (SQLException se) {\n+                // we need to make our best guess whether this is the empty\n+                // ResultSet bug, since this exception could occur\n+                // for other reasons (like an invalid query string). Note\n+                // that Postgres error messages are localized, so we\n+                // cannot just parse the exception String.\n+                ResultSet rs = getResultSet(wrap);\n+\n+                // ResultSet should be empty: if not, then maybe an\n+                // actual error occured\n+                if (rs == null)\n+                    throw se;\n+\n+                return rs;\n+            }\n+        }\n+\n+        public void setFetchSize(int i)\n+            throws SQLException {\n+            // some postgres drivers do not support the setFetchSize method\n+            try {\n+                if (_dict.supportsSetFetchSize)\n+                    super.setFetchSize(i);\n+            } catch (SQLException e) {\n+                _dict.supportsSetFetchSize = false;\n+                if (_dict.log.isWarnEnabled())\n+                    _dict.log.warn(_loc.get(\"psql-no-set-fetch-size\"), e);\n+            }\n+        }\n+    }\n+}"},{"sha":"3a0be1ba78da408fbcae3bef3247f18b90fb40ce","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PrimaryRow.java","status":"added","additions":438,"deletions":0,"changes":438,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PrimaryRow.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PrimaryRow.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PrimaryRow.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,438 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.commons.lang.ObjectUtils;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.RelationId;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.InvalidStateException;\n+\n+/**\n+ * Primary table row that tracks foreign keys and auto-inc columns.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class PrimaryRow\n+    extends RowImpl {\n+\n+    // VALID flag in superclass uses 2 << 0\n+    private static final byte PK_SET = 2 << 1;\n+    private static final byte PK_WHERE = 2 << 2;\n+    private static final byte DEPENDENT = 2 << 4;\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (PrimaryRow.class);\n+\n+    private OpenJPAStateManager _pk = null;\n+    private ColumnIO _pkIO = null;\n+    private OpenJPAStateManager[] _fkSet = null;\n+    private ColumnIO[] _fkIO = null;\n+    private OpenJPAStateManager[] _fkWhere = null;\n+    private OpenJPAStateManager[] _relSet = null;\n+    private RelationId[] _callbacks = null;\n+    private Object _failed = null;\n+    private int _idx = -1;\n+\n+    /**\n+     * Constructor; supply table and action.\n+     */\n+    public PrimaryRow(Table table, int action, OpenJPAStateManager owner) {\n+        this(table.getColumns(), action, owner);\n+    }\n+\n+    protected PrimaryRow(Column[] cols, int action, OpenJPAStateManager owner) {\n+        super(cols, action);\n+        _pk = owner;\n+    }\n+\n+    /**\n+     * Mark this row as dependent on some other row.\n+     */\n+    public boolean isDependent() {\n+        return (flags & DEPENDENT) > 0;\n+    }\n+\n+    /**\n+     * Mark this row as dependent on some other row.\n+     */\n+    public void setDependent(boolean dependent) {\n+        if (dependent)\n+            flags |= DEPENDENT;\n+        else\n+            flags &= ~DEPENDENT;\n+    }\n+\n+    /**\n+     * The index of this row in ordered row list.\n+     */\n+    public int getIndex() {\n+        return _idx;\n+    }\n+\n+    /**\n+     * The index of this row in ordered row list.\n+     */\n+    public void setIndex(int idx) {\n+        _idx = idx;\n+    }\n+\n+    public Object getFailedObject() {\n+        return _failed;\n+    }\n+\n+    public void setFailedObject(Object failed) {\n+        _failed = failed;\n+    }\n+\n+    public OpenJPAStateManager getPrimaryKey() {\n+        return _pk;\n+    }\n+\n+    public void setPrimaryKey(OpenJPAStateManager sm)\n+        throws SQLException {\n+        setPrimaryKey(null, sm);\n+    }\n+\n+    public void setPrimaryKey(ColumnIO io, OpenJPAStateManager sm) {\n+        _pk = sm;\n+        flags |= PK_SET;\n+        _pkIO = io;\n+\n+        // force valid\n+        setValid(true);\n+    }\n+\n+    public void wherePrimaryKey(OpenJPAStateManager sm)\n+        throws SQLException {\n+        _pk = sm;\n+        flags |= PK_WHERE;\n+\n+        // force valid\n+        if (getAction() == ACTION_DELETE)\n+            setValid(true);\n+    }\n+\n+    /**\n+     * Return the I/O information for the given set foreign key.\n+     */\n+    public ColumnIO getForeignKeyIO(ForeignKey fk) {\n+        return (_fkIO == null) ? null : _fkIO[fk.getIndex()];\n+    }\n+\n+    /**\n+     * Return the value for the given foreign key. Values not needed for\n+     * constraint analyses are not recorded.\n+     */\n+    public OpenJPAStateManager getForeignKeySet(ForeignKey fk) {\n+        return (_fkSet == null) ? null : _fkSet[fk.getIndex()];\n+    }\n+\n+    /**\n+     * Return the value for the given foreign key. Values not needed for\n+     * constraint analyses are not recorded.\n+     */\n+    public OpenJPAStateManager getForeignKeyWhere(ForeignKey fk) {\n+        return (_fkWhere == null) ? null : _fkWhere[fk.getIndex()];\n+    }\n+\n+    public void setForeignKey(ForeignKey fk, OpenJPAStateManager sm)\n+        throws SQLException {\n+        setForeignKey(fk, null, sm);\n+    }\n+\n+    public void setForeignKey(ForeignKey fk, ColumnIO io,\n+        OpenJPAStateManager sm)\n+        throws SQLException {\n+        if (!delayForeignKey(fk, sm, true))\n+            super.setForeignKey(fk, io, sm);\n+        else\n+            recordForeignKey(fk, io, sm, true);\n+    }\n+\n+    public void whereForeignKey(ForeignKey fk, OpenJPAStateManager sm)\n+        throws SQLException {\n+        if (!delayForeignKey(fk, sm, false))\n+            super.whereForeignKey(fk, sm);\n+        else\n+            recordForeignKey(fk, null, sm, false);\n+    }\n+\n+    public void clearForeignKey(ForeignKey fk)\n+        throws SQLException {\n+        super.clearForeignKey(fk);\n+        if (_fkSet != null)\n+            _fkSet[fk.getIndex()] = null;\n+        if (_fkIO != null)\n+            _fkIO[fk.getIndex()] = null;\n+    }\n+\n+    /**\n+     * If this is a delete, delay foreign keys to other deleted objects if the \n+     * key is restricted or cascade. If this is an update or insert, delay \n+     * foreign keys to other inserts if the key is not logical. If the foreign \n+     * key is to a new record and the columns are auto-inc, record it.\n+     */\n+    private boolean delayForeignKey(ForeignKey fk, OpenJPAStateManager sm,\n+        boolean set) {\n+        if (sm == null)\n+            return false;\n+\n+        if (getAction() == ACTION_DELETE)\n+            return sm.isDeleted() && !fk.isDeferred()\n+                && (fk.getDeleteAction() == ForeignKey.ACTION_RESTRICT ||\n+                    fk.getDeleteAction() == ForeignKey.ACTION_CASCADE);\n+\n+        if (!sm.isNew() || sm.isFlushed())\n+            return false;\n+        if (!fk.isDeferred() && !fk.isLogical())\n+            return true;\n+        if (fk.isPrimaryKeyAutoAssigned())\n+            return true;\n+        return false;\n+    }\n+\n+    /**\n+     * Record a delayed foreign key.\n+     */\n+    private void recordForeignKey(ForeignKey fk, ColumnIO io,\n+        OpenJPAStateManager sm, boolean set) {\n+        if (set) {\n+            // force valid\n+            if (canSetAny(io, fk.getColumns().length\n+                + fk.getConstantColumns().length, false))\n+                setValid(true);\n+\n+            if (_fkSet == null)\n+                _fkSet = new OpenJPAStateManager[getTable().\n+                    getForeignKeys().length];\n+            _fkSet[fk.getIndex()] = sm;\n+\n+            if (_fkIO != null)\n+                _fkIO[fk.getIndex()] = io;\n+            else if (io != null && ((getAction() == ACTION_INSERT\n+                && !io.isAllInsertable(fk, false))\n+                || (getAction() != ACTION_INSERT\n+                && !io.isAllUpdatable(fk, false)))) {\n+                _fkIO = new ColumnIO[_fkSet.length];\n+                _fkIO[fk.getIndex()] = io;\n+            }\n+        } else {\n+            // force valid\n+            if (getAction() == ACTION_DELETE)\n+                setValid(true);\n+\n+            if (_fkWhere == null)\n+                _fkWhere = new OpenJPAStateManager[getTable().\n+                    getForeignKeys().length];\n+            _fkWhere[fk.getIndex()] = sm;\n+        }\n+    }\n+\n+    /**\n+     * Return the recorded value for the given relation id column. Only\n+     * values that are dependent on a new, unflushed auto-assigned instance\n+     * are recorded.\n+     */\n+    public OpenJPAStateManager getRelationIdSet(Column col) {\n+        return (_relSet == null) ? null : _relSet[getRelationIdIndex(col)];\n+    }\n+\n+    /**\n+     * Return the recorded callbacks for the given relation id column. Only\n+     * values that are dependent on a new, unflushed auto-assigned instance\n+     * are recorded.\n+     */\n+    public RelationId getRelationIdCallback(Column col) {\n+        return (_callbacks == null) ? null\n+            : _callbacks[getRelationIdIndex(col)];\n+    }\n+\n+    public void setRelationId(Column col, OpenJPAStateManager sm,\n+        RelationId rel)\n+        throws SQLException {\n+        if (sm == null || sm.getObjectId() != null || !sm.isNew()\n+            || sm.isFlushed() || !isPrimaryKeyAutoAssigned(sm))\n+            super.setRelationId(col, sm, rel);\n+        else {\n+            if (_relSet == null) {\n+                Column[] cols = getTable().getRelationIdColumns();\n+                _relSet = new OpenJPAStateManager[cols.length];\n+                _callbacks = new RelationId[cols.length];\n+            }\n+            int idx = getRelationIdIndex(col);\n+            _relSet[idx] = sm;\n+            _callbacks[idx] = rel;\n+        }\n+    }\n+\n+    public void clearRelationId(Column col)\n+        throws SQLException {\n+        super.clearRelationId(col);\n+        if (_relSet != null) {\n+            int idx = getRelationIdIndex(col);\n+            _relSet[idx] = null;\n+            _callbacks[idx] = null;\n+        }\n+    }\n+\n+    /**\n+     * Return the index into our relation id array of the value for the\n+     * given column.\n+     */\n+    private int getRelationIdIndex(Column col) {\n+        Column[] cols = getTable().getRelationIdColumns();\n+        for (int i = 0; i < cols.length; i++)\n+            if (cols[i] == col)\n+                return i;\n+        return -1;\n+    }\n+\n+    /**\n+     * Return true if any primary key columns of the given instance are\n+     * auto-assigned.\n+     */\n+    private static boolean isPrimaryKeyAutoAssigned(OpenJPAStateManager sm) {\n+        ClassMapping cls = (ClassMapping) sm.getMetaData();\n+        while (cls.getJoinablePCSuperclassMapping() != null)\n+            cls = cls.getJoinablePCSuperclassMapping();\n+        Column[] cols = cls.getPrimaryKeyColumns();\n+        for (int i = 0; i < cols.length; i++)\n+            if (cols[i].isAutoAssigned())\n+                return true;\n+        return false;\n+    }\n+\n+    protected void setObject(Column col, Object val, int metaType,\n+        boolean overrideDefault)\n+        throws SQLException {\n+        // make sure we're not setting two different values\n+        Object prev = getSet(col);\n+        if (prev != null) {\n+            if (prev == NULL)\n+                prev = null;\n+            if (!rowValueEquals(prev, val)) {\n+                throw new InvalidStateException(_loc.get(\"diff-values\",\n+                    new Object[]{ col.getFullName(),\n+                        (prev == null) ? null : prev.getClass(), prev,\n+                        (val == null) ? null : val.getClass(), val })).\n+                    setFatal(true);\n+            }\n+        }\n+        super.setObject(col, val, metaType, overrideDefault);\n+    }\n+\n+    /**\n+     * Return true if the two values should be considered equal.\n+     */\n+    private static boolean rowValueEquals(Object o1, Object o2) {\n+        if (ObjectUtils.equals(o1, o2))\n+            return true;\n+\n+        // check for numeric equality (bug #1151)\n+        return o1 instanceof Number && o2 instanceof Number\n+            && ((Number) o1).doubleValue() == ((Number) o2).doubleValue();\n+    }\n+\n+    protected String generateSQL(DBDictionary dict) {\n+        try {\n+            if ((flags & PK_SET) > 0)\n+                super.setPrimaryKey(_pkIO, _pk);\n+            if ((flags & PK_WHERE) > 0)\n+                super.wherePrimaryKey(_pk);\n+            if (_fkSet != null) {\n+                ForeignKey[] fks = getTable().getForeignKeys();\n+                ColumnIO io;\n+                for (int i = 0; i < _fkSet.length; i++) {\n+                    if (_fkSet[i] != null) {\n+                        io = (_fkIO == null) ? null : _fkIO[i];\n+                        super.setForeignKey(fks[i], io, _fkSet[i]);\n+                    }\n+                }\n+            }\n+            if (_relSet != null) {\n+                Column[] cols = getTable().getRelationIdColumns();\n+                for (int i = 0; i < _relSet.length; i++)\n+                    if (_relSet[i] != null)\n+                        super.setRelationId(cols[i], _relSet[i], _callbacks[i]);\n+            }\n+            if (_fkWhere != null) {\n+                ForeignKey[] fks = getTable().getForeignKeys();\n+                for (int i = 0; i < _fkWhere.length; i++)\n+                    if (_fkWhere[i] != null)\n+                        super.whereForeignKey(fks[i], _fkWhere[i]);\n+            }\n+        }\n+        catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, dict);\n+        }\n+        return super.generateSQL(dict);\n+    }\n+\n+    protected RowImpl newInstance(Column[] cols, int action) {\n+        return new PrimaryRow(cols, action, _pk);\n+    }\n+\n+    public void copyInto(RowImpl row, boolean whereOnly) {\n+        super.copyInto(row, whereOnly);\n+        if (!(row instanceof PrimaryRow))\n+            return;\n+\n+        PrimaryRow prow = (PrimaryRow) row;\n+        prow._pk = _pk;\n+        prow._pkIO = _pkIO;\n+        if ((flags & PK_WHERE) > 0)\n+            prow.flags |= PK_WHERE;\n+        if (!whereOnly && (flags & PK_SET) > 0)\n+            prow.flags |= PK_SET;\n+\n+        if (_fkWhere != null) {\n+            if (prow._fkWhere == null)\n+                prow._fkWhere = new OpenJPAStateManager[_fkWhere.length];\n+            System.arraycopy(_fkWhere, 0, prow._fkWhere, 0, _fkWhere.length);\n+        }\n+        if (!whereOnly && _fkSet != null) {\n+            if (prow._fkSet == null)\n+                prow._fkSet = new OpenJPAStateManager[_fkSet.length];\n+            System.arraycopy(_fkSet, 0, prow._fkSet, 0, _fkSet.length);\n+            if (_fkIO != null) {\n+                if (prow._fkIO == null)\n+                    prow._fkIO = new ColumnIO[_fkIO.length];\n+                System.arraycopy(_fkIO, 0, prow._fkIO, 0, _fkIO.length);\n+            }\n+        }\n+        if (!whereOnly && _relSet != null) {\n+            if (prow._relSet == null) {\n+                prow._relSet = new OpenJPAStateManager[_relSet.length];\n+                prow._callbacks = new RelationId[_callbacks.length];\n+            }\n+            System.arraycopy(_relSet, 0, prow._relSet, 0, _relSet.length);\n+            System.arraycopy(_callbacks, 0, prow._callbacks, 0,\n+                _callbacks.length);\n+        }\n+    }\n+}"},{"sha":"240926fd30868bcee61ca9b78bc24feebb8750e6","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Raw.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Raw.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Raw.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Raw.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+/**\n+ * Represents a raw SQL string for passing to\n+ * <code>Row.setObject</code>.\n+ *\n+ * @author Abe White\n+ */\n+public class Raw {\n+\n+    public final String sql;\n+\n+    public Raw(String sql) {\n+        this.sql = sql;\n+    }\n+\n+    public String toString() {\n+        return sql;\n+    }\n+}"},{"sha":"8f5c729f4c762ea3a24e0a1c24a91a3dfa7bce14","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Result.java","status":"added","additions":607,"deletions":0,"changes":607,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Result.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Result.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Result.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,607 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Ref;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.lib.util.Closeable;\n+\n+/**\n+ * A result from the execution of a query or stored procedure. This\n+ * interface is aligned closely with the {@link java.sql.ResultSet}, so you\n+ * can expect like-named methods to have similar semantics. However, the\n+ * interface has been distilled and simplified, so a result object could\n+ * easily mask information sources other than a result set.\n+ *  For more flexible customization of data loading, see the\n+ * {@link org.apache.openjpa.kernel.PCResultObjectProvider}.\n+ *\n+ * @author Abe White\n+ * @see ResultSetResult\n+ */\n+public interface Result\n+    extends Closeable {\n+\n+    /**\n+     * The eager result for the given key, or null if none.\n+     */\n+    public Object getEager(FieldMapping key);\n+\n+    /**\n+     * The eager result for the given key, or null if none.\n+     */\n+    public void putEager(FieldMapping key, Object res);\n+\n+    /**\n+     * Return a new joins instance to use for traversing to related data.\n+     */\n+    public Joins newJoins();\n+\n+    /**\n+     * Free the resources used by this result; do <strong>not</strong>\n+     * close the SQL connection.\n+     */\n+    public void close();\n+\n+    /**\n+     * If true, then any results loaded from this Result\n+     * will be locked in the database.\n+     */\n+    public boolean isLocking();\n+\n+    /**\n+     * Return true if the result supports random access.\n+     */\n+    public boolean supportsRandomAccess()\n+        throws SQLException;\n+\n+    /**\n+     * Move to the given <strong>0-based</strong> row in the result, or\n+     * return false if the row does not exist. This method will only be\n+     * called if the result supports random access.\n+     */\n+    public boolean absolute(int row)\n+        throws SQLException;\n+\n+    /**\n+     * Advance to the next row, or return false if there are no more rows\n+     * in the result.\n+     */\n+    public boolean next()\n+        throws SQLException;\n+\n+    /**\n+     * Push back the last result. In other words, just ignore the next call\n+     * to {@link #next}. After the first time this method is called,\n+     * additional calls before a call to {@link #next} or {@link #absolute}\n+     * should have no further affect.\n+     */\n+    public void pushBack()\n+        throws SQLException;\n+\n+    /**\n+     * Return the number of rows in this result.\n+     */\n+    public int size()\n+        throws SQLException;\n+\n+    /**\n+     * Return true if the given id or column is available in the result.\n+     */\n+    public boolean contains(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return true if all the given ids or columns are available in the result.\n+     */\n+    public boolean containsAll(Object[] objs)\n+        throws SQLException;\n+\n+    /**\n+     * Return true if the given column is available in the result.\n+     */\n+    public boolean contains(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return true if all the given columns are available in the result.\n+     */\n+    public boolean containsAll(Column[] cols, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * If this is the result of a UNION used to select a hierarchy of\n+     * mappings, the base mapping represented by the current row.\n+     * This information is not available after getting any eager results\n+     * from the row.\n+     */\n+    public ClassMapping getBaseMapping();\n+\n+    /**\n+     * If this is the result of a UNION used to select a hierarchy of\n+     * mappings, the base mapping represented by the current row.\n+     * This information is not available after getting any eager results\n+     * from the row.\n+     */\n+    public void setBaseMapping(ClassMapping mapping);\n+\n+    /**\n+     * If this is the result used to select a toMany relationship,\n+     * the mappedByFieldMapping is field mapping representing \n+     * the inverse relationship. This is to avoid unneeded  \n+     * extra sql to retrieve the eager inverse field.\n+     */\n+    public FieldMapping getMappedByFieldMapping();\n+\n+    /**\n+     * If this is the result used to select a toMany relationship,\n+     * the mappedByFieldMapping is field mapping representing \n+     * the inverse relationship. This is to avoid unneeded  \n+     * extra sql to retrieve the eager inverse field.\n+     */\n+    public void setMappedByFieldMapping(FieldMapping fieldMapping);\n+\n+    /**\n+     * If this is the result used to select a toMany relationship,\n+     * the mappedByValue is value of the owner of the toMany relationship. \n+     * This is to avoid unneeded extra sql to retrieve the eager inverse field.\n+     */\n+    public Object getMappedByValue();\n+\n+    /**\n+     * If this is the result used to select a toMany relationship,\n+     * the mappedByValue is value of the owner of the toMany relationship. \n+     * This is to avoid unneeded extra sql to retrieve the eager inverse field.\n+     */\n+    public void setMappedByValue(Object mappedByValue);\n+\n+    /**\n+     * The index of the select within the UNION that the current row\n+     * corresponds to, or 0.\n+     */\n+    public int indexOf();\n+\n+    /**\n+     * Load a pc object using the given store manager.\n+     */\n+    public Object load(ClassMapping mapping, JDBCStore store,\n+        JDBCFetchConfiguration fetch)\n+        throws SQLException;\n+\n+    /**\n+     * Load a pc object using the given store manager.\n+     */\n+    public Object load(ClassMapping mapping, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public Array getArray(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public InputStream getAsciiStream(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id.\n+     */\n+    public BigDecimal getBigDecimal(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id.\n+     */\n+    public BigInteger getBigInteger(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public InputStream getBinaryStream(Object obj)\n+        throws SQLException;\n+    \n+    public InputStream getLOBStream(JDBCStore store, Object obj)\n+        throws SQLException;\n+    /**\n+     * Return the value stored in the given column or id; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public Blob getBlob(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id.\n+     */\n+    public boolean getBoolean(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id.\n+     */\n+    public byte getByte(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public byte[] getBytes(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id.\n+     */\n+    public Calendar getCalendar(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id.\n+     */\n+    public char getChar(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public Reader getCharacterStream(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public Clob getClob(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id.\n+     */\n+    public Date getDate(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public java.sql.Date getDate(Object obj, Calendar cal)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id.\n+     */\n+    public double getDouble(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id.\n+     */\n+    public float getFloat(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id.\n+     */\n+    public int getInt(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id.\n+     */\n+    public Locale getLocale(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id.\n+     */\n+    public long getLong(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id.\n+     */\n+    public Number getNumber(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id.\n+     *\n+     * @param obj the column or id whose data to fetch\n+     * @param metaType the type code from {@link org.apache.openjpa.meta.JavaTypes} or\n+     * {@link JavaSQLTypes} for the type of the data; if\n+     * <code>obj</code> is a column, you may specify -1\n+     * to use the column's recorded java type\n+     * @param arg some JDBC data access methods use an argument, such\n+     * as a {@link Calendar} or {@link Map}\n+     */\n+    public Object getObject(Object obj, int metaType, Object arg)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public Object getSQLObject(Object obj, Map map)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public Ref getRef(Object obj, Map map)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id.\n+     */\n+    public short getShort(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id.\n+     */\n+    public String getString(Object obj)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public Time getTime(Object obj, Calendar cal)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column or id; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public Timestamp getTimestamp(Object obj, Calendar cal)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public Array getArray(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public InputStream getAsciiStream(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column.\n+     */\n+    public BigDecimal getBigDecimal(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column.\n+     */\n+    public BigInteger getBigInteger(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public InputStream getBinaryStream(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public Blob getBlob(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column.\n+     */\n+    public boolean getBoolean(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column.\n+     */\n+    public byte getByte(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public byte[] getBytes(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column.\n+     */\n+    public Calendar getCalendar(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column.\n+     */\n+    public char getChar(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public Reader getCharacterStream(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public Clob getClob(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column.\n+     */\n+    public Date getDate(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public java.sql.Date getDate(Column col, Calendar cal, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column.\n+     */\n+    public double getDouble(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column.\n+     */\n+    public float getFloat(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column.\n+     */\n+    public int getInt(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column.\n+     */\n+    public Locale getLocale(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column.\n+     */\n+    public long getLong(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column.\n+     */\n+    public Number getNumber(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column.\n+     *\n+     * @param col the column whose data to fetch\n+     * @param arg some JDBC data access methods use an argument, such\n+     * as a {@link Calendar} or {@link Map}\n+     */\n+    public Object getObject(Column col, Object arg, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public Object getSQLObject(Column col, Map map, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public Ref getRef(Column col, Map map, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column.\n+     */\n+    public short getShort(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column.\n+     */\n+    public String getString(Column col, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public Time getTime(Column col, Calendar cal, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return the value stored in the given column; may not be supported\n+     * by results that are not backed by a SQL result set.\n+     */\n+    public Timestamp getTimestamp(Column col, Calendar cal, Joins joins)\n+        throws SQLException;\n+\n+    /**\n+     * Return true if the last value fetched was null.\n+     */\n+    public boolean wasNull()\n+        throws SQLException;\n+\n+    /**\n+     * Informs this receiver about the application element for which a\n+     * subsequent data request will be made.\n+     */\n+    public void startDataRequest(Object mapping);\n+\n+    /**\n+     * Ends a data request. Must be called in conjunction with\n+     * {@link #startDataRequest}. The calls can be nested as follws<br />\n+     * <pre> startDataRequest (relation); startDataRequest (relationsField);\n+     * getObject(\"COLUMN_Y\"); endDataRequest (); endDataRequest ();\n+     * </pre>\n+     */\n+    public void endDataRequest();\n+}"},{"sha":"2398c7fd0a8cdf6617c65ab13b3631150246568e","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java","status":"added","additions":512,"deletions":0,"changes":512,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,512 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Connection;\n+import java.sql.Ref;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.meta.JavaTypes;\n+\n+import serp.util.Numbers;\n+\n+/**\n+ * Base {@link Result} implementation wrapped around a result set.\n+ * Column objects, column names, or column indexes (as <code>Number</code>\n+ * instances) can be used to retrieve result set data.\n+ *\n+ * @author Abe White\n+ */\n+public class ResultSetResult\n+    extends AbstractResult {\n+\n+    private final Connection _conn;\n+    private final Statement _stmnt;\n+    private final ResultSet _rs;\n+    private final DBDictionary _dict;\n+    private boolean _closeConn = true;\n+    private int _row = -1;\n+    private int _size = -1;\n+\n+    // optional; used to deserialize blobs containing refs to persistent objs\n+    private JDBCStore _store = null;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ResultSetResult(Connection conn, Statement stmnt,\n+        ResultSet rs, DBDictionary dict) {\n+        if (stmnt == null)\n+            try {\n+                stmnt = rs.getStatement();\n+            } catch (Throwable t) {\n+            }\n+\n+        _conn = conn;\n+        _stmnt = stmnt;\n+        _rs = rs;\n+        _dict = dict;\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ResultSetResult(Connection conn, Statement stmnt,\n+        ResultSet rs, JDBCStore store) {\n+        this(conn, stmnt, rs, store.getDBDictionary());\n+        setStore(store);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ResultSetResult(Connection conn,\n+        ResultSet rs, DBDictionary dict) {\n+        _conn = conn;\n+        _stmnt = null;\n+        _rs = rs;\n+        _dict = dict;\n+    }\n+\n+    /**\n+     * JDBC 2 constructor. Relies on being able to retrieve the statement\n+     * from the result set, and the connection from the statement.\n+     */\n+    public ResultSetResult(ResultSet rs, DBDictionary dict)\n+        throws SQLException {\n+        _stmnt = rs.getStatement();\n+        _conn = _stmnt.getConnection();\n+        _rs = rs;\n+        _dict = dict;\n+    }\n+\n+    /**\n+     * JDBC 2 constructor. Relies on being able to retrieve the statement\n+     * from the result set, and the connection from the statement.\n+     */\n+    public ResultSetResult(ResultSet rs, JDBCStore store)\n+        throws SQLException {\n+        this(rs, store.getDBDictionary());\n+        setStore(store);\n+    }\n+\n+    /**\n+     * Return the statement that produced this result.\n+     */\n+    public Statement getStatement() {\n+        return _stmnt;\n+    }\n+\n+    /**\n+     * Return the backing result set.\n+     */\n+    public ResultSet getResultSet() {\n+        return _rs;\n+    }\n+\n+    /**\n+     * Return the dictionary in use.\n+     */\n+    public DBDictionary getDBDictionary() {\n+        return _dict;\n+    }\n+\n+    /**\n+     * Optional store manager used to deserialize blobs containing\n+     * references to persistent objects.\n+     */\n+    public JDBCStore getStore() {\n+        return _store;\n+    }\n+\n+    /**\n+     * Optional store manager used to deserialize blobs containing\n+     * references to persistent objects.\n+     */\n+    public void setStore(JDBCStore store) {\n+        _store = store;\n+    }\n+\n+    /**\n+     * Whether to close the backing connection when this result is closed.\n+     * Defaults to true.\n+     */\n+    public boolean getCloseConnection() {\n+        return _closeConn;\n+    }\n+\n+    /**\n+     * Whether to close the backing connection when this result is closed.\n+     * Defaults to true.\n+     */\n+    public void setCloseConnection(boolean closeConn) {\n+        _closeConn = closeConn;\n+    }\n+\n+    public void close() {\n+        super.close();\n+        try {\n+            _rs.close();\n+        } catch (SQLException se) {\n+        }\n+        if (_stmnt != null)\n+            try {\n+                _stmnt.close();\n+            } catch (SQLException se) {\n+            }\n+        if (_closeConn)\n+            try {\n+                _conn.close();\n+            } catch (SQLException se) {\n+            }\n+    }\n+\n+    public boolean supportsRandomAccess()\n+        throws SQLException {\n+        return _rs.getType() != ResultSet.TYPE_FORWARD_ONLY;\n+    }\n+\n+    protected boolean absoluteInternal(int row)\n+        throws SQLException {\n+        if (row == ++_row)\n+            return _rs.next();\n+\n+        // random access\n+        _rs.absolute(row + 1);\n+        if (_rs.getRow() == 0) {\n+            _row = -1;\n+            return false;\n+        }\n+        _row = row;\n+        return true;\n+    }\n+\n+    protected boolean nextInternal()\n+        throws SQLException {\n+        _row++;\n+        return _rs.next();\n+    }\n+\n+    public int size()\n+        throws SQLException {\n+        if (_size == -1) {\n+            _rs.last();\n+            _size = _rs.getRow();\n+            if (_row == -1)\n+                _rs.beforeFirst();\n+            else\n+                _rs.absolute(_row + 1);\n+        }\n+        return _size;\n+    }\n+\n+    protected boolean containsInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return ((Number) translate(obj, joins)).intValue() > 0;\n+    }\n+\n+    protected Array getArrayInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getArray(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected InputStream getAsciiStreamInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getAsciiStream(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected BigDecimal getBigDecimalInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getBigDecimal(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected Number getNumberInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getNumber(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected BigInteger getBigIntegerInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getBigInteger(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected InputStream getBinaryStreamInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getBinaryStream(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected Blob getBlobInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getBlob(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected boolean getBooleanInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getBoolean(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected byte getByteInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getByte(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected byte[] getBytesInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getBytes(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected Calendar getCalendarInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getCalendar(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected char getCharInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getChar(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected Reader getCharacterStreamInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getCharacterStream(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected Clob getClobInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getClob(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected Date getDateInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getDate(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected java.sql.Date getDateInternal(Object obj, Calendar cal,\n+        Joins joins)\n+        throws SQLException {\n+        return _dict.getDate(_rs, ((Number) obj).intValue(), cal);\n+    }\n+\n+    protected double getDoubleInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getDouble(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected float getFloatInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getFloat(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected int getIntInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getInt(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected Locale getLocaleInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getLocale(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected long getLongInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getLong(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected Object getStreamInternal(JDBCStore store, Object obj,\n+        int metaTypeCode, Object arg, Joins joins) throws SQLException {\n+        return getLOBStreamInternal(store, obj, joins);\n+    }\n+    \n+    protected Object getObjectInternal(Object obj, int metaTypeCode,\n+        Object arg, Joins joins)\n+        throws SQLException {\n+        if (metaTypeCode == -1 && obj instanceof Column)\n+            metaTypeCode = ((Column) obj).getJavaType();\n+\n+        Object val = null;\n+        switch (metaTypeCode) {\n+            case JavaTypes.BOOLEAN:\n+            case JavaTypes.BOOLEAN_OBJ:\n+                val = (getBooleanInternal(obj, joins)) ? Boolean.TRUE\n+                    : Boolean.FALSE;\n+                break;\n+            case JavaTypes.BYTE:\n+            case JavaTypes.BYTE_OBJ:\n+                val = new Byte(getByteInternal(obj, joins));\n+                break;\n+            case JavaTypes.CHAR:\n+            case JavaTypes.CHAR_OBJ:\n+                val = new Character(getCharInternal(obj, joins));\n+                break;\n+            case JavaTypes.DOUBLE:\n+            case JavaTypes.DOUBLE_OBJ:\n+                val = new Double(getDoubleInternal(obj, joins));\n+                break;\n+            case JavaTypes.FLOAT:\n+            case JavaTypes.FLOAT_OBJ:\n+                val = new Float(getFloatInternal(obj, joins));\n+                break;\n+            case JavaTypes.INT:\n+            case JavaTypes.INT_OBJ:\n+                val = Numbers.valueOf(getIntInternal(obj, joins));\n+                break;\n+            case JavaTypes.LONG:\n+            case JavaTypes.LONG_OBJ:\n+                val = Numbers.valueOf(getLongInternal(obj, joins));\n+                break;\n+            case JavaTypes.SHORT:\n+            case JavaTypes.SHORT_OBJ:\n+                val = new Short(getShortInternal(obj, joins));\n+                break;\n+            case JavaTypes.STRING:\n+                return getStringInternal(obj, joins);\n+            case JavaTypes.OBJECT:\n+                return _dict\n+                    .getBlobObject(_rs, ((Number) obj).intValue(), _store);\n+            case JavaTypes.DATE:\n+                return getDateInternal(obj, joins);\n+            case JavaTypes.CALENDAR:\n+                return getCalendarInternal(obj, joins);\n+            case JavaTypes.BIGDECIMAL:\n+                return getBigDecimalInternal(obj, joins);\n+            case JavaTypes.NUMBER:\n+                return getNumberInternal(obj, joins);\n+            case JavaTypes.BIGINTEGER:\n+                return getBigIntegerInternal(obj, joins);\n+            case JavaTypes.LOCALE:\n+                return getLocaleInternal(obj, joins);\n+            case JavaSQLTypes.SQL_ARRAY:\n+                return getArrayInternal(obj, joins);\n+            case JavaSQLTypes.ASCII_STREAM:\n+                return getAsciiStreamInternal(obj, joins);\n+            case JavaSQLTypes.BINARY_STREAM:\n+                return getBinaryStreamInternal(obj, joins);\n+            case JavaSQLTypes.BLOB:\n+                return getBlobInternal(obj, joins);\n+            case JavaSQLTypes.BYTES:\n+                return getBytesInternal(obj, joins);\n+            case JavaSQLTypes.CHAR_STREAM:\n+                return getCharacterStreamInternal(obj, joins);\n+            case JavaSQLTypes.CLOB:\n+                return getClobInternal(obj, joins);\n+            case JavaSQLTypes.SQL_DATE:\n+                return getDateInternal(obj, (Calendar) arg, joins);\n+            case JavaSQLTypes.SQL_OBJECT:\n+                return getSQLObjectInternal(obj, (Map) arg, joins);\n+            case JavaSQLTypes.REF:\n+                return getRefInternal(obj, (Map) arg, joins);\n+            case JavaSQLTypes.TIME:\n+                return getTimeInternal(obj, (Calendar) arg, joins);\n+            case JavaSQLTypes.TIMESTAMP:\n+                return getTimestampInternal(obj, (Calendar) arg, joins);\n+            default:\n+                if (obj instanceof Column) {\n+                    Column col = (Column) obj;\n+                    if (col.getType() == Types.BLOB\n+                        || col.getType() == Types.VARBINARY) {\n+                        return _dict\n+                            .getBlobObject(_rs, col.getIndex(), _store);\n+                    }\n+                }\n+                return _dict.getObject(_rs, ((Number) obj).intValue(), null);\n+        }\n+        return (_rs.wasNull()) ? null : val;\n+    }\n+\n+    protected Object getSQLObjectInternal(Object obj, Map map, Joins joins)\n+        throws SQLException {\n+        return _dict.getObject(_rs, ((Number) obj).intValue(), map);\n+    }\n+\n+    protected Ref getRefInternal(Object obj, Map map, Joins joins)\n+        throws SQLException {\n+        return _dict.getRef(_rs, ((Number) obj).intValue(), map);\n+    }\n+\n+    protected short getShortInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        return _dict.getShort(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected String getStringInternal(Object obj, Joins joins)\n+        throws SQLException {\n+        if (obj instanceof Column && ((Column) obj).getType() == Types.CLOB)\n+            return _dict.getClobString(_rs, ((Column) obj).getIndex());\n+        return _dict.getString(_rs, ((Number) obj).intValue());\n+    }\n+\n+    protected Time getTimeInternal(Object obj, Calendar cal, Joins joins)\n+        throws SQLException {\n+        return _dict.getTime(_rs, ((Number) obj).intValue(), cal);\n+    }\n+\n+    protected Timestamp getTimestampInternal(Object obj, Calendar cal,\n+        Joins joins)\n+        throws SQLException {\n+        return _dict.getTimestamp(_rs, ((Number) obj).intValue(), cal);\n+    }\n+\n+    public boolean wasNull()\n+        throws SQLException {\n+        return _rs.wasNull();\n+    }\n+\n+    protected Object translate(Object obj, Joins joins)\n+        throws SQLException {\n+        if (obj instanceof Number)\n+            return obj;\n+        return Numbers.valueOf(findObject(obj, joins));\n+    }\n+\n+    /**\n+     * Return the 1-based result set index for the given column or id, or a\n+     * non-positive number if the column is not contained in this result.\n+     */\n+    protected int findObject(Object obj, Joins joins)\n+        throws SQLException {\n+        try {\n+            return getResultSet().findColumn(obj.toString());\n+        } catch (SQLException se) {\n+            return 0;\n+        }\n+    }\n+  \n+    protected InputStream getLOBStreamInternal(JDBCStore store, Object obj,\n+        Joins joins) throws SQLException {\n+        return _dict.getLOBStream(store, _rs, ((Number) obj).intValue());\n+    }\n+}"},{"sha":"7e77eb4c63c97afd418895c2fc2891a4b876efc1","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Row.java","status":"added","additions":523,"deletions":0,"changes":523,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Row.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Row.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Row.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,523 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import org.apache.openjpa.jdbc.meta.RelationId;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * Logical representation of a table row for insert/update/delete. The\n+ * {@link org.apache.openjpa.jdbc.kernel.UpdateManager} is responsible for implementing\n+ * rows to do something useful when the values are set.\n+ *\n+ * @author Abe White\n+ */\n+public interface Row {\n+\n+    /**\n+     * Symbolic constant reserved for situations when a row operation\n+     * is unknown.\n+     */\n+    public static final int ACTION_UNKNOWN = -1;\n+\n+    /**\n+     * Mark the row for update.\n+     */\n+    public static final int ACTION_UPDATE = 0;\n+\n+    /**\n+     * Mark the row for inserttion.\n+     */\n+    public static final int ACTION_INSERT = 1;\n+\n+    /**\n+     * Mark the row for deletion.\n+     */\n+    public static final int ACTION_DELETE = 2;\n+\n+    /**\n+     * Return the table for this row.\n+     */\n+    public Table getTable();\n+\n+    /**\n+     * Return the action for this row.\n+     */\n+    public int getAction();\n+\n+    /**\n+     * Return the failed object to include in optimistic lock exceptions.\n+     */\n+    public Object getFailedObject();\n+\n+    /**\n+     * Set the failed object to include in the optimistic lock exception\n+     * that will be thrown if this update results in an update count of 0\n+     * when executed. Leave null to avoid checking the update count.\n+     */\n+    public void setFailedObject(Object failed);\n+\n+    /**\n+     * Whether this row has information set on it.\n+     */\n+    public boolean isValid();\n+\n+    /**\n+     * Whether this row has information set on it.\n+     */\n+    public void setValid(boolean valid);\n+\n+    /**\n+     * Return the instance that controls this row. The\n+     * {@link #setPrimaryKey} method does not necessarily have to be called\n+     * to know the owning instance, nor does this row's table have to have\n+     * an actual primary key.\n+     */\n+    public OpenJPAStateManager getPrimaryKey();\n+\n+    /**\n+     * Set the primary key to represent the given object.\n+     */\n+    public void setPrimaryKey(OpenJPAStateManager sm)\n+        throws SQLException;\n+\n+    /**\n+     * Set the primary key to represent the given object.\n+     *\n+     * @param io information on which columns are settable; may be null\n+     */\n+    public void setPrimaryKey(ColumnIO io, OpenJPAStateManager sm)\n+        throws SQLException;\n+\n+    /**\n+     * Set the primary key equality criteria for this row.\n+     */\n+    public void wherePrimaryKey(OpenJPAStateManager sm)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given foreign key to the given object.\n+     * If the related type uses table-per-class mappings, the foreign key may\n+     * be targeted at an independent superclass table.\n+     */\n+    public void setForeignKey(ForeignKey fk, OpenJPAStateManager sm)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given foreign key to the given object.\n+     * If the related type uses table-per-class mappings, the foreign key may\n+     * be targeted at an independent superclass table.\n+     *\n+     * @param io information on which columns are settable; may be null\n+     */\n+    public void setForeignKey(ForeignKey fk, ColumnIO io,\n+        OpenJPAStateManager sm)\n+        throws SQLException;\n+\n+    /**\n+     * Set the foreign key equality criteria to link to the given object.\n+     * If the related type uses table-per-class mappings, the foreign key may\n+     * be targeted at an independent superclass table.\n+     */\n+    public void whereForeignKey(ForeignKey fk, OpenJPAStateManager sm)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setArray(Column col, Array val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setAsciiStream(Column col, InputStream val, int length)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setBigDecimal(Column col, BigDecimal val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setBigInteger(Column col, BigInteger val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setBinaryStream(Column col, InputStream val, int length)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setBlob(Column col, Blob val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setBoolean(Column col, boolean val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setByte(Column col, byte val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setBytes(Column col, byte[] val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setCalendar(Column col, Calendar val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setChar(Column col, char val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setCharacterStream(Column col, Reader val, int length)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setClob(Column col, Clob val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setDate(Column col, Date val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setDate(Column col, java.sql.Date val, Calendar cal)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setDouble(Column col, double val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setFloat(Column col, float val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setInt(Column col, int val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setLong(Column col, long val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setLocale(Column col, Locale val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setNull(Column col)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     *\n+     * @param overrideDefault whether to set this column to null even if this\n+     * is an insert and the column has a default\n+     */\n+    public void setNull(Column col, boolean overrideDefault)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setNumber(Column col, Number val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     *\n+     * @param col the column being set\n+     * @param val the value for the column\n+     */\n+    public void setObject(Column col, Object val)\n+        throws SQLException;\n+\n+    /**\n+     * Set a DB understood value for the given column.\n+     * The value will not be parameterized and instead be inserted as raw SQL.\n+     */\n+    public void setRaw(Column col, String value)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column to the identity of given instance,\n+     * using the given callback to create the column value. This method is\n+     * used for mappings that store some serialized form of id values, but must\n+     * make sure that the related object's id is assigned (which might\n+     * require an insert if the instance uses auto-increment) before it is\n+     * serialized.\n+     */\n+    public void setRelationId(Column col, OpenJPAStateManager sm,\n+        RelationId rel)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setShort(Column col, short val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setString(Column col, String val)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setTime(Column col, Time val, Calendar cal)\n+        throws SQLException;\n+\n+    /**\n+     * Set the value of the given column in this row.\n+     */\n+    public void setTimestamp(Column col, Timestamp val, Calendar cal)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereArray(Column col, Array val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereAsciiStream(Column col, InputStream val, int length)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereBigDecimal(Column col, BigDecimal val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereBigInteger(Column col, BigInteger val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereBinaryStream(Column col, InputStream val, int length)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereBlob(Column col, Blob val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereBoolean(Column col, boolean val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereByte(Column col, byte val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereBytes(Column col, byte[] val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereCalendar(Column col, Calendar val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereChar(Column col, char val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereCharacterStream(Column col, Reader val, int length)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereClob(Column col, Clob val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereDate(Column col, Date val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereDate(Column col, java.sql.Date val, Calendar cal)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereDouble(Column col, double val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereFloat(Column col, float val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereInt(Column col, int val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereLong(Column col, long val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereLocale(Column col, Locale val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereNull(Column col)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereNumber(Column col, Number val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     *\n+     * @param col the column being set\n+     * @param val the value for the column\n+     */\n+    public void whereObject(Column col, Object val)\n+        throws SQLException;\n+\n+    /**\n+     * Set a DB understood where condition for the given column.\n+     * The value will not be parameterized and instead be inserted as raw SQL.\n+     */\n+    public void whereRaw(Column col, String value)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereShort(Column col, short val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereString(Column col, String val)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereTime(Column col, Time val, Calendar cal)\n+        throws SQLException;\n+\n+    /**\n+     * Set an equality condition on the value of the given column in this row.\n+     */\n+    public void whereTimestamp(Column col, Timestamp val, Calendar cal)\n+        throws SQLException;\n+}"},{"sha":"b59a47c531612cf92cf22d742f26a08e264bb62d","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java","status":"added","additions":963,"deletions":0,"changes":963,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,963 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Locale;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n+import org.apache.openjpa.jdbc.meta.Joinable;\n+import org.apache.openjpa.jdbc.meta.RelationId;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.InternalException;\n+import serp.util.Numbers;\n+\n+/**\n+ * Basic {@link Row} implementation.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class RowImpl\n+    implements Row, Cloneable {\n+\n+    public static final Object NULL = new Object();\n+    protected static final int VALID = 2 << 0;\n+\n+    public static final int RAW = Integer.MIN_VALUE;\n+\n+    protected byte flags = 0;\n+    private final Column[] _cols;\n+    private final int _action;\n+    private final Object[] _vals;\n+    private final int[] _types;\n+\n+    private String _sql = null;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param table the table the row is a part of\n+     * @param action the action on the row\n+     */\n+    public RowImpl(Table table, int action) {\n+        this(table.getColumns(), action);\n+    }\n+\n+    protected RowImpl(Column[] cols, int action) {\n+        _cols = cols;\n+        _action = action;\n+\n+        // we need room for values and types for all columns; if an update or\n+        // delete, then we need to double that for where column conditions\n+        int len = _cols.length;\n+        if (action != ACTION_INSERT)\n+            len *= 2;\n+        _vals = new Object[len];\n+        _types = new int[len];\n+    }\n+\n+    public Table getTable() {\n+        return _cols[0].getTable();\n+    }\n+\n+    public Column[] getColumns() {\n+        return _cols;\n+    }\n+\n+    public int getAction() {\n+        return _action;\n+    }\n+\n+    public boolean isValid() {\n+        return (flags & VALID) != 0;\n+    }\n+\n+    public void setValid(boolean valid) {\n+        if (valid)\n+            flags |= VALID;\n+        else\n+            flags &= ~VALID;\n+    }\n+\n+    /**\n+     * This implementation does not track primary keys.\n+     */\n+    public OpenJPAStateManager getPrimaryKey() {\n+        return null;\n+    }\n+\n+    /**\n+     * This implementation does not track failed objects.\n+     */\n+    public Object getFailedObject() {\n+        return null;\n+    }\n+\n+    /**\n+     * This implementation does not track failed objects.\n+     */\n+    public void setFailedObject(Object failed) {\n+        throw new InternalException();\n+    }\n+\n+    /**\n+     * Secondary rows cannot be dependent.\n+     */\n+    public boolean isDependent() {\n+        return false;\n+    }\n+\n+    /**\n+     * Return the value set for update on the given column.\n+     */\n+    public Object getSet(Column col) {\n+        return _vals[getSetIndex(col)];\n+    }\n+\n+    /**\n+     * Return the value set for where on the given column.\n+     */\n+    public Object getWhere(Column col) {\n+        return _vals[getWhereIndex(col)];\n+    }\n+\n+    public void setPrimaryKey(OpenJPAStateManager sm)\n+        throws SQLException {\n+        setPrimaryKey(null, sm);\n+    }\n+\n+    public void setPrimaryKey(ColumnIO io, OpenJPAStateManager sm)\n+        throws SQLException {\n+        flushPrimaryKey(sm, io, true);\n+    }\n+\n+    public void wherePrimaryKey(OpenJPAStateManager sm)\n+        throws SQLException {\n+        flushPrimaryKey(sm, null, false);\n+    }\n+\n+    /**\n+     * Flush the primary key values.\n+     */\n+    private void flushPrimaryKey(OpenJPAStateManager sm, ColumnIO io,\n+        boolean set)\n+        throws SQLException {\n+        ClassMapping mapping = (ClassMapping) sm.getMetaData();\n+        while (mapping.getTable() != getTable())\n+            mapping = mapping.getPCSuperclassMapping();\n+        Column[] cols = mapping.getPrimaryKeyColumns();\n+        flushJoinValues(sm, cols, cols, io, set);\n+    }\n+\n+    public void setForeignKey(ForeignKey fk, OpenJPAStateManager sm)\n+        throws SQLException {\n+        setForeignKey(fk, null, sm);\n+    }\n+\n+    public void setForeignKey(ForeignKey fk, ColumnIO io,\n+        OpenJPAStateManager sm)\n+        throws SQLException {\n+        flushForeignKey(fk, io, sm, true);\n+    }\n+\n+    public void whereForeignKey(ForeignKey fk, OpenJPAStateManager sm)\n+        throws SQLException {\n+        flushForeignKey(fk, null, sm, false);\n+    }\n+\n+    /**\n+     * Clear a circular foreign key.\n+     */\n+    public void clearForeignKey(ForeignKey fk)\n+        throws SQLException {\n+        _sql = null;\n+        Column[] cols = fk.getColumns();\n+        for (int i = 0; i < cols.length; i++)\n+            _vals[getSetIndex(cols[i])] = null;\n+    }\n+\n+    /**\n+     * Flush the foreign key values.\n+     */\n+    private void flushForeignKey(ForeignKey fk, ColumnIO io,\n+        OpenJPAStateManager sm, boolean set)\n+        throws SQLException {\n+        flushJoinValues(sm, fk.getPrimaryKeyColumns(), fk.getColumns(),\n+            io, set);\n+        if (sm != null) {\n+            Column[] cols = fk.getConstantColumns();\n+            int len = fk.getColumns().length;\n+            Object obj;\n+            int type;\n+            for (int i = 0; i < cols.length; i++) {\n+                obj = fk.getConstant(cols[i]);\n+                type = cols[i].getJavaType();\n+                if (set && canSet(io, i + len, obj == null))\n+                    setObject(cols[i], obj, type, false);\n+                else if (!set)\n+                    whereObject(cols[i], obj, type);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Flush the given instance value to the given columns. Note that\n+     * foreign keys may include columns also mapped by simple values. We\n+     * use a priority mechanism to ensure that we do not let the nulling\n+     * of a foreign key null columns also owned by simple values.\n+     *\n+     * @param to the instance being joined to\n+     * @param toCols the columns being joined to\n+     * @param fromCols the columns being joined from\n+     * @param io information about I/O capabilities in this context\n+     * @param set whether this should be flushed as an update or\n+     * as a where condition\n+     */\n+    private void flushJoinValues(OpenJPAStateManager to, Column[] toCols,\n+        Column[] fromCols, ColumnIO io, boolean set)\n+        throws SQLException {\n+        if (to == null) {\n+            for (int i = 0; i < fromCols.length; i++) {\n+                if (set && canSet(io, i, true))\n+                    setNull(fromCols[i]);\n+                else if (!set)\n+                    whereNull(fromCols[i]);\n+            }\n+            return;\n+        }\n+        if (set && !canSetAny(io, fromCols.length, false))\n+            return;\n+\n+        ClassMapping toMapping = (ClassMapping) to.getMetaData();\n+        Joinable join;\n+        Object val;\n+        for (int i = 0; i < toCols.length; i++) {\n+            // don't even translate join value if unsettable\n+            if (set) {\n+                if (_action == ACTION_INSERT && fromCols[i].isAutoAssigned())\n+                    continue;\n+                if (!canSet(io, i, false))\n+                    continue;\n+            }\n+\n+            join = toMapping.assertJoinable(toCols[i]);\n+            val = join.getJoinValue(to, toCols[i], (JDBCStore) to.\n+                getContext().getStoreManager().getInnermostDelegate());\n+            if (set && val == null) {\n+                if (canSet(io, i, true))\n+                    setNull(fromCols[i]);\n+            } else if (set && val instanceof Raw)\n+                setRaw(fromCols[i], val.toString());\n+            else if (set)\n+                setObject(fromCols[i], val, toCols[i].getJavaType(), false);\n+            else if (val == null)\n+                whereNull(fromCols[i]);\n+            else if (val instanceof Raw)\n+                whereRaw(fromCols[i], val.toString());\n+            else\n+                whereObject(fromCols[i], val, toCols[i].getJavaType());\n+        }\n+    }\n+\n+    /**\n+     * Return true if any of the given column indexes are settable.\n+     */\n+    protected boolean canSetAny(ColumnIO io, int i, boolean nullValue) {\n+        if (io == null)\n+            return true;\n+        if (_action == ACTION_INSERT)\n+            return io.isAnyInsertable(i, nullValue);\n+        if (_action == ACTION_UPDATE)\n+            return io.isAnyUpdatable(i, nullValue);\n+        return true;\n+    }\n+\n+    /**\n+     * Return true if the given column index is settable.\n+     */\n+    protected boolean canSet(ColumnIO io, int i, boolean nullValue) {\n+        if (io == null)\n+            return true;\n+        if (_action == ACTION_INSERT)\n+            return io.isInsertable(i, nullValue);\n+        if (_action == ACTION_UPDATE)\n+            return io.isUpdatable(i, nullValue);\n+        return true;\n+    }\n+\n+    public void setRelationId(Column col, OpenJPAStateManager sm,\n+        RelationId rel)\n+        throws SQLException {\n+        setObject(col, rel.toRelationDataStoreValue(sm, col),\n+            col.getJavaType(), false);\n+    }\n+\n+    /**\n+     * Clear a circular relation id.\n+     */\n+    public void clearRelationId(Column col)\n+        throws SQLException {\n+        _sql = null;\n+        _vals[getSetIndex(col)] = null;\n+    }\n+\n+    public void setArray(Column col, Array val)\n+        throws SQLException {\n+        setObject(col, val, JavaSQLTypes.ARRAY, false);\n+    }\n+\n+    public void setAsciiStream(Column col, InputStream val, int length)\n+        throws SQLException {\n+        setObject(col, (val == null) ? null : new Sized(val, length),\n+            JavaSQLTypes.ASCII_STREAM, false);\n+    }\n+\n+    public void setBigDecimal(Column col, BigDecimal val)\n+        throws SQLException {\n+        setObject(col, val, JavaTypes.BIGDECIMAL, false);\n+    }\n+\n+    public void setBigInteger(Column col, BigInteger val)\n+        throws SQLException {\n+        setObject(col, val, JavaTypes.BIGINTEGER, false);\n+    }\n+\n+    public void setBinaryStream(Column col, InputStream val, int length)\n+        throws SQLException {\n+        setObject(col, (val == null) ? null : new Sized(val, length),\n+            JavaSQLTypes.BINARY_STREAM, false);\n+    }\n+\n+    public void setBlob(Column col, Blob val)\n+        throws SQLException {\n+        setObject(col, val, JavaSQLTypes.BLOB, false);\n+    }\n+\n+    public void setBoolean(Column col, boolean val)\n+        throws SQLException {\n+        setObject(col, ((val) ? Boolean.TRUE : Boolean.FALSE),\n+            JavaTypes.BOOLEAN, false);\n+    }\n+\n+    public void setByte(Column col, byte val)\n+        throws SQLException {\n+        setObject(col, new Byte(val), JavaTypes.BYTE, false);\n+    }\n+\n+    public void setBytes(Column col, byte[] val)\n+        throws SQLException {\n+        setObject(col, val, JavaSQLTypes.BYTES, false);\n+    }\n+\n+    public void setCalendar(Column col, Calendar val)\n+        throws SQLException {\n+        setObject(col, val, JavaTypes.CALENDAR, false);\n+    }\n+\n+    public void setChar(Column col, char val)\n+        throws SQLException {\n+        setObject(col, new Character(val), JavaTypes.CHAR, false);\n+    }\n+\n+    public void setCharacterStream(Column col, Reader val, int length)\n+        throws SQLException {\n+        setObject(col, (val == null) ? null : new Sized(val, length),\n+            JavaSQLTypes.CHAR_STREAM, false);\n+    }\n+\n+    public void setClob(Column col, Clob val)\n+        throws SQLException {\n+        setObject(col, val, JavaSQLTypes.CLOB, false);\n+    }\n+\n+    public void setDate(Column col, Date val)\n+        throws SQLException {\n+        setObject(col, val, JavaTypes.DATE, false);\n+    }\n+\n+    public void setDate(Column col, java.sql.Date val, Calendar cal)\n+        throws SQLException {\n+        Object obj;\n+        if (val == null || cal == null)\n+            obj = val;\n+        else\n+            obj = new Calendard(val, cal);\n+        setObject(col, obj, JavaSQLTypes.SQL_DATE, false);\n+    }\n+\n+    public void setDouble(Column col, double val)\n+        throws SQLException {\n+        setObject(col, new Double(val), JavaTypes.DOUBLE, false);\n+    }\n+\n+    public void setFloat(Column col, float val)\n+        throws SQLException {\n+        setObject(col, new Float(val), JavaTypes.FLOAT, false);\n+    }\n+\n+    public void setInt(Column col, int val)\n+        throws SQLException {\n+        setObject(col, Numbers.valueOf(val), JavaTypes.INT, false);\n+    }\n+\n+    public void setLong(Column col, long val)\n+        throws SQLException {\n+        setObject(col, Numbers.valueOf(val), JavaTypes.LONG, false);\n+    }\n+\n+    public void setLocale(Column col, Locale val)\n+        throws SQLException {\n+        setObject(col, val, JavaTypes.LOCALE, false);\n+    }\n+\n+    public void setNull(Column col)\n+        throws SQLException {\n+        setNull(col, false);\n+    }\n+\n+    public void setNull(Column col, boolean overrideDefault)\n+        throws SQLException {\n+        setObject(col, null, col.getJavaType(), overrideDefault);\n+    }\n+\n+    public void setNumber(Column col, Number val)\n+        throws SQLException {\n+        setObject(col, val, JavaTypes.NUMBER, false);\n+    }\n+\n+    public void setRaw(Column col, String val)\n+        throws SQLException {\n+        setObject(col, val, RAW, false);\n+    }\n+\n+    public void setShort(Column col, short val)\n+        throws SQLException {\n+        setObject(col, new Short(val), JavaTypes.SHORT, false);\n+    }\n+\n+    public void setString(Column col, String val)\n+        throws SQLException {\n+        setObject(col, val, JavaTypes.STRING, false);\n+    }\n+\n+    public void setTime(Column col, Time val, Calendar cal)\n+        throws SQLException {\n+        Object obj;\n+        if (val == null || cal == null)\n+            obj = val;\n+        else\n+            obj = new Calendard(val, cal);\n+        setObject(col, obj, JavaSQLTypes.TIME, false);\n+    }\n+\n+    public void setTimestamp(Column col, Timestamp val, Calendar cal)\n+        throws SQLException {\n+        Object obj;\n+        if (val == null || cal == null)\n+            obj = val;\n+        else\n+            obj = new Calendard(val, cal);\n+        setObject(col, obj, JavaSQLTypes.TIMESTAMP, false);\n+    }\n+\n+    public void setObject(Column col, Object val)\n+        throws SQLException {\n+        if (val instanceof Raw)\n+            setObject(col, val, RAW, false);\n+        else\n+            setObject(col, val, col.getJavaType(), false);\n+    }\n+\n+    public void whereArray(Column col, Array val)\n+        throws SQLException {\n+        whereObject(col, val, JavaSQLTypes.SQL_ARRAY);\n+    }\n+\n+    public void whereAsciiStream(Column col, InputStream val, int length)\n+        throws SQLException {\n+        whereObject(col, (val == null) ? null : new Sized(val, length),\n+            JavaSQLTypes.ASCII_STREAM);\n+    }\n+\n+    public void whereBigDecimal(Column col, BigDecimal val)\n+        throws SQLException {\n+        whereObject(col, val, JavaTypes.BIGDECIMAL);\n+    }\n+\n+    public void whereBigInteger(Column col, BigInteger val)\n+        throws SQLException {\n+        whereObject(col, val, JavaTypes.BIGINTEGER);\n+    }\n+\n+    public void whereBinaryStream(Column col, InputStream val, int length)\n+        throws SQLException {\n+        whereObject(col, (val == null) ? null : new Sized(val, length),\n+            JavaSQLTypes.BINARY_STREAM);\n+    }\n+\n+    public void whereBlob(Column col, Blob val)\n+        throws SQLException {\n+        whereObject(col, val, JavaSQLTypes.BLOB);\n+    }\n+\n+    public void whereBoolean(Column col, boolean val)\n+        throws SQLException {\n+        whereObject(col, ((val) ? Boolean.TRUE : Boolean.FALSE),\n+            JavaTypes.BOOLEAN);\n+    }\n+\n+    public void whereByte(Column col, byte val)\n+        throws SQLException {\n+        whereObject(col, new Byte(val), JavaTypes.BYTE);\n+    }\n+\n+    public void whereBytes(Column col, byte[] val)\n+        throws SQLException {\n+        whereObject(col, val, JavaSQLTypes.BYTES);\n+    }\n+\n+    public void whereCalendar(Column col, Calendar val)\n+        throws SQLException {\n+        whereObject(col, val, JavaTypes.CALENDAR);\n+    }\n+\n+    public void whereChar(Column col, char val)\n+        throws SQLException {\n+        whereObject(col, new Character(val), JavaTypes.CHAR);\n+    }\n+\n+    public void whereCharacterStream(Column col, Reader val, int length)\n+        throws SQLException {\n+        whereObject(col, (val == null) ? null : new Sized(val, length),\n+            JavaSQLTypes.CHAR_STREAM);\n+    }\n+\n+    public void whereClob(Column col, Clob val)\n+        throws SQLException {\n+        whereObject(col, val, JavaSQLTypes.CLOB);\n+    }\n+\n+    public void whereDate(Column col, Date val)\n+        throws SQLException {\n+        whereObject(col, val, JavaTypes.DATE);\n+    }\n+\n+    public void whereDate(Column col, java.sql.Date val, Calendar cal)\n+        throws SQLException {\n+        Object obj;\n+        if (val == null || cal == null)\n+            obj = val;\n+        else\n+            obj = new Calendard(val, cal);\n+        whereObject(col, obj, JavaSQLTypes.SQL_DATE);\n+    }\n+\n+    public void whereDouble(Column col, double val)\n+        throws SQLException {\n+        whereObject(col, new Double(val), JavaTypes.DOUBLE);\n+    }\n+\n+    public void whereFloat(Column col, float val)\n+        throws SQLException {\n+        whereObject(col, new Float(val), JavaTypes.FLOAT);\n+    }\n+\n+    public void whereInt(Column col, int val)\n+        throws SQLException {\n+        whereObject(col, Numbers.valueOf(val), JavaTypes.INT);\n+    }\n+\n+    public void whereLong(Column col, long val)\n+        throws SQLException {\n+        whereObject(col, Numbers.valueOf(val), JavaTypes.LONG);\n+    }\n+\n+    public void whereLocale(Column col, Locale val)\n+        throws SQLException {\n+        whereObject(col, val, JavaTypes.LOCALE);\n+    }\n+\n+    public void whereNull(Column col)\n+        throws SQLException {\n+        whereObject(col, null, col.getJavaType());\n+    }\n+\n+    public void whereNumber(Column col, Number val)\n+        throws SQLException {\n+        whereObject(col, val, JavaTypes.NUMBER);\n+    }\n+\n+    public void whereRaw(Column col, String val)\n+        throws SQLException {\n+        whereObject(col, val, RAW);\n+    }\n+\n+    public void whereShort(Column col, short val)\n+        throws SQLException {\n+        whereObject(col, new Short(val), JavaTypes.SHORT);\n+    }\n+\n+    public void whereString(Column col, String val)\n+        throws SQLException {\n+        whereObject(col, val, JavaTypes.STRING);\n+    }\n+\n+    public void whereTime(Column col, Time val, Calendar cal)\n+        throws SQLException {\n+        Object obj;\n+        if (val == null || cal == null)\n+            obj = val;\n+        else\n+            obj = new Calendard(val, cal);\n+        whereObject(col, obj, JavaSQLTypes.TIME);\n+    }\n+\n+    public void whereTimestamp(Column col, Timestamp val, Calendar cal)\n+        throws SQLException {\n+        Object obj;\n+        if (val == null || cal == null)\n+            obj = val;\n+        else\n+            obj = new Calendard(val, cal);\n+        whereObject(col, obj, JavaSQLTypes.TIMESTAMP);\n+    }\n+\n+    public void whereObject(Column col, Object val)\n+        throws SQLException {\n+        if (val instanceof Raw)\n+            whereObject(col, val, RAW);\n+        else\n+            whereObject(col, val, col.getJavaType());\n+    }\n+\n+    /**\n+     * All set column methods delegate to this one. Set the given object\n+     * unless this is an insert and the given column is auto-assigned.\n+     */\n+    protected void setObject(Column col, Object val, int metaType,\n+        boolean overrideDefault)\n+        throws SQLException {\n+        // never set auto increment columns and honor column defaults\n+        if (_action == ACTION_INSERT) {\n+            if (col.isAutoAssigned()) {\n+            \t// OPENJPA-349: validate because this can be the only column\n+            \tsetValid(true);\n+                return;\n+            }\n+            if (!overrideDefault && val == null \n+                && col.getDefaultString() != null)\n+                return;\n+        }\n+        if (val == null && col.isNotNull())\n+            val = JavaSQLTypes.getEmptyValue(col.getJavaType());\n+        flush(col, val, metaType, true);\n+    }\n+\n+    /**\n+     * All where column methods delegate to this one.\n+     */\n+    protected void whereObject(Column col, Object val, int metaType)\n+        throws SQLException {\n+        flush(col, val, metaType, false);\n+    }\n+\n+    /**\n+     * Flush the given value as a set or where condition.\n+     */\n+    private void flush(Column col, Object val, int metaType, boolean set) {\n+        int idx = (set) ? getSetIndex(col) : getWhereIndex(col);\n+        _types[idx] = metaType;\n+        if (val == null)\n+            _vals[idx] = NULL;\n+        else\n+            _vals[idx] = val;\n+        if (set || _action == ACTION_DELETE)\n+            setValid(true);\n+    }\n+\n+    /**\n+     * Return the SQL for the operation on this row.\n+     */\n+    public String getSQL(DBDictionary dict) {\n+        if (!isValid())\n+            return \"\";\n+        if (_sql == null)\n+            _sql = generateSQL(dict);\n+        return _sql;\n+    }\n+\n+    /**\n+     * Generate the SQL for this row; the result of this method is cached.\n+     */\n+    protected String generateSQL(DBDictionary dict) {\n+        switch (getAction()) {\n+            case ACTION_UPDATE:\n+                return getUpdateSQL(dict);\n+            case ACTION_INSERT:\n+                return getInsertSQL(dict);\n+            default:\n+                return getDeleteSQL(dict);\n+        }\n+    }\n+\n+    /**\n+     * Return the SQL for a prepared statement update on this row.\n+     */\n+    private String getUpdateSQL(DBDictionary dict) {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"UPDATE \").append(dict.getFullName(getTable(), false)).\n+            append(\" SET \");\n+\n+        boolean hasVal = false;\n+        for (int i = 0; i < _cols.length; i++) {\n+            if (_vals[i] == null)\n+                continue;\n+\n+            if (hasVal)\n+                buf.append(\", \");\n+            buf.append(_cols[i]);\n+            if (_types[i] == RAW)\n+                buf.append(\" = \").append(_vals[i]);\n+            else\n+                buf.append(\" = ?\");\n+            hasVal = true;\n+        }\n+\n+        appendWhere(buf, dict);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Return the SQL for a prepared statement insert on this row.\n+     */\n+    private String getInsertSQL(DBDictionary dict) {\n+        StringBuffer buf = new StringBuffer();\n+        StringBuffer vals = new StringBuffer();\n+        buf.append(\"INSERT INTO \").\n+            append(dict.getFullName(getTable(), false)).append(\" (\");\n+\n+        boolean hasVal = false;\n+        for (int i = 0; i < _cols.length; i++) {\n+            if (_vals[i] == null)\n+                continue;\n+\n+            if (hasVal) {\n+                buf.append(\", \");\n+                vals.append(\", \");\n+            }\n+            buf.append(_cols[i]);\n+            if (_types[i] == RAW)\n+                vals.append(_vals[i]);\n+            else\n+                vals.append(\"?\");\n+            hasVal = true;\n+        }\n+\n+        buf.append(\") VALUES (\").append(vals.toString()).append(\")\");\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Return the SQL for a prepared statement delete on this row.\n+     */\n+    private String getDeleteSQL(DBDictionary dict) {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"DELETE FROM \").\n+            append(dict.getFullName(getTable(), false));\n+        appendWhere(buf, dict);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Appends the where clause onto the given sql buffer.\n+     */\n+    private void appendWhere(StringBuffer buf, DBDictionary dict) {\n+        boolean hasWhere = false;\n+        for (int i = 0; i < _cols.length; i++) {\n+            if (_vals[getWhereIndex(_cols[i])] == null)\n+                continue;\n+\n+            if (!hasWhere)\n+                buf.append(\" WHERE \");\n+            else\n+                buf.append(\" AND \");\n+\n+            // Get platform specific version column name\n+            if (_cols[i].getVersionStrategy() != null)\n+               buf.append(dict.getVersionColumn(_cols[i], _cols[i]\n+                   .getTableName())).append(\" = ?\");\n+            // sqlserver seems to have problems using null parameters in the\n+            // where clause\n+            else if (_vals[getWhereIndex(_cols[i])] == NULL)\n+                buf.append(_cols[i]).append(\" IS NULL\");\n+            else if (_types[i] == RAW)\n+                buf.append(_cols[i]).append(\" = \").append(_vals[i]);\n+            else\n+                buf.append(_cols[i]).append(\" = ?\");\n+            hasWhere = true;\n+        }\n+    }\n+\n+    /**\n+     * The number of parameters that will be set for this row.\n+     */\n+    public int getParameterCount() {\n+        return _vals.length;\n+    }\n+\n+    /**\n+     * Flush the row's values to the given prepared statement.\n+     */\n+    public void flush(PreparedStatement stmnt, DBDictionary dict,\n+        JDBCStore store)\n+        throws SQLException {\n+        flush(stmnt, 1, dict, store);\n+    }\n+\n+    /**\n+     * Flush the row's values to the given prepared statement.\n+     */\n+    public void flush(PreparedStatement stmnt, int idx, DBDictionary dict,\n+        JDBCStore store)\n+        throws SQLException {\n+\n+        // this simple method works because the SQL is always prepared\n+        // based on the indexing of the columns in the table object -- the\n+        // same ordering we use when storing values and meta types. skip\n+        // updates when setting params for DELETEs; the updates are just there\n+        // to let us eval fk constraints\n+        int i = (getAction() == ACTION_DELETE) ? _cols.length: 0;\n+        Column col;\n+        Object val;\n+        int half = _vals.length / 2;\n+        for (; i < _vals.length; i++) {\n+            if (_vals[i] == null)\n+                continue;\n+\n+            // we don't set null params in the WHERE clause; we use the NULL\n+            // keyword instead to satisfy sqlserver\n+            if (_vals[i] == NULL && getAction() != ACTION_INSERT && i >= half)\n+                continue;\n+\n+            // if this is an update the vals array will be 2 x the cols\n+            // array length; it repeats for where values\n+            if (i < _cols.length)\n+                col = _cols[i];\n+            else\n+                col = _cols[i - _cols.length];\n+\n+            val = _vals[i];\n+            if (val == NULL)\n+                val = null;\n+\n+            if (val == null || _types[i] != RAW) {\n+                dict.setTyped(stmnt, idx, val, col, _types[i], store);\n+                idx++;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * The array value array index for the given column's value.\n+     */\n+    private int getSetIndex(Column col) {\n+        return col.getIndex();\n+    }\n+\n+    /**\n+     * The array value array index for the given column's value.\n+     */\n+    private int getWhereIndex(Column col) {\n+        return col.getIndex() + _cols.length;\n+    }\n+\n+    /**\n+     * Performs a proper deep clone.\n+     */\n+    public Object clone() {\n+        RowImpl clone = newInstance(getColumns(), getAction());\n+        copyInto(clone, false);\n+        return clone;\n+    }\n+\n+    /**\n+     * Return a new row.\n+     */\n+    protected RowImpl newInstance(Column[] cols, int action) {\n+        return new RowImpl(cols, action);\n+    }\n+\n+    /**\n+     * Copy all values from this row into the given one.\n+     *\n+     * @param whereOnly if true, only copy where conditions\n+     */\n+    public void copyInto(RowImpl row, boolean whereOnly) {\n+        int action = getAction();\n+        int rowAction = row.getAction();\n+\n+        int start;\n+        int len;\n+        if (whereOnly) {\n+            if (action == ACTION_INSERT || rowAction == ACTION_INSERT)\n+                start = len = 0;\n+            else\n+                start = len = _vals.length / 2;\n+        } else {\n+            start = 0;\n+            if (rowAction == ACTION_INSERT && action != ACTION_INSERT)\n+                len = _vals.length / 2;\n+            else\n+                len = _vals.length;\n+        }\n+\n+        System.arraycopy(_vals, start, row._vals, start, len);\n+        System.arraycopy(_types, start, row._types, start, len);\n+        if (isValid())\n+            row.setValid(true);\n+    }\n+    \n+    public Object[] getVals() {\n+        return _vals;\n+    }\n+    \n+    public int[] getTypes() {\n+        return _types;\n+    }\n+}"},{"sha":"fd8417a9526d9fae0625335dce915bee1bd06e1f","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManager.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * Manages rows during an insert/update/delete process. Row managers\n+ * do not have to be threadsafe.\n+ *\n+ * @author Abe White\n+ */\n+public interface RowManager {\n+\n+    /**\n+     * Return the row for the given table and owner object, or null if\n+     * <code>create</code> is false and the row has not already been created.\n+     * The action must be one of {@link Row#ACTION_INSERT},\n+     * {@link Row#ACTION_UPDATE}, {@link Row#ACTION_DELETE}.\n+     */\n+    public Row getRow(Table table, int action, OpenJPAStateManager sm,\n+        boolean create);\n+\n+    /**\n+     * Return a row for the given secondary table.\n+     * The action must be one of {@link Row#ACTION_INSERT},\n+     * {@link Row#ACTION_UPDATE}, {@link Row#ACTION_DELETE}.\n+     * Note that secondary rows are not considered when creating the foreign\n+     * key dependency graph, with can cause constraint violations when using\n+     * the <code>UPDATE</code> action. Only use this action if the secondary\n+     * row does not have restrict-action foreign keys. Otherwise use both\n+     * a delete and then an insert to perform the update.\n+     */\n+    public Row getSecondaryRow(Table table, int action);\n+\n+    /**\n+     * Flush the secondary row; after flushing the row is available for reuse.\n+     * It will retain all previously set values.\n+     */\n+    public void flushSecondaryRow(Row row)\n+        throws SQLException;\n+\n+    /**\n+     * Return a logical row representing an update that should be made to\n+     * all rows of the given table. The action must be one of\n+     * {@link Row#ACTION_UPDATE}, {@link Row#ACTION_DELETE}.\n+     */\n+    public Row getAllRows(Table table, int action);\n+\n+    /**\n+     * Flush the logical row.\n+     */\n+    public void flushAllRows(Row row)\n+        throws SQLException;\n+}"},{"sha":"47a0b513661698ef82acaa6cf49d648b87a90650","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManagerImpl.java","status":"added","additions":294,"deletions":0,"changes":294,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowManagerImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.util.InternalException;\n+\n+/**\n+ * Manages SQL rows during an insert/update/delete process.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class RowManagerImpl\n+    implements RowManager {\n+\n+    private Map<Key, PrimaryRow> _inserts = null;\n+    private Map<Key, PrimaryRow> _updates = null;\n+    private Map<Key, PrimaryRow> _deletes = null;\n+    private Collection<SecondaryRow> _secondaryUpdates = null;\n+    private Collection<SecondaryRow> _secondaryDeletes = null;\n+    private Collection<Row> _allRowUpdates = null;\n+    private Collection<Row> _allRowDeletes = null;\n+\n+    // we maintain a list of the order of all primary rows if the user\n+    // wants to be able to fetch them in order\n+    private final List<PrimaryRow> _primaryOrder;\n+\n+    // track whether we're dealing with any auto-inc columns\n+    private boolean _auto = false;\n+\n+    // cache the last key and primary row; when looping over\n+    // all the field mappings of a class each one will probably ask for the\n+    // same key, so avoid the key creation and row lookup when possible\n+    private Key _key = null;\n+    private PrimaryRow _row = null;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param order whether to keep track of the order in which rows are added\n+     */\n+    public RowManagerImpl(boolean order) {\n+        _primaryOrder = (order) ? new ArrayList<PrimaryRow>() : null;\n+    }\n+\n+    /**\n+     * Whether any primary rows have auto-assign constraints.\n+     */\n+    public boolean hasAutoAssignConstraints() {\n+        return _auto;\n+    }\n+\n+    /**\n+     * Return the ordered primary rows. Only available if ordering requested\n+     * on construction.\n+     */\n+    public List<PrimaryRow> getOrdered() {\n+        if(_primaryOrder == null ) { \n+            return Collections.emptyList();\n+        }\n+        else { \n+            return _primaryOrder;\n+        }\n+    }\n+\n+    /**\n+     * Return all inserted primary rows.\n+     */\n+    public Collection<PrimaryRow> getInserts() {\n+        if(_inserts == null ) {\n+            return Collections.emptyList();\n+        }\n+        else {\n+            return _inserts.values();\n+        }\n+    }\n+\n+    /**\n+     * Return all updated primary rows.\n+     */\n+    public Collection<PrimaryRow> getUpdates() {\n+        if(_updates == null ){ \n+            return Collections.emptyList();\n+        }\n+        else { \n+            return _updates.values();\n+        }\n+    }\n+\n+    /**\n+     * Return all deleted primary rows.\n+     */\n+    public Collection<PrimaryRow> getDeletes() {\n+        if(_deletes == null) { \n+            return Collections.emptyList();\n+        }\n+        else {\n+            return _deletes.values();\n+        }\n+    }\n+\n+    /**\n+     * Return all inserted and updated secondary rows.\n+     */\n+    public Collection<SecondaryRow> getSecondaryUpdates() {\n+        if(_secondaryUpdates == null) { \n+            return Collections.emptyList();\n+        }\n+        else { \n+            return _secondaryUpdates;\n+        }\n+    }\n+\n+    /**\n+     * Return all deleted secondary rows.\n+     */\n+    public Collection<SecondaryRow> getSecondaryDeletes() {\n+        if(_secondaryDeletes == null) { \n+            return Collections.emptyList();\n+        }\n+        else { \n+            return _secondaryDeletes;\n+        }\n+    }\n+\n+    /**\n+     * Return any 'all row' updates.\n+     */\n+    public Collection<Row> getAllRowUpdates() {\n+        if(_allRowUpdates == null) { \n+            return Collections.emptyList();\n+        }\n+        else { \n+            return _allRowUpdates;\n+        }\n+    }\n+\n+    /**\n+     * Return any 'all row' deletes.\n+     */\n+    public Collection<Row> getAllRowDeletes() {\n+        if(_allRowDeletes == null) { \n+            return Collections.emptyList();\n+        }\n+        else { \n+            return _allRowDeletes;\n+        }\n+        \n+    }\n+\n+    public Row getSecondaryRow(Table table, int action) {\n+        return new SecondaryRow(table, action);\n+    }\n+\n+    public void flushSecondaryRow(Row row)\n+        throws SQLException {\n+        if (!row.isValid())\n+            return;\n+\n+        SecondaryRow srow = (SecondaryRow) row;\n+        if (srow.getAction() == Row.ACTION_DELETE) {\n+            if (_secondaryDeletes == null)\n+                _secondaryDeletes = new ArrayList<SecondaryRow>();\n+            _secondaryDeletes.add((SecondaryRow) srow.clone());\n+        } else {\n+            if (_secondaryUpdates == null)\n+                _secondaryUpdates = new ArrayList<SecondaryRow>();\n+            _secondaryUpdates.add((SecondaryRow) srow.clone());\n+        }\n+    }\n+\n+    public Row getAllRows(Table table, int action) {\n+        return new RowImpl(table, action);\n+    }\n+\n+    public void flushAllRows(Row row) {\n+        if (!row.isValid())\n+            return;\n+\n+        switch (row.getAction()) {\n+            case Row.ACTION_UPDATE:\n+                if (_allRowUpdates == null)\n+                    _allRowUpdates = new ArrayList<Row>();\n+                _allRowUpdates.add(row);\n+                break;\n+            case Row.ACTION_DELETE:\n+                if (_allRowDeletes == null)\n+                    _allRowDeletes = new ArrayList<Row>();\n+                _allRowDeletes.add(row);\n+                break;\n+            default:\n+                throw new InternalException(\"action = \" + row.getAction());\n+        }\n+    }\n+\n+    public Row getRow(Table table, int action, OpenJPAStateManager sm,\n+        boolean create) {\n+        if (sm == null)\n+            return null;\n+\n+        // check if request matches cached version\n+        if (_key != null && _key.table == table && _key.sm == sm\n+            && _row != null && _row.getAction() == action)\n+            return _row;\n+\n+        Map<Key, PrimaryRow> map;\n+        if (action == Row.ACTION_DELETE) {\n+            if (_deletes == null && create)\n+                _deletes = new LinkedHashMap<Key, PrimaryRow>();\n+            map = _deletes;\n+        } else if (action == Row.ACTION_INSERT) {\n+            if (_inserts == null && create)\n+                _inserts = new LinkedHashMap<Key, PrimaryRow>();\n+            map = _inserts;\n+        } else {\n+            if (_updates == null && create)\n+                _updates = new LinkedHashMap<Key, PrimaryRow>();\n+            map = _updates;\n+        }\n+        if (map == null)\n+            return null;\n+\n+        _key = new Key(table, sm);\n+        _row = map.get(_key);\n+\n+        if (_row == null && create) {\n+            _row = new PrimaryRow(table, action, sm);\n+            map.put(_key, _row);\n+            if (_primaryOrder != null) {\n+                _row.setIndex(_primaryOrder.size());\n+                _primaryOrder.add(_row);\n+            }\n+\n+            if (!_auto && action == Row.ACTION_INSERT)\n+                _auto = table.getAutoAssignedColumns().length > 0;\n+        }\n+\n+        if (_row != null)\n+            _row.setFailedObject(sm.getManagedInstance());\n+        return _row;\n+    }\n+\n+    /**\n+     * Key for hashing virtual rows.\n+     */\n+    private static class Key {\n+\n+        public final Table table;\n+        public final OpenJPAStateManager sm;\n+\n+        public Key(Table table, OpenJPAStateManager sm) {\n+            this.table = table;\n+            this.sm = sm;\n+        }\n+\n+        public int hashCode() {\n+            return (table.hashCode() + sm.hashCode()) % Integer.MAX_VALUE;\n+        }\n+\n+        public boolean equals(Object other) {\n+            if (other == this)\n+                return true;\n+\n+            Key key = (Key) other;\n+            return table == key.table && sm == key.sm;\n+        }\n+    }\n+}"},{"sha":"a4d4c22490edb4e7e791ac39b4941e0f9d64e6b8","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","status":"added","additions":700,"deletions":0,"changes":700,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,700 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.io.Serializable;\n+import java.sql.CallableStatement;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.lang.ObjectUtils;\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.exps.Val;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Sequence;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import serp.util.Numbers;\n+\n+/**\n+ * Buffer for SQL statements that can be used to create\n+ * java.sql.PreparedStatements.\n+ *\n+ * @author Marc Prud'hommeaux\n+ * @author Abe White\n+ * @since 0.2.4\n+ */\n+public final class SQLBuffer\n+    implements Serializable, Cloneable {\n+\n+    private static final String PARAMETER_TOKEN = \"?\";\n+\n+    private final DBDictionary _dict;\n+    private final StringBuffer _sql = new StringBuffer();\n+    private List _subsels = null;\n+    private List _params = null;\n+    private List _cols = null;\n+\n+    /**\n+     * Default constructor.\n+     */\n+    public SQLBuffer(DBDictionary dict) {\n+        _dict = dict;\n+    }\n+\n+    /**\n+     * Copy constructor.\n+     */\n+    public SQLBuffer(SQLBuffer buf) {\n+        _dict = buf._dict;\n+        append(buf);\n+    }\n+\n+    /**\n+     * Perform a shallow clone of this SQL Buffer.\n+     */\n+    public Object clone() {\n+        return new SQLBuffer(this);\n+    }\n+\n+    /**\n+     * Return true if the buffer is emtpy.\n+     */\n+    public boolean isEmpty() {\n+        return _sql.length() == 0;\n+    }\n+\n+    /**\n+     * Append all SQL and parameters of the given buffer.\n+     */\n+    public SQLBuffer append(SQLBuffer buf) {\n+        append(buf, _sql.length(), (_params == null) ? 0 : _params.size(),\n+            true);\n+        return this;\n+    }\n+\n+    /**\n+     * Append all SQL and parameters of the given buffer at the given positions.\n+     */\n+    private void append(SQLBuffer buf, int sqlIndex, int paramIndex,\n+        boolean subsels) {\n+        if (subsels) {\n+            // only allow appending of buffers with subselects, not insertion\n+            if (_subsels != null && !_subsels.isEmpty()\n+                && sqlIndex != _sql.length())\n+                throw new IllegalStateException();\n+            if (buf._subsels != null && !buf._subsels.isEmpty()) {\n+                if (sqlIndex != _sql.length())\n+                    throw new IllegalStateException();\n+                if (_subsels == null)\n+                    _subsels = new ArrayList(buf._subsels.size());\n+                for (int i = 0; i < buf._subsels.size(); i++)\n+                    _subsels.add(((Subselect) buf._subsels.get(i)).\n+                        clone(sqlIndex, paramIndex));\n+            }\n+        }\n+\n+        if (sqlIndex == _sql.length())\n+            _sql.append(buf._sql.toString());\n+        else\n+            _sql.insert(sqlIndex, buf._sql.toString());\n+\n+        if (buf._params != null) {\n+            if (_params == null)\n+                _params = new ArrayList();\n+            if (_cols == null && buf._cols != null) {\n+                _cols = new ArrayList();\n+                while (_cols.size() < _params.size())\n+                    _cols.add(null);\n+            }\n+\n+            if (paramIndex == _params.size()) {\n+                _params.addAll(buf._params);\n+                if (buf._cols != null)\n+                    _cols.addAll(buf._cols);\n+                else if (_cols != null)\n+                    while (_cols.size() < _params.size())\n+                        _cols.add(null);\n+            } else {\n+                _params.addAll(paramIndex, buf._params);\n+                if (buf._cols != null)\n+                    _cols.addAll(paramIndex, buf._cols);\n+                else if (_cols != null)\n+                    while (_cols.size() < _params.size())\n+                        _cols.add(paramIndex, null);\n+            }\n+        }\n+    }\n+\n+    public SQLBuffer append(Table table) {\n+        _sql.append(_dict.getFullName(table, false));\n+        return this;\n+    }\n+\n+    public SQLBuffer append(Sequence seq) {\n+        _sql.append(_dict.getFullName(seq));\n+        return this;\n+    }\n+\n+    public SQLBuffer append(Column col) {\n+        _sql.append(col.getName());\n+        return this;\n+    }\n+\n+    public SQLBuffer append(String s) {\n+        _sql.append(s);\n+        return this;\n+    }\n+\n+    /**\n+     * Append a subselect. This delays resolution of the select SQL.\n+     */\n+    public SQLBuffer append(Select sel, JDBCFetchConfiguration fetch) {\n+        return append(sel, fetch, false);\n+    }\n+\n+    /**\n+     * Append a subselect count. This delays resolution of the select SQL.\n+     */\n+    public SQLBuffer appendCount(Select sel, JDBCFetchConfiguration fetch) {\n+        return append(sel, fetch, true);\n+    }\n+\n+    /**\n+     * Append a subselect. This delays resolution of the select SQL.\n+     */\n+    private SQLBuffer append(Select sel, JDBCFetchConfiguration fetch,\n+        boolean count) {\n+        _sql.append(\"(\");\n+        Subselect sub = new Subselect();\n+        sub.select = sel;\n+        sub.fetch = fetch;\n+        sub.count = count;\n+        sub.sqlIndex = _sql.length();\n+        sub.paramIndex = (_params == null) ? 0 : _params.size();\n+        _sql.append(\")\");\n+\n+        if (_subsels == null)\n+            _subsels = new ArrayList(2);\n+        _subsels.add(sub);\n+        return this;\n+    }\n+\n+    /**\n+     * Replace a subselect.\n+     */\n+    public boolean replace(Select old, Select sel) {\n+        if (_subsels == null)\n+            return false;\n+        Subselect sub;\n+        for (int i = 0; i < _subsels.size(); i++) {\n+            sub = (Subselect) _subsels.get(i);\n+            if (sub.select == old) {\n+                sub.select = sel;\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Append a parameter value.\n+     */\n+    public SQLBuffer appendValue(Object o) {\n+        return appendValue(o, null);\n+    }\n+\n+    /**\n+     * Append a parameter value for a specific column.\n+     */\n+    public SQLBuffer appendValue(Object o, Column col) {\n+        if (o == null)\n+            _sql.append(\"NULL\");\n+        else if (o instanceof Raw)\n+            _sql.append(o.toString());\n+        else {\n+            _sql.append(PARAMETER_TOKEN);\n+\n+            // initialize param and col lists; we hold off on col list until\n+            // we get the first non-null col\n+            if (_params == null)\n+                _params = new ArrayList();\n+            if (col != null && _cols == null) {\n+                _cols = new ArrayList();\n+                while (_cols.size() < _params.size())\n+                    _cols.add(null);\n+            }\n+\n+            _params.add(o);\n+            if (_cols != null)\n+                _cols.add(col);\n+            if (col == null)\n+                return this;\n+            boolean isFK = false;\n+            ForeignKey[] fks = col.getTable().getForeignKeys();\n+            for (int i = 0; i < fks.length; i++) {\n+                Column[] cols = fks[i].getColumns();\n+                for (int j = 0; j < cols.length; j++) {\n+                    if (cols[j] == col) {\n+                        isFK = true;\n+                        break;\n+                    }\n+                }\n+                if (isFK)\n+                    break;\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Append a parameter value.\n+     */\n+    public SQLBuffer appendValue(boolean b) {\n+        return appendValue(b, null);\n+    }\n+\n+    /**\n+     * Append a parameter value.\n+     */\n+    public SQLBuffer appendValue(boolean b, Column col) {\n+        return appendValue((b) ? Boolean.TRUE : Boolean.FALSE, col);\n+    }\n+\n+    /**\n+     * Append a parameter value.\n+     */\n+    public SQLBuffer appendValue(byte b) {\n+        return appendValue(b, null);\n+    }\n+\n+    /**\n+     * Append a parameter value.\n+     */\n+    public SQLBuffer appendValue(byte b, Column col) {\n+        return appendValue(new Byte(b), col);\n+    }\n+\n+    /**\n+     * Append a parameter value.\n+     */\n+    public SQLBuffer appendValue(char c) {\n+        return appendValue(c, null);\n+    }\n+\n+    /**\n+     * Append a parameter value.\n+     */\n+    public SQLBuffer appendValue(char c, Column col) {\n+        return appendValue(new Character(c), col);\n+    }\n+\n+    /**\n+     * Append a parameter value.\n+     */\n+    public SQLBuffer appendValue(double d) {\n+        return appendValue(d, null);\n+    }\n+\n+    /**\n+     * Append a parameter value.\n+     */\n+    public SQLBuffer appendValue(double d, Column col) {\n+        return appendValue(new Double(d), col);\n+    }\n+\n+    /**\n+     * Append a parameter value.\n+     */\n+    public SQLBuffer appendValue(float f) {\n+        return appendValue(f, null);\n+    }\n+\n+    /**\n+     * Append a parameter value.\n+     */\n+    public SQLBuffer appendValue(float f, Column col) {\n+        return appendValue(new Float(f), col);\n+    }\n+\n+    /**\n+     * Append a parameter value.\n+     */\n+    public SQLBuffer appendValue(int i) {\n+        return appendValue(i, null);\n+    }\n+\n+    /**\n+     * Append a parameter value.\n+     */\n+    public SQLBuffer appendValue(int i, Column col) {\n+        return appendValue(Numbers.valueOf(i), col);\n+    }\n+\n+    /**\n+     * Append a parameter value.\n+     */\n+    public SQLBuffer appendValue(long l) {\n+        return appendValue(l, null);\n+    }\n+\n+    /**\n+     * Append a parameter value.\n+     */\n+    public SQLBuffer appendValue(long l, Column col) {\n+        return appendValue(Numbers.valueOf(l), col);\n+    }\n+\n+    /**\n+     * Append a parameter value.\n+     */\n+    public SQLBuffer appendValue(short s) {\n+        return appendValue(s, null);\n+    }\n+\n+    /**\n+     * Append a parameter value.\n+     */\n+    public SQLBuffer appendValue(short s, Column col) {\n+        return appendValue(new Short(s), col);\n+    }\n+\n+    /**\n+     * Return the list of parameter values.\n+     */\n+    public List getParameters() {\n+        return (_params == null) ? Collections.EMPTY_LIST : _params;\n+    }\n+\n+    /**\n+     * Return the SQL for this buffer.\n+     */\n+    public String getSQL() {\n+        return getSQL(false);\n+    }\n+    \n+    /**\n+     * Returns the SQL for this buffer.\n+     *\n+     * @param replaceParams if true, then replace parameters with the\n+     * actual parameter values\n+     */\n+    public String getSQL(boolean replaceParams) {\n+        resolveSubselects();\n+        String sql = _sql.toString();\n+        if (!replaceParams || _params == null || _params.isEmpty())\n+            return sql;\n+\n+        StringBuffer buf = new StringBuffer();\n+        Iterator pi = _params.iterator();\n+        for (int i = 0; i < sql.length(); i++) {\n+            if (sql.charAt(i) != '?') {\n+                buf.append(sql.charAt(i));\n+                continue;\n+            }\n+\n+            Object param = pi.hasNext() ? pi.next() : null;\n+            if (param == null)\n+                buf.append(\"NULL\");\n+            else if (param instanceof Number || param instanceof Boolean)\n+                buf.append(param);\n+            else if (param instanceof String || param instanceof Character)\n+                buf.append(\"'\").append(param).append(\"'\");\n+            else\n+                buf.append(\"?\");\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Resolve our delayed subselects.\n+     */\n+    private void resolveSubselects() {\n+        if (_subsels == null || _subsels.isEmpty())\n+            return;\n+\n+        // add subsels backwards so that the stored insertion points of\n+        // later subsels remain valid\n+        Subselect sub;\n+        SQLBuffer buf;\n+        for (int i = _subsels.size() - 1; i >= 0; i--) {\n+            sub = (Subselect) _subsels.get(i);\n+            if (sub.count)\n+                buf = sub.select.toSelectCount();\n+            else\n+                buf = sub.select.toSelect(false, sub.fetch);\n+            buf.resolveSubselects();\n+            append(buf, sub.sqlIndex, sub.paramIndex, false);\n+        }\n+        _subsels.clear();\n+    }\n+\n+    /**\n+     * Create and populate the parameters of a prepared statement using\n+     * the SQL in this buffer.\n+     */\n+    public PreparedStatement prepareStatement(Connection conn)\n+        throws SQLException {\n+        return prepareStatement(conn, ResultSet.TYPE_FORWARD_ONLY,\n+            ResultSet.CONCUR_READ_ONLY);\n+    }\n+\n+    /**\n+     * Create and populate the parameters of a prepared statement using\n+     * the SQL in this buffer.\n+     */\n+    public PreparedStatement prepareStatement(Connection conn, int rsType,\n+        int rsConcur, List parms)\n+        throws SQLException {\n+        return prepareStatement(conn, null, rsType, rsConcur, parms);\n+    }\n+    \n+    /**\n+     * Create and populate the parameters of a prepared statement using\n+     * the SQL in this buffer.\n+     */\n+    public PreparedStatement prepareStatement(Connection conn, int rsType,\n+        int rsConcur)\n+        throws SQLException {\n+        return prepareStatement(conn, rsType, rsConcur, null);\n+    }\n+\n+    /**\n+     * Create and populate the parameters of a prepred statement using the\n+     * SQL in this buffer and the given fetch configuration.\n+     */\n+    public PreparedStatement prepareStatement(Connection conn,\n+        JDBCFetchConfiguration fetch, int rsType, int rsConcur)\n+        throws SQLException {\n+        return prepareStatement(conn, fetch, rsType, rsConcur, null);\n+    }\n+    \n+    /**\n+     * Create and populate the parameters of a prepred statement using the\n+     * SQL in this buffer and the given fetch configuration.\n+     */\n+    public PreparedStatement prepareStatement(Connection conn,\n+        JDBCFetchConfiguration fetch, int rsType, int rsConcur, List parms)\n+        throws SQLException {\n+        if (rsType == -1 && fetch == null)\n+            rsType = ResultSet.TYPE_FORWARD_ONLY;\n+        else if (rsType == -1)\n+            rsType = fetch.getResultSetType();\n+        if (rsConcur == -1)\n+            rsConcur = ResultSet.CONCUR_READ_ONLY;\n+\n+        PreparedStatement stmnt;\n+        if (rsType == ResultSet.TYPE_FORWARD_ONLY\n+            && rsConcur == ResultSet.CONCUR_READ_ONLY)\n+            stmnt = conn.prepareStatement(getSQL());\n+        else\n+            stmnt = conn.prepareStatement(getSQL(), rsType, rsConcur);\n+        try {\n+            setParameters(stmnt, parms);\n+            if (fetch != null) {\n+                if (fetch.getFetchBatchSize() > 0)\n+                    stmnt.setFetchSize(fetch.getFetchBatchSize());\n+                if (rsType != ResultSet.TYPE_FORWARD_ONLY\n+                    && fetch.getFetchDirection() != ResultSet.FETCH_FORWARD)\n+                    stmnt.setFetchDirection(fetch.getFetchDirection());\n+            }\n+            return stmnt;\n+        } catch (SQLException se) {\n+            try {\n+                stmnt.close();\n+            } catch (SQLException se2) {\n+            }\n+            throw se;\n+        }\n+    }\n+\n+    /**\n+     * Create and populate the parameters of a prepared statement using\n+     * the SQL in this buffer.\n+     */\n+    public CallableStatement prepareCall(Connection conn)\n+        throws SQLException {\n+        return prepareCall(conn, ResultSet.TYPE_FORWARD_ONLY,\n+            ResultSet.CONCUR_READ_ONLY);\n+    }\n+\n+    /**\n+     * Create and populate the parameters of a prepared statement using\n+     * the SQL in this buffer.\n+     */\n+    public CallableStatement prepareCall(Connection conn, int rsType,\n+        int rsConcur)\n+        throws SQLException {\n+        return prepareCall(conn, null, rsType, rsConcur);\n+    }\n+\n+    /**\n+     * Create and populate the parameters of a prepred statement using the\n+     * SQL in this buffer and the given fetch configuration.\n+     */\n+    public CallableStatement prepareCall(Connection conn,\n+        JDBCFetchConfiguration fetch, int rsType, int rsConcur)\n+        throws SQLException {\n+        if (rsType == -1 && fetch == null)\n+            rsType = ResultSet.TYPE_FORWARD_ONLY;\n+        else if (rsType == -1)\n+            rsType = fetch.getResultSetType();\n+        if (rsConcur == -1)\n+            rsConcur = ResultSet.CONCUR_READ_ONLY;\n+\n+        CallableStatement stmnt;\n+        if (rsType == ResultSet.TYPE_FORWARD_ONLY\n+            && rsConcur == ResultSet.CONCUR_READ_ONLY)\n+            stmnt = conn.prepareCall(getSQL());\n+        else\n+            stmnt = conn.prepareCall(getSQL(), rsType, rsConcur);\n+        try {\n+            setParameters(stmnt);\n+            if (fetch != null) {\n+                if (fetch.getFetchBatchSize() > 0)\n+                    stmnt.setFetchSize(fetch.getFetchBatchSize());\n+                if (rsType != ResultSet.TYPE_FORWARD_ONLY\n+                    && fetch.getFetchDirection() != ResultSet.FETCH_FORWARD)\n+                    stmnt.setFetchDirection(fetch.getFetchDirection());\n+            }\n+            return stmnt;\n+        } catch (SQLException se) {\n+            try {\n+                stmnt.close();\n+            } catch (SQLException se2) {\n+            }\n+            throw se;\n+        }\n+    }\n+\n+    /**\n+     * Populate the parameters of an existing PreparedStatement\n+     * with values from this buffer.\n+     */\n+    public void setParameters(PreparedStatement ps)\n+        throws SQLException {\n+        setParameters(ps, null);\n+    }\n+    \n+    /**\n+     * Populate the parameters of an existing PreparedStatement\n+     * with values from this buffer.\n+     */\n+    public void setParameters(PreparedStatement ps, List cacheParams)\n+        throws SQLException {\n+        List params = ((cacheParams != null && cacheParams.size() > 0) ? \n+            cacheParams : _params);    \n+        \n+        if (params == null)\n+            return;\n+\n+        Column col;\n+        for (int i = 0; i < params.size(); i++) {\n+            col = (_cols == null) ? null : (Column) _cols.get(i);\n+            _dict.setUnknown(ps, i + 1, params.get(i), col);\n+        }\n+    }\n+\n+    public int hashCode() {\n+        int hash = _sql.hashCode();\n+        return (_params == null) ? hash : hash ^ _params.hashCode();\n+    }\n+\n+    /**\n+     * Compare internal SQL without resolving subselects or stringifying\n+     * parameters.\n+     */\n+    public boolean sqlEquals(String sql) {\n+        return _sql.toString().equals(sql);\n+    }\n+\n+    public boolean equals(Object other) {\n+        if (other == this)\n+            return true;\n+        if (!(other instanceof SQLBuffer))\n+            return false;\n+\n+        SQLBuffer buf = (SQLBuffer) other;\n+        return _sql.equals(buf._sql)\n+            && ObjectUtils.equals(_params, buf._params);\n+    }\n+\n+    /**\n+     * Replace SQL '?' with CAST string if required by DB platform\n+     * @param oper\n+     * @param val\n+     */\n+    public void addCastForParam(String oper, Val val) {\n+        if (_sql.charAt(_sql.length() - 1) == '?') {\n+            String castString = _dict.addCastAsType(oper, val);\n+            if (castString != null)\n+                _sql.replace(_sql.length() - 1, _sql.length(), castString);\n+        }\n+    }\n+\n+    /**\n+     * Replace current buffer string with the new string\n+     * \n+     * @param start replace start position\n+     * @param end replace end position\n+     * @param newString\n+     */\n+    public void replaceSqlString(int start, int end, String newString) {\n+        _sql.replace(start, end, newString);\n+    }\n+    \n+    /**\n+     * Represents a subselect.\n+     */\n+    private static class Subselect {\n+\n+        public Select select;\n+        public JDBCFetchConfiguration fetch;\n+        public boolean count;\n+        public int sqlIndex;\n+        public int paramIndex;\n+\n+        public Subselect clone(int sqlIndex, int paramIndex) {\n+            if (sqlIndex == 0 && paramIndex == 0)\n+                return this;\n+\n+            Subselect sub = new Subselect();\n+            sub.select = select;\n+            sub.fetch = fetch;\n+            sub.count = count;\n+            sub.sqlIndex = this.sqlIndex + sqlIndex;\n+            sub.paramIndex = this.paramIndex + paramIndex;\n+            return sub;\n+        }\n+    }\n+    \n+    public void setParameters(List params) {\n+        _params = params;\n+    }\n+    \n+    public List getColumns() {\n+        return _cols;\n+    }\n+}"},{"sha":"5ed844a4b8b6f4957a240bd5cc173f0f8d165ca5","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","status":"added","additions":155,"deletions":0,"changes":155,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,155 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one\r\n+ * or more contributor license agreements.  See the NOTICE file\r\n+ * distributed with this work for additional information\r\n+ * regarding copyright ownership.  The ASF licenses this file\r\n+ * to you under the Apache License, Version 2.0 (the\r\n+ * \"License\"); you may not use this file except in compliance\r\n+ * with the License.  You may obtain a copy of the License at\r\n+ *\r\n+ * http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing,\r\n+ * software distributed under the License is distributed on an\r\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n+ * KIND, either express or implied.  See the License for the\r\n+ * specific language governing permissions and limitations\r\n+ * under the License.\r\n+ */\r\n+package org.apache.openjpa.jdbc.sql;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+\r\n+import javax.xml.parsers.DocumentBuilder;\r\n+\r\n+import org.apache.commons.lang.StringUtils;\r\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\r\n+import org.apache.openjpa.lib.log.Log;\r\n+import org.apache.openjpa.lib.util.Localizer;\r\n+import org.apache.openjpa.lib.xml.XMLFactory;\r\n+import org.apache.openjpa.util.StoreException;\r\n+import org.w3c.dom.Document;\r\n+import org.w3c.dom.Element;\r\n+import org.w3c.dom.NamedNodeMap;\r\n+import org.w3c.dom.Node;\r\n+import org.w3c.dom.NodeList;\r\n+\r\n+/**\r\n+ * Parses XML content of SQL Error State codes to populate errro codes for\r\n+ * a given Database Dictionary.\r\n+ * \r\n+ * @author Pinaki Poddar\r\n+ * \r\n+ */\r\n+public class SQLErrorCodeReader {\r\n+\tprivate Log log = null;\r\n+\tpublic static final String ERROR_CODE_DELIMITER = \",\";\r\n+\tpublic static final Map<String, Integer> storeErrorTypes = \r\n+\t\tnew HashMap<String, Integer>();\r\n+\tstatic {\r\n+\t\tstoreErrorTypes.put(\"lock\", StoreException.LOCK);\r\n+\t\tstoreErrorTypes.put(\"object-exists\", StoreException.OBJECT_EXISTS);\r\n+\t\tstoreErrorTypes\r\n+\t\t\t\t.put(\"object-not-found\", StoreException.OBJECT_NOT_FOUND);\r\n+\t\tstoreErrorTypes.put(\"optimistic\", StoreException.OPTIMISTIC);\r\n+\t\tstoreErrorTypes.put(\"referential-integrity\",\r\n+\t\t\t\tStoreException.REFERENTIAL_INTEGRITY);\r\n+\r\n+\t}\r\n+\t\r\n+\tprivate static final Localizer _loc = \r\n+\t\tLocalizer.forPackage(SQLErrorCodeReader.class);\r\n+\t\r\n+\tpublic List<String> getDictionaries(InputStream in) {\r\n+\t\tList<String> result = new ArrayList<String>();\r\n+\t\tDocumentBuilder builder = XMLFactory.getDOMParser(false, false);\r\n+\t\ttry {\r\n+\t\t\tDocument doc = builder.parse(in);\r\n+\t\t\tElement root = doc.getDocumentElement();\r\n+\t\t\tNodeList nodes = root.getElementsByTagName(\"dictionary\");\r\n+\t\t\tfor (int i = 0; i < nodes.getLength(); i++) {\r\n+\t\t\t\tNode node = nodes.item(i);\r\n+\t\t\t\tNamedNodeMap attrs = node.getAttributes();\r\n+\t\t\t\tNode dictionary = attrs.getNamedItem(\"class\");\r\n+\t\t\t\tif (dictionary != null) {\r\n+\t\t\t\t   result.add(dictionary.getNodeValue());\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\tif (log.isWarnEnabled()) {\r\n+\t\t\t\tlog.error(_loc.get(\"error-code-parse-error\"));\r\n+\t\t\t}\r\n+\t\t} finally {\r\n+\t\t\ttry {\r\n+\t\t\t\tin.close();\r\n+\t\t\t} catch (IOException e) {\r\n+\t\t\t\t// ignore\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\treturn result;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Parses given stream of XML content for error codes of the given database\r\n+\t * dictionary name. Populates the given dictionary with the error codes.\r\n+\t * \r\n+\t */\r\n+\tpublic void parse(InputStream in, String dictName, DBDictionary dict) {\r\n+\t\tif (in == null || dict == null)\r\n+\t\t\treturn;\r\n+\t\tlog = dict.conf.getLog(JDBCConfiguration.LOG_JDBC);\r\n+\t\tDocumentBuilder builder = XMLFactory.getDOMParser(false, false);\r\n+\t\ttry {\r\n+\t\t\tDocument doc = builder.parse(in);\r\n+\t\t\tElement root = doc.getDocumentElement();\r\n+\t\t\tNodeList nodes = root.getElementsByTagName(\"dictionary\");\r\n+\t\t\tfor (int i = 0; i < nodes.getLength(); i++) {\r\n+\t\t\t\tNode node = nodes.item(i);\r\n+\t\t\t\tNamedNodeMap attrs = node.getAttributes();\r\n+\t\t\t\tNode dictionary = attrs.getNamedItem(\"class\");\r\n+\t\t\t\tif (dictionary != null \r\n+\t\t\t\t && dictionary.getNodeValue().equals(dictName)) {\r\n+\t\t\t\t\treadErrorCodes(node, dict);\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t} catch (Throwable e) {\r\n+\t\t\tif (log.isWarnEnabled()) {\r\n+\t\t\t\tlog.error(_loc.get(\"error-code-parse-error\"));\r\n+\t\t\t}\r\n+\t\t} finally {\r\n+\t\t\ttry {\r\n+\t\t\t\tin.close();\r\n+\t\t\t} catch (IOException e) {\r\n+\t\t\t\t// ignore\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tstatic void readErrorCodes(Node node, DBDictionary dict) {\r\n+\t\tNodeList children = node.getChildNodes();\r\n+\t\tfor (int i = 0; i < children.getLength(); i++) {\r\n+\t\t\tNode child = children.item(i);\r\n+\t\t\tshort nodeType = child.getNodeType();\r\n+\t\t\tif (nodeType == Node.ELEMENT_NODE) {\r\n+\t\t\t\tString errorType = child.getNodeName();\r\n+\t\t\t\tNode textNode = child.getFirstChild();\r\n+\t\t\t\tif (storeErrorTypes.containsKey(errorType) && textNode != null){\r\n+\t\t\t\t\tString errorCodes = textNode.getNodeValue();\r\n+\t\t\t\t\tif (!StringUtils.isEmpty(errorCodes)) {\r\n+\t\t\t\t\t\tString[] codes = errorCodes.split(ERROR_CODE_DELIMITER);\r\n+\t\t\t\t\t\tfor (String code : codes) {\r\n+\t\t\t\t\t\t\tdict.addErrorCode(storeErrorTypes.get(errorType),\r\n+\t\t\t\t\t\t\t\t\tcode.trim());\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+}\r"},{"sha":"cfd6934e850041581b4003afc13f5c7e22e846a8","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLExceptions.java","status":"added","additions":120,"deletions":0,"changes":120,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLExceptions.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLExceptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLExceptions.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.SQLException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.openjpa.lib.util.Localizer.Message;\n+import org.apache.openjpa.util.LockException;\n+import org.apache.openjpa.util.ObjectExistsException;\n+import org.apache.openjpa.util.ObjectNotFoundException;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.OptimisticException;\n+import org.apache.openjpa.util.ReferentialIntegrityException;\n+import org.apache.openjpa.util.StoreException;\n+\n+/**\n+ * Helper class for converting a {@link SQLException} into\n+ * the appropriate OpenJPA type.\n+ *\n+ * @author Marc Prud'hommeaux\n+ * @nojavadoc\n+ */\n+public class SQLExceptions {\n+\n+    private static final SQLException[] EMPTY_EXCEPS = new SQLException[0];\n+\n+    /**\n+     * Convert the specified exception into a {@link StoreException}.\n+     */\n+    public static OpenJPAException getStore(SQLException se) {\n+        return getStore(se, null, null);\n+    }\n+\n+    /**\n+     * Convert the specified exception into a {@link OpenJPAException}.\n+     */\n+    public static OpenJPAException getStore(SQLException se, Object failed) {\n+        return getStore(se, failed, null);\n+    }\n+\n+    /**\n+     * Convert the specified exception into a {@link StoreException}.\n+     */\n+    public static OpenJPAException getStore(SQLException se,\n+        DBDictionary dict) {\n+        return getStore(se.getMessage(), se, dict);\n+    }\n+\n+    /**\n+     * Convert the specified exception into a {@link StoreException}.\n+     */\n+    public static OpenJPAException getStore(SQLException se, Object failed,\n+        DBDictionary dict) {\n+        return getStore(se.getMessage(), se, failed, dict);\n+    }\n+\n+    /**\n+     * Convert the specified exception into a {@link StoreException}.\n+     */\n+    public static OpenJPAException getStore(Message msg, SQLException se,\n+        DBDictionary dict) {\n+        return getStore(msg.getMessage(), se, null, dict);\n+    }\n+\n+    /**\n+     * Convert the specified exception into a {@link StoreException}.\n+     */\n+    public static OpenJPAException getStore(String msg, SQLException se,\n+        DBDictionary dict) {\n+        return getStore(msg, se, null, dict);\n+    }\n+\n+    /**\n+     * Convert the specified exception into a {@link StoreException}.\n+     */\n+    public static OpenJPAException getStore(String msg, SQLException se,\n+        Object failed, DBDictionary dict) {\n+        if (msg == null)\n+            msg = se.getClass().getName();\n+        SQLException[] ses = getSQLExceptions(se);\n+        if (dict == null)\n+            return new StoreException(msg).setFailedObject(failed).\n+                setNestedThrowables(ses);\n+        return dict.newStoreException(msg, ses, failed);\n+    }\n+    \n+    /**\n+     * Returns an array of {@link SQLException} instances for the\n+     * specified exception.\n+     */\n+    private static SQLException[] getSQLExceptions(SQLException se) {\n+        if (se == null)\n+            return EMPTY_EXCEPS;\n+\n+        List errs = new LinkedList();\n+        while (se != null && !errs.contains(se)) {\n+            errs.add(se);\n+            se = se.getNextException();\n+        }\n+        return (SQLException[]) errs.toArray(new SQLException[errs.size()]);\n+    }\n+}"},{"sha":"4233acf9108ccee9632322d738486c212b62a1b1","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactory.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+/**\n+ * Factory for SQL constructs.\n+ *\n+ * @author Abe White\n+ */\n+public interface SQLFactory {\n+\n+    /**\n+     * Select factory.\n+     */\n+    public Select newSelect();\n+\n+    /**\n+     * Union factory.\n+     *\n+     * @param selects the number of selects in the union\n+     */\n+    public Union newUnion(int selects);\n+\n+    /**\n+     * Union factory.\n+     *\n+     * @param selects the members of the union\n+     */\n+    public Union newUnion(Select[] selects);\n+}"},{"sha":"28f97c6015445b7c67c438afc0711e73af4e225c","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactoryImpl.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactoryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLFactoryImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+\n+/**\n+ * Default factory for SQL abstraction constructs.\n+ *\n+ * @author Abe White\n+ */\n+public class SQLFactoryImpl\n+    implements SQLFactory, Configurable {\n+\n+    private JDBCConfiguration _conf = null;\n+\n+    /**\n+     * System configuration.\n+     */\n+    public JDBCConfiguration getConfiguration() {\n+        return _conf;\n+    }\n+\n+    public Select newSelect() {\n+        return new SelectImpl(_conf);\n+    }\n+\n+    public Union newUnion(int selects) {\n+        return new LogicalUnion(_conf, selects);\n+    }\n+\n+    public Union newUnion(Select[] selects) {\n+        return new LogicalUnion(_conf, selects);\n+    }\n+\n+    public void setConfiguration(Configuration conf) {\n+        _conf = (JDBCConfiguration) conf;\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+    }\n+}"},{"sha":"18ac7cc65cb0d2ec3b27c5400d7857bed8446d1f","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","status":"added","additions":241,"deletions":0,"changes":241,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.JavaTypes;\n+\n+/**\n+ * Dictionary for MS SQLServer.\n+ */\n+public class SQLServerDictionary\n+    extends AbstractSQLServerDictionary {\n+\n+    public static final String VENDOR_MICROSOFT = \"microsoft\";\n+    public static final String VENDOR_NETDIRECT = \"netdirect\";\n+    public static final String VENDOR_JTDS = \"jtds\";\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (SQLServerDictionary.class);\n+\n+    private String schemaCase = SCHEMA_CASE_PRESERVE;\n+    /**\n+     * Flag whether to treat UNIQUEIDENTIFIER as VARBINARY or VARCHAR\n+     */\n+    public boolean uniqueIdentifierAsVarbinary = true;\n+\n+    public SQLServerDictionary() {\n+        platform = \"Microsoft SQL Server\";\n+\n+        // SQLServer locks on a table-by-table basis\n+        forUpdateClause = null;\n+        tableForUpdateClause = \"WITH (UPDLOCK)\";\n+\n+        supportsNullTableForGetColumns = false;\n+        requiresAliasForSubselect = true;\n+\n+        stringLengthFunction = \"LEN({0})\";\n+    }\n+\n+    public void connectedConfiguration(Connection conn)\n+        throws SQLException {\n+        super.connectedConfiguration(conn);\n+\n+        DatabaseMetaData meta = conn.getMetaData();\n+        String driverName = meta.getDriverName();\n+        String url = meta.getURL();\n+        if (driverVendor == null) {\n+            if (\"NetDirect JSQLConnect\".equals(driverName))\n+                driverVendor = VENDOR_NETDIRECT;\n+            else if (driverName != null && driverName.startsWith(\"jTDS\"))\n+                driverVendor = VENDOR_JTDS;\n+            else if (\"SQLServer\".equals(driverName)) {\n+                if (url != null && url.startsWith(\"jdbc:microsoft:sqlserver:\"))\n+                    driverVendor = VENDOR_MICROSOFT;\n+                else if (url != null\n+                    && url.startsWith(\"jdbc:datadirect:sqlserver:\"))\n+                    driverVendor = VENDOR_DATADIRECT;\n+                else\n+                    driverVendor = VENDOR_OTHER;\n+            } else\n+                driverVendor = VENDOR_OTHER;\n+            if (driverName.indexOf(platform) != -1) {\n+                String versionString = driverName.\n+                    substring(platform.length() + 1);\n+                if (versionString.indexOf(\" \") != -1)\n+                    versionString = versionString.substring(0,\n+                        versionString.indexOf(\" \"));\n+                int version = Integer.parseInt(versionString);\n+                if (version >= 2005)\n+                    supportsXMLColumn = true;\n+            }\n+        }\n+\n+        // warn about using cursors\n+        if ((VENDOR_MICROSOFT.equalsIgnoreCase(driverVendor)\n+            || VENDOR_DATADIRECT.equalsIgnoreCase(driverVendor))\n+            && url.toLowerCase().indexOf(\"selectmethod=cursor\") == -1)\n+            log.warn(_loc.get(\"sqlserver-cursor\", url));\n+\n+        // warn about prepared statement caching if using ms driver\n+        String props = conf.getConnectionFactoryProperties();\n+        if (props == null)\n+            props = \"\";\n+        if (VENDOR_MICROSOFT.equalsIgnoreCase(driverVendor)\n+            && props.toLowerCase().indexOf(\"maxcachedstatements=0\") == -1)\n+            log.warn(_loc.get(\"sqlserver-cachedstmnts\"));\n+    }\n+\n+    public Column[] getColumns(DatabaseMetaData meta, String catalog,\n+        String schemaName, String tableName, String columnName, Connection conn)\n+        throws SQLException {\n+        Column[] cols = super.getColumns(meta, catalog, schemaName, tableName,\n+            columnName, conn);\n+\n+        // for opta driver, which reports nvarchar as unknown type\n+        for (int i = 0; cols != null && i < cols.length; i++) {\n+            String typeName = cols[i].getTypeName();\n+            if (typeName == null)\n+                continue;\n+\n+            typeName = typeName.toUpperCase();\n+\n+            if (\"NVARCHAR\".equals(typeName))\n+                cols[i].setType(Types.VARCHAR);\n+            else if (\"UNIQUEIDENTIFIER\".equals(typeName)) {\n+                if (uniqueIdentifierAsVarbinary)\n+                    cols[i].setType(Types.VARBINARY);\n+                else\n+                    cols[i].setType(Types.VARCHAR);\n+            } else if (\"NCHAR\".equals(typeName))\n+                cols[i].setType(Types.CHAR);\n+            else if (\"NTEXT\".equals(typeName))\n+                cols[i].setType(Types.CLOB);\n+        }\n+        return cols;\n+    }\n+    \n+    protected void appendLength(SQLBuffer buf, int type) {\n+        if (type == Types.VARCHAR)\n+            buf.append(\"(\").append(Integer.toString(characterColumnSize)).append(\")\");\n+    }\n+\n+    /**\n+     * If this dictionary supports XML type,\n+     * use this method to append xml predicate.\n+     * \n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison\n+     * @param rhs the right hand side of the comparison\n+     * @param lhsxml indicates whether the left operand maps to xml\n+     * @param rhsxml indicates whether the right operand maps to xml\n+     */\n+    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\n+        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\n+        super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\n+        if (lhsxml && rhsxml)\n+            appendXmlComparison2(buf, op, lhs, rhs);\n+        else if (lhsxml)\n+            appendXmlComparison1(buf, op, lhs, rhs);\n+        else \n+            appendXmlComparison1(buf, op, rhs, lhs);\n+    }\n+    /**\n+     * Append an xml comparison predicate\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison\n+     */\n+    private void appendXmlComparison1(SQLBuffer buf, String op,\n+        FilterValue lhs, FilterValue rhs) {\n+        boolean castrhs = rhs.isConstant();\n+        if (castrhs)\n+            appendXmlValue(buf, lhs);\n+        else\n+            appendXmlExist(buf, lhs);\n+        buf.append(\" \").append(op).append(\" \");\n+        if (castrhs)\n+            rhs.appendTo(buf);\n+        else {\n+            buf.append(\"sql:column(\\\"\");\n+            rhs.appendTo(buf);\n+            buf.append(\"\\\")\").\n+                append(\"]') = 1\");\n+        }\n+    }\n+    \n+    private void appendXmlExist(SQLBuffer buf, FilterValue lhs) {\n+        buf.append(lhs.getColumnAlias(\n+            lhs.getFieldMapping().getColumns()[0])).\n+            append(\".exist('\").\n+            append(\"/*[\");\n+        lhs.appendTo(buf);    \n+    }\n+    \n+    /**\n+     * Append an xml comparison predicate (both operands map to xml column)\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison (maps to xml column)\n+     */\n+    private void appendXmlComparison2(SQLBuffer buf, String op, \n+        FilterValue lhs, FilterValue rhs) {\n+        appendXmlValue(buf, lhs);\n+        buf.append(\" \").append(op).append(\" \");\n+        appendXmlValue(buf, rhs);\n+    }\n+    \n+    private void appendXmlValue(SQLBuffer buf, FilterValue val) {\n+        Class rc = Filters.wrap(val.getType());\n+        int type = getJDBCType(JavaTypes.getTypeCode(rc), false);\n+        boolean isXmlAttribute = (val.getXmlMapping() == null) ? false\n+                : val.getXmlMapping().isXmlAttribute();\n+        buf.append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\".value(\").\n+            append(\"'(/*/\");\n+        val.appendTo(buf);\n+        if (!isXmlAttribute)\n+            buf.append(\"/text()\");\n+        buf.append(\")[1]','\").\n+            append(getTypeName(type));\n+        appendLength(buf, type);\n+        buf.append(\"')\");\n+    }\n+    \n+    /**\n+     * Return DB specific schemaCase\n+     */\n+    public String getSchemaCase() {\n+        return schemaCase;\n+    }\n+}"},{"sha":"7195c46003d89877ddd0c754067bfa43dea8de2e","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SecondaryRow.java","status":"added","additions":191,"deletions":0,"changes":191,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SecondaryRow.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SecondaryRow.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SecondaryRow.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.RelationId;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+\n+/**\n+ * Secondary table row that tracks foreign keys to auto-inc columns.\n+ *\n+ * @author Abe White\n+ * @nojavadoc\n+ */\n+public class SecondaryRow\n+    extends RowImpl {\n+\n+    private OpenJPAStateManager[] _fks = null;\n+    private ColumnIO[] _fkIO = null;\n+    private OpenJPAStateManager[] _rels = null;\n+    private RelationId[] _callbacks = null;\n+\n+    /**\n+     * Constructor; supply table and action.\n+     */\n+    public SecondaryRow(Table table, int action) {\n+        this(table.getColumns(), action);\n+    }\n+\n+    protected SecondaryRow(Column[] cols, int action) {\n+        super(cols, action);\n+    }\n+\n+    public void setForeignKey(ForeignKey fk, OpenJPAStateManager sm)\n+        throws SQLException {\n+        setForeignKey(fk, null, sm);\n+    }\n+\n+    public void setForeignKey(ForeignKey fk, ColumnIO io,\n+        OpenJPAStateManager sm)\n+        throws SQLException {\n+        if (!delayForeignKey(fk, sm)) {\n+            super.setForeignKey(fk, io, sm);\n+            return;\n+        }\n+\n+        // force valid\n+        if (canSetAny(io, fk.getColumns().length\n+            + fk.getConstantColumns().length, false))\n+            setValid(true);\n+\n+        // record foreig key for delayed flush\n+        if (_fks == null)\n+            _fks = new OpenJPAStateManager[getTable().getForeignKeys().length];\n+        _fks[fk.getIndex()] = sm;\n+\n+        if (_fkIO != null)\n+            _fkIO[fk.getIndex()] = io;\n+        else if (io != null\n+            && ((getAction() == ACTION_INSERT\n+            && !io.isAllInsertable(fk, false))\n+            || (getAction() != ACTION_INSERT\n+            && !io.isAllUpdatable(fk, false)))) {\n+            _fkIO = new ColumnIO[_fks.length];\n+            _fkIO[fk.getIndex()] = io;\n+        }\n+    }\n+\n+    /**\n+     * Record foreign keys to new auto-inc instances; flush them only when\n+     * we have to generate our SQL to give the instance a chance to finalize\n+     * its values.\n+     */\n+    private boolean delayForeignKey(ForeignKey fk, OpenJPAStateManager sm) {\n+        return fk.isPrimaryKeyAutoAssigned() && getAction() != ACTION_DELETE\n+            && sm != null && sm.isNew() && !sm.isFlushed();\n+    }\n+\n+    public void setRelationId(Column col, OpenJPAStateManager sm,\n+        RelationId rel)\n+        throws SQLException {\n+        if (sm == null || sm.getObjectId() != null || !sm.isNew()\n+            || sm.isFlushed() || !isPrimaryKeyAutoAssigned(sm))\n+            super.setRelationId(col, sm, rel);\n+        else {\n+            if (_rels == null) {\n+                Column[] cols = getTable().getRelationIdColumns();\n+                _rels = new OpenJPAStateManager[cols.length];\n+                _callbacks = new RelationId[cols.length];\n+            }\n+            int idx = getRelationIdIndex(col);\n+            _rels[idx] = sm;\n+            _callbacks[idx] = rel;\n+        }\n+    }\n+\n+    /**\n+     * Return the index into our relation id array of the value for the\n+     * given column.\n+     */\n+    private int getRelationIdIndex(Column col) {\n+        Column[] cols = getTable().getRelationIdColumns();\n+        for (int i = 0; i < cols.length; i++)\n+            if (cols[i] == col)\n+                return i;\n+        return -1;\n+    }\n+\n+    /**\n+     * Return true if any primary key columns of the given instance are\n+     * auto-assigned.\n+     */\n+    private static boolean isPrimaryKeyAutoAssigned(OpenJPAStateManager sm) {\n+        ClassMapping cls = (ClassMapping) sm.getMetaData();\n+        while (cls.getJoinablePCSuperclassMapping() != null)\n+            cls = cls.getJoinablePCSuperclassMapping();\n+        Column[] cols = cls.getPrimaryKeyColumns();\n+        for (int i = 0; i < cols.length; i++)\n+            if (cols[i].isAutoAssigned())\n+                return true;\n+        return false;\n+    }\n+\n+    protected String generateSQL(DBDictionary dict) {\n+        try {\n+            if (_fks != null) {\n+                ForeignKey[] fks = getTable().getForeignKeys();\n+                ColumnIO io;\n+                for (int i = 0; i < _fks.length; i++) {\n+                    if (_fks[i] != null) {\n+                        io = (_fkIO == null) ? null : _fkIO[i];\n+                        super.setForeignKey(fks[i], io, _fks[i]);\n+                    }\n+                }\n+            }\n+            if (_rels != null) {\n+                Column[] cols = getTable().getRelationIdColumns();\n+                for (int i = 0; i < _rels.length; i++)\n+                    if (_rels[i] != null)\n+                        super.setRelationId(cols[i], _rels[i], _callbacks[i]);\n+            }\n+        }\n+        catch (SQLException se) {\n+            throw SQLExceptions.getStore(se, dict);\n+        }\n+        return super.generateSQL(dict);\n+    }\n+\n+    protected RowImpl newInstance(Column[] cols, int action) {\n+        return new SecondaryRow(cols, action);\n+    }\n+\n+    public void copyInto(RowImpl row, boolean whereOnly) {\n+        super.copyInto(row, whereOnly);\n+        if (_fks == null || whereOnly || row.getAction() == ACTION_DELETE\n+            || !(row instanceof SecondaryRow))\n+            return;\n+\n+        SecondaryRow srow = (SecondaryRow) row;\n+        if (srow._fks == null)\n+            srow._fks = new OpenJPAStateManager[_fks.length];\n+        System.arraycopy(_fks, 0, srow._fks, 0, _fks.length);\n+        if (_fkIO != null) {\n+            if (srow._fkIO == null)\n+                srow._fkIO = new ColumnIO[_fkIO.length];\n+            System.arraycopy(_fkIO, 0, srow._fkIO, 0, _fkIO.length);\n+        }\n+    }\n+}"},{"sha":"14a0d5e0820dc4dd7ae56b4fbd43e4238a1fc020","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java","status":"added","additions":723,"deletions":0,"changes":723,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,723 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+\n+/**\n+ * Abstraction of a SQL SELECT statement.\n+ *\n+ * @author Abe White\n+ */\n+public interface Select\n+    extends SelectExecutor {\n+\n+    /**\n+     * Constant indicating to batch the select using an inner join.\n+     */\n+    public static final int EAGER_INNER = 0;\n+\n+    /**\n+     * Constant indicating to batch the select using an outer join.\n+     */\n+    public static final int EAGER_OUTER = 1;\n+\n+    /**\n+     * Constant indicating to use a separate select executed in parallel.\n+     */\n+    public static final int EAGER_PARALLEL = 2;\n+\n+    /**\n+     * Constant indicating a select can be made without joins.\n+     */\n+    public static final int TYPE_JOINLESS = 3;\n+\n+    /**\n+     * Constant indicating a two-part select and load.\n+     */\n+    public static final int TYPE_TWO_PART = 4;\n+\n+    /**\n+     * Constant indicating to add conditions to the selcet to select this\n+     * class and joinable subclasses only.\n+     */\n+    public static final int SUBS_JOINABLE = 1;\n+\n+    /**\n+     * Constant indicating to add conditions to the select to select this\n+     * class only.\n+     */\n+    public static final int SUBS_NONE = 2;\n+\n+    /**\n+     * Constant indicating to select subclasses but without adding any\n+     * class conditions to the select.\n+     */\n+    public static final int SUBS_ANY_JOINABLE = 3;\n+\n+    /**\n+     * Constant indicating to select this class but without adding any\n+     * class conditions to the select.\n+     */\n+    public static final int SUBS_EXACT = 4;\n+\n+    /**\n+     * The alias to use for the from select, if any.\n+     */\n+    public static final String FROM_SELECT_ALIAS = \"s\";\n+\n+    /**\n+     * The index of this select within the UNION, or 0.\n+     */\n+    public int indexOf();\n+\n+    /**\n+     * Return this select's subselects, or empty collection if none.\n+     */\n+    public List getSubselects();\n+\n+    /**\n+     * Return the parent of this select, if it is a subselect.\n+     */\n+    public Select getParent();\n+\n+    /**\n+     * Return the subselect path for this select, if it is a subselect.\n+     */\n+    public String getSubselectPath();\n+\n+    /**\n+     * Turn this select into a subselect of the given instance.\n+     */\n+    public void setParent(Select parent, String path);\n+\n+    /**\n+     * Another select instance that creates a temporary table from which\n+     * this select pulls data.\n+     */\n+    public Select getFromSelect();\n+\n+    /**\n+     * Another select instance that creates a temporary table from which\n+     * this select pulls data.\n+     */\n+    public void setFromSelect(Select sel);\n+\n+    /**\n+     * Whether this select has an eager join of the specified type.\n+     */\n+    public boolean hasEagerJoin(boolean toMany);\n+\n+    /**\n+     * Whether this select has a join of the specified type.\n+     */\n+    public boolean hasJoin(boolean toMany);\n+\n+    /**\n+     * Return whether the given table is being used in this select.\n+     */\n+    public boolean isSelected(Table table);\n+\n+    /**\n+     * Return the set of all used table aliases.\n+     */\n+    public Collection getTableAliases();\n+\n+    /**\n+     * Return the actual {@link Val}s and {@link Column}s that were\n+     * selected, in the order that they were selected.\n+     *\n+     * @since 1.1.0\n+     */\n+    public List getSelects();\n+\n+    /**\n+     * Return the aliases of all selected columns and all selected buffers,\n+     * in the order they were selected. Each alias may be either a string\n+     * or a {@link SQLBuffer}.\n+     */\n+    public List getSelectAliases();\n+\n+    /**\n+     * Get the aliases for identifier columns that can be used in COUNT\n+     * selects to find the number of matches. Each alias will be a\n+     * string. If no identifier columns have been nominated, then all\n+     * column alises are returned.\n+     */\n+    public List getIdentifierAliases();\n+\n+    /**\n+     * Return the ordering SQL for this select.\n+     */\n+    public SQLBuffer getOrdering();\n+\n+    /**\n+     * Return the grouping SQL for this select.\n+     */\n+    public SQLBuffer getGrouping();\n+\n+    /**\n+     * Return the WHERE clause, minus any necessary end joins.\n+     */\n+    public SQLBuffer getWhere();\n+\n+    /**\n+     * Return the HAVING clause, or null if none.\n+     */\n+    public SQLBuffer getHaving();\n+\n+    /**\n+     * Return the SQL for this select. This buffer contains\n+     * the final SQL to be executed/cached.\n+     */\n+    public SQLBuffer getSQL();    \n+    \n+    /**\n+     * Create and set the SQLBuffer object to this select. This buffer contains\n+     * the final SQL to be executed/cached.\n+     */\n+    public void setSQL(JDBCStore store, JDBCFetchConfiguration fetch); \n+    \n+    \n+    /**\n+     * Apply class conditions from relation joins.  This may affect the return\n+     * values of {@link #getJoins}, {@link #getJoinIterator}, and\n+     * {@link #getWhere}.\n+     */\n+    public void addJoinClassConditions();\n+\n+    /**\n+     * Return the top-level joins for this select.\n+     */\n+    public Joins getJoins();\n+\n+    /**\n+     * Return the top-level {@link Join} elements for this select.\n+     */\n+    public Iterator getJoinIterator();\n+\n+    /**\n+     * The result start index.\n+     */\n+    public long getStartIndex();\n+\n+    /**\n+     * The result end index.\n+     */\n+    public long getEndIndex();\n+\n+    /**\n+     * Set the result range for this select.\n+     */\n+    public void setRange(long start, long end);\n+\n+    /**\n+     * Return the alias for the given column.\n+     */\n+    public String getColumnAlias(Column col);\n+\n+    /**\n+     * Return the alias for the given column.\n+     */\n+    public String getColumnAlias(Column col, Joins joins);\n+\n+    /**\n+     * Return the alias for the given column.\n+     */\n+    public String getColumnAlias(String col, Table table);\n+\n+    /**\n+     * Return the alias for the given column.\n+     */\n+    public String getColumnAlias(String col, Table table, Joins joins);\n+\n+    /**\n+     * Return true if this is an aggregate select.\n+     */\n+    public boolean isAggregate();\n+\n+    /**\n+     * Set to true for aggregate selects.\n+     */\n+    public void setAggregate(boolean agg);\n+\n+    /**\n+     * Return true if this select includes a LOB.\n+     */\n+    public boolean isLob();\n+\n+    /**\n+     * Set to true for selects that include LOB columns.\n+     */\n+    public void setLob(boolean lob);\n+\n+    /**\n+     * Clear the existing column selects.\n+     */\n+    public void clearSelects();\n+\n+    /**\n+     * Select the given SQL as a placeholder for a UNION element.\n+     */\n+    public void selectPlaceholder(String sql);\n+\n+    /**\n+     * Select the given SQL; the given id object is an identifier\n+     * to use when retrieving the corresponding value from a {@link Result}.\n+     *\n+     * @return true if selected\n+     */\n+    public boolean select(SQLBuffer sql, Object id);\n+\n+    /**\n+     * Select the given SQL; the given id object is an identifier\n+     * to use when retrieving the corresponding value from a {@link Result}.\n+     *\n+     * @return true if selected\n+     */\n+    public boolean select(SQLBuffer sql, Object id, Joins joins);\n+\n+    /**\n+     * Select the given SQL; the given id object is an identifier\n+     * to use when retrieving the corresponding value from a {@link Result}.\n+     *\n+     * @return true if selected\n+     */\n+    public boolean select(String sql, Object id);\n+\n+    /**\n+     * Select the given SQL; the given id object is an identifier\n+     * to use when retrieving the corresponding value from a {@link Result}.\n+     *\n+     * @return true if selected\n+     */\n+    public boolean select(String sql, Object id, Joins joins);\n+\n+    /**\n+     * Select the given column.\n+     *\n+     * @return true if selected\n+     */\n+    public boolean select(Column col);\n+\n+    /**\n+     * Select the given column.\n+     *\n+     * @return true if selected\n+     */\n+    public boolean select(Column col, Joins joins);\n+\n+    /**\n+     * Select the given columns.\n+     *\n+     * @return bit set of indexes of columns that were selected\n+     */\n+    public int select(Column[] cols);\n+\n+    /**\n+     * Select the given columns.\n+     *\n+     * @return bit set of indexes of columns that were selected\n+     */\n+    public int select(Column[] cols, Joins joins);\n+\n+    /**\n+     * Select the columns of the given mapping, possibly including subclasses.\n+     * This method should be called after all where conditions are added in\n+     * case the given mapping batches other selects.\n+     */\n+    public void select(ClassMapping mapping, int subclasses,\n+        JDBCStore store, JDBCFetchConfiguration fetch, int eager);\n+\n+    /**\n+     * Select the columns of the given mapping, possibly including subclasses.\n+     * This method should be called after all where conditions are added in\n+     * case the given mapping batches other selects.\n+     */\n+    public void select(ClassMapping mapping, int subclasses,\n+        JDBCStore store, JDBCFetchConfiguration fetch, int eager,\n+        Joins joins);\n+\n+    /**\n+     * Select the given column as one that can be used to get a count of\n+     * distinct matches. It is not necessary to designate distinct identifiers\n+     * when eagerly traversing the entire result of the select or when\n+     * not using an LRSSize setting of <code>count</code>.\n+     *\n+     * @return true if selected\n+     */\n+    public boolean selectIdentifier(Column col);\n+\n+    /**\n+     * Select the given column as one that can be used to get a count of\n+     * distinct matches. It is not necessary to designate distinct identifiers\n+     * when eagerly traversing the entire result of the select or when\n+     * not using an LRSSize setting of <code>count</code>.\n+     *\n+     * @return true if selected\n+     */\n+    public boolean selectIdentifier(Column col, Joins joins);\n+\n+    /**\n+     * Select the given columns as ones that can be used to get a count of\n+     * distinct matches. It is not necessary to designate distinct identifiers\n+     * when eagerly traversing the entire result of the select or when\n+     * not using an LRSSize setting of <code>count</code>.\n+     *\n+     * @return bit set of indexes of columns that were selected\n+     */\n+    public int selectIdentifier(Column[] cols);\n+\n+    /**\n+     * Select the given columns as ones that can be used to get a count of\n+     * distinct matches. It is not necessary to designate distinct identifiers\n+     * when eagerly traversing the entire result of the select or when\n+     * not using an LRSSize setting of <code>count</code>.\n+     *\n+     * @return bit set of indexes of columns that were selected\n+     */\n+    public int selectIdentifier(Column[] cols, Joins joins);\n+\n+    /**\n+     * Select the columns of the given mapping, possibly including subclasses.\n+     * This method should be called after all where conditions are added in\n+     * case the given mapping batches other selects.\n+     * The primary key columns of the mapping can be used to get a count of\n+     * distinct matches. It is not necessary to designate distinct identifiers\n+     * when eagerly traversing the entire result of the select or when\n+     * not using an LRSSize setting of <code>count</code>.\n+     */\n+    public void selectIdentifier(ClassMapping mapping, int subclasses,\n+        JDBCStore store, JDBCFetchConfiguration fetch, int eager);\n+\n+    /**\n+     * Select the columns of the given mapping, possibly including subclasses.\n+     * This method should be called after all where conditions are added in\n+     * case the given mapping batches other selects.\n+     * The primary key columns of the mapping can be used to get a count of\n+     * distinct matches. It is not necessary to designate distinct identifiers\n+     * when eagerly traversing the entire result of the select or when\n+     * not using an LRSSize setting of <code>count</code>.\n+     */\n+    public void selectIdentifier(ClassMapping mapping, int subclasses,\n+        JDBCStore store, JDBCFetchConfiguration fetch, int eager,\n+        Joins joins);\n+\n+    /**\n+     * Select the primary key columns of the given mapping, joining to\n+     * superclasses as necessary to get all columns needed to construct\n+     * an object id.\n+     *\n+     * @return bit set of indexes of pk columns that were selected\n+     */\n+    public int selectPrimaryKey(ClassMapping mapping);\n+\n+    /**\n+     * Select the primary key columns of the given mapping, joining to\n+     * superclasses as necessary to get all columns needed to construct\n+     * an object id.\n+     *\n+     * @return bit set of indexes of pk columns that were selected\n+     */\n+    public int selectPrimaryKey(ClassMapping mapping, Joins joins);\n+\n+    /**\n+     * Clear odering conditions.\n+     */\n+    public void clearOrdering();\n+\n+    /**\n+     * Order on the primary key columns of the given mapping,\n+     * joining to superclasses as necessary to get all columns needed to\n+     * construct an object id.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public int orderByPrimaryKey(ClassMapping mapping, boolean asc,\n+        boolean sel);\n+\n+    /**\n+     * Select and order on the primary key columns of the given mapping,\n+     * joining to superclasses as necessary to get all columns needed to\n+     * construct an object id.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public int orderByPrimaryKey(ClassMapping mapping, boolean asc,\n+        Joins joins, boolean sel);\n+\n+    /**\n+     * Order by the given column.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public boolean orderBy(Column col, boolean asc, boolean sel);\n+\n+    /**\n+     * Order by the given column.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public boolean orderBy(Column col, boolean asc, Joins joins,\n+        boolean sel);\n+\n+    /**\n+     * Order by the given columns.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public int orderBy(Column[] cols, boolean asc, boolean sel);\n+\n+    /**\n+     * Order by the given columns.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public int orderBy(Column[] cols, boolean asc, Joins joins, boolean sel);\n+\n+    /**\n+     * Add an ORDER BY clause.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public boolean orderBy(SQLBuffer sql, boolean asc, boolean sel);\n+\n+    /**\n+     * Add an ORDER BY clause.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public boolean orderBy(SQLBuffer sql, boolean asc, Joins joins,\n+        boolean sel);\n+\n+    /**\n+     * Add an ORDER BY clause.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public boolean orderBy(String sql, boolean asc, boolean sel);\n+\n+    /**\n+     * Add an ORDER BY clause.\n+     * Optionally selects ordering data if not already selected.\n+     */\n+    public boolean orderBy(String sql, boolean asc, Joins joins, boolean sel);\n+\n+    /**\n+     * Add where conditions setting the mapping's primary key to the given\n+     * oid values. If the given mapping does not use oid values for its\n+     * primary key, we will recursively join to its superclass until we find\n+     * an ancestor that does.\n+     */\n+    public void wherePrimaryKey(Object oid, ClassMapping mapping,\n+        JDBCStore store);\n+    \n+    \n+    /**\n+     * Add where conditions setting the mapping's primary key to the given\n+     * oid values. If the parmList is not null, the value of the primary\n+     * key will be collected and saved into the parmList. If the parmList is \n+     * null, this method will build the where clause with the value\n+     * incorporated in the where clause.\n+     */\n+    public int wherePrimaryKey(ClassMapping mapping, Column[] toCols, \n+            Column[] fromCols, Object oid, JDBCStore store, PathJoins pj,\n+            SQLBuffer buf, List parmList);\n+    \n+\n+    /**\n+     * Add where conditions setting the given foreign key to the given\n+     * oid values.\n+     *\n+     * @see #wherePrimaryKey\n+     */\n+    public void whereForeignKey(ForeignKey fk, Object oid,\n+        ClassMapping mapping, JDBCStore store);\n+\n+    /**\n+     * Add the given where conditions.\n+     */\n+    public void where(Joins joins);\n+\n+    /**\n+     * Add the given where conditions.\n+     */\n+    public void where(SQLBuffer sql);\n+\n+    /**\n+     * Add the given where conditions.\n+     */\n+    public void where(SQLBuffer sql, Joins joins);\n+\n+    /**\n+     * Add the given where conditions.\n+     */\n+    public void where(String sql);\n+\n+    /**\n+     * Add the given where conditions.\n+     */\n+    public void where(String sql, Joins joins);\n+\n+    /**\n+     * Add the given having conditions.\n+     */\n+    public void having(SQLBuffer sql);\n+\n+    /**\n+     * Add the given having conditions.\n+     */\n+    public void having(SQLBuffer sql, Joins joins);\n+\n+    /**\n+     * Add the given having conditions.\n+     */\n+    public void having(String sql);\n+\n+    /**\n+     * Add the given having conditions.\n+     */\n+    public void having(String sql, Joins joins);\n+\n+    /**\n+     * Group by the given column.\n+     */\n+    public void groupBy(Column col);\n+\n+    /**\n+     * Group by the given column.\n+     */\n+    public void groupBy(Column col, Joins joins);\n+\n+    /**\n+     * Group by the given columns.\n+     */\n+    public void groupBy(Column[] cols);\n+\n+    /**\n+     * Group by the given columns.\n+     */\n+    public void groupBy(Column[] cols, Joins joins);\n+\n+    /**\n+     * Add a GROUP BY clause.\n+     */\n+    public void groupBy(SQLBuffer sql);\n+\n+    /**\n+     * Add a GROUP BY clause.\n+     */\n+    public void groupBy(SQLBuffer sql, Joins joins);\n+\n+    /**\n+     * Add a GROUP BY clause.\n+     */\n+    public void groupBy(String sql);\n+\n+    /**\n+     * Add a GROUP BY clause.\n+     */\n+    public void groupBy(String sql, Joins joins);\n+\n+    /**\n+     * Group by the columns of the given mapping, possibly including subclasses.\n+     * Assumes EAGER_NONE.\n+     */\n+    public void groupBy(ClassMapping mapping, int subclasses, JDBCStore store, \n+        JDBCFetchConfiguration fetch);\n+\n+    /**\n+     * Group by the columns of the given mapping, possibly including subclasses.\n+     * Assumes EAGER_NONE.\n+     */\n+    public void groupBy(ClassMapping mapping, int subclasses, JDBCStore store, \n+        JDBCFetchConfiguration fetch, Joins joins);\n+\n+    /**\n+     * Return a SELECT with the same joins and where conditions as this one.\n+     *\n+     * @param sels number of selects to UNION together; ignored if &lt;= 1\n+     */\n+    public SelectExecutor whereClone(int sels);\n+\n+    /**\n+     * Return a SELECT that is a complete clone of this one.\n+     *\n+     * @param sels number of selects to UNION together; ignored if &lt;= 1\n+     */\n+    public SelectExecutor fullClone(int sels);\n+\n+    /**\n+     * Return a select that will be eagerly executed with this one, or null if\n+     * the\tselect cannot be created for the given key and join type.\n+     * If the join type is inner or outer, then this select instance will be\n+     * returned. Otherwise, the returned select will have a clone of this\n+     * select's where conditions and joins but will be independent.\n+     *\n+     * @param key the key for the eager select\n+     * @param eagerType one of the EAGER_* constants\n+     * @param toMany whether the eager join is to-many\n+     * @param sels number of selects to UNION together; ignored if &lt;= 1\n+     */\n+    public SelectExecutor eagerClone(FieldMapping key, int eagerType,\n+        boolean toMany, int sels);\n+\n+    /**\n+     * Return the eager select for the given key.\n+     */\n+    public SelectExecutor getEager(FieldMapping key);\n+\n+    /**\n+     * Return a new instance to use for joining.\n+     */\n+    public Joins newJoins();\n+\n+    /**\n+     * Return a new instance to use for outer joining.\n+     */\n+    public Joins newOuterJoins();\n+\n+    /**\n+     * Append the given joins to the given buffer.\n+     */\n+    public void append(SQLBuffer buf, Joins joins);\n+\n+    /**\n+     * AND the given joins together. The given joins will be hollowed in the\n+     * process.\n+     */\n+    public Joins and(Joins joins1, Joins joins2);\n+\n+    /**\n+     * OR the given joins together. The common joins will be removed in the\n+     * process.\n+     */\n+    public Joins or(Joins joins1, Joins joins2);\n+\n+    /**\n+     * Return a join set making the given joins outer joins.\n+     */\n+    public Joins outer(Joins joins);\n+\n+    /**\n+     * Implement toString to generate SQL string for profiling/debuggging.\n+     */\n+    public String toString();\n+}"},{"sha":"72aa438bf701368e89c5fcf0cf5af84da832b8b8","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectExecutor.java","status":"added","additions":153,"deletions":0,"changes":153,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectExecutor.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectExecutor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectExecutor.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a","patch":"@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+\n+/**\n+ * Interface for configuring and executing a SQL select.\n+ *\n+ * @author Abe White\n+ */\n+public interface SelectExecutor {\n+\n+    /**\n+     * Return the select configuration.\n+     */\n+    public JDBCConfiguration getConfiguration();\n+\n+    /**\n+     * Return this select as a SQL statement formatted for the current\n+     * dictionary.\n+     */\n+    public SQLBuffer toSelect(boolean forUpdate, JDBCFetchConfiguration fetch);\n+\n+    /**\n+     * Return this select as a COUNT SQL statement formatted for the current\n+     * dictionary.\n+     */\n+    public SQLBuffer toSelectCount();\n+\n+    /**\n+     * Whether to automatically make results distinct when relational joins\n+     * would otherwise introduce duplicates.\n+     */\n+    public boolean getAutoDistinct();\n+\n+    /**\n+     * Whether to automatically make results distinct when relational joins\n+     * would otherwise introduce duplicates.\n+     */\n+    public void setAutoDistinct(boolean distinct);\n+\n+    /**\n+     * Whether this is a SELECT DISTINCT / UNION ALL.\n+     */\n+    public boolean isDistinct();\n+\n+    /**\n+     * Whether this is a SELECT DISTINCT / UNION ALL.\n+     */\n+    public void setDistinct(boolean distinct);\n+\n+    /**\n+     * Whether the result of this select should be treated as a large\n+     * result set.\n+     */\n+    public boolean isLRS();\n+\n+    /**\n+     * Whether the result of this select should be treated as a large\n+     * result set.\n+     */\n+    public void setLRS(boolean lrs);\n+    \n+    /**\n+     * The expected result count for the query.\n+     */\n+    public int getExpectedResultCount();\n+\n+    /**\n+     * The expected result count for the query.\n+     *\n+     * @param force if false, the count will be discarded if this select has\n+     * any to-many eager joins that would throw off the result count\n+     */\n+    public void setExpectedResultCount(int expectedResultCount, boolean force);\n+\n+    /**\n+     * The join syntax for this select, as one of the syntax constants from\n+     * {@link JoinSyntaxes}.\n+     */\n+    public int getJoinSyntax();\n+\n+    /**\n+     * The join syntax for this select, as one of the syntax constants from\n+     * {@link JoinSyntaxes}.\n+     */\n+    public void setJoinSyntax(int joinSyntax);\n+\n+    /**\n+     * Return whether this select can support a random access result set type.\n+     */\n+    public boolean supportsRandomAccess(boolean forUpdate);\n+\n+    /**\n+     * Whether this select can be executed for update.\n+     */\n+    public boolean supportsLocking();\n+\n+    /**\n+     * Return the number of instances matching this select.\n+     */\n+    public int getCount(JDBCStore store)\n+        throws SQLException;\n+\n+    /**\n+     * Execute this select in the context of the given store manager.\n+     */\n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch)\n+        throws SQLException;\n+\n+    /**\n+     * Execute this select in the context of the given store manager.\n+     */\n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n+        List params) \n+        throws SQLException;\n+\n+    /**\n+     * Execute this select in the context of the given store manager.\n+     */\n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n+        int lockLevel, List params)\n+        throws SQLException;\n+\n+    /**\n+     * Execute this select in the context of the given store manager.\n+     */\n+    public Result execute(JDBCStore store, JDBCFetchConfiguration fetch,\n+        int lockLevel)\n+        throws SQLException;\n+}"},{"sha":"3237a97a482d66ac1a390c879bab81dacbe31b94","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"68420e72cb6188058d563e20b86b2f9a056001af","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Sized.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Sized.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Sized.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Sized.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"81464d5dc75a7b7dfc0b0a10e6701e00a61446a0","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java","status":"added","additions":323,"deletions":0,"changes":323,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"614994c0f72e3e5c8b0fe4428739fa00d5b345d9","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Union.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Union.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Union.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Union.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7bd28ce668ec6c1ebc3b62ca7ffd484328337fe7","filename":"1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/package.html","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/package.html","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/package.html?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"23a89461afcc0a221109c5801f499e374fa1c91f","filename":"1.2.x/openjpa-jdbc/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ProductDerivation","status":"added","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ProductDerivation","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ProductDerivation","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/resources/META-INF/services/org.apache.openjpa.lib.conf.ProductDerivation?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"6384f36cc27312f07886e2707e1f4f927702321a","filename":"1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/antlib.xml","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/antlib.xml","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/antlib.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/antlib.xml?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"13c497cbd3fe08523966d5f5f13b1489dd376a8b","filename":"1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/localizer.properties","status":"added","additions":19,"deletions":0,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/ant/localizer.properties?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"401cd51bb487eb55df3421efe5ddec8347194ad7","filename":"1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/conf/localizer.properties","status":"added","additions":246,"deletions":0,"changes":246,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/conf/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/conf/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/conf/localizer.properties?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"9a1d91c4616d59241e60d9598a65a52b289b4523","filename":"1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/exps/localizer.properties","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/exps/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/exps/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/exps/localizer.properties?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"5c918cd85318cbd7821ef97cce57a87f0a12d686","filename":"1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","status":"added","additions":117,"deletions":0,"changes":117,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b5111fcc26b6e5dde5fd4a887bc4d76857974994","filename":"1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/java-keywords.rsrc","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/java-keywords.rsrc","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/java-keywords.rsrc","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/java-keywords.rsrc?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"815e939edec7e7db2414e3469b1709a01f0dde82","filename":"1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/localizer.properties","status":"added","additions":417,"deletions":0,"changes":417,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/localizer.properties?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7a12b9fb29e6afd0efaf3565849a65f7a9d1655f","filename":"1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/strats/localizer.properties","status":"added","additions":139,"deletions":0,"changes":139,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/strats/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/strats/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/meta/strats/localizer.properties?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"cab55e1bef5782aabf0393cddd2d999ea85c868b","filename":"1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/localizer.properties","status":"added","additions":153,"deletions":0,"changes":153,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/localizer.properties?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"82dd2693311ef4c98da3a7a1ee92bc52a134bcc5","filename":"1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/schemas-doctype.rsrc","status":"added","additions":47,"deletions":0,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/schemas-doctype.rsrc","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/schemas-doctype.rsrc","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/schema/schemas-doctype.rsrc?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"1c8b9f7a1893281c714b4ae528d4f17d4f43801a","filename":"1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","status":"added","additions":179,"deletions":0,"changes":179,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"5a532772390880a8e0e9252db7efd7004b08724c","filename":"1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-error-state-codes.xml","status":"added","additions":146,"deletions":0,"changes":146,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-error-state-codes.xml","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-error-state-codes.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-error-state-codes.xml?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"952ae4c0d56976010a2d31e92226fa940b654aad","filename":"1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-keywords.rsrc","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-keywords.rsrc","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-keywords.rsrc","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-keywords.rsrc?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d35d9f7b00913a3e01f8a1496d87aab51e270b75","filename":"1.2.x/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java","status":"added","additions":882,"deletions":0,"changes":882,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8b9def9fd5ea58433272f3a5470ef36a84486893","filename":"1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar","status":"added","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"1ff224476d5e273eebfde43fb16df720381ce931","filename":"1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar.md5","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar.md5","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar.md5","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar.md5?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"dc1ea7a1720b73971f008e74c9eed948bfd36e32","filename":"1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar.sha1","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar.sha1","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar.sha1","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.jar.sha1?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c045dd729f1c7cca7745777cb3bbb8e4b6bfbbcb","filename":"1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3dc4f3a4b73c2ff3bafabc131b6d75fca1e6f72d","filename":"1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom.md5","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom.md5","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom.md5","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom.md5?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c90336c33b456a1e63aff8391fec721283ecc386","filename":"1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom.sha1","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom.sha1","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom.sha1","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/0.0.1/websphere_uow_api-0.0.1.pom.sha1?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"a474011bd0cb268bb0baa0f6be30633bf8b6b4c4","filename":"1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml","status":"added","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"73b10622e4e5c51e6eb114cd092203c908569426","filename":"1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml.md5","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml.md5","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml.md5","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml.md5?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b7520c252188a305299346309522424c70399da4","filename":"1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml.sha1","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml.sha1","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml.sha1","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/internal-repository/com/ibm/websphere/websphere_uow_api/maven-metadata.xml.sha1?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c42a685aebfca6eb13421ceee197157a5836cba2","filename":"1.2.x/openjpa-kernel/pom.xml","status":"added","additions":166,"deletions":0,"changes":166,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/pom.xml?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7851de74d54f24496e54917077a160d25aab09b3","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreBrokerFactory.java","status":"added","additions":148,"deletions":0,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreBrokerFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"258fd8145e3036d977055824bda89cb3494fa568","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java","status":"added","additions":520,"deletions":0,"changes":520,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/AbstractStoreManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"5382c2b4376fa1484d998cf78ae4d14bedd92e47","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/package.html","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/package.html","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/abstractstore/package.html?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"9232004a1c829eaea3b2e91ed7a9c1ed9fe540f2","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ant/ApplicationIdToolTask.java","status":"added","additions":112,"deletions":0,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ant/ApplicationIdToolTask.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ant/ApplicationIdToolTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ant/ApplicationIdToolTask.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"28aebb58c56f76d17366b2fa53e1999e6d83f811","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ant/MetaDataToolTask.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ant/MetaDataToolTask.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ant/MetaDataToolTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ant/MetaDataToolTask.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"f82fda0ca76450ed727863695bf86323a0441a70","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ant/PCEnhancerTask.java","status":"added","additions":91,"deletions":0,"changes":91,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ant/PCEnhancerTask.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ant/PCEnhancerTask.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ant/PCEnhancerTask.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"bc1d862d7d6816a24fd9e433b221584da8e37175","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ant/package.html","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ant/package.html","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ant/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ant/package.html?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8b1c09c448ae89cb086f0022af2e290ebe43e29a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/AutoDetachValue.java","status":"added","additions":88,"deletions":0,"changes":88,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/AutoDetachValue.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/AutoDetachValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/AutoDetachValue.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d70a112d1af14c17f02ade564cb8817fa02f657e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerFactoryValue.java","status":"added","additions":87,"deletions":0,"changes":87,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerFactoryValue.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerFactoryValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerFactoryValue.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"ee0db6ca06c1bc12aba1d8d5f5e108fde3bae2ef","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerValue.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerValue.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/BrokerValue.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7d6c43d2a8ea953f6f8c7ab72889bc8ebf7cf055","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java","status":"added","additions":92,"deletions":0,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c552ccd6d0a21b694f65acfb82ebeb9e0b39ad62","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java","status":"added","additions":253,"deletions":0,"changes":253,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c1276f97d1687ea1f79c1ae5d342e309186e23d4","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java","status":"added","additions":121,"deletions":0,"changes":121,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c054895ecb40c7a907af6da793301a412dde9dc3","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","status":"added","additions":272,"deletions":0,"changes":272,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"11abd55613b3bbba6b701160eaf64178d8c6a712","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/DetachOptions.java","status":"added","additions":160,"deletions":0,"changes":160,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/DetachOptions.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/DetachOptions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/DetachOptions.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"6762bd9614112d55a14eecc0dfca8bd8126dd486","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java","status":"added","additions":202,"deletions":0,"changes":202,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"10f6a2198df8e48f2a5e3808c3afcf10ed86190a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"af9e39019ec4629b8b97125bd1f68fb6a37177e8","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"a21de1125daa504788dacc3669cff889c1f225e4","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfiguration.java","status":"added","additions":1513,"deletions":0,"changes":1513,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfiguration.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"917d6c48e6391cdc3f93eb466a05a753f6624302","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","status":"added","additions":1447,"deletions":0,"changes":1447,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c0676b180e65a0eb872f404ffc3ff044cfa65b74","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"4d89d3eadbbefa7144d57b337ef71aebe7e3447c","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersion.java","status":"added","additions":143,"deletions":0,"changes":143,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersion.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersion.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"6cad968c6bda1d584bcc6e4a41b04b0a182d94f8","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersionAndConfigurationTypeValidationPolicy.java","status":"added","additions":66,"deletions":0,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersionAndConfigurationTypeValidationPolicy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersionAndConfigurationTypeValidationPolicy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersionAndConfigurationTypeValidationPolicy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b504a60e2ad4db18b5b976ae246664c08a395dd8","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","status":"added","additions":95,"deletions":0,"changes":95,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"58a371283f56a1f59617ac1caadaafb051cd4c06","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/RemoteCommitProviderValue.java","status":"added","additions":140,"deletions":0,"changes":140,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/RemoteCommitProviderValue.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/RemoteCommitProviderValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/RemoteCommitProviderValue.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d04108b5d16ff30ba7e6487ac989ca86c91e8e4e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/SeqValue.java","status":"added","additions":49,"deletions":0,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/SeqValue.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/SeqValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/SeqValue.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b9c3af5ce3ccdfa2e44466cafa26ad6ed590ef80","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/package.html","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/package.html","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/conf/package.html?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"9e7c732b14e56a491e1ce784e2fd07db134cc72b","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","status":"added","additions":455,"deletions":0,"changes":455,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"6adbd8bc58e4e1ef1e2ea28e14188d64e73280e7","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","status":"added","additions":322,"deletions":0,"changes":322,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"6e582ea09f6c81b5ba4599643a49b90154422506","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/Caches.java","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/Caches.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/Caches.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/Caches.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3208e640c7bfb985fbb4d4240c88910df3998f98","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentDataCache.java","status":"added","additions":153,"deletions":0,"changes":153,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentDataCache.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"fd1a44f641c41fb2f51e70e69f3433d90fb85154","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentQueryCache.java","status":"added","additions":140,"deletions":0,"changes":140,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentQueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentQueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ConcurrentQueryCache.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"cb3d09c62a10700e7a0c0399a7606bce54ac99c7","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCache.java","status":"added","additions":267,"deletions":0,"changes":267,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCache.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCache.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"034bec13200463fd56b6f95f78580be5b60ed2a5","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManager.java","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d5a4308b4148f0be4bba02ad98c913d0895e881e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManagerImpl.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheManagerImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"099b40faf90576a88096a32e32377877d9f4316e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCData.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCData.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCData.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"950b44eec6337461112427997b328e0f0db7f68b","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataGenerator.java","status":"added","additions":255,"deletions":0,"changes":255,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataGenerator.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"130e97fa41df7d209e6c9feb67c3cbc906351eea","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataImpl.java","status":"added","additions":209,"deletions":0,"changes":209,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCachePCDataImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"6224fe80c510fc51211971195b338796e746c23d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","status":"added","additions":248,"deletions":0,"changes":248,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"999129ec113b6141c6b2690d9b2c0d5098d84d9a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","status":"added","additions":744,"deletions":0,"changes":744,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheStoreManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8db30d3a95514238157f751d250be97eb8cc8d3f","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingDataCache.java","status":"added","additions":348,"deletions":0,"changes":348,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingDataCache.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"59bf8992769eb78ded661946ff50f6c81351aa7f","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingQueryCache.java","status":"added","additions":219,"deletions":0,"changes":219,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingQueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingQueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DelegatingQueryCache.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"1cf40fbbead5ef41fead2d64254204aad32428f3","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationEvent.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationEvent.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationEvent.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"915f4fb1d42f12928556166d4c57c7cc94a270b9","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationListener.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/ExpirationListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"07e8931bcbe766a3bfb1f0404c75d41d9c6fdf32","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCache.java","status":"added","additions":138,"deletions":0,"changes":138,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCache.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"4b5722ee5a6712d6b75d0c08314b627165b8eb0d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","status":"added","additions":670,"deletions":0,"changes":670,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"43f962ebaf33b09171be6fc083da7b4e5d32df49","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryKey.java","status":"added","additions":469,"deletions":0,"changes":469,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryKey.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryKey.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"2e46304704845e0dd4a137829fe4fc5276768d1a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryResult.java","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryResult.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryResult.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryResult.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"48060101c8d77e3493c38afc52c373aa884a595d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedEvent.java","status":"added","additions":52,"deletions":0,"changes":52,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedEvent.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedEvent.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8d07e89f8b9ac684ad8584c6b9539a6f87177ac2","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedListener.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/TypesChangedListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"1741bad61dfc06868150052060a81826e4513829","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/package.html","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/package.html","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/package.html?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c8d6e9e96baaf26e8dd5fff105f4b0ee90899738","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/AbstractManagedRuntime.java","status":"added","additions":108,"deletions":0,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/AbstractManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/AbstractManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/AbstractManagedRuntime.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"0c072a08b73a67fb47907a41e11b01b00543add3","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/AutomaticManagedRuntime.java","status":"added","additions":314,"deletions":0,"changes":314,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/AutomaticManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/AutomaticManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/AutomaticManagedRuntime.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"9324439ef3bb54b3084446ce8afda67db5997209","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/InvocationManagedRuntime.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/InvocationManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/InvocationManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/InvocationManagedRuntime.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"39159fbfd217b1c7ca52ba501c169c036872500d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","status":"added","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/JNDIManagedRuntime.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"0ef4a0983b02fb938148527c9284f9fa50b6a7f2","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/ManagedRuntime.java","status":"added","additions":91,"deletions":0,"changes":91,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/ManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/ManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/ManagedRuntime.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"eb8350c8cac2c4cf1aa8cf128cbb3513fede34db","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/RegistryManagedRuntime.java","status":"added","additions":207,"deletions":0,"changes":207,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/RegistryManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/RegistryManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/RegistryManagedRuntime.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c4c3a4eca5480ace14ddb605739f531a803ac927","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/SunOneManagedRuntime.java","status":"added","additions":61,"deletions":0,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/SunOneManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/SunOneManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/SunOneManagedRuntime.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"74116ec4c76f7dd0813c1e1fe257e9b2357260c7","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WASManagedRuntime.java","status":"added","additions":398,"deletions":0,"changes":398,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WASManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WASManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WASManagedRuntime.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"4220609d7197dd4321d98a830028555c6ee42119","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WASRegistryManagedRuntime.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WASRegistryManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WASRegistryManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WASRegistryManagedRuntime.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"e3faf06ad7b9f44908245a9410f71bddc0ba44c8","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WLSManagedRuntime.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WLSManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WLSManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/WLSManagedRuntime.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"98622262780d4415f07c6409f118a015afdf0be4","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/package.html","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/package.html","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/ee/package.html?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"a4e968dade96b105d9b6612e6c9603f294406d63","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ApplicationIdTool.java","status":"added","additions":1483,"deletions":0,"changes":1483,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ApplicationIdTool.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ApplicationIdTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ApplicationIdTool.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"f3be4a540ad4c9739e7306f99cd18ee6afe215e7","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"fa76f87bea5bec925be8ae667cfe484d765fb8f1","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","status":"added","additions":152,"deletions":0,"changes":152,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"981937aa634ab3e581be80d2067968ba47b0eac5","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/CodeGenerator.java","status":"added","additions":620,"deletions":0,"changes":620,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/CodeGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/CodeGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/CodeGenerator.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"04516f04797c67347c12a9b0644c4d412f566cf1","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"61fc603e90414e4cbe71faf7451e9b0690e64598","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorage.java","status":"added","additions":141,"deletions":0,"changes":141,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorage.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorage.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorage.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"a7a7a573abd258df4cf7791cdb2ffd6fa432fff1","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorageGenerator.java","status":"added","additions":536,"deletions":0,"changes":536,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorageGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorageGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicStorageGenerator.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"06bfdc5dbc57b6fbefff82950f7f7e40e9224dcd","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldConsumer.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldConsumer.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldConsumer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldConsumer.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"184a36f3e84d3ed94339edd11236f87bac72ff24","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldManager.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"838a520cb00554d2afdd7d7f925689a1e291e515","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldSupplier.java","status":"added","additions":75,"deletions":0,"changes":75,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldSupplier.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldSupplier.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/FieldSupplier.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"505b5ff25e5777465e8ebc1530798393c94295d2","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/InstrumentationFactory.java","status":"added","additions":123,"deletions":0,"changes":123,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/InstrumentationFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/InstrumentationFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/InstrumentationFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"53cc3c137eb884e96b6ed48a0b9479bc522965b3","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","status":"added","additions":302,"deletions":0,"changes":302,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"1934f15390de20ac7b0d8f4ece8a99f3465dee02","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b564a06625c319705be539b2b95998f0ae13d4d0","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","status":"added","additions":228,"deletions":0,"changes":228,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCClassFileTransformer.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8c189ee45efc67b140616a8e02a0d777eb65bb5f","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","status":"added","additions":1077,"deletions":0,"changes":1077,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"793c03e9d86d40cfada2169a4d0e1dbb623ae1a0","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","status":"added","additions":4535,"deletions":0,"changes":4535,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8c72a7d376189d6ad6bbae552f9ff6ae726b34e3","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java","status":"added","additions":130,"deletions":0,"changes":130,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancerAgent.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"9d5b213ff7f59726016d7f2ae7b07449b5b9958a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","status":"added","additions":288,"deletions":0,"changes":288,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"fa825746fd4de9ca83cdea430105cccf24e4c8ab","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","status":"added","additions":272,"deletions":0,"changes":272,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"205a680f182378725a9fad6e361b5c85de090d59","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PersistenceCapable.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PersistenceCapable.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"85ecedbf1169d63c6d6bd632bc09262218fc2f77","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","status":"added","additions":237,"deletions":0,"changes":237,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"869c5e81ff3c35ee28d684eadae4ab7318572f2e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","status":"added","additions":387,"deletions":0,"changes":387,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8b578368ad881978faa631f3fefc1110242a9050","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/Reflection.java","status":"added","additions":757,"deletions":0,"changes":757,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/Reflection.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/Reflection.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/Reflection.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"73a16b20967c270f9a4e06fac6116586f8ee7e9e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClassesModes.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClassesModes.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClassesModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClassesModes.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8066b3791db6a0b7ed68f73e22039c47e49b6dca","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"fbe451ad7be35bdc89c1fff4d54a3d398d25ca1e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/StateManager.java","status":"added","additions":286,"deletions":0,"changes":286,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/StateManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/StateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/StateManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c859bd87435b3a024a0d9efcf9300c2e75f2aa7e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/package.html","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/package.html","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/package.html?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"87778962ad87a8e495c57f70f173ebc021533fa3","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractLifecycleListener.java","status":"added","additions":108,"deletions":0,"changes":108,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractLifecycleListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractLifecycleListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractLifecycleListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"1798e553b1e5fffbd6e070e860809082eef85f76","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractRemoteCommitProvider.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractRemoteCommitProvider.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"bbc398af88ecff71c911d78f6b3a942143f36517","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractTransactionListener.java","status":"added","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractTransactionListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractTransactionListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/AbstractTransactionListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3c11bb2b49a6d03d726b5d0823e2f1383707f7b2","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/AttachListener.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/AttachListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/AttachListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/AttachListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"2f7ffecf94568f4bce117064f081b38af4182159","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeanLifecycleCallbacks.java","status":"added","additions":100,"deletions":0,"changes":100,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeanLifecycleCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeanLifecycleCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeanLifecycleCallbacks.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"e516b115f8671c5e41e13541d2034f97f04710bb","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeginTransactionListener.java","status":"added","additions":36,"deletions":0,"changes":36,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeginTransactionListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeginTransactionListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BeginTransactionListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3786a551c44162f7a8638237aee81e68d958e4d6","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"925d079398a3a31ba16ab24455c722632c04f555","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"12ba15dc639e0da141570874ce330641bb505ab6","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"f757b92d970baa1b7f783bab87c6d6486f929dd9","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/CallbackModes.java","status":"added","additions":53,"deletions":0,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/CallbackModes.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/CallbackModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/CallbackModes.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"03b1a8089365e5e09b7bfe6370d0a7dc6753c24b","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/ClearListener.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/ClearListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/ClearListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/ClearListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"fbd67614f54ad82c8f11befcfbd6c7f4160c54fa","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/DeleteListener.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/DeleteListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/DeleteListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/DeleteListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8a6b25a2448799fc3fbb45ac16b0768252a4a149","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/DetachListener.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/DetachListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/DetachListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/DetachListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8bd8004cf16e028a9706406be572da64de7530e9","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/DirtyListener.java","status":"added","additions":48,"deletions":0,"changes":48,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/DirtyListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/DirtyListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/DirtyListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"6172ef4cb48398f863ed979bcbb67e384ffbd4cc","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/EndTransactionListener.java","status":"added","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/EndTransactionListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/EndTransactionListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/EndTransactionListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"2b956c8e5de872960ed54fa2ad2e7e085177ca15","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/ExceptionOrphanedKeyAction.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/ExceptionOrphanedKeyAction.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/ExceptionOrphanedKeyAction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/ExceptionOrphanedKeyAction.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d71700edfdbaf49d9dcef8a4ba2097ba477cdf39","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/FlushTransactionListener.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/FlushTransactionListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/FlushTransactionListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/FlushTransactionListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"39ada6c18bcae64908600bd1d911d3c3a924378e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/JMSRemoteCommitProvider.java","status":"added","additions":284,"deletions":0,"changes":284,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/JMSRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/JMSRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/JMSRemoteCommitProvider.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"af9aebf4b54075e350717ddc579770e62575ae4f","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleCallbacks.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleCallbacks.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"bb8cf0127e1405a196416071fc7289b258aa5d32","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEvent.java","status":"added","additions":217,"deletions":0,"changes":217,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEvent.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEvent.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"6003ae0643efc2d07fef417013fbedc73c3ef34b","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","status":"added","additions":648,"deletions":0,"changes":648,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleEventManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"f7cec6312182ef704ac1326655e87b802d340bab","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleListener.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LifecycleListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"0e2f28384fd8418c7890901f41883d6e10ca4913","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LoadListener.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LoadListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LoadListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LoadListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"44cce1f57f270b956338c77f12afad7f985c3272","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LogOrphanedKeyAction.java","status":"added","additions":107,"deletions":0,"changes":107,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LogOrphanedKeyAction.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LogOrphanedKeyAction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/LogOrphanedKeyAction.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"77be27c91d97d60f8bded7c1d1599f846e10050b","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/MethodLifecycleCallbacks.java","status":"added","additions":160,"deletions":0,"changes":160,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/MethodLifecycleCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/MethodLifecycleCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/MethodLifecycleCallbacks.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c7f7c8623fc10c6c957a1b09ff9b3bb42af12336","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/NoneOrphanedKeyAction.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/NoneOrphanedKeyAction.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/NoneOrphanedKeyAction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/NoneOrphanedKeyAction.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"4a14a9d382b41da4ccc34531a38aa2100330cd66","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/OrphanedKeyAction.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/OrphanedKeyAction.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/OrphanedKeyAction.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/OrphanedKeyAction.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"2af5a3fb516893f48f52f1d78d28e33b350f30f9","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/PersistListener.java","status":"added","additions":37,"deletions":0,"changes":37,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/PersistListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/PersistListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/PersistListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7273d0c0b51f5e3e31a480203c4e514db9d5cbd7","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"76a54c7317ec89626d1bad313dae009880771d55","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","status":"added","additions":33,"deletions":0,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"5036e44f836f259ed629e10402443c4ca90586dd","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java","status":"added","additions":198,"deletions":0,"changes":198,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEvent.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"4f87e14426c0a35b9258e6ac0543b7faf898195d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","status":"added","additions":253,"deletions":0,"changes":253,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"415e85a99e0d36196faf9e4a1e8e135223b5a991","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitListener.java","status":"added","additions":60,"deletions":0,"changes":60,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"eaa2f16f8774b7d0c29b181aef649129b244c568","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitProvider.java","status":"added","additions":62,"deletions":0,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitProvider.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c8a449a22371aa0c9f3b8a107b3f6258419317b9","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"6023b785dba6354212419d58abc2ff76454f0fda","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/StoreListener.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/StoreListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/StoreListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/StoreListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"987cafaf0196195fa3805f52f169caac6ea61258","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","status":"added","additions":948,"deletions":0,"changes":948,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"0a8eb7a1cba610e729656a1bb3512cd396a81a74","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEvent.java","status":"added","additions":156,"deletions":0,"changes":156,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEvent.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEvent.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"adcd0dd1b3672c26af8f24df965e11e7881590b0","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","status":"added","additions":129,"deletions":0,"changes":129,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d675d908a8149aff449d9ea2b8583e39446f20ec","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionListener.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b274521db182f31111753362c44adc133ad15974","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"09033a097969089a399a14a6615e86e2e4faa357","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/package.html","status":"added","additions":30,"deletions":0,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/package.html","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/package.html","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/event/package.html?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7659a9bc5208740017a2e674b9fa5fcb6fcbcb26","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","status":"added","additions":827,"deletions":0,"changes":827,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d677041290bdbe122151736749a7a4d91adaeb0a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractFieldManager.java","status":"added","additions":112,"deletions":0,"changes":112,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractFieldManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8e14fc09329099dfb8a3856f2016b3b158d90831","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractLockManager.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractLockManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d14712996cde315d011e4362b640e4a7b0e54358","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCData.java","status":"added","additions":421,"deletions":0,"changes":421,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCData.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCData.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3338f59a233d84d0def67d6a08f58e035809c2c8","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCResultObjectProvider.java","status":"added","additions":172,"deletions":0,"changes":172,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractPCResultObjectProvider.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"f8f12dc4b9445a3d4537d5af367e2f602076abc1","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","status":"added","additions":190,"deletions":0,"changes":190,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"a1e7b873c17cedb6d1352fc219e4ee43f9f81cbd","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","status":"added","additions":338,"deletions":0,"changes":338,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"fa9e0f2a78081749d78b1aadbce325014746b8f4","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java","status":"added","additions":512,"deletions":0,"changes":512,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"59169e2265c3b98cc616619d41bb2d3c18e79c05","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoClear.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoClear.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoClear.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoClear.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"cac90d7731ef07cb57e9b89aadf87271a206c369","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoDetach.java","status":"added","additions":46,"deletions":0,"changes":46,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoDetach.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoDetach.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AutoDetach.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"4af5d2a8c8c9e874a7ef8f3d29e892f8c26bec9a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java","status":"added","additions":163,"deletions":0,"changes":163,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Bootstrap.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"e945eba5a8173d770370f8784e006b528173378d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Broker.java","status":"added","additions":718,"deletions":0,"changes":718,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Broker.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Broker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Broker.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"0592d73f1846b6789170645d01594da933242d35","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java","status":"added","additions":121,"deletions":0,"changes":121,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"60ac73f3c193e4b87585ad1342d99f3d35f66f02","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"added","additions":4755,"deletions":0,"changes":4755,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"f55785b333b351b6a6b95ac18d66ddb604882c88","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ClearFieldManager.java","status":"added","additions":78,"deletions":0,"changes":78,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ClearFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ClearFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ClearFieldManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c00f6e37a35621877c39cba13ee2cd6bcf7f316b","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ConnectionRetainModes.java","status":"added","additions":45,"deletions":0,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ConnectionRetainModes.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ConnectionRetainModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ConnectionRetainModes.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8e97520f1fd1b2072511a3d2f8f64b3922b979e7","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","status":"added","additions":1387,"deletions":0,"changes":1387,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBroker.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"bcf88c7338ebaa10cf132e5a1c2a0eaf67dbd710","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBrokerFactory.java","status":"added","additions":212,"deletions":0,"changes":212,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingBrokerFactory.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"4bc67a63a0d36e60681a96660bedfdff21976311","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingExtent.java","status":"added","additions":185,"deletions":0,"changes":185,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingExtent.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingExtent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingExtent.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"dcbe31ecc42fece127fa3bc9e56aba9391459d43","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","status":"added","additions":481,"deletions":0,"changes":481,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingFetchConfiguration.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"e6e9a30e0814e1301d8966c3da80889a7f11521c","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java","status":"added","additions":651,"deletions":0,"changes":651,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingQuery.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3eba25d98e79ea6704410ee115003cf45bacc430","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingResultList.java","status":"added","additions":438,"deletions":0,"changes":438,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingResultList.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingResultList.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d45d0fb3151078d9dfbedab7934d3c4902444d6b","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingSeq.java","status":"added","additions":134,"deletions":0,"changes":134,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingSeq.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingSeq.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"adaa2e97b18e41c23c328afbada50d9c3505e30a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java","status":"added","additions":202,"deletions":0,"changes":202,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DelegatingStoreManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b821825c8b4aa5e713249658d476416517d7f007","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","status":"added","additions":835,"deletions":0,"changes":835,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"18fd09b0e2dc420cb014ca472f3a63d1eed8ab94","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachState.java","status":"added","additions":50,"deletions":0,"changes":50,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"51fc74de7e785bae8b940863b20de5d602dc154f","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","status":"added","additions":197,"deletions":0,"changes":197,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateAttachStrategy.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"5476ee05ded870358111d5a614290f3b3e30e2ac","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","status":"added","additions":949,"deletions":0,"changes":949,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"174e70dcd5b856075a2df8d32df43fb3bca94971","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","status":"added","additions":597,"deletions":0,"changes":597,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedValueStateManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3b42701141ea2d342fe8c184212cf54f79458d49","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECleanState.java","status":"added","additions":86,"deletions":0,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECleanState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECleanState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECleanState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"1fae43122644b8cb9761c4efff73c9d4445a2043","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECopyState.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECopyState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECopyState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ECopyState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"71a32a184530adad9ae3c96cf017763d2f3093e9","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDeletedState.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDeletedState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDeletedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDeletedState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"65cb520d91474c5e41a102741458409fd04903ed","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDirtyState.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDirtyState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDirtyState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/EDirtyState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"4d60fd5a7e5ca0c50191276aa5c5e53fd96d949d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ENonTransState.java","status":"added","additions":77,"deletions":0,"changes":77,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ENonTransState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ENonTransState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ENonTransState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"e67abfb14544a32fce9f5fc64a3a8ab6d460512c","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java","status":"added","additions":743,"deletions":0,"changes":743,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExpressionStoreQuery.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"75a6c82a0c2763298ffe71171326a44b06412c2d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Extent.java","status":"added","additions":91,"deletions":0,"changes":91,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Extent.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Extent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Extent.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"dd7a8a759847ad0cc42c218b96d791ef01cfcd3f","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","status":"added","additions":353,"deletions":0,"changes":353,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"1fdfce43adec63d620615ed4121a271c03a48723","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","status":"added","additions":363,"deletions":0,"changes":363,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfiguration.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"9363edb9daf678d36f7e7841b05435fb08037481","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","status":"added","additions":748,"deletions":0,"changes":748,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FetchConfigurationImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"e056934155b142c30d7d84c649b1d6b291a88e1e","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","status":"added","additions":903,"deletions":0,"changes":903,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"fa368680df9312b6e5d21ae2ebe7a2e9046fd5c4","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FinalizingBrokerImpl.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FinalizingBrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FinalizingBrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FinalizingBrokerImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"fd69b31f7304ef58197deb1d9e7ff98f41dd81e5","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FindCallbacks.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FindCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FindCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/FindCallbacks.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8185a73be2df818e296f84a6324abebac2234ed1","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/HollowState.java","status":"added","additions":83,"deletions":0,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/HollowState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/HollowState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/HollowState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"ac5251b693da28662de308252543cdc5332f8093","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InMemorySavepointManager.java","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InMemorySavepointManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InMemorySavepointManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InMemorySavepointManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"2c89e07661fae8e879f5e3596978a751cd773480","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InverseManager.java","status":"added","additions":409,"deletions":0,"changes":409,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InverseManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InverseManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/InverseManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"ab422de8849817747a624bb20b7c57026b461268","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LocalManagedRuntime.java","status":"added","additions":215,"deletions":0,"changes":215,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LocalManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LocalManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LocalManagedRuntime.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"6a18d96be5c0d240b24d808344ffe64200a73290","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockLevels.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockLevels.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockLevels.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockLevels.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"c9a88f87fd187bc9bef8d1f7defc3a5cd71a29a7","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockManager.java","status":"added","additions":111,"deletions":0,"changes":111,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/LockManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"36371784c0363c4151b8eeee698d1b84d04b7d15","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java","status":"added","additions":309,"deletions":0,"changes":309,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"141ac7850f6333b284f7ee67e34c17004b37a7ba","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java","status":"added","additions":262,"deletions":0,"changes":262,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/MethodStoreQuery.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"ceeb77d3db46c9e0b00306fe97e68cbf7dd30909","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/NoneLockManager.java","status":"added","additions":41,"deletions":0,"changes":41,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/NoneLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/NoneLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/NoneLockManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"99cdcaab6642a673675a9f86ae2f80a4089efbca","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","status":"added","additions":739,"deletions":0,"changes":739,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ObjectIdStateManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"12fcaff9d1b4c70e649699133cc197146547650a","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpCallbacks.java","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpCallbacks.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpCallbacks.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpCallbacks.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3effd27e0d3a956e8d18b437ca4ddf9a6e7d5c08","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPASavepoint.java","status":"added","additions":128,"deletions":0,"changes":128,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPASavepoint.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPASavepoint.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPASavepoint.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"a6f44dc4386223b86642d2b36933eadb728e61c9","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java","status":"added","additions":502,"deletions":0,"changes":502,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OpenJPAStateManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"e00bc6d59972f8f90947ce72a7117a8bda16bfa7","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OrderingMergedResultObjectProvider.java","status":"added","additions":111,"deletions":0,"changes":111,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OrderingMergedResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OrderingMergedResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/OrderingMergedResultObjectProvider.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"78c1bde3f537cc54c740066e158649caffaa040c","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCData.java","status":"added","additions":107,"deletions":0,"changes":107,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCData.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCData.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"7b3233a7e5335b6227aecd3ad8aabca795a3647c","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCDataImpl.java","status":"added","additions":313,"deletions":0,"changes":313,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCDataImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCDataImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCDataImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"44f267eba47b87fa03af2617d06090283000c85d","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCResultObjectProvider.java","status":"added","additions":42,"deletions":0,"changes":42,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCResultObjectProvider.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCResultObjectProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCResultObjectProvider.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"f9efd77879850ab4a18c0481408d99ca4b690cb8","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCState.java","status":"added","additions":496,"deletions":0,"changes":496,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d975c3ab18ccacadcbc2fa480d984ab02516634c","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCleanState.java","status":"added","additions":85,"deletions":0,"changes":85,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCleanState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCleanState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PCleanState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3b7b66607ae038520a97c1ffd40d5f0b52fa7654","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedFlushedState.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedFlushedState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedFlushedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedFlushedState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"8d9c6350d8867da9d754c13b470ceae3dac6fad1","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedState.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDeletedState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"1425c79fdb6bdd432602381712b3605407b157f1","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDirtyState.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDirtyState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDirtyState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PDirtyState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b61fee96811bfc25caa67cde3bb142087a4aec4b","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewDeletedState.java","status":"added","additions":92,"deletions":0,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewDeletedState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewDeletedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewDeletedState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"0030c72ab813b0aa7359504503f7fba97be320f6","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedFlushedState.java","status":"added","additions":38,"deletions":0,"changes":38,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedFlushedState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedFlushedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedFlushedState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"ff72ce00747876072e4a758620f8d1d2fa15937f","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedState.java","status":"added","additions":94,"deletions":0,"changes":94,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewFlushedDeletedState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b6718ff2b9a15bf8495b8b676f6dde54348c07a0","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewProvisionalState.java","status":"added","additions":93,"deletions":0,"changes":93,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewProvisionalState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewProvisionalState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewProvisionalState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"0b62fb3d54d5c6f907a262a4fb8419f2deac6356","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewState.java","status":"added","additions":93,"deletions":0,"changes":93,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNewState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"a66863690bba6fd3988143d712f58d3af3e55b19","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDeletedState.java","status":"added","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDeletedState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDeletedState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDeletedState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"93f50219bf84fc1c69b0adb7db6c45971cca07d9","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDirtyState.java","status":"added","additions":69,"deletions":0,"changes":69,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDirtyState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDirtyState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransDirtyState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"2f313ce7fbc50e97a2f87e8867cf3ce0530c0040","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransNewState.java","status":"added","additions":63,"deletions":0,"changes":63,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransNewState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransNewState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransNewState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d629a8a25e8e9f2cd22bd084a732e3a278992c8b","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransState.java","status":"added","additions":122,"deletions":0,"changes":122,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/PNonTransState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"ae3ef4d6b27dd6cf0dfeb44ed3c4e578c8b2e896","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Query.java","status":"added","additions":193,"deletions":0,"changes":193,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Query.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Query.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Query.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d493ffa1ed50fe9edf1b221b3c1cff11930b8fca","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryContext.java","status":"added","additions":284,"deletions":0,"changes":284,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryContext.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryContext.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryContext.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"d4094545f1ddca23932200b2a39be7a29d3d31de","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryFlushModes.java","status":"added","additions":57,"deletions":0,"changes":57,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryFlushModes.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryFlushModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryFlushModes.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"43e1e0f7af19f39292e86d3cf43656e2d4785acc","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryHints.java","status":"added","additions":31,"deletions":0,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryHints.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryHints.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryHints.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b23f5b90bb923c46a1af6e0559ff852a0f120f46","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","status":"added","additions":2162,"deletions":0,"changes":2162,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"ea7dc696eb4b6aac1f312833d3b66e0f16a666c6","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryLanguages.java","status":"added","additions":70,"deletions":0,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryLanguages.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryLanguages.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryLanguages.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"2b96c20f3875180cb8a643bd4b876945ad4c1075","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryOperations.java","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryOperations.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryOperations.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryOperations.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"43c4821208e7a6d8627f558a0d4d5a68deae8fe0","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ROPStoreManager.java","status":"added","additions":80,"deletions":0,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ROPStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ROPStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ROPStoreManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"3142e50e790defc358006cfc66a9b0d251db6460","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/RestoreState.java","status":"added","additions":43,"deletions":0,"changes":43,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/RestoreState.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/RestoreState.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/RestoreState.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"28f2abee3f625913fda5d9e5b569c0109b1b02f3","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java","status":"added","additions":357,"deletions":0,"changes":357,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ResultPacker.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"9a8b0f45b1c4911b72dbe6238efacf964d297f53","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","status":"added","additions":245,"deletions":0,"changes":245,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SaveFieldManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"b68890f6b4c2d5fe6509c4fa4625a5efc8042a88","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointFieldManager.java","status":"added","additions":246,"deletions":0,"changes":246,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointFieldManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"f95a39b5c9e91118debaa630cf3a7bd598239ffc","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointManager.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SavepointManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"e7365241d6f2d9e6cc8d84801015494323758176","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Seq.java","status":"added","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Seq.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Seq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Seq.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"},{"sha":"5ea1fc677b10299319bc26cf0480946510a5a86b","filename":"1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","status":"added","additions":865,"deletions":0,"changes":865,"blob_url":"https://github.com/apache/openjpa/blob/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","raw_url":"https://github.com/apache/openjpa/raw/f290fad39391ba583289c4abfe52d3f81f95d18a/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/1.2.x/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/SingleFieldManager.java?ref=f290fad39391ba583289c4abfe52d3f81f95d18a"}]}

