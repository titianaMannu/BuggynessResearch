{"sha":"f2a266c4c2dde0124814c16776f020c120a8ccf2","node_id":"MDY6Q29tbWl0MjA2MzY0OmYyYTI2NmM0YzJkZGUwMTI0ODE0YzE2Nzc2ZjAyMGMxMjBhOGNjZjI=","commit":{"author":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-08-02T22:23:32Z"},"committer":{"name":"A. Abram White","email":"awhite@apache.org","date":"2006-08-02T22:23:32Z"},"message":"Allow null load-fetch-group.  Allow a DFG field to have a different \nload-fetch-group.  \n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/openjpa/trunk@428177 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"bb9758338a444f53c89f93fe6c0205686833956c","url":"https://api.github.com/repos/apache/openjpa/git/trees/bb9758338a444f53c89f93fe6c0205686833956c"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/f2a266c4c2dde0124814c16776f020c120a8ccf2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/f2a266c4c2dde0124814c16776f020c120a8ccf2","html_url":"https://github.com/apache/openjpa/commit/f2a266c4c2dde0124814c16776f020c120a8ccf2","comments_url":"https://api.github.com/repos/apache/openjpa/commits/f2a266c4c2dde0124814c16776f020c120a8ccf2/comments","author":null,"committer":null,"parents":[{"sha":"b3f8f9de489afbc4bfa18bacaf8e3101944c0510","url":"https://api.github.com/repos/apache/openjpa/commits/b3f8f9de489afbc4bfa18bacaf8e3101944c0510","html_url":"https://github.com/apache/openjpa/commit/b3f8f9de489afbc4bfa18bacaf8e3101944c0510"}],"stats":{"total":128,"additions":62,"deletions":66},"files":[{"sha":"957a9ea602b744c724bce3d09c01db18a8eccdc4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","status":"modified","additions":37,"deletions":47,"changes":84,"blob_url":"https://github.com/apache/openjpa/blob/f2a266c4c2dde0124814c16776f020c120a8ccf2/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f2a266c4c2dde0124814c16776f020c120a8ccf2/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StateManagerImpl.java?ref=f2a266c4c2dde0124814c16776f020c120a8ccf2","patch":"@@ -2751,68 +2751,58 @@ boolean loadFields(BitSet fields, FetchConfiguration fetch, int lockLevel,\n         return ret;\n     }\n \n-    protected void loadField(int field, int lockLevel, boolean forWrite,\n-            boolean fgs) {\n-    \tloadField (field, lockLevel, forWrite, fgs, null);\n-    }\n-    \n     /**\n      * Load the given field's fetch group; the field itself may already be\n      * loaded if it is being set by the user.\n      */\n     protected void loadField(int field, int lockLevel, boolean forWrite,\n-        boolean fgs, FetchConfiguration fetch) {\n-    \tif (fetch == null) \n-    \t\tfetch = _broker.getFetchConfiguration();\n-    \tboolean isLoadFetchGroupAdded = false;\n+        boolean fgs) {\n+        FetchConfiguration fetch = _broker.getFetchConfiguration();\n         FieldMetaData fmd = _meta.getField(field);\n         BitSet fields = null;\n+\n         // if this is a dfg field or we need to load our dfg, do so\n-        if (fmd.isInDefaultFetchGroup()\n-            || (fgs && (_flags & FLAG_LOADED) == 0)) \n+        if (fgs && (_flags & FLAG_LOADED) == 0)\n             fields = getUnloadedInternal(fetch, LOAD_FGS, null);\n         \n-        // if not a dfg field, use first custom fetch group as load group\n-        //### need to use metadata load-fetch-group\n-        if (!fmd.isInDefaultFetchGroup()) {\n-            String lfg = fmd.getLoadFetchGroup();\n-            if (lfg != null) {  \n-                FieldMetaData[] fmds = _meta.getFields();\n-                for (int i = 0; i < fmds.length; i++) {\n-                    if (!_loaded.get(i) && (i == field\n-                        || fmds[i].isInFetchGroup(lfg))) {\n-                        if (fields == null)\n-                            fields = new BitSet(fmds.length);\n-                        fields.set(i);\n-                    }\n-                }\n-                // relation field is loaded with the load-fetch-group\n-                // but this addition must be reverted once the load is over\n-                if (isRelation(fmd) && !fetch.hasFetchGroup(lfg)) {\n-                \tfetch.addFetchGroup(fmd.getLoadFetchGroup());\n-                \tisLoadFetchGroupAdded = true;\n+        // check for load fetch group\n+        String lfg = fmd.getLoadFetchGroup();\n+        boolean lfgAdded = false;\n+        if (lfg != null) {  \n+            FieldMetaData[] fmds = _meta.getFields();\n+            for (int i = 0; i < fmds.length; i++) {\n+                if (!_loaded.get(i) && (i == field\n+                    || fmds[i].isInFetchGroup(lfg))) {\n+                    if (fields == null)\n+                        fields = new BitSet(fmds.length);\n+                    fields.set(i);\n                 }\n-            } else if (!_loaded.get(fmd.getIndex())) {\n-                if (fields == null)\n-                    fields = new BitSet();\n-                fields.set(fmd.getIndex());\n             }\n+\n+            // relation field is loaded with the load-fetch-group\n+            // but this addition must be reverted once the load is over\n+            if (!fetch.hasFetchGroup(lfg)) {\n+                fetch.addFetchGroup(lfg);\n+                lfgAdded = true;\n+            }\n+        } else if (fmd.isInDefaultFetchGroup() && fields == null) {\n+            // no load group but dfg: add dfg fields if we haven't already\n+            fields = getUnloadedInternal(fetch, LOAD_FGS, null);\n+        } else if (!_loaded.get(fmd.getIndex())) {\n+            // no load group or dfg: load individual field\n+            if (fields == null)\n+                fields = new BitSet();\n+            fields.set(fmd.getIndex());\n         }\n \n         // call this method even if there are no unloaded fields; loadFields\n-        // takes care of things like loading version info and setting PC\n-        // flags\n-        loadFields(fields, fetch, lockLevel, null, forWrite);\n-        \n-        // remove the load fetch group \n-        if (isLoadFetchGroupAdded)\n-        \tfetch.removeFetchGroup(fmd.getLoadFetchGroup());\n-    }\n-    \n-    private static boolean isRelation(FieldMetaData fm) {\n-    \treturn fm.isDeclaredTypePC() \n-    \t    || fm.getElement().isDeclaredTypePC()\n-    \t    || fm.getKey().isDeclaredTypePC();\n+        // takes care of things like loading version info and setting PC flags\n+        try {\n+            loadFields(fields, fetch, lockLevel, null, forWrite);\n+        } finally {\n+            if (lfgAdded)\n+                fetch.removeFetchGroup(lfg);\n+        }\n     }\n \n     /**"},{"sha":"cdf0bb73026fb9128c42e8265ca2d1a259ca1f58","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","status":"modified","additions":12,"deletions":10,"changes":22,"blob_url":"https://github.com/apache/openjpa/blob/f2a266c4c2dde0124814c16776f020c120a8ccf2/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/f2a266c4c2dde0124814c16776f020c120a8ccf2/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FieldMetaData.java?ref=f2a266c4c2dde0124814c16776f020c120a8ccf2","patch":"@@ -575,15 +575,21 @@ public void setDefaultFetchGroupExplicit(boolean explicit) {\n     }\n \n     /**\n-     * Gets the fetch group that is to be loaded when this receiver is loaded.\n-     *  \n-     * @return name of the load fetch group. Can be null, if not explicitly \n-     * set.\n+     * The fetch group that is to be loaded when this receiver is loaded, or\n+     * null if none set.\n      */\n     public String getLoadFetchGroup () {\n     \treturn _lfg;\n     }\n     \n+    /**\n+     * The fetch group that is to be loaded when this receiver is loaded, or\n+     * null if none set.\n+     */\n+    public void setLoadFetchGroup (String lfg) {\n+    \t_lfg = lfg;\n+    }\n+\n     /**\n      * Whether this field is in the given fetch group.\n      */\n@@ -620,12 +626,6 @@ public void setInFetchGroup(String fg, boolean in) {\n             || (!in && _fgSet != null && _fgSet.remove(fg)))\n             _fgs = null;\n     }\n-\n-    public void setLoadFetchGroup (String lfg) {\n-    \tif (StringUtils.isEmpty(lfg))\n-    \t\tthrow new MetaDataException(_loc.get(\"empty-fg-name\"),this);\n-    \t_lfg = lfg;\n-    }\n     \n     /**\n      * How the data store should treat null values for this field:\n@@ -1669,6 +1669,8 @@ public void copy(FieldMetaData field) {\n         }\n         if (_fgSet == null && field._fgSet != null)\n             _fgSet = new HashSet(field._fgSet);\n+        if (_lfg == null)\n+            _lfg = field.getLoadFetchGroup();\n         if (_lrs == null)\n             _lrs = (field.isLRS()) ? Boolean.TRUE : Boolean.FALSE;\n         if (_valStrategy == -1)"},{"sha":"9166e4fce73899c4a2f045f4210d22ea391da877","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","status":"modified","additions":13,"deletions":9,"changes":22,"blob_url":"https://github.com/apache/openjpa/blob/f2a266c4c2dde0124814c16776f020c120a8ccf2/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/f2a266c4c2dde0124814c16776f020c120a8ccf2/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java?ref=f2a266c4c2dde0124814c16776f020c120a8ccf2","patch":"@@ -2,6 +2,7 @@\n \r\n import java.util.Map;\r\n \r\n+import org.apache.openjpa.kernel.StoreManager;\r\n import org.apache.openjpa.lib.util.concurrent.ConcurrentHashMap;\r\n \r\n /**\r\n@@ -37,21 +38,24 @@ public void registerImplementation(Class facadeType, Class storeType,\n      * @param implType the registered implementor\r\n      */\r\n     public Class getImplementation(Class facadeType, Class storeType) {\r\n-        Object key = (storeType == null) ? (Object)facadeType \r\n-            : new Key(facadeType, storeType);\r\n-        Class c = (Class) _impls.get(key);\r\n-        // if no store-specific type, see if there is a generic avaialble\r\n-        if (c == null && storeType != null)\r\n-            c = (Class) _impls.get(facadeType);\r\n-        return c; \r\n+        // traverse store type hierarchy to store manager to find most specific\r\n+        // store avaialble\r\n+        Class impl;\r\n+        for (; storeType != null && storeType != StoreManager.class; \r\n+            storeType = storeType.getSuperclass()) {\r\n+            impl = (Class) _impls.get(new Key(facadeType, storeType));\r\n+            if (impl != null)\r\n+                return impl; \r\n+        }    \r\n+        return (Class) _impls.get(facadeType);\r\n     }\r\n \r\n     /**\r\n      * Lookup key for facade+store hash.\r\n      */\r\n     private static class Key {\r\n-        private final Class _facadeType;\r\n-        private final Class _storeType;\r\n+        public final Class _facadeType;\r\n+        public final Class _storeType;\r\n \r\n         public Key(Class facadeType, Class storeType) {\r\n             _facadeType = facadeType;\r"}]}

