{"sha":"f2e51da5971b1840fd78cb9f8ef267f103dd64b7","node_id":"MDY6Q29tbWl0MjA2MzY0OmYyZTUxZGE1OTcxYjE4NDBmZDc4Y2I5ZjhlZjI2N2YxMDNkZDY0Yjc=","commit":{"author":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T16:20:55Z"},"committer":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T16:20:55Z"},"message":"OPENJPA-1414: Performance improvements for detach processing. Patch contributed by Dianne Richards.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@888463 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"bc95a72ad14dc57b3c8caeca8e3d46ed3f87fa5a","url":"https://api.github.com/repos/apache/openjpa/git/trees/bc95a72ad14dc57b3c8caeca8e3d46ed3f87fa5a"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/f2e51da5971b1840fd78cb9f8ef267f103dd64b7","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/f2e51da5971b1840fd78cb9f8ef267f103dd64b7","html_url":"https://github.com/apache/openjpa/commit/f2e51da5971b1840fd78cb9f8ef267f103dd64b7","comments_url":"https://api.github.com/repos/apache/openjpa/commits/f2e51da5971b1840fd78cb9f8ef267f103dd64b7/comments","author":null,"committer":null,"parents":[{"sha":"4bacdf4c3c01b0a391266e32ec41f1401ff332e4","url":"https://api.github.com/repos/apache/openjpa/commits/4bacdf4c3c01b0a391266e32ec41f1401ff332e4","html_url":"https://github.com/apache/openjpa/commit/4bacdf4c3c01b0a391266e32ec41f1401ff332e4"}],"stats":{"total":62,"additions":51,"deletions":11},"files":[{"sha":"1ba0aef775679642613caabd9550cc6b54a0cf5f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","status":"modified","additions":30,"deletions":1,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/f2e51da5971b1840fd78cb9f8ef267f103dd64b7/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","raw_url":"https://github.com/apache/openjpa/raw/f2e51da5971b1840fd78cb9f8ef267f103dd64b7/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java?ref=f2e51da5971b1840fd78cb9f8ef267f103dd64b7","patch":"@@ -57,6 +57,7 @@\n     private boolean _storeMapCollectionInEntityAsBlob = false;\n     private boolean _flushBeforeDetach = true;\n     private boolean _reorderMetaDataResolution = false;\n+    private boolean _reloadOnDetach = true;\n \n     /**\n      * Whether to require exact identity value types when creating object\n@@ -288,7 +289,35 @@ public boolean getReorderMetaDataResolution() {\n      * @param reorderProcessBuffer true if the reordering should be performed, false if not.\n      */\n     public void setReorderMetaDataResolution(boolean reorderProcessBuffer) {\n-    \t_reorderMetaDataResolution = reorderProcessBuffer;\n+        _reorderMetaDataResolution = reorderProcessBuffer;\n     }\n \n+    /**\n+     * Whether OpenJPA should attempt to load fields when the DetachState\n+     * option is set to loaded. This also determines whether a\n+     * redundant copy of the version field is made. Defaults to true.\n+     * \n+     * @return the _reloadOnDetach\n+     * \n+     * @since 1.2.2\n+     */\n+    public boolean getReloadOnDetach() {\n+        return _reloadOnDetach;\n+    }\n+\n+    /**\n+     * Whether OpenJPA should attempt to load fields when the DetachState\n+     * option is set to loaded. This also determines whether a\n+     * redundant copy of the version field is made. Defaults to true.\n+     * \n+     * @param reloadOnDetach the _reloadOnDetach to set\n+     * \n+     * @since 1.2.2\n+     */\n+    public void setReloadOnDetach(boolean reloadOnDetach) {\n+        _reloadOnDetach = reloadOnDetach;\n+    }   \n+\n+    \n+\n }"},{"sha":"8a8afefd9b1a7409bec05da63b4ee17080f7aba2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","status":"modified","additions":21,"deletions":10,"changes":31,"blob_url":"https://github.com/apache/openjpa/blob/f2e51da5971b1840fd78cb9f8ef267f103dd64b7/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","raw_url":"https://github.com/apache/openjpa/raw/f2e51da5971b1840fd78cb9f8ef267f103dd64b7/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java?ref=f2e51da5971b1840fd78cb9f8ef267f103dd64b7","patch":"@@ -34,6 +34,7 @@\n import java.util.Map;\n \n import org.apache.commons.collections.map.IdentityMap;\n+import org.apache.openjpa.conf.Compatibility;\n import org.apache.openjpa.conf.DetachOptions;\n import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.event.CallbackModes;\n@@ -68,6 +69,7 @@\n     private final boolean _failFast;\n     private boolean _flushed = false;\n     private boolean _flushBeforeDetach;\n+    private boolean _reloadOnDetach;\n \n     // if we're not detaching full, we need to track all detached objects;\n     // if we are, then we use a special field manager for more efficient\n@@ -92,7 +94,7 @@ static boolean preSerialize(StateManagerImpl sm) {\n         boolean setState = meta.getDetachedState() != null\n             && !ClassMetaData.SYNTHETIC.equals(meta.getDetachedState());\n         BitSet idxs = (setState) ? new BitSet(meta.getFields().length) : null;\n-        preDetach(sm.getBroker(), sm, idxs);\n+        preDetach(sm.getBroker(), sm, idxs, false, true);\n \n         if (setState) {\n             sm.getPersistenceCapable().pcSetDetachedState(getDetachedState\n@@ -120,7 +122,7 @@ static boolean writeDetachedState(StateManagerImpl sm, ObjectOutput out,\n         flushDirty(sm);\n \n         Broker broker = sm.getBroker();\n-        preDetach(broker, sm, idxs);\n+        preDetach(broker, sm, idxs, false, true);\n \n         // write detached state object and state manager\n         DetachOptions opts = broker.getConfiguration().\n@@ -145,7 +147,8 @@ static boolean writeDetachedState(StateManagerImpl sm, ObjectOutput out,\n      * effect of this method\n      */\n     private static void preDetach(Broker broker, StateManagerImpl sm,\n-        BitSet idxs) {\n+        BitSet idxs, boolean full, \n+        boolean reloadOnDetach) {\n         // make sure the existing object has the right fields fetched; call\n         // even if using currently-loaded fields for detach to make sure\n         // version is set\n@@ -157,8 +160,12 @@ private static void preDetach(Broker broker, StateManagerImpl sm,\n         else if (detachMode == DETACH_ALL)\n             loadMode = StateManagerImpl.LOAD_ALL;\n         try {\n-            sm.load(broker.getFetchConfiguration(), loadMode, exclude, null, \n-                false);\n+            if (detachMode != DETACH_LOADED || \n+                    reloadOnDetach ||\n+                    (!reloadOnDetach && !full)) {\n+                sm.load(broker.getFetchConfiguration(), loadMode, exclude,\n+                    null, false);\n+            }\n         } catch (ObjectNotFoundException onfe) {\n             // consume the exception\n         }\n@@ -274,9 +281,10 @@ public DetachManager(BrokerImpl broker, boolean full, OpCallbacks call) {\n             _detached = new IdentityMap();\n             _fullFM = null;\n         }\n-        _flushBeforeDetach =\n-                broker.getConfiguration().getCompatibilityInstance()\n-                        .getFlushBeforeDetach();\n+        Compatibility compatibility = \n+            broker.getConfiguration().getCompatibilityInstance();\n+        _flushBeforeDetach = compatibility.getFlushBeforeDetach();\n+        _reloadOnDetach = compatibility.getReloadOnDetach();\n     }\n \n     /**\n@@ -431,7 +439,8 @@ private Object detachInternal(Object toDetach) {\n         }\n         \n         BitSet fields = new BitSet();\n-        preDetach(_broker, sm, fields);\n+        preDetach(_broker, sm, fields, _full, \n+            _reloadOnDetach);\n \n         // create and store new object before copy to avoid endless recursion\n         PersistenceCapable pc = sm.getPersistenceCapable();\n@@ -451,7 +460,9 @@ private Object detachInternal(Object toDetach) {\n                 _opts.getAccessUnloaded(), _broker.getMultithreaded());\n         if (_full) {\n             _fullFM.setStateManager(sm);\n-            _fullFM.detachVersion();\n+            if (_copy || _reloadOnDetach) {\n+                _fullFM.detachVersion();\n+            }\n             _fullFM.reproxy(detSM);\n             _fullFM.setStateManager(null);\n         } else {"}]}

