{"sha":"f42bfb718eac77ed53f592636d71fc537dc11d01","node_id":"MDY6Q29tbWl0MjA2MzY0OmY0MmJmYjcxOGVhYzc3ZWQ1M2Y1OTI2MzZkNzFmYzUzN2RjMTFkMDE=","commit":{"author":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2007-09-21T03:29:38Z"},"committer":{"name":"Catalina Wei","email":"fancy@apache.org","date":"2007-09-21T03:29:38Z"},"message":"OPENJPA-378 DB2 \"FETCH FIRST <n> ROWS ONLY\" clause should not be generated in subselect for SELECT COUNT(*) from (subselect ...) s\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.0.x@577972 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"9a30fec275575a1974a1a5e0a175b6763821ad69","url":"https://api.github.com/repos/apache/openjpa/git/trees/9a30fec275575a1974a1a5e0a175b6763821ad69"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/f42bfb718eac77ed53f592636d71fc537dc11d01","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/f42bfb718eac77ed53f592636d71fc537dc11d01","html_url":"https://github.com/apache/openjpa/commit/f42bfb718eac77ed53f592636d71fc537dc11d01","comments_url":"https://api.github.com/repos/apache/openjpa/commits/f42bfb718eac77ed53f592636d71fc537dc11d01/comments","author":null,"committer":null,"parents":[{"sha":"134fcf10ccf6e5feeac95825da45d7fc745bf1b8","url":"https://api.github.com/repos/apache/openjpa/commits/134fcf10ccf6e5feeac95825da45d7fc745bf1b8","html_url":"https://github.com/apache/openjpa/commit/134fcf10ccf6e5feeac95825da45d7fc745bf1b8"}],"stats":{"total":46,"additions":37,"deletions":9},"files":[{"sha":"69234dd7ff8a6d4098eeac7f6d8c94d47491f10f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/f42bfb718eac77ed53f592636d71fc537dc11d01/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f42bfb718eac77ed53f592636d71fc537dc11d01/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java?ref=f42bfb718eac77ed53f592636d71fc537dc11d01","patch":"@@ -148,11 +148,14 @@ public boolean supportsRandomAccessResultSet(Select sel,\n             && super.supportsRandomAccessResultSet(sel, forUpdate);\r\n     }\r\n \r\n-    protected void appendSelectRange(SQLBuffer buf, long start, long end) {\r\n+    protected void appendSelectRange(SQLBuffer buf, long start, long end,\r\n+        boolean subselect) {\r\n         // appends the literal range string, since DB2 is unable to handle\r\n         // a bound parameter for it\r\n-        buf.append(\" FETCH FIRST \").append(Long.toString(end)).\r\n-            append(\" ROWS ONLY\");\r\n+        // do not generate FETCH FIRST clause for subselect\r\n+        if (!subselect)\r\n+            buf.append(\" FETCH FIRST \").append(Long.toString(end)).\r\n+                append(\" ROWS ONLY\");\r\n     }\r\n \r\n     public String[] getCreateSequenceSQL(Sequence seq) {\r"},{"sha":"ffe44cf72f641ffda7180a1b9a4b4b5ca521944c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","status":"modified","additions":31,"deletions":6,"changes":37,"blob_url":"https://github.com/apache/openjpa/blob/f42bfb718eac77ed53f592636d71fc537dc11d01/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f42bfb718eac77ed53f592636d71fc537dc11d01/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java?ref=f42bfb718eac77ed53f592636d71fc537dc11d01","patch":"@@ -1736,7 +1736,7 @@ public SQLBuffer toSelectCount(Select sel) {\n         from.append(\"(\");\n         from.append(toSelect(subSelect, null, subFrom, where,\n             sel.getGrouping(), sel.getHaving(), null, sel.isDistinct(),\n-            false, sel.getStartIndex(), sel.getEndIndex()));\n+            false, sel.getStartIndex(), sel.getEndIndex(), true));\n         from.append(\")\");\n         if (requiresAliasForSubselect)\n             from.append(\" \").append(Select.FROM_SELECT_ALIAS);\n@@ -2183,6 +2183,19 @@ public SQLBuffer toSelect(SQLBuffer selects, JDBCFetchConfiguration fetch,\n             getForUpdateClause(fetch, forUpdate, null));\n     }\n \n+    /**\n+     * Combine the given components into a SELECT statement.\n+     */\n+    private SQLBuffer toSelect(SQLBuffer selects, JDBCFetchConfiguration fetch,\n+        SQLBuffer from, SQLBuffer where, SQLBuffer group,\n+        SQLBuffer having, SQLBuffer order,\n+        boolean distinct, boolean forUpdate, long start, long end,\n+        boolean subselect) {\n+        return toOperation(getSelectOperation(fetch), selects, from, where,\n+            group, having, order, distinct, start, end,\n+            getForUpdateClause(fetch, forUpdate, null), subselect);\n+    }\n+\n     /**\n      * Combine the given components into a SELECT statement.\n      */\n@@ -2227,16 +2240,27 @@ protected SQLBuffer toOperation(String op, SQLBuffer selects,\n         SQLBuffer from, SQLBuffer where, SQLBuffer group, SQLBuffer having,\n         SQLBuffer order, boolean distinct, long start, long end,\n         String forUpdateClause) {\n+        return toOperation(op, selects, from, where, group, having, order,\n+            distinct, start, end, forUpdateClause, false);\n+    }\n+\n+    /**\n+     * Return the SQL for the given selecting operation.\n+     */\n+    private SQLBuffer toOperation(String op, SQLBuffer selects,\n+        SQLBuffer from, SQLBuffer where, SQLBuffer group, SQLBuffer having,\n+        SQLBuffer order, boolean distinct, long start, long end,\n+        String forUpdateClause, boolean subselect) {\n         SQLBuffer buf = new SQLBuffer(this);\n         buf.append(op);\n \n         boolean range = start != 0 || end != Long.MAX_VALUE;\n         if (range && rangePosition == RANGE_PRE_DISTINCT)\n-            appendSelectRange(buf, start, end);\n+            appendSelectRange(buf, start, end, subselect);\n         if (distinct)\n             buf.append(\" DISTINCT\");\n         if (range && rangePosition == RANGE_POST_DISTINCT)\n-            appendSelectRange(buf, start, end);\n+            appendSelectRange(buf, start, end, subselect);\n \n         buf.append(\" \").append(selects).append(\" FROM \").append(from);\n \n@@ -2251,19 +2275,20 @@ protected SQLBuffer toOperation(String op, SQLBuffer selects,\n         if (order != null && !order.isEmpty())\n             buf.append(\" ORDER BY \").append(order);\n         if (range && rangePosition == RANGE_POST_SELECT)\n-            appendSelectRange(buf, start, end);\n+            appendSelectRange(buf, start, end, subselect);\n         if (forUpdateClause != null)\n             buf.append(\" \").append(forUpdateClause);\n         if (range && rangePosition == RANGE_POST_LOCK)\n-            appendSelectRange(buf, start, end);\n+            appendSelectRange(buf, start, end, subselect);\n         return buf;\n     }\n \n     /**\n      * If this dictionary can select ranges,\n      * use this method to append the range SQL.\n      */\n-    protected void appendSelectRange(SQLBuffer buf, long start, long end) {\n+    protected void appendSelectRange(SQLBuffer buf, long start, long end\n+        , boolean subselect) {\n     }\n \n     /**"}]}

