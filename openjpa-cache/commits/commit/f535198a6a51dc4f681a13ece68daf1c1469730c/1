{"sha":"f535198a6a51dc4f681a13ece68daf1c1469730c","node_id":"MDY6Q29tbWl0MjA2MzY0OmY1MzUxOThhNmE1MWRjNGY2ODFhMTNlY2U2OGRhZjFjMTQ2OTczMGM=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2008-07-15T19:43:33Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2008-07-15T19:43:33Z"},"message":"OPENJPA-245 merging revision 646082 from 1.1.0 branch\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.0.x@677015 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"2ef69226f3ef8566208e213c4700d813d4fa4dfa","url":"https://api.github.com/repos/apache/openjpa/git/trees/2ef69226f3ef8566208e213c4700d813d4fa4dfa"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/f535198a6a51dc4f681a13ece68daf1c1469730c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/f535198a6a51dc4f681a13ece68daf1c1469730c","html_url":"https://github.com/apache/openjpa/commit/f535198a6a51dc4f681a13ece68daf1c1469730c","comments_url":"https://api.github.com/repos/apache/openjpa/commits/f535198a6a51dc4f681a13ece68daf1c1469730c/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"7cb20fd5abc91dac4ab46caff168ae41798f4c6e","url":"https://api.github.com/repos/apache/openjpa/commits/7cb20fd5abc91dac4ab46caff168ae41798f4c6e","html_url":"https://github.com/apache/openjpa/commit/7cb20fd5abc91dac4ab46caff168ae41798f4c6e"}],"stats":{"total":238,"additions":185,"deletions":53},"files":[{"sha":"1191dd992295893de3df374aef042966613346eb","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","status":"modified","additions":86,"deletions":41,"changes":127,"blob_url":"https://github.com/apache/openjpa/blob/f535198a6a51dc4f681a13ece68daf1c1469730c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","raw_url":"https://github.com/apache/openjpa/raw/f535198a6a51dc4f681a13ece68daf1c1469730c/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java?ref=f535198a6a51dc4f681a13ece68daf1c1469730c","patch":"@@ -118,7 +118,10 @@\n     public static final int ENHANCE_INTERFACE = 2 << 1;\n     public static final int ENHANCE_PC = 2 << 2;\n \n-    private static final String PRE = \"pc\";\n+    public static final String PRE = \"pc\";\n+    public static final String ISDETACHEDSTATEDEFINITIVE = PRE \n+        + \"isDetachedStateDefinitive\";\n+\n     private static final Class PCTYPE = PersistenceCapable.class;\n     private static final String SM = PRE + \"StateManager\";\n     private static final Class SMTYPE = StateManager.class;\n@@ -2932,27 +2935,45 @@ private void modifyReadObjectMethod(BCMethod method, boolean full) {\n      */\n     private void addIsDetachedMethod()\n         throws NoSuchMethodException {\n-        // public boolean pcIsDetached ()\n+        // public boolean pcIsDetached()\n         BCMethod method = _pc.declareMethod(PRE + \"IsDetached\",\n             Boolean.class, null);\n         method.makePublic();\n         Code code = method.getCode(true);\n-        writeIsDetachedMethod(code);\n+        boolean needsDefinitiveMethod = writeIsDetachedMethod(code);\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+        if (!needsDefinitiveMethod) \n+            return;\n+\n+        // private boolean pcIsDetachedStateDefinitive()\n+        //   return false;\n+        // auxilliary enhancers may change the return value of this method\n+        // if their specs consider detached state definitive\n+        method = _pc.declareMethod(ISDETACHEDSTATEDEFINITIVE, boolean.class,\n+            null);\n+        method.makePrivate();\n+        code = method.getCode(true);\n+        code.constant().setValue(false);\n+        code.ireturn();\n         code.calculateMaxStack();\n         code.calculateMaxLocals();\n     }\n \n     /**\n      * Creates the body of the pcIsDetached() method to determine if an\n      * instance is detached.\n+     *\n+     * @return true if we need a pcIsDetachedStateDefinitive method, false\n+     * otherwise\n      */\n-    private void writeIsDetachedMethod(Code code)\n+    private boolean writeIsDetachedMethod(Code code)\n         throws NoSuchMethodException {\n         // not detachable: return Boolean.FALSE\n         if (!_meta.isDetachable()) {\n             code.getstatic().setField(Boolean.class, \"FALSE\", Boolean.class);\n             code.areturn();\n-            return;\n+            return false;\n         }\n \n         // if (sm != null)\n@@ -3000,7 +3021,7 @@ private void writeIsDetachedMethod(Code code)\n                 ifins.setTarget(target);\n                 notdeser.setTarget(target);\n                 code.areturn();\n-                return;\n+                return false;\n             }\n         }\n \n@@ -3010,9 +3031,9 @@ private void writeIsDetachedMethod(Code code)\n         if (notdeser != null)\n             notdeser.setTarget(target);\n \n-        // allow users with version fields to manually construct a \"detached\"\n-        // instance, so check version before taking into account non-existent\n-        // detached state\n+        // allow users with version or auto-assigned pk fields to manually \n+        // construct a \"detached\" instance, so check these before taking into \n+        // account non-existent detached state\n \n         // consider detached if version is non-default\n         FieldMetaData version = _meta.getVersionField();\n@@ -3027,41 +3048,13 @@ private void writeIsDetachedMethod(Code code)\n             ifins.setTarget(code.getstatic().setField(Boolean.class, \"FALSE\",\n                 Boolean.class));\n             code.areturn();\n-            return;\n-        }\n-\n-        // no detached state: if instance uses detached state and it's not\n-        // synthetic or the instance is not serializable or the state isn't\n-        // transient, must not be detached\n-        if (state == null\n-            && (!ClassMetaData.SYNTHETIC.equals(_meta.getDetachedState())\n-            || !Serializable.class.isAssignableFrom(_meta.getDescribedType())\n-            || !_repos.getConfiguration().getDetachStateInstance().\n-            isDetachedStateTransient())) {\n-            // return Boolean.FALSE\n-            code.getstatic().setField(Boolean.class, \"FALSE\", Boolean.class);\n-            code.areturn();\n-            return;\n-        }\n-\n-        // no detached state: if instance uses detached state (and must be\n-        // synthetic and transient in serializable instance at this point),\n-        // not detached if state not set to DESERIALIZED\n-        if (state == null) {\n-            // if (pcGetDetachedState () == null) // instead of DESERIALIZED\n-            //     return Boolean.FALSE;\n-            loadManagedInstance(code, false);\n-            code.invokevirtual().setMethod(PRE + \"GetDetachedState\",\n-                Object.class, null);\n-            ifins = code.ifnonnull();\n-            code.getstatic().setField(Boolean.class, \"FALSE\", Boolean.class);\n-            code.areturn();\n-            ifins.setTarget(code.nop());\n+            return false;\n         }\n \n         // consider detached if auto-genned primary keys are non-default\n         ifins = null;\n         JumpInstruction ifins2 = null;\n+        boolean hasAutoAssignedPK = false;\n         if (state != Boolean.TRUE\n             && _meta.getIdentityType() == ClassMetaData.ID_APPLICATION) {\n             // for each pk field:\n@@ -3095,13 +3088,65 @@ private void writeIsDetachedMethod(Code code)\n             }\n         }\n \n-        // give up; we just don't know\n-        target = code.constant().setNull();\n+        // create artificial target to simplify\n+        target = code.nop();\n         if (ifins != null)\n             ifins.setTarget(target);\n         if (ifins2 != null)\n             ifins2.setTarget(target);\n+\n+        // if has auto-assigned pk and we get to this point, must have default\n+        // value, so must be new instance\n+        if (hasAutoAssignedPK) {\n+            code.getstatic().setField(Boolean.class, \"FALSE\", Boolean.class);\n+            code.areturn();\n+            return false;\n+        }\n+\n+        // if detached state is not definitive, just give up now and return\n+        // null so that the runtime will perform a DB lookup to determine\n+        // whether we're detached or new\n+        code.aload().setThis();\n+        code.invokespecial().setMethod(ISDETACHEDSTATEDEFINITIVE, boolean.class,\n+            null);\n+        ifins = code.ifne();\n+        code.constant().setNull();\n         code.areturn();\n+        ifins.setTarget(code.nop());\n+\n+        // no detached state: if instance uses detached state and it's not\n+        // synthetic or the instance is not serializable or the state isn't\n+        // transient, must not be detached\n+        if (state == null\n+            && (!ClassMetaData.SYNTHETIC.equals(_meta.getDetachedState())\n+            || !Serializable.class.isAssignableFrom(_meta.getDescribedType())\n+            || !_repos.getConfiguration().getDetachStateInstance().\n+            isDetachedStateTransient())) {\n+            // return Boolean.FALSE\n+            code.getstatic().setField(Boolean.class, \"FALSE\", Boolean.class);\n+            code.areturn();\n+            return true;\n+        }\n+\n+        // no detached state: if instance uses detached state (and must be\n+        // synthetic and transient in serializable instance at this point),\n+        // not detached if state not set to DESERIALIZED\n+        if (state == null) {\n+            // if (pcGetDetachedState () == null) // instead of DESERIALIZED\n+            //     return Boolean.FALSE;\n+            loadManagedInstance(code, false);\n+            code.invokevirtual().setMethod(PRE + \"GetDetachedState\",\n+                Object.class, null);\n+            ifins = code.ifnonnull();\n+            code.getstatic().setField(Boolean.class, \"FALSE\", Boolean.class);\n+            code.areturn();\n+            ifins.setTarget(code.nop());\n+        }\n+\n+        // give up; we just don't know\n+        code.constant().setNull();\n+        code.areturn();\n+        return true;\n     }\n \n     /**"},{"sha":"c01dcb2fa9ea5ff0238e5b5b8d2f733fb27dba47","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","status":"modified","additions":1,"deletions":8,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/f535198a6a51dc4f681a13ece68daf1c1469730c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/f535198a6a51dc4f681a13ece68daf1c1469730c/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/VersionAttachStrategy.java?ref=f535198a6a51dc4f681a13ece68daf1c1469730c","patch":"@@ -69,19 +69,12 @@ protected void provideField(Object toAttach, StateManagerImpl sm,\n     public Object attach(AttachManager manager, Object toAttach,\n         ClassMetaData meta, PersistenceCapable into, OpenJPAStateManager owner,\n         ValueMetaData ownerMeta, boolean explicit) {\n-\n-        // VersionAttachStrategy is invoked in the case where no more\n-        // intelligent strategy could be found; let's be more lenient\n-        // about new vs. detached record determination.\n-        if (into == null)\n-            into = findFromDatabase(manager, toAttach);\n-\n         BrokerImpl broker = manager.getBroker();\n         PersistenceCapable pc = ImplHelper.toPersistenceCapable(toAttach,\n             meta.getRepository().getConfiguration());\n \n         boolean embedded = ownerMeta != null && ownerMeta.isEmbeddedPC();\n-        boolean isNew = !broker.isDetached(pc) && into == null;\n+        boolean isNew = !broker.isDetached(pc);\n         Object version = null;\n         StateManagerImpl sm;\n "},{"sha":"1aec8296135641fffa70efeb843c0bb3c0350fc6","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","status":"modified","additions":12,"deletions":1,"changes":13,"blob_url":"https://github.com/apache/openjpa/blob/f535198a6a51dc4f681a13ece68daf1c1469730c/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/f535198a6a51dc4f681a13ece68daf1c1469730c/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties?ref=f535198a6a51dc4f681a13ece68daf1c1469730c","patch":"@@ -116,7 +116,9 @@ not-managed: The given instance \"{0}\" is not managed by this context.\n trans-not-managed: This broker is not configured to use managed transactions.\n bad-detached-op: You cannot perform operation {0} on detached object \"{1}\". \\\n \tThis operation only applies to managed objects.\n-persist-detached: Attempt to persist detached object \"{0}\".\n+persist-detached: Attempt to persist detached object \"{0}\".  If this is a new \\\n+  instance, make sure any versino and/or auto-generated primary key fields are \\\n+  null/default when persisting.\n null-value: The field \"{0}\" of instance \"{1}\" contained a null value; \\\n \tthe metadata for this field specifies that nulls are illegal.\n change-identity: Attempt to change a primary key field of an instance that \\\n@@ -381,3 +383,12 @@ multi-threaded-access: Multiple concurrent threads attempted to access a \\\n     single broker. By default brokers are not thread safe; if you require \\\n     and/or intend a broker to be accessed by more than one thread, set the \\\n     openjpa.Multithreaded property to true to override the default behavior.\n+no-saved-fields: No state snapshot is available for instance of type \"{0}\", \\\n+    but this instance uses state-comparison for dirty detection.\n+cant-serialize-flushed-broker: Serialization not allowed once a broker has \\\n+    been flushed.\n+cant-serialize-pessimistic-broker: Serialization not allowed for brokers with \\\n+    an active datastore (pessimistic) transaction.\n+cant-serialize-connected-broker: Serialization not allowed for brokers with \\\n+    an active connection to the database.\n+no-interface-metadata: No metadata was found for managed interface {0}."},{"sha":"1af43571a18b059746bd388ddb137f29d087e50c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/TestAttachConstructedCopy.java","status":"added","additions":72,"deletions":0,"changes":72,"blob_url":"https://github.com/apache/openjpa/blob/f535198a6a51dc4f681a13ece68daf1c1469730c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/TestAttachConstructedCopy.java","raw_url":"https://github.com/apache/openjpa/raw/f535198a6a51dc4f681a13ece68daf1c1469730c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/TestAttachConstructedCopy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/detachment/TestAttachConstructedCopy.java?ref=f535198a6a51dc4f681a13ece68daf1c1469730c","patch":"@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.detachment;\n+\n+import javax.persistence.EntityManager;\n+\n+import junit.textui.TestRunner;\n+import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n+\n+/**\n+ * Test that manually constructing instances with existing primary key values\n+ * and attaching them works.\n+ *\n+ * @author Abe White\n+ */\n+public class TestAttachConstructedCopy\n+    extends SingleEMFTestCase {\n+\n+    public void setUp() {\n+        setUp(Record.class);\n+    }\n+\n+    public void testAttachConstructedCopyWithGeneratedPKAndNoVersion() {\n+        Record record = new Record();\n+        record.setContent(\"orig\");\n+\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        em.persist(record);\n+        em.getTransaction().commit();\n+        em.close();\n+        int id = record.getId();\n+\n+        Record copy = new Record();\n+        copy.setId(id);\n+        copy.setContent(\"new\");\n+\n+        em = emf.createEntityManager();\n+        em.getTransaction().begin(); \n+        record = em.merge(copy);\n+        assertTrue(record != copy);\n+        assertEquals(\"new\", record.getContent());\n+        em.getTransaction().commit();\n+        em.close();\n+\n+        em = emf.createEntityManager();\n+        record = em.find(Record.class, id);\n+        assertEquals(\"new\", record.getContent());\n+        em.close();\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(TestAttachConstructedCopy.class);\n+    }\n+}\n+"},{"sha":"666972176d75f9b2fe7edfb8f665bbd5bb1ef7b0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestGeneratedValues.java","status":"modified","additions":9,"deletions":2,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/f535198a6a51dc4f681a13ece68daf1c1469730c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestGeneratedValues.java","raw_url":"https://github.com/apache/openjpa/raw/f535198a6a51dc4f681a13ece68daf1c1469730c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestGeneratedValues.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestGeneratedValues.java?ref=f535198a6a51dc4f681a13ece68daf1c1469730c","patch":"@@ -19,6 +19,7 @@\n package org.apache.openjpa.persistence.generationtype;\r\n \r\n import javax.persistence.EntityManager;\r\n+import javax.persistence.EntityExistsException;\r\n \r\n import org.apache.openjpa.persistence.InvalidStateException;\r\n import org.apache.openjpa.persistence.test.SingleEMFTestCase;\r\n@@ -59,7 +60,10 @@ public void testInitialValues() {\n         } catch (InvalidStateException ise) {\r\n             // expected result\r\n             return;\r\n-        } \r\n+        }  catch (EntityExistsException eee) {\r\n+            // also ok\r\n+            return;\r\n+        }\r\n         \r\n         // should not get here...\r\n         fail();\r\n@@ -78,7 +82,10 @@ public void testIdSetter() {\n         } catch (InvalidStateException ise) {\r\n             // expected result\r\n             return;\r\n-        } \r\n+        }  catch (EntityExistsException eee) {\r\n+            // also ok\r\n+            return;\r\n+        }\r\n         \r\n         // should not get here...\r\n         fail();\r"},{"sha":"1ca4542726df4495d01e3f3eab71b0889a6c5f46","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestMultipleSchemaNames.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f535198a6a51dc4f681a13ece68daf1c1469730c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestMultipleSchemaNames.java","raw_url":"https://github.com/apache/openjpa/raw/f535198a6a51dc4f681a13ece68daf1c1469730c/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestMultipleSchemaNames.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/generationtype/TestMultipleSchemaNames.java?ref=f535198a6a51dc4f681a13ece68daf1c1469730c","patch":"@@ -94,6 +94,7 @@ public void setUp() {\n         delgentable2.executeUpdate();\n         Query delgentable3 = em\n                 .createNativeQuery(\"delete from schema3g.id_gen3\");\n+        delgentable3.executeUpdate();\n         Query delgentable4 = em\n                 .createNativeQuery(\"delete from schema4g.id_gen4\");\n         delgentable4.executeUpdate();"},{"sha":"c0daa39cf70d0a97a422105d692b9f4ec1703a2a","filename":"openjpa-project/src/doc/manual/ref_guide_remote.xml","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/f535198a6a51dc4f681a13ece68daf1c1469730c/openjpa-project/src/doc/manual/ref_guide_remote.xml","raw_url":"https://github.com/apache/openjpa/raw/f535198a6a51dc4f681a13ece68daf1c1469730c/openjpa-project/src/doc/manual/ref_guide_remote.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-project/src/doc/manual/ref_guide_remote.xml?ref=f535198a6a51dc4f681a13ece68daf1c1469730c","patch":"@@ -195,7 +195,10 @@ attached instance's corresponding fields to null.\n                     <para>\n If the instance has a <literal>Version</literal> field,\n OpenJPA will consider the object detached if the version field has a non-default\n-value, and new otherwise.\n+value, and new otherwise.  Similarly, if the instance has \n+<literal>GeneratedValue</literal> primary key fields, OpenJPA will consider the\n+object detached if any of these fields have non-default values, and new \n+otherwise.\n                     </para>\n                     <para>\n When attaching null fields in these cases, OpenJPA cannot distinguish between a"}]}

