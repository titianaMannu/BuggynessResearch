{"sha":"f6ae418aa546bf481bf5079ade672c0aa41bf188","node_id":"MDY6Q29tbWl0MjA2MzY0OmY2YWU0MThhYTU0NmJmNDgxYmY1MDc5YWRlNjcyYzBhYTQxYmYxODg=","commit":{"author":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2009-08-27T00:26:00Z"},"committer":{"name":"Pinaki Poddar","email":"ppoddar@apache.org","date":"2009-08-27T00:26:00Z"},"message":"OPENJPA-1267: JDBC Escape Syntax for temporal type data in Criteria Query\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@808235 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"d5c8a49180b2bd2ac2825a570fffac33282c05ee","url":"https://api.github.com/repos/apache/openjpa/git/trees/d5c8a49180b2bd2ac2825a570fffac33282c05ee"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/f6ae418aa546bf481bf5079ade672c0aa41bf188","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/f6ae418aa546bf481bf5079ade672c0aa41bf188","html_url":"https://github.com/apache/openjpa/commit/f6ae418aa546bf481bf5079ade672c0aa41bf188","comments_url":"https://api.github.com/repos/apache/openjpa/commits/f6ae418aa546bf481bf5079ade672c0aa41bf188/comments","author":null,"committer":null,"parents":[{"sha":"9177e9369af17d0ad68a95401a23db6555eb9077","url":"https://api.github.com/repos/apache/openjpa/commits/9177e9369af17d0ad68a95401a23db6555eb9077","html_url":"https://github.com/apache/openjpa/commit/9177e9369af17d0ad68a95401a23db6555eb9077"}],"stats":{"total":244,"additions":244,"deletions":0},"files":[{"sha":"5d2839c1d7ae894b9ee311069857acde4f91804e","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","status":"modified","additions":73,"deletions":0,"changes":73,"blob_url":"https://github.com/apache/openjpa/blob/f6ae418aa546bf481bf5079ade672c0aa41bf188/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","raw_url":"https://github.com/apache/openjpa/raw/f6ae418aa546bf481bf5079ade672c0aa41bf188/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/Filters.java?ref=f6ae418aa546bf481bf5079ade672c0aa41bf188","patch":"@@ -23,6 +23,8 @@\n import java.math.BigInteger;\n import java.security.AccessController;\n import java.security.PrivilegedActionException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n import java.util.ArrayList;\n import java.util.Calendar;\n import java.util.Collection;\n@@ -231,6 +233,8 @@ public static boolean canConvert(Class c1, Class c2, boolean strict) {\n             return true;\n         if (c2 == String.class)\n             return !strict;\n+        if (c1 == String.class && isTemporalType(c2))\n+            return true;\n         return false;\n     }\n \n@@ -288,6 +292,14 @@ else if (o instanceof String && ((String) o).length() == 1)\n                         return i;\n                     num = true;\n                 }\n+            } else if (o instanceof String && isJDBCTemporalSyntax(o.toString())) {\n+                try {\n+                    Object temporal = parseJDBCTemporalSyntax(o.toString());\n+                    if (temporal != null && type.isAssignableFrom(temporal.getClass()))\n+                        return temporal;\n+                } catch (IllegalArgumentException e) {\n+                    \n+                }\n             }\n         }\n         if (!num)\n@@ -911,4 +923,65 @@ public static void hintToSetter(Object target, String hintKey,\n         }\n         Reflection.set(target, setter, value);\n \t}\n+    \n+    /**\n+     * Parses the given string assuming it is a JDBC key expression. Extracts the \n+     * data portion and based on the key, calls static java.sql.Date/Time/Timestamp.valueOf(String)\n+     * method to convert to a java.sql.Date/Time/Timestamp instance.\n+     */\n+    public static Object parseJDBCTemporalSyntax(String s) {\n+        s = clip(s.trim(), \"{\", \"}\", true);\n+        if (s.startsWith(\"ts\")) {\n+            return java.sql.Timestamp.valueOf(clip(s.substring(2).trim(), \"'\", \"'\", false));\n+        } else if (s.startsWith(\"d\")) {\n+            return java.sql.Date.valueOf(clip(s.substring(1).trim(), \"'\", \"'\", false));\n+        } else if (s.startsWith(\"t\")) {\n+            return java.sql.Time.valueOf(clip(s.substring(2).trim(), \"'\", \"'\", false));\n+        } else {\n+            return null;\n+        }\n+    }\n+    \n+    /**\n+     * Affirms if the given String is enclosed in {}.\n+     * \n+     */\n+    public static boolean isJDBCTemporalSyntax(String s) {\n+        if (s != null) {\n+            s = s.trim();\n+        }\n+        return s != null && s.startsWith(\"{\") && s.endsWith(\"}\");\n+    }\n+    \n+    /**\n+     * Removes the first and last string if they are the terminal sequence in the given string.\n+     * \n+     * @param s a string to be examined\n+     * @param first the characters in the beginning of the given string\n+     * @param last the characters in the end of the given string\n+     * @param fail if true throws exception if the given string does not have the given terminal sequences.\n+     * @return the string with terminal sequences removed.\n+     */\n+    public static String clip(String s, String first, String last, boolean fail) {\n+        if (s == null)\n+            return s;\n+        if (s.startsWith(first) && s.endsWith(last)) {\n+            return s.substring(first.length(), s.length()-last.length()).trim();\n+        }\n+        if (fail) {\n+            throw new IllegalArgumentException(s + \" is not valid escape syntax for JDBC\");\n+        }\n+        return s;\n+    }\n+    \n+    /**\n+     * Affirms if the given class is Data, Time or Timestamp.\n+     */\n+    public static boolean isTemporalType(Class<?> c) {\n+        return c != null \n+            && (Date.class.isAssignableFrom(c) \n+             || Time.class.isAssignableFrom(c) \n+             || Timestamp.class.isAssignableFrom(c));\n+    }\n+\n }"},{"sha":"a2eacca173b9797c193887c94825f08fc8c2ed60","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/criteria/TestDateStringConversion.java","status":"added","additions":171,"deletions":0,"changes":171,"blob_url":"https://github.com/apache/openjpa/blob/f6ae418aa546bf481bf5079ade672c0aa41bf188/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/criteria/TestDateStringConversion.java","raw_url":"https://github.com/apache/openjpa/raw/f6ae418aa546bf481bf5079ade672c0aa41bf188/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/criteria/TestDateStringConversion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/criteria/TestDateStringConversion.java?ref=f6ae418aa546bf481bf5079ade672c0aa41bf188","patch":"@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.persistence.criteria;\n+\n+import java.sql.Date;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.util.List;\n+\n+import javax.persistence.criteria.CriteriaQuery;\n+import javax.persistence.criteria.Root;\n+\n+import org.apache.openjpa.kernel.Filters;\n+\n+/**\n+ * Test JDBC Escape Syntax date/time strings in query.\n+ * \n+ * \n+ * @author Pinaki Poddar\n+ *\n+ */\n+public class TestDateStringConversion extends CriteriaTest {\n+    private static final String OPEN_BRACKET  = \"{\";\n+    private static final String CLOSE_BRACKET = \"}\";\n+    private static final String SINGLE_QUOTE  = \"'\";\n+    \n+    void createData(String name) {\n+        long now = System.currentTimeMillis();\n+        long tomorrow = now + 24*60*60*1000+1;\n+        \n+        Date date = new Date(tomorrow);\n+        DependentId id = new DependentId();\n+        id.setEffDate(date);\n+        id.setName(name);\n+        Dependent pc = new Dependent();\n+        pc.setId(id);\n+        pc.setEndDate(date);\n+        em.getTransaction().begin();\n+        em.persist(pc);\n+        em.getTransaction().commit();\n+    }\n+    \n+    /**\n+     * The persistent property Dependent.endDate being tested is declared as Date but mapped with\n+     * @Temporal(TemporalType.TIMESTAMP). \n+     * \n+     * When executing JPQL, the query string directly uses a JDBC Escape Syntax that is passed\n+     * to JDBC Driver and hence that string should encode a Timestamp.\n+     * \n+     * Criteria Query, on the other hand, must conform to the API signature and hence the expression\n+     * that takes the JDBC Escape Syntax must be cast to Date.class to match the declared type of\n+     * Dependent.endDate.\n+     * \n+     */\n+    public void testDateString() {\n+        createData(\"testDateString\");\n+        long now = System.currentTimeMillis();\n+        \n+        String dateString = createJDBCEscapeString(new Date(now));\n+        String tsString = createJDBCEscapeString(new Timestamp(now));\n+        \n+        // add Timestamp string because Dependent.endDate is mapped to TemporalType.TimeStamp\n+        String jpql = \"select d from Dependent d where d.endDate >= \" + tsString + \" ORDER BY d.endDate\";\n+        \n+        \n+        CriteriaQuery<Dependent> c = cb.createQuery(Dependent.class);\n+        Root<Dependent> d = c.from(Dependent.class);\n+        // the literal is cast to Date.class because Dependent.endDate is declared as Date\n+        c.where(cb.greaterThanOrEqualTo(d.get(Dependent_.endDate), cb.literal(dateString).as(Date.class)));\n+        c.orderBy(cb.asc(d.get(Dependent_.endDate)));\n+        \n+        // can not compare SQL because JPQL and Criteria handles JDBC escape syntax in \n+        // a different way.\n+        assertSameResult(c, jpql);\n+    }\n+    \n+    /**\n+     * A similar query but the JDBC Escape String is passed as an parameter.\n+     * Parameter value binding is relaxed to accept the string as a value\n+     * of temporal type instance.\n+     * Hence does not require, as in the the earlier case, to use different \n+     * escape string. \n+     */\n+    public void testDateStringAsParameter() {\n+        createData(\"testDateStringAsParameter\");\n+        long now = System.currentTimeMillis();\n+        \n+        Date earlier = new Date(now - 1000);\n+        \n+        String dateString = createJDBCEscapeString(earlier);\n+        String jpql = \"select d from Dependent d where d.endDate >= :dateString ORDER BY d.endDate\";\n+        CriteriaQuery<Dependent> c = cb.createQuery(Dependent.class);\n+        Root<Dependent> d = c.from(Dependent.class);\n+        \n+        c.where(cb.greaterThanOrEqualTo(d.get(Dependent_.endDate), cb.parameter(String.class, \"dateString\")\n+                .as(Date.class)));\n+        c.orderBy(cb.asc(d.get(Dependent_.endDate)));\n+        \n+        assertEquivalence(c, jpql, new String[]{\"dateString\"}, new Object[]{dateString});\n+    }\n+    \n+    String createJDBCEscapeString(Object time) {\n+        String key = \"\";\n+        if (time instanceof Date)\n+            key = \"d \";\n+        else if (time instanceof Time)\n+            key = \"t \";\n+        else if (time instanceof Timestamp)\n+            key = \"ts \";\n+        else {\n+            fail(\"Wrong object \" + time + \" of \" + time.getClass() + \" for JDBC conversion\");\n+        }\n+        return OPEN_BRACKET + key + SINGLE_QUOTE + time.toString() + SINGLE_QUOTE + CLOSE_BRACKET;\n+    }\n+    \n+    public void testJDBCEscapeSyntaxTimestamp() {\n+        Timestamp ts = new Timestamp(System.currentTimeMillis());\n+        String s = \"{ts '\" + ts.toString() + \"'}\";\n+        assertTrue(Filters.isJDBCTemporalSyntax(s));\n+        assertNotNull(Filters.parseJDBCTemporalSyntax(s));\n+        Object converted = Filters.convert(s, Timestamp.class);\n+        assertTrue(converted instanceof Timestamp);\n+        assertEquals(\"Original=\" + s + \" Converted \" + converted, ts.toString(), converted.toString());\n+    }\n+    \n+    public void testJDBCEscapeSyntaxTime() {\n+        Time t = new Time(System.currentTimeMillis());\n+        String s = \"{t '\" + t.toString() + \"'}\";\n+        assertTrue(Filters.isJDBCTemporalSyntax(s));\n+        assertNotNull(Filters.parseJDBCTemporalSyntax(s));\n+        Object converted = Filters.convert(s, Time.class);\n+        assertTrue(converted instanceof Time);\n+        assertEquals(\"Original=\" + s + \" Converted \" + converted, t.toString(), converted.toString());\n+    }\n+    \n+    public void testJDBCEscapeSyntaxDate() {\n+        Date d = new Date(System.currentTimeMillis());\n+        String s = \"{d '\" + d.toString() + \"'}\";\n+        assertTrue(Filters.isJDBCTemporalSyntax(s));\n+        assertNotNull(Filters.parseJDBCTemporalSyntax(s));\n+        Object converted = Filters.convert(s, Date.class);\n+        assertTrue(converted instanceof Date);\n+        assertEquals(\"Original=\" + s + \" Converted \" + converted, d.toString(), converted.toString());\n+    }\n+    \n+    void assertSameResult(CriteriaQuery<Dependent> c, String jpql) {\n+        List<Dependent> jResult = em.createQuery(jpql).getResultList();\n+        List<Dependent> cResult = em.createQuery(c).getResultList();\n+        assertFalse(jResult.isEmpty());\n+        assertEquals(cResult.size(), jResult.size());\n+        for (int i = 0; i < jResult.size(); i++) {\n+            assertEquals(jResult.get(i).getEndDate(), cResult.get(i).getEndDate());\n+        }\n+    }\n+}"}]}

