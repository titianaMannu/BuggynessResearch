{"sha":"f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","node_id":"MDY6Q29tbWl0MjA2MzY0OmY3NGM1ZDdhNjlmYjNkZGE2N2ZiMjZjMWMwMjUwZDQ4ZTI5ZmUzNTk=","commit":{"author":{"name":"Fay Wang","email":"faywang@apache.org","date":"2009-07-20T17:49:36Z"},"committer":{"name":"Fay Wang","email":"faywang@apache.org","date":"2009-07-20T17:49:36Z"},"message":"OPENJPA-1185: commit subquery overhaul on behalf of Catalina\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@795934 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"331b5532d7a0640611ef2c3243c2c59d7da772ce","url":"https://api.github.com/repos/apache/openjpa/git/trees/331b5532d7a0640611ef2c3243c2c59d7da772ce"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","html_url":"https://github.com/apache/openjpa/commit/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","comments_url":"https://api.github.com/repos/apache/openjpa/commits/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/comments","author":null,"committer":null,"parents":[{"sha":"0adf13872e941840ad4d349d7e52dff0f96eff70","url":"https://api.github.com/repos/apache/openjpa/commits/0adf13872e941840ad4d349d7e52dff0f96eff70","html_url":"https://github.com/apache/openjpa/commit/0adf13872e941840ad4d349d7e52dff0f96eff70"}],"stats":{"total":1430,"additions":1151,"deletions":279},"files":[{"sha":"22608e27d4be80cbf5aea40c3d3d2695ac89191a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","status":"modified","additions":26,"deletions":3,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreQuery.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -30,7 +30,6 @@\n import java.util.Map;\n \n import org.apache.openjpa.event.LifecycleEventManager;\n-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n import org.apache.openjpa.jdbc.kernel.exps.ExpContext;\n import org.apache.openjpa.jdbc.kernel.exps.GetColumn;\n import org.apache.openjpa.jdbc.kernel.exps.JDBCExpressionFactory;\n@@ -46,20 +45,20 @@\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n import org.apache.openjpa.jdbc.meta.strats.VerticalClassStrategy;\n import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\n import org.apache.openjpa.jdbc.schema.Table;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.SQLExceptions;\n import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.jdbc.sql.SelectImpl;\n import org.apache.openjpa.jdbc.sql.Union;\n import org.apache.openjpa.kernel.ExpressionStoreQuery;\n import org.apache.openjpa.kernel.Filters;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.OrderingMergedResultObjectProvider;\n-import org.apache.openjpa.kernel.QueryContext;\n import org.apache.openjpa.kernel.QueryHints;\n import org.apache.openjpa.kernel.exps.Constant;\n+import org.apache.openjpa.kernel.exps.Context;\n import org.apache.openjpa.kernel.exps.ExpressionFactory;\n import org.apache.openjpa.kernel.exps.ExpressionParser;\n import org.apache.openjpa.kernel.exps.FilterListener;\n@@ -143,11 +142,28 @@ public boolean supportsDataStoreExecution() {\n     protected ExpressionFactory getExpressionFactory(ClassMetaData meta) {\n         return new JDBCExpressionFactory((ClassMapping) meta);\n     }\n+    \n+    private void resetSelect(Context ctx) {\n+        List<Context> subselCtxs = ctx.getSubselContexts();\n+        if (subselCtxs != null) {\n+            for (Context subselCtx : subselCtxs) {\n+                SelectImpl sel = (SelectImpl)subselCtx.getSelect();\n+                sel.reset();\n+                resetSelect(subselCtx);\n+            }\n+        }\n+    }\n \n     protected ResultObjectProvider executeQuery(Executor ex,\n         ClassMetaData base, ClassMetaData[] metas, boolean subclasses,\n         ExpressionFactory[] facts, QueryExpressions[] exps, Object[] params,\n         Range range) {\n+        Context expCtx = exps[0].ctx(); \n+        if (expCtx != null) {\n+            expCtx.resetAliasCount();\n+            expCtx.setSelect(null);\n+            resetSelect(expCtx);\n+        }\n         if (metas.length > 1 && exps[0].isAggregate())\n             throw new UserException(Localizer.forPackage(JDBCStoreQuery.class).\n                 get(\"mult-mapping-aggregate\", Arrays.asList(metas)));\n@@ -449,6 +465,13 @@ protected Number executeUpdate(Executor ex, ClassMetaData base,\n     private Number executeBulkOperation(ClassMetaData[] metas,\n         boolean subclasses, ExpressionFactory[] facts, QueryExpressions[] exps,\n         Object[] params, Map updates) {\n+        Context expCtx = exps[0].ctx(); \n+        if (ctx != null) {\n+            expCtx.resetAliasCount();\n+            expCtx.setSelect(null);\n+            resetSelect(expCtx);\n+        }\n+        \n         // we cannot execute a bulk delete statement when have mappings in\n         // multiple tables, so indicate we want to use in-memory with null\n         ClassMapping[] mappings = (ClassMapping[]) metas;"},{"sha":"fcbc2f3f0f58f46b72780c41fb3562e4d8b854fb","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AbstractVal.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AbstractVal.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AbstractVal.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/AbstractVal.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -114,5 +114,9 @@ public Value getSelectAs() {\n     public Path getPath() {\n         return null;\n     }\n+    \n+    public String getName() {\n+        return null;\n+    }    \n }\n "},{"sha":"c6bf4b779eecea161e9ceb032dabbea93bc04613","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ConstPath.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -27,6 +27,7 @@\n import org.apache.openjpa.kernel.Broker;\n import org.apache.openjpa.kernel.Filters;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.exps.Context;\n import org.apache.openjpa.kernel.exps.ExpressionVisitor;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n@@ -217,4 +218,14 @@ public void get(XMLMetaData meta, String name) {\n     public XMLMetaData getXmlMapping() {\n         return null;\n     }\n+\n+    public void setSchemaAlias(String schemaAlias) {\n+    }\n+    \n+    public String getSchemaAlias() {\n+        return null;\n+    }\n+    \n+    public void setSubqueryContext(Context conext) {\n+    }\n }"},{"sha":"954d0f1c8f76289bcbdeb35016bba050ce12ef8f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -167,7 +167,8 @@ public Expression or(Expression exp1, Expression exp2) {\n     }\n \n     public Expression not(Expression exp) {\n-        if (HasContainsExpressionVisitor.hasContains(exp))\n+        if (!(exp instanceof IsNotEmptyExpression) &&\n+            HasContainsExpressionVisitor.hasContains(exp))\n             return new NotContainsExpression((Exp) exp);\n         return new NotExpression((Exp) exp);\n     }"},{"sha":"c68ec854fd64378d39be1c991fe76dd679c10dcc","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Lit.java","status":"modified","additions":8,"deletions":1,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Lit.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Lit.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/Lit.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -36,6 +36,7 @@\n     private Object _val;\n     private int _ptype;\n     private boolean _isRaw;\n+    private Object _rawVal;\n \n     /**\n      * Constructor. Supply literal value.\n@@ -46,6 +47,8 @@ public Lit(Object val, int ptype) {\n     }\n \n     public Class getType() {\n+        if (_isRaw && _rawVal != null)\n+            return Raw.class;\n         return (_val == null) ? Object.class : _val.getClass();\n     }\n \n@@ -77,6 +80,10 @@ public void setRaw(boolean isRaw) {\n         _isRaw = isRaw;\n     }\n \n+    public Object getRawValue() {\n+        return _rawVal;\n+    }\n+\n     public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n         return new LitExpState();\n     }\n@@ -120,7 +127,7 @@ public void appendTo(Select sel, ExpContext ctx, ExpState state,\n                 if (!isOrdinal)\n                     value.append(\"'\");\n                 lstate.sqlValue = new Raw(value.toString());\n-                setValue(lstate.sqlValue);\n+                _rawVal = lstate.sqlValue;\n             }\n             sql.appendValue(lstate.sqlValue, lstate.getColumn(index));\n         }"},{"sha":"5c2c97a78328cd2c42e6eaccde9cd6d4acbc04a6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotContainsExpression.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotContainsExpression.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotContainsExpression.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/NotContainsExpression.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -67,6 +67,10 @@ public void appendTo(Select sel, ExpContext ctx, ExpState state,\n \n         Select sub = ctx.store.getSQLFactory().newSelect();\n         sub.setParent(sel, null);\n+        // this subselect has the same context as its parent\n+        sub.setContext(sel.ctx());\n+        // the context select should still belong to parent\n+        sub.ctx().setSelect(sel);\n         ExpState estate = _exp.initialize(sub, ctx, ((NotContainsExpState) \n             state).contains);\n         sub.where(sub.and(null, estate.joins));"},{"sha":"1d0cc53257d181bac398157d96d74cffd2628b99","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","status":"modified","additions":110,"deletions":7,"changes":117,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -45,6 +45,7 @@\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.StoreContext;\n import org.apache.openjpa.kernel.exps.CandidatePath;\n+import org.apache.openjpa.kernel.exps.Context;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n@@ -82,6 +83,7 @@\n     private boolean _cid = false;\n     private FieldMetaData _xmlfield = null;\n     private boolean _keyPath = false;\n+    private String _schemaAlias = null;\n \n     /**\n      * Return a path starting with the 'this' ptr.\n@@ -99,10 +101,12 @@ public PCPath(ClassMapping candidate, Variable var) {\n \n         PCPath other = var.getPCPath();\n         Action action = new Action();\n+        action.var = var.getName();\n         if (other == null) {\n             _type = UNBOUND_VAR;\n             action.op = Action.UNBOUND_VAR;\n             action.data = var;\n+            _schemaAlias = var.getName();\n         } else {\n             // bound variable; copy path\n             _type = UNACCESSED_VAR;\n@@ -111,6 +115,7 @@ public PCPath(ClassMapping candidate, Variable var) {\n \n             action.op = Action.VAR;\n             action.data = var.getName();\n+            _schemaAlias = other._schemaAlias;\n         }\n         _actions.add(action);\n         _cast = var.getType(); // initial type is var type\n@@ -131,6 +136,22 @@ public PCPath(SubQ sub) {\n         _varName = sub.getCandidateAlias();\n     }\n \n+    public void setSchemaAlias(String schemaAlias) {\n+        if (_schemaAlias == null) \n+            _schemaAlias = schemaAlias;\n+    }\n+\n+    public String getSchemaAlias() {\n+        return _schemaAlias;\n+    }\n+    \n+    public void setSubqueryContext(Context context) {\n+        Action action = lastFieldAction();\n+        if (action == null)\n+            return;\n+        action.context = context;\n+    }\n+    \n     /**\n      * Set the path as a binding of the given variable.\n      */\n@@ -420,8 +441,7 @@ public Class getType() {\n         if (act != null && act.op == Action.GET_XPATH)\n             return ((XMLMetaData) act.data).getType();\n         \n-        FieldMetaData fld = act == null ? null :\n-            (FieldMetaData) act.data;\n+        FieldMetaData fld = (act == null) ? null : (FieldMetaData) act.data;\n         boolean key = act != null && act.op == Action.GET_KEY;\n         if (fld != null) {\n             switch (fld.getDeclaredTypeCode()) {\n@@ -457,30 +477,53 @@ public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n         boolean forceOuter = false;\n         ClassMapping rel = _candidate;\n \n+        sel.setSchemaAlias(_schemaAlias);\n+\n         // iterate to the final field\n         ClassMapping owner;\n         ClassMapping from, to;\n         Action action;\n         Variable var;\n         Iterator itr = (_actions == null) ? null : _actions.iterator();\n         FieldMapping field = null;\n+        Action prevaction = null;\n+        boolean isCorrelatedPath = false;\n+        boolean fromParentRootInSubselect = navigateFromParentRootInSubselect(sel);\n+                \n         while (itr != null && itr.hasNext()) {\n             action = (Action) itr.next();\n \n             // treat subqueries like variables for alias generation purposes\n-            if (action.op == Action.VAR)\n-                pstate.joins = pstate.joins.setVariable((String) action.data);\n-            else if (action.op == Action.SUBQUERY)\n+            if (action.op == Action.VAR) {\n+                if (sel.getParent() != null && action.var != null &&\n+                    prevaction != null && prevaction.data != null &&\n+                    sel.ctx().getVariable(action.var) == null) {\n+                    //System.out.println(\"Correlated action var=\"+action.var);\n+                    isCorrelatedPath = true;\n+                    pstate.joins = pstate.joins.setCorrelatedVariable(action.var);\n+                } else \n+                    pstate.joins = pstate.joins.setVariable((String) action.data);\n+            }\n+            else if (action.op == Action.SUBQUERY) {\n                 pstate.joins = pstate.joins.setSubselect((String) action.data);\n+            }\n             else if (action.op == Action.UNBOUND_VAR) {\n                 // unbound vars are cross-joined to the candidate table\n                 var = (Variable) action.data;\n                 rel = (ClassMapping) var.getMetaData();\n                 if (rel == null)\n                 \tthrow new IllegalArgumentException(_loc.get(\n                 \t    \"invalid-unbound-var\", var.getName()).toString());\n-                pstate.joins = pstate.joins.setVariable(var.getName());\n-                pstate.joins = pstate.joins.crossJoin(_candidate.getTable(), \n+                \t    \n+                if (sel.getParent() != null && action.var != null &&\n+                    sel.ctx().getVariable(action.var) == null) {\n+                    //System.out.println(\"Correlated action var=\"+action.var);\n+                    isCorrelatedPath = true;\n+                    pstate.joins = pstate.joins.setCorrelatedVariable(var.getName());\n+                } else                 \n+                    pstate.joins = pstate.joins.setVariable(var.getName());\n+\n+                pstate.joins = pstate.joins.crossJoin(_candidate.getTable(),\n                     rel.getTable());\n             } else {\n                 // move past the previous field, if any\n@@ -496,6 +539,13 @@ else if (action.op == Action.UNBOUND_VAR) {\n                         pstate.cmpfield = field;\n                         break;\n                     }\n+                    \n+                    if (fromParentRootInSubselect) {\n+                        isCorrelatedPath = true;\n+                        pstate.joins = pstate.joins.setCorrelatedVariable(_schemaAlias);\n+                        pstate.joins.setJoinContext(null);\n+                    }\n+                    \n                     rel = traverseField(pstate, key, forceOuter, false);\n                 }\n \n@@ -543,6 +593,9 @@ else if (action.op == Action.UNBOUND_VAR) {\n                 if (action.op == Action.GET_XPATH)\n                     break;\n             }\n+            prevaction = action;\n+            if (prevaction != null && prevaction.context != null) \n+                pstate.joins = pstate.joins.setJoinContext(prevaction.context);\n         }\n         if (_varName != null)\n             pstate.joins = pstate.joins.setVariable(_varName);\n@@ -557,9 +610,55 @@ else if (action.op == Action.UNBOUND_VAR) {\n         if ((flags & JOIN_REL) != 0)\n             joinRelation(pstate, key, forceOuter || (flags & FORCE_OUTER) != 0,\n                 false);\n+        if (isCorrelatedPath) {\n+            // check if there are joins that belong to parent\n+            pstate.joins.moveJoinsToParent();\n+        }\n+        pstate.joins.setJoinContext(null);\n+        \n+        if (_actions == null) {\n+            String subqAlias = findSubqAlias(sel);\n+            pstate.joins = pstate.joins.setSubselect(subqAlias);\n+            pstate.joins.setCorrelatedVariable(_schemaAlias);\n+        }\n+        \n         return pstate;\n     }\n+    \n+    public String findSubqAlias(Select sel) {\n+        Select pSel = sel.getParent();\n+        if (pSel == null)\n+            return null;\n+        Context pCtx = pSel.ctx();\n+        if (pCtx.subquery == null)\n+            return null;\n+        if (pCtx.getSchema(_schemaAlias) != null)\n+            return ((SubQ)pCtx.subquery).getCandidateAlias();\n+        return findSubqAlias(pSel);\n+    }\n \n+    /**\n+     * When a PCPath is in subselect, and it is simply a navigation\n+     * from the parent root, the joins involved in this PCPath\n+     * must happen in the main select.  \n+     */\n+    private boolean navigateFromParentRootInSubselect(Select sel) {\n+        if (sel.getParent() == null)\n+            return false;\n+        Iterator itr = (_actions == null) ? null : _actions.iterator();\n+        boolean navigateFromRoot = false;\n+        boolean hasVar = false;\n+        boolean startsWithSubquery = false;\n+        while (itr != null && itr.hasNext()) {\n+            Action action = (Action) itr.next();\n+            if (action.op == Action.VAR) \n+                hasVar = true;\n+            else if (action.op == Action.SUBQUERY)\n+                startsWithSubquery = true;\n+        }\n+        return !hasVar && !startsWithSubquery && sel.ctx().getSchema(_schemaAlias) == null;\n+    }\n+    \n     /**\n      * Return whether the given source field joins to the given target field.\n      */\n@@ -846,6 +945,8 @@ public int length(Select sel, ExpContext ctx, ExpState state) {\n     public void appendTo(Select sel, ExpContext ctx, ExpState state, \n         SQLBuffer sql, int index) {\n         Column col = getColumns(state)[index];\n+        if (sel != null)\n+            sel.setSchemaAlias(_schemaAlias);\n \n         // if select is null, it means we are not aliasing columns\n         // (e.g., during a bulk update)\n@@ -977,6 +1078,8 @@ public int getId() {\n \n         public int op = -1;\n         public Object data = null;\n+        public String var = null;\n+        public Context context = null;\n \n         public String toString() {\n             return op + \"|\" + data;"},{"sha":"fc5594abb1dbf740a64f35588f9e18e774b7f57b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java","status":"modified","additions":24,"deletions":1,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SelectConstructor.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -20,6 +20,7 @@\n \n import java.io.Serializable;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n \n import org.apache.openjpa.jdbc.meta.ClassMapping;\n@@ -29,8 +30,10 @@\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.kernel.exps.AbstractExpressionVisitor;\n import org.apache.openjpa.kernel.exps.Constant;\n+import org.apache.openjpa.kernel.exps.Context;\n import org.apache.openjpa.kernel.exps.Expression;\n import org.apache.openjpa.kernel.exps.QueryExpressions;\n+import org.apache.openjpa.kernel.exps.Subquery;\n import org.apache.openjpa.kernel.exps.Value;\n \n /**\n@@ -43,6 +46,7 @@\n     implements Serializable {\n \n     private boolean _extent = false;\n+    private Select _subselect = null;\n \n     /**\n      * Return true if we know the select to have on criteria; to be an extent.\n@@ -53,6 +57,10 @@ public boolean isExtent() {\n         return _extent;\n     }\n \n+    public void setSubselect(Select subselect) {\n+        _subselect = subselect;\n+    }\n+\n     /**\n      * Evaluate the expression, returning a new select and filling in any\n      * associated expression state. Use {@link #select} to then select the data.\n@@ -114,10 +122,25 @@ public Select evaluate(ExpContext ctx, Select parent, String alias,\n      */\n     private Select newSelect(ExpContext ctx, Select parent,\n         String alias, QueryExpressions exps, QueryExpressionsState state) {\n-        Select sel = ctx.store.getSQLFactory().newSelect();\n+        Select sel = parent != null ? _subselect\n+            : ctx.store.getSQLFactory().newSelect();\n         sel.setAutoDistinct((exps.distinct & exps.DISTINCT_AUTO) != 0);\n         sel.setJoinSyntax(ctx.fetch.getJoinSyntax());\n         sel.setParent(parent, alias);\n+\n+        if (sel.ctx() == null)\n+            sel.setContext(exps.ctx());\n+\n+        if (parent == null && exps.ctx().getSubselContexts() != null) {\n+            // this is the case subselect was created before parent got created\n+            List<Context> subselCtxs = exps.ctx().getSubselContexts();\n+            for (Context subselCtx : subselCtxs) {\n+                Select subsel = (Select) subselCtx.getSelect();\n+                Subquery subquery = subselCtx.getSubquery();\n+                subsel.setParent(sel, subquery.getCandidateAlias());\n+            }\n+        }\n+     \n         initialize(sel, ctx, exps, state);\n \n         if (!sel.getAutoDistinct()) {"},{"sha":"c9b3d74545820f007f80d44107c9d38bbb83b293","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java","status":"modified","additions":27,"deletions":7,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/SubQ.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -20,6 +20,7 @@\n \n import java.sql.SQLException;\n \n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n@@ -38,18 +39,19 @@\n  *\n  * @author Abe White\n  */\n-class SubQ\n+public class SubQ\n     extends AbstractVal\n     implements Subquery {\n \n     private final ClassMapping _candidate;\n     private final boolean _subs;\n-    private final String _alias;\n+    private final String _subqAlias;\n     private final SelectConstructor _cons = new SelectConstructor();\n \n     private Class _type = null;\n     private ClassMetaData _meta = null;\n     private QueryExpressions _exps = null;\n+    private Select _select = null;\n \n     /**\n      * Constructor. Supply candidate, whether subclasses are included in\n@@ -58,7 +60,14 @@\n     public SubQ(ClassMapping candidate, boolean subs, String alias) {\n         _candidate = candidate;\n         _subs = subs;\n-        _alias = alias;\n+        _subqAlias = alias;\n+        _select = (((JDBCConfiguration) candidate.getMappingRepository().\n+            getConfiguration()).getSQLFactoryInstance().newSelect());\n+        _cons.setSubselect(_select);\n+    }\n+\n+    public Object getSelect() {\n+        return _select;\n     }\n \n     /**\n@@ -67,6 +76,14 @@ public SubQ(ClassMapping candidate, boolean subs, String alias) {\n     public ClassMapping getCandidate() {\n         return _candidate;\n     }\n+    \n+    public boolean getSubs() {\n+        return _subs;\n+    }\n+    \n+    public String getSubqAlias() {\n+        return _subqAlias;\n+    }\n \n     public Class getType() {\n         if (_exps != null && _type == null) {\n@@ -93,16 +110,19 @@ public void setMetaData(ClassMetaData meta) {\n     }\n \n     public String getCandidateAlias() {\n-        return _alias;\n+        return _subqAlias;\n     }\n \n     public void setQueryExpressions(QueryExpressions query) {\n         _exps = query;\n+        _select.setContext(query.ctx());\n     }\n \n     public ExpState initialize(Select sel, ExpContext ctx, int flags) {\n-        if (_exps.projections.length == 1)\n-            return ((Val) _exps.projections[0]).initialize(sel, ctx, flags);\n+        _select.setParent(sel, null);\n+        if (_exps.projections.length == 1) {\n+            return ((Val) _exps.projections[0]).initialize(_select, ctx, flags);\n+        }\n         return ExpState.NULL;\n     }\n \n@@ -180,7 +200,7 @@ public void appendTo(Select sel, ExpContext ctx, ExpState state,\n     private void appendTo(Select sel, ExpContext ctx, ExpState state, \n         SQLBuffer sql, int index, boolean size) {\n         QueryExpressionsState substate = new QueryExpressionsState();\n-        Select sub = _cons.evaluate(ctx, sel, _alias, _exps, substate);\n+        Select sub = _cons.evaluate(ctx, sel, _subqAlias, _exps, substate);\n         _cons.select(sub, ctx, _candidate, _subs, _exps, substate, \n             JDBCFetchConfiguration.EAGER_NONE);\n "},{"sha":"e7cfa8abd1da353b5264bdacdd420d36e0fcb652","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMapping.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMapping.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMapping.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -583,6 +583,7 @@ public void mapJoin(boolean adapt, boolean joinRequired) {\n             _unq = _info.getJoinUnique(this, false, adapt);\n             _joinTableUniques = _info.getJoinTableUniques(this, false, adapt);\n             _idx = _info.getJoinIndex(this, adapt);\n+            table.setAssociation();\n         }\n     }\n "},{"sha":"7dd895aef4e31db5b54750888cfce2d329f9260a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java","status":"modified","additions":10,"deletions":1,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -62,7 +62,8 @@\n     private Unique[] _unqs = null;\n     private String _comment = null;\n     private int _lineNum = 0;  \n-    private int _colNum = 0;  \n+    private int _colNum = 0;\n+    private boolean _isAssociation = false;\n \n     /**\n      * Default constructor.\n@@ -84,6 +85,14 @@ public Table(String name, Schema schema) {\n         _schema = schema;\n     }\n \n+    public void setAssociation() {\n+        _isAssociation = true;\n+    }\n+\n+    public boolean isAssociation() {\n+        return _isAssociation;\n+    }\n+\n     /**\n      * Called when the table is removed from its schema. Removes all table\n      * members, and invalidates the table."},{"sha":"8e462238f86e1a8b51f9a8f165a68ca3f9439031","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractResult.java","status":"modified","additions":16,"deletions":0,"changes":16,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractResult.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractResult.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractResult.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -47,6 +47,7 @@\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.kernel.exps.Context;\n import org.apache.openjpa.lib.util.Closeable;\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.util.UnsupportedException;\n@@ -885,7 +886,22 @@ public Joins setSubselect(String alias) {\n             return this;\n         }\n \n+        public Joins setJoinContext(Context context) {\n+            return this;\n+        }\n+\n         public void appendTo(SQLBuffer buf) {\n         }\n+\n+        public Joins setCorrelatedVariable(String var) {\n+            return this;\n+        }\n+\n+        public String getCorrelatedVariable() {\n+            return null;\n+        }\n+        \n+        public void moveJoinsToParent() {\n+        }\n     }\n }"},{"sha":"594ce2083f9c4ec05da947252e9b34d607eac08c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","status":"modified","additions":70,"deletions":15,"changes":85,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -2197,14 +2197,59 @@ protected SQLBuffer getFrom(Select sel, boolean forUpdate) {\n             Iterator itr = sel.getJoinIterator();\n             boolean first = true;\n             while (itr.hasNext()) {\n-                fromSQL.append(toSQL92Join((Join) itr.next(), forUpdate,\n+                Join join = (Join) itr.next();\n+                if (correlatedJoinCondition(join, sel))\n+                    continue;\n+                fromSQL.append(toSQL92Join(sel, join, forUpdate,\n                     first));\n                 first = false;\n+                if (itr.hasNext() && join.isCorrelated()) {\n+                    fromSQL.append(\", \");\n+                    first = true;\n+                }\n+            }\n+\n+            for (Iterator itr2 = aliases.iterator(); itr2.hasNext();) {\n+                String tableAlias = itr2.next().toString();\n+                if (fromSQL.getSQL().indexOf(tableAlias) == -1) {\n+                    if (!first)\n+                        fromSQL.append(\", \");\n+                    fromSQL.append(tableAlias);\n+                    first = false;\n+                }\n             }\n         }\n         return fromSQL;\n     }\n \n+    private boolean correlatedJoinCondition(Join join, Select sel) {\n+        if (!join.isCorrelated())\n+            return false;\n+        Iterator itr = sel.getJoinIterator();\n+        boolean skip = false;\n+        //if table1 in join is in the main query, table2 is in\n+        //subquery, and table2 participates in other joins\n+        //in subquery, the join condition can only be placed in \n+        //the where clause in the subquery\n+        while (itr.hasNext()) {\n+            Join join1 = (Join) itr.next();\n+            if (join == join1)\n+                continue;\n+            if (join.getIndex2() == join1.getIndex1() ||\n+                join.getIndex2() == join1.getIndex2()) {\n+                skip = true;\n+                if (join.getForeignKey() != null){\n+                    SQLBuffer where = new SQLBuffer(this);\n+                    where.append(\"(\").append(toTraditionalJoin(join)).append(\")\");\n+                    sel.where(where.getSQL());\n+                }                \n+                break;\n+            }\n+        }\n+        return skip;\n+    }\n+    \n+    \n     /**\n      * Return the FROM clause for a select that selects from a tmp table\n      * created by an inner select.\n@@ -2308,33 +2353,43 @@ public SQLBuffer toTraditionalJoin(Join join) {\n      * Use the given join instance to create SQL joining its tables in\n      * the SQL92 style.\n      */\n-    public SQLBuffer toSQL92Join(Join join, boolean forUpdate, boolean first) {\n+    public SQLBuffer toSQL92Join(Select sel, Join join, boolean forUpdate,\n+        boolean first) {\n         SQLBuffer buf = new SQLBuffer(this);\n-        if (first) {\n+        boolean corelated = join.isCorrelated();\n+        if (first && !corelated) {\n             buf.append(join.getTable1()).append(\" \").\n                 append(join.getAlias1());\n             if (forUpdate && tableForUpdateClause != null)\n                 buf.append(\" \").append(tableForUpdateClause);\n         }\n \n         buf.append(\" \");\n-        if (join.getType() == Join.TYPE_OUTER)\n-            buf.append(outerJoinClause);\n-        else if (join.getType() == Join.TYPE_INNER)\n-            buf.append(innerJoinClause);\n-        else // cross\n-            buf.append(crossJoinClause);\n-        buf.append(\" \");\n+        if (!corelated) {\n+            if (join.getType() == Join.TYPE_OUTER)\n+                buf.append(outerJoinClause);\n+            else if (join.getType() == Join.TYPE_INNER)\n+                buf.append(innerJoinClause);\n+            else // cross\n+                buf.append(crossJoinClause);\n+            buf.append(\" \");\n+        }\n \n         buf.append(join.getTable2()).append(\" \").append(join.getAlias2());\n         if (forUpdate && tableForUpdateClause != null)\n             buf.append(\" \").append(tableForUpdateClause);\n \n-        if (join.getForeignKey() != null)\n-            buf.append(\" ON \").append(toTraditionalJoin(join));\n-        else if (requiresConditionForCrossJoin &&\n-            join.getType() == Join.TYPE_CROSS)\n-            buf.append(\" ON (1 = 1)\");\n+        if (!corelated) {\n+            if (join.getForeignKey() != null)\n+                buf.append(\" ON \").append(toTraditionalJoin(join));\n+            else if (requiresConditionForCrossJoin &&\n+                    join.getType() == Join.TYPE_CROSS)\n+                buf.append(\" ON (1 = 1)\");\n+        } else if (join.getForeignKey() != null){\n+            SQLBuffer where = new SQLBuffer(this);\n+            where.append(\"(\").append(toTraditionalJoin(join)).append(\")\");\n+            sel.where(where.getSQL());\n+        }\n \n         return buf;\n     }"},{"sha":"d3b3f0919897473766824540b001f773b1ac0f38","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Join.java","status":"modified","additions":18,"deletions":0,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Join.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Join.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Join.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -45,6 +45,8 @@\n     private int _subs;\n     private Joins _joins;\n     private boolean _inverse;\n+    private boolean _correlated = false;\n+    private boolean _isNotMyJoin = false;\n \n     /**\n      * Constructor for inner and outer joins.\n@@ -189,5 +191,21 @@ public Object clone() {\n             return null;\n         }\n     }\n+\n+    public boolean isCorrelated() {\n+        return _correlated;\n+    }\n+\n+    public void setCorrelated() {\n+        _correlated = true;\n+    }\n+\n+    public boolean isNotMyJoin() {\n+        return _isNotMyJoin;\n+    }\n+\n+    public void setIsNotMyJoin() {\n+        _isNotMyJoin = true;\n+    }\n }\n "},{"sha":"31b98e59bf1932443f937f6e05681e17ff9b572b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Joins.java","status":"modified","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Joins.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Joins.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Joins.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -21,6 +21,7 @@\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.kernel.exps.Context;\n \n /**\n  * Tracks joins made when traversing relations in a select.\n@@ -77,4 +78,28 @@ public Joins outerJoinRelation(String name, ForeignKey fk,\n      * Set the subquery alias.\n      */\n     public Joins setSubselect(String alias);\n+\n+    /**\n+     * Set subquery context when traversing into the next join is\n+     * in transition from parent context to subquery.\n+     * @param context\n+     */\n+    public Joins setJoinContext(Context context);\n+    \n+    /**\n+     * Set the correlated variable name being traversed into\n+     * with the next join.\n+     */\n+    public Joins setCorrelatedVariable(String var);\n+\n+    /**\n+     * Return correlated variable name\n+     * @return\n+     */\n+    public String getCorrelatedVariable();\n+\n+    /**\n+     * Move joins that belong to subquery's parent\n+     */\n+    public void moveJoinsToParent();\n }"},{"sha":"2d92d9e1b7c023bb4a7159fd5df3554350bd1258","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java","status":"modified","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/LogicalUnion.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -30,6 +30,7 @@\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.kernel.exps.Value;\n+import org.apache.openjpa.kernel.exps.Context;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n@@ -880,6 +881,18 @@ public void setExpectedResultCount(int expectedResultCount,\n             boolean force) {\n             sel.setExpectedResultCount(expectedResultCount, force);\n         }\n+\n+        public void setContext(Context context) {\n+            sel.setContext(context);\n+        }\n+\n+        public Context ctx() {\n+            return sel.ctx();\n+        }\n+\n+        public void setSchemaAlias(String schemaAlias) {\n+            sel.setSchemaAlias(schemaAlias);\n+        }\n     }\n \n     /**"},{"sha":"d7c70fd703e8f5878cb130597cc2ad4700097bb4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java","status":"modified","additions":18,"deletions":0,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/Select.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -30,6 +30,7 @@\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n import org.apache.openjpa.jdbc.schema.Table;\n import org.apache.openjpa.kernel.exps.Value;\n+import org.apache.openjpa.kernel.exps.Context;\n \n /**\n  * Abstraction of a SQL SELECT statement.\n@@ -701,4 +702,21 @@ public SelectExecutor eagerClone(FieldMapping key, int eagerType,\n      * Return the alias for the given column, without creating new table alias\n      */\n     public String getColumnAlias(Column col, Object path);\n+\n+    /**\n+     * Set JPQL query context for this select\n+     * @param context\n+     */\n+    public void setContext(Context context);\n+\n+    /**\n+     * Return the JPQL query context of this select\n+     */\n+    public Context ctx();\n+\n+    /**\n+     * Record the initial schemaAlias of a join path\n+     * @param schemaAlias\n+     */\n+    public void setSchemaAlias(String schemaAlias);\n }"},{"sha":"17391102a60cc47f38bbb167d91106c39c63f6a7","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","status":"modified","additions":340,"deletions":190,"changes":530,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -26,7 +26,6 @@\n import java.sql.Types;\n import java.util.AbstractList;\n import java.util.ArrayList;\n-import java.util.BitSet;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n@@ -56,6 +55,7 @@\n import org.apache.openjpa.jdbc.schema.Table;\n import org.apache.openjpa.kernel.StoreContext;\n import org.apache.openjpa.kernel.exps.Value;\n+import org.apache.openjpa.kernel.exps.Context;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.util.ApplicationIds;\n@@ -119,9 +119,6 @@\n     // 'parent.address.street' for the purposes of comparisons\n     private Map _aliases = null;\n \n-    // to cache table alias using Table as the key\n-    private Map _tableAliases = null;\n-\n     // map of indexes to table aliases like 'TABLENAME t0'\n     private SortedMap _tables = null;\n \n@@ -165,13 +162,12 @@\n     // from select if this select selects from a tmp table created by another\n     private SelectImpl _from = null;\n     protected SelectImpl _outer = null;\n-    \n-    // bitSet indicating if an alias is removed from parent select\n-    // bit 0 : correspond to alias 0\n-    // bit 1 : correspond to alias 1, etc.\n-    // if the bit is set, the corresponding alias has been removed from parent\n-    // and recorded under subselect.\n-    private BitSet _removedAliasFromParent = new BitSet(16);\n+\n+    // JPQL Query context this select is associated with\n+    private Context _ctx = null;\n+\n+    // A path navigation is begin with this schema alias\n+    private String _schemaAlias = null;\n      \n     /**\n      * Helper method to return the proper table alias for the given alias index.\n@@ -206,6 +202,21 @@ public SelectImpl(JDBCConfiguration conf) {\n         _selects._dict = _dict;\n     }\n \n+    public void setContext(Context context) {\n+        if (_ctx == null) {\n+            _ctx = context;\n+            _ctx.setSelect(this);\n+        }\n+    }\n+\n+    public Context ctx() {\n+        return _ctx;\n+    }\n+\n+    public void setSchemaAlias(String schemaAlias) {\n+        _schemaAlias = schemaAlias;\n+    }\n+\n     /////////////////////////////////\n     // SelectExecutor implementation\n     /////////////////////////////////\n@@ -521,7 +532,7 @@ public String getSubselectPath() {\n \n     public void setParent(Select parent, String path) {\n         if (path != null)\n-            _subPath = path + ':';\n+            _subPath = path;\n         else\n             _subPath = null;\n \n@@ -546,62 +557,6 @@ public void setParent(Select parent, String path) {\n             else\n                 _joinSyntax = _parent._joinSyntax;\n         }\n-        \n-        if (_parent.getAliases() == null || _subPath == null)\n-            return;\n-\n-        if (_parent._aliases.size() <= 1)\n-            return;\n-        // Do not remove aliases for databases that use SYNTAX_DATABASE (oracle)\n-        if(_parent._joinSyntax != JoinSyntaxes.SYNTAX_DATABASE) {\n-            // resolve aliases for subselect from parent\n-            Set<Map.Entry> entries = _parent.getAliases().entrySet();\n-            for (Map.Entry entry : entries) {\n-                Object key = entry.getKey();\n-                Integer alias = (Integer) entry.getValue();\n-                if (key.toString().indexOf(_subPath) != -1 ||\n-                    _parent.findTableAlias(alias) == false) {\n-                    if (_aliases == null)\n-                        _aliases = new HashMap();\n-                    _aliases.put(key, alias);\n-    \n-                    Object tableString = _parent.getTables().get(alias);\n-                    if (_tables == null)\n-                        _tables = new TreeMap();\n-                    _tables.put(alias, tableString);\n-                    \n-                    _removedAliasFromParent.set(alias.intValue());\n-                }\n-            }\n-            \n-            if (_aliases != null) {\n-                // aliases moved into subselect should be removed from parent\n-                entries = _aliases.entrySet();\n-                for (Map.Entry entry : entries) {\n-                    Object key = entry.getKey();\n-                    Integer alias = (Integer) entry.getValue();\n-                    if (key.toString().indexOf(_subPath) != -1 ||\n-                        _parent.findTableAlias(alias) == false) {\n-                        _parent.removeAlias(key);\n-    \n-                        Object tableString = _parent.getTables().get(alias);\n-                        _parent.removeTable(alias);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    \n-    private boolean findTableAlias(Integer alias) {\n-        // if alias is defined and referenced, return true.\n-        String value = \"t\" + alias.toString() + \".\";\n-        if (_tableAliases != null)\n-            if (_tableAliases.containsValue(value))\n-               return _tables.containsKey(alias);\n-           else\n-               return _joins != null;\n-        else\n-            return true;\n     }\n     \n     public Map getAliases() {\n@@ -773,17 +728,6 @@ else if (join.getTable2() == table)\n      * Return the alias for the given column.\n      */\n     private String getColumnAlias(String col, Table table, PathJoins pj) {\n-        String tableAlias = null;\n-        if (pj == null || pj.path() == null) {\n-            if (_tableAliases == null)\n-                _tableAliases = new HashMap();\n-            tableAlias = (String) _tableAliases.get(table);\n-            if (tableAlias == null) {\n-                tableAlias = getTableAlias(table, pj).toString();\n-                _tableAliases.put(table, tableAlias);\n-            }\n-            return new StringBuilder(tableAlias).append(col).toString();\n-        }\n         return getTableAlias(table, pj).append(col).toString();\n     }\n     \n@@ -1663,10 +1607,7 @@ else if (!pre) {\n             if ((_flags & OUTER) != 0)\n                 pj = (PathJoins) outer(pj);\n             if (record) {\n-                if (!pj.isEmpty())\n-                    removeParentJoins(pj);\n                 if (!pj.isEmpty()) {\n-                    removeJoinsFromSubselects(pj);\n                     if (_joins == null)\n                         _joins = new SelectJoins(this);\n                     if (_joins.joins() == null)\n@@ -1679,43 +1620,6 @@ else if (!pre) {\n         return pj;\n     }\n \n-    /**\n-     * Remove any joins already in our parent select from the given non-empty\n-     * join set.\n-     */\n-    private void removeParentJoins(PathJoins pj) {\n-        if (_parent == null)\n-            return;\n-        if (_parent._joins != null && !_parent._joins.isEmpty()) {\n-            boolean removed = false;\n-            if (!_removedAliasFromParent.isEmpty()) {\n-                for (Iterator itr = pj.joins().iterator(); itr.hasNext();) {\n-                   Join jn = (Join) itr.next();\n-                   if (_aliases.containsValue(jn.getIndex1()))\n-                       removed = _parent._joins.joins().remove(jn);\n-                }\n-            }\n-            if (!removed)\n-                pj.joins().removeAll(_parent._joins.joins());\n-        }\n-        if (!pj.isEmpty())\n-            _parent.removeParentJoins(pj);\n-    }\n-\n-    /**\n-     * Remove the given non-empty joins from the joins of our subselects.\n-     */\n-    private void removeJoinsFromSubselects(PathJoins pj) {\n-        if (_subsels == null)\n-            return;\n-        SelectImpl sub;\n-        for (int i = 0; i < _subsels.size(); i++) {\n-            sub = (SelectImpl) _subsels.get(i);\n-            if (sub._joins != null && !sub._joins.isEmpty())\n-                sub._joins.joins().removeAll(pj.joins());\n-        }\n-    }\n-\n     public SelectExecutor whereClone(int sels) {\n         if (sels < 1)\n             sels = 1;\n@@ -1732,6 +1636,7 @@ public SelectExecutor whereClone(int sels) {\n             sel._flags &= ~EAGER_TO_MANY;\n             sel._flags &= ~FORCE_COUNT;\n             sel._joinSyntax = _joinSyntax;\n+            sel._schemaAlias = _schemaAlias;\n             if (_aliases != null)\n                 sel._aliases = new HashMap(_aliases);\n             if (_tables != null)\n@@ -1888,6 +1793,8 @@ public Joins newOuterJoins() {\n     public void append(SQLBuffer buf, Joins joins) {\n         if (joins == null || joins.isEmpty())\n             return;\n+        if (_joinSyntax == JoinSyntaxes.SYNTAX_SQL92)\n+            return;\n \n         if (!buf.isEmpty())\n             buf.append(\" AND \");\n@@ -1915,6 +1822,10 @@ public Joins and(Joins joins1, Joins joins2) {\n         return and((PathJoins) joins1, (PathJoins) joins2, true);\n     }\n \n+    public Select getSelect() {\n+        return null;\n+    }\n+\n     /**\n      * Combine the given joins.\n      */\n@@ -1925,20 +1836,25 @@ private SelectJoins and(PathJoins j1, PathJoins j2, boolean nullJoins) {\n \n         SelectJoins sj = new SelectJoins(this);\n         if (j1 == null || j1.isEmpty()) {\n-            if (nullJoins)\n-                sj.setJoins(j2.joins());\n-            else\n-                sj.setJoins(new JoinSet(j2.joins()));\n+            if (j2.getSelect() == this) {\n+                if (nullJoins)\n+                    sj.setJoins(j2.joins());\n+                else\n+                    sj.setJoins(new JoinSet(j2.joins()));\n+            }\n         } else {\n-            JoinSet set;\n-            if (nullJoins)\n-                set = j1.joins();\n-            else\n-                set = new JoinSet(j1.joins());\n+            JoinSet set = null;\n+            if (j1.getSelect() == this) {\n+                if (nullJoins)\n+                    set = j1.joins();\n+                else\n+                    set = new JoinSet(j1.joins());\n \n-            if (j2 != null && !j2.isEmpty())\n-                set.addAll(j2.joins());\n-            sj.setJoins(set);\n+                if (j2 != null && !j2.isEmpty()\n+                    && j2.getSelect() == this)\n+                    set.addAll(j2.joins());\n+                sj.setJoins(set);\n+            }\n         }\n \n         // null previous joins; all are combined into this one\n@@ -2070,72 +1986,111 @@ private int getTableIndex(Table table, PathJoins pj, boolean create) {\n         if (_from != null)\n             return -1;\n \n+        Integer i = null;\n         Object key = table.getFullName();\n         if (pj != null && pj.path() != null)\n             key = new Key(pj.path().toString(), key);\n \n+        if (_ctx != null)\n+            i = findAliasForQuery(table, pj, key, create);\n+\n+        if (i != null)\n+            return i.intValue();\n+\n         // check out existing aliases\n-        Integer i = findAlias(table, key, false, null);\n+        i = findAlias(table, key);\n+\n         if (i != null)\n             return i.intValue();\n         if (!create)\n             return -1;\n \n         // not found; create alias\n-        i = Numbers.valueOf(aliasSize());\n+        i = Numbers.valueOf(aliasSize(null));\n+//        System.out.println(\"GetTableIndex\\t\"+\n+//                ((_parent != null) ? \"Sub\" :\"\") +\n+//                \" created alias: \"+\n+//                i.intValue()+ \" \"+ key);\n         recordTableAlias(table, key, i);\n         return i.intValue();\n     }\n \n-    /**\n-     * Attempt to find the alias for the given key.\n-     *\n-     * @param fromParent whether a parent is checking its subselects\n-     * @param fromSub the subselect checking its parent\n-     */\n-    private Integer findAlias(Table table, Object key, boolean fromParent,\n-        SelectImpl fromSub) {\n+    private Integer findAliasForQuery(Table table, PathJoins pj, Object key,\n+        boolean create) {\n+        Integer i = null;\n+        SelectImpl sel = this;\n+        String alias = _schemaAlias;\n+        if (isPathInThisContext(pj) || table.isAssociation())          \n+            alias = null;\n+\n+        // find the context where this alias is defined\n+        Context ctx = (alias != null) ?\n+            _ctx.findContext(alias) : null;\n+        if (ctx != null)\n+            sel = (SelectImpl) ctx.getSelect();\n+\n+        if (!create) \n+            i = sel.findAlias(table, key);  // find in parent and in myself\n+        else\n+            i = sel.getAlias(table, key); // find in myself\n+        if (i != null)\n+            return i;\n+        \n+        if (create) { // create here\n+            i = sel.createAlias(table, key);\n+        } else if (ctx != null && ctx != ctx()) { // create in other select\n+            i = ((SelectImpl)ctx.getSelect()).createAlias(table, key);\n+        }\n+\n+        return i;\n+    }\n+\n+    private boolean isPathInThisContext(PathJoins pj) {\n+        // currCtx is set from Action, it is reset to null after the PCPath initialization\n+        Context currCtx = pj == null ? null : ((PathJoinsImpl)pj).context;\n+        \n+        // lastCtx is set to currCtx after the SelectJoins.join. pj.lastCtx and pj.path string are \n+        // the last snapshot of pj. They will be used together for later table alias resolution in\n+        // the getColumnAlias(). \n+        Context lastCtx = pj == null ? null : ((PathJoinsImpl)pj).lastContext;\n+        Context thisCtx = currCtx == null ? lastCtx : currCtx;\n+        String corrVar = pj == null ? null : pj.getCorrelatedVariable();\n+        \n+        return (pj != null && pj.path() != null && \n+            (corrVar == null || (thisCtx != null && ctx() == thisCtx)));\n+    }\n+ \n+    private Integer getAlias(Table table, Object key) {\n+        Integer alias = null;\n+        if (_aliases != null)\n+            alias = (Integer) _aliases.get(key);\n+        return alias;\n+    }\n+\n+    private int createAlias(Table table, Object key) {\n+        Integer i = Numbers.valueOf(ctx().nextAlias());\n+//        System.out.println(\"\\t\"+\n+//                ((_parent != null) ? \"Sub\" :\"\") +\n+//                \"Query created alias: \"+ \n+//                i.intValue()+ \" \"+ key);\n+        recordTableAlias(table, key, i);\n+        return i.intValue();\n+    }\n+\n+    private Integer findAlias(Table table, Object key) {\n         Integer alias = null;\n         if (_aliases != null) {\n-            alias = (Integer) ((fromParent) ? _aliases.remove(key)\n-                : _aliases.get(key));\n+            alias = (Integer) _aliases.get(key);\n             if (alias != null) {\n-                if (fromParent)\n-                    _tables.remove(alias);\n                 return alias;\n             }\n         }\n-        if (!fromParent && _parent != null) {\n-            boolean removeAliasFromParent = key.toString().indexOf(\":\") != -1;\n-            alias = _parent.findAlias(table, key, removeAliasFromParent, this);\n+        if (_parent != null) {\n+            alias = _parent.findAlias(table, key);\n             if (alias != null) {\n-                if (removeAliasFromParent) {\n-                    recordTableAlias(table, key, alias);\n-                    _removedAliasFromParent.set(alias.intValue());\n-                }\n                 return alias;\n             }\n         }\n-        if (_subsels != null) {\n-            SelectImpl sub;\n-            for (int i = 0; i < _subsels.size(); i++) {\n-                sub = (SelectImpl) _subsels.get(i);\n-                if (sub == fromSub)\n-                    continue;\n-                if (alias != null) {\n-                    if (sub._aliases != null)\n-                        sub._aliases.remove(key);\n-                    if (sub._tables != null)\n-                        sub._tables.remove(alias);\n-                } else {\n-                    if (key instanceof String) {\n-                        alias = sub.findAlias(table, key, true, null);\n-                        if (!fromParent && alias != null)\n-                            recordTableAlias(table, key, alias);\n-                    }\n-                }\n-            }\n-        }\n         return alias;\n     }\n \n@@ -2157,26 +2112,16 @@ private void recordTableAlias(Table table, Object key, Integer alias) {\n     /**\n      * Calculate total number of aliases.\n      */\n-    private int aliasSize() {\n-        return aliasSize(false, null);\n-    }\n-\n-    /**\n-     * Calculate total number of aliases.\n-     *\n-     * @param fromParent whether a parent is checking its subselects\n-     * @param fromSub the subselect checking its parent\n-     */\n-    private int aliasSize(boolean fromParent, SelectImpl fromSub) {\n-        int aliases = (fromParent || _parent == null) ? 0\n-            : _parent.aliasSize(false, this);\n+    private int aliasSize(SelectImpl fromSub) {\n+        int aliases = (_parent == null) ? 0\n+            : _parent.aliasSize(this);\n         aliases += (_aliases == null) ? 0 : _aliases.size();\n         if (_subsels != null) {\n             SelectImpl sub;\n             for (int i = 0; i < _subsels.size(); i++) {\n                 sub = (SelectImpl) _subsels.get(i);\n                 if (sub != fromSub)\n-                    aliases += sub.aliasSize(true, null);\n+                    aliases += sub.aliasSize(null);\n             }\n         }\n         return aliases;\n@@ -2268,6 +2213,37 @@ public Joins setSubselect(String alias) {\n      */\n     private static class Placeholder {\n     }\n+    \n+    public void reset() {\n+        _aliases = null;\n+        _eager = null;\n+        _eagerKeys = null;\n+        _expectedResultCount = 0;\n+        _flags = 0;\n+        _from = null;\n+        _grouped = null;\n+        _grouping = null;\n+        _having = null;\n+        _joins = null;\n+        _joinSyntax = 0;\n+        _nullIds = 0;\n+        _ordered = null;\n+        _ordering = null;\n+        _orders = 0;\n+        _outer = null;\n+        _parent = null;\n+        _placeholders = 0;\n+        _preJoins = null;\n+        _schemaAlias = null;\n+        _selects._aliases = null;\n+        _selects._ids = null;\n+        _subPath = null;\n+        _subsels = null;\n+        _tables = null;\n+        _where = null;\n+        \n+    }\n+    \n \n     /**\n      * Key type used for aliases.\n@@ -2599,6 +2575,21 @@ public Joins setSubselect(String alias) {\n                 return this;\n             return new PathJoinsImpl().setSubselect(alias);\n         }\n+\n+        public Joins setCorrelatedVariable(String var) {\n+            return this;\n+        }\n+\n+        public Joins setJoinContext(Context ctx) {\n+            return this;\n+        }\n+\n+        public String getCorrelatedVariable() {\n+            return null;\n+        }\n+\n+        public void moveJoinsToParent() {\n+        }\n     }\n \n     /**\n@@ -2609,6 +2600,13 @@ public Joins setSubselect(String alias) {\n \n         protected StringBuffer path = null;\n         protected String var = null;\n+        protected String correlatedVar = null;\n+        protected Context context = null;\n+        protected Context lastContext = null;\n+\n+        public Select getSelect() {\n+            return null;\n+        }\n \n         public boolean isOuter() {\n             return false;\n@@ -2642,9 +2640,25 @@ public Joins setVariable(String var) {\n             return this;\n         }\n \n+        public String getVariable() {\n+            return var;\n+        }\n+        \n+        public Joins setCorrelatedVariable(String var) {\n+            this.correlatedVar = var;\n+            return this;\n+        }\n+        \n+        public String getCorrelatedVariable() {\n+            return correlatedVar;\n+        }\n+\n+        public Joins setJoinContext(Context context) {\n+            this.context = context;\n+            return this;\n+         }\n+\n         public Joins setSubselect(String alias) {\n-            if (!alias.endsWith(\":\"))\n-                alias += ':';\n             append(alias);\n             return this;\n         }\n@@ -2700,6 +2714,9 @@ public String toString() {\n             return \"PathJoinsImpl<\" + hashCode() + \">: \"\n                 + String.valueOf(path);\n         }\n+\n+        public void moveJoinsToParent() {\n+        }\n     }\n \n     /**\n@@ -2718,6 +2735,10 @@ public SelectJoins(SelectImpl sel) {\n             _sel = sel;\n         }\n \n+        public Select getSelect() {\n+            return _sel;\n+        }\n+\n         public boolean isOuter() {\n             return _outer;\n         }\n@@ -2778,9 +2799,14 @@ public Joins crossJoin(Table localTable, Table foreignTable) {\n             // until we get past the local table\n             String var = this.var;\n             this.var = null;\n+            Context ctx = context; \n+            context = null; \n \n             int alias1 = _sel.getTableIndex(localTable, this, true);\n             this.append(var);\n+            this.append(correlatedVar);\n+            context = ctx; \n+            \n             int alias2 = _sel.getTableIndex(foreignTable, this, true);\n             Join j = new Join(localTable, alias1, foreignTable, alias2,\n                 null, false);\n@@ -2789,7 +2815,10 @@ public Joins crossJoin(Table localTable, Table foreignTable) {\n             if (_joins == null)\n                 _joins = new JoinSet();\n             _joins.add(j);\n+            setCorrelated(j);\n             _outer = false;\n+            lastContext =  context;\n+            context = null;\n             return this;\n         }\n \n@@ -2817,6 +2846,8 @@ private Joins join(String name, ForeignKey fk, ClassMapping target,\n             // until we get past the local table\n             String var = this.var;\n             this.var = null;\n+            Context ctx = context; \n+            context = null; \n \n             // get first table alias before updating path; if there is a from\n             // select then we shouldn't actually create a join object, since\n@@ -2825,23 +2856,36 @@ private Joins join(String name, ForeignKey fk, ClassMapping target,\n             Table table1 = null;\n             int alias1 = -1;\n             if (createJoin) {\n+                boolean createIndex = true;\n                 table1 = (inverse) ? fk.getPrimaryKeyTable() : fk.getTable();\n-                alias1 = _sel.getTableIndex(table1, this, true);\n+                if (correlatedVar != null)\n+                    createIndex = false;  // not to create here\n+                alias1 = _sel.getTableIndex(table1, this, createIndex);\n             }\n \n             // update the path with the relation name before getting pk alias\n             this.append(name);\n             this.append(var);\n+            this.append(correlatedVar);\n+            context = ctx; \n+            \n             if (toMany) {\n                 _sel._flags |= IMPLICIT_DISTINCT;\n                 _sel._flags |= TO_MANY;\n             }\n             _outer = outer;\n \n             if (createJoin) {\n+                boolean createIndex = true;\n                 Table table2 = (inverse) ? fk.getTable() \n                     : fk.getPrimaryKeyTable();\n-                int alias2 = _sel.getTableIndex(table2, this, true);\n+                if (table2.isAssociation())\n+                    createIndex = true;\n+                else if (context == _sel.ctx()) \n+                   createIndex = true;\n+                else if (correlatedVar != null)\n+                    createIndex = false;\n+                int alias2 = _sel.getTableIndex(table2, this, createIndex);\n                 Join j = new Join(table1, alias1, table2, alias2, fk, inverse);\n                 j.setType((outer) ? Join.TYPE_OUTER : Join.TYPE_INNER);\n \n@@ -2850,10 +2894,91 @@ private Joins join(String name, ForeignKey fk, ClassMapping target,\n                 if (_joins.add(j) && (subs == Select.SUBS_JOINABLE \n                     || subs == Select.SUBS_NONE))\n                     j.setRelation(target, subs, clone(_sel));\n+\n+                setCorrelated(j);\n             }\n+            lastContext = context;\n+            context = null;\n             return this;\n         }\n \n+        private void setCorrelated(Join j) {\n+            if (_sel._parent == null)\n+                return;\n+\n+            if (_sel._aliases == null) {\n+                j.setIsNotMyJoin();\n+               return;\n+            }\n+\n+            Object aliases[] = _sel._aliases.values().toArray();\n+            boolean found1 = false;\n+            boolean found2 = false;\n+\n+            for (int i = 0; i < aliases.length; i++) {\n+                int alias = ((Integer)aliases[i]).intValue();\n+                if (alias == j.getIndex1())\n+                    found1 = true;\n+                if (alias == j.getIndex2())\n+                    found2 = true;\n+            }\n+                \n+            if (found1 && found2)\n+                return;\n+            else if (!found1 && !found2) {\n+                j.setIsNotMyJoin();\n+                return;\n+            }\n+            else {\n+                j.setCorrelated();\n+            }\n+        }\n+\n+        public void moveJoinsToParent() {\n+            if (_joins == null)\n+                return;\n+           Join j = null;\n+           List<Join> removed = new ArrayList<Join>(5);\n+           for (Iterator itr = _joins.iterator(); itr.hasNext();) {\n+               j = (Join) itr.next();\n+               if (j.isNotMyJoin()) {\n+                   addJoinsToParent(_sel._parent, j);\n+                   removed.add(j);\n+               }\n+           }\n+           for (Join join : removed) {\n+               _joins.remove(join);\n+           }\n+        }\n+\n+        private void addJoinsToParent(SelectImpl parent, Join join) {\n+            if (parent._aliases == null)\n+                return;\n+            Object aliases[] = parent._aliases.values().toArray();\n+            boolean found1 = false;\n+            boolean found2 = false;\n+\n+            for (int i = 0; i < aliases.length; i++) {\n+                int alias = ((Integer)aliases[i]).intValue();\n+                if (alias == join.getIndex1())\n+                    found1 = true;\n+                if (alias == join.getIndex2())\n+                    found2 = true;\n+            }\n+                \n+            if (found1 && found2) {\n+                // this is my join, add join\n+                if (parent._joins == null) \n+                    parent._joins = new SelectJoins(parent);\n+                SelectJoins p = parent._joins;\n+                if (p.joins() == null)\n+                    p.setJoins(new JoinSet());                \n+                p.joins().add(join);\n+            }\n+            else if (parent._parent != null)\n+                addJoinsToParent(parent._parent, join);\n+        }\n+\n         public SelectJoins clone(SelectImpl sel) {\n             SelectJoins sj = new SelectJoins(sel);\n             sj.var = var;\n@@ -3067,6 +3192,25 @@ public void clear() {\n             _idents = null;\n         }\n     }\n+\n+    public Joins setCorrelatedVariable(String var) {\n+        if (var == null)\n+            return this;\n+        return new SelectJoins(this).setCorrelatedVariable(var);\n+    }\n+    \n+    public Joins setJoinContext(Context ctx) {\n+        if (ctx == null)\n+            return this;\n+        return new SelectJoins(this).setJoinContext(ctx);\n+    }\n+\n+    public String getCorrelatedVariable() {\n+        return null;\n+    }\n+\n+    public void moveJoinsToParent() {\n+    }\n }\n \n /**\n@@ -3106,5 +3250,11 @@ public void clear() {\n      * Null the set of {@link Join} elements.\n      */\n     public void nullJoins();\n+\n+    /**\n+     * The select owner of this join\n+     * @return\n+     */\n+    public Select getSelect();\n }\n "},{"sha":"c1df80fccea77af1f8cbb42ebd2fb4fcf67eb8b2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","status":"modified","additions":30,"deletions":3,"changes":33,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/AbstractExpressionBuilder.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -169,10 +169,12 @@ protected Value getVariable(String id, boolean bind) {\n             type = TYPE_OBJECT;\n         else\n             meta = getMetaData(type, false);\n-        if (meta != null)\n+        if (meta != null) {\n             addAccessPath(meta);\n+            addSchemaToContext(id, meta);\n+        }\n \n-        Value var;\n+        Value var = null;\n         if (bind)\n             var = factory.newBoundVariable(id, type);\n         else\n@@ -182,6 +184,8 @@ protected Value getVariable(String id, boolean bind) {\n         if (_seenVars == null)\n             _seenVars = new HashMap<String,Value>();\n         _seenVars.put(id, var);\n+\n+        addVariableToContext(id, var);\n         return var;\n     }\n \n@@ -308,7 +312,7 @@ protected Value traversePath(Path path, String field, boolean pcOnly,\n             }\n         }\n \n-        if (meta != null || !pcOnly)\n+        if (meta != null || !pcOnly) \n             path.get(fmd, allowNull);\n \n         return path;\n@@ -521,5 +525,28 @@ protected static void setImplicitType(Value val, Class<?> expected) {\n      * Returns the current string being parsed; used for error messages.\n \t */\n \tprotected abstract String currentQuery ();\n+\n+    /**\n+     * Register the schema alias to the current JPQL query context.\n+     * @param alias\n+     * @param meta\n+     */\n+    protected abstract void addSchemaToContext(String alias,\n+        ClassMetaData meta);\n+\n+    /**\n+     * Register the variable associated with the schema alias (id) to\n+     * the current JPQL query context.\n+     * @param id\n+     * @param var\n+     */\n+    protected abstract void addVariableToContext(String id, Value var);\n+\n+    /**\n+     * Returns the variable associated with the schema alias (id).\n+     * @param id\n+     * @return\n+     */\n+    protected abstract Value getSeenVariable(String id);\n }\n "},{"sha":"16bccfe88c896df676efe012cd8e3afe046be58c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","status":"modified","additions":10,"deletions":0,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/CandidatePath.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -196,4 +196,14 @@ public void get(XMLMetaData meta, String name) {\n     public XMLMetaData getXmlMapping() {\n         return null;\n     }\n+\n+    public void setSchemaAlias(String schemaAlias) {\n+    }\n+\n+    public String getSchemaAlias() {\n+        return null;\n+    }\n+    \n+    public void setSubqueryContext(Context conext) {\n+    }\n }"},{"sha":"ae110e20b3bf3399ac5e2ba111da36d26e47f96d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Context.java","status":"added","additions":224,"deletions":0,"changes":224,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Context.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Context.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Context.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.kernel.exps;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.openjpa.kernel.jpql.JPQLExpressionBuilder.ParsedJPQL;\n+import org.apache.openjpa.meta.ClassMetaData;\n+\n+/**\n+ * JPQL / Criteria Query Context\n+ * @since 2.0\n+ *\n+ */\n+public class Context implements Serializable {\n+\n+    public final ParsedJPQL parsed;\n+    public ClassMetaData meta;\n+    public String schemaAlias;\n+    public Subquery subquery;\n+    public Expression from = null;\n+    private Context parent = null;\n+    private List<Context> subsels = null;\n+    private Object select = null;\n+    private int aliasCount = -1; \n+    private Map<String,Value> variables = new HashMap<String,Value>();\n+    private Map<String,ClassMetaData> schemas =\n+        new HashMap<String,ClassMetaData>();\n+\n+    public Context(ParsedJPQL parsed, Subquery subquery, Context parent) {\n+        this.parsed = parsed;\n+        this.subquery = subquery;\n+        this.parent = parent;\n+        if (subquery != null) {\n+            this.select = subquery.getSelect();\n+            parent.addSubselContext(this);\n+        }\n+    }\n+\n+    public void setSubquery(Subquery subquery) {\n+        this.subquery = subquery;\n+        this.select = subquery.getSelect();\n+        parent.addSubselContext(this);\n+    }\n+    \n+    public ClassMetaData meta() {\n+        return meta;\n+    }\n+\n+    public String schemaAlias() {\n+        return schemaAlias;\n+    }\n+\n+    public Subquery subquery() {\n+        return subquery;\n+    }\n+\n+    /**\n+     * Returns next table alias to be created.\n+     * @return\n+     */\n+    public int nextAlias() {\n+        Context p = this;\n+        while (p.subquery != null) {\n+            p = p.parent;\n+        }\n+        p.aliasCount++;\n+        return p.aliasCount;\n+    }\n+\n+    /**\n+     * Reset alias count for prepared query cache\n+     *\n+     */\n+    public void resetAliasCount() {\n+        Context p = this;\n+        while (p.subquery != null) {\n+            p = p.parent;\n+        }\n+        p.aliasCount = -1;\n+    }\n+\n+    /**\n+     * Register the select for this context.\n+     * @param select\n+     */\n+    public void setSelect(Object select) {\n+        this.select = select;\n+    }\n+\n+    /**\n+     * Returns the select associated with this context.\n+     * @return\n+     */\n+    public Object getSelect() {\n+        return select;\n+    }\n+\n+    /**\n+     * Register the subquery context in this context.\n+     * @param sub\n+     */\n+    private void addSubselContext(Context sub) {\n+        if (subsels == null)\n+            subsels = new ArrayList<Context>();\n+        subsels.add(sub);\n+    }\n+\n+    /**\n+     * Returns the subquery context.\n+     * @return\n+     */\n+    public List<Context> getSubselContexts() {\n+        return subsels;\n+    }\n+\n+    /**\n+     * Returns the subquery in this context.\n+     * @return\n+     */\n+    public Subquery getSubquery() {\n+        return subquery;\n+    }\n+\n+    public Context getParent() {\n+        return parent;\n+    }\n+\n+    public void setParent(Context parent) {\n+        this.parent = parent;\n+    }\n+\n+    public void addVariable(String id, Value var) {\n+        variables.put(id.toLowerCase(), var);\n+    }\n+\n+    public void addSchema(String id, ClassMetaData meta) {\n+        schemas.put(id.toLowerCase(), meta);\n+    }\n+\n+    public ClassMetaData getSchema(String id) {\n+        if (id != null)\n+            return schemas.get(id.toLowerCase());\n+        return null;\n+    }\n+\n+    /**\n+     * Given an alias and return its associated variable.\n+     * @param var\n+     * @return\n+     */\n+    public Value getVariable(String var) {\n+        Value variable = var == null ? null \n+            : variables.get(var.toLowerCase());\n+        return variable;\n+    }\n+\n+    /**\n+     * Given an alias find the context of its associated\n+     * variable where it is defined.\n+     * @param alias\n+     * @return\n+     */\n+    public Context findContext(String alias) {\n+        Value var = getVariable(alias);\n+        if (var != null)\n+            return this;\n+        for (Context p = parent; p != null; ) {\n+            var = p.getVariable(alias);\n+            if (var != null)\n+                return p;\n+            p = p.parent;\n+        }\n+        if (subsels != null) {\n+            for (Context subsel : subsels) {\n+                if (subsel != null) {\n+                    var = subsel.getVariable(alias);\n+                    if (var != null)\n+                        return subsel;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Given an alias find the variable in JPQL contexts.\n+     * @param alias\n+     * @return\n+     */\n+    public Value findVariable(String alias) {\n+        Value var = getVariable(alias);\n+        if (var != null)\n+            return var;\n+        for (Context p = parent; p != null; ) {\n+            var = p.getVariable(alias);\n+            if (var != null)\n+                return var;\n+            p = p.parent;\n+        }\n+        return null;\n+    }\n+}\n+"},{"sha":"face10d97a3fab6061191eb94316095f9e20ce6d","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Path.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -67,4 +67,15 @@\n      * @return Return xmlmapping\n      */\n     public XMLMetaData getXmlMapping();\n+\n+    /**\n+     * Set the schema alias (the identification variable)\n+     * this path is begin with.\n+     * @param schemaAlias\n+     */\n+    public void setSchemaAlias(String schemaAlias);\n+        \n+    public String getSchemaAlias();\n+    \n+    public void setSubqueryContext(Context context);\n }"},{"sha":"7f44cb940b42bab200450b91aa046bd600d282a5","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java","status":"modified","additions":19,"deletions":0,"changes":19,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/QueryExpressions.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -22,10 +22,12 @@\n import java.util.Collections;\n import java.util.LinkedHashMap;\n import java.util.Map;\n+import java.util.Stack;\n \n import org.apache.commons.collections.map.LinkedMap;\n import org.apache.openjpa.kernel.QueryOperations;\n import org.apache.openjpa.kernel.StoreQuery;\n+import org.apache.openjpa.kernel.exps.Context;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n \n@@ -69,8 +71,25 @@\n     public String[] fetchInnerPaths = StoreQuery.EMPTY_STRINGS;\n     public Value[] range = EMPTY_VALUES;\n     private Boolean _aggregate = null;\n+    private Stack<Context> _contexts = null;\n     public Object state;\n     \n+    /**\n+     * Set reference to the JPQL query contexts.\n+     * @param contexts\n+     */\n+    public void setContexts(Stack<Context> contexts) {\n+        _contexts = contexts;\n+    }\n+\n+    /**\n+     * Returns the current JPQL query context.\n+     * @return\n+     */\n+    public Context ctx() {\n+        return _contexts.peek();\n+    }\n+\n     /**\n      * Whether this is an aggregate results.\n      */"},{"sha":"1271cea907993e5ceca07d1c29efa7f83bd547c9","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/SubQ.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -41,6 +41,10 @@ public SubQ(String alias) {\n         _alias = alias;\n     }\n \n+    public Object getSelect() {\n+        return null;\n+    }\n+\n     public String getCandidateAlias() {\n         return _alias;\n     }"},{"sha":"abe16fe860a92b23298704e56803ae5fbc5032ff","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Subquery.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -36,4 +36,6 @@\n      * Set the parsed subquery.\n      */\n     public void setQueryExpressions(QueryExpressions query);\n+\n+    public Object getSelect();\n }"},{"sha":"8051062e74e2781c9ac0c214fa2bf403e335a500","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Val.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -135,4 +135,8 @@ public Value getSelectAs() {\n     public Path getPath() {\n         return null;\n     }\n+\n+    public String getName() {\n+        return null;\n+    }\n }"},{"sha":"77e707678eecf4777355cc089f164fc26a14cca1","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/exps/Value.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -90,4 +90,6 @@\n     public Value getSelectAs();\n \n     public Path getPath();\n+\n+    public String getName();\n }"},{"sha":"d72a00b936cb3c5c5f8d9c8ca5944963a531b046","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","status":"modified","additions":98,"deletions":43,"changes":141,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/jpql/JPQLExpressionBuilder.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -46,6 +46,7 @@\n import org.apache.openjpa.kernel.exps.Resolver;\n import org.apache.openjpa.kernel.exps.Subquery;\n import org.apache.openjpa.kernel.exps.Value;\n+import org.apache.openjpa.kernel.exps.Context;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.lib.util.Localizer.Message;\n import org.apache.openjpa.lib.log.Log;\n@@ -99,7 +100,7 @@ public JPQLExpressionBuilder(ExpressionFactory factory,\n             ? (ParsedJPQL) parsedQuery\n             : parsedQuery instanceof String\n             ? getParsedQuery((String) parsedQuery)\n-            : null, null));\n+            : null, null, null));\n \n         if (ctx().parsed == null)\n             throw new InternalException(parsedQuery + \"\");\n@@ -271,11 +272,15 @@ protected String currentQuery() {\n \n     QueryExpressions getQueryExpressions() {\n         QueryExpressions exps = new QueryExpressions();\n+        exps.setContexts(contexts);\n \n         evalQueryOperation(exps);\n \n         Expression filter = null;\n-        filter = and(evalFromClause(root().id == JJTSELECT), filter);\n+        Expression from = ctx().from;\n+        if (from == null)\n+            from = evalFromClause(root().id == JJTSELECT);\n+        filter = and(from, filter);\n         filter = and(evalWhereClause(), filter);\n         filter = and(evalSelectClause(exps), filter);\n \n@@ -413,7 +418,7 @@ private void evalOrderingClauses(QueryExpressions exps) {\n                 exps.ascending[i] = node.getChildCount() <= 1 ||\n                     lastChild(node).id == JJTASCENDING ? true : false;\n             }\n-            // check if order by selec item alias\n+            // check if order by select item result alias\n             for (int i = 0; i < ordercount; i++) {\n                 if (exps.orderingClauses[i] != null && \n                     !exps.orderingClauses[i].equals(\"\"))\n@@ -543,12 +548,15 @@ private Expression evalWhereClause() {\n     }\n \n     private Expression evalFromClause(boolean needsAlias) {\n-        Expression exp = null;\n-\n         // build up the alias map in the FROM clause\n         JPQLNode from = root().findChildByID(JJTFROM, false);\n         if (from == null)\n             throw parseException(EX_USER, \"no-from-clause\", null, null);\n+        return evalFromClause(from, needsAlias);\n+    }\n+\n+    private Expression evalFromClause(JPQLNode from, boolean needsAlias) {\n+        Expression exp = null;\n \n         for (int i = 0; i < from.children.length; i++) {\n             JPQLNode node = from.children[i];\n@@ -573,7 +581,7 @@ else if (node.id == JJTOUTERFETCHJOIN)\n \n     private Expression bindVariableForKeyPath(Path path, String alias,\n         Expression exp) {\n-        if (alias != null && !isSeendVariable(alias)) {\n+        if (alias != null && ctx().findVariable(alias) == null) {\n             // subquery may have KEY range over a variable \n             // that is not defined.\n             JPQLNode key = root().findChildByID(JJTKEY, true);\n@@ -584,6 +592,29 @@ private Expression bindVariableForKeyPath(Path path, String alias,\n         }\n         return exp;\n     }\n+\n+    private Expression getSubquery(String alias, Path path, Expression exp) {\n+        FieldMetaData fmd = path.last();\n+        ClassMetaData candidate = getFieldType(fmd);\n+        if (candidate == null && fmd.isElementCollection())\n+            candidate = fmd.getDefiningMetaData();\n+\n+        setCandidate(candidate, alias);\n+\n+        Context subContext = ctx();\n+        Subquery subquery = ctx().getSubquery();\n+        if (subquery == null){\n+            subquery = factory.newSubquery(candidate, true, alias);\n+            subContext.setSubquery(subquery);\n+        }\n+        Path subpath = factory.newPath(subquery);\n+        subpath.setMetaData(candidate);\n+        subquery.setMetaData(candidate);\n+        exp = bindVariableForKeyPath(path, alias, exp);\n+        exp =  and(exp, factory.equal(path, subpath));\n+        return exp;\n+    }\n+\n     /**\n      * Adds a join condition to the given expression.\n      *\n@@ -604,14 +635,8 @@ private Expression addJoin(JPQLNode node, boolean inner, Expression exp) {\n         JPQLNode alias = node.getChildCount() >= 2 ? right(node) : null;\n         // OPENJPA-15 support subquery's from clause do not start with \n         // identification_variable_declaration()\n-        if (inner && ctx().subquery != null && ctx().schemaAlias == null) {\n-            setCandidate(getFieldType(path.last()), alias.text);\n-\n-            Path subpath = factory.newPath(ctx().subquery);\n-            subpath.setMetaData(ctx().subquery.getMetaData());\n-            exp = bindVariableForKeyPath(path, alias.text, exp);\n-            exp =  and(exp, factory.equal(path, subpath));\n-            return exp;\n+        if (inner && ctx().getParent() != null && ctx().schemaAlias == null) {\n+            return getSubquery(alias.text, path, exp);\n         }\n \n         return addJoin(path, alias, exp);\n@@ -666,23 +691,13 @@ private Expression evalFromItem(Expression exp, JPQLNode node,\n         } else {\n             alias = right(node).text;\n             JPQLNode left = left(node);\n+            addSchemaToContext(alias, cmd);\n \n             // check to see if the we are referring to a path in the from\n             // clause, since we might be in a subquery against a collection\n             if (isPath(left)) {\n                 Path path = getPath(left);\n-                FieldMetaData fmd = path.last();\n-                ClassMetaData candidate = getFieldType(fmd);\n-\n-                if (candidate == null && fmd.isElementCollection())\n-                    candidate = fmd.getDefiningMetaData();\n-\n-                setCandidate(candidate, alias);\n-\n-                Path subpath = factory.newPath(ctx().subquery);\n-                subpath.setMetaData(ctx().subquery.getMetaData());\n-                exp = bindVariableForKeyPath(path, alias, exp);\n-                return and(exp, factory.equal(path, subpath));\n+                return getSubquery(alias, path, exp);\n             } else {\n                 // we have an alias: bind it as a variable\n                 Value var = getVariable(alias, true);\n@@ -764,8 +779,15 @@ protected Value getVariable(String id, boolean bind) {\n         return super.getVariable(id.toLowerCase(), bind);\n     }\n \n-    protected boolean isSeendVariable(String id) {\n-        return id != null && super.isSeenVariable(id.toLowerCase());\n+    protected Value getDefinedVariable(String id) {\n+        return ctx().getVariable(id);\n+    }\n+\n+    protected boolean isSeenVariable(String var) {\n+        Context c = ctx().findContext(var);\n+        if (c != null)\n+            return true;\n+        return false;\n     }\n \n     /**\n@@ -1181,7 +1203,11 @@ else if (node.getChildCount() == 2\n                 return eval(onlyChild(node));\n \n             case JJTCOUNT:\n-                return factory.count(getValue(lastChild(node)));\n+                JPQLNode c = lastChild(node);\n+                if (c.id == JJTIDENTIFIER)\n+                    // count(e)\n+                    return factory.count(getPath(node, false, true));\n+                return factory.count(getValue(c));\n \n             case JJTMAX:\n                 return factory.max(getNumberValue(onlyChild(node)));\n@@ -1392,12 +1418,22 @@ private Value getSubquery(JPQLNode node) {\n \n         // parse the subquery\n         ParsedJPQL parsed = new ParsedJPQL(node.parser.jpql, node);\n+        Context parent = ctx();\n+        Context subContext = new Context(parsed, null, ctx());\n+        contexts.push(subContext);\n+        subContext.setParent(parent);\n \n         ClassMetaData candidate = getCandidateMetaData(node);\n-        Subquery subq = factory.newSubquery(candidate, subclasses, alias);\n+        Subquery subq = subContext.getSubquery();\n+        if (subq == null) {\n+            subq = factory.newSubquery(candidate, subclasses, alias);\n+            subContext.setSubquery(subq);\n+        }\n         subq.setMetaData(candidate);\n-\n-        contexts.push(new Context(parsed, subq));\n+        \n+        // evaluate from clause for resolving variables defined in subquery\n+        JPQLNode from = node.getChild(1);\n+        subContext.from = evalFromClause(from, true);\n \n         try {\n             QueryExpressions subexp = getQueryExpressions();\n@@ -1506,7 +1542,14 @@ private Value getIdentifier(JPQLNode node) {\n         if (cmd != null) {\n             // handle the case where the class name is the alias\n             // for the candidate (we don't use variables for this)\n-            Value thiz = factory.getThis();\n+            Value thiz = null;\n+            if (ctx().subquery == null || \n+                ctx().getSchema(name.toLowerCase()) == null) {\n+                thiz = factory.getThis();\n+            } else {\n+                thiz = factory.newPath(ctx().subquery);\n+            }\n+            ((Path)thiz).setSchemaAlias(name);\n             thiz.setMetaData(cmd);\n             return thiz;\n         } else if (val instanceof Path) {\n@@ -1734,6 +1777,7 @@ private Path getPath(JPQLNode node, boolean pcOnly, boolean inner) {\n             if (ctx().subquery != null) {\n                 path = factory.newPath(ctx().subquery);\n                 path.setMetaData(ctx().subquery.getMetaData());\n+                factory.bindVariable(val, path);\n             } else {\n                 path = factory.newPath();\n                 path.setMetaData(ctx().meta);\n@@ -1748,6 +1792,8 @@ else if (val.getMetaData() != null)\n             throw parseException(EX_USER, \"path-invalid\",\n                 new Object[]{ assemble(node), name }, null);\n \n+        path.setSchemaAlias(name);\n+\n         // walk through the children and assemble the path\n         boolean allowNull = !inner;\n         for (int i = 1; i < node.children.length; i++) {\n@@ -1758,7 +1804,10 @@ else if (val.getMetaData() != null)\n             }\n             path = (Path) traversePath(path, node.children[i].text, pcOnly,\n                 allowNull);\n-\n+            if (ctx().getParent() != null && ctx().getVariable(path.getSchemaAlias()) == null) {\n+                path.setSubqueryContext(ctx());\n+            }\n+        \n             // all traversals but the first one will always be inner joins\n             allowNull = false;\n         }\n@@ -1902,17 +1951,23 @@ private ClassMetaData getMetaDataForAlias(String alias) {\n         return null;\n     }\n \n-    private class Context {\n+    protected void addSchemaToContext(String id, ClassMetaData meta) {\n+        ctx().addSchema(id.toLowerCase(), meta);    \n+    }\n \n-        private final ParsedJPQL parsed;\n-        private ClassMetaData meta;\n-        private String schemaAlias;\n-        private Subquery subquery;\n+    protected void addVariableToContext(String id, Value var) {\n+        ctx().addVariable(id, var);\n+    }\n \n-        Context(ParsedJPQL parsed, Subquery subquery) {\n-            this.parsed = parsed;\n-            this.subquery = subquery;\n-        }\n+    protected Value getSeenVariable(String var) {\n+        Context c = ctx();\n+        Value v = c.getVariable(var);\n+        if (v != null)\n+            return v;\n+        if (c.getParent() != null)\n+            return c.getParent().findVariable(var);\n+\n+        return null;\n     }\n \n     ////////////////////////////"},{"sha":"aa769afafdaf14d026f20de9abc9aa520b51fcb9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestSubquery.java","status":"modified","additions":20,"deletions":7,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestSubquery.java","raw_url":"https://github.com/apache/openjpa/raw/f74c5d7a69fb3dda67fb26c1c0250d48e29fe359/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestSubquery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/query/TestSubquery.java?ref=f74c5d7a69fb3dda67fb26c1c0250d48e29fe359","patch":"@@ -24,6 +24,7 @@\n import javax.persistence.EntityManager;\n import javax.persistence.Query;\n \n+import org.apache.openjpa.persistence.query.Customer.CreditRating;\n import org.apache.openjpa.persistence.test.SingleEMFTestCase;\n \n /**\n@@ -68,7 +69,7 @@ public void setUp() {\n             \" (select o from c.orders o where o.oid = 1) or exists\" +\n             \" (select o from c.orders o where o.oid = 2)\",\n         \"select c.name from Customer c, in(c.orders) o where o.amount \" +\n-        \"between\" +\n+            \"between\" +\n             \" (select max(o.amount) from Order o) and\" +\n             \" (select avg(o.amount) from Order o) \",\n         \"select o.oid from Order o where o.amount >\" +\n@@ -90,12 +91,12 @@ public void setUp() {\n             \"(SELECT MAX(m3.datePublished) \"+\n             \"FROM Magazine m3 \"+\n             \"WHERE m3.idPublisher.id = p.id)) \", \n-    // outstanding problem subqueries:\n-    // \"select o from Order o where o.amount > (select count(o) from Order o)\",\n-    // \"select o from Order o where o.amount > (select count(o2) from\n-    // Order o2)\",\n-    // \"select c from Customer c left join c.orders o where not exists\"\n-    //   + \" (select o2 from c.orders o2 where o2 = o)\",\n+        \"select o from Order o where o.amount > \" +\n+            \" (select count(o) from Order o)\",\n+        \"select o from Order o where o.amount > \" +\n+            \"(select count(o2) from Order o2)\",\n+        \"select c from Customer c left join c.orders o where not exists\"\n+         + \" (select o2 from c.orders o2 where o2 = o)\",\n     };\n \n     static String[]  querys_jpa20 = new String[] {        \n@@ -206,4 +207,16 @@ public void testSubSelectMaxDateRange() {\n         q.getResultList();\n         em.close();\n     }\n+\n+    public void testUpdateWithCorrelatedSubquery() {\n+        String update = \"update Customer c set c.creditRating = ?1 where EXISTS\" +\n+           \" (select o from  in(c.orders)  o)\";\n+        EntityManager em = emf.createEntityManager();\n+        em.getTransaction().begin();\n+        CreditRating creditRating = CreditRating.GOOD;\n+        int updateCount = em.createQuery(update).\n+            setParameter(1, creditRating).executeUpdate();\n+        em.getTransaction().rollback();\n+        em.close();\n+    }\n }"}]}

