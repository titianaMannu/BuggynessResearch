{"sha":"fadd48fe5b68577a3a75d86fb7e51746d6662c3b","node_id":"MDY6Q29tbWl0MjA2MzY0OmZhZGQ0OGZlNWI2ODU3N2EzYTc1ZDg2ZmI3ZTUxNzQ2ZDY2NjJjM2I=","commit":{"author":{"name":"Jeremy Bauer","email":"jrbauer@apache.org","date":"2010-01-15T19:38:18Z"},"committer":{"name":"Jeremy Bauer","email":"jrbauer@apache.org","date":"2010-01-15T19:38:18Z"},"message":"OPENJPA-1115  Remaining delimited identifiers support, including pluggable identifier utility.  Includes code and test contributions from Dianne Richards.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/trunk@899784 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"62fc417657eef38537e36fffe47dbe2953efd8c8","url":"https://api.github.com/repos/apache/openjpa/git/trees/62fc417657eef38537e36fffe47dbe2953efd8c8"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/fadd48fe5b68577a3a75d86fb7e51746d6662c3b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/fadd48fe5b68577a3a75d86fb7e51746d6662c3b","html_url":"https://github.com/apache/openjpa/commit/fadd48fe5b68577a3a75d86fb7e51746d6662c3b","comments_url":"https://api.github.com/repos/apache/openjpa/commits/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/comments","author":null,"committer":null,"parents":[{"sha":"7b53696e6e5162debf7d48d0f02940f5df15239e","url":"https://api.github.com/repos/apache/openjpa/commits/7b53696e6e5162debf7d48d0f02940f5df15239e","html_url":"https://github.com/apache/openjpa/commit/7b53696e6e5162debf7d48d0f02940f5df15239e"}],"stats":{"total":11176,"additions":8932,"deletions":2244},"files":[{"sha":"bbbacde0f14a62caeb96a2cffbee3e24f5f6fa86","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfiguration.java","status":"modified","additions":22,"deletions":1,"changes":23,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfiguration.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -21,6 +21,7 @@\n import javax.sql.DataSource;\n \n import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifierUtil;\n import org.apache.openjpa.jdbc.kernel.EagerFetchModes;\n import org.apache.openjpa.jdbc.kernel.LRSSizes;\n import org.apache.openjpa.jdbc.kernel.UpdateManager;\n@@ -31,6 +32,7 @@\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.SQLFactory;\n import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n import org.apache.openjpa.lib.jdbc.ConnectionDecorator;\n import org.apache.openjpa.lib.jdbc.JDBCEvent;\n import org.apache.openjpa.lib.jdbc.JDBCListener;\n@@ -592,7 +594,7 @@\n      * Return the non-enlisted data source to use. If there is a valid\n      * non-xa connection factory configured, then it will be returned. Its\n      * default user name and password on calls to\n-     * {@link DataSource#getConnection} will be the specificed connection 2\n+     * {@link DataSource#getConnection} will be the specified connection 2\n      * user name and password. If those are null and the given context is\n      * non-null, its user name password will be used instead. If the context\n      * is null too, then the user name and password used to retrieve the first\n@@ -602,4 +604,23 @@\n      * @see #getDataSource\n      */\n     public DataSource getDataSource2(StoreContext ctx);\n+    \n+    /**\n+     * Gets the String constant that matches the {@link IdentifierUtil}\n+     * @return String-based name of the {@link IdentifierUtil}\n+     */\n+    public String getIdentifierUtil();\n+\n+    /**\n+     * Gets the {@link DBIdentifierUtil}\n+     * @return DBIdentifierUtil\n+     */\n+    public DBIdentifierUtil getIdentifierUtilInstance();\n+    \n+    /**\n+     * Sets the {@link DBIdentifierUtil}\n+     * @param util instance of the identifier utility\n+     */\n+    public void setIdentifierUtil(DBIdentifierUtil util);\n+\n }"},{"sha":"cbf41ae6fd273ebdbe2d7282d2064cf181e3f8ef","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java","status":"modified","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/conf/JDBCConfigurationImpl.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -24,6 +24,7 @@\n \n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.conf.OpenJPAConfigurationImpl;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifierUtil;\n import org.apache.openjpa.jdbc.kernel.BatchingConstraintUpdateManager;\n import org.apache.openjpa.jdbc.kernel.BatchingOperationOrderUpdateManager;\n import org.apache.openjpa.jdbc.kernel.EagerFetchModes;\n@@ -47,6 +48,7 @@\n import org.apache.openjpa.lib.conf.ProductDerivations;\n import org.apache.openjpa.lib.conf.StringListValue;\n import org.apache.openjpa.lib.conf.StringValue;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n import org.apache.openjpa.lib.jdbc.ConnectionDecorator;\n import org.apache.openjpa.lib.jdbc.DecoratingDataSource;\n import org.apache.openjpa.lib.jdbc.JDBCListener;\n@@ -82,6 +84,7 @@\n     public ObjectValue mappingDefaultsPlugin;\n     public PluginValue driverDataSourcePlugin;\n     public MappingFactoryValue mappingFactoryPlugin;\n+    public ObjectValue identifierUtilPlugin;\n \n     // used internally\n     private String firstUser = null;\n@@ -331,6 +334,15 @@ public JDBCConfigurationImpl(boolean derivations, boolean loadGlobals) {\n         finderCachePlugin.setDynamic(true);\n         finderCachePlugin.setInstantiatingGetter(\"getFinderCacheInstance\");\n \n+        identifierUtilPlugin = addPlugin(\"jdbc.IdentifierUtil\", true);\n+        aliases = new String[] { \n+            \"default\", \"org.apache.openjpa.jdbc.identifier.DBIdentifierUtilImpl\" };\n+        identifierUtilPlugin.setAliases(aliases);\n+        identifierUtilPlugin.setDefault(aliases[0]);\n+        identifierUtilPlugin.setString(aliases[0]);\n+        identifierUtilPlugin.setInstantiatingGetter(\"getIdentifierUtilInstance\");\n+\n+        \n         // this static initializer is to get past a weird\n         // ClassCircularityError that happens only under IBM's\n         // JDK 1.3.1 on Linux from within the JRun ClassLoader;\n@@ -899,4 +911,19 @@ protected boolean isInvalidProperty(String propName) {\n                 return true; \n         return false;\n     }\n+    \n+    public String getIdentifierUtil() {\n+        return identifierUtilPlugin.getString();\n+    }\n+\n+    public DBIdentifierUtil getIdentifierUtilInstance() {\n+        if (identifierUtilPlugin.get() == null)\n+            identifierUtilPlugin.instantiate(DBIdentifierUtil.class, this);\n+        return (DBIdentifierUtil) identifierUtilPlugin.get();\n+    }\n+\n+    public void setIdentifierUtil(DBIdentifierUtil util) {\n+        identifierUtilPlugin.set(util);\n+    }\n+\n }"},{"sha":"1a7201dcada7b85e931ff7d41a9662801a0ccf7d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/ColumnDefIdentifierRule.java","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/ColumnDefIdentifierRule.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/ColumnDefIdentifierRule.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/ColumnDefIdentifierRule.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.identifier;\n+\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n+\n+/**\n+ * Default rule for column definition.  This rule disables delimiting of\n+ * column definitions.  Column definitions can be extremely tricky to \n+ * delimit correctly.  Blindly delimiting them causes failures on most\n+ * databases.  Where user defined types are concerned, generally they don't\n+ * need to be delimited and if so, they are more appropriately delimited\n+ * when they are specified.\n+ */\n+public class ColumnDefIdentifierRule extends DBIdentifierRule {\n+\n+    public ColumnDefIdentifierRule() {\n+        super();\n+        setName(DBIdentifierType.COLUMN_DEFINITION.toString());\n+        // Disable auto delimiting of column definition.\n+        setCanDelimit(false);\n+    }\n+}"},{"sha":"d629d165f0b98e0624beff2a4f39b4ffc9aef923","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DBIdentifier.java","status":"added","additions":911,"deletions":0,"changes":911,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DBIdentifier.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DBIdentifier.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DBIdentifier.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,911 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.identifier;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.lib.identifier.Identifier;\n+import org.apache.openjpa.lib.identifier.IdentifierImpl;\n+\n+/**\n+ * Encapsulates a database identifier.  With a few exceptions, this class is \n+ * intended to treated as immutable.  \n+ */\n+public class DBIdentifier extends IdentifierImpl implements Cloneable, Identifier, Serializable {\n+\n+    /**\n+     * Database identifier types.\n+     */\n+    public enum DBIdentifierType {\n+        DEFAULT,\n+        TABLE,\n+        SCHEMA,\n+        CATALOG,\n+        DATABASE,\n+        COLUMN,\n+        COLUMN_DEFINITION,\n+        SEQUENCE,\n+        CONSTRAINT,\n+        INDEX,\n+        FOREIGN_KEY,\n+        CONSTANT,\n+        NULL\n+    }\n+    \n+    // Array for quick compound identifier determination.  Compound identifiers\n+    // can have multi-part names, such as {schema, table} and should be stored\n+    // as a QualifiedDBIdentifier.\n+    private static boolean _compoundIdentifier[] = new boolean[DBIdentifierType.values().length];\n+    \n+    static {\n+        _compoundIdentifier[DBIdentifierType.TABLE.ordinal()] = true;\n+        _compoundIdentifier[DBIdentifierType.COLUMN.ordinal()] = true;\n+        _compoundIdentifier[DBIdentifierType.SEQUENCE.ordinal()] = true;\n+        _compoundIdentifier[DBIdentifierType.CONSTRAINT.ordinal()] = true;\n+        _compoundIdentifier[DBIdentifierType.INDEX.ordinal()] = true;\n+    }\n+    \n+    private DBIdentifierType _type = DBIdentifierType.DEFAULT;\n+    \n+    /**\n+     * Special NULL indicator for db identifiers.\n+     */\n+    public static final DBIdentifier NULL = new DBIdentifier(DBIdentifierType.NULL);\n+    \n+    // All constructors are protected or private.  Static factory operations\n+    // should be used to construct new identifiers.\n+    protected DBIdentifier() {\n+    }\n+\n+    private DBIdentifier(DBIdentifierType type) {\n+        setType(type);\n+    }\n+\n+    protected DBIdentifier(String name, DBIdentifierType type) {\n+        setType(type);\n+        setName(name);\n+    }\n+\n+    protected DBIdentifier(String name, DBIdentifierType type, boolean delimit) {\n+        setType(type);\n+        setName(name, delimit);\n+    }\n+    \n+    protected DBIdentifier(String name, boolean delimit) {\n+        setName(name, delimit);\n+    }\n+\n+\n+    /**\n+     * Set the name of the identifier.\n+     */\n+    public void setName(String name) {\n+        setName(name, false);\n+    }\n+\n+    /**\n+     * Set the name of this identifier based upon a given identifier.\n+     */\n+    public void setName(DBIdentifier name) {\n+        assertNotNull();\n+        if (DBIdentifier.isNull(name)) {\n+            setNameInternal(null);\n+            setType(name.getType());\n+            return;\n+        }\n+        setNameInternal(name.getNameInternal());\n+        setType(name.getType());\n+    }\n+\n+    /**\n+     * Set the name of the identifier and optionally force delimiting of the identifier. \n+     */\n+    public void setName(String name, boolean delimit) {\n+        assertNotNull();\n+        \n+        // Normalize the name, if necessary.  Do not normalize constants or column definitions.\n+        if (DBIdentifierType.CONSTANT != getType() && DBIdentifierType.COLUMN_DEFINITION != getType()) {\n+            if (delimit) {\n+                name = Normalizer.delimit(name, true);\n+             } else {\n+                 name = Normalizer.normalizeString(name);\n+             }\n+        }\n+        super.setName(name);\n+    }\n+    \n+    /**\n+     * Set the type of the identifier\n+     * @param type\n+     */\n+    protected void setType(DBIdentifierType type) {\n+        _type = type;\n+    }\n+\n+    /**\n+     * Get the identifier type\n+     * @return the identifier type\n+     */\n+    public DBIdentifierType getType() {\n+        return _type;\n+    }\n+    \n+\n+    /**\n+     * Splits a string delimited by the specified delimiter of a given name type\n+     * into an array of DBIdentifier objects.\n+     * Example:  COL1|\"COL 2\"|COL3  delim=| --> DBIdentifier[]{ COL1, \"COL 2\", COL3 }\n+     * @param name\n+     * @param id\n+     * @param delim\n+     * @return\n+     */\n+    public static DBIdentifier[] split(String name, DBIdentifierType id, String delim) {\n+        \n+        if (!Normalizer.canSplit(name, delim)) {\n+            return new DBIdentifier[] { new DBIdentifier(name, id) };\n+        }\n+        \n+        String[] names = Normalizer.splitName(name, delim);\n+        if (names.length == 0) {\n+            return new DBIdentifier[] { };\n+        }\n+        DBIdentifier[] sNames = new DBIdentifier[names.length];\n+        for (int i = 0; i < names.length ; i++) {\n+            sNames[i] = new DBIdentifier(names[i], id);\n+        }\n+        return sNames;\n+    }\n+    \n+    /**\n+     * Joins the list of identifiers using the appropriate delimiters and\n+     * returns a string based identifier.\n+     * @param resultId\n+     * @param names\n+     * @return\n+     */\n+    public static String join(DBIdentifier...names) {\n+        if (names == null || names.length == 0) {\n+            return null;\n+        }\n+        String[] strNames = new String[names.length];\n+        for (int i = 0; i < names.length; i++) {\n+            strNames[i] = names[i].getNameInternal();\n+        }\n+        return Normalizer.joinNames(strNames);\n+    }\n+    /**\n+     * Splits a given DBIdentifier into multiple DBIdentifiers.  Uses the base name \n+     * type and heuristics to determine the types and placement of the resulting\n+     * components.\n+     * @param name\n+     * @return\n+     */\n+    public static DBIdentifier[] split(DBIdentifierType resultType, String name) {\n+        \n+        String[] names = Normalizer.splitName(name);\n+        switch (names.length) {\n+            case 2:\n+                return getTwoPartIdentifier(names, resultType);\n+            case 3:\n+                return getThreePartIdentifier(names, resultType);\n+            case 4:\n+                return getFourPartIdentifier(names, resultType);\n+            default:\n+                return new DBIdentifier[] { new DBIdentifier(name, resultType) };\n+        }\n+    }\n+\n+    /*\n+     * Returns a two-part identifier based upon the base identifier type.\n+     */\n+    private static DBIdentifier[] getTwoPartIdentifier(String[] names, DBIdentifierType baseId) {\n+        DBIdentifier[] sNames = new DBIdentifier[2];\n+        DBIdentifierType id0 = DBIdentifierType.DEFAULT;\n+        DBIdentifierType id1 = baseId;\n+        if (baseId != DBIdentifierType.COLUMN &&\n+                baseId != DBIdentifierType.SCHEMA) {\n+            id0 = DBIdentifierType.SCHEMA;\n+        }\n+        else if (baseId == DBIdentifierType.COLUMN) {\n+            // Length 2, base name column\n+            id0 = DBIdentifierType.TABLE;\n+        }\n+        else if (baseId == DBIdentifierType.SCHEMA) {\n+            id0 = DBIdentifierType.DATABASE;\n+        }\n+        sNames[0] = new DBIdentifier(names[0], id0);\n+        sNames[1] = new DBIdentifier(names[1], id1);\n+        return sNames;\n+    }\n+\n+    /*\n+     * Returns a three-part identifier based upon the base identifier type.\n+     */\n+    private static DBIdentifier[] getThreePartIdentifier(String[] names, DBIdentifierType baseId) {\n+        DBIdentifier[] sNames = new DBIdentifier[3];\n+        DBIdentifierType id0 = DBIdentifierType.DEFAULT;\n+        DBIdentifierType id1 = DBIdentifierType.DEFAULT;\n+        DBIdentifierType id2 = baseId;\n+        if (baseId != DBIdentifierType.SCHEMA &&\n+            baseId != DBIdentifierType.COLUMN) {\n+            id0 = DBIdentifierType.DATABASE;\n+            id1 = DBIdentifierType.SCHEMA;\n+        }\n+        else if (baseId == DBIdentifierType.COLUMN) {\n+            // Length 2, base name column\n+            id0 = DBIdentifierType.SCHEMA;\n+            id1 = DBIdentifierType.TABLE;\n+        }\n+        sNames[0] = new DBIdentifier(names[0], id0);\n+        sNames[1] = new DBIdentifier(names[1], id1);\n+        sNames[2] = new DBIdentifier(names[2], id2);\n+        return sNames;\n+    }\n+\n+    /*\n+     * Returns a four-part identifier based upon the base identifier type.\n+     */\n+    private static DBIdentifier[] getFourPartIdentifier(String[] names, DBIdentifierType baseId) {\n+        DBIdentifier[] sNames = new DBIdentifier[4];\n+        DBIdentifierType id0 = DBIdentifierType.DEFAULT;\n+        DBIdentifierType id1 = DBIdentifierType.DEFAULT;\n+        DBIdentifierType id2 = DBIdentifierType.DEFAULT;\n+        DBIdentifierType id3 = baseId;\n+        if (baseId == DBIdentifierType.COLUMN) {\n+            id0 = DBIdentifierType.DATABASE;\n+            id1 = DBIdentifierType.SCHEMA;\n+            id2 = DBIdentifierType.TABLE;\n+        }\n+        sNames[0] = new DBIdentifier(names[0], id0);\n+        sNames[1] = new DBIdentifier(names[1], id1);\n+        sNames[2] = new DBIdentifier(names[2], id2);\n+        sNames[3] = new DBIdentifier(names[3], id3);\n+        return sNames;\n+    }\n+\n+    /**\n+     * Returns true if the identifier is null or the name is null or empty.\n+     * @param name\n+     * @return\n+     */\n+    public static boolean isEmpty(DBIdentifier name) {\n+        if (isNull(name)) {\n+            return true;\n+        }\n+        return StringUtils.isEmpty(name.getName());\n+    }\n+\n+    \n+    /**\n+     * Returns true if the identifier is null.\n+     * @param name\n+     * @return\n+     */\n+    public static boolean isNull(DBIdentifier name) {\n+        return (name == null || name.getType() == DBIdentifierType.NULL);\n+    }\n+\n+    /**\n+     * Clones an identifier using deep copy.\n+     */\n+    public DBIdentifier clone() {\n+        DBIdentifier sName = new DBIdentifier();\n+        sName.setNameInternal(getNameInternal());\n+        sName.setType(getType());\n+        return sName;\n+    }\n+    \n+    /*\n+     * Internal method to set the base name and avoid normalizing an already \n+     * normalized name.\n+     * @param name\n+     */\n+    private void setNameInternal(String name) {\n+        super.setName(name);\n+    }\n+\n+    /*\n+     * Internal method to get the base name. \n+     * normalized name.\n+     * @param name\n+     */\n+    private String getNameInternal() {\n+        return super.getName();\n+    }\n+\n+    /**\n+     * Returns a copy of an identifier with name trimmed to null.\n+     * @param name\n+     * @return\n+     */\n+    public static DBIdentifier trimToNull(DBIdentifier name) {\n+        if (DBIdentifier.isNull(name)) {\n+            return name;\n+        }\n+        DBIdentifier sName = name.clone();\n+        sName.setNameInternal(StringUtils.trimToNull(sName.getNameInternal()));\n+        return sName;\n+    }\n+\n+    /**\n+     * Equality operation for identifiers.  Supports comparison with strings\n+     * and objects of this type.\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof DBIdentifier) {\n+            DBIdentifier sName = (DBIdentifier)obj;\n+            return this.equals(sName, false);\n+        } else if (obj instanceof String) {\n+            return obj.equals(this.getNameInternal());\n+        }\n+        throw new IllegalArgumentException(\"Unsupported type comparison: \" + obj.getClass().getName());\n+    }\n+\n+    /**\n+     * Returns true if this object is NULL or has a null name component.\n+     * @return\n+     */\n+    public boolean isNull() {\n+        return (_type == DBIdentifierType.NULL || getName() == null);\n+    }\n+\n+    /**\n+     * Comparison operator for identifiers.\n+     */\n+    public int compareTo(Identifier o) {\n+        if (o instanceof DBIdentifier) {\n+            if (this == DBIdentifier.NULL && (o == null || o == DBIdentifier.NULL)) {\n+                return 0;\n+            }\n+            if (this == DBIdentifier.NULL)\n+                return 1;\n+            if (o == null || o == DBIdentifier.NULL)\n+                return -1;\n+        }\n+        return super.compareTo(o);\n+    }\n+    \n+\n+    /**\n+     * Converts the provided set of names to an array of identifiers of the \n+     * provided type\n+     * @param columnNames\n+     * @param id\n+     * @return\n+     */\n+    public static DBIdentifier[] toArray(String[] columnNames, DBIdentifierType id) {\n+        return toArray(columnNames, id, false);\n+    }\n+\n+    /**\n+     * Converts the provided set of names to an array of identifiers of the \n+     * provided type, optionally delimiting the names.\n+     * @param columnNames\n+     * @param id\n+     * @return\n+     */\n+    public static DBIdentifier[] toArray(String[] names, DBIdentifierType id, boolean delimit) {\n+        if (names == null) {\n+            return null;\n+        }\n+        DBIdentifier[] sNames = new DBIdentifier[names.length];\n+        for (int i = 0; i < names.length; i++) {\n+            sNames[i] = new DBIdentifier(names[i], id, delimit);\n+        }\n+        return sNames;\n+    }\n+    \n+    /**\n+     * Returns a string array of names based upon the provided set of identifiers.\n+     * @param sNames\n+     * @return\n+     */\n+    public static String[] toStringArray(DBIdentifier[] sNames) {\n+        if (sNames == null) {\n+            return null;\n+        }\n+        String[] names = new String[sNames.length];\n+        for (int i = 0; i < sNames.length; i++) {\n+            names[i] = sNames[i].getName();\n+        }\n+        return names;\n+    }\n+\n+    /**\n+     * Constructs a new identifier of type Catalog.\n+     */\n+    public static DBIdentifier newCatalog(String name) {\n+        return newIdentifier(name, DBIdentifierType.CATALOG);\n+    }\n+\n+    /**\n+     * Constructs a new identifier of type Catalog ,optionally delimiting\n+     * the name.\n+     */\n+    public static DBIdentifier newCatalog(String name, boolean delimit) {\n+        return newIdentifier(name, DBIdentifierType.CATALOG, false, delimit);\n+    }\n+    \n+    /**\n+     * Constructs a new identifier of type Table.\n+     */\n+    public static DBIdentifier newTable(String name) {\n+        return newIdentifier(name, DBIdentifierType.TABLE);\n+    }\n+\n+    /**\n+     * Constructs a new identifier of type Table, optionally delimiting\n+     * the name.\n+     */\n+    public static DBIdentifier newTable(String name, boolean delimit) {\n+        return newIdentifier(name, DBIdentifierType.TABLE, false, delimit);\n+    }\n+    \n+    /**\n+     * Constructs a new identifier of type Column.\n+     */\n+    public static DBIdentifier newColumn(String name) {\n+        return newIdentifier(name, DBIdentifierType.COLUMN);\n+    }\n+\n+    /**\n+     * Constructs a new identifier of type Column,optionally delimiting\n+     * the name.\n+     */\n+    public static DBIdentifier newColumn(String name, boolean delimit) {\n+        return newIdentifier(name, DBIdentifierType.COLUMN, false, delimit);\n+    }\n+\n+    /**\n+     * Constructs a new identifier of type Schema.\n+     */\n+    public static DBIdentifier newSchema(String name) {\n+        return newIdentifier(name, DBIdentifierType.SCHEMA);\n+    }\n+\n+    /**\n+     * Constructs a new identifier of type Schema, optionally delimiting\n+     * the name.\n+     */\n+    public static DBIdentifier newSchema(String name, boolean delimit) {\n+        return newIdentifier(name, DBIdentifierType.SCHEMA, false, delimit);\n+    }\n+\n+    /**\n+     * Constructs a new identifier of type Index.\n+     */\n+    public static DBIdentifier newIndex(String name) {\n+        return newIdentifier(name, DBIdentifierType.INDEX);\n+    }\n+\n+    /**\n+     * Constructs a new identifier of type Index, optionally delimiting\n+     * the name.\n+     */\n+    public static DBIdentifier newIndex(String name, boolean delimit) {\n+        return newIdentifier(name, DBIdentifierType.INDEX, false, delimit);\n+    }\n+\n+    /**\n+     * Constructs a new identifier of type Sequence.\n+     */\n+    public static DBIdentifier newSequence(String name) {\n+        return newIdentifier(name, DBIdentifierType.SEQUENCE);\n+    }\n+\n+    /**\n+     * Constructs a new identifier of type Sequence, optionally delimiting\n+     * the name.\n+     */\n+    public static DBIdentifier newSequence(String name, boolean delimit) {\n+        return newIdentifier(name, DBIdentifierType.SEQUENCE, false, delimit);\n+    }\n+\n+    /**\n+     * Constructs a new identifier of type ForeignKey.\n+     */\n+    public static DBIdentifier newForeignKey(String name) {\n+        return newIdentifier(name, DBIdentifierType.FOREIGN_KEY);\n+    }\n+\n+    /**\n+     * Constructs a new identifier of type ForeignKey, optionally delimiting\n+     * the name.\n+     */\n+    public static DBIdentifier newForeignKey(String name, boolean delimit) {\n+        return newIdentifier(name, DBIdentifierType.FOREIGN_KEY, false, delimit);\n+    }\n+\n+    /**\n+     * Constructs a new identifier of type Constraint.\n+     */\n+    public static DBIdentifier newConstraint(String name) {\n+        return newIdentifier(name, DBIdentifierType.CONSTRAINT);\n+    }\n+\n+    /**\n+     * Constructs a new identifier of type Constraint, optionally delimiting\n+     * the name.\n+     */\n+    public static DBIdentifier newConstraint(String name, boolean delimit) {\n+        return newIdentifier(name, DBIdentifierType.CONSTRAINT, false, delimit);\n+    }\n+\n+    /**\n+     * Constructs a new identifier of type Constant.\n+     */\n+    public static DBIdentifier newConstant(String name) {\n+        return newIdentifier(name, DBIdentifierType.CONSTANT);\n+    }\n+\n+    /**\n+     * Constructs a new identifier of type Column Definition.\n+     */\n+    public static DBIdentifier newColumnDefinition(String name) {\n+        return newIdentifier(name, DBIdentifierType.COLUMN_DEFINITION);\n+    }\n+\n+    /**\n+     * Constructs a new identifier of type Default.\n+     */\n+    public static DBIdentifier newDefault(String name) {\n+        return newIdentifier(name, DBIdentifierType.DEFAULT);\n+    }\n+\n+    /**\n+     * Constructs a new identifier with the provided name and type\n+     */\n+    protected static DBIdentifier newIdentifier(String name, DBIdentifierType id) {\n+        return newIdentifier(name, id, false, false);\n+    }\n+\n+    /**\n+     * Constructs a new identifier with the provided name an type. Optionally,\n+     * converting the name to upper case.\n+     */\n+    public static DBIdentifier newIdentifier(String name, DBIdentifierType id, boolean toUpper) {\n+        return newIdentifier(name, id, toUpper, false );\n+    }\n+\n+    /**\n+     * Constructs a new identifier (potentially a compound QualifiedDBIdentifier) with the provided \n+     * name an type. Optionally, converting the name to upper case and delimiting it.\n+     */\n+    protected static DBIdentifier newIdentifier(String name, DBIdentifierType id, boolean toUpper, boolean delimit) {\n+        if (name == null) {\n+            return DBIdentifier.NULL;\n+        }\n+        \n+        DBIdentifier dbId = DBIdentifier.NULL;\n+        // Create a DBIDentifier for single component names.  Otherwise, create a QualifiedDBIdentifier.\n+        if (!_compoundIdentifier[id.ordinal()] || delimit) {\n+            dbId = new DBIdentifier(name, id, delimit);\n+            if (toUpper) {\n+                return toUpper(dbId);\n+            }\n+        } else {\n+            // Name can be split. Break it up into components and return a path\n+            DBIdentifier[] sNames = DBIdentifier.split(id, name);\n+            dbId = new QualifiedDBIdentifier(sNames);\n+        }\n+        return dbId;\n+    }\n+\n+    /**\n+     * Static equality method for comparing two identifiers.\n+     * @param name1\n+     * @param name2\n+     * @return\n+     */\n+    public static boolean equal(DBIdentifier name1, DBIdentifier name2) {\n+        boolean name1Null = DBIdentifier.isNull(name1);\n+        if (name1Null && DBIdentifier.isNull(name2)) {\n+            return true;\n+        }\n+        if (name1Null) {\n+            return false;\n+        }\n+        return ((DBIdentifier)name1).equals(name2, false);\n+    }\n+\n+    \n+    private void assertNotNull() {\n+        if (this == DBIdentifier.NULL || getType() == DBIdentifierType.NULL) {\n+            throw new IllegalStateException(\"Cannot modify NULL instance\");\n+        }\n+    }\n+    \n+    /**\n+     * Returns a new DBIdentifier truncated to length\n+     * @param name\n+     * @param length\n+     * @return\n+     */\n+    public static DBIdentifier truncate(DBIdentifier name, int length) {\n+        DBIdentifier sName = name.clone();\n+        String strName = sName.getNameInternal();\n+        if (StringUtils.isEmpty(strName)) {\n+            return sName;\n+        }\n+        strName = Normalizer.truncate(strName, length);\n+        sName.setNameInternal(strName);\n+        return sName;\n+    }\n+\n+    /**\n+     * Returns a new DBIdentifier with the given string appended.\n+     * @param name\n+     * @param length\n+     * @return\n+     */\n+    public static DBIdentifier append(DBIdentifier name, String str) {\n+        DBIdentifier sName = name.clone();\n+        String strName = sName.getNameInternal();\n+        strName = Normalizer.append(strName, str);\n+        sName.setNameInternal(strName);\n+        return sName;\n+    }\n+\n+    /**\n+     * Returns a new DBIdentifier with the given string combined using \n+     * delimiting rules and appropriate separators.\n+     * @param name\n+     * @param length\n+     * @return\n+     */\n+    public static DBIdentifier combine(DBIdentifier name, String str) {\n+        DBIdentifier sName = name.clone();\n+        String strName = sName.getNameInternal();\n+        strName = Normalizer.combine(strName, str);\n+        sName.setNameInternal(strName);\n+        return sName;\n+    }\n+\n+    /**\n+     * Returns a new DBIdentifier converted to lower case - if not delimited.\n+     * @param name\n+     * @return\n+     */\n+    public static DBIdentifier toLower(DBIdentifier name) {\n+        return toLower(name, false);\n+    }\n+    \n+    /**\n+     * Returns a new DBIdentifier converted to lower case.  If delimited,\n+     * force to lower case using force option.\n+     * @param name\n+     * @return\n+     */\n+    public static DBIdentifier toLower(DBIdentifier name, boolean force) {\n+        if (DBIdentifier.isNull(name)) {\n+            return name;\n+        }\n+        DBIdentifier sName = name.clone();\n+        if (sName.getNameInternal() == null) {\n+            return sName;\n+        }\n+        // Do not convert delimited names to lower case.  They may have\n+        // been delimited to preserve case.\n+        if (force || !Normalizer.isDelimited(sName.getNameInternal())) {\n+            sName.setNameInternal(sName.getNameInternal().toLowerCase());\n+        }\n+        return sName;\n+    }\n+\n+    /**\n+     * Returns a new DBIdentifier converted to upper case - if not delimited.\n+     * @param name\n+     * @return\n+     */\n+    public static DBIdentifier toUpper(DBIdentifier name) {\n+        return toUpper(name, false);\n+    }\n+\n+    /**\n+     * Returns a new DBIdentifier converted to upper case.  If delimited,\n+     * force to upper case using force option.\n+     * @param name\n+     * @return\n+     */\n+    public static DBIdentifier toUpper(DBIdentifier name, boolean force) {\n+        if (DBIdentifier.isNull(name)) {\n+            return name;\n+        }\n+        DBIdentifier sName = name.clone();\n+        if (sName.getNameInternal() == null) {\n+            return sName;\n+        }\n+        // Do not convert delimited names to upper case.  They may have\n+        // been delimited to preserve case.\n+        if (force || !Normalizer.isDelimited(sName.getNameInternal())) {\n+            sName.setNameInternal(sName.getNameInternal().toUpperCase());\n+        }\n+        return sName;\n+    }\n+\n+    /**\n+     * Returns a new DBIdentifier with the specified leading string removed.\n+     * @param name\n+     * @return\n+     */\n+    public static DBIdentifier removeLeading(DBIdentifier name, String leadingStr) {\n+        DBIdentifier sName = name.clone();\n+        if (isEmpty(sName)) {\n+            return sName;\n+        }\n+        String strName = sName.getNameInternal();\n+        int leadingLen = leadingStr.length();\n+        while (strName.startsWith(leadingStr)) {\n+            strName = strName.substring(leadingLen);\n+        }\n+        sName.setNameInternal(strName);\n+        return sName;\n+    }\n+    \n+    /**\n+     * Returns a new DBIdentifier with Hungarian notation removed.\n+     * @param name\n+     * @return\n+     */\n+    public static DBIdentifier removeHungarianNotation(DBIdentifier name) {\n+        DBIdentifier hName = name.clone();\n+        if (isEmpty(hName)) {\n+            return hName;\n+        }\n+        String strName = hName.getNameInternal();\n+        strName = Normalizer.removeHungarianNotation(strName);\n+        hName.setNameInternal(strName);\n+        return hName;\n+    }\n+\n+    /**\n+     * Equality operator which ignores case.\n+     * @param name\n+     * @return\n+     */\n+   public boolean equalsIgnoreCase(DBIdentifier name) {\n+       return equals(name, true);\n+   }\n+\n+   /**\n+    * Static equality operator which ignores case.\n+    * @param name\n+    * @return\n+    */\n+    public static boolean equalsIgnoreCase(DBIdentifier name1, DBIdentifier name2) {\n+        boolean name1Null = DBIdentifier.isNull(name1);\n+        if (name1Null && DBIdentifier.isNull(name2)) {\n+            return true;\n+        }\n+        if (name1Null) {\n+            return false;\n+        }\n+        return name1.equals(name2, true);\n+    }\n+\n+    private boolean equals(DBIdentifier sName, boolean ignoreCase) {\n+        if (sName.getNameInternal() == null && getNameInternal() == null) {\n+            return true;\n+        }\n+        if (getNameInternal() == null) {\n+            return false;\n+        }\n+        if (ignoreCase || !Normalizer.isDelimited(getNameInternal())) {\n+            return getNameInternal().equalsIgnoreCase(sName.getNameInternal());\n+        }\n+        return getNameInternal().equals(sName.getNameInternal());\n+    }\n+\n+    /**\n+     * Returns a new identifier with a combined prefix and name using the standard name\n+     * concatenation character ('_').\n+     * @param prefix\n+     */\n+    public static DBIdentifier preCombine(DBIdentifier name, String prefix) {\n+        if (DBIdentifier.isNull(name)) {\n+            return name;\n+        }\n+        DBIdentifier sName = name.clone();\n+        String strName = sName.getNameInternal();\n+        strName = Normalizer.combine(prefix, strName);\n+        sName.setNameInternal(strName);\n+        return sName;\n+    }\n+\n+    /**\n+     * Returns a new identifier with delimiters removed.\n+     * @param name\n+     * @return\n+     */\n+    public static DBIdentifier removeDelimiters(DBIdentifier name) {\n+        if (DBIdentifier.isNull(name)) {\n+            return name;\n+        }\n+        DBIdentifier sName = name.clone();\n+        if (isEmpty(sName)) {\n+            return sName;\n+        }\n+        String strName = sName.getNameInternal();\n+        strName = Normalizer.removeDelimiters(strName);\n+        sName.setNameInternal(strName);\n+        return sName;\n+    }\n+\n+    /**\n+     * Returns a new delimiter with leading and trailing spaces removed.\n+     * @param name\n+     * @return\n+     */\n+    public static DBIdentifier trim(DBIdentifier name) {\n+        if (DBIdentifier.isNull(name)) {\n+            return name;\n+        }\n+        DBIdentifier sName = name.clone();\n+        if (isEmpty(sName)) {\n+            return sName;\n+        }\n+        String strName = sName.getNameInternal();\n+        strName = strName.trim();\n+        sName.setNameInternal(strName);\n+        return sName;\n+    }\n+\n+    /**\n+     * The length of the name, including delimiting characters.\n+     */\n+    public int length() {\n+        if (DBIdentifier.isNull(this)) {\n+            return 0;\n+        }\n+        return super.length();\n+    }\n+\n+    /**\n+     * Returns true if the identifier is delimited.\n+     */\n+    public boolean isDelimited() {\n+        if (DBIdentifier.isEmpty(this)) {\n+            return false;\n+        }\n+        return Normalizer.isDelimited(getNameInternal());\n+    }\n+\n+    /**\n+     * Combines an array of names names using standard combining rules and\n+     * returns an identifier of the specified type.\n+     */\n+    public static DBIdentifier combine(DBIdentifierType id, String...names) {\n+        return newIdentifier(Normalizer.combine(names), id);\n+    }\n+\n+    /**\n+     * Returns the unqualified name of this identifier.\n+     */\n+    public DBIdentifier getUnqualifiedName() {\n+        return this;\n+    }\n+}"},{"sha":"1a49fcb23560ec54cce6f1333d8065fdc0d6ae9c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DBIdentifierRule.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DBIdentifierRule.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DBIdentifierRule.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DBIdentifierRule.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.identifier;\n+\n+import java.util.Set;\n+\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n+import org.apache.openjpa.lib.identifier.IdentifierRule;\n+\n+/**\n+ * The default DBIdentifier rule.  Closely matches SQL92 naming rules.\n+ */\n+public class DBIdentifierRule extends IdentifierRule {\n+    \n+    public static final String DEFAULT_SQL_92 = \"DefaultSQL92\";\n+    \n+    public static final String SPECIAL_CHARS = \" #$&%!?,.:;\\\"\\'\";\n+    \n+    public DBIdentifierRule() {\n+        setName(DEFAULT_SQL_92);\n+        // SQL92 Identifier rule 1) Can be up to 128 characters long\n+//        setMaxLength(128);\n+        // OpenJPA allows names with a length of 255 by default\n+        setMaxLength(255);\n+        // SQL92 Identifier rule 2) Must begin with a letter\n+        setMustBeginWithLetter(true);\n+        // SQL92 Identifier rule 3) Can contain letters, digits, and underscores\n+        setOnlyLettersDigitsUnderscores(true);\n+        // SQL Identifier rule 4) Can't contain spaces or special characters such \n+        // as #, $, &, %, or punctuation.\n+        setSpecialCharacters(SPECIAL_CHARS);\n+    }\n+\n+    public DBIdentifierRule(DBIdentifierType id, Set<String> reservedWords) {\n+        this();\n+        setName(id.toString());\n+        // SQL Identifier rule 5) Can't be reserved words\n+        setReservedWords(reservedWords);\n+    }\n+}"},{"sha":"755ddf07bebc6a7296398db3b18ddc029cbf911c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DBIdentifierUtil.java","status":"added","additions":213,"deletions":0,"changes":213,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DBIdentifierUtil.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DBIdentifierUtil.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DBIdentifierUtil.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.identifier;\n+\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.NameSet;\n+import org.apache.openjpa.jdbc.schema.Schema;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n+\n+import static org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n+\n+/**\n+ * An interface for DB identifier utility-style operations.  This interface\n+ * extends the basic operations provided by IdentifierUtil with additional\n+ * operations those specific to DBIdentifiers and identifier conversion.\n+ */\n+public interface DBIdentifierUtil extends IdentifierUtil {\n+\n+    // Legacy values for naming operations\n+    public static final int ANY = 0;\n+    public static final int TABLE = 1;\n+    public static final int SEQUENCE = 2;\n+    public static final int COLUMN = 3;\n+\n+    /**\n+     * Shortens the given name to the given maximum length, then checks that\n+     * it is not a reserved word. If it is reserved, appends a \"0\". If\n+     * the name conflicts with an existing schema component and uniqueness\n+     * checking is enabled, the last character is replace with '0', then \n+     * '1', etc. \n+     * Note that the given max len may be 0 if the database metadata is \n+     * incomplete.\n+     * \n+     * Note: If the name is delimited, make sure the ending delimiter is\n+     * not stripped off.\n+     */\n+    public DBIdentifier makeIdentifierValid(DBIdentifier sname, NameSet set, int maxLen,\n+        boolean checkForUniqueness);\n+\n+    /**\n+     * Shortens the given name to the given maximum length, then checks that\n+     * it is not a reserved word. If it is reserved, appends a \"0\". If\n+     * the name conflicts with an existing schema component and uniqueness\n+     * checking is enabled, the last character is replace with '0', then \n+     * '1', etc. \n+     * Note that the given max len may be 0 if the database metadata is \n+     * incomplete.\n+     * \n+     * Note: If the name is delimited, make sure the ending delimiter is\n+     * not stripped off.\n+     */\n+    public DBIdentifier makeNameValid(String name, NameSet set, int maxLen,\n+        int nameType, boolean checkForUniqueness);\n+\n+    /**\n+     * Returns a valid column name/identifier, based upon the configuration and\n+     * provided parameters.\n+     * @param name\n+     * @param table\n+     * @param maxLen\n+     * @param checkForUniqueness\n+     * @return\n+     */\n+    public DBIdentifier getValidColumnIdentifier(DBIdentifier name, Table table, int maxLen, \n+        boolean checkForUniqueness);\n+    \n+    /**\n+     * Returns a valid index identifier, based upon the configuration and\n+     * provided parameters.\n+     * @param name\n+     * @param table\n+     * @param maxLen\n+     * @param checkForUniqueness\n+     * @return\n+     */\n+    public DBIdentifier getValidIndexIdentifier(DBIdentifier name, Table table, int maxLen);\n+\n+    /**\n+     * Returns a valid index identifier, based upon the configuration and\n+     * provided parameters.\n+     * @param name\n+     * @param table\n+     * @param maxLen\n+     * @param checkForUniqueness\n+     * @return\n+     */\n+    public DBIdentifier getValidSequenceIdentifier(DBIdentifier name, Schema schema, int maxLen);\n+    \n+    /**\n+     * Returns a valid table identifier, based upon the configuration and provided\n+     * parameters.\n+     * @param name\n+     * @param schema\n+     * @param maxLen\n+     * @return\n+     */\n+    public DBIdentifier getValidTableIdentifier(DBIdentifier name, Schema schema, int maxLen);\n+\n+    /**\n+     * Returns a valid unique constraint identifier, based upon the configuration and\n+     * provided parameters.\n+     * @param name\n+     * @param table\n+     * @param maxLen\n+     * @return\n+     */\n+    public DBIdentifier getValidUniqueIdentifier(DBIdentifier name, Table table, int maxLen);\n+\n+    /**\n+     * Returns a valid foreign key identifier, based upon the configuration and\n+     * provided parameters.\n+     * @param name\n+     * @param table\n+     * @param toTable\n+     * @param maxLen\n+     * @return\n+     */\n+    public DBIdentifier getValidForeignKeyIdentifier(DBIdentifier name, Table table, Table toTable, int maxLen);\n+\n+    /**\n+     * Converts the specified identifier to a format required by the database.\n+     * @param name\n+     * @return\n+     */\n+    public String toDBName(DBIdentifier name);\n+\n+    /**\n+     * Converts the specified identifier to a format required by the database, \n+     * optionally delimiting the name.\n+     * @param name\n+     * @param delimit\n+     * @return\n+     */\n+    public String toDBName(DBIdentifier name, boolean delimit);\n+\n+    /**\n+     * Converts the specified string to a format required by the database.\n+     * @param name\n+     * @return\n+     */\n+    public String toDBName(String name);\n+\n+    /**\n+     * Converts the specified string to a format required by the database,\n+     * optionally delimiting the name.\n+     * @param name\n+     * @return\n+     */\n+    public String toDBName(String name, boolean delimit);\n+\n+    /**\n+     * Converts the name returned by the database to an identifier of the\n+     * specified type.\n+     * @param name\n+     * @return\n+     */\n+    public DBIdentifier fromDBName(String name, DBIdentifierType id);\n+\n+    /**\n+     * Appends multiple columns names together into comma delimited string.\n+     * @param columns\n+     * @return\n+     */\n+    public String appendColumns(Column[] columns);\n+\n+    /**\n+     * Converts the name of the specified delimiter to the appropriate\n+     * case as defined by the configuration.\n+     * @param columns\n+     * @return\n+     */\n+    public DBIdentifier convertSchemaCase(DBIdentifier schema);\n+\n+    /**\n+     * Appends multiple names together using the appropriate name delimiter.\n+     * @param resultId\n+     * @param names\n+     * @return\n+     */\n+    public DBIdentifier append(DBIdentifierType resultId, DBIdentifier...names);\n+\n+    /**\n+     * Returns a generated key sequence identifier for the column.\n+     * @param col\n+     * @param maxLen\n+     * @return\n+     */\n+    public DBIdentifier getGeneratedKeySequenceName(Column col, int maxLen);\n+\n+    /**\n+     * Converts a provided alias to a format specified in the configuration.\n+     * @param alias\n+     * @return\n+     */\n+    public String convertAlias(String alias);\n+}"},{"sha":"dc959aac5c0923af0516703322625c484288d67b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DBIdentifierUtilImpl.java","status":"added","additions":478,"deletions":0,"changes":478,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DBIdentifierUtilImpl.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DBIdentifierUtilImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DBIdentifierUtilImpl.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,478 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.identifier;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.NameSet;\n+import org.apache.openjpa.jdbc.schema.Schema;\n+import org.apache.openjpa.jdbc.schema.SchemaGroup;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.identifier.IdentifierConfiguration;\n+import org.apache.openjpa.lib.identifier.IdentifierRule;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n+import org.apache.openjpa.lib.identifier.IdentifierUtilImpl;\n+\n+public class DBIdentifierUtilImpl extends IdentifierUtilImpl implements DBIdentifierUtil,\n+    Configurable {\n+    \n+    private JDBCConfiguration _conf = null;\n+\n+    public DBIdentifierUtilImpl() {\n+    }\n+    \n+    public DBIdentifierUtilImpl(IdentifierConfiguration config) {\n+        super(config);\n+    }\n+    \n+    public DBIdentifier getValidColumnIdentifier(DBIdentifier name, Table table,\n+        int maxLen, boolean checkForUniqueness) {\n+        if (DBIdentifier.isNull(name)) {\n+            return name;\n+        }\n+        String rule = name.getType().name();\n+        maxLen = getMaxLen(rule, name, maxLen);\n+\n+        DBIdentifier sName = DBIdentifier.removeLeading(name, IdentifierUtil.UNDERSCORE);\n+        return makeIdentifierValid(sName, table, maxLen, checkForUniqueness);\n+    }\n+    \n+    public DBIdentifier getValidForeignKeyIdentifier(DBIdentifier name, Table table, Table toTable, int maxLen) {\n+        if (DBIdentifier.isNull(name)) {\n+            return name;\n+        }\n+        String rule = name.getType().name();\n+        maxLen = getMaxLen(rule, name, maxLen);\n+\n+        DBIdentifier sName = makeName(rule, name, table, \"F\");\n+        return makeIdentifierValid(sName, table.getSchema().getSchemaGroup(),\n+            maxLen, true);\n+    }\n+\n+    \n+    public DBIdentifier getValidUniqueIdentifier(DBIdentifier name, Table table, int maxLen) {\n+        if (DBIdentifier.isNull(name)) {\n+            return name;\n+        }\n+        String rule = name.getType().name();\n+        maxLen = getMaxLen(rule, name, maxLen);\n+\n+        DBIdentifier sName = makeName(rule, name, table, \"U\");\n+        return makeIdentifierValid(sName, table.getSchema().getSchemaGroup(),\n+            maxLen, true);\n+    }\n+\n+    public DBIdentifier getValidIndexIdentifier(DBIdentifier name, Table table, int maxLen) {\n+        if (DBIdentifier.isNull(name)) {\n+            return name;\n+        }\n+        String rule = name.getType().name();\n+        maxLen = getMaxLen(rule, name, maxLen);\n+\n+        DBIdentifier sName = makeName(rule, name, table, \"I\");\n+        return makeIdentifierValid(sName, table.getSchema().getSchemaGroup(),\n+            maxLen, true);\n+    }\n+\n+    public DBIdentifier getValidSequenceIdentifier(DBIdentifier name, Schema schema, int maxLen) {\n+        if (DBIdentifier.isNull(name)) {\n+            return name;\n+        }\n+        String rule = name.getType().name();\n+        maxLen = getMaxLen(rule, name, maxLen);\n+\n+        DBIdentifier sName = makeName(rule, name, \"S\");\n+        return makeIdentifierValid(sName, schema.getSchemaGroup(), maxLen, true);\n+    }\n+\n+    public DBIdentifier getValidTableIdentifier(DBIdentifier name, Schema schema, int maxLen) {\n+        if (DBIdentifier.isNull(name)) {\n+            return name;\n+        }\n+        String rule = name.getType().name();\n+        maxLen = getMaxLen(rule, name, maxLen);\n+\n+        DBIdentifier sName = makeName(rule, name, null);\n+        \n+        return makeIdentifierValid(sName, schema.getSchemaGroup(),\n+            maxLen, true);\n+    }\n+\n+    public DBIdentifier makeNameValid(String name, NameSet set, int maxLen,\n+        int nameType, boolean checkForUniqueness) {\n+        DBIdentifierType id = DBIdentifierType.DEFAULT;\n+        switch (nameType) {\n+            case DBIdentifierUtil.TABLE:\n+                id = DBIdentifierType.TABLE;\n+                break;\n+            case DBIdentifierUtil.SEQUENCE:\n+                id = DBIdentifierType.SEQUENCE;\n+                break;\n+            case DBIdentifierUtil.COLUMN:\n+                id = DBIdentifierType.COLUMN;\n+                break;\n+        }\n+        return makeIdentifierValid(DBIdentifier.newIdentifier(name, id), set, maxLen, checkForUniqueness);\n+    }\n+\n+    public DBIdentifier makeIdentifierValid(DBIdentifier sname, NameSet set, int maxLen,\n+        boolean checkForUniqueness) {\n+        DBIdentifier validName = sname;\n+        String rule = sname.getType().name();\n+        \n+        maxLen = getMaxLen(rule, validName, maxLen);\n+\n+        int nameLen = validName.getName().length();\n+        if (nameLen > maxLen) {\n+            validName = DBIdentifier.truncate(validName, nameLen - maxLen);\n+            nameLen = validName.getName().length();\n+        }\n+        if (isReservedWord(rule, validName.getName())) {\n+            if (nameLen == maxLen)\n+                validName = DBIdentifier.truncate(validName, 1);\n+            validName = DBIdentifier.append(validName, \"0\");\n+            nameLen = validName.getName().length();\n+        }\n+\n+        // now make sure the name is unique\n+        if (set != null && checkForUniqueness) {\n+            for (int version = 1, chars = 1; true; version++) {\n+                // for table names, we check for the table itself in case the\n+                // name set is lazy about schema reflection\n+                if (validName.getType() == DBIdentifierType.TABLE) {\n+                    if (!((SchemaGroup) set).isKnownTable(QualifiedDBIdentifier.getPath(validName)))\n+                        break;\n+                } else if (validName.getType() == DBIdentifierType.SEQUENCE) {\n+                    if (!((SchemaGroup) set).isKnownSequence(QualifiedDBIdentifier.getPath(validName)))\n+                        break;\n+                } else {\n+                    if (!set.isNameTaken(validName))\n+                        break;\n+                }\n+\n+                // a single char for the version is probably enough, but might\n+                // as well be general about it...\n+                if (version > 1) {\n+                    validName = DBIdentifier.truncate(validName, chars);\n+                }\n+                if (version >= Math.pow(10, chars))\n+                    chars++;\n+                if (nameLen + chars > maxLen) {\n+                    validName = DBIdentifier.truncate(validName, nameLen + chars - maxLen);\n+                }\n+                validName = DBIdentifier.append(validName, Integer.toString(version)); \n+                nameLen = validName.getName().length();\n+            }\n+        }\n+        \n+        if (validName.isDelimited()) {\n+            String delimCase = getIdentifierConfiguration().getDelimitedCase();\n+            if (delimCase.equals(CASE_LOWER)) {\n+                return DBIdentifier.toLower(validName,true);\n+            }\n+            else if (delimCase.equals(CASE_UPPER)) {\n+                return DBIdentifier.toUpper(validName,true);\n+            }\n+            else {\n+                return validName;\n+            }\n+        }\n+        return DBIdentifier.toUpper(validName);\n+    }\n+\n+    /**\n+     *  Converts the name to a name which can be used within a SQL statement.  Uses\n+     *  the appropriate delimiters and separators. \n+     *  @parm name a DBIdentifier\n+     */\n+    public String toDBName(DBIdentifier name) {\n+        return toDBName(name, true);\n+    }\n+    \n+    /**\n+     *  Converts the name to a name which can be used within a SQL statement.  Uses\n+     *  the appropriate delimiters and separators. \n+     *  @parm name a DBIdentifier\n+     *  @param delimit If true, allows the name to be delimited, if necessary.  \n+     *  Otherwise, the identifier is not delimited.\n+     */\n+    public String toDBName(DBIdentifier name, boolean delimit) {\n+        if (DBIdentifier.isNull(name)) {\n+            return null;\n+        }\n+        if (getIdentifierConfiguration().getSupportsDelimitedIdentifiers() && delimit \n+            && getIdentifierConfiguration().delimitAll() && !name.isDelimited()) {\n+            return delimit(name, true);\n+        }\n+        String rule = name.getType().name();\n+        if (name instanceof QualifiedDBIdentifier) {\n+            QualifiedDBIdentifier path = (QualifiedDBIdentifier)name;\n+            return convertFull(Normalizer.getNamingConfiguration(), rule, path.getName());\n+        }\n+        return convert(Normalizer.getNamingConfiguration(), rule, name.getName());\n+    }\n+\n+    /**\n+     * Converts the identifier to a format appropriate for the configuration.\n+     * Delimits if necessary\n+     */\n+    public String toDBName(String name) {\n+        return toDBName(name, true);\n+    }\n+\n+    /**\n+     * Converts the identifier to a format appropriate for the configuration using\n+     * the default naming rule.\n+     * @param delimit If false, do not delimit.  Otherwise, delimit if necessary.\n+     */\n+    public String toDBName(String name, boolean delimit) {\n+        return toDBName(getIdentifierConfiguration().getDefaultIdentifierRule().getName(), name, delimit);\n+    }\n+\n+    /**\n+     * Converts the identifier to a format appropriate for the configuration using\n+     * the specified naming rule.\n+     * @param delimit If false, do not delimit.  Otherwise, delimit if necessary.\n+     */\n+    private String toDBName(String rule, String name, boolean delimit) {\n+        if (name == null) {\n+            return null;\n+        }\n+        if (getIdentifierConfiguration().getSupportsDelimitedIdentifiers() && delimit && \n+            getIdentifierConfiguration().delimitAll() && !Normalizer.isDelimited(name)) {\n+            return delimit(rule, name, true);\n+        }\n+        return convert(Normalizer.getNamingConfiguration(), rule, name);\n+    }\n+\n+    /**\n+     * Creates a new identifier of a given type based upon the name returned\n+     * from the database.  \n+     */\n+    public DBIdentifier fromDBName(String name, DBIdentifierType id) {\n+        if (name == null) {\n+            return DBIdentifier.NULL;\n+        }\n+        if (!getIdentifierConfiguration().getSupportsDelimitedIdentifiers()) {\n+            return DBIdentifier.newIdentifier(name, id);\n+        }\n+        String delimCase = getIdentifierConfiguration().getDelimitedCase();\n+        String nonDelimCase = getIdentifierConfiguration().getSchemaCase();\n+        String caseName = name;\n+        \n+        // If delimited and non-delimited case are the same, don't change \n+        // case or try to determine whether delimiting is required.  Let the\n+        // normalizer figure it out using standard rules.\n+        if (delimCase.equals(nonDelimCase)) {\n+            return DBIdentifier.newIdentifier(name, id, false, false);\n+        }\n+        \n+        // Otherwise, try to determine whether to delimit based on an expected vs.\n+        // actual name comparison.\n+        if (delimCase.equals(CASE_PRESERVE)) {\n+            if (nonDelimCase.equals(CASE_LOWER)) {\n+                caseName = name.toLowerCase();\n+            } else {\n+                caseName = name.toUpperCase();\n+            }\n+        } else if (delimCase.equals(CASE_LOWER)) {\n+            if (nonDelimCase.equals(CASE_UPPER)) {\n+                caseName = name.toUpperCase();\n+            }\n+        } else if (delimCase.equals(CASE_UPPER)) {\n+            if (nonDelimCase.equals(CASE_LOWER)) {\n+                caseName = name.toLowerCase();\n+            }\n+        }\n+        \n+        boolean delimit = !caseName.equals(name) || getIdentifierConfiguration().delimitAll();\n+        return DBIdentifier.newIdentifier((delimit ? name : caseName), id, false, delimit);\n+    }\n+\n+    public DBIdentifier append(DBIdentifierType resultId, DBIdentifier...names) {\n+        if (names == null || names.length == 0) {\n+            return DBIdentifier.NULL;\n+        }\n+        DBIdentifier sName = DBIdentifier.newIdentifier(\"\", resultId);\n+        for (DBIdentifier name : names) {\n+            DBIdentifier.append(sName, name.getName());\n+        }\n+        return sName;\n+    }\n+    \n+    public String appendColumns(Column[] columns) {\n+        if (columns == null || columns.length == 0) {\n+            return \"\";\n+        }\n+        if (columns.length == 1) {\n+            return toDBName(columns[0].getIdentifier());\n+        }\n+        StringBuilder colsb = new StringBuilder(\"\");\n+        for (int i = 0; i < columns.length; i++) {\n+            colsb.append(toDBName(columns[i].getIdentifier()));\n+            if (i < (columns.length - 1)) {\n+                colsb.append(\", \");\n+            }\n+        }\n+        return colsb.toString();\n+    }\n+    \n+    public String delimit(DBIdentifier name, boolean force) {\n+        String rule = name.getType().name();\n+        // If this is a compound path, each item must be delimited\n+        // separately\n+        if (name instanceof QualifiedDBIdentifier) {\n+            QualifiedDBIdentifier path = (QualifiedDBIdentifier)name;\n+            // Make sure this is a qualified path before delimiting\n+            // separately\n+            if (!((path.getType() == DBIdentifierType.COLUMN &&\n+                  path.isUnqualifiedColumn()) ||\n+                  (path.getType() != DBIdentifierType.COLUMN &&\n+                   path.isUnqualifiedObject()))) {\n+                DBIdentifier[] names = QualifiedDBIdentifier.splitPath(name);\n+                for (int i = 0; i < names.length; i++) {\n+                    DBIdentifier sName = names[i].getUnqualifiedName();\n+                    if (!sName.isDelimited()) {\n+                        String pRule = sName.getType().name();\n+                        names[i].setName(delimit(pRule, sName.getName(), force));\n+                    }\n+                }\n+                return QualifiedDBIdentifier.newPath(names).getName();\n+            }\n+        }\n+        return delimit(rule, name.getName(), force);\n+    }\n+    \n+    public String shorten(String name, int targetLength) {\n+        return DBDictionary.shorten(name, targetLength);\n+    }\n+    \n+    public DBIdentifier getGeneratedKeySequenceName(Column col, int maxLen) {\n+        DBIdentifier tname = col.getTableIdentifier();\n+        DBIdentifier cname = col.getIdentifier();\n+        int max = maxLen;\n+        int extraChars = -max + tname.getName().length() + 1 // <tname> + '_'\n+            + cname.getName().length() + 4; // <cname> + '_SEQ'\n+        String tsname = tname.getName();\n+        if (extraChars > 0) {\n+            // this assumes that tname is longer than extraChars\n+            tsname = tsname.substring(0, tsname.length() - extraChars);\n+        }\n+        return DBIdentifier.combine(DBIdentifierType.SEQUENCE, tsname, cname.getName(), \"SEQ\");\n+    }\n+    \n+    /**\n+     * Convert the specified schema name to a name that the database will\n+     * be able to understand in metadata operations.\n+     */\n+    public DBIdentifier convertSchemaCase(DBIdentifier name) {\n+        if (DBIdentifier.isNull(name))\n+            return DBIdentifier.NULL;\n+\n+        DBIdentifier sName = name.clone();\n+        // Handle delimited string differently. Return unquoted name.\n+        String delimCase = getIdentifierConfiguration().getDelimitedCase();\n+        if (/* getNamingConfiguration().delimitAll() || */ name.isDelimited()) {\n+            if (CASE_UPPER.equals(delimCase)) {\n+                sName = DBIdentifier.toUpper(sName,true);\n+            }\n+            else if (CASE_LOWER.equals(delimCase)) {\n+                sName = DBIdentifier.toLower(sName,true);\n+            }\n+            \n+            return DBIdentifier.removeDelimiters(sName);\n+        }\n+        if (!getIdentifierConfiguration().delimitAll()) {\n+            // Not delimited, use the base schema case expected by the DB\n+            String schemaCase = getIdentifierConfiguration().getSchemaCase();\n+            if (CASE_LOWER.equals(schemaCase))\n+                return DBIdentifier.toLower(sName);\n+            if (CASE_PRESERVE.equals(schemaCase))\n+                return sName;\n+            return DBIdentifier.toUpper(sName);\n+        }\n+        return sName;\n+    }\n+    \n+    /**\n+     * Converts a column alias to use the appropriate delimiters\n+     */\n+    public String convertAlias(String alias) {\n+        String[] names = Normalizer.splitName(alias);\n+        if (names.length <= 1) {\n+            // Nothing to split\n+            return alias;\n+        }\n+        // Skip the the first name.  It is the alias (T0, T1, etc.)\n+        for (int i = 1; i < names.length; i++) {\n+            names[i] = toDBName(getIdentifierConfiguration().getDefaultIdentifierRule().toString(), names[i], true);\n+        }\n+        return joinNames(getIdentifierConfiguration().getDefaultIdentifierRule(), names);\n+    }\n+\n+    private DBIdentifier makeName(String rule, DBIdentifier name, Table tbl, String prefix) {\n+        DBIdentifier sName = DBIdentifier.removeLeading(name, IdentifierUtil.UNDERSCORE);\n+        String tableName = tbl.getIdentifier().getName();\n+        int len = Math.min(tableName.length(), 7);\n+        \n+        String str = combineNames(rule, new String[] { prefix == null ? \"\" : prefix, \n+            shorten(tableName, len), sName.getName() });\n+        sName.setName(str);\n+        return sName;\n+    }\n+\n+    private DBIdentifier makeName(String rule, DBIdentifier name, String prefix) {\n+        DBIdentifier sName = DBIdentifier.removeLeading(name, IdentifierUtil.UNDERSCORE);\n+        if (!StringUtils.isEmpty(prefix)) {\n+            sName = DBIdentifier.preCombine(sName, prefix);\n+        }\n+        return sName;\n+    }\n+\n+    private int getMaxLen(String rule, DBIdentifier name, int maxLen) {\n+        IdentifierConfiguration config = getIdentifierConfiguration();\n+        if (maxLen < 1) {\n+            IdentifierRule nrule = config.getIdentifierRule(rule);\n+            maxLen = nrule.getMaxLength();\n+        }\n+        // Subtract delimiter length if name is delimited or will be delimited\n+        if (config.delimitAll() || name.isDelimited()) {\n+            maxLen = maxLen - (config.getLeadingDelimiter().length() + config.getTrailingDelimiter().length());\n+        }\n+        \n+        return maxLen;\n+    }\n+    \n+    /**\n+     * System configuration.\n+     */\n+    public JDBCConfiguration getConfiguration() {\n+        return _conf;\n+    }\n+\n+    @Override\n+    public void setConfiguration(Configuration conf) {\n+        _conf = (JDBCConfiguration)conf;\n+    }\n+}"},{"sha":"5f1ac5832e4432a938676b16c01510814da65627","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DefaultIdentifierConfiguration.java","status":"added","additions":81,"deletions":0,"changes":81,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DefaultIdentifierConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DefaultIdentifierConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/DefaultIdentifierConfiguration.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.identifier;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.identifier.IdentifierConfiguration;\n+import org.apache.openjpa.lib.identifier.IdentifierRule;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n+\n+public class DefaultIdentifierConfiguration implements IdentifierConfiguration {\n+\n+    private DBIdentifierRule normalizingRule = new DBIdentifierRule();\n+    private Map<String, IdentifierRule> normalizingRules = new HashMap<String, IdentifierRule>();\n+\n+    public DefaultIdentifierConfiguration() {\n+        normalizingRules.put(IdentifierRule.DEFAULT_RULE, normalizingRule);\n+    }\n+    \n+    public boolean delimitAll() {\n+        return false;\n+    }\n+\n+    public IdentifierRule getDefaultIdentifierRule() {\n+        return normalizingRule;\n+    }\n+\n+    public String getDelimitedCase() {\n+        return IdentifierUtil.CASE_PRESERVE;\n+    }\n+\n+    public String getSchemaCase() {\n+        return IdentifierUtil.CASE_PRESERVE;\n+    }\n+\n+    public String getLeadingDelimiter() {\n+        return IdentifierUtil.DOUBLE_QUOTE;\n+    }\n+\n+    public String getIdentifierDelimiter() {\n+        return IdentifierUtil.DOT;\n+    }\n+\n+    public String getIdentifierConcatenator() {\n+        return IdentifierUtil.UNDERSCORE;\n+    }\n+\n+    public <T> IdentifierRule getIdentifierRule(T t) {\n+        return normalizingRule;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Map<String, IdentifierRule> getIdentifierRules() {\n+        return normalizingRules;\n+    }\n+\n+    public String getTrailingDelimiter() {\n+        return IdentifierUtil.DOUBLE_QUOTE;\n+    }\n+\n+    public boolean getSupportsDelimitedIdentifiers() {\n+        return true;\n+    }\n+}"},{"sha":"5c8a2824f0eb5e7d8843beb04b136c813f6db695","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/Normalizer.java","status":"added","additions":311,"deletions":0,"changes":311,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/Normalizer.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/Normalizer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/Normalizer.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,311 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.identifier;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.lib.identifier.IdentifierConfiguration;\n+import org.apache.openjpa.lib.identifier.IdentifierRule;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n+\n+/**\n+ * Static utility class used for operating on string based identifiers. \n+ */\n+public class Normalizer {\n+\n+    private static IdentifierUtil normalizer = \n+        new DBIdentifierUtilImpl(new DefaultIdentifierConfiguration());\n+    \n+    private static IdentifierRule defaultRule;\n+    \n+    static {\n+        defaultRule = normalizer.getIdentifierConfiguration().getDefaultIdentifierRule();\n+    }\n+\n+    public static IdentifierConfiguration getNamingConfiguration() {\n+        return normalizer.getIdentifierConfiguration();\n+    }\n+    \n+    /**\n+     * Normalizes a multi-part name\n+     * @param name\n+     * @return\n+     */\n+    public static String normalizeMulti(String name) {\n+        if (StringUtils.isEmpty(name)) {\n+            return name;\n+        }\n+        String[] names = normalizer.splitName(defaultRule, name);\n+        return normalizer.joinNames(defaultRule, names);\n+    }\n+\n+    /**\n+     * Normalizes a single part name\n+     * @param name\n+     * @return\n+     */\n+    public static String normalizeString(String name) {\n+        if (StringUtils.isEmpty(name)) {\n+            return name;\n+        }\n+        if (!normalizer.isDelimited(defaultRule, name)) {\n+            // If not delimited, delimit the string if necessary\n+            return normalizer.delimit(defaultRule, name);\n+        }\n+        return name;\n+    }\n+    \n+    /**\n+     * Returns true if the name is delimited with default delimiters\n+     * @param name\n+     * @return\n+     */\n+    public static boolean isDelimited(String name) {\n+        if (StringUtils.isEmpty(name)) {\n+            return false;\n+        }\n+        return normalizer.isDelimited(defaultRule, name);\n+    }\n+    \n+    /**\n+     * Splits names into individual components and compares individually\n+     * for equality\n+     * @param name1\n+     * @param name2\n+     * @return\n+     */\n+    public static boolean fullNamesEqual(String name1, String name2) {\n+        if (StringUtils.isEmpty(name1) && StringUtils.isEmpty(name2)) {\n+            return true;\n+        }\n+        // Split multi-part names into individual components and compare\n+        // each component.  If delimited, do case compare.\n+        String[] names1 = normalizer.splitName(defaultRule, name1);\n+        String[] names2 = normalizer.splitName(defaultRule, name2);\n+        if (names1.length != names2.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < names1.length; i++) {\n+            if (normalizer.isDelimited(defaultRule, names1[i])) {\n+                if (!StringUtils.equals(names1[i],names2[i])) {\n+                    return false;\n+                }\n+            } else {\n+                if (!StringUtils.equalsIgnoreCase(names1[i],names2[i])) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Compares two string names for equality.  If delimited, does a\n+     * case comparison.  If not delimited, does a case insensitive \n+     * comparison.\n+     * @param name1\n+     * @param name2\n+     * @return\n+     */\n+    public static boolean namesEqual(String name1, String name2) {\n+        if (StringUtils.isEmpty(name1) && StringUtils.isEmpty(name2)) {\n+            return true;\n+        }\n+        if (normalizer.isDelimited(defaultRule, name1)) {\n+            if (!StringUtils.equals(name1, name2)) {\n+                return false;\n+            }\n+        } else {\n+            if (!StringUtils.equalsIgnoreCase(name1, name2)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Normalizes a name, if not delimited, converts to uppercase.\n+     * @param name\n+     * @return\n+     */\n+    public static String normalizeUpper(String name) {\n+        String nName = normalizeString(name);\n+        // Do not convert delimited names to upper case.  They may have\n+        // been delimited to preserve case.\n+        if (!isDelimited(nName)) {\n+            nName = name.toUpperCase();\n+        }\n+        return nName;\n+    }\n+    \n+    /**\n+     * Splits a name into normalized components\n+     * @param name\n+     * @return\n+     */\n+    public static String[] splitName(String name) {\n+        return normalizer.splitName(defaultRule, name);\n+    }\n+    \n+    \n+    /**\n+     * Splits a name into normalized components using the specified\n+     * name delimiter (ex. schema:table, delim = : --> { schema, table }\n+     * @param name\n+     * @return\n+     */\n+    public static String[] splitName(String name, String delim) {\n+        return normalizer.splitName(defaultRule, name, delim);\n+    }\n+\n+    /**\n+     * Joins multiple names using default identifier rules.\n+     * @param names\n+     * @return\n+     */\n+    public static String joinNames(String[] names) {\n+        return normalizer.joinNames(defaultRule, names);\n+    }\n+\n+    /**\n+     * Joins multiple names using the specified delimiter.\n+     * @param names\n+     * @return\n+     */\n+    public static String joinNames(String[] names, String delimiter) {\n+        return normalizer.joinNames(defaultRule, names, delimiter);\n+    }\n+    \n+    /**\n+     * Joins two names using the default identifier rules.\n+     * @param names\n+     * @return\n+     */\n+    public static String joinNames(String name1, String name2) {\n+        return joinNames(new String[] { name1, name2});\n+    }\n+    \n+\n+    /**\n+     * Truncates a name to the specified length while maintaining\n+     * delimiters.\n+     * @param name\n+     * @param length\n+     * @return\n+     */\n+    public static String truncate(String name, int length) {\n+        return normalizer.truncateName(defaultRule, name, length);\n+    }\n+\n+    /**\n+     * Convert a normalized name to a name using the specified configuration and\n+     * naming rule.\n+     * Note: Currently only delimiters are converted.\n+     * @param config\n+     * @param rule\n+     * @param name\n+     * @return\n+     */\n+    public static String convert(IdentifierConfiguration config, String rule, String name) {\n+        return normalizer.convert(config, rule, name);\n+    }\n+\n+    /**\n+     * Combines two names using default identifier rules.\n+     * @param name1\n+     * @param name2\n+     * @return\n+     */\n+    public static String combine(String name1, String name2) {\n+        return normalizer.combineNames(defaultRule, name1, name2);\n+    }\n+\n+    /**\n+     * Combines multiple names using default identifier rules.\n+     * @param name1\n+     * @param name2\n+     * @return\n+     */\n+    public static String combine(String...names) {\n+        return normalizer.combineNames(defaultRule, names);\n+    }\n+\n+    \n+    /**\n+     * Appends one string to another using default identifier rules.\n+     * @param name1\n+     * @param name2\n+     * @return\n+     */\n+    public static String append(String name1, String name2) {\n+        return normalizer.appendNames(defaultRule, name1, name2);\n+    }\n+    \n+    /**\n+     * Removes Hungarian notation from a string.\n+     * @param name1\n+     * @param name2\n+     * @return\n+     */\n+    public static String removeHungarianNotation(String name) {\n+        return normalizer.removeHungarianNotation(defaultRule, name);\n+    }\n+\n+    /**\n+     * Removes default delimiters from a string.\n+     * @param name1\n+     * @param name2\n+     * @return\n+     */\n+    public static String removeDelimiters(String name) {\n+        return normalizer.removeDelimiters(defaultRule, name);\n+    }\n+\n+    /**\n+     * Delimits a string if necessary, optionally forcing it to be\n+     * delimited.\n+     * @param name1\n+     * @param name2\n+     * @return\n+     */\n+    public static String delimit(String name, boolean force) {\n+        return normalizer.delimit(defaultRule, name, force);\n+    }\n+\n+    /**\n+     * Determines whether a name can be split into multiple components.\n+     * @param name1\n+     * @param name2\n+     * @return\n+     */\n+    public static boolean canSplit(String name) {\n+        return normalizer.canSplit(defaultRule, name);\n+    }\n+\n+    /**\n+     * Determines whether a name can be split into multiple components, taking\n+     * into account the specified delimiter.\n+     * @param name1\n+     * @param name2\n+     * @return\n+     */\n+    public static boolean canSplit(String name, String delim) {\n+        return normalizer.canSplit(defaultRule, name, delim);\n+    }\n+}"},{"sha":"1750e932272360b46ff7d53d83eed7b63949385d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/QualifiedDBIdentifier.java","status":"added","additions":359,"deletions":0,"changes":359,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/QualifiedDBIdentifier.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/QualifiedDBIdentifier.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/identifier/QualifiedDBIdentifier.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,359 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.identifier;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.openjpa.lib.identifier.Identifier;\n+\n+/**\n+ * This class extends DBIdentifier to provide support for qualified identifiers\n+ * such as schema qualified tables and table qualified columns.  It provides methods\n+ * to create qualified identifiers from individual identifiers.\n+ *\n+ */\n+public class QualifiedDBIdentifier extends DBIdentifier implements Identifier, Cloneable, Serializable {\n+    \n+    private DBIdentifier _schemaName = DBIdentifier.NULL;  // The schema name\n+    // The table name if the object (column, constraint) is qualified by a table name\n+    private DBIdentifier _objectTableName = DBIdentifier.NULL; \n+    \n+    \n+    protected QualifiedDBIdentifier(DBIdentifier... sNames) {\n+        setPath(sNames);\n+    }\n+    \n+    /**\n+     * Creates a qualified identifier based upon an array of DBIdentifiers.  Identifiers\n+     * must be specified in order.\n+     * @param names\n+     * @return\n+     */\n+    public static QualifiedDBIdentifier newPath(DBIdentifier...names) {\n+        return new QualifiedDBIdentifier(names);\n+    }\n+    \n+    /**\n+     * Set the identifiers that make up the path.  Identifiers must be specified\n+     * in path order.  (ex. [ table, column ] )\n+     * @param sNames\n+     */\n+    public void setPath(DBIdentifier...sNames) {\n+        resetNames();\n+        if (sNames == null || sNames.length == 0) {\n+            return;\n+        }\n+        \n+        if (sNames.length == 1) {\n+            DBIdentifier sName = sNames[0];\n+            if (sName.getType() == DBIdentifierType.SCHEMA) {\n+                setSchemaName(sName.clone());\n+            }\n+            setName(sName.clone());\n+            setType(sName.getType());\n+            return;\n+        }\n+\n+        for (int i = (sNames.length - 1); i >= 0; i--) {\n+            DBIdentifier sName = sNames[i];\n+            if (DBIdentifier.isNull(sName)) {\n+                continue;\n+            }\n+            if (i == (sNames.length - 1) && sNames.length != 1) {\n+                setName(sName.clone());\n+            } else {\n+                if (sName.getType() == DBIdentifierType.SCHEMA) {\n+                    setSchemaName(sName.clone());\n+                }\n+                else if (sName.getType() == DBIdentifierType.TABLE) {\n+                    setObjectTableName(sName.clone());\n+                }\n+            }\n+        }   \n+    }\n+    \n+    // Reset the path names\n+    private void resetNames() {\n+        _schemaName = DBIdentifier.NULL;\n+        _objectTableName = DBIdentifier.NULL;\n+    }\n+\n+    /**\n+     * Splits a qualified path into separate identifiers.\n+     * @param sName\n+     * @return\n+     */\n+    public static DBIdentifier[] splitPath(DBIdentifier sName) {\n+        if (sName instanceof QualifiedDBIdentifier && sName.getType() != DBIdentifierType.SCHEMA) {\n+            QualifiedDBIdentifier path = (QualifiedDBIdentifier)sName;\n+            List<DBIdentifier> names = new ArrayList<DBIdentifier>();\n+            \n+            if (!DBIdentifier.isNull(path.getSchemaName())) {\n+                names.add(path.getSchemaName().clone());\n+            }\n+            if (!DBIdentifier.isNull(path.getObjectTableName())) {\n+                names.add(path.getObjectTableName().clone());\n+            }\n+            if (!DBIdentifier.isNull(path.getIdentifier())) {\n+                names.add(((DBIdentifier)path).clone());\n+            }\n+            return names.toArray(new DBIdentifier[names.size()]);\n+        }\n+        if (sName instanceof DBIdentifier) {\n+            return new DBIdentifier[] { sName.clone() };\n+        }\n+        return new DBIdentifier[] {};\n+    }\n+\n+    /**\n+     * Creates a qualified path from an identifier.\n+     * @param sName\n+     * @return\n+     */\n+    public static QualifiedDBIdentifier getPath(DBIdentifier sName) {\n+        if (sName instanceof QualifiedDBIdentifier) {\n+            return (QualifiedDBIdentifier)sName.clone();\n+        }\n+        return QualifiedDBIdentifier.newPath(sName);\n+    }\n+\n+    /**\n+     *Sets the schema component of the path.\n+     */\n+    public void setSchemaName(DBIdentifier schemaName) {\n+        _schemaName = schemaName;\n+    }\n+\n+    /**\n+     * Gets the schema component of the path.\n+     * @return\n+     */\n+    public DBIdentifier getSchemaName() {\n+        return _schemaName;\n+    }\n+\n+    /**\n+     * Sets the object table name component of the path, if the path\n+     * is a table qualified identifier such as a constraint or column.\n+     */\n+    public void setObjectTableName(DBIdentifier objectName) {\n+        _objectTableName = objectName;\n+    }\n+\n+    \n+    /**\n+     * Gets the object table name component of the path, if the path\n+     * is a table qualified identifier such as a constraint or column.\n+     */\n+    public DBIdentifier getObjectTableName() {\n+        return _objectTableName;\n+    }\n+\n+    /**\n+     * Returns true if this object is not qualified by a schema component.\n+     * @return\n+     */\n+    public boolean isUnqualifiedObject() {\n+        return DBIdentifier.isNull(getSchemaName());\n+    }\n+\n+    /**\n+     * Returns true if this object is not qualified by a table or schema \n+     * component.\n+     * @return\n+     */\n+    public boolean isUnqualifiedColumn() {\n+        return DBIdentifier.isNull(getObjectTableName()) && DBIdentifier.isNull(getSchemaName());\n+    }\n+\n+    /**\n+     * Equality operator.\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (obj instanceof QualifiedDBIdentifier) {\n+            QualifiedDBIdentifier sPath = (QualifiedDBIdentifier)obj;\n+            return DBIdentifier.equal(sPath.getSchemaName(), getSchemaName()) &&\n+                DBIdentifier.equal(sPath.getObjectTableName(), getObjectTableName()) &&\n+                DBIdentifier.equal(sPath, this);\n+            \n+        }\n+        else if (obj instanceof DBIdentifier) {\n+            DBIdentifier sName = (DBIdentifier)obj;\n+            return DBIdentifier.equal(sName, this);\n+        } else if (obj instanceof String) {\n+            return obj.equals(this.getName());\n+        }\n+        throw new IllegalArgumentException(\"Cannot compare to type: \" + obj.getClass().getName());\n+    }\n+    \n+    /**\n+     * Compares two qualified identifiers for equality.\n+     * @param path1\n+     * @param path2\n+     * @return\n+     */\n+    public static boolean pathEqual(QualifiedDBIdentifier path1, QualifiedDBIdentifier path2) {\n+        if (path1 == null && path2 == null) {\n+            return true;\n+        }\n+        if (path1 == null) {\n+            return false;\n+        }\n+        DBIdentifier[] names1 = QualifiedDBIdentifier.splitPath(path1);\n+        DBIdentifier[] names2 = QualifiedDBIdentifier.splitPath(path2);\n+        if (names1.length != names2.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < names1.length; i++) {\n+            if (!DBIdentifier.equal(names1[i], names2[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns a fully qualified name as a string.\n+     */\n+    public String toString() {\n+        return getName();\n+    }\n+\n+    /**\n+     * Returns the fully qualified name as a string\n+     */\n+    public String getName() {\n+        // If no schema or object or table qualifier, return the base name\n+        if (DBIdentifier.isEmpty(_schemaName) && DBIdentifier.isEmpty(_objectTableName)) {\n+            return getBaseName();\n+        }\n+        DBIdentifier[] names = QualifiedDBIdentifier.splitPath(this);\n+        return DBIdentifier.join(names);\n+    }\n+    \n+    /**\n+     * Returns the base name of this qualified name.  For example, if the \n+     * qualified name is a schema qualified table, the table name is returned.\n+     * @return\n+     */\n+    public String getBaseName() {\n+        return super.getName();\n+    }\n+\n+    /**\n+     * Returns this object as a DBIdentifier.\n+     * @return\n+     */\n+    public DBIdentifier getIdentifier() {\n+        return this;\n+    }\n+    \n+    /**\n+     * Set the name of this qualified identifier.  Splits the string into\n+     * multiple components.  This method assumes the type does not change.\n+     */\n+    public void setName(String name) {\n+        // Split apart name into components\n+        DBIdentifier[] sNames = DBIdentifier.split(getType(), name);\n+        setPath(sNames);\n+    }\n+\n+    /**\n+     * Set the base name component of this compound identifier\n+     * @param name\n+     */\n+    protected void setBaseName(String name) {\n+        super.setName(name);\n+    }\n+\n+    /**\n+     * Returns the length of the qualified identifier, including delimiters\n+     * and name separators.\n+     */\n+    public int length() {\n+        String name = getName();\n+        if (name == null) {\n+            return 0;\n+        }\n+        return name.length();\n+    }\n+\n+    /**\n+     * Compares this identifier with another identifier.\n+     */\n+    public int compareTo(Identifier o) {\n+        if (o instanceof DBIdentifier) {\n+            if (o == null || o == DBIdentifier.NULL)\n+                return -1;\n+            return super.compareTo(o);\n+        }\n+        return getName().compareTo(o.getName());\n+    }\n+    \n+    /**\n+     * Returns true if all identifiers within this compound identifier are\n+     * delimited. Otherwise, false.\n+     */\n+    @Override\n+    public boolean isDelimited() {\n+        if (DBIdentifier.isEmpty(this)) {\n+            return false;\n+        }\n+        if (!DBIdentifier.isNull(getObjectTableName())) {\n+            if (!Normalizer.isDelimited(getObjectTableName().getName())) {\n+                return false;\n+            }\n+        }\n+        if (!DBIdentifier.isNull(getSchemaName())) {\n+            if (!Normalizer.isDelimited(getSchemaName().getName())) {\n+                return false;\n+            }\n+        }\n+        return super.isDelimited();\n+    }\n+    \n+    /**\n+     * Returns a new unqualified name based on this instance.\n+     */\n+    @Override\n+    public DBIdentifier getUnqualifiedName() {\n+        QualifiedDBIdentifier newName = (QualifiedDBIdentifier)clone();\n+        newName.setObjectTableName(DBIdentifier.NULL);\n+        newName.setSchemaName(DBIdentifier.NULL);\n+        return newName;\n+    }\n+    \n+    /**\n+     * Creates a clone of this identifier.\n+     */\n+    public QualifiedDBIdentifier clone() {\n+        QualifiedDBIdentifier sPath = new QualifiedDBIdentifier();\n+        sPath.setObjectTableName(getObjectTableName().clone());\n+        sPath.setSchemaName(getSchemaName().clone());\n+        sPath.setBaseName(super.getName());\n+        sPath.setType(getType());\n+        return sPath;\n+    }\n+\n+}"},{"sha":"8ad2787893ef250bef1fbc56802d05c5608a8b14","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ClassTableJDBCSeq.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ClassTableJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ClassTableJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ClassTableJDBCSeq.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -50,7 +50,7 @@\n     private static final Localizer _loc = Localizer.forPackage\n         (ClassTableJDBCSeq.class);\n \n-    private final Map _stats = new HashMap();\n+    private final Map<String, Status> _stats = new HashMap<String, Status>();\n     private boolean _ignore = false;\n     private boolean _aliases = false;\n \n@@ -113,7 +113,7 @@ protected synchronized Status getStatus(ClassMapping mapping) {\n     protected Column addPrimaryKeyColumn(Table table) {\n         DBDictionary dict = getConfiguration().getDBDictionaryInstance();\n         Column pkColumn = table.addColumn(dict.getValidColumnName(\n-            getPrimaryKeyColumn(), table));\n+            getPrimaryKeyColumnIdentifier(), table));\n         pkColumn.setType(dict.getPreferredType(Types.VARCHAR));\n         pkColumn.setJavaType(JavaTypes.STRING);\n         pkColumn.setSize(dict.characterColumnSize);\n@@ -223,7 +223,7 @@ public static boolean run(JDBCConfiguration conf, String[] args,\n             ClassArgParser cap = conf.getMetaDataRepositoryInstance()\n                 .getMetaDataFactory().newClassArgParser();\n             cap.setClassLoader(loader);\n-            Class cls = cap.parseTypes(args[0])[0];\n+            Class<?> cls = cap.parseTypes(args[0])[0];\n \n             if (repos == null)\n                 repos = conf.getMappingRepositoryInstance();"},{"sha":"429419b01165d6a4c85aebfbc6c6221b42a571a2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/MixedLockManager.java","status":"modified","additions":5,"deletions":4,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/MixedLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/MixedLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/MixedLockManager.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -23,6 +23,7 @@\n import java.util.List;\n import java.util.Map;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n@@ -87,15 +88,15 @@ protected void lockInternal(OpenJPAStateManager sm, int level, int timeout,\n         // \n         if(!dict.supportsLockingWithMultipleTables) {\n             // look for columns mapped to secondary tables which need to be locked\n-            Map<String,FieldMapping> colsMappedToSecTable = new HashMap<String,FieldMapping>();\n+            Map<DBIdentifier,FieldMapping> colsMappedToSecTable = new HashMap<DBIdentifier,FieldMapping>();\n             FieldMapping fms[] = mapping.getFieldMappings();\n             for( FieldMapping fm : fms) {\n-                String secTableName = fm.getMappingInfo().getTableName();\n-                if( secTableName != null ) {\n+                DBIdentifier secTableName = fm.getMappingInfo().getTableIdentifier();\n+                if(!DBIdentifier.isNull(secTableName)) {\n                     colsMappedToSecTable.put(secTableName, fm);\n                 }\n             }\n-            for( String secTableName : colsMappedToSecTable.keySet()) {\n+            for( DBIdentifier secTableName : colsMappedToSecTable.keySet()) {\n                 FieldMapping fm = colsMappedToSecTable.get(secTableName);\n                 // select only the PK columns, since we just want to lock\n                 Select select = factory.newSelect();"},{"sha":"f4dae06d2aad9f56c7fd0b308fa7fa23c32c352b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","status":"modified","additions":38,"deletions":26,"changes":64,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -27,6 +27,8 @@\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.QualifiedDBIdentifier;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.schema.Schema;\n import org.apache.openjpa.jdbc.schema.SchemaGroup;\n@@ -69,7 +71,7 @@\n     private static Localizer _loc = Localizer.forPackage(NativeJDBCSeq.class);\n \n     private JDBCConfiguration _conf = null;\n-    private String _seqName = \"OPENJPA_SEQUENCE\";\n+    private DBIdentifier _seqName = DBIdentifier.newSequence(\"OPENJPA_SEQUENCE\");\n     private int _increment = 1;\n     private int _initial = 1;\n     private int _allocate = 0;\n@@ -78,23 +80,24 @@\n \n     // for deprecated auto-configuration support\n     private String _format = null;\n-    private String _tableName = \"DUAL\";\n+    private DBIdentifier _tableName = DBIdentifier.newTable(\"DUAL\");\n     private boolean _subTable = false;\n \n-    private String _schema = null;\n+    private DBIdentifier _schema = DBIdentifier.NULL;\n         \n     /**\n      * The sequence name. Defaults to <code>OPENJPA_SEQUENCE</code>.\n      */\n+    // @GETTER\n     public String getSequence() {\n-        return _seqName;\n+        return _seqName.getName();\n     }\n \n     /**\n      * The sequence name. Defaults to <code>OPENJPA_SEQUENCE</code>.\n      */\n     public void setSequence(String seqName) {\n-        _seqName = seqName;\n+        _seqName = DBIdentifier.newSequence(seqName);\n     }\n \n     /**\n@@ -153,7 +156,7 @@ public void setIncrement(int increment) {\n      */\n     @Deprecated\n     public void setTableName(String table) {\n-        _tableName = table;\n+        _tableName = DBIdentifier.newTable(table);\n     }\n \n     /**\n@@ -168,23 +171,22 @@ public void setFormat(String format) {\n     @Override\n     public void addSchema(ClassMapping mapping, SchemaGroup group) {\n         // sequence already exists?\n-        if (group.isKnownSequence(_seqName))\n+        QualifiedDBIdentifier path = QualifiedDBIdentifier.getPath(_seqName);\n+        if (group.isKnownSequence(path))\n             return;\n \n-        String schemaName = getSchema();\n-        if (schemaName == null || schemaName.length() == 0) {\n-            schemaName = Strings.getPackageName(_seqName);\n-            if (schemaName.length() == 0)\n-                schemaName = Schemas.getNewTableSchema(_conf);\n+        DBIdentifier schemaName = getSchemaIdentifier();\n+        if (DBIdentifier.isEmpty(schemaName)) {\n+            schemaName = path.getSchemaName();\n+            if (DBIdentifier.isEmpty(schemaName))\n+                schemaName = Schemas.getNewTableSchemaIdentifier(_conf);\n         }\n \n         // create table in this group\n         Schema schema = group.getSchema(schemaName);\n         if (schema == null)\n             schema = group.addSchema(schemaName);\n         schema.importSequence(_seq);\n-        // TODO: temp until a more global name solution is implemented\n-        schema.addDelimSequenceName(_conf.getDBDictionaryInstance().addDelimiters(_seqName), _seq);\n     }\n \n     @Override\n@@ -208,8 +210,8 @@ public void endConfiguration() {\n             if (_format == null)\n                 throw new MetaDataException(_loc.get(\"no-seq-sql\", _seqName));\n         }\n-        if (_tableName == null)\n-            _tableName = \"DUAL\";\n+        if (DBIdentifier.isNull(_tableName))\n+            _tableName = DBIdentifier.newTable(\"DUAL\");\n \n         String name = dict.getFullName(_seq);\n         Object[] subs = (_subTable) ? new Object[]{ name, _tableName }\n@@ -234,26 +236,25 @@ protected Object nextInternal(JDBCStore store, ClassMapping mapping)\n      * Creates the sequence object.\n      */\n     private void buildSequence() {\n-        String seqName = Strings.getClassName(_seqName);\n+        QualifiedDBIdentifier path = QualifiedDBIdentifier.getPath(_seqName);\n+        DBIdentifier seqName = path.getIdentifier();\n         // JPA 2 added schema as a configurable attribute on  \n         // sequence generator.  OpenJPA <= 1.x allowed this via\n         // schema.sequence on the sequence name.  Specifying a schema\n         // name on the annotation or in the orm will override the old \n         // behavior.\n-        String schemaName = _schema;\n-        if (schemaName == null || schemaName.length() == 0) {\n-            schemaName = Strings.getPackageName(_seqName);\n-            if (schemaName.length() == 0)\n-                schemaName = Schemas.getNewTableSchema(_conf);\n+        DBIdentifier schemaName = _schema;\n+        if (DBIdentifier.isEmpty(schemaName)) {\n+            schemaName = path.getSchemaName();\n+            if (DBIdentifier.isEmpty(schemaName))\n+                schemaName = Schemas.getNewTableSchemaIdentifier(_conf);\n         }\n \n         // build the sequence in one of the designated schemas\n         SchemaGroup group = new SchemaGroup();\n         Schema schema = group.addSchema(schemaName);\n \n         _seq = schema.addSequence(seqName);\n-        // TODO: temp until a global name solution is implemented\n-        schema.addDelimSequenceName(_conf.getDBDictionaryInstance().addDelimiters(seqName), _seq);\n         _seq.setInitialValue(_initial);\n         _seq.setIncrement(_increment);\n         _seq.setAllocate(_allocate);\n@@ -402,11 +403,22 @@ else if (ACTION_GET.equals(action)) {\n         return true;\n     }\n \n-    public void setSchema(String _schema) {\n-        this._schema = _schema;\n+    /**\n+     * @deprecated\n+     */\n+    public void setSchema(String schema) {\n+        _schema = DBIdentifier.newSchema(schema);\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public String getSchema() {\n+        return _schema.getName();\n+    }\n+\n+    public DBIdentifier getSchemaIdentifier() {\n         return _schema;\n     }\n+\n }"},{"sha":"c418c64ba5dddccff4448acea8cb053e28667cec","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManagerImpl.java","status":"modified","additions":37,"deletions":8,"changes":45,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PreparedStatementManagerImpl.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -29,6 +29,8 @@\n import java.util.List;\n \n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n@@ -167,10 +169,10 @@ private boolean hasGeneratedKey(ClassMapping meta) {\n      * from the result set associated with the stmnt. If not, a separate \n      * sql to select the key will be issued from DBDictionary. \n      */\n-    protected List populateAutoAssignCols(PreparedStatement stmnt, \n-        Column[] autoAssign, String[] autoAssignColNames, RowImpl row) \n+    protected List<Object> populateAutoAssignCols(PreparedStatement stmnt, \n+        Column[] autoAssign, DBIdentifier[] autoAssignColNames, RowImpl row) \n         throws SQLException {\n-        List vals = null;\n+        List<Object> vals = null;\n         if (_dict.supportsGetGeneratedKeys) {\n             // set auto assign values to id col\n             vals = getGeneratedKeys(stmnt, autoAssignColNames);\n@@ -179,9 +181,22 @@ protected List populateAutoAssignCols(PreparedStatement stmnt,\n         return vals;\n     }\n \n+    protected List<Object> populateAutoAssignCols(PreparedStatement stmnt, \n+        Column[] autoAssign, String[] autoAssignColNames, RowImpl row) \n+        throws SQLException {\n+        return populateAutoAssignCols(stmnt, autoAssign, \n+            DBIdentifier.toArray(autoAssignColNames, DBIdentifierType.COLUMN), row);\n+    }\n+    \n     protected void setObjectId(List vals, Column[] autoAssign,\n         String[] autoAssignColNames, RowImpl row) \n         throws SQLException{\n+        setObjectId(vals, autoAssign, DBIdentifier.toArray(autoAssignColNames, DBIdentifierType.COLUMN), row);\n+    }\n+    \n+    protected void setObjectId(List vals, Column[] autoAssign,\n+        DBIdentifier[] autoAssignColNames, RowImpl row) \n+        throws SQLException{\n         OpenJPAStateManager sm = row.getPrimaryKey();\n         ClassMapping mapping = (ClassMapping) sm.getMetaData();\n         Object val = null;\n@@ -202,9 +217,15 @@ protected void setObjectId(List vals, Column[] autoAssign,\n      * This method will only be called when the database supports\n      * getGeneratedKeys.\n      */\n-    protected List getGeneratedKeys(PreparedStatement stmnt, \n+    protected List<Object> getGeneratedKeys(PreparedStatement stmnt, \n         String[] autoAssignColNames) \n         throws SQLException {\n+        return getGeneratedKeys(stmnt, DBIdentifier.toArray(autoAssignColNames, DBIdentifierType.COLUMN));\n+    }\n+\n+    protected List<Object> getGeneratedKeys(PreparedStatement stmnt, \n+        DBIdentifier[] autoAssignColNames) \n+        throws SQLException {\n         ResultSet rs = stmnt.getGeneratedKeys();\n         List<Object> vals = new ArrayList<Object>();\n         while (rs.next()) {\n@@ -222,14 +243,22 @@ protected List getGeneratedKeys(PreparedStatement stmnt,\n         return autoAssign;\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     protected String[] getAutoAssignColNames(Column[] autoAssign, RowImpl row) {\n-        String[] autoAssignColNames = null;\n+        DBIdentifier[] names =  getAutoAssignColIdentifiers(autoAssign, row);\n+        return DBIdentifier.toStringArray(names);\n+    }\n+\n+    protected DBIdentifier[] getAutoAssignColIdentifiers(Column[] autoAssign, RowImpl row) {\n+        DBIdentifier[] autoAssignColNames = null;\n         if (autoAssign != null && autoAssign.length > 0\n             && row.getPrimaryKey() != null) {\n-            autoAssignColNames = new String[autoAssign.length];\n+            autoAssignColNames = new DBIdentifier[autoAssign.length];\n             for (int i = 0; i < autoAssign.length; i++)\n-                autoAssignColNames[i] =\n-                    _dict.convertSchemaCase(autoAssign[i].getName());\n+                autoAssignColNames[i] = autoAssign[i].getIdentifier();\n+//                    _dict.convertSchemaCase(.getName());\n         }\n         return autoAssignColNames;\n     }"},{"sha":"84471026a80d84d05d8545b9fd7f8a3c94c9ed8e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java","status":"modified","additions":87,"deletions":51,"changes":138,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/TableJDBCSeq.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -31,6 +31,10 @@\n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n+import org.apache.openjpa.jdbc.identifier.Normalizer;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.QualifiedDBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.PrimaryKey;\n@@ -46,6 +50,7 @@\n import org.apache.openjpa.lib.conf.Configurable;\n import org.apache.openjpa.lib.conf.Configuration;\n import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.lib.util.Options;\n@@ -54,7 +59,6 @@\n import org.apache.openjpa.util.UserException;\n \n import serp.util.Numbers;\n-import serp.util.Strings;\n \n ////////////////////////////////////////////////////////////\n // NOTE: Do not change property names; see SequenceMetaData\n@@ -88,11 +92,11 @@\n     private final HashMap<ClassMapping, Status> _stat =\n         new HashMap<ClassMapping, Status>();\n \n-    private String _table = DEFAULT_TABLE;\n-    private String _seqColumnName = \"SEQUENCE_VALUE\";\n-    private String _pkColumnName = \"ID\";\n-    private String[] _uniqueColumnNames;\n-    private String _uniqueConstraintName;\n+    private DBIdentifier _table = DBIdentifier.newTable(DEFAULT_TABLE);\n+    private DBIdentifier _seqColumnName = DBIdentifier.newColumn(\"SEQUENCE_VALUE\");\n+    private DBIdentifier _pkColumnName = DBIdentifier.newColumn(\"ID\");\n+    private DBIdentifier[] _uniqueColumnNames;\n+    private DBIdentifier _uniqueConstraintName = DBIdentifier.NULL;\n \n     private Column _seqColumn = null;\n     private Column _pkColumn = null;\n@@ -106,7 +110,7 @@\n      * will be used.\n      */\n     public String getTable() {\n-        return _table;\n+        return _table.getName();\n     }\n \n     /**\n@@ -118,7 +122,10 @@ public String getTable() {\n      * will be used.\n      */\n     public void setTable(String name) {\n-        _table = name;\n+        // Split the name into its individual parts\n+        String[] names = Normalizer.splitName(name);\n+        // Join the name back together.  This will delimit as appropriate.\n+        _table = DBIdentifier.newTable(Normalizer.joinNames(names));\n     }\n \n     /**\n@@ -134,22 +141,26 @@ public void setTableName(String name) {\n      * to <code>SEQUENCE_VALUE</code>.\n      */\n     public String getSequenceColumn() {\n-        return _seqColumnName;\n+        return _seqColumnName.getName();\n     }\n \n     /**\n      * The name of the column that holds the sequence value. Defaults\n      * to <code>SEQUENCE_VALUE</code>.\n      */\n     public void setSequenceColumn(String sequenceColumn) {\n-        _seqColumnName = sequenceColumn;\n+        _seqColumnName = DBIdentifier.newColumn(sequenceColumn);\n     }\n \n     /**\n      * The name of the table's primary key column. Defaults to\n      * <code>ID</code>.\n      */\n     public String getPrimaryKeyColumn() {\n+        return _pkColumnName.getName();\n+    }\n+\n+    public DBIdentifier getPrimaryKeyColumnIdentifier() {\n         return _pkColumnName;\n     }\n \n@@ -158,7 +169,7 @@ public String getPrimaryKeyColumn() {\n      * <code>ID</code>.\n      */\n     public void setPrimaryKeyColumn(String primaryKeyColumn) {\n-        _pkColumnName = primaryKeyColumn;\n+        _pkColumnName = DBIdentifier.newColumn(primaryKeyColumn);\n     }\n \n     /**\n@@ -186,7 +197,7 @@ public void setAllocate(int alloc) {\n      * GeneratedValue.TABLE strategy to start with. \n      * @return an initial number\n      */\n-    public int getInitialValue() {        \n+    public int getInitialValue() {\n         return _intValue;\n     }\n \n@@ -206,11 +217,11 @@ public void setInitialValue(int intValue) {\n      */\n     public void setUniqueColumns(String columnNames) {\n     \t_uniqueColumnNames = (StringUtils.isEmpty(columnNames)) \n-    \t\t? null : StringUtils.split(columnNames, '|');\n+    \t\t? null : DBIdentifier.split(columnNames, DBIdentifierType.COLUMN, IdentifierUtil.BAR);\n     }\n     \n     public String getUniqueColumns() {\n-    \treturn StringUtils.join(_uniqueColumnNames, '|');\n+    \treturn Normalizer.joinNames(DBIdentifier.toStringArray(_uniqueColumnNames), IdentifierUtil.BAR);\n     }\n \n     /**\n@@ -245,16 +256,20 @@ public void addSchema(ClassMapping mapping, SchemaGroup group) {\n         \n         Schema[] schemas = group.getSchemas();\n         for (int i = 0; i < schemas.length; i++) {\n-            String schemaName = Strings.getPackageName(_table);\n-            if (schemaName.length() == 0)\n-                schemaName = Schemas.getNewTableSchema(_conf);\n-            if (schemaName == null)\n-                schemaName = schemas[i].getName();\n+            QualifiedDBIdentifier path = QualifiedDBIdentifier.getPath(_table);\n+            DBIdentifier schemaName = path.getSchemaName();\n+            if (DBIdentifier.isEmpty(schemaName)) {\n+                schemaName = Schemas.getNewTableSchemaIdentifier(_conf);\n+            }\n+            if (DBIdentifier.isNull(schemaName)) {\n+                schemaName = schemas[i].getIdentifier();\n+            }\n \n             // create table in this group\n             Schema schema = group.getSchema(schemaName);\n-            if (schema == null)\n+            if (schema == null) {\n                 schema = group.addSchema(schemaName);\n+            }\n             \n             Table copy = schema.importTable(_pkColumn.getTable());\n             // importTable() does not import unique constraints\n@@ -265,8 +280,7 @@ public void addSchema(ClassMapping mapping, SchemaGroup group) {\n             // we need to reset the table name in the column with the\n             // fully qualified name for matching the table name from the\n             // Column.\n-            _pkColumn.resetTableName(schemaName + \".\"\n-                    + _pkColumn.getTableName());\n+            _pkColumn.resetTableIdentifier(QualifiedDBIdentifier.newPath(schemaName, _pkColumn.getTableIdentifier()));\n             // some databases require to create an index for the sequence table\n             _conf.getDBDictionaryInstance().createIndexIfNecessary(schema,\n                     _table, _pkColumn);\n@@ -351,7 +365,7 @@ protected Status getStatus(ClassMapping mapping) {\n     protected Column addPrimaryKeyColumn(Table table) {\n         DBDictionary dict = _conf.getDBDictionaryInstance();\n         Column pkColumn = table.addColumn(dict.getValidColumnName\n-            (getPrimaryKeyColumn(), table));\n+            (getPrimaryKeyColumnIdentifier(), table));\n         pkColumn.setType(dict.getPreferredType(Types.TINYINT));\n         pkColumn.setJavaType(JavaTypes.INT);\n         return pkColumn;\n@@ -368,20 +382,20 @@ protected Object getPrimaryKey(ClassMapping mapping) {\n      * Creates the object-level representation of the sequence table.\n      */\n     private void buildTable() {\n-        String tableName = null;\n-        String schemaName = \"\";\n-        if (StringUtils.contains(_table,'.')) {\n-            String[] tableParts = StringUtils.split(_table, '.');\n-            // TODO: do we need to check for length? Could we have xxx. or .xxx?\n-            schemaName = tableParts[0];\n-            tableName = tableParts[1];\n+        DBIdentifier tableName = DBIdentifier.NULL;\n+        DBIdentifier schemaName = DBIdentifier.NULL;\n+        QualifiedDBIdentifier path = QualifiedDBIdentifier.getPath(_table);\n+        if (!DBIdentifier.isEmpty(path.getSchemaName())) {\n+            schemaName = path.getSchemaName();\n+            tableName = path.getUnqualifiedName();\n         }\n         else {\n             tableName = _table;\n         }\n         \n-        if (schemaName.length() == 0)\n-            schemaName = Schemas.getNewTableSchema(_conf);\n+        if (DBIdentifier.isEmpty(schemaName)) {\n+            schemaName = Schemas.getNewTableSchemaIdentifier(_conf);\n+        }\n \n         SchemaGroup group = new SchemaGroup();\n         Schema schema = group.addSchema(schemaName);\n@@ -398,17 +412,17 @@ private void buildTable() {\n         _seqColumn.setJavaType(JavaTypes.LONG);\n         \n         if (_uniqueColumnNames != null) {\n-            String uniqueName = _uniqueConstraintName;\n-            if (StringUtils.isEmpty(uniqueName)) {\n-                uniqueName = dict.getValidUniqueName(\"UNQ\", table);\n+            DBIdentifier uniqueName = _uniqueConstraintName;\n+            if (DBIdentifier.isEmpty(uniqueName)) {\n+                uniqueName = dict.getValidUniqueName(DBIdentifier.newConstraint(\"UNQ\"), table);\n             }\n     \t\tUnique u = table.addUnique(uniqueName);\n-    \t\tfor (String columnName : _uniqueColumnNames) {\n+    \t\tfor (DBIdentifier columnName : _uniqueColumnNames) {\n     \t\t\tif (!table.containsColumn(columnName, _conf.getDBDictionaryInstance()))\n                     throw new UserException(_loc.get(\"unique-missing-column\",\n-                            columnName, table.getName(),\n+                            columnName, table.getIdentifier(),\n                             table.getColumnNames()));\n-    \t\t\tColumn col = table.getColumn(columnName, _conf.getDBDictionaryInstance());\n+    \t\t\tColumn col = table.getColumn(columnName);\n     \t\t\tu.addColumn(col);\n     \t\t}\n         }\n@@ -469,7 +483,7 @@ private void insertSequence(ClassMapping mapping, Connection conn)\n                 getClass(), mapping));\n \n         DBDictionary dict = _conf.getDBDictionaryInstance();\n-        String tableName = resolveTableName(mapping, _pkColumn.getTable());\n+        DBIdentifier tableName = resolveTableIdentifier(mapping, _pkColumn.getTable());\n         SQLBuffer insert = new SQLBuffer(dict).append(\"INSERT INTO \").\n             append(tableName).append(\" (\").\n             append(_pkColumn).append(\", \").append(_seqColumn).\n@@ -519,7 +533,7 @@ protected long getSequence(ClassMapping mapping, Connection conn)\n         SQLBuffer sel = new SQLBuffer(dict).append(_seqColumn);\n         SQLBuffer where = new SQLBuffer(dict).append(_pkColumn).append(\" = \").\n             appendValue(pk, _pkColumn);\n-        String tableName = resolveTableName(mapping, _seqColumn.getTable());\n+        DBIdentifier tableName = resolveTableIdentifier(mapping, _seqColumn.getTable());\n         SQLBuffer tables = new SQLBuffer(dict).append(tableName);\n \n         SQLBuffer select = dict.toSelect(sel, null, tables, where, null, null,\n@@ -577,7 +591,7 @@ protected boolean setSequence(ClassMapping mapping, Status stat, int inc,\n \n                 // update the value\n                 upd = new SQLBuffer(dict);\n-                String tableName = resolveTableName(mapping,\n+                DBIdentifier tableName = resolveTableIdentifier(mapping,\n                         _seqColumn.getTable());\n                 upd.append(\"UPDATE \").append(tableName).\n                     append(\" SET \").append(_seqColumn).append(\" = \").\n@@ -612,19 +626,32 @@ protected boolean setSequence(ClassMapping mapping, Status stat, int inc,\n      * \n      * @param class\n      *            mapping to get the schema name\n+     * @deprecated\n      */\n     public String resolveTableName(ClassMapping mapping, Table table) {\n-        String sName = mapping.getTable().getSchemaName();\n-        String tableName;\n-        if (sName == null)\n-            tableName = table.getFullName();\n-        else if (table.getSchemaName() != null)\n-            tableName = table.getFullName();\n-        else\n-            tableName = sName + \".\" + table.getName();\n+        return resolveTableIdentifier(mapping, table).getName();\n+    }\n+\n+    /**\n+     * Resolve a fully qualified table name\n+     * \n+     * @param class\n+     *            mapping to get the schema name\n+     */\n+    public DBIdentifier resolveTableIdentifier(ClassMapping mapping, Table table) {\n+        DBIdentifier sName = mapping.getTable().getSchemaIdentifier();\n+        DBIdentifier tableName = DBIdentifier.NULL;\n+        if (DBIdentifier.isNull(sName)) {\n+            tableName = table.getFullIdentifier();\n+        } else if (!DBIdentifier.isNull(table.getSchemaIdentifier())) {\n+            tableName = table.getFullIdentifier();\n+        } else {\n+            tableName = QualifiedDBIdentifier.newPath(sName, table.getIdentifier());\n+        }\n         return tableName;\n     }\n \n+    \n     /**\n      * Creates the sequence table in the DB.\n      */\n@@ -763,6 +790,7 @@ else if (ACTION_GET.equals(action) || ACTION_SET.equals(action)) {\n     /**\n      * Helper struct to hold status information.\n      */\n+    @SuppressWarnings(\"serial\")\n     protected static class Status\n         implements Serializable {\n \n@@ -809,11 +837,19 @@ protected long getSequence(ResultSet rs, DBDictionary dict)\n         return dict.getLong(rs, 1);\n     }\n \n-    public void setUniqueConstraintName(String _uniqueConstraintName) {\n-        this._uniqueConstraintName = _uniqueConstraintName;\n+    public void setUniqueConstraintName(String uniqueConstraintName) {\n+        _uniqueConstraintName = DBIdentifier.newConstraint(uniqueConstraintName);\n+    }\n+\n+    public void setUniqueConstraintName(DBIdentifier uniqueConstraintName) {\n+        _uniqueConstraintName = uniqueConstraintName;\n     }\n \n     public String getUniqueConstraintName() {\n+        return _uniqueConstraintName.getName();\n+    }\n+\n+    public DBIdentifier getUniqueConstraintIdentifier() {\n         return _uniqueConstraintName;\n     }\n "},{"sha":"c98c8349eaf05ee395ee687bc3edb4dbe692b127","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ValueTableJDBCSeq.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ValueTableJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ValueTableJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ValueTableJDBCSeq.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -78,7 +78,7 @@ public void setPrimaryKeyValue(String value) {\n     protected Column addPrimaryKeyColumn(Table table) {\n         DBDictionary dict = getConfiguration().getDBDictionaryInstance();\n         Column pkColumn = table.addColumn(dict.getValidColumnName\n-            (getPrimaryKeyColumn(), table));\n+            (getPrimaryKeyColumnIdentifier(), table));\n         pkColumn.setType(dict.getPreferredType(Types.VARCHAR));\n         pkColumn.setJavaType(JavaTypes.STRING);\n         pkColumn.setSize(dict.characterColumnSize);"},{"sha":"e22509dd94b9e6e8713bcbf70f2b7c61cabfe9c8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/PCPath.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -979,7 +979,7 @@ public void appendTo(Select sel, ExpContext ctx, ExpState state,\n         // if select is null, it means we are not aliasing columns\n         // (e.g., during a bulk update)\n         if (sel == null)\n-            sql.append(col.getName());\n+            sql.append(col.getIdentifier());\n         else if (_type == XPATH)\n             // if this is an xpath, append xpath string\n             sql.append(getXPath());"},{"sha":"fe12a3492b0cd6be33b2178346b7046c8c288366","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -281,7 +281,7 @@ public Joinable assertJoinable(Column col) {\n         Joinable join = getJoinable(col);\n         if (join == null)\n             throw new MetaDataException(_loc.get(\"no-joinable\",\n-                col.getFullName()));\n+                col.getQualifiedPath().toString()));\n         return join;\n     }\n "},{"sha":"5f14db307f9979c4e2d633dd265d4a1ddc8bda6c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMappingInfo.java","status":"modified","additions":135,"deletions":49,"changes":184,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMappingInfo.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -29,7 +29,8 @@\n import java.util.Map;\n import java.util.Map.Entry;\n \n-import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.QualifiedDBIdentifier;\n import org.apache.openjpa.jdbc.meta.strats.FullClassStrategy;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n@@ -51,6 +52,7 @@\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public class ClassMappingInfo\n     extends MappingInfo\n     implements SourceTracker, Commentable {\n@@ -59,10 +61,10 @@\n         (ClassMappingInfo.class);\n \n     private String _className = Object.class.getName();\n-    private String _tableName = null;\n-    private String _schemaName = null;\n+    private DBIdentifier _tableName = DBIdentifier.NULL;\n+    private DBIdentifier _schemaName = DBIdentifier.NULL;\n     private boolean _joined = false;\n-    private Map _seconds = null;\n+    private Map<DBIdentifier, List<Column>> _seconds = null;\n     private String _subStrat = null;\n     private File _file = null;\n     private int _srcType = SRC_OTHER;\n@@ -71,7 +73,7 @@\n     private int _colNum = 0;  \n     \n     // Unique constraints indexed by primary or secondary table name\n-    private Map<String,List<Unique>> _uniques;\n+    private Map<DBIdentifier,List<Unique>> _uniques;\n \n     /**\n      * The described class name.\n@@ -103,29 +105,49 @@ public void setHierarchyStrategy(String strategy) {\n \n     /**\n      * The given table name.\n+     * @deprecated\n      */\n     public String getTableName() {\n-        return _tableName;\n+        return getTableIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getTableIdentifier() {\n+        return _tableName == null ? DBIdentifier.NULL : _tableName;\n     }\n \n     /**\n      * The given table name.\n+     * @deprecated\n      */\n     public void setTableName(String table) {\n+        setTableIdentifier(DBIdentifier.newTable(table));\n+    }\n+\n+    public void setTableIdentifier(DBIdentifier table) {\n         _tableName = table;\n     }\n \n     /**\n      * The default schema name for unqualified tables.\n+     * @deprecated\n      */\n     public String getSchemaName() {\n-        return _schemaName;\n+        return getSchemaIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getSchemaIdentifier() {\n+        return _schemaName == null ? DBIdentifier.NULL : _schemaName;\n     }\n \n     /**\n      * The default schema name for unqualified tables.\n+     * @deprecated\n      */\n     public void setSchemaName(String schema) {\n+        setSchemaIdentifier(DBIdentifier.newSchema(schema));\n+    }\n+\n+    public void setSchemaIdentifier(DBIdentifier schema) {\n         _schemaName = schema;\n     }\n \n@@ -145,45 +167,57 @@ public void setJoinedSubclass(boolean joined) {\n \n     /**\n      * Return the class-level joined tables.\n+     * @deprecated\n      */\n     public String[] getSecondaryTableNames() {\n         if (_seconds == null)\n             return new String[0];\n-        return (String[]) _seconds.keySet().toArray(new String[]{ });\n+        return DBIdentifier.toStringArray(_seconds.keySet().toArray(new DBIdentifier[]{ }));\n+    }\n+\n+    public DBIdentifier[] getSecondaryTableIdentifiers() {\n+        if (_seconds == null)\n+            return new DBIdentifier[0];\n+        return (DBIdentifier[]) _seconds.keySet().toArray(new DBIdentifier[]{ });\n     }\n \n     /**\n      * We allow fields to reference class-level joins using just the table\n      * name, whereas the class join might have schema, etc information.\n      * This method returns the name of the given table as listed in a\n      * class-level join, or the given name if no join exists.\n+     * @deprecated\n      */\n     public String getSecondaryTableName(String tableName) {\n+        return getSecondaryTableIdentifier(DBIdentifier.newTable(tableName)).getName();\n+    }\n+\n+    public DBIdentifier getSecondaryTableIdentifier(DBIdentifier tableName) {\n         // if no secondary table joins, bad table name, exact match,\n         // or an already-qualified table name, nothing to do\n-        if (_seconds == null || tableName == null\n+        QualifiedDBIdentifier path = QualifiedDBIdentifier.getPath(tableName);\n+        if (_seconds == null || DBIdentifier.isNull(tableName)\n             || _seconds.containsKey(tableName)\n-            || tableName.indexOf('.') != -1)\n+            || !DBIdentifier.isNull(path.getSchemaName()))\n             return tableName;\n \n         // decide which class-level join table is best match\n-        String best = tableName;\n+        DBIdentifier best = tableName;\n         int pts = 0;\n-        String fullJoin;\n-        String join;\n-        int idx;\n-        for (Iterator itr = _seconds.keySet().iterator(); itr.hasNext();) {\n+        DBIdentifier fullJoin = DBIdentifier.NULL;\n+        DBIdentifier join = DBIdentifier.NULL;\n+        for (Iterator<DBIdentifier> itr = _seconds.keySet().iterator(); itr.hasNext();) {\n             // award a caseless match without schema 2 points\n-            fullJoin = (String) itr.next();\n-            idx = fullJoin.lastIndexOf('.');\n-            if (idx == -1 && pts < 2 && fullJoin.equalsIgnoreCase(tableName)) {\n+            fullJoin = (DBIdentifier) itr.next();\n+            QualifiedDBIdentifier joinPath = QualifiedDBIdentifier.getPath(fullJoin);\n+            if (joinPath.isUnqualifiedObject() && pts < 2 && fullJoin.equalsIgnoreCase(tableName)) {\n                 best = fullJoin;\n                 pts = 2;\n-            } else if (idx == -1)\n+            } else if (joinPath.isUnqualifiedObject())\n                 continue;\n \n             // immediately return an exact match with schema\n-            join = fullJoin.substring(idx + 1);\n+            join = joinPath.getIdentifier();\n             if (join.equals(tableName))\n                 return fullJoin;\n \n@@ -199,48 +233,78 @@ public String getSecondaryTableName(String tableName) {\n     /**\n      * Return any columns defined for the given class level join, or empty\n      * list if none.\n+     * @deprecated\n      */\n-    public List getSecondaryTableJoinColumns(String tableName) {\n-        if (_seconds == null || tableName == null)\n-            return Collections.EMPTY_LIST;\n+    public List<Column> getSecondaryTableJoinColumns(String tableName) {\n+        return getSecondaryTableJoinColumns(DBIdentifier.newTable(tableName));\n+    }\n+\n+    public List<Column> getSecondaryTableJoinColumns(DBIdentifier tableName) {\n+        if (_seconds == null || DBIdentifier.isNull(tableName)) {\n+            return Collections.emptyList();\n+        }\n \n         // get the columns for the join with the best match for table name\n-        List cols = (List) _seconds.get(getSecondaryTableName(tableName));\n+        List<Column> cols = _seconds.get(getSecondaryTableIdentifier(tableName));\n         if (cols == null) {\n             // possible that given table has extra info the join table\n             // doesn't have; strip it\n-            int idx = tableName.lastIndexOf('.');\n-            if (idx != -1) {\n-                tableName = tableName.substring(idx + 1);\n-                cols = (List) _seconds.get(getSecondaryTableName(tableName));\n+            QualifiedDBIdentifier path = QualifiedDBIdentifier.getPath(tableName);\n+            if (!DBIdentifier.isNull(path.getSchemaName())) {\n+                tableName = path.getIdentifier();\n+                cols = _seconds.get(getSecondaryTableIdentifier(tableName));\n             }\n         }\n-        return (cols == null) ? Collections.EMPTY_LIST : cols;\n+        if (cols == null) {\n+            return Collections.emptyList();\n+        }\n+        return cols;\n     }\n     \n     /**\n      * Adds a Secondary table of given name to this mapping. A secondary table \n      * must be known before unique constraints are added to a Secondary table.\n+     * @deprecated\n      */\n     public void addSecondaryTable(String second) {\n-    \tsetSecondaryTableJoinColumns(second, null);\n+    \tsetSecondaryTableJoinColumns(DBIdentifier.newTable(second), null);\n+    }\n+\n+    public void addSecondaryTable(DBIdentifier second) {\n+        setSecondaryTableJoinColumns(second, null);\n     }\n \n     /**\n      * Declare the given class-level join to the named (secondary) table.\n+     * @deprecated\n      */\n-    public void setSecondaryTableJoinColumns(String tableName, List cols) {\n+    public void setSecondaryTableJoinColumns(String tableName, List<Column> cols) {\n+        if (cols == null)\n+            cols = Collections.emptyList();\n+        setSecondaryTableJoinColumns(DBIdentifier.newTable(tableName), cols);\n+    }\n+\n+    public void setSecondaryTableJoinColumns(DBIdentifier tableName, List<Column> cols) {\n         if (cols == null)\n-            cols = Collections.EMPTY_LIST;\n+            cols = Collections.emptyList();\n         if (_seconds == null)\n-            _seconds = new LinkedHashMap();\n+            _seconds = new LinkedHashMap<DBIdentifier, List<Column>>();\n         _seconds.put(tableName, cols);\n     }\n     \n     /**\n      * Return the named table for the given class.\n+     * @deprecated\n      */\n     public Table getTable(final ClassMapping cls, String tableName, \n+        boolean adapt) {\n+        return getTable(cls, DBIdentifier.newTable(tableName), adapt);\n+    }\n+\n+    /**\n+     * Return the named table for the given class.\n+     */\n+    public Table getTable(final ClassMapping cls, DBIdentifier tableName, \n     \t\tboolean adapt) {\n         Table t = createTable(cls, new TableDefaults() {\n             public String get(Schema schema) {\n@@ -249,6 +313,10 @@ public String get(Schema schema) {\n                 return cls.getMappingRepository().getMappingDefaults().\n                     getTableName(cls, schema);\n             }\n+            public DBIdentifier getIdentifier(Schema schema) {\n+                return cls.getMappingRepository().getMappingDefaults().\n+                    getTableIdentifier(cls, schema);\n+            }\n         }, _schemaName, tableName, adapt);\n         t.setComment(cls.getTypeAlias() == null\n             ? cls.getDescribedType().getName()\n@@ -312,7 +380,7 @@ public void syncWith(ClassMapping cls) {\n         if (cls.getTable() != null && (sup == null\n             || sup.getTable() != cls.getTable()))\n             _tableName = cls.getMappingRepository().getDBDictionary().\n-                getFullName(cls.getTable(), true);\n+                getFullIdentifier(cls.getTable(), true);\n \n         // set io before syncing cols\n         setColumnIO(cls.getColumnIO());\n@@ -334,12 +402,12 @@ else if (cls.getIdentityType() == ClassMapping.ID_DATASTORE)\n     }\n \n     public boolean hasSchemaComponents() {\n-        return super.hasSchemaComponents() || _tableName != null;\n+        return super.hasSchemaComponents() || !DBIdentifier.isNull(_tableName);\n     }\n \n     protected void clear(boolean canFlags) {\n         super.clear(canFlags);\n-        _tableName = null;\n+        _tableName = DBIdentifier.NULL;\n     }\n \n     public void copy(MappingInfo info) {\n@@ -348,15 +416,15 @@ public void copy(MappingInfo info) {\n             return;\n \n         ClassMappingInfo cinfo = (ClassMappingInfo) info;\n-        if (_tableName == null)\n-            _tableName = cinfo.getTableName();\n+        if (DBIdentifier.isNull(_tableName))\n+            _tableName = cinfo.getTableIdentifier();\n         if (_subStrat == null)\n             _subStrat = cinfo.getHierarchyStrategy();\n         if (cinfo._seconds != null) {\n             if (_seconds == null)\n-                _seconds = new HashMap();\n-            Object key;\n-            for (Iterator itr = cinfo._seconds.keySet().iterator();\n+                _seconds = new HashMap<DBIdentifier, List<Column>>();\n+            DBIdentifier key;\n+            for (Iterator<DBIdentifier> itr = cinfo._seconds.keySet().iterator();\n                 itr.hasNext();) {\n                 key = itr.next();\n                 if (!_seconds.containsKey(key))\n@@ -365,8 +433,8 @@ public void copy(MappingInfo info) {\n         }\n         if (cinfo._uniques != null) {\n         \tif (_uniques == null)\n-        \t\t_uniques = new HashMap<String, List<Unique>>();\n-        for (Entry<String, List<Unique>> entry : cinfo._uniques.entrySet())\n+        \t\t_uniques = new HashMap<DBIdentifier, List<Unique>>();\n+        for (Entry<DBIdentifier, List<Unique>> entry : cinfo._uniques.entrySet())\n         \t\tif (!_uniques.containsKey(entry.getKey()))\n         \t\t\t_uniques.put(entry.getKey(), entry.getValue());\n         }\n@@ -378,9 +446,20 @@ public void copy(MappingInfo info) {\n      * @param table must be primary table or secondary table name added a \n      * priori to this receiver.\n      * @param unique the unique constraint. null means no-op.\n+     * @deprecated\n      */\n     public void addUnique(String table, Unique unique) {\n-    \tif (!StringUtils.equals(_tableName, table) &&\n+        addUnique(DBIdentifier.newTable(table), unique);\n+    }\n+\n+    /**\n+     * Add a unique constraint for the given table.\n+     * @param table must be primary table or secondary table name added a \n+     * priori to this receiver.\n+     * @param unique the unique constraint. null means no-op.\n+     */\n+    public void addUnique(DBIdentifier table, Unique unique) {\n+    \tif (!DBIdentifier.equal(_tableName, table) &&\n     \t   (_seconds == null || !_seconds.containsKey(table))) {\n             throw new UserException(_loc.get(\"unique-no-table\", \n                     new Object[]{table, _className, _tableName, \n@@ -389,8 +468,8 @@ public void addUnique(String table, Unique unique) {\n     \tif (unique == null)\n     \t\treturn;\n         if (_uniques == null)\n-            _uniques = new HashMap<String,List<Unique>>();\n-        unique.setTableName(table);\n+            _uniques = new HashMap<DBIdentifier,List<Unique>>();\n+        unique.setTableIdentifier(table);\n         List<Unique> uniques = _uniques.get(table);\n         if (uniques == null) {\n         \tuniques = new ArrayList<Unique>();\n@@ -403,8 +482,16 @@ public void addUnique(String table, Unique unique) {\n     \n     /**\n      * Get the unique constraints of the given primary or secondary table.\n+     * @deprecated\n      */\n     public Unique[] getUniques(String table) {\n+        return getUniques(DBIdentifier.newTable(table));\n+    }\n+\n+    /**\n+     * Get the unique constraints of the given primary or secondary table.\n+     */\n+    public Unique[] getUniques(DBIdentifier table) {\n         if (_uniques == null || _uniques.isEmpty() \n         || _uniques.containsKey(table))\n             return new Unique[0];\n@@ -421,14 +508,14 @@ public void addUnique(String table, Unique unique) {\n         if (_uniques == null || _uniques.isEmpty())\n             return new Unique[0];\n         List<Unique> result = new ArrayList<Unique>();\n-        for (String tableName : _uniques.keySet()) {\n+        for (DBIdentifier tableName : _uniques.keySet()) {\n         \tList<Unique> uniqueConstraints = _uniques.get(tableName);\n         \tfor (Unique template : uniqueConstraints) {\n         \t\tColumn[] templateColumns = template.getColumns();\n                 Column[] uniqueColumns = new Column[templateColumns.length];\n                 Table table = getTable((ClassMapping)cm, tableName, adapt);\n         \t\tfor (int i=0; i<uniqueColumns.length; i++) {\n-                    String columnName = templateColumns[i].getName();\n+                    DBIdentifier columnName = templateColumns[i].getIdentifier();\n         \t\t\tif (!table.containsColumn(columnName)) {\n                         throw new UserException(_loc.get(\n                                 \"unique-missing-column\", \n@@ -491,5 +578,4 @@ public int getColNumber() {\n     public void setColNumber(int colNum) {\n         _colNum = colNum;\n     }\n-    \n }"},{"sha":"e36c5df187e4befdda474987a2760f3371308e55","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassStrategy.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassStrategy.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -107,7 +107,7 @@ public boolean customLoad(OpenJPAStateManager sm, JDBCStore store,\n     /**\n      * Implement this method to customize loading from a {@link Result}\n      * into an instance. Return true if this mapping handles the\n-     * load; false if normal loading should procede after calling this method.\n+     * load; false if normal loading should proceed after calling this method.\n      */\n     public boolean customLoad(OpenJPAStateManager sm, JDBCStore store,\n         JDBCFetchConfiguration fetch, Result result)"},{"sha":"03f86aedb46e446745d68157cb4d47ef377b0405","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DelegatingJoinable.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DelegatingJoinable.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DelegatingJoinable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DelegatingJoinable.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -41,6 +41,7 @@\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public class DelegatingJoinable\n     implements Joinable {\n \n@@ -68,7 +69,7 @@ public DelegatingJoinable(Joinable join, ForeignKey fk) {\n             _cols[i] = fk.getColumn(pks[i]);\n             if (_cols[i] == null)\n                 throw new MetaDataException(_loc.get(\"incomplete-join\",\n-                    pks[i].getFullName()));\n+                    pks[i].getFullDBIdentifier()));\n         }\n     }\n \n@@ -84,7 +85,7 @@ public DelegatingJoinable(Joinable join, Column[] cols) {\n         _cols = cols;\n         if (cols.length != join.getColumns().length)\n             throw new MetaDataException(_loc.get(\"bad-remap\",\n-                join.getColumns()[0].getFullName()));\n+                join.getColumns()[0].getFullDBIdentifier()));\n     }\n \n     public int getFieldIndex() {"},{"sha":"e2776658c7d9aead29fe91e5c5f0b59104390fa0","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Discriminator.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Discriminator.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Discriminator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/Discriminator.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -33,7 +33,6 @@\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.util.Localizer;\n-import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.meta.MetaDataContext;\n import org.apache.openjpa.meta.MetaDataModes;\n import org.apache.openjpa.meta.MetaDataRepository;\n@@ -44,6 +43,7 @@\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public class Discriminator\n     implements DiscriminatorStrategy, MetaDataContext, MetaDataModes {\n \n@@ -393,7 +393,7 @@ public void loadSubclasses(JDBCStore store)\n         assertStrategy().loadSubclasses(store);\n     }\n \n-    public Class getClass(JDBCStore store, ClassMapping base, Result result)\n+    public Class<?> getClass(JDBCStore store, ClassMapping base, Result result)\n         throws SQLException, ClassNotFoundException {\n         return assertStrategy().getClass(store, base, result);\n     }"},{"sha":"7466c3cdeadc5f830031f159e334f4a0ef63d137","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorMappingInfo.java","status":"modified","additions":1,"deletions":5,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorMappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorMappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorMappingInfo.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -28,9 +28,7 @@\n import org.apache.openjpa.jdbc.schema.Index;\n import org.apache.openjpa.jdbc.schema.SchemaGroup;\n import org.apache.openjpa.jdbc.schema.Table;\n-import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.meta.JavaTypes;\n-import org.apache.openjpa.util.MetaDataException;\n \n /**\n  * Information about the mapping from a discriminator to the schema, in\n@@ -40,12 +38,10 @@\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public class DiscriminatorMappingInfo\n     extends MappingInfo {\n \n-    private static final Localizer _loc = Localizer.forPackage\n-        (DiscriminatorMappingInfo.class);\n-\n     private String _value = null;\n     \n     /**"},{"sha":"24245d89b44499d94996f5657167ed7f9320c47b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorStrategy.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/DiscriminatorStrategy.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -58,7 +58,7 @@ public void loadSubclasses(JDBCStore store)\n     /**\n      * Return the class for the current result row.\n      */\n-    public Class getClass(JDBCStore store, ClassMapping base, Result result)\n+    public Class<?> getClass(JDBCStore store, ClassMapping base, Result result)\n         throws SQLException, ClassNotFoundException;\n \n     /**"},{"sha":"af44cdf988544ccb771729c6ccb156e760faed90","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMapping.java","status":"modified","additions":12,"deletions":3,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMapping.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMapping.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -23,6 +23,7 @@\n \n import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.enhance.Reflection;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.strats.NoneFieldStrategy;\n@@ -58,6 +59,7 @@\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public class FieldMapping\n     extends FieldMetaData\n     implements ValueMapping, FieldStrategy {\n@@ -98,7 +100,7 @@\n     /**\n      * Constructor.\n      */\n-    public FieldMapping(String name, Class type, ClassMapping owner) {\n+    public FieldMapping(String name, Class<?> type, ClassMapping owner) {\n         super(name, type, owner);\n         _info = owner.getMappingRepository().newMappingInfo(this);\n         _val = (ValueMapping) getValue();\n@@ -623,7 +625,7 @@ public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n \n     private void setPKValueFromMappedByIdField(OpenJPAStateManager sm) {\n         if (sm instanceof StateManagerImpl) {\n-            List mappedByIdFields = ((StateManagerImpl)sm).\n+            List<FieldMetaData> mappedByIdFields = ((StateManagerImpl)sm).\n                 getMappedByIdFields();\n             if (mappedByIdFields == null)\n                 return;\n@@ -1161,10 +1163,17 @@ public void setPolymorphic(int poly) {\n         _val.setPolymorphic(poly);\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public void mapConstraints(String name, boolean adapt) {\n         _val.mapConstraints(name, adapt);\n     }\n \n+    public void mapConstraints(DBIdentifier name, boolean adapt) {\n+        _val.mapConstraints(name, adapt);\n+    }\n+\n     public void copyMappingInfo(ValueMapping vm) {\n         _val.copyMappingInfo(vm);\n     }\n@@ -1326,7 +1335,7 @@ public void setBi1MJoinTableInfo() {\n             if (mapped != null) {\n                 FieldMappingInfo info = getMappingInfo();\n                 FieldMappingInfo mappedInfo = mapped.getMappingInfo();\n-                info.setTableName(mappedInfo.getTableName());\n+                info.setTableIdentifier(mappedInfo.getTableIdentifier());\n                 info.setColumns(mapped.getElementMapping().getValueInfo().getColumns());\n                 getElementMapping().getValueInfo().setColumns(\n                     mappedInfo.getColumns());"},{"sha":"ced9c7c0a91c540f60cd15071eec43ba0a716d23","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMappingInfo.java","status":"modified","additions":40,"deletions":22,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/FieldMappingInfo.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -22,8 +22,7 @@\n import java.util.Collection;\n import java.util.List;\n \n-import org.apache.openjpa.conf.Compatibility;\n-import org.apache.openjpa.jdbc.meta.strats.MapTableFieldStrategy;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n@@ -47,14 +46,15 @@\n  * @author Abe White\n  * @author Pinaki Poddar\n  */\n+@SuppressWarnings(\"serial\")\n public class FieldMappingInfo\n     extends MappingInfo\n     implements Commentable {\n \n     private static final Localizer _loc = Localizer.forPackage\n         (FieldMappingInfo.class);\n \n-    private String _tableName = null;\n+    private DBIdentifier _tableName = DBIdentifier.NULL;\n     private boolean _outer = false;\n     private Column _orderCol = null;\n     private boolean _canOrderCol = true;\n@@ -63,15 +63,25 @@\n \n     /**\n      * The user-supplied name of the table for this field.\n+     * @deprecated\n      */\n     public String getTableName() {\n-        return _tableName;\n+        return getTableIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getTableIdentifier() {\n+        return _tableName == null ? DBIdentifier.NULL : _tableName;\n     }\n \n     /**\n      * The user-supplied name of the table for this field.\n+     * @deprecated\n      */\n     public void setTableName(String tableName) {\n+        setTableIdentifier(DBIdentifier.newTable(tableName));\n+    }\n+\n+    public void setTableIdentifier(DBIdentifier tableName) {\n         _tableName = tableName;\n     }\n \n@@ -124,19 +134,19 @@ public void setCanOrderColumn(boolean canOrder) {\n      */\n     public Table getTable(final FieldMapping field, boolean create,\n         boolean adapt) {\n-        if (_tableName == null && !create)\n+        if (DBIdentifier.isNull(_tableName) && !create)\n             return null;\n \n         Table table = field.getDefiningMapping().getTable();\n-        String schemaName = (table == null) ? null \n-            : table.getSchema().getName();\n+        DBIdentifier schemaName = (table == null) ? DBIdentifier.NULL \n+            : table.getSchema().getIdentifier();\n \n         // if we have no join columns defined, there may be class-level join\n         // information with a more fully-qualified name for our table\n-        String tableName = _tableName;\n-        if (tableName != null && getColumns().isEmpty())\n+        DBIdentifier tableName = _tableName;\n+        if (!DBIdentifier.isNull(tableName) && getColumns().isEmpty())\n             tableName = field.getDefiningMapping().getMappingInfo().\n-                getSecondaryTableName(tableName);\n+                getSecondaryTableIdentifier(tableName);\n \n         return createTable(field, new TableDefaults() {\n             public String get(Schema schema) {\n@@ -145,13 +155,18 @@ public String get(Schema schema) {\n                 return field.getMappingRepository().getMappingDefaults().\n                     getTableName(field, schema);\n             }\n+            public DBIdentifier getIdentifier(Schema schema) {\n+                // TODO Auto-generated method stub\n+                return field.getMappingRepository().getMappingDefaults().\n+                    getTableIdentifier(field, schema);\n+            }\n         }, schemaName, tableName, adapt);\n     }\n \n     public ForeignKey getJoinForeignKey (final FieldMapping field, Table table,\n         boolean adapt) {\n         if (field.isUni1ToMFK()) {\n-            List cols = field.getElementMapping().getValueInfo().getColumns();\n+            List<Column> cols = field.getElementMapping().getValueInfo().getColumns();\n             return getJoin(field, table, adapt, cols);\n         }\n         return null;\n@@ -168,7 +183,7 @@ public ForeignKey getJoin(final FieldMapping field, Table table,\n     }\n     \n     public ForeignKey getJoin(final FieldMapping field, Table table,\n-            boolean adapt, List cols) {\n+            boolean adapt, List<Column> cols) {\n         if (cols.isEmpty()) {\n         \tClassMapping mapping;\n         \tif (field.isEmbedded() && \n@@ -251,7 +266,7 @@ public void addJoinTableUnique(Unique u) {\n             Column[] uniqueColumns = new Column[templateColumns.length];\n             Table table = getTable(field, true, adapt);\n             for (int i=0; i<uniqueColumns.length; i++) {\n-                String columnName = templateColumns[i].getName();\n+                DBIdentifier columnName = templateColumns[i].getIdentifier();\n                 Column uniqueColumn = table.getColumn(columnName);\n                 uniqueColumns[i] = uniqueColumn;\n             }\n@@ -302,12 +317,15 @@ public Column getOrderColumn(FieldMapping field, Table table,\n         Column tmplate = new Column();\n         // Compatibility option determines what should be used for\n         // the default order column name\n+        boolean delimit = field.getMappingRepository().getDBDictionary().delimitAll();\n         if (field.getMappingRepository().getConfiguration()\n             .getCompatibilityInstance().getUseJPA2DefaultOrderColumnName()) {\n             // Use the same strategy as column to build the field name\n-            tmplate.setName(field.getName() + \"_ORDER\");            \n-        } else {        \n-            tmplate.setName(\"ordr\");\n+            DBIdentifier sName = DBIdentifier.newColumn(field.getName(), delimit);\n+            sName = DBIdentifier.append(sName,\"_ORDER\");\n+            tmplate.setIdentifier(sName);\n+        } else {\n+            tmplate.setIdentifier(DBIdentifier.newColumn(\"ordr\", delimit));\n         }\n         \n         tmplate.setJavaType(JavaTypes.INT);\n@@ -337,7 +355,7 @@ public void syncWith(FieldMapping field) {\n \n         if (field.getJoinForeignKey() != null)\n             _tableName = field.getMappingRepository().getDBDictionary().\n-                getFullName(field.getTable(), true);\n+                getFullIdentifier(field.getTable(), true);\n \n         ClassMapping def = field.getDefiningMapping();\n         setColumnIO(field.getJoinColumnIO());\n@@ -391,21 +409,21 @@ protected void syncJoinTableUniques(MetaDataContext context, Unique[] unqs)\n         _joinTableUniques = new ArrayList<Unique>();\n         for (Unique unique:unqs) {\n         \tUnique copy = new Unique();\n-        \tcopy.setName(unique.getName());\n+        \tcopy.setIdentifier(unique.getIdentifier());\n         \tcopy.setDeferred(unique.isDeferred());\n         \t_joinTableUniques.add(unique);\n         }\n     }\n \n \n     public boolean hasSchemaComponents() {\n-        return super.hasSchemaComponents() || _tableName != null\n+        return super.hasSchemaComponents() || !DBIdentifier.isNull(_tableName)\n             || _orderCol != null;\n     }\n \n     protected void clear(boolean canFlags) {\n         super.clear(canFlags);\n-        _tableName = null;\n+        _tableName = DBIdentifier.NULL;\n         _orderCol = null;\n         if (canFlags)\n             _canOrderCol = true;\n@@ -417,8 +435,8 @@ public void copy(MappingInfo info) {\n             return;\n \n         FieldMappingInfo finfo = (FieldMappingInfo) info;\n-        if (_tableName == null)\n-            _tableName = finfo.getTableName();\n+        if (DBIdentifier.isNull(_tableName))\n+            _tableName = finfo.getTableIdentifier();\n         if (!_outer)\n             _outer = finfo.isJoinOuter();\n         if (_canOrderCol && _orderCol == null)"},{"sha":"7db657476c2d9343e47a33d505ea7afa1f90f14e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCColumnOrder.java","status":"modified","additions":10,"deletions":1,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCColumnOrder.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCColumnOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCColumnOrder.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -20,6 +20,7 @@\n \n import java.util.Comparator;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n import org.apache.openjpa.jdbc.sql.Joins;\n@@ -30,6 +31,7 @@\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n class JDBCColumnOrder\n     implements JDBCOrder {\n \n@@ -64,15 +66,22 @@ public void setColumnIO(ColumnIO io) {\n         _io = io;\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public String getName() {\n         return (_col == null) ? \"\" : _col.getName();\n     }\n \n+    public DBIdentifier getIdentifier() {\n+        return (_col == null) ? DBIdentifier.newColumn(\"\") : _col.getIdentifier();\n+    }\n+\n     public boolean isAscending() {\n         return true;\n     }\n \n-    public Comparator getComparator() {\n+    public Comparator<?> getComparator() {\n         return null;\n     }\n "},{"sha":"e9a14373e30541b4d56abd157815a7d4291cbee9","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCOrder.java","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCOrder.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCOrder.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.openjpa.jdbc.meta;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.meta.Order;\n@@ -43,4 +44,7 @@\n      * we're selecting\n      */\n     public void order(Select sel, ClassMapping elem, Joins joins);\n+    \n+    public DBIdentifier getIdentifier();\n+\n }"},{"sha":"730e861fec46f0c27705a3ba1c24394adc557c8c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCRelatedFieldOrder.java","status":"modified","additions":10,"deletions":1,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCRelatedFieldOrder.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCRelatedFieldOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCRelatedFieldOrder.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -20,6 +20,7 @@\n \n import java.util.Comparator;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.lib.util.Localizer;\n@@ -30,6 +31,7 @@\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n class JDBCRelatedFieldOrder\n     implements JDBCOrder {\n \n@@ -49,15 +51,22 @@ public JDBCRelatedFieldOrder(FieldMapping owner, FieldMapping rel,\n         _asc = asc;\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public String getName() {\n         return _fm.getName();\n     }\n \n+    public DBIdentifier getIdentifier() {\n+        return DBIdentifier.newColumn(_fm.getName());\n+    }\n+\n     public boolean isAscending() {\n         return _asc;\n     }\n \n-    public Comparator getComparator() {\n+    public Comparator<?> getComparator() {\n         return null;\n     }\n "},{"sha":"6719a83a82fb59c1823bd59ec72d3699c853a338","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCValueOrder.java","status":"modified","additions":8,"deletions":1,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCValueOrder.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCValueOrder.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JDBCValueOrder.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -20,6 +20,7 @@\n \n import java.util.Comparator;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Select;\n import org.apache.openjpa.meta.Order;\n@@ -30,11 +31,13 @@\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n class JDBCValueOrder\n     implements JDBCOrder {\n \n     private final FieldMapping _fm;\n     private final boolean _asc;\n+    private static final DBIdentifier SQL_ELEMENT = DBIdentifier.newColumn(Order.ELEMENT);\n \n     public JDBCValueOrder(FieldMapping fm, boolean asc) {\n         _fm = fm;\n@@ -45,11 +48,15 @@ public String getName() {\n         return Order.ELEMENT;\n     }\n \n+    public DBIdentifier getIdentifier() {\n+        return SQL_ELEMENT;\n+    }\n+\n     public boolean isAscending() {\n         return _asc;\n     }\n \n-    public Comparator getComparator() {\n+    public Comparator<?> getComparator() {\n         return null;\n     }\n "},{"sha":"b4e74d9bef9686b229ad0763f9d504c07d30aa6a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JavaSQLTypes.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JavaSQLTypes.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JavaSQLTypes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/JavaSQLTypes.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -68,7 +68,7 @@\n     /**\n      * Return the proper date typecode.\n      */\n-    public static int getDateTypeCode(Class dtype) {\n+    public static int getDateTypeCode(Class<?> dtype) {\n         if (dtype == java.util.Date.class)\n             return DATE;\n         if (dtype == java.sql.Date.class)"},{"sha":"70b68f00db398439cf69e8b4a91578d35ee4d722","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaults.java","status":"modified","additions":104,"deletions":1,"changes":105,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaults.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.openjpa.jdbc.meta;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n import org.apache.openjpa.jdbc.schema.Index;\n@@ -87,7 +88,7 @@\n      * @param adapt whether we can adapt the mapping or schema\n      * @return the handler/strategy alias or instance, or null\n      */\n-    public Object getStrategy(ValueMapping vm, Class type, boolean adapt);\n+    public Object getStrategy(ValueMapping vm, Class<?> type, boolean adapt);\n \n     /**\n      * Return the default discriminator value for the given instance.\n@@ -97,16 +98,31 @@\n     /**\n      * Return the default table name for the given class. This method is\n      * only called for classes mapped to their own table.\n+     * @deprecated\n      */\n     public String getTableName(ClassMapping cls, Schema defaultSchema);\n \n+    /**\n+     * Return the default table name for the given class. This method is\n+     * only called for classes mapped to their own table.\n+     */\n+    public DBIdentifier getTableIdentifier(ClassMapping cls, Schema defaultSchema);\n+\n     /**\n      * Return the default secondary table name for the given field. This\n      * method is only called for fields whose strategy requires a secondary\n      * table.\n+     * @deprecated\n      */\n     public String getTableName(FieldMapping fm, Schema defaultSchema);\n \n+    /**\n+     * Return the default secondary table name for the given field. This\n+     * method is only called for fields whose strategy requires a secondary\n+     * table.\n+     */\n+    public DBIdentifier getTableIdentifier(FieldMapping fm, Schema defaultSchema);\n+\n     /**\n      * Fill in default information for the given datastore identity columns.\n      * The columns' name and Java type will already be populated with generic\n@@ -170,21 +186,50 @@ public void populateJoinColumn(FieldMapping fm, Table local, Table foreign,\n      * @param inverse whether this is an inverse foreign key\n      * @param pos the index of this column in the logical foreign key\n      * @param cols the number of columns in the logical foreign key\n+     * @deprecated\n      */\n     public void populateForeignKeyColumn(ValueMapping vm, String name,\n         Table local, Table foreign, Column col, Object target, boolean inverse,\n         int pos, int cols);\n \n+    /**\n+     * Fill in default information for the given column used to join a value\n+     * to its related type. The column will be a clone of the target\n+     * column, or have its name and Java type set in the case of a constant\n+     * target.\n+     *\n+     * @param name base name for value, as decided by mapping\n+     * @param target the target of this column in the join; may be\n+     * another column or a constant value\n+     * @param inverse whether this is an inverse foreign key\n+     * @param pos the index of this column in the logical foreign key\n+     * @param cols the number of columns in the logical foreign key\n+     */\n+    public void populateForeignKeyColumn(ValueMapping vm, DBIdentifier name,\n+        Table local, Table foreign, Column col, Object target, boolean inverse,\n+        int pos, int cols);\n+\n     /**\n      * Fill in default information for the given value columns.\n      * The columns' name and Java type will already be populated with generic\n      * defaults that may be replaced.\n      *\n      * @param name base name for value, as decided by mapping\n+     * @deprecated\n      */\n     public void populateColumns(ValueMapping vm, String name, Table table,\n         Column[] cols);\n \n+    /**\n+     * Fill in default information for the given value columns.\n+     * The columns' name and Java type will already be populated with generic\n+     * defaults that may be replaced.\n+     *\n+     * @param name base name for value, as decided by mapping\n+     */\n+    public void populateColumns(ValueMapping vm, DBIdentifier name, Table table,\n+        Column[] cols);\n+\n     /**\n      * Fill in default information for the given order columns.\n      * The columns' name and Java type will already be populated with generic\n@@ -206,10 +251,24 @@ public boolean populateOrderColumns(FieldMapping fm, Table table,\n      * @return false if the given value should not have null indicator\n      * columns by default; fill in default information even\n      * when returning false in case the user forces an indicator\n+     * @deprecated\n      */\n     public boolean populateNullIndicatorColumns(ValueMapping vm, String name,\n         Table table, Column[] cols);\n \n+    /**\n+     * Fill in default information for the given null indicator columns.\n+     * The columns' name and Java type will already be populated with generic\n+     * defaults that may be replaced.\n+     *\n+     * @param name base name for value, as decided by mapping\n+     * @return false if the given value should not have null indicator\n+     * columns by default; fill in default information even\n+     * when returning false in case the user forces an indicator\n+     */\n+    public boolean populateNullIndicatorColumns(ValueMapping vm, DBIdentifier name,\n+        Table table, Column[] cols);\n+\n     /**\n      * Return a default foreign key for the join from this class' table to its\n      * superclass' table, or null for a logical foreign key only. Do not\n@@ -236,10 +295,23 @@ public ForeignKey getJoinForeignKey(FieldMapping fm, Table local,\n      *\n      * @param name base name for value, as decided by mapping\n      * @param inverse whether this is an inverse key\n+     * @deprecated\n      */\n     public ForeignKey getForeignKey(ValueMapping vm, String name, Table local,\n         Table foreign, boolean inverse);\n \n+    /**\n+     * Return a default foreign key for the join from this value to its\n+     * related type, or null for a logical foreign key only. Do not\n+     * add columns to the key or add the key to the table; only fill in\n+     * its information such as name, delete action, etc.\n+     *\n+     * @param name base name for value, as decided by mapping\n+     * @param inverse whether this is an inverse key\n+     */\n+    public ForeignKey getForeignKey(ValueMapping vm, DBIdentifier name, Table local,\n+        Table foreign, boolean inverse);\n+\n     /**\n      * Return a default index for the join, or null if the\n      * join columns should not be indexed by default. Do not\n@@ -255,10 +327,22 @@ public ForeignKey getForeignKey(ValueMapping vm, String name, Table local,\n      * uniqueness, etc.\n      *\n      * @param name base name for value, as decided by mapping\n+     * @deprecated\n      */\n     public Index getIndex(ValueMapping vm, String name, Table table,\n         Column[] cols);\n \n+    /**\n+     * Return a default index for the value, or null if the value columns\n+     * should not be indexed by default. Do not add columns to the index or\n+     * add the index to the table; only fill in its information such as name,\n+     * uniqueness, etc.\n+     *\n+     * @param name base name for value, as decided by mapping\n+     */\n+    public Index getIndex(ValueMapping vm, DBIdentifier name, Table table,\n+        Column[] cols);\n+\n     /**\n      * Return a default index for the version, or null if the\n      * version columns should not be indexed by default. Do not\n@@ -290,16 +374,35 @@ public Index getIndex(ValueMapping vm, String name, Table table,\n      * information such as name, deferrability, etc.\n      *\n      * @param name base name for value, as decided by mapping\n+     * @deprecated\n      */\n     public Unique getUnique(ValueMapping vm, String name, Table table,\n         Column[] cols);\n \n+    /**\n+     * Return a default constraint for the value, or null if the value columns\n+     * should not be constrained by default. Do not add columns to the\n+     * constraint or add the constraint to the table; only fill in its\n+     * information such as name, deferrability, etc.\n+     *\n+     * @param name base name for value, as decided by mapping\n+     */\n+    public Unique getUnique(ValueMapping vm, DBIdentifier name, Table table,\n+        Column[] cols);\n+\n     /**\n      * Return the name of the primary key for the table of the given class,\n      * or null for database default.\n+     * @deprecated\n      */\n     public String getPrimaryKeyName(ClassMapping cm, Table table);\n \n+    /**\n+     * Return the name of the primary key for the table of the given class,\n+     * or null for database default.\n+     */\n+    public DBIdentifier getPrimaryKeyIdentifier(ClassMapping cm, Table table);\n+\n     /**\n      * If desired, install a primary key on the given secondary table.\n      */"},{"sha":"56f70e4ff2c14d194eee80700153bbced78bd699","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaultsImpl.java","status":"modified","additions":181,"deletions":72,"changes":253,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaultsImpl.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaultsImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingDefaultsImpl.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -24,6 +24,8 @@\n import java.util.Properties;\n \n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.identifier.Normalizer;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.meta.strats.UntypedPCValueHandler;\n import org.apache.openjpa.jdbc.meta.strats.EnumValueHandler;\n import org.apache.openjpa.jdbc.schema.Column;\n@@ -36,7 +38,8 @@\n import org.apache.openjpa.lib.conf.Configurable;\n import org.apache.openjpa.lib.conf.Configuration;\n import org.apache.openjpa.lib.conf.Configurations;\n-import org.apache.openjpa.lib.util.JavaVersions;\n+import org.apache.openjpa.lib.identifier.Identifier;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n import org.apache.openjpa.meta.JavaTypes;\n import serp.util.Strings;\n \n@@ -66,11 +69,11 @@\n     private boolean _addNullInd = false;\n     private boolean _ordinalEnum = false;\n     private boolean _stringifyUnmapped = false;\n-    private String _dsIdName = null;\n-    private String _versName = null;\n-    private String _discName = null;\n-    private String _orderName = null;\n-    private String _nullIndName = null;\n+    private DBIdentifier _dsIdName = DBIdentifier.NULL;\n+    private DBIdentifier _versName = DBIdentifier.NULL;\n+    private DBIdentifier _discName = DBIdentifier.NULL;\n+    private DBIdentifier _orderName = DBIdentifier.NULL;\n+    private DBIdentifier _nullIndName = DBIdentifier.NULL;\n     private boolean _removeHungarianNotation = false;\n \n     public boolean isRemoveHungarianNotation() {\n@@ -333,83 +336,133 @@ public void setDeferConstraints(boolean defer) {\n     /**\n      * Default base name for datastore identity columns, or null to the\n      * mapping's built-in name.\n+     * @deprecated\n      */\n     public String getDataStoreIdColumnName() {\n-        return _dsIdName;\n+        return getDataStoreIdColumnIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getDataStoreIdColumnIdentifier() {\n+        return _dsIdName == null ? DBIdentifier.NULL : _dsIdName;\n     }\n \n     /**\n      * Default base name for datastore identity columns, or null to the\n      * mapping's built-in name.\n+     * @deprecated\n      */\n     public void setDataStoreIdColumnName(String dsIdName) {\n+        setDataStoreIdColumnIdentifier(DBIdentifier.newColumn(dsIdName));\n+    }\n+\n+    public void setDataStoreIdColumnIdentifier(DBIdentifier dsIdName) {\n         _dsIdName = dsIdName;\n     }\n \n     /**\n      * Default base name for version identity columns, or null to the mapping's\n      * built-in name.\n+     * @deprecated\n      */\n     public String getVersionColumnName() {\n-        return _versName;\n+        return getVersionColumnIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getVersionColumnIdentifier() {\n+        return _versName == null ? DBIdentifier.NULL : _versName;\n     }\n \n     /**\n      * Default base name for version identity columns, or null to the mapping's\n      * built-in name.\n+     * @deprecated\n      */\n     public void setVersionColumnName(String versName) {\n+        setVersionColumnIdentifier(DBIdentifier.newColumn(versName));\n+    }\n+\n+    public void setVersionColumnIdentifier(DBIdentifier versName) {\n         _versName = versName;\n     }\n \n     /**\n      * Default base name for discriminator columns, or null to the mapping's\n      * built-in name.\n+     * @deprecated\n      */\n     public String getDiscriminatorColumnName() {\n-        return _discName;\n+        return getDiscriminatorColumnIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getDiscriminatorColumnIdentifier() {\n+        return _discName == null ? DBIdentifier.NULL : _discName;\n     }\n \n     /**\n      * Default base name for discriminator columns, or null to the mapping's\n      * built-in name.\n+     * @deprecated\n      */\n     public void setDiscriminatorColumnName(String discName) {\n+        setDiscriminatorColumnIdentifier(DBIdentifier.newColumn(discName));\n+    }\n+\n+    public void setDiscriminatorColumnIdentifier(DBIdentifier discName) {\n         _discName = discName;\n     }\n \n     /**\n      * Default base name for order columns, or null to the mapping's\n      * built-in name.\n+     * @deprecated\n      */\n     public String getOrderColumnName() {\n-        return _orderName;\n+        return getOrderColumnIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getOrderColumnIdentifier() {\n+        return _orderName == null ? DBIdentifier.NULL : _orderName;\n     }\n \n     /**\n      * Default base name for order columns, or null to the mapping's\n      * built-in name.\n+     * @deprecated\n      */\n     public void setOrderColumnName(String orderName) {\n+        setOrderColumnIdentifier(DBIdentifier.newColumn(orderName));\n+    }\n+\n+    public void setOrderColumnIdentifier(DBIdentifier orderName) {\n         _orderName = orderName;\n     }\n \n     /**\n      * Default base name for null indicator columns, or null to the mapping's\n      * built-in name.\n+     * @deprecated\n      */\n     public String getNullIndicatorColumnName() {\n-        return _nullIndName;\n+        return getNullIndicatorColumnIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getNullIndicatorColumnIdentifier() {\n+        return _nullIndName == null ? DBIdentifier.NULL : _nullIndName;\n     }\n \n     /**\n      * Default base name for null indicator columns, or null to the mapping's\n      * built-in name.\n+     * @deprecated\n      */\n     public void setNullIndicatorColumnName(String nullIndName) {\n+        setNullIndicatorColumnIdentifier(DBIdentifier.newColumn(nullIndName));\n+    }\n+    \n+    public void setNullIndicatorColumnIdentifier(DBIdentifier nullIndName) {\n         _nullIndName = nullIndName;\n     }\n-\n+    \n     public boolean defaultMissingInfo() {\n         return _defMissing;\n     }\n@@ -451,7 +504,7 @@ public Object getStrategy(Discriminator disc, boolean adapt) {\n         return null;\n     }\n \n-    public Object getStrategy(ValueMapping vm, Class type, boolean adapt) {\n+    public Object getStrategy(ValueMapping vm, Class<?> type, boolean adapt) {\n         Object ret = _fieldMap.get(type.getName());\n         if (ret != null)\n             return ret;\n@@ -511,33 +564,39 @@ public Object getDiscriminatorValue(Discriminator disc, boolean adapt) {\n \n     public String getTableName(ClassMapping cls, Schema schema) {\n         String name = Strings.getClassName(cls.getDescribedType()).\n-            replace('$', '_');\n+            replace(IdentifierUtil.DOLLAR_CHAR, IdentifierUtil.UNDERSCORE_CHAR);\n         if (!_defMissing)\n             name = dict.getValidTableName(name, schema);\n         return name;\n     }\n \n+    public DBIdentifier getTableIdentifier(ClassMapping cls, Schema schema) {\n+        return DBIdentifier.newTable(getTableName(cls, schema));\n+    }\n+\n     public String getTableName(FieldMapping fm, Schema schema) {\n-        String name = fm.getName();\n+        return getTableIdentifier(fm, schema).getName();\n+    }\n+\n+    public DBIdentifier getTableIdentifier(FieldMapping fm, Schema schema) {\n+        DBIdentifier sName = DBIdentifier.newTable(fm.getName());\n         Table table = fm.getDefiningMapping().getTable();\n         if (table != null) {\n-            String tableName = table.getName();\n-            if (tableName.length() > 5)\n-                tableName = tableName.substring(0, 5);\n-            name = tableName + \"_\" + name;\n+            DBIdentifier tableName = DBIdentifier.truncate(table.getIdentifier(),5);\n+            sName = DBIdentifier.append(tableName, fm.getName());\n         }\n         if (!_defMissing)\n-            name = dict.getValidTableName(name, schema);\n-        return name;\n+            sName = dict.getValidTableName(sName, schema);\n+        return sName;\n     }\n \n     public void populateDataStoreIdColumns(ClassMapping cls, Table table,\n         Column[] cols) {\n         for (int i = 0; i < cols.length; i++) {\n-            if (_dsIdName != null && cols.length == 1)\n-                cols[i].setName(_dsIdName);\n-            else if (_dsIdName != null)\n-                cols[i].setName(_dsIdName + i);\n+            if (!DBIdentifier.isNull(_dsIdName) && cols.length == 1)\n+                cols[i].setIdentifier(_dsIdName);\n+            else if (!DBIdentifier.isNull(_dsIdName))\n+                cols[i].setIdentifier(DBIdentifier.append(_dsIdName, Integer.toString(i)));\n             correctName(table, cols[i]);\n         }\n     }\n@@ -548,52 +607,42 @@ else if (_dsIdName != null)\n     protected void correctName(Table table, Column col) {\n         if (!_defMissing || _removeHungarianNotation)\n         {\n-            String name = col.getName();\n+            DBIdentifier name = col.getIdentifier();\n             if (_removeHungarianNotation)\n-                name = removeHungarianNotation(name);\n-            String correctedName = dict.getValidColumnName(name, table);\n-            col.setName(correctedName);\n+                name = DBIdentifier.removeHungarianNotation(name);\n+            DBIdentifier correctedName = dict.getValidColumnName(name, table);\n+            col.setIdentifier(correctedName);\n             table.addCorrectedColumnName(correctedName, true);\n         }\n     }\n \n     protected String removeHungarianNotation(String columnName) {\n-        char[] name = columnName.toCharArray();\n-        int newStart = 0;\n-\n-        for (int i = 0; i < name.length; i++) {\n-            if (Character.isUpperCase(name[i]))\n-            {\n-                newStart = i;\n-                break;\n-            }\n-        }\n-\n-        return columnName.substring(newStart);\n+        return Normalizer.removeHungarianNotation(columnName);\n     }\n \n     public void populateColumns(Version vers, Table table, Column[] cols) {\n         for (int i = 0; i < cols.length; i++) {\n-            if (_versName != null && cols.length == 1)\n-                cols[i].setName(_versName);\n-            else if (_versName != null) {\n-                if (i == 0)\n-                    cols[i].setName(_versName);\n-                else\n-                    cols[i].setName(_versName + \"_\" + i);\n-            } else if (_versName != null)\n-                cols[i].setName(_versName + i);\n+            if (!DBIdentifier.isNull(_versName) && cols.length == 1)\n+                cols[i].setIdentifier(_versName);\n+            else if (!DBIdentifier.isNull(_versName)) {\n+                if (i == 0) {\n+                    cols[i].setIdentifier(_versName);\n+                } else {\n+                    cols[i].setIdentifier(DBIdentifier.append(_versName, Integer.toString(i)));\n+                }\n+            } else if (!DBIdentifier.isNull(_versName))\n+                cols[i].setIdentifier(DBIdentifier.append(_versName, Integer.toString(i)));\n             correctName(table, cols[i]);\n         }\n     }\n \n     public void populateColumns(Discriminator disc, Table table,\n         Column[] cols) {\n         for (int i = 0; i < cols.length; i++) {\n-            if (_discName != null && cols.length == 1)\n-                cols[i].setName(_discName);\n-            else if (_discName != null)\n-                cols[i].setName(_discName + i);\n+            if (!DBIdentifier.isNull(_discName) && cols.length == 1)\n+                cols[i].setIdentifier(_discName);\n+            else if (!DBIdentifier.isNull(_discName))\n+                cols[i].setIdentifier(DBIdentifier.append(_discName, Integer.toString(i)));\n             correctName(table, cols[i]);\n         }\n     }\n@@ -608,17 +657,32 @@ public void populateJoinColumn(FieldMapping fm, Table local, Table foreign,\n         correctName(local, col);\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public void populateForeignKeyColumn(ValueMapping vm, String name,\n+        Table local, Table foreign, Column col, Object target, boolean inverse,\n+        int pos, int cols) {\n+        populateForeignKeyColumn(vm, DBIdentifier.newColumn(name), local, foreign, col,\n+            target, inverse, pos, cols);\n+    }\n+\n+    public void populateForeignKeyColumn(ValueMapping vm, DBIdentifier name,\n         Table local, Table foreign, Column col, Object target, boolean inverse,\n         int pos, int cols) {\n         if (cols == 1)\n-            col.setName(name);\n+            col.setIdentifier(name);\n         else if (target instanceof Column)\n-            col.setName(name + \"_\" + ((Column) target).getName());\n+            col.setIdentifier(DBIdentifier.combine(name,((Column) target).getIdentifier().getName()));\n         correctName(local, col);\n     }\n \n     public void populateColumns(ValueMapping vm, String name, Table table,\n+        Column[] cols) {\n+        populateColumns(vm, DBIdentifier.newColumn(name), table, cols);\n+    }\n+\n+    public void populateColumns(ValueMapping vm, DBIdentifier name, Table table,\n         Column[] cols) {\n         for (int i = 0; i < cols.length; i++)\n             correctName(table, cols[i]);\n@@ -627,23 +691,31 @@ public void populateColumns(ValueMapping vm, String name, Table table,\n     public boolean populateOrderColumns(FieldMapping fm, Table table,\n         Column[] cols) {\n         for (int i = 0; i < cols.length; i++) {\n-            if (_orderName != null && cols.length == 1)\n-                cols[i].setName(_orderName);\n-            else if (_orderName != null)\n-                cols[i].setName(_orderName + i);\n+            if (!DBIdentifier.isNull(_orderName) && cols.length == 1)\n+                cols[i].setIdentifier(_orderName);\n+            else if (!DBIdentifier.isNull(_orderName))\n+                cols[i].setIdentifier(DBIdentifier.append(_orderName, Integer.toString(i)));\n             correctName(table, cols[i]);\n         }\n         return _orderLists && (JavaTypes.ARRAY == fm.getTypeCode()\n             || List.class.isAssignableFrom(fm.getType()));\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public boolean populateNullIndicatorColumns(ValueMapping vm, String name,\n+        Table table, Column[] cols) {\n+        return populateNullIndicatorColumns(vm, DBIdentifier.newColumn(name), table, cols);\n+    }\n+\n+    public boolean populateNullIndicatorColumns(ValueMapping vm, DBIdentifier name,\n         Table table, Column[] cols) {\n         for (int i = 0; i < cols.length; i++) {\n-            if (_nullIndName != null && cols.length == 1)\n-                cols[i].setName(_nullIndName);\n-            else if (_nullIndName != null)\n-                cols[i].setName(_nullIndName + i);\n+            if (!DBIdentifier.isNull(_nullIndName) && cols.length == 1)\n+                cols[i].setIdentifier(_nullIndName);\n+            else if (!DBIdentifier.isNull(_nullIndName))\n+                cols[i].setIdentifier(DBIdentifier.append(_nullIndName, Integer.toString(i)));\n             correctName(table, cols[i]);\n         }\n         return _addNullInd;\n@@ -669,7 +741,15 @@ public ForeignKey getJoinForeignKey(FieldMapping fm, Table local,\n         return fk;\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public ForeignKey getForeignKey(ValueMapping vm, String name, Table local,\n+        Table foreign, boolean inverse) {\n+        return getForeignKey(vm, DBIdentifier.newForeignKey(name), local, foreign, inverse);\n+    }\n+        \n+    public ForeignKey getForeignKey(ValueMapping vm, DBIdentifier name, Table local,\n         Table foreign, boolean inverse) {\n         if (_fkAction == ForeignKey.ACTION_NONE)\n             return null;\n@@ -687,7 +767,7 @@ public Index getJoinIndex(FieldMapping fm, Table table, Column[] cols) {\n             return null;\n \n         Index idx = new Index();\n-        idx.setName(getIndexName(null, table, cols));\n+        idx.setIdentifier(getIndexName(DBIdentifier.NULL, table, cols));\n         return idx;\n     }\n \n@@ -703,20 +783,34 @@ protected boolean areAllPrimaryKeyColumns(Column[] cols) {\n \n     /**\n      * Generate an index name.\n+     * @deprecated\n      */\n     protected String getIndexName(String name, Table table, Column[] cols) {\n+        return getIndexName(DBIdentifier.newIndex(name), table, cols).getName();\n+    }\n+\n+    protected DBIdentifier getIndexName(DBIdentifier name, Table table, Column[] cols) {\n         // always use dict for index names because no spec mandates them\n         // based on defaults\n-        if (name == null)\n-            name = cols[0].getName();\n+        DBIdentifier sName = name;\n+        if (DBIdentifier.isNull(sName))\n+            sName = cols[0].getIdentifier();\n \n         if (_removeHungarianNotation)\n-            name = removeHungarianNotation(name);\n+            sName = DBIdentifier.removeHungarianNotation(sName);\n \n-        return dict.getValidIndexName(name, table);\n+        return dict.getValidIndexName(sName, table);\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public Index getIndex(ValueMapping vm, String name, Table table,\n+        Column[] cols) {\n+        return getIndex(vm, DBIdentifier.newIndex(name), table, cols);\n+    }\n+\n+    public Index getIndex(ValueMapping vm, DBIdentifier name, Table table,\n         Column[] cols) {\n         if (!_indexFK || vm.getForeignKey() == null\n             || !vm.getForeignKey().isLogical())\n@@ -725,39 +819,54 @@ public Index getIndex(ValueMapping vm, String name, Table table,\n             return null;\n \n         Index idx = new Index();\n-        idx.setName(getIndexName(name, table, cols));\n+        idx.setIdentifier(getIndexName(name, table, cols));\n         return idx;\n     }\n \n     public Index getIndex(Version vers, Table table, Column[] cols) {\n         if (!_indexVers)\n             return null;\n         Index idx = new Index();\n-        idx.setName(getIndexName(_versName, table, cols));\n+        idx.setIdentifier(getIndexName(_versName, table, cols));\n         return idx;\n     }\n \n     public Index getIndex(Discriminator disc, Table table, Column[] cols) {\n         if (!_indexDisc)\n             return null;\n         Index idx = new Index();\n-        idx.setName(getIndexName(_discName, table, cols));\n+        idx.setIdentifier(getIndexName(_discName, table, cols));\n         return idx;\n     }\n \n     public Unique getJoinUnique(FieldMapping fm, Table table, Column[] cols) {\n         return null;\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public Unique getUnique(ValueMapping vm, String name, Table table,\n         Column[] cols) {\n         return null;\n     }\n \n+    public Unique getUnique(ValueMapping vm, DBIdentifier name, Table table,\n+        Column[] cols) {\n+        return null;\n+    }\n+\n+    /**\n+     * @deprecated\n+     */\n     public String getPrimaryKeyName(ClassMapping cm, Table table) {\n         return null;\n     }\n \n+    public DBIdentifier getPrimaryKeyIdentifier(ClassMapping cm, Table table) {\n+        return DBIdentifier.NULL;\n+    }\n+\n     public void installPrimaryKey(FieldMapping fm, Table table) {\n     }\n "},{"sha":"6cd0963881ee4e927c960d75420ec9d50b94f0c6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingInfo.java","status":"modified","additions":158,"deletions":137,"changes":295,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingInfo.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -26,6 +26,9 @@\n \n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.identifier.Normalizer;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.QualifiedDBIdentifier;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n@@ -51,6 +54,7 @@\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class MappingInfo\n     implements Serializable {\n \n@@ -64,7 +68,7 @@\n         (MappingInfo.class);\n \n     private String _strategy = null;\n-    private List _cols = null;\n+    private List<Column> _cols = null;\n     private Index _idx = null;\n     private Unique _unq = null;\n     private ForeignKey _fk = null;\n@@ -92,19 +96,30 @@ public void setStrategy(String strategy) {\n     /**\n      * Raw column data.\n      */\n-    public List getColumns() {\n-        return (_cols == null) ? Collections.EMPTY_LIST : _cols;\n+    public List<Column> getColumns() {\n+        if (_cols == null) {\n+            return Collections.emptyList();\n+        }\n+        return _cols;\n     }\n     \n+    /**\n+     * Gets the columns whose table name matches the given table name. \n+     * @deprecated\n+     */\n+    public List<Column> getColumns(String tableName) {\n+        return getColumns(DBIdentifier.newTable(tableName));\n+    }\n+\n     /**\n      * Gets the columns whose table name matches the given table name. \n      */\n-    public List getColumns(String tableName) {\n+    public List<Column> getColumns(DBIdentifier tableName) {\n         if (_cols == null) \n-        \treturn Collections.EMPTY_LIST;\n-        List result = new ArrayList();\n-        for (Object col : _cols) {\n-        \tif (StringUtils.equals(((Column)col).getTableName(), \n+        \treturn Collections.emptyList();\n+        List<Column> result = new ArrayList<Column>();\n+        for (Column col : _cols) {\n+        \tif (DBIdentifier.equal(col.getTableIdentifier(), \n         \t\t\ttableName)) \n         \t\tresult.add(col);\n         }\n@@ -114,7 +129,7 @@ public List getColumns(String tableName) {\n     /**\n      * Raw column data.\n      */\n-    public void setColumns(List cols) {\n+    public void setColumns(List<Column> cols) {\n         _cols = cols;\n     }\n \n@@ -321,12 +336,12 @@ public void copy(MappingInfo info) {\n                 _canFK = info.canForeignKey();\n         }\n         _implicitRelation = info.isImplicitRelation();\n-        List cols = getColumns();\n-        List icols = info.getColumns();\n+        List<Column> cols = getColumns();\n+        List<Column> icols = info.getColumns();\n         if (!icols.isEmpty() && (cols.isEmpty()\n             || cols.size() == icols.size())) {\n             if (cols.isEmpty())\n-                cols = new ArrayList(icols.size());\n+                cols = new ArrayList<Column>(icols.size());\n             for (int i = 0; i < icols.size(); i++) {\n                 if (cols.size() == i)\n                     cols.add(new Column());\n@@ -448,7 +463,7 @@ public void assertNoJoin(MetaDataContext context, boolean die) {\n             Column col;\n             for (int i = 0; !join && i < _cols.size(); i++) {\n                 col = (Column) _cols.get(i);\n-                if (col.getTarget() != null)\n+                if (!DBIdentifier.isNull(col.getTargetIdentifier()))\n                     join = true;\n             }\n         }\n@@ -469,43 +484,48 @@ public void assertNoJoin(MetaDataContext context, boolean die) {\n      * @param schemaName default schema if known, or null\n      * @param given given table name\n      * @param adapt whether we can alter the schema or mappings\n+     * @deprecated\n      */\n     public Table createTable(MetaDataContext context, TableDefaults def,\n         String schemaName, String given, boolean adapt) {\n+        return createTable(context, def, DBIdentifier.newSchema(schemaName), \n+            DBIdentifier.newTable(given), adapt);\n+    }\n+\n+    public Table createTable(MetaDataContext context, TableDefaults def,\n+        DBIdentifier schemaName, DBIdentifier given, boolean adapt) {\n         MappingRepository repos = (MappingRepository) context.getRepository();\n-        if (given == null && (def == null || (!adapt\n+        if (DBIdentifier.isNull(given) && (def == null || (!adapt\n             && !repos.getMappingDefaults().defaultMissingInfo())))\n             throw new MetaDataException(_loc.get(\"no-table\", context));\n \n-        if (schemaName == null)\n-            schemaName = Schemas.getNewTableSchema((JDBCConfiguration)\n+        if (DBIdentifier.isNull(schemaName))\n+            schemaName = Schemas.getNewTableSchemaIdentifier((JDBCConfiguration)\n                 repos.getConfiguration());\n \n         // if no given and adapting or defaulting missing info, use template\n         SchemaGroup group = repos.getSchemaGroup();\n         Schema schema = null;\n-        if (given == null) {\n+        if (DBIdentifier.isNull(given)) {\n             schema = group.getSchema(schemaName);\n             if (schema == null)\n                 schema = group.addSchema(schemaName);\n-            given = def.get(schema);\n+            given = def.getIdentifier(schema);\n         }\n \n-        String fullName;\n-        String sep = repos.getDBDictionary().catalogSeparator;\n-        int dotIdx = given.lastIndexOf(sep);\n-        if (dotIdx == -1)\n-            fullName = (schemaName == null) ? given : schemaName + sep + given;\n-        else {\n-            fullName = given;\n+        QualifiedDBIdentifier path = QualifiedDBIdentifier.getPath(given);\n+        if (DBIdentifier.isNull(path.getSchemaName())) {\n+            if (!DBIdentifier.isNull(schemaName)) {\n+                path.setSchemaName(schemaName);\n+            }\n+        } else {\n+            schemaName = path.getSchemaName();\n             schema = null;\n-            schemaName = given.substring(0, dotIdx);\n-            given = given.substring(dotIdx + 1);\n         }\n \n         // look for named table using full name and findTable, which allows\n         // the dynamic schema factory to create the table if needed\n-        Table table = group.findTable(fullName);\n+        Table table = group.findTable(path);\n         if (table != null)\n             return table;\n         if (!adapt)\n@@ -543,7 +563,7 @@ public Table createTable(MetaDataContext context, TableDefaults def,\n         // mapping, or none at all if we're adapting.  can't just given one of\n         // n columns because we don't know which of the n columns the info\n         // applies to\n-        List given = getColumns();\n+        List<Column> given = getColumns();\n         \n         if (context instanceof FieldMapping && ((FieldMapping)context).hasMapsIdCols())\n             given = ((FieldMapping)context).getValueInfo().getMapsIdColumns();\n@@ -553,7 +573,7 @@ public Table createTable(MetaDataContext context, TableDefaults def,\n         if ((!given.isEmpty() || (!adapt && !fill))\n             && given.size() != tmplates.length) {\n         \t// also consider when this info has columns from multiple tables\n-        \tgiven = getColumns(table.getName());\n+        \tgiven = getColumns(table.getIdentifier());\n         \tif ((!adapt && !fill) && given.size() != tmplates.length) {\n         \t\t// try default table\n         \t\tgiven = getColumns(\"\");\n@@ -577,7 +597,7 @@ public Table createTable(MetaDataContext context, TableDefaults def,\n         return cols;\n     }\n     \n-    boolean canMerge(List given, Column[] templates, boolean adapt,\n+    boolean canMerge(List<Column> given, Column[] templates, boolean adapt,\n             boolean fill) {\n     \treturn !((!given.isEmpty() || (!adapt && !fill)) \n     \t\t\t&& given.size() != templates.length);\n@@ -627,8 +647,8 @@ protected static Column mergeColumn(MetaDataContext context, String prefix,\n         assertTable(context, table);\n \n         // if not adapting must provide column name at a minimum\n-        String colName = (given == null) ? null : given.getName();\n-        if (colName == null && !adapt && !fill)\n+        DBIdentifier colName = (given == null) ? DBIdentifier.NULL : given.getIdentifier();\n+        if (DBIdentifier.isNull(colName) && !adapt && !fill)\n             throw new MetaDataException(_loc.get(prefix + \"-no-col-name\",\n                 context));\n \n@@ -638,15 +658,15 @@ protected static Column mergeColumn(MetaDataContext context, String prefix,\n         // determine the column name based on given info, or template if none;\n         // also make sure that if the user gave a column name, he didn't try\n         // to put the column in an unexpected table\n-        if (colName == null)\n-            colName = tmplate.getName();\n-        int dotIdx = colName.lastIndexOf(dict.catalogSeparator);\n-        if (dotIdx == 0)\n-            colName = colName.substring(1);\n-        else if (dotIdx != -1) {\n-            findTable(context, colName.substring(0, dotIdx), table,\n+        if (DBIdentifier.isNull(colName))\n+            colName = tmplate.getIdentifier();\n+        QualifiedDBIdentifier path = QualifiedDBIdentifier.getPath(colName);\n+        if (path.isUnqualifiedColumn()) {\n+            colName = path.getIdentifier();\n+        } else if (!DBIdentifier.isNull(path.getObjectTableName())) {\n+            findTable(context, path.getObjectTableName(), table,\n                 null, null);\n-            colName = colName.substring(dotIdx + 1);\n+            colName = path.getUnqualifiedName();\n         }\n \n         // find existing column\n@@ -658,8 +678,8 @@ else if (dotIdx != -1) {\n             // should seldom if ever occur as long as the database dictionaries\n             // are kept up-to-date. \n             // \n-            if ((colName.length() > dict.maxColumnNameLength) || \n-               dict.getInvalidColumnWordSet().contains(colName.toUpperCase()) &&\n+            if ((colName.getName().length() > dict.maxColumnNameLength) || \n+               dict.getInvalidColumnWordSet().contains(DBIdentifier.toUpper(colName).getName()) &&\n               !(table.getClass().getName().contains(\"DynamicTable\"))) {\n                 colName=dict.getValidColumnName(colName, new Table());\n                 col = table.getColumn(colName);\n@@ -814,7 +834,7 @@ else if (col.getJavaType() == JavaTypes.OBJECT) {\n      * @param rel if we're finding the target table of a join, the\n      * joined-to type; allows us to also look in its superclass tables\n      */\n-    private static Table findTable(MetaDataContext context, String name,\n+    private static Table findTable(MetaDataContext context, DBIdentifier name,\n         Table expected, Table inverse, ClassMapping rel) {\n         // is this the expected table?\n         if (expected == null && rel != null)\n@@ -837,15 +857,15 @@ private static Table findTable(MetaDataContext context, String name,\n \n         // none of the possible tables\n         throw new MetaDataException(_loc.get(\"col-wrong-table\", context,\n-            expected, name));\n+            expected, name.getName()));\n     }\n \n     /**\n      * Return whether the given name matches the given table.\n      */\n-    private static boolean isTableName(String name, Table table) {\n-        return name.equalsIgnoreCase(table.getName())\n-            || name.equalsIgnoreCase(table.getFullName());\n+    private static boolean isTableName(DBIdentifier name, Table table) {\n+        return DBIdentifier.equal(name, table.getIdentifier())\n+            || DBIdentifier.equal(name, table.getFullIdentifier());\n     }\n \n     /**\n@@ -910,10 +930,10 @@ protected Index createIndex(MetaDataContext context, String prefix,\n         if (_idx == null && (tmplate == null || (!adapt && !fill)))\n             return null;\n \n-        String name = null;\n+        DBIdentifier name = DBIdentifier.NULL;\n         boolean unq;\n         if (_idx != null) {\n-            name = _idx.getName();\n+            name = _idx.getIdentifier();\n             unq = _idx.isUnique();\n             // preserve multiple columns if they are specified in the index\n             if (_idx.getColumns() != null && _idx.getColumns().length > 1)\n@@ -922,11 +942,11 @@ protected Index createIndex(MetaDataContext context, String prefix,\n             unq = tmplate.isUnique();\n \n         // if no name provided by user info, make one\n-        if (name == null) {\n+        if (DBIdentifier.isNull(name)) {\n             if (tmplate != null)\n-                name = tmplate.getName();\n+                name = tmplate.getIdentifier();\n             else {\n-                name = cols[0].getName();\n+                name = cols[0].getIdentifier();\n                 name = repos.getDBDictionary().getValidIndexName(name, table);\n             }\n         }\n@@ -1009,13 +1029,13 @@ protected Unique createUnique(MetaDataContext context, String prefix,\n         if (!adapt && !fill && _unq == null)\n             return null;\n \n-        String name;\n+        DBIdentifier name = DBIdentifier.NULL;\n         boolean deferred;\n         if (_unq != null) {\n-            name = _unq.getName();\n+            name = _unq.getIdentifier();\n             deferred = _unq.isDeferred();\n         } else {\n-            name = tmplate.getName();\n+            name = tmplate.getIdentifier();\n             deferred = tmplate.isDeferred();\n         }\n \n@@ -1027,8 +1047,8 @@ protected Unique createUnique(MetaDataContext context, String prefix,\n             deferred = false;\n         }\n         \n-        if (StringUtils.isEmpty(name)) {\n-        \tname = cols[0].getName();\n+        if (DBIdentifier.isEmpty(name)) {\n+        \tname = cols[0].getIdentifier();\n         \tname = repos.getDBDictionary().getValidUniqueName(name, table);\n         }\n         \n@@ -1054,7 +1074,7 @@ protected Unique createUnique(MetaDataContext context, String prefix,\n      * @param adapt whether we can modify the existing mapping or schema\n      */\n     protected ForeignKey createForeignKey(MetaDataContext context,\n-        String prefix, List given, ForeignKeyDefaults def, Table table,\n+        String prefix, List<Column> given, ForeignKeyDefaults def, Table table,\n         ClassMapping cls, ClassMapping rel, boolean inversable, boolean adapt) {\n         assertTable(context, table);\n         if (prefix == null)\n@@ -1116,10 +1136,10 @@ protected ForeignKey createForeignKey(MetaDataContext context,\n         if (exist != null) {\n             // make existing key logical?\n             if (!_canFK) {\n-                if (exist.getDeleteAction() != exist.ACTION_NONE && !adapt)\n+                if (exist.getDeleteAction() != ForeignKey.ACTION_NONE && !adapt)\n                     throw new MetaDataException(_loc.get(prefix\n                         + \"-fk-exists\", context));\n-                exist.setDeleteAction(exist.ACTION_NONE);\n+                exist.setDeleteAction(ForeignKey.ACTION_NONE);\n             }\n \n             if (_fk != null && _fk.isDeferred() && !exist.isDeferred()) {\n@@ -1140,7 +1160,7 @@ protected ForeignKey createForeignKey(MetaDataContext context,\n             return exist;\n         }\n \n-        String name = null;\n+        DBIdentifier name = DBIdentifier.NULL;\n         int delAction = ForeignKey.ACTION_NONE;\n         int upAction = ForeignKey.ACTION_NONE;\n         boolean deferred = false;\n@@ -1149,22 +1169,22 @@ protected ForeignKey createForeignKey(MetaDataContext context,\n             : def.get(local, foreign, _join == JOIN_INVERSE);\n         if (_fk != null && (tmplate == null || (!adapt && !fill))) {\n             // if not adapting or no template info use given data\n-            name = _fk.getName();\n+            name = _fk.getIdentifier();\n             delAction = _fk.getDeleteAction();\n             upAction = _fk.getUpdateAction();\n             deferred = _fk.isDeferred();\n         } else if (_canFK && (adapt || fill)) {\n             if (_fk == null && tmplate != null) {\n                 // no user given info; use template data\n-                name = tmplate.getName();\n+                name = tmplate.getIdentifier();\n                 delAction = tmplate.getDeleteAction();\n                 upAction = tmplate.getUpdateAction();\n                 deferred = tmplate.isDeferred();\n             } else if (_fk != null && tmplate != null) {\n                 // merge user and template data, always letting user info win\n-                name = _fk.getName();\n-                if (name == null && tmplate.getName() != null)\n-                    name = tmplate.getName();\n+                name = _fk.getIdentifier();\n+                if (DBIdentifier.isNull(name) && !DBIdentifier.isNull(tmplate.getIdentifier()))\n+                    name = tmplate.getIdentifier();\n                 delAction = _fk.getDeleteAction();\n                 if (delAction == ForeignKey.ACTION_NONE)\n                     delAction = tmplate.getDeleteAction();\n@@ -1216,7 +1236,7 @@ else if ((joins[i][2] == Boolean.TRUE) != (_join == JOIN_INVERSE))\n      * Use the join information to populate our internal column I/O data.\n      */\n     private void setIOFromJoins(ForeignKey fk, Object[][] joins) {\n-        List cols = getColumns();\n+        List<Column> cols = getColumns();\n         _io = null;\n         if (cols.isEmpty())\n             return;\n@@ -1255,7 +1275,7 @@ else if ((joins[i][2] == Boolean.TRUE) == (_join == JOIN_INVERSE))\n      */\n     private Object[][] createJoins(MetaDataContext context,\n         String prefix, Table table, ClassMapping cls, ClassMapping rel,\n-        List given, ForeignKeyDefaults def, boolean inversable, boolean adapt) {\n+        List<Column> given, ForeignKeyDefaults def, boolean inversable, boolean adapt) {\n         MappingRepository repos = (MappingRepository) context.getRepository();\n         boolean fill = repos.getMappingDefaults().defaultMissingInfo();\n         Object[][] joins;\n@@ -1271,7 +1291,7 @@ else if ((joins[i][2] == Boolean.TRUE) == (_join == JOIN_INVERSE))\n             Column tmplate;\n             for (int i = 0; i < targets.length; i++) {\n                 tmplate = new Column();\n-                tmplate.setName(targets[i].getName());\n+                tmplate.setIdentifier(targets[i].getIdentifier());\n                 tmplate.setJavaType(targets[i].getJavaType());\n                 tmplate.setType(targets[i].getType());\n                 tmplate.setTypeName(targets[i].getTypeName());\n@@ -1328,16 +1348,16 @@ private void mergeJoinColumn(MetaDataContext context, String prefix,\n         ClassMapping rel, ForeignKeyDefaults def, boolean inversable,\n         boolean adapt, boolean fill) {\n         // default to the primary key column name if this is a pk join\n-        String name = given.getName();\n-        if (name == null && given != null\n+        DBIdentifier name = given.getIdentifier();\n+        if (DBIdentifier.isNull(name) && given != null\n             && given.getFlag(Column.FLAG_PK_JOIN) && cls != null) {\n             Column[] pks = cls.getPrimaryKeyColumns();\n             if (pks.length == 1)\n-                name = pks[0].getName();\n+                name = pks[0].getIdentifier();\n         }\n \n         // if we can't adapt, then the user must at least give a column name\n-        if (name == null && !adapt && !fill)\n+        if (DBIdentifier.isNull(name) && !adapt && !fill)\n             throw new MetaDataException(_loc.get(prefix + \"-no-fkcol-name\",\n                 context));\n \n@@ -1347,18 +1367,16 @@ private void mergeJoinColumn(MetaDataContext context, String prefix,\n         Table foreign = rel.getTable();\n         boolean fullName = false;\n         boolean inverse = false;\n-        if (name != null) {\n-            int dotIdx = name.lastIndexOf('.');\n-            if (dotIdx != -1) {\n-                // allow use of '.' without prefix to mean \"use expected\n-                // foreign table\"\n-                if (dotIdx == 0)\n+        if (!DBIdentifier.isNull(name)) {\n+            QualifiedDBIdentifier path = QualifiedDBIdentifier.getPath(name);\n+            if (!DBIdentifier.isNull(path.getObjectTableName())) {\n+                if (DBIdentifier.isEmpty(path.getObjectTableName()))\n                     local = foreign;\n                 else\n-                    local = findTable(context, name.substring(0, dotIdx),\n+                    local = findTable(context, path.getObjectTableName(),\n                         local, foreign, null);\n                 fullName = true;\n-                name = name.substring(dotIdx + 1);\n+                name = path.getIdentifier().getUnqualifiedName();\n \n                 // if inverse join, then swap local and foreign tables\n                 if (local != table) {\n@@ -1375,28 +1393,27 @@ private void mergeJoinColumn(MetaDataContext context, String prefix,\n         }\n \n         // determine target\n-        String targetName = given.getTarget();\n+        DBIdentifier targetName = given.getTargetIdentifier();\n         Object target = null;\n         Table ttable = null;\n         boolean constant = false;\n         boolean fullTarget = false;\n-        if (targetName == null && given.getTargetField() != null) {\n+        if (DBIdentifier.isNull(targetName) && given.getTargetField() != null) {\n             ClassMapping tcls = (inverse) ? cls : rel;\n             String fieldName = given.getTargetField();\n-            int dotIdx = fieldName.lastIndexOf('.');\n-            fullTarget = dotIdx != -1;\n+            String[] names = Normalizer.splitName(fieldName);\n+            fullTarget = names.length > 1;\n \n-            if (dotIdx == 0) {\n+            if (names.length > 1 && StringUtils.isEmpty(names[0])) {\n                 // allow use of '.' without prefix to mean \"use expected local\n                 // cls\"; but if we already inversed no need to switch again\n                 if (!inverse)\n                     tcls = cls;\n-                fieldName = fieldName.substring(1);\n-            } else if (dotIdx > 0) {\n+                fieldName = names[1];\n+            } else if (names.length > 1) {\n                 // must be class + field name\n-                tcls = findClassMapping(context, fieldName.substring\n-                    (0, dotIdx), cls, rel);\n-                fieldName = fieldName.substring(dotIdx + 1);\n+                tcls = findClassMapping(context, names[0], cls, rel);\n+                fieldName = names[1];\n             }\n             if (tcls == null)\n                 throw new MetaDataException(_loc.get(prefix\n@@ -1412,39 +1429,40 @@ private void mergeJoinColumn(MetaDataContext context, String prefix,\n                     + \"-fktargetfield-cols\", context, fieldName, name));\n             ttable = (field.getJoinForeignKey() != null) ? field.getTable()\n                 : field.getDefiningMapping().getTable();\n-            targetName = field.getColumns()[0].getName();\n-        } else if (targetName != null) {\n-            if (targetName.charAt(0) == '\\'') {\n+            targetName = field.getColumns()[0].getIdentifier();\n+        } else if (!DBIdentifier.isNull(targetName)) {\n+            String targetNameStr = targetName.getName();\n+            if (targetNameStr.charAt(0) == '\\'') {\n                 constant = true;\n-                target = targetName.substring(1, targetName.length() - 1);\n-            } else if (targetName.charAt(0) == '-'\n-                || targetName.charAt(0) == '.'\n-                || Character.isDigit(targetName.charAt(0))) {\n+                target = targetNameStr.substring(1, targetNameStr.length() - 1);\n+            } else if (targetNameStr.charAt(0) == '-'\n+                || targetNameStr.charAt(0) == '.'\n+                || Character.isDigit(targetNameStr.charAt(0))) {\n                 constant = true;\n                 try {\n-                    if (targetName.indexOf('.') == -1)\n-                        target = new Integer(targetName);\n+                    if (targetNameStr.indexOf('.') == -1)\n+                        target = new Integer(targetNameStr);\n                     else\n-                        target = new Double(targetName);\n+                        target = new Double(targetNameStr);\n                 } catch (RuntimeException re) {\n                     throw new MetaDataException(_loc.get(prefix\n                         + \"-bad-fkconst\", context, targetName, name));\n                 }\n-            } else if (\"null\".equalsIgnoreCase(targetName))\n+            } else if (\"null\".equalsIgnoreCase(targetNameStr))\n                 constant = true;\n             else {\n-                int dotIdx = targetName.lastIndexOf('.');\n-                fullTarget = dotIdx != -1;\n-                if (dotIdx == 0) {\n+                QualifiedDBIdentifier path = QualifiedDBIdentifier.getPath(targetName); \n+                fullTarget = (!DBIdentifier.isNull(path.getObjectTableName()));\n+                if (!DBIdentifier.isNull(path.getObjectTableName()) && \n+                    DBIdentifier.isEmpty(path.getObjectTableName())) {\n                     // allow use of '.' without prefix to mean \"use expected\n                     // local table\", but ignore if we're already inversed\n                     if (!inverse)\n                         ttable = local;\n-                    targetName = targetName.substring(1);\n-                } else if (dotIdx != -1) {\n-                    ttable = findTable(context, targetName.substring(0,\n-                        dotIdx), foreign, local, (inverse) ? cls : rel);\n-                    targetName = targetName.substring(dotIdx + 1);\n+                    targetName = path.getIdentifier().getUnqualifiedName();\n+                } else if (!DBIdentifier.isNull(path.getObjectTableName())) {\n+                    ttable = findTable(context, path.getObjectTableName(), foreign, local, (inverse) ? cls : rel);\n+                    targetName = path.getIdentifier().getUnqualifiedName();\n                 }\n             }\n         }\n@@ -1468,19 +1486,19 @@ private void mergeJoinColumn(MetaDataContext context, String prefix,\n         // in the column name, but not in the column target, or if the user\n         // gives no column name but a full target name\n         inverse = inverse || local != table || (local == foreign\n-            && ((fullName && !fullTarget) || (name == null && fullTarget)));\n+            && ((fullName && !fullTarget) || (DBIdentifier.isNull(name) && fullTarget)));\n         if (!inversable && !constant && inverse) {\n             if (local == foreign)\n                 throw new MetaDataException(_loc.get(prefix\n                     + \"-bad-fk-self-inverse\", context, local));\n             throw new MetaDataException(_loc.get(prefix + \"-bad-fk-inverse\",\n                 context, local, table));\n         }\n-        if (name == null && constant)\n+        if (DBIdentifier.isNull(name) && constant)\n             throw new MetaDataException(_loc.get(prefix\n                 + \"-no-fkcol-name-adapt\", context));\n \n-        if (name == null && targetName == null) {\n+        if (DBIdentifier.isNull(name) && DBIdentifier.isNull(targetName)) {\n             // if no name or target is provided and there's more than one likely\n             // join possibility, too ambiguous\n             PrimaryKey pk = foreign.getPrimaryKey();\n@@ -1489,13 +1507,13 @@ private void mergeJoinColumn(MetaDataContext context, String prefix,\n                     + \"-no-fkcol-name-adapt\", context));\n \n             // assume target is pk column\n-            targetName = pk.getColumns()[0].getName();\n-        } else if (name != null && targetName == null) {\n+            targetName = pk.getColumns()[0].getIdentifier();\n+        } else if (!DBIdentifier.isNull(name) && DBIdentifier.isNull(targetName)) {\n             // if one primary key column use it for target; if multiple joins\n             // look for a foreign column with same name as local column\n             PrimaryKey pk = foreign.getPrimaryKey();\n             if (joins.length == 1 && pk != null && pk.getColumns().length == 1) {\n-                targetName = pk.getColumns()[0].getName();\n+                targetName = pk.getColumns()[0].getIdentifier();\n             }\n             else if (foreign.getColumn(name) != null) {\n                 targetName = name;\n@@ -1509,15 +1527,15 @@ else if (foreign.getColumn(name) != null) {\n         // find the target column, and create template for local column based\n         // on it\n         Column tmplate = new Column();\n-        tmplate.setName(name);\n+        tmplate.setIdentifier(name);\n         if (!constant) {\n             Column tcol = foreign.getColumn(targetName);\n             if (tcol == null)\n                 throw new MetaDataException(_loc.get(prefix + \"-bad-fktarget\",\n                     new Object[]{ context, targetName, name, foreign }));\n \n-            if (name == null)\n-                tmplate.setName(tcol.getName());\n+            if (DBIdentifier.isNull(name))\n+                tmplate.setIdentifier(tcol.getIdentifier());\n             tmplate.setJavaType(tcol.getJavaType());\n             tmplate.setType(tcol.getType());\n             tmplate.setTypeName(tcol.getTypeName());\n@@ -1535,8 +1553,8 @@ else if (target instanceof Double)\n         if (def != null)\n             def.populate(local, foreign, tmplate, target, inverse, idx,\n                 joins.length);\n-        if (name != null)\n-            tmplate.setName(name);\n+        if (!DBIdentifier.isNull(name))\n+            tmplate.setIdentifier(name);\n \n         // create or merge local column\n         Column col = mergeColumn(context, prefix, tmplate, true, given, local,\n@@ -1589,7 +1607,7 @@ protected void syncColumns(MetaDataContext context, Column[] cols,\n         if (cols == null || cols.length == 0)\n             _cols = null;\n         else {\n-            _cols = new ArrayList(cols.length);\n+            _cols = new ArrayList<Column>(cols.length);\n             Column col;\n             for (int i = 0; i < cols.length; i++) {\n                 col = syncColumn(context, cols[i], cols.length,\n@@ -1621,7 +1639,7 @@ protected void syncIndex(MetaDataContext context, Index idx) {\n \n         _canIdx = true;\n         _idx = new Index();\n-        _idx.setName(idx.getName());\n+        _idx.setIdentifier(idx.getIdentifier());\n         _idx.setUnique(idx.isUnique());\n         if (idx.getColumns() != null && idx.getColumns().length > 1)\n             _idx.setColumns(idx.getColumns());\n@@ -1638,7 +1656,7 @@ protected void syncUnique(MetaDataContext context, Unique unq) {\n \n         _canUnq = true;\n         _unq = new Unique();\n-        _unq.setName(unq.getName());\n+        _unq.setIdentifier(unq.getIdentifier());\n         _unq.setDeferred(unq.isDeferred());\n     }\n     \n@@ -1665,7 +1683,7 @@ protected void syncForeignKey(MetaDataContext context, ForeignKey fk,\n         else {\n             _canFK = true;\n             _fk = new ForeignKey();\n-            _fk.setName(fk.getName());\n+            _fk.setIdentifier(fk.getIdentifier());\n             _fk.setDeleteAction(fk.getDeleteAction());\n             _fk.setUpdateAction(fk.getUpdateAction());\n             _fk.setDeferred(fk.isDeferred());\n@@ -1679,7 +1697,7 @@ protected void syncForeignKey(MetaDataContext context, ForeignKey fk,\n         Object[] cpks = fk.getPrimaryKeyConstants();\n \n         int size = cols.length + ccols.length + cpkCols.length;\n-        _cols = new ArrayList(size);\n+        _cols = new ArrayList<Column>(size);\n         Column col;\n         for (int i = 0; i < cols.length; i++) {\n             col = syncColumn(context, cols[i], size, false, local,\n@@ -1725,27 +1743,28 @@ protected static Column syncColumn(MetaDataContext context, Column col,\n             getDBDictionary();\n         Column copy = new Column();\n         if (col.getTable() != colTable || inverse)\n-            copy.setName(dict.getFullName(col.getTable(), true)\n-                + dict.catalogSeparator + col.getName());\n+            copy.setIdentifier(QualifiedDBIdentifier.newPath(dict.getFullIdentifier(col.getTable(), true),\n+                col.getIdentifier()));\n         else\n-            copy.setName(col.getName());\n+            copy.setIdentifier(col.getIdentifier());\n \n         // set target if not default\n         if (target != null) {\n             if (target == NULL)\n-                copy.setTarget(\"null\");\n+                copy.setTargetIdentifier(DBIdentifier.newColumn(\"null\"));\n             else if (target instanceof Column) {\n                 Column tcol = (Column) target;\n                 if ((!inverse && tcol.getTable() != targetTable)\n                     || (inverse && tcol.getTable() != colTable))\n-                    copy.setTarget(dict.getFullName(tcol.getTable(), true)\n-                        + dict.catalogSeparator + tcol.getName());\n+                    copy.setTargetIdentifier(\n+                        QualifiedDBIdentifier.newPath(dict.getFullIdentifier(tcol.getTable(), true),\n+                        tcol.getIdentifier()));\n                 else if (!defaultTarget(col, tcol, num))\n-                    copy.setTarget(tcol.getName());\n+                    copy.setTargetIdentifier(tcol.getIdentifier());\n             } else if (target instanceof Number)\n-                copy.setTarget(target.toString());\n+                copy.setTargetIdentifier(DBIdentifier.newConstant(target.toString()));\n             else\n-                copy.setTarget(\"'\" + target + \"'\");\n+                copy.setTargetIdentifier(DBIdentifier.newConstant(\"'\" + target + \"'\"));\n         } else if (num > 1)\n             copy.setTargetField(col.getTargetField());\n \n@@ -1839,7 +1858,7 @@ private static boolean isPrimitive(int type) {\n      */\n     private static boolean defaultTarget(Column col, Column targetCol,\n         int num) {\n-        if (col.getName().equals(targetCol.getName()))\n+        if (col.getIdentifier().equals(targetCol.getIdentifier()))\n             return true;\n         if (num > 1)\n             return false;\n@@ -1857,8 +1876,10 @@ private static boolean defaultTarget(Column col, Column targetCol,\n \n         /**\n          * Return the default table name.\n+         * @deprecated\n          */\n         public String get(Schema schema);\n+        public DBIdentifier getIdentifier(Schema schema);\n     }\n \n     /**"},{"sha":"61d348143b346f68380600fc9d40b2f185abd32d","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","status":"modified","additions":25,"deletions":23,"changes":48,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -30,6 +30,7 @@\n \n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.meta.strats.BlobValueHandler;\n import org.apache.openjpa.jdbc.meta.strats.ByteArrayValueHandler;\n import org.apache.openjpa.jdbc.meta.strats.CharArrayStreamValueHandler;\n@@ -112,7 +113,8 @@\n     private transient DBDictionary _dict = null;\n     private transient MappingDefaults _defaults = null;\n     \n-    private Map _results = new HashMap(); // object->queryresultmapping\n+    // object->queryresultmapping\n+    private Map<Object, QueryResultMapping> _results = new HashMap<Object, QueryResultMapping>(); \n     private SchemaGroup _schema = null;\n     private StrategyInstaller _installer = null;\n \n@@ -344,11 +346,11 @@ private static Object getQueryResultKey(QueryResultMapping res) {\n      * Return a unique key for the given class / name. The class argument\n      * can be null.\n      */\n-    private static Object getQueryResultKey(Class cls, String name) {\n+    private static Object getQueryResultKey(Class<?> cls, String name) {\n         return getQueryKey(cls, name);\n     }\n \n-    public ClassMapping getMapping(Class cls, ClassLoader envLoader,\n+    public ClassMapping getMapping(Class<?> cls, ClassLoader envLoader,\n         boolean mustExist) {\n         return (ClassMapping) super.getMetaData(cls, envLoader, mustExist);\n     }\n@@ -362,7 +364,7 @@ public ClassMapping getMapping(Object oid, ClassLoader envLoader,\n         return (ClassMapping) super.getMetaData(oid, envLoader, mustExist);\n     }\n \n-    public ClassMapping[] getImplementorMappings(Class cls,\n+    public ClassMapping[] getImplementorMappings(Class<?> cls,\n         ClassLoader envLoader, boolean mustExist) {\n         return (ClassMapping[]) super.getImplementorMetaDatas(cls, envLoader,\n             mustExist);\n@@ -415,15 +417,15 @@ protected void prepareMapping(ClassMetaData meta) {\n         mapping.resolveNonRelationMappings();\n     }\n \n-    protected ClassMetaData newClassMetaData(Class type) {\n+    protected ClassMetaData newClassMetaData(Class<?> type) {\n         return new ClassMapping(type, this);\n     }\n \n     protected ClassMetaData[] newClassMetaDataArray(int length) {\n         return new ClassMapping[length];\n     }\n \n-    protected FieldMetaData newFieldMetaData(String name, Class type,\n+    protected FieldMetaData newFieldMetaData(String name, Class<?> type,\n         ClassMetaData owner) {\n         return new FieldMapping(name, type, (ClassMapping) owner);\n     }\n@@ -530,7 +532,7 @@ protected ClassStrategy instantiateClassStrategy(String name,\n \n         String props = Configurations.getProperties(name);\n         name = Configurations.getClassName(name);\n-        Class strat = null;\n+        Class<?> strat = null;\n \n         // base and vertical strategies use same alias; differentiate on join\n         if (FullClassStrategy.ALIAS.equals(name))\n@@ -575,7 +577,7 @@ protected FieldStrategy namedStrategy(FieldMapping field,\n         String props = Configurations.getProperties(name);\n         name = Configurations.getClassName(name);\n         try {\n-            Class c = JavaTypes.classForName(name, field,\n+            Class<?> c = JavaTypes.classForName(name, field,\n                 AccessController.doPrivileged(\n                     J2DoPrivHelper.getClassLoaderAction(FieldStrategy.class)));\n             if (FieldStrategy.class.isAssignableFrom(c)) {\n@@ -636,7 +638,7 @@ protected DiscriminatorStrategy namedStrategy(Discriminator discrim) {\n \n         String props = Configurations.getProperties(name);\n         name = Configurations.getClassName(name);\n-        Class strat = null;\n+        Class<?> strat = null;\n \n         if (ClassNameDiscriminatorStrategy.ALIAS.equals(name))\n             strat = ClassNameDiscriminatorStrategy.class;\n@@ -698,7 +700,7 @@ protected VersionStrategy instantiateVersionStrategy(String name,\n \n         String props = Configurations.getProperties(name);\n         name = Configurations.getClassName(name);\n-        Class strat = null;\n+        Class<?> strat = null;\n \n         if (NumberVersionStrategy.ALIAS.equals(name))\n             strat = NumberVersionStrategy.class;\n@@ -729,7 +731,7 @@ else if (StateComparisonVersionStrategy.ALIAS.equals(name))\n     /**\n      * Instantiate the given version strategy.\n      */\n-    protected VersionStrategy instantiateVersionStrategy(Class strat,\n+    protected VersionStrategy instantiateVersionStrategy(Class<?> strat,\n         Version version, String props) {\n         try {\n             VersionStrategy strategy = (VersionStrategy)\n@@ -824,7 +826,7 @@ protected FieldStrategy defaultStrategy(FieldMapping field,\n     protected FieldStrategy defaultStrategy(FieldMapping field,\n         boolean installHandlers, boolean adapting) {\n         // not persistent?\n-        if (field.getManagement() != field.MANAGE_PERSISTENT\n+        if (field.getManagement() != FieldMetaData.MANAGE_PERSISTENT\n             || field.isVersion())\n             return NoneFieldStrategy.getInstance();\n         if (field.getDefiningMapping().getStrategy() ==\n@@ -1038,7 +1040,7 @@ private boolean useInverseKeyMapping(FieldMapping field) {\n         // an association table\n         FieldMappingInfo info = field.getMappingInfo();\n         ValueMapping elem = field.getElementMapping();\n-        boolean useInverseKeyMapping = info.getTableName() == null && info.getColumns().isEmpty()\n+        boolean useInverseKeyMapping = DBIdentifier.isNull(info.getTableIdentifier()) && info.getColumns().isEmpty()\n             && !elem.getValueInfo().getColumns().isEmpty();\n         \n         // JPA 2.0: non-default mapping: uni-/1-M/JoinColumn ==> foreign key strategy\n@@ -1157,7 +1159,7 @@ public boolean hasJoinColumn(FieldMapping field) {\n     }\n     \n     public boolean hasJoinTable(FieldMapping field) {\n-        boolean hasJoinTable = field.getMappingInfo().getTableName() != null ? true : false;\n+        boolean hasJoinTable = !DBIdentifier.isNull(field.getMappingInfo().getTableIdentifier()) ? true : false;\n         return hasJoinTable;\n     }\n \n@@ -1179,7 +1181,7 @@ public boolean isBidirectional(FieldMapping field) {\n     /**\n      * Check the given value against mapped strategies.\n      */\n-    private Object mappedStrategy(ValueMapping val, Class type,\n+    private Object mappedStrategy(ValueMapping val, Class<?> type,\n         boolean adapting) {\n         if (type == null || type == Object.class)\n             return null;\n@@ -1200,7 +1202,7 @@ private Object mappedStrategy(ValueMapping val, Class type,\n         String props = Configurations.getProperties(name);\n         name = Configurations.getClassName(name);\n         try {\n-            Class c = JavaTypes.classForName(name, val,\n+            Class<?> c = JavaTypes.classForName(name, val,\n                 AccessController.doPrivileged(\n                     J2DoPrivHelper.getClassLoaderAction(FieldStrategy.class)));\n             Object o = AccessController.doPrivileged(\n@@ -1227,7 +1229,7 @@ protected ValueHandler namedHandler(ValueMapping val) {\n         String props = Configurations.getProperties(name);\n         name = Configurations.getClassName(name);\n         try {\n-            Class c = JavaTypes.classForName(name, val,\n+            Class<?> c = JavaTypes.classForName(name, val,\n                 AccessController.doPrivileged(\n                     J2DoPrivHelper.getClassLoaderAction(ValueHandler.class)));\n             if (ValueHandler.class.isAssignableFrom(c)) {\n@@ -1344,7 +1346,7 @@ private boolean useUntypedPCHandler(ValueMapping val) {\n      * Checks for hints as to whether the given column is a CLOB.\n      */\n     private boolean isClob(ValueMapping val, boolean warn) {\n-        List cols = val.getValueInfo().getColumns();\n+        List<Column> cols = val.getValueInfo().getColumns();\n         if (cols.size() != 1)\n             return false;\n \n@@ -1511,12 +1513,12 @@ protected ClassMapping findBaseClassMapping(ClassMapping mapping) {\n                 // persistent subclasses may not have been resolved yet.  \n                 // run through the persistent types to see if any of them \n                 // or their superclass is a subclass of this class.\n-                Collection classes = loadPersistentTypes(false, \n+                Collection<Class<?>> classes = loadPersistentTypes(false, \n                         mapping.getEnvClassLoader());\n-                Class cls;\n-                for (Iterator itr = classes.iterator(); itr.hasNext();) {\n-                    cls = (Class) itr.next();\n-                    Class supcl = cls.getSuperclass();\n+                Class<?> cls;\n+                for (Iterator<Class<?>> itr = classes.iterator(); itr.hasNext();) {\n+                    cls = itr.next();\n+                    Class<?> supcl = cls.getSuperclass();\n                     while (supcl != null && \n                            !supcl.getClass().equals(java.lang.Object.class)) {\n                         if (!supcl.isInterface() &&"},{"sha":"2b58f7a829d31a5e7570b5a35a6879d061cf4fc4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingStrategyInstaller.java","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingStrategyInstaller.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingStrategyInstaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingStrategyInstaller.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -18,6 +18,8 @@\n  */\n package org.apache.openjpa.jdbc.meta;\n \n+import org.apache.openjpa.meta.MetaDataModes;\n+\n /**\n  * Installer used during mapping that attempts to use the given mapping\n  * information (if any), and fails if it does not work.\n@@ -26,6 +28,7 @@\n  * @nojavadoc\n  * @since 0.4.0\n  */\n+@SuppressWarnings(\"serial\")\n public class MappingStrategyInstaller\n     extends StrategyInstaller {\n \n@@ -45,7 +48,7 @@ public void installStrategy(ClassMapping cls) {\n         if (strat == null)\n             strat = repos.defaultStrategy(cls, true);\n         cls.setStrategy(strat, Boolean.TRUE);\n-        cls.setSourceMode(cls.MODE_MAPPING, true);\n+        cls.setSourceMode(MetaDataModes.MODE_MAPPING, true);\n     }\n \n     public void installStrategy(FieldMapping field) {"},{"sha":"9c741d7163bbe61f133a2f512c631a4c189a7737","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingTool.java","status":"modified","additions":32,"deletions":29,"changes":61,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingTool.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingTool.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -52,6 +52,8 @@\n import org.apache.openjpa.lib.conf.Configurations;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.meta.ClassArgParser;\n+import org.apache.openjpa.lib.meta.MetaDataSerializer;\n+import org.apache.openjpa.lib.meta.SourceTracker;\n import org.apache.openjpa.lib.util.Files;\n import org.apache.openjpa.lib.util.J2DoPrivHelper;\n import org.apache.openjpa.lib.util.Localizer;\n@@ -62,6 +64,7 @@\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.meta.MetaDataFactory;\n import org.apache.openjpa.meta.MetaDataModes;\n+import org.apache.openjpa.meta.MetaDataRepository;\n import org.apache.openjpa.meta.QueryMetaData;\n import org.apache.openjpa.meta.SequenceMetaData;\n import org.apache.openjpa.meta.ValueStrategies;\n@@ -123,8 +126,8 @@\n     private Writer _schemaWriter = null;\n \n     // buffer metadatas to be dropped\n-    private Set _dropCls = null;\n-    private Set _dropMap = null;\n+    private Set<Class<?>> _dropCls = null;\n+    private Set<ClassMapping> _dropMap = null;\n     private boolean _flush = false;\n     private boolean _flushSchema = false;\n \n@@ -377,7 +380,7 @@ public MappingRepository getRepository() {\n         if (_repos == null) {\n             _repos = _conf.newMappingRepositoryInstance();\n             _repos.setSchemaGroup(getSchemaGroup());\n-            _repos.setValidate(_repos.VALIDATE_UNENHANCED, false);\n+            _repos.setValidate(MetaDataRepository.VALIDATE_UNENHANCED, false);\n         }\n         return _repos;\n     }\n@@ -467,7 +470,7 @@ else if (_dropMap != null)\n \n         try {\n             if (_dropCls != null && !_dropCls.isEmpty()) {\n-                Class[] cls = (Class[]) _dropCls.toArray\n+                Class<?>[] cls = (Class[]) _dropCls.toArray\n                     (new Class[_dropCls.size()]);\n                 if (!io.drop(cls, _mode, null))\n                     _log.warn(_loc.get(\"bad-drop\", _dropCls));\n@@ -508,7 +511,7 @@ else if (_dropMap != null)\n                     // serialize the planned schema to the stream\n                     SchemaSerializer ser = new XMLSchemaSerializer(_conf);\n                     ser.addAll(getSchemaGroup());\n-                    ser.serialize(_schemaWriter, ser.PRETTY);\n+                    ser.serialize(_schemaWriter, MetaDataSerializer.PRETTY);\n                     _schemaWriter.flush();\n                 }\n             }\n@@ -517,21 +520,21 @@ else if (_dropMap != null)\n \n             QueryMetaData[] queries = repos.getQueryMetaDatas();\n             SequenceMetaData[] seqs = repos.getSequenceMetaDatas();\n-            Map output = null;\n+            Map<File, String> output = null;\n \n             // if we're outputting to stream, set all metas to same file so\n             // they get placed in single string\n             if (_mappingWriter != null) {\n-                output = new HashMap();\n+                output = new HashMap<File, String>();\n                 File tmp = new File(\"openjpatmp\");\n                 for (int i = 0; i < mappings.length; i++)\n-                    mappings[i].setSource(tmp, mappings[i].SRC_OTHER);\n+                    mappings[i].setSource(tmp, SourceTracker.SRC_OTHER);\n                 for (int i = 0; i < queries.length; i++)\n                     queries[i].setSource(tmp, queries[i].getSourceScope(),\n-                        queries[i].SRC_OTHER);\n+                        SourceTracker.SRC_OTHER);\n                 for (int i = 0; i < seqs.length; i++)\n                     seqs[i].setSource(tmp, seqs[i].getSourceScope(),\n-                        seqs[i].SRC_OTHER);\n+                        SourceTracker.SRC_OTHER);\n             }\n \n             // store\n@@ -541,9 +544,9 @@ else if (_dropMap != null)\n             // write to stream\n             if (_mappingWriter != null) {\n                 PrintWriter out = new PrintWriter(_mappingWriter);\n-                for (Iterator itr = output.values().iterator();\n+                for (Iterator<String> itr = output.values().iterator();\n                     itr.hasNext();)\n-                    out.println((String) itr.next());\n+                    out.println(itr.next());\n                 out.flush();\n             }\n         }\n@@ -634,7 +637,7 @@ else if (mapping.getIdentityStrategy() == ValueStrategies.NATIVE\n     /**\n      * Run the configured action on the given instance.\n      */\n-    public void run(Class cls) {\n+    public void run(Class<?> cls) {\n         if (ACTION_ADD.equals(_action)) {\n             if (_meta)\n                 addMeta(cls);\n@@ -653,7 +656,7 @@ else if (ACTION_VALIDATE.equals(_action))\n     /**\n      * Add the mapping for the given instance.\n      */\n-    private void add(Class cls) {\n+    private void add(Class<?> cls) {\n         if (cls == null)\n             return;\n \n@@ -669,7 +672,7 @@ private void add(Class cls) {\n      * Return the mapping for the given type, or null if the type is\n      * persistence-aware.\n      */\n-    private static ClassMapping getMapping(MappingRepository repos, Class cls,\n+    private static ClassMapping getMapping(MappingRepository repos, Class<?> cls,\n         boolean validate) {\n         // this will parse all possible metadata rsrcs looking for cls, so\n         // will detect if p-aware\n@@ -685,7 +688,7 @@ private static ClassMapping getMapping(MappingRepository repos, Class cls,\n     /**\n      * Create a metadata for the given instance.\n      */\n-    private void addMeta(Class cls) {\n+    private void addMeta(Class<?> cls) {\n         if (cls == null)\n             return;\n \n@@ -710,7 +713,7 @@ private void addMeta(Class cls) {\n     /**\n      * Refresh or add the mapping for the given instance.\n      */\n-    private void refresh(Class cls) {\n+    private void refresh(Class<?> cls) {\n         if (cls == null)\n             return;\n \n@@ -725,7 +728,7 @@ private void refresh(Class cls) {\n     /**\n      * Validate the mappings for the given class and its fields.\n      */\n-    private void validate(Class cls) {\n+    private void validate(Class<?> cls) {\n         if (cls == null)\n             return;\n \n@@ -739,7 +742,7 @@ private void validate(Class cls) {\n     /**\n      * Create the schema using the mapping for the given instance.\n      */\n-    private void buildSchema(Class cls) {\n+    private void buildSchema(Class<?> cls) {\n         if (cls == null)\n             return;\n \n@@ -770,12 +773,12 @@ private void buildSchema(Class cls) {\n     /**\n      * Drop mapping for given class.\n      */\n-    private void drop(Class cls) {\n+    private void drop(Class<?> cls) {\n         if (cls == null)\n             return;\n \n         if (_dropCls == null)\n-            _dropCls = new HashSet();\n+            _dropCls = new HashSet<Class<?>>();\n         _dropCls.add(cls);\n         if (!contains(_schemaActions,SchemaTool.ACTION_DROP))\n             return;\n@@ -791,7 +794,7 @@ private void drop(Class cls) {\n         if (mapping != null) {\n             _flushSchema = true;\n             if (_dropMap == null)\n-                _dropMap = new HashSet();\n+                _dropMap = new HashSet<ClassMapping>();\n             _dropMap.add(mapping);\n         } else\n             _log.warn(_loc.get(\"no-drop-meta\", cls));\n@@ -1003,26 +1006,26 @@ public static boolean run(JDBCConfiguration conf, String[] args,\n \n         // collect the classes to act on\n         Log log = conf.getLog(OpenJPAConfiguration.LOG_TOOL);\n-        Collection classes = null;\n+        Collection<Class<?>> classes = null;\n         if (args.length == 0) {\n             if (ACTION_IMPORT.equals(flags.action))\n                 return false;\n             log.info(_loc.get(\"running-all-classes\"));\n             classes = conf.getMappingRepositoryInstance().\n                 loadPersistentTypes(true, loader);\n         } else {\n-            classes = new HashSet();\n+            classes = new HashSet<Class<?>>();\n             ClassArgParser classParser = conf.getMetaDataRepositoryInstance().\n                 getMetaDataFactory().newClassArgParser();\n             classParser.setClassLoader(loader);\n-            Class[] parsed;\n+            Class<?>[] parsed;\n             for (int i = 0; args != null && i < args.length; i++) {\n                 parsed = classParser.parseTypes(args[i]);\n                 classes.addAll(Arrays.asList(parsed));\n             }\n         }\n \n-        Class[] act = (Class[]) classes.toArray(new Class[classes.size()]);\n+        Class<?>[] act = (Class[]) classes.toArray(new Class[classes.size()]);\n         if (ACTION_EXPORT.equals(flags.action)) {\n             // run exports until the first export succeeds\n             ImportExport[] instances = newImportExports();\n@@ -1081,7 +1084,7 @@ public static boolean run(JDBCConfiguration conf, String[] args,\n      */\n     private static ImportExport[] newImportExports() {\n         try {\n-            Class[] types = Services.getImplementorClasses(ImportExport.class);\n+            Class<?>[] types = Services.getImplementorClasses(ImportExport.class);\n             ImportExport[] instances = new ImportExport[types.length];\n             for (int i = 0; i < types.length; i++)\n                 instances[i] = (ImportExport) AccessController.doPrivileged(\n@@ -1129,14 +1132,14 @@ private static boolean contains(String list, String key) {\n         /**\n          * Import mappings for the given classes based on the given arguments.\n          */\n-        public boolean importMappings(JDBCConfiguration conf, Class[] act,\n+        public boolean importMappings(JDBCConfiguration conf, Class<?>[] act,\n             String[] args, boolean meta, Log log, ClassLoader loader)\n             throws IOException;\n \n         /**\n          * Export mappings for the given classes based on the given arguments.\n          */\n-        public boolean exportMappings(JDBCConfiguration conf, Class[] act,\n+        public boolean exportMappings(JDBCConfiguration conf, Class<?>[] act,\n             boolean meta, Log log, Writer writer)\n             throws IOException;\n     }"},{"sha":"4500a0522c56146f9992fd9be4c1183693e16562","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneMappingDefaults.java","status":"modified","additions":55,"deletions":1,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneMappingDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneMappingDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/NoneMappingDefaults.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.openjpa.jdbc.meta;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n import org.apache.openjpa.jdbc.schema.Index;\n@@ -63,7 +64,7 @@ public Object getStrategy(Discriminator disc, boolean adapt) {\n         return null;\n     }\n \n-    public Object getStrategy(ValueMapping vm, Class type, boolean adapt) {\n+    public Object getStrategy(ValueMapping vm, Class<?> type, boolean adapt) {\n         return null;\n     }\n \n@@ -98,11 +99,17 @@ public void populateJoinColumn(FieldMapping fm, Table local, Table foreign,\n         Column col, Object target, int pos, int cols) {\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public void populateForeignKeyColumn(ValueMapping vm, String name,\n         Table local, Table foreign, Column col, Object target, boolean inverse,\n         int pos, int cols) {\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public void populateColumns(ValueMapping vm, String name, Table table,\n         Column[] cols) {\n     }\n@@ -112,6 +119,9 @@ public boolean populateOrderColumns(FieldMapping fm, Table table,\n         return false;\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public boolean populateNullIndicatorColumns(ValueMapping vm, String name,\n         Table table, Column[] cols) {\n         return false;\n@@ -127,6 +137,9 @@ public ForeignKey getJoinForeignKey(FieldMapping fm, Table local,\n         return null;\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public ForeignKey getForeignKey(ValueMapping vm, String name, Table local,\n         Table foreign, boolean inverse) {\n         return null;\n@@ -164,4 +177,45 @@ public String getPrimaryKeyName(ClassMapping cm, Table table) {\n \n     public void installPrimaryKey(FieldMapping fm, Table table) {\n     }\n+\n+    public ForeignKey getForeignKey(ValueMapping vm, DBIdentifier name, Table local,\n+        Table foreign, boolean inverse) {\n+        return null;\n+    }\n+\n+    public Index getIndex(ValueMapping vm, DBIdentifier name, Table table,\n+        Column[] cols) {\n+        return null;\n+    }\n+\n+    public Unique getUnique(ValueMapping vm, DBIdentifier name, Table table,\n+        Column[] cols) {\n+        return null;\n+    }\n+\n+    public void populateColumns(ValueMapping vm, DBIdentifier name, Table table,\n+        Column[] cols) {\n+    }\n+\n+    public void populateForeignKeyColumn(ValueMapping vm, DBIdentifier name,\n+        Table local, Table foreign, Column col, Object target, boolean inverse,\n+        int pos, int cols) {\n+    }\n+\n+    public boolean populateNullIndicatorColumns(ValueMapping vm, DBIdentifier name,\n+        Table table, Column[] cols) {\n+        return false;\n+    }\n+\n+    public DBIdentifier getTableIdentifier(ClassMapping cls, Schema defaultSchema) {\n+        return DBIdentifier.newTable(getTableName(cls, defaultSchema));\n+    }\n+\n+    public DBIdentifier getTableIdentifier(FieldMapping fm, Schema defaultSchema) {\n+        return DBIdentifier.newTable(getTableName(fm, defaultSchema));\n+    }\n+\n+    public DBIdentifier getPrimaryKeyIdentifier(ClassMapping cm, Table table) {\n+        return DBIdentifier.NULL;\n+    }\n }"},{"sha":"9b9fd93f6f9bdc99eb59fc131eb8a533da61f2e2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseMappingTool.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseMappingTool.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseMappingTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ReverseMappingTool.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -100,7 +100,7 @@\n import serp.util.Strings;\n \n /**\n- * Reverse-maps a schema into class mappings and the assiciated java\n+ * Reverse-maps a schema into class mappings and the associated java\n  * code. Generates a Java code files for persistent classes and associated\n  * identity classes and metadata.\n  *"},{"sha":"ae59eb23071fe4429b6f90e9ac717c596a341eb0","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/SequenceMapping.java","status":"modified","additions":100,"deletions":25,"changes":125,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/SequenceMapping.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/SequenceMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/SequenceMapping.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -19,25 +19,24 @@\n package org.apache.openjpa.jdbc.meta;\n \n import java.io.File;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n \n import org.apache.commons.lang.StringUtils;\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.jdbc.conf.JDBCSeqValue;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n import org.apache.openjpa.jdbc.kernel.ClassTableJDBCSeq;\n import org.apache.openjpa.jdbc.kernel.TableJDBCSeq;\n import org.apache.openjpa.jdbc.kernel.ValueTableJDBCSeq;\n-import org.apache.openjpa.jdbc.schema.Unique;\n import org.apache.openjpa.lib.conf.PluginValue;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n import org.apache.openjpa.meta.SequenceMetaData;\n \n /**\n  * Specialization of sequence metadata for ORM.\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public class SequenceMapping\n     extends SequenceMetaData {\n \n@@ -65,17 +64,32 @@\n     private static final String PROP_UNIQUE_CONSTRAINT = \"UniqueConstraintName\";\n \n     private File _mapFile = null;\n-    private String _table = null;\n-    private String _sequenceColumn = null;\n-    private String _primaryKeyColumn = null;\n+    private DBIdentifier _table = DBIdentifier.NULL;\n+    private DBIdentifier _sequenceColumn = DBIdentifier.NULL;\n+    private DBIdentifier _primaryKeyColumn = DBIdentifier.NULL;\n     private String _primaryKeyValue = null;\n-    private String[] _uniqueColumns   = null;\n-    private String _uniqueConstraintName = null;\n+    private DBIdentifier[] _uniqueColumns   = null;\n+    private DBIdentifier _uniqueConstraintName = DBIdentifier.NULL;\n     \n+    /**\n+     * @deprecated\n+     * @param name\n+     * @param repos\n+     */\n     public SequenceMapping(String name, MappingRepository repos) {\n         super(name, repos);\n     }\n \n+    /**\n+     * Sequence names are a kernel object so DBIdentifiers must be converted to\n+     * strings \n+     * @param name\n+     * @param repos\n+     */\n+    public SequenceMapping(DBIdentifier name, MappingRepository repos) {\n+        super(DBIdentifier.isNull(name) ? null : name.getName(), repos);\n+    }\n+\n     /**\n      * Allow sequence to have a mapping file separate from its metadata\n      * source file.\n@@ -94,43 +108,73 @@ public void setMappingFile(File file) {\n \n     /**\n      * Name of sequence table, if any.\n+     * @deprecated\n      */\n     public String getTable() {\n-        return _table;\n+        return getTableIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getTableIdentifier() {\n+        return _table == null ? DBIdentifier.NULL : _table ;\n     }\n \n     /**\n      * Name of sequence table, if any.\n+     * @deprecated\n      */\n     public void setTable(String table) {\n+        setTableIdentifier(DBIdentifier.newTable(table));\n+    }\n+\n+    public void setTableIdentifier(DBIdentifier table) {\n         _table = table;\n     }\n \n     /**\n      * Name of sequence column, if any.\n+     * @deprecated\n      */\n     public String getSequenceColumn() {\n-        return _sequenceColumn;\n+        return getSequenceColumnIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getSequenceColumnIdentifier() {\n+        return _sequenceColumn == null ? DBIdentifier.NULL : _sequenceColumn;\n     }\n \n     /**\n      * Name of sequence column, if any.\n+     * @deprecated\n      */\n     public void setSequenceColumn(String sequenceColumn) {\n+        setSequenceColumnIdentifier(DBIdentifier.newColumn(sequenceColumn));\n+    }\n+\n+    public void setSequenceColumnIdentifier(DBIdentifier sequenceColumn) {\n         _sequenceColumn = sequenceColumn;\n     }\n \n     /**\n      * Name of primary key column, if any.\n+     * @deprecated\n      */\n     public String getPrimaryKeyColumn() {\n-        return _primaryKeyColumn;\n+        return getPrimaryKeyColumnIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getPrimaryKeyColumnIdentifier() {\n+        return _primaryKeyColumn == null ? DBIdentifier.NULL : _primaryKeyColumn;\n     }\n \n     /**\n      * Name of primary key column, if any.\n+     * @deprecated\n      */\n     public void setPrimaryKeyColumn(String primaryKeyColumn) {\n+        setPrimaryKeyColumnIdentifier(DBIdentifier.newColumn(primaryKeyColumn));\n+    }\n+\n+    public void setPrimaryKeyColumnIdentifier(DBIdentifier primaryKeyColumn) {\n         _primaryKeyColumn = primaryKeyColumn;\n     }\n \n@@ -148,13 +192,29 @@ public void setPrimaryKeyValue(String primaryKeyValue) {\n         _primaryKeyValue = primaryKeyValue;\n     }\n \n+    /**\n+     * @deprecated\n+     * @param cols\n+     */\n     public void setUniqueColumns(String[] cols) {\n-    \t_uniqueColumns = cols;\n+        setUniqueColumnsIdentifier(DBIdentifier.toArray(cols, DBIdentifierType.COLUMN));\n     }\n-    \n+\n+    public void setUniqueColumnsIdentifier(DBIdentifier[] cols) {\n+        _uniqueColumns = cols;\n+    }\n+\n+    /**\n+     * @deprecated\n+     */\n     public String[] getUniqueColumns() {\n+        return DBIdentifier.toStringArray(getUniqueColumnsIdentifier());\n+    }\n+\n+    public DBIdentifier[] getUniqueColumnsIdentifier() {\n     \treturn _uniqueColumns;\n     }\n+\n     \n     protected PluginValue newPluginValue(String property) {\n         return new JDBCSeqValue(property);\n@@ -170,17 +230,17 @@ protected void addStandardProperties(StringBuilder props) {\n         // set preserves the intended ones. While this is an ugly solution,\n         // it's less ugly than other ones.\n         \n-        appendProperty(props, PROP_TABLE, addQuotes(_table));\n-        appendProperty(props, PROP_SEQUENCE_COL, addQuotes(_sequenceColumn));\n-        appendProperty(props, PROP_PK_COL, addQuotes(_primaryKeyColumn));\n+        appendProperty(props, PROP_TABLE, addQuotes(_table.getName()));\n+        appendProperty(props, PROP_SEQUENCE_COL, addQuotes(_sequenceColumn.getName()));\n+        appendProperty(props, PROP_PK_COL, addQuotes(_primaryKeyColumn.getName()));\n         appendProperty(props, PROP_PK_VALUE, addQuotes(_primaryKeyValue));\n         // Array of unique column names are passed to configuration\n         // as a single string \"x|y|z\". The configurable (TableJDBCSeq) must\n         // parse it back.\n-        if (_uniqueConstraintName != null && \n-                _uniqueConstraintName.length() > 0) {\n+        if (!DBIdentifier.isNull(_uniqueConstraintName) && \n+                _uniqueConstraintName.getName().length() > 0) {\n             appendProperty(props, PROP_UNIQUE_CONSTRAINT, \n-                addQuotes(_uniqueConstraintName));\n+                addQuotes(_uniqueConstraintName.getName()));\n         }\n             \n         if (_uniqueColumns != null && _uniqueColumns.length > 0)\n@@ -189,19 +249,34 @@ protected void addStandardProperties(StringBuilder props) {\n     }\n     \n     private String addQuotes(String name) {\n-        if (name != null && name.startsWith(\"\\\"\") && name.endsWith(\"\\\"\")) {\n-            return \"\\\"\" + name + \"\\\"\";\n+        if (name != null && name.contains(IdentifierUtil.DOUBLE_QUOTE)) {\n+            return IdentifierUtil.DOUBLE_QUOTE + name + IdentifierUtil.DOUBLE_QUOTE;\n         }\n         return name;\n     }\n \n+    /**\n+     * @deprecated\n+     * @param name\n+     */\n     public void setUniqueConstraintName(String name) {\n+        _uniqueConstraintName = DBIdentifier.newConstraint(name);\n+    }\n+\n+    public void setUniqueConstraintIdentifier(DBIdentifier name) {\n         _uniqueConstraintName = name;\n-        \n     }\n \n+    /**\n+     * @deprecated\n+     * @return\n+     */\n     public String getUniqueConstraintName() {\n-        return _uniqueConstraintName;\n+        return getUniqueConstraintIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getUniqueConstraintIdentifier() {\n+        return _uniqueConstraintName == null ? DBIdentifier.NULL : _uniqueConstraintName;\n         \n     }\n }"},{"sha":"25eb973787e60f14121555b7e5a36c9dd0c0387e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMapping.java","status":"modified","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMapping.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMapping.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -21,6 +21,7 @@\n import java.io.Serializable;\n import java.sql.SQLException;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n@@ -249,9 +250,17 @@ public void whereForeignKey(Row row, OpenJPAStateManager rel)\n      * Map indexes and constraints for this value, using the current\n      * {@link ValueMappingInfo}. The foreign key or columns of this value\n      * must be set before calling this method.\n+     * @deprecated\n      */\n     public void mapConstraints(String name, boolean adapt);\n \n+    /**\n+     * Map indexes and constraints for this value, using the current\n+     * {@link ValueMappingInfo}. The foreign key or columns of this value\n+     * must be set before calling this method.\n+     */\n+    public void mapConstraints(DBIdentifier name, boolean adapt);\n+\n     /**\n      * Clear mapping information, including strategy.\n      */"},{"sha":"13fe736184b2f9a7eb76bdf9e11ee3c931da88a2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingImpl.java","status":"modified","additions":18,"deletions":9,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingImpl.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingImpl.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -22,6 +22,7 @@\n import java.util.HashMap;\n import java.util.Map;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n@@ -45,6 +46,7 @@\n  * @author Abe White\n  * @since 0.4.0\n  */\n+@SuppressWarnings(\"serial\")\n public class ValueMappingImpl\n     extends ValueMetaDataImpl\n     implements ValueMapping {\n@@ -59,7 +61,7 @@\n     private Column[] _cols = Schemas.EMPTY_COLUMNS;\n     private ColumnIO _io = null;\n     private ForeignKey _fk = null;\n-    private Map _targetFKs = null;\n+    private Map<ClassMapping,ForeignKey> _targetFKs = null;\n     private Index _idx = null;\n     private Unique _unq = null;\n     private int _join = JOIN_FORWARD;\n@@ -188,7 +190,7 @@ public ForeignKey getForeignKey(ClassMapping target) {\n                 if (cachedFK != null)\n                     return (ForeignKey) cachedFK;\n             } else\n-                _targetFKs = new HashMap();\n+                _targetFKs = new HashMap<ClassMapping, ForeignKey>();\n \n             ForeignKey newfk = (_join == JOIN_FORWARD)\n                 ? newForwardForeignKey(target) : newInverseForeignKey(target);\n@@ -220,12 +222,12 @@ private ForeignKey newForwardForeignKey(ClassMapping target) {\n                     cols[i].getTargetField());\n             else if (_fk != null)\n                 tcols[i] = getEquivalentColumn(_fk.getPrimaryKeyColumn\n-                    (cols[i]).getName(), target, true);\n-            else if (cols[i].getTarget() != null)\n-                tcols[i] = getEquivalentColumn(cols[i].getTarget(), target,\n+                    (cols[i]).getIdentifier(), target, true);\n+            else if (!DBIdentifier.isNull(cols[i].getTargetIdentifier()))\n+                tcols[i] = getEquivalentColumn(cols[i].getTargetIdentifier(), target,\n                     true);\n             else\n-                tcols[i] = getEquivalentColumn(cols[i].getName(), target,\n+                tcols[i] = getEquivalentColumn(cols[i].getIdentifier(), target,\n                     false);\n         }\n \n@@ -239,7 +241,7 @@ else if (cols[i].getTarget() != null)\n             cols = _fk.getConstantPrimaryKeyColumns();\n             for (int i = 0; i < cols.length; i++)\n                 newfk.joinConstant(_fk.getPrimaryKeyConstant(cols[i]),\n-                    getEquivalentColumn(cols[i].getName(), target, true));\n+                    getEquivalentColumn(cols[i].getIdentifier(), target, true));\n         }\n         return newfk;\n     }\n@@ -267,7 +269,7 @@ private Column getEquivalentColumn(Column col, ClassMapping target,\n     /**\n      * Return the given mapping's equivalent of the given column.\n      */\n-    private Column getEquivalentColumn(String colName, ClassMapping target,\n+    private Column getEquivalentColumn(DBIdentifier colName, ClassMapping target,\n         boolean explicit) {\n         // if there was no explicit target, use single pk column\n         if (!explicit) {\n@@ -433,11 +435,18 @@ public void refSchemaComponents() {\n             embed.refSchemaComponents();\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public void mapConstraints(String name, boolean adapt) {\n+        mapConstraints(DBIdentifier.newConstraint(name), adapt);\n+    }\n+\n+    public void mapConstraints(DBIdentifier name, boolean adapt) {\n         _unq = _info.getUnique(this, name, adapt);\n         _idx = _info.getIndex(this, name, adapt);\n     }\n-\n+    \n     public void clearMapping() {\n         _handler = null;\n         _cols = Schemas.EMPTY_COLUMNS;"},{"sha":"c9881674f6e4eb558b0f446d7d8a93530367909a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingInfo.java","status":"modified","additions":53,"deletions":13,"changes":66,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ValueMappingInfo.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -21,6 +21,7 @@\n import java.util.Collections;\n import java.util.List;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n@@ -40,6 +41,7 @@\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public class ValueMappingInfo\n     extends MappingInfo {\n \n@@ -48,7 +50,7 @@\n \n     private boolean _criteria = false;\n     private boolean _canNull = true;\n-    private List _mapsIdCols = null;\n+    private List<Column> _mapsIdCols = null;\n \n     /**\n      * Whether to use class criteria when joining to related type.\n@@ -83,8 +85,14 @@ public void setCanIndicateNull(boolean ind) {\n      *\n      * @param name base name for value mapping\n      * @param inversable whether an inverse join is allowed\n+     * @deprecated\n      */\n     public ForeignKey getTypeJoin(final ValueMapping val, final String name,\n+        boolean inversable, boolean adapt) {\n+        return getTypeJoin(val, DBIdentifier.newForeignKey(name), inversable, adapt);\n+    }\n+\n+    public ForeignKey getTypeJoin(final ValueMapping val, final DBIdentifier name,\n         boolean inversable, boolean adapt) {\n         ClassMapping rel = val.getTypeMapping();\n         if (rel == null)\n@@ -123,9 +131,15 @@ public Table getTable(ValueMapping val) {\n     \n     /**\n      * Return the join from the related type to this value.\n+     * @deprecated\n      */\n     public ForeignKey getInverseTypeJoin(final ValueMapping val,\n         final String name, boolean adapt) {\n+        return getInverseTypeJoin(val, DBIdentifier.newForeignKey(name), adapt);\n+    }\n+\n+    public ForeignKey getInverseTypeJoin(final ValueMapping val,\n+        final DBIdentifier name, boolean adapt) {\n         ClassMapping rel = val.getTypeMapping();\n         if (rel == null || rel.getTable() == null)\n             return null;\n@@ -149,8 +163,14 @@ public void populate(Table local, Table foreign, Column col,\n \n     /**\n      * Return the columns for this value, based on the given templates.\n+     * @deprecated\n      */\n     public Column[] getColumns(ValueMapping val, String name,\n+        Column[] tmplates, Table table, boolean adapt) {\n+        return getColumns(val, DBIdentifier.newColumn(name), tmplates, table, adapt);\n+    }\n+\n+    public Column[] getColumns(ValueMapping val, DBIdentifier name,\n         Column[] tmplates, Table table, boolean adapt) {\n         orderColumnsByTargetField(val, tmplates, adapt);\n         val.getMappingRepository().getMappingDefaults().populateColumns\n@@ -166,7 +186,7 @@ private void orderColumnsByTargetField(ValueMapping val, Column[] tmplates,\n         boolean adapt) {\n         if (tmplates.length < 2 || tmplates[0].getTargetField() == null)\n             return;\n-        List cols = getColumns();\n+        List<Column> cols = getColumns();\n         if (cols.isEmpty() || cols.size() != tmplates.length)\n             return;\n \n@@ -200,8 +220,13 @@ public int findTargetField(Column[] tmplates, String target) {\n \n     /**\n      * Return a unique constraint for the given columns, or null if none.\n+     * @deprecated\n      */\n     public Unique getUnique(ValueMapping val, String name, boolean adapt) {\n+        return getUnique(val, DBIdentifier.newConstraint(name), adapt);\n+    }\n+\n+    public Unique getUnique(ValueMapping val, DBIdentifier name, boolean adapt) {\n         Column[] cols = val.getColumns();\n         if (cols.length == 0)\n             return null;\n@@ -213,8 +238,13 @@ public Unique getUnique(ValueMapping val, String name, boolean adapt) {\n \n     /**\n      * Return an index for the given columns, or null if none.\n+     * @deprecated\n      */\n     public Index getIndex(ValueMapping val, String name, boolean adapt) {\n+        return getIndex(val, DBIdentifier.newIndex(name), adapt);\n+    }\n+\n+    public Index getIndex(ValueMapping val, DBIdentifier name, boolean adapt) {\n         Column[] cols = val.getColumns();\n         if (cols.length == 0)\n             return null;\n@@ -226,8 +256,14 @@ public Index getIndex(ValueMapping val, String name, boolean adapt) {\n \n     /**\n      * Return the null indicator column for this value, or null if none.\n+     * @deprecated\n      */\n     public Column getNullIndicatorColumn(ValueMapping val, String name,\n+        Table table, boolean adapt) {\n+        return getNullIndicatorColumn(val, DBIdentifier.newColumn(name), table, adapt);\n+    }\n+\n+    public Column getNullIndicatorColumn(ValueMapping val, DBIdentifier name,\n         Table table, boolean adapt) {\n         // reset IO\n         setColumnIO(null);\n@@ -237,14 +273,15 @@ public Column getNullIndicatorColumn(ValueMapping val, String name,\n             return null;\n \n         // extract given null-ind column\n-        List cols = getColumns();\n+        List<Column> cols = getColumns();\n         Column given = (cols.isEmpty()) ? null : (Column) cols.get(0);\n         MappingDefaults def = val.getMappingRepository().getMappingDefaults();\n         if (given == null && (!adapt && !def.defaultMissingInfo()))\n             return null;\n \n         Column tmplate = new Column();\n-        tmplate.setName(name + \"_null\");\n+        DBIdentifier sName = DBIdentifier.append(name, \"_null\");\n+        tmplate.setIdentifier(sName);\n         tmplate.setJavaType(JavaTypes.INT);\n         if (!def.populateNullIndicatorColumns(val, name, table, new Column[]\n             { tmplate }) && given == null)\n@@ -258,17 +295,17 @@ public Column getNullIndicatorColumn(ValueMapping val, String name,\n             setColumnIO(io);\n         }\n \n-        if (given != null && given.getName() != null) {\n+        if (given != null && !DBIdentifier.isNull(given.getIdentifier())) {\n             // test if given column name is actually a field name, in which\n             // case we use its column as the null indicator column\n             ClassMapping embed = val.getEmbeddedMapping();\n             FieldMapping efm = (embed == null) ? null\n-                : embed.getFieldMapping(given.getName());\n+                : embed.getFieldMapping(given.getIdentifier().getName());\n             if (efm != null && efm.getColumns().length > 0)\n-                given.setName(efm.getColumns()[0].getName());\n+                given.setIdentifier(efm.getColumns()[0].getIdentifier());\n         }\n-        boolean compat = given == null || given.getName() == null\n-            || table == null || !table.isNameTaken(given.getName());\n+        boolean compat = given == null || DBIdentifier.isNull(given.getIdentifier())\n+            || table == null || !table.isNameTaken(given.getIdentifier());\n \n         return mergeColumn(val, \"null-ind\", tmplate, compat, given,\n             table, adapt, def.defaultMissingInfo());\n@@ -295,7 +332,7 @@ public void syncWith(ValueMapping val) {\n                 setJoinDirection(JOIN_FORWARD);\n             } else {\n                 foreign = val.getTypeMapping().getTable();\n-                setJoinDirection((val.getJoinDirection() == val.JOIN_FORWARD)\n+                setJoinDirection((val.getJoinDirection() == ValueMapping.JOIN_FORWARD)\n                     ? JOIN_FORWARD : JOIN_INVERSE);\n             }\n             syncForeignKey(val, val.getForeignKey(), local, foreign);\n@@ -337,14 +374,17 @@ public void copy(MappingInfo info) {\n     /**\n      * Raw column data.\n      */\n-    public List getMapsIdColumns() {\n-        return (_mapsIdCols == null) ? Collections.EMPTY_LIST : _mapsIdCols;\n+    public List<Column> getMapsIdColumns() {\n+        if (_mapsIdCols == null) {\n+            return Collections.emptyList();\n+        }\n+        return  _mapsIdCols;\n     }\n     \n     /**\n      * Raw column data.\n      */\n-    public void setMapsIdColumns(List cols) {\n+    public void setMapsIdColumns(List<Column> cols) {\n         _mapsIdCols = cols;\n     }\n }"},{"sha":"60f9e840a04eaf341aeb4bf69f81e0c7c7ab0d6b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionMappingInfo.java","status":"modified","additions":11,"deletions":11,"changes":22,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionMappingInfo.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionMappingInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/VersionMappingInfo.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -26,7 +26,7 @@\n import java.util.Map;\n import java.util.Set;\n \n-import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.meta.strats.NoneVersionStrategy;\n import org.apache.openjpa.jdbc.meta.strats.SuperclassVersionStrategy;\n import org.apache.openjpa.jdbc.schema.Column;\n@@ -69,21 +69,21 @@\n     public Column[] getMultiTableColumns(Version vers, Column[] templates,\n             boolean adapt) {\n     \tTable primaryTable = vers.getClassMapping().getTable();\n-    \tList<String> secondaryTableNames = Arrays.asList(vers\n-                .getClassMapping().getMappingInfo().getSecondaryTableNames());\n+    \tList<DBIdentifier> secondaryTableNames = Arrays.asList(vers\n+                .getClassMapping().getMappingInfo().getSecondaryTableIdentifiers());\n         Map<Table, List<Column>> assign = new LinkedHashMap<Table,\n                 List<Column>>();\n     \tfor (Column col : templates) {\n-    \t    String tableName = col.getTableName();\n+    \t    DBIdentifier tableName = col.getTableIdentifier();\n     \t    Table table;\n-    \t\tif (StringUtils.isEmpty(tableName) \n-    \t\t  || tableName.equals(primaryTable.getName())) {\n+    \t\tif (DBIdentifier.isEmpty(tableName) \n+    \t\t  || tableName.equals(primaryTable.getIdentifier())) {\n     \t\t\ttable = primaryTable;\n     \t\t} else if (secondaryTableNames.contains(tableName)) {\n     \t\t\ttable = primaryTable.getSchema().getTable(tableName);\n     \t\t} else {\n                 throw new UserException(_loc.get(\"bad-version-column-table\",\n-    \t\t\t\t\tcol.getName(), tableName));\n+    \t\t\t\t\tcol.getIdentifier().toString(), tableName));\n     \t\t}\n     \t\tif (!assign.containsKey(table))\n     \t\t\tassign.put(table, new ArrayList<Column>());\n@@ -147,9 +147,9 @@ public void syncWith(Version version) {\n     boolean spansMultipleTables(Column[] cols) {\n     \tif (cols == null || cols.length <= 1) \n     \t\treturn false;\n-    \tSet<String> tables = new HashSet<String>();\n+    \tSet<DBIdentifier> tables = new HashSet<DBIdentifier>();\n     \tfor (Column col : cols)\n-    \t\tif (tables.add(col.getTableName()) && tables.size() > 1)\n+    \t\tif (tables.add(col.getTableIdentifier()) && tables.size() > 1)\n     \t\t\treturn true;\n     \treturn false;\n     }\n@@ -159,10 +159,10 @@ boolean spansMultipleTables(Column[] cols) {\n      */\n     private Table getSingleTable(Version version, Column[] cols) {\n     \tif (cols == null || cols.length == 0 \n-    \t || StringUtils.isEmpty(cols[0].getTableName()))\n+    \t || DBIdentifier.isEmpty(cols[0].getTableIdentifier()))\n     \t\treturn version.getClassMapping().getTable();\n     \treturn version.getClassMapping().getTable().getSchema()\n-    \t\t.getTable(cols[0].getTableName());\n+    \t\t.getTable(cols[0].getTableIdentifier());\n     }\n \n "},{"sha":"f578486fdb31a4b726b39d4fef219a1d863efd77","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/BlobValueHandler.java","status":"modified","additions":13,"deletions":1,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/BlobValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/BlobValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/BlobValueHandler.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -18,9 +18,11 @@\n  */\n package org.apache.openjpa.jdbc.meta.strats;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.meta.ValueMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.meta.JavaTypes;\n \n /**\n@@ -40,10 +42,20 @@ public static BlobValueHandler getInstance() {\n         return _instance;\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public Column[] map(ValueMapping vm, String name, ColumnIO io,\n+        boolean adapt) {\n+        DBDictionary dict = vm.getMappingRepository().getDBDictionary();\n+        DBIdentifier colName = DBIdentifier.newColumn(name, dict != null ? dict.delimitAll() : false);\n+        return map(vm, colName, io, adapt);\n+    }\n+\n+    public Column[] map(ValueMapping vm, DBIdentifier name, ColumnIO io,\n         boolean adapt) {\n         Column col = new Column();\n-        col.setName(name);\n+        col.setIdentifier(name);\n         col.setJavaType(JavaTypes.OBJECT);\n         col.setSize(-1);\n         return new Column[]{ col };"},{"sha":"ca068ba11c12e1b6a264401c25c2ec4f41d13395","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ByteArrayValueHandler.java","status":"modified","additions":13,"deletions":1,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ByteArrayValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ByteArrayValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ByteArrayValueHandler.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -18,11 +18,13 @@\n  */\n package org.apache.openjpa.jdbc.meta.strats;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n import org.apache.openjpa.jdbc.meta.ValueMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n \n /**\n  * Handler for byte array values.\n@@ -42,10 +44,20 @@ public static ByteArrayValueHandler getInstance() {\n         return _instance;\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public Column[] map(ValueMapping vm, String name, ColumnIO io,\n+        boolean adapt) {\n+        DBDictionary dict = vm.getMappingRepository().getDBDictionary();\n+        DBIdentifier colName = DBIdentifier.newColumn(name, dict != null ? dict.delimitAll() : false);\n+        return map(vm, colName, io, adapt);\n+    }\n+\n+    public Column[] map(ValueMapping vm, DBIdentifier name, ColumnIO io,\n         boolean adapt) {\n         Column col = new Column();\n-        col.setName(name);\n+        col.setIdentifier(name);\n         col.setJavaType(JavaSQLTypes.BYTES);\n         col.setSize(-1);\n         return new Column[]{ col };"},{"sha":"a2e6f0313000014c37527776d7d4252264ddd18a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayStreamValueHandler.java","status":"modified","additions":13,"deletions":1,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayStreamValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayStreamValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayStreamValueHandler.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -23,11 +23,13 @@\n import java.io.IOException;\n import java.io.Reader;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n import org.apache.openjpa.jdbc.meta.ValueMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.Sized;\n import org.apache.openjpa.util.StoreException;\n \n@@ -49,10 +51,20 @@ public static CharArrayStreamValueHandler getInstance() {\n         return _instance;\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public Column[] map(ValueMapping vm, String name, ColumnIO io,\n+        boolean adapt) {\n+        DBDictionary dict = vm.getMappingRepository().getDBDictionary();\n+        DBIdentifier colName = DBIdentifier.newColumn(name, dict != null ? dict.delimitAll() : false);\n+        return map(vm, colName, io, adapt);\n+    }\n+\n+    public Column[] map(ValueMapping vm, DBIdentifier name, ColumnIO io,\n         boolean adapt) {\n         Column col = new Column();\n-        col.setName(name);\n+        col.setIdentifier(name);\n         col.setJavaType(JavaSQLTypes.CHAR_STREAM);\n         col.setSize(-1);\n         return new Column[]{ col };"},{"sha":"1f161816dde7a741cd661f69828c8d77326d0f91","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayValueHandler.java","status":"modified","additions":13,"deletions":1,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/CharArrayValueHandler.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -18,10 +18,12 @@\n  */\n package org.apache.openjpa.jdbc.meta.strats;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ValueMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.meta.JavaTypes;\n \n /**\n@@ -42,10 +44,20 @@ public static CharArrayValueHandler getInstance() {\n         return _instance;\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public Column[] map(ValueMapping vm, String name, ColumnIO io,\n+        boolean adapt) {\n+        DBDictionary dict = vm.getMappingRepository().getDBDictionary();\n+        DBIdentifier colName = DBIdentifier.newColumn(name, dict != null ? dict.delimitAll() : false);\n+        return map(vm, colName, io, adapt);\n+    }\n+\n+    public Column[] map(ValueMapping vm, DBIdentifier name, ColumnIO io,\n         boolean adapt) {\n         Column col = new Column();\n-        col.setName(name);\n+        col.setIdentifier(name);\n         col.setJavaType(JavaTypes.STRING);\n         return new Column[]{ col };\n     }"},{"sha":"fda65af5712a19b92edb623c36fe893c414a20dd","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClobValueHandler.java","status":"modified","additions":13,"deletions":1,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClobValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClobValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ClobValueHandler.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -18,9 +18,11 @@\n  */\n package org.apache.openjpa.jdbc.meta.strats;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.meta.ValueMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.meta.JavaTypes;\n \n /**\n@@ -40,10 +42,20 @@ public static ClobValueHandler getInstance() {\n         return _instance;\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public Column[] map(ValueMapping vm, String name, ColumnIO io,\n+        boolean adapt) {\n+        DBDictionary dict = vm.getMappingRepository().getDBDictionary();\n+        DBIdentifier colName = DBIdentifier.newColumn(name, dict != null ? dict.delimitAll() : false);\n+        return map(vm, colName, io, adapt);\n+    }\n+    \n+    public Column[] map(ValueMapping vm, DBIdentifier name, ColumnIO io,\n         boolean adapt) {\n         Column col = new Column();\n-        col.setName(name);\n+        col.setIdentifier(name);\n         col.setJavaType(JavaTypes.STRING);\n         col.setSize(-1);\n         return new Column[]{ col };"},{"sha":"9da5944132622f56ce45b0427d2686eb61e1485a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ColumnVersionStrategy.java","status":"modified","additions":7,"deletions":3,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ColumnVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ColumnVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ColumnVersionStrategy.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -23,6 +23,7 @@\n import java.sql.SQLException;\n import java.util.Comparator;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n@@ -31,6 +32,7 @@\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n import org.apache.openjpa.jdbc.schema.Index;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.Row;\n import org.apache.openjpa.jdbc.sql.RowManager;\n@@ -147,12 +149,12 @@ public void map(boolean adapt) {\n         \tfor (int i = 0; i < info.getColumns().size(); i++) {\n                 templates[i] = new Column();\n         \t\tColumn infoColumn = (Column)info.getColumns().get(i);\n-        \t\ttemplates[i].setTableName(infoColumn.getTableName());\n+        \t\ttemplates[i].setTableIdentifier(infoColumn.getTableIdentifier());\n         \t\ttemplates[i].setType(infoColumn.getType());\n         \t\ttemplates[i].setSize(infoColumn.getSize());\n                 templates[i].setDecimalDigits(infoColumn.getDecimalDigits());\n         \t\ttemplates[i].setJavaType(getJavaType(i));\n-        \t\ttemplates[i].setName(infoColumn.getName());\n+        \t\ttemplates[i].setIdentifier(infoColumn.getIdentifier());\n         \t}\n         \tColumn[] cols = info.getColumns(vers, templates, adapt);\n         \tfor (int i = 0; i < cols.length; i++)\n@@ -162,7 +164,9 @@ public void map(boolean adapt) {\n         } else {\n            Column tmplate = new Column();\n            tmplate.setJavaType(getJavaType());\n-           tmplate.setName(\"versn\");\n+           DBDictionary dict = vers.getMappingRepository().getDBDictionary();\n+           DBIdentifier versName = DBIdentifier.newColumn(\"versn\", dict != null ? dict.delimitAll() : false);\n+           tmplate.setIdentifier(versName);\n \n            Column[] cols = info.getColumns(vers, new Column[]{ tmplate },\n                    adapt);"},{"sha":"1db2491daf02d31ec7abd7ba7d8915b57d9981bc","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -25,8 +25,10 @@\n import org.apache.openjpa.kernel.*;\n import org.apache.openjpa.util.*;\n import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.*;\n import org.apache.openjpa.jdbc.schema.*;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n \n /**\n  * <p>Handler for embedded objects as elements of a collection or map.  For\n@@ -50,7 +52,17 @@\n     private int _nullIdx = -1;\n     private boolean _synthetic = false;\n \n+    /**\n+     * @deprecated\n+     */\n     public Column[] map(ValueMapping vm, String name, ColumnIO io,\n+        boolean adapt) {\n+        DBDictionary dict = vm.getMappingRepository().getDBDictionary();\n+        DBIdentifier colName = DBIdentifier.newColumn(name, dict != null ? dict.delimitAll() : false);\n+        return map(vm, colName, io, adapt);\n+    }\n+    \n+    public Column[] map(ValueMapping vm, DBIdentifier name, ColumnIO io,\n         boolean adapt) {\n         LinkedList cols = new LinkedList();\n         LinkedList args = new LinkedList();"},{"sha":"df0b091760be327849c8b25cc1afcef4274db6cf","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedValueHandler.java","status":"modified","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EmbedValueHandler.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -23,6 +23,7 @@\n import java.util.List;\n \n import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n@@ -33,6 +34,7 @@\n import org.apache.openjpa.jdbc.meta.ValueMappingImpl;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.kernel.ObjectIdStateManager;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.StateManagerImpl;\n@@ -53,8 +55,19 @@\n \n     /**\n      * Maps embedded value and gathers columns and arguments into given lists.\n+     * @deprecated\n      */\n     protected void map(ValueMapping vm, String name, ColumnIO io,\n+        boolean adapt, List cols, List args) {\n+        DBDictionary dict = vm.getMappingRepository().getDBDictionary();\n+        DBIdentifier colName = DBIdentifier.newColumn(name, dict != null ? dict.delimitAll() : false);\n+        map(vm, colName, io, adapt, cols, args);\n+    }\n+\n+    /**\n+     * Maps embedded value and gathers columns and arguments into given lists.\n+     */    \n+    protected void map(ValueMapping vm, DBIdentifier name, ColumnIO io,\n         boolean adapt, List cols, List args) {\n         // have to resolve embedded value to collect its columns\n         vm.getEmbeddedMapping().resolve(vm.MODE_META | vm.MODE_MAPPING);"},{"sha":"3a0654926648111e56a3655c24ff68d334c00bed","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EnumValueHandler.java","status":"modified","additions":13,"deletions":1,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EnumValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EnumValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/EnumValueHandler.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -20,10 +20,12 @@\n \n import java.lang.reflect.Method;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ValueMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.util.MetaDataException;\n \n@@ -52,7 +54,17 @@ public void setStoreOrdinal(boolean ordinal) {\n         _ordinal = ordinal;\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public Column[] map(ValueMapping vm, String name, ColumnIO io,\n+        boolean adapt) {\n+        DBDictionary dict = vm.getMappingRepository().getDBDictionary();\n+        DBIdentifier colName = DBIdentifier.newColumn(name, dict != null ? dict.delimitAll() : false);\n+        return map(vm, colName, io, adapt);\n+    }\n+    \n+    public Column[] map(ValueMapping vm, DBIdentifier name, ColumnIO io,\n         boolean adapt) {\n         // all enum classes have a static method called 'values()'\n         // that returns an array of all the enum values\n@@ -64,7 +76,7 @@ public void setStoreOrdinal(boolean ordinal) {\n         }\n \n         Column col = new Column();\n-        col.setName(name);\n+        col.setIdentifier(name);\n         if (_ordinal)\n             col.setJavaType(JavaTypes.SHORT);\n         else {"},{"sha":"c9da32ca029a988cf552b152f80720af176fcf74","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FlatClassStrategy.java","status":"modified","additions":4,"deletions":3,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FlatClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FlatClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FlatClassStrategy.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.openjpa.jdbc.meta.strats;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.ClassMappingInfo;\n import org.apache.openjpa.jdbc.schema.Table;\n@@ -49,9 +50,9 @@ public void map(boolean adapt) {\n         ClassMappingInfo info = cls.getMappingInfo();\n         info.assertNoSchemaComponents(cls, true);\n \n-        if (info.getTableName() != null) {\n-            Table table = info.createTable(cls, null, info.getSchemaName(),\n-                info.getTableName(), false);\n+        if (!DBIdentifier.isNull(info.getTableIdentifier())) {\n+            Table table = info.createTable(cls, null, info.getSchemaIdentifier(),\n+                info.getTableIdentifier(), false);\n             if (table != sup.getTable())\n                 throw new MetaDataException(_loc.get(\"flat-table\", cls,\n                     table.getFullName(), sup.getTable().getFullName()));"},{"sha":"e7f75822e67b3068659916033f53be4a6a01f643","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FullClassStrategy.java","status":"modified","additions":7,"deletions":3,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FullClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FullClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/FullClassStrategy.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -20,13 +20,15 @@\n \n import java.sql.SQLException;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.ClassMappingInfo;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.PrimaryKey;\n import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.Row;\n import org.apache.openjpa.jdbc.sql.RowManager;\n import org.apache.openjpa.jdbc.sql.Select;\n@@ -74,7 +76,9 @@ public void map(boolean adapt) {\n         Column[] pkCols = null;\n         if (cls.getIdentityType() == cls.ID_DATASTORE) {\n             Column id = new Column();\n-            id.setName(\"id\");\n+            DBDictionary dict = cls.getMappingRepository().getDBDictionary();\n+            DBIdentifier idName = DBIdentifier.newColumn(\"id\", dict != null ? dict.delimitAll() : false);\n+            id.setIdentifier(idName);\n             id.setJavaType(JavaTypes.LONG);\n             id.setComment(\"datastore id\");\n             if (cls.getIdentityStrategy() == ValueStrategies.AUTOASSIGN)\n@@ -90,10 +94,10 @@ public void map(boolean adapt) {\n         // add a primary key if we don't have one already\n         PrimaryKey pk = table.getPrimaryKey();\n         if (pk == null) {\n-            String pkname = null;\n+            DBIdentifier pkname = DBIdentifier.NULL;\n             if (adapt)\n                 pkname = cls.getMappingRepository().getMappingDefaults().\n-                    getPrimaryKeyName(cls, table);\n+                    getPrimaryKeyIdentifier(cls, table);\n             pk = table.addPrimaryKey(pkname);\n             pk.setLogical(!adapt);\n             if (pkCols != null)"},{"sha":"9dd20858362d65148431489f5975f1bed20753d8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -21,6 +21,7 @@\n import java.sql.*;\n import java.util.*;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.*;\n import org.apache.openjpa.jdbc.meta.*;\n import org.apache.openjpa.jdbc.schema.*;\n@@ -110,8 +111,8 @@ public void map(boolean adapt) {\n         _kio = new ColumnIO();\n         List columns = key.getValueInfo().getColumns(); \n         DBDictionary dict = field.getMappingRepository().getDBDictionary();\n-        String colName = dict.getValidColumnName(\"key\", field.getTable());\n-        _kcols = HandlerStrategies.map(key, colName, _kio, adapt);\n+        DBIdentifier colName = dict.getValidColumnName(DBIdentifier.newColumn(\"key\"), field.getTable());\n+        _kcols = HandlerStrategies.map(key, colName.getName(), _kio, adapt);\n \n         _vio = new ColumnIO();\n         _vcols = HandlerStrategies.map(val, \"value\", _vio, adapt);"},{"sha":"65b77cce55eb3935f401e09da2d1a90fce4e5e37","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -27,6 +27,7 @@\n import org.apache.openjpa.util.*;\n import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.*;\n import org.apache.openjpa.jdbc.schema.*;\n import org.apache.openjpa.jdbc.sql.*;\n@@ -164,7 +165,7 @@ public void map(boolean adapt) {\n         _kio = new ColumnIO();\n         DBDictionary dict = field.getMappingRepository().getDBDictionary();\n         _kcols = HandlerStrategies.map(key, \n-            dict.getValidColumnName(\"key\", field.getTable()), _kio, adapt);\n+            dict.getValidColumnName(DBIdentifier.newColumn(\"key\"), field.getTable()).getName(), _kio, adapt);\n \n         field.mapPrimaryKey(adapt);\n     }"},{"sha":"10c86032fa757df15ae0acc5ce2f9bf325f43669","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerStrategies.java","status":"modified","additions":7,"deletions":5,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerStrategies.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerStrategies.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerStrategies.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -20,23 +20,23 @@\n \n import java.sql.SQLException;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n-import org.apache.openjpa.jdbc.meta.FieldMapping;\n import org.apache.openjpa.jdbc.meta.RelationId;\n import org.apache.openjpa.jdbc.meta.ValueHandler;\n import org.apache.openjpa.jdbc.meta.ValueMapping;\n import org.apache.openjpa.jdbc.meta.ValueMappingInfo;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.Row;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.util.InvalidStateException;\n-import org.apache.openjpa.util.UserException;\n \n /**\n  * Utility methods for strategies using value handlers.\n@@ -58,9 +58,11 @@\n         vinfo.assertNoJoin(vm, true);\n         vinfo.assertNoForeignKey(vm, !adapt);\n \n-        Column[] cols = vm.getHandler().map(vm, name, io, adapt);\n+        DBDictionary dict = vm.getMappingRepository().getDBDictionary();\n+        DBIdentifier colName = DBIdentifier.newColumn(name, dict != null ? dict.delimitAll() : false);\n+        Column[] cols = vm.getHandler().map(vm, colName.getName(), io, adapt);\n         if (cols.length > 0 && cols[0].getTable() == null) {\n-            cols = vinfo.getColumns(vm, name, cols,\n+            cols = vinfo.getColumns(vm, colName, cols,\n                 vm.getFieldMapping().getTable(), adapt);\n             if (vinfo.isImplicitRelation())\n             \tfor (int i = 0; i < cols.length; i++)\n@@ -77,7 +79,7 @@\n                 }\n             }\n         }\n-        vm.mapConstraints(name, adapt);\n+        vm.mapConstraints(colName, adapt);\n         return cols;\n     }\n "},{"sha":"6792553381cee20e70574c422bbad95b93c86bfe","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ImmutableValueHandler.java","status":"modified","additions":13,"deletions":1,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ImmutableValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ImmutableValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ImmutableValueHandler.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -18,12 +18,14 @@\n  */\n package org.apache.openjpa.jdbc.meta.strats;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n import org.apache.openjpa.jdbc.meta.ValueMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.meta.JavaTypes;\n \n /**\n@@ -44,10 +46,20 @@ public static ImmutableValueHandler getInstance() {\n         return _instance;\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public Column[] map(ValueMapping vm, String name, ColumnIO io,\n+        boolean adapt) {\n+        DBDictionary dict = vm.getMappingRepository().getDBDictionary();\n+        DBIdentifier colName = DBIdentifier.newColumn(name, dict != null ? dict.delimitAll() : false);\n+        return map(vm, colName, io, adapt);\n+    }\n+\n+    public Column[] map(ValueMapping vm, DBIdentifier name, ColumnIO io,\n         boolean adapt) {\n         Column col = new Column();\n-        col.setName(name);\n+        col.setIdentifier(name);\n         if (vm.getTypeCode() == JavaTypes.DATE)\n             col.setJavaType(JavaSQLTypes.getDateTypeCode(vm.getType()));\n         else"},{"sha":"3dbf4a88aa8716eed51542285eaf261eb681a889","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/InValueDiscriminatorStrategy.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/InValueDiscriminatorStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/InValueDiscriminatorStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/InValueDiscriminatorStrategy.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -20,11 +20,13 @@\n \n import java.sql.SQLException;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.DiscriminatorMappingInfo;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.Index;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.Row;\n@@ -79,7 +81,9 @@ public void map(boolean adapt) {\n \n         Column tmplate = new Column();\n         tmplate.setJavaType(getJavaType());\n-        tmplate.setName(\"typ\");\n+        DBDictionary dict = cls.getMappingRepository().getDBDictionary();\n+        DBIdentifier typName = DBIdentifier.newColumn(\"typ\", dict != null ? dict.delimitAll() : false);\n+        tmplate.setIdentifier(typName);\n \n         Column[] cols = info.getColumns(disc, new Column[]{ tmplate }, adapt);\n         disc.setColumns(cols);"},{"sha":"6ccf33351c72df6a38f3cacb8eb48bf29713a0b3","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java","status":"modified","additions":8,"deletions":3,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -23,11 +23,13 @@\n import java.sql.SQLException;\n import java.sql.Types;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n import org.apache.openjpa.jdbc.meta.ValueMappingInfo;\n import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.PostgresDictionary;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.Row;\n@@ -58,19 +60,22 @@ public void map(boolean adapt) {\n         ValueMappingInfo vinfo = field.getValueInfo();\n         vinfo.assertNoJoin(field, true);\n         vinfo.assertNoForeignKey(field, !adapt);\n+        DBDictionary dict = field.getMappingRepository().getDBDictionary();\n+        DBIdentifier fieldName = DBIdentifier.newColumn(field.getName(), dict != null ? dict.delimitAll() : false);\n+\n         Column tmpCol = new Column();\n-        tmpCol.setName(field.getName());\n+        tmpCol.setIdentifier(fieldName);\n         tmpCol.setType(fieldType);\n         tmpCol.setJavaType(field.getTypeCode());\n         \n         tmpCol.setSize(-1);\n \n-        Column[] cols = vinfo.getColumns(field, field.getName(),\n+        Column[] cols = vinfo.getColumns(field, fieldName,\n             new Column[]{ tmpCol }, field.getTable(), adapt);\n \n         field.setColumns(cols);\n         field.setColumnIO(vinfo.getColumnIO());\n-        field.mapConstraints(field.getName(), adapt);\n+        field.mapConstraints(fieldName, adapt);\n         field.mapPrimaryKey(adapt);\n     }\n "},{"sha":"df8edcc9c765b60396c944c357f0a08869dea767","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MapTableFieldStrategy.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -24,6 +24,7 @@\n \n import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.enhance.ReflectingPersistenceCapable;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n@@ -241,7 +242,7 @@ protected void handleMappedByForeignKey(boolean adapt){\n             val.getValueInfo().setColumns(field.getValueInfo().getColumns());\n             if (val.getTypeMapping().isMapped()) {\n                 ValueMappingInfo vinfo = val.getValueInfo();\n-                ForeignKey fk = vinfo.getTypeJoin(val, null, false, adapt);\n+                ForeignKey fk = vinfo.getTypeJoin(val, DBIdentifier.NULL, false, adapt);\n                 val.setForeignKey(fk);\n                 val.setColumnIO(vinfo.getColumnIO());\n             } else"},{"sha":"cc9d8c7c5e64a7476667c71c0c8af9635aec0f6f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedLobFieldStrategy.java","status":"modified","additions":7,"deletions":4,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedLobFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedLobFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/MaxEmbeddedLobFieldStrategy.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -23,7 +23,7 @@\n import java.sql.ResultSet;\n import java.sql.SQLException;\n \n-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n@@ -87,17 +87,20 @@ public void map(boolean adapt) {\n         vinfo.assertNoJoin(field, true);\n         vinfo.assertNoForeignKey(field, !adapt);\n \n+        DBDictionary dict = field.getMappingRepository().getDBDictionary();\n+        DBIdentifier fieldName = DBIdentifier.newColumn(field.getName(), dict != null ? dict.delimitAll() : false);\n+\n         // get value columns\n         Column tmpCol = new Column();\n-        tmpCol.setName(field.getName());\n+        tmpCol.setIdentifier(fieldName);\n         tmpCol.setJavaType(getExpectedJavaType());\n         tmpCol.setSize(-1);\n-        Column[] cols = vinfo.getColumns(field, field.getName(),\n+        Column[] cols = vinfo.getColumns(field, fieldName,\n             new Column[]{ tmpCol }, field.getTable(), adapt);\n \n         field.setColumns(cols);\n         field.setColumnIO(vinfo.getColumnIO());\n-        field.mapConstraints(field.getName(), adapt);\n+        field.mapConstraints(fieldName, adapt);\n         field.mapPrimaryKey(adapt);\n     }\n "},{"sha":"7fe9ce8451b86e77fd30db5fcb5c1ed8618f1f51","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdValueHandler.java","status":"modified","additions":17,"deletions":5,"changes":22,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ObjectIdValueHandler.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -22,12 +22,14 @@\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n import org.apache.openjpa.jdbc.meta.ValueMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.kernel.ObjectIdStateManager;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.util.InternalException;\n@@ -44,7 +46,17 @@\n \n     private Object[] _args = null;\n \n+    /**\n+     * @deprecated\n+     */\n     public Column[] map(ValueMapping vm, String name, ColumnIO io,\n+        boolean adapt) {\n+        DBDictionary dict = vm.getMappingRepository().getDBDictionary();\n+        DBIdentifier colName = DBIdentifier.newColumn(name, dict != null ? dict.delimitAll() : false);\n+        return map(vm, colName, io, adapt);\n+    }\n+\n+    public Column[] map(ValueMapping vm, DBIdentifier name, ColumnIO io,\n         boolean adapt) {\n         List cols = new ArrayList();\n         List args = new ArrayList();\n@@ -85,7 +97,7 @@ private void setMapsIdCol(ValueMapping vm) {\n     \n     private void setMapsIdCols(List cols, ClassMapping cm) {\n         for (int i = 0; i < cols.size(); i++) {\n-            String refColName = ((Column)cols.get(i)).getTarget();\n+            DBIdentifier refColName = ((Column)cols.get(i)).getTargetIdentifier();\n             FieldMapping fm = getReferenceField(cm, refColName);\n             if (fm != null) {\n                 List colList1 = new ArrayList();\n@@ -104,7 +116,7 @@ private void setMapsIdCols(List cols, FieldMapping fm) {\n         }\n             \n         for (int i = 0; i < cols.size(); i++) {\n-            String refColName = ((Column)cols.get(i)).getTarget();\n+            DBIdentifier refColName = ((Column)cols.get(i)).getTargetIdentifier();\n             if (isReferenceField(fm, refColName)) {\n                 List colList1 = new ArrayList();\n                 colList1.add(cols.get(i));\n@@ -114,7 +126,7 @@ private void setMapsIdCols(List cols, FieldMapping fm) {\n         }\n     }\n     \n-    private FieldMapping getReferenceField(ClassMapping cm, String refColName) {\n+    private FieldMapping getReferenceField(ClassMapping cm, DBIdentifier refColName) {\n         FieldMapping[] fmds = cm.getFieldMappings();\n         for (int i = 0; i < fmds.length; i++) {\n             if (isReferenceField(fmds[i], refColName))\n@@ -123,13 +135,13 @@ private FieldMapping getReferenceField(ClassMapping cm, String refColName) {\n         return null;\n     }\n     \n-    private boolean isReferenceField(FieldMapping fm, String refColName) {\n+    private boolean isReferenceField(FieldMapping fm, DBIdentifier refColName) {\n         List cols = fm.getValueInfo().getColumns();\n         if (cols.size() == 0) {\n             if (fm.getName().equals(refColName))\n                 return true;                \n         } else {\n-            if (((Column)cols.get(0)).getName().equals(refColName))\n+            if (((Column)cols.get(0)).getIdentifier().equals(refColName))\n                 return true;\n         } \n         return false;"},{"sha":"009518bfe4007c49389d91eaf900a7391ff5957e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveFieldStrategy.java","status":"modified","additions":8,"deletions":3,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/PrimitiveFieldStrategy.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -20,6 +20,7 @@\n \n import java.sql.SQLException;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.Embeddable;\n@@ -29,6 +30,7 @@\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n import org.apache.openjpa.jdbc.schema.PrimaryKey;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.Row;\n@@ -75,12 +77,15 @@ public void map(boolean adapt) {\n         vinfo.assertNoJoin(field, true);\n         vinfo.assertNoForeignKey(field, !adapt);\n \n+        // Determine whether to delimit the base field name\n+        DBDictionary dict = field.getMappingRepository().getDBDictionary();\n+        DBIdentifier fieldName = DBIdentifier.newColumn(field.getName(), dict != null ? dict.delimitAll() : false);\n         // get value columns\n         Column tmpCol = new Column();\n-        tmpCol.setName(field.getName());\n+        tmpCol.setIdentifier(fieldName);\n         tmpCol.setJavaType(field.getTypeCode());\n \n-        Column[] cols = vinfo.getColumns(field, field.getName(),\n+        Column[] cols = vinfo.getColumns(field, fieldName,\n             new Column[]{ tmpCol }, field.getTable(), adapt);\n         if (field.getValueStrategy() == ValueStrategies.AUTOASSIGN)\n             cols[0].setAutoAssigned(true);\n@@ -89,7 +94,7 @@ public void map(boolean adapt) {\n         \t\tcols[i].setImplicitRelation(true);\n         field.setColumns(cols);\n         field.setColumnIO(vinfo.getColumnIO());\n-        field.mapConstraints(field.getName(), adapt);\n+        field.mapConstraints(fieldName, adapt);\n \n         // add primary key columns to table pk if logical\n         field.mapPrimaryKey(adapt);"},{"sha":"95399c6091a3016a87831fd3a2d42f53872c8770","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -28,9 +28,9 @@\n \n import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.enhance.ReflectingPersistenceCapable;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n-import org.apache.openjpa.jdbc.kernel.MixedLockManager;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.Embeddable;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n@@ -144,15 +144,15 @@ public void map(boolean adapt) {\n         // around an inverse key: check to see if we're mapped as a secondary\n         // table join but we're in the table of the related type, and if so\n         // switch our join mapping info to our value mapping info\n-        String tableName = field.getMappingInfo().getTableName();\n+        DBIdentifier tableName = field.getMappingInfo().getTableIdentifier();\n         Table table = field.getTypeMapping().getTable();\n         ValueMappingInfo vinfo = field.getValueInfo();\n-        if (tableName != null && table != null\n-            && (tableName.equalsIgnoreCase(table.getName())\n-            || tableName.equalsIgnoreCase(table.getFullName()))) {\n+        if (!DBIdentifier.isNull(tableName) && table != null\n+            && (tableName.equals(table.getIdentifier())\n+            || tableName.equals(table.getFullIdentifier()))) {\n             vinfo.setJoinDirection(MappingInfo.JOIN_INVERSE);\n             vinfo.setColumns(field.getMappingInfo().getColumns());\n-            field.getMappingInfo().setTableName(null);\n+            field.getMappingInfo().setTableIdentifier(DBIdentifier.NULL);\n             field.getMappingInfo().setColumns(null);\n         }\n         \n@@ -981,7 +981,7 @@ private ForeignKey createTranslatingForeignKey(ClassMapping relmapping,\n             if (gfk != null)\n                 tcol = gfk.getColumn(tcol);\n             if (tfk == null)\n-                tfk = new ForeignKey(null, tcol.getTable());\n+                tfk = new ForeignKey(DBIdentifier.NULL, tcol.getTable());\n             tfk.join(tcol, fk.getPrimaryKeyColumn(cols[i]));\n         }\n         return tfk;"},{"sha":"90d352ec610597c18dbc8a0e2593cac6c88e484a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","status":"modified","additions":6,"deletions":5,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -27,6 +27,7 @@\n import org.apache.openjpa.util.*;\n import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.*;\n import org.apache.openjpa.jdbc.schema.*;\n import org.apache.openjpa.jdbc.sql.*;\n@@ -201,14 +202,14 @@ public void map(boolean adapt) {\n             throw new MetaDataException(_loc.get(\"not-relation\", val));\n         FieldMapping mapped = field.getMappedByMapping();\n         DBDictionary dict = field.getMappingRepository().getDBDictionary();\n-        String keyName = null;\n+        DBIdentifier keyName = null;\n         if (field.isUni1ToMFK() || (!field.isBiMTo1JT() && mapped != null)) { \n             handleMappedByForeignKey(adapt);\n-            keyName = dict.getValidColumnName(\"vkey\", field.getTable());\n+            keyName = dict.getValidColumnName(DBIdentifier.newColumn(\"vkey\"), field.getTable());\n         } else if (field.isBiMTo1JT() || mapped == null) { \n             field.mapJoin(adapt, true);\n-            mapTypeJoin(val, \"value\", adapt);\n-            keyName = dict.getValidColumnName(\"key\", field.getTable());\n+            mapTypeJoin(val, DBIdentifier.newColumn(\"value\"), adapt);\n+            keyName = dict.getValidColumnName(DBIdentifier.newColumn(\"key\"), field.getTable());\n         }\n         mapTypeJoin(key, keyName, adapt);\n \n@@ -218,7 +219,7 @@ public void map(boolean adapt) {\n     /**\n      * Map the given value's join to its persistent type.\n      */\n-    private void mapTypeJoin(ValueMapping vm, String name, boolean adapt) {\n+    private void mapTypeJoin(ValueMapping vm, DBIdentifier name, boolean adapt) {\n         if (vm.getTypeMapping().isMapped()) {\n             ValueMappingInfo vinfo = vm.getValueInfo();\n             ForeignKey fk = vinfo.getTypeJoin(vm, name, false, adapt);"},{"sha":"3e7c39ff360a0f01157fa9294cb622a6104470d5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationStrategies.java","status":"modified","additions":18,"deletions":8,"changes":26,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationStrategies.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationStrategies.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationStrategies.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -20,6 +20,7 @@\n \n import java.util.List;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n@@ -104,6 +105,11 @@ public static Object toDataStoreValue(ValueMapping vm, Object val,\n      */\n     public static void mapRelationToUnmappedPC(ValueMapping vm,\n         String name, boolean adapt) {\n+        mapRelationToUnmappedPC(vm, DBIdentifier.newColumn(name), adapt);\n+    }\n+\n+    public static void mapRelationToUnmappedPC(ValueMapping vm,\n+        DBIdentifier name, boolean adapt) {\n         if (vm.getTypeMapping().getIdentityType() == ClassMapping.ID_UNKNOWN)\n             throw new MetaDataException(_loc.get(\"rel-to-unknownid\", vm));\n \n@@ -119,11 +125,11 @@ public static void mapRelationToUnmappedPC(ValueMapping vm,\n      * class relation.\n      */\n     private static Column[] newUnmappedPCTemplateColumns(ValueMapping vm,\n-        String name) {\n+        DBIdentifier name) {\n         ClassMapping rel = vm.getTypeMapping();\n         if (rel.getIdentityType() == ClassMapping.ID_DATASTORE) {\n             Column col = new Column();\n-            col.setName(name);\n+            col.setIdentifier(name);\n             col.setJavaType(JavaTypes.LONG);\n             col.setRelationId(true);\n             return new Column[]{ col };\n@@ -134,11 +140,15 @@ public static void mapRelationToUnmappedPC(ValueMapping vm,\n         for (int i = 0; i < pks.length; i++) {\n             cols[i] = mapPrimaryKey(vm, pks[i]);\n             if (cols.length == 1)\n-                cols[i].setName(name);\n-            else if (cols[i].getName() == null)\n-                cols[i].setName(name + \"_\" + pks[i].getName());\n-            else\n-                cols[i].setName(name + \"_\" + cols[i].getName());\n+                cols[i].setIdentifier(name);\n+            else if (DBIdentifier.isNull(cols[i].getIdentifier())) {\n+                DBIdentifier sName = DBIdentifier.combine(cols[i].getIdentifier(), pks[i].getName());\n+                cols[i].setIdentifier(sName);\n+            }\n+            else {\n+                DBIdentifier sName = DBIdentifier.combine(cols[i].getIdentifier(), cols[i].getName());\n+                cols[i].setIdentifier(sName);\n+            }\n             cols[i].setTargetField(pks[i].getName());\n             cols[i].setRelationId(true);\n         }\n@@ -193,7 +203,7 @@ private static Column mapPrimaryKey(ValueMapping vm, FieldMapping pk) {\n         }\n \n         if (tmplate != null) {\n-            col.setName(tmplate.getName());\n+            col.setIdentifier(tmplate.getIdentifier());\n             col.setType(tmplate.getType());\n             col.setTypeName(tmplate.getTypeName());\n             col.setSize(tmplate.getSize());"},{"sha":"8f1551951ccb42aed58fbb28b27e79ed0007934f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StateComparisonVersionStrategy.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StateComparisonVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StateComparisonVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StateComparisonVersionStrategy.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -22,16 +22,19 @@\n import java.util.BitSet;\n import java.util.Collection;\n \n+import org.apache.openjpa.jdbc.identifier.Normalizer;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.Row;\n import org.apache.openjpa.jdbc.sql.RowImpl;\n import org.apache.openjpa.jdbc.sql.RowManager;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.StoreManager;\n+import org.apache.openjpa.lib.identifier.IdentifierConfiguration;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.util.ArrayStateImage;\n import org.apache.openjpa.util.InternalException;\n@@ -238,7 +241,7 @@ private CustomUpdate(Column[] cols) {\n          * WHERE clause of an UPDATE to test whether the current database\n          * record matches our stored version.\n          */\n-        public String getSQL() {\n+        public String getSQL(DBDictionary dict) {\n             Column[] cols = getTable().getColumns();\n             StringBuilder buf = new StringBuilder();\n             boolean hasWhere = false;\n@@ -251,9 +254,9 @@ public String getSQL() {\n                 if (hasWhere)\n                     buf.append(\" AND \");\n                 if (val == NULL)\n-                    buf.append(cols[i]).append(\" IS NULL\");\n+                    buf.append(dict.getColumnDBName(cols[i]) + \" IS NULL\");\n                 else\n-                    buf.append(cols[i]).append(\" = ?\");\n+                    buf.append(dict.getColumnDBName(cols[i]) + \" = ?\");\n                 hasWhere = true;\n             }\n             return buf.toString();"},{"sha":"5de9f78c42ccce05a4416350302e42d2b9be923c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StringFieldStrategy.java","status":"modified","additions":8,"deletions":3,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StringFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StringFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/StringFieldStrategy.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -20,6 +20,7 @@\n \n import java.sql.SQLException;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.Embeddable;\n@@ -30,6 +31,7 @@\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n import org.apache.openjpa.jdbc.schema.PrimaryKey;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.Joins;\n import org.apache.openjpa.jdbc.sql.Result;\n import org.apache.openjpa.jdbc.sql.Row;\n@@ -71,19 +73,22 @@ public void map(boolean adapt) {\n         vinfo.assertNoJoin(field, true);\n         vinfo.assertNoForeignKey(field, !adapt);\n \n+        DBDictionary dict = field.getMappingRepository().getDBDictionary();\n+        DBIdentifier fieldName = DBIdentifier.newColumn(field.getName(), dict != null ? dict.delimitAll() : false);\n+\n         // get value columns\n         Column tmpCol = new Column();\n-        tmpCol.setName(field.getName());\n+        tmpCol.setIdentifier(fieldName);\n         tmpCol.setJavaType(field.getTypeCode());\n \n-        Column[] cols = vinfo.getColumns(field, field.getName(),\n+        Column[] cols = vinfo.getColumns(field, fieldName,\n             new Column[]{ tmpCol }, field.getTable(), adapt);\n         if (field.getValueStrategy() == ValueStrategies.AUTOASSIGN)\n             cols[0].setAutoAssigned(true);\n \n         field.setColumns(cols);\n         field.setColumnIO(vinfo.getColumnIO());\n-        field.mapConstraints(field.getName(), adapt);\n+        field.mapConstraints(fieldName, adapt);\n \n         // add primary key columns to table pk if logical\n         field.mapPrimaryKey(adapt);"},{"sha":"0cd1a3f96439b4b3b65575713a14f53443733837","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/UntypedPCValueHandler.java","status":"modified","additions":13,"deletions":1,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/UntypedPCValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/UntypedPCValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/UntypedPCValueHandler.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -21,12 +21,14 @@\n import java.sql.SQLException;\n \n import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.RelationId;\n import org.apache.openjpa.jdbc.meta.ValueMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.kernel.OpenJPAStateManager;\n import org.apache.openjpa.kernel.StoreContext;\n import org.apache.openjpa.lib.util.Localizer;\n@@ -56,10 +58,20 @@ public static UntypedPCValueHandler getInstance() {\n         return _instance;\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public Column[] map(ValueMapping vm, String name, ColumnIO io,\n+        boolean adapt) {\n+        DBDictionary dict = vm.getMappingRepository().getDBDictionary();\n+        DBIdentifier colName = DBIdentifier.newColumn(name, dict != null ? dict.delimitAll() : false);\n+        return map(vm, colName, io, adapt);\n+    }\n+\n+    public Column[] map(ValueMapping vm, DBIdentifier name, ColumnIO io,\n         boolean adapt) {\n         Column col = new Column();\n-        col.setName(name);\n+        col.setIdentifier(name);\n         col.setJavaType(JavaTypes.STRING);\n         col.setRelationId(true);\n         return new Column[]{ col };"},{"sha":"f6506db1e684d441579cec675dcc70c3ad6ecdb8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/VerticalClassStrategy.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/VerticalClassStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/VerticalClassStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/VerticalClassStrategy.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -20,6 +20,7 @@\n \n import java.sql.SQLException;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n@@ -79,10 +80,10 @@ public void map(boolean adapt) {\n         // add a primary key if we don't have one already\n         PrimaryKey pk = table.getPrimaryKey();\n         if (pk == null) {\n-            String pkname = null;\n+            DBIdentifier pkname = DBIdentifier.NULL;\n             if (adapt)\n                 pkname = cls.getMappingRepository().getMappingDefaults().\n-                    getPrimaryKeyName(cls, table);\n+                    getPrimaryKeyIdentifier(cls, table);\n             pk = table.addPrimaryKey(pkname);\n             pk.setLogical(!adapt);\n             pk.setColumns(pkCols);"},{"sha":"663495fd6421fa8275d71e3ddc7a760b58e68c87","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/XMLValueHandler.java","status":"modified","additions":15,"deletions":3,"changes":18,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/XMLValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/XMLValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/XMLValueHandler.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -28,10 +28,12 @@\n import javax.xml.bind.Unmarshaller;\n import javax.xml.transform.stream.StreamSource;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.ValueMapping;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ColumnIO;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.util.InternalException;\n \n@@ -45,14 +47,24 @@\n     extends AbstractValueHandler {\n     private static final String PROXY_SUFFIX = \"$proxy\";\n \n+    /**\n+     * @deprecated\n+     */\n     public Column[] map(ValueMapping vm, String name, ColumnIO io,\n+        boolean adapt) {\n+        DBDictionary dict = vm.getMappingRepository().getDBDictionary();\n+        DBIdentifier colName = DBIdentifier.newColumn(name, dict != null ? dict.delimitAll() : false);\n+        return map(vm, colName, io, adapt);\n+    }\n+\n+    public Column[] map(ValueMapping vm, DBIdentifier name, ColumnIO io,\n         boolean adapt) {\n         Column col = new Column();\n-        col.setName(name);\n+        col.setIdentifier(name);\n         col.setJavaType(JavaTypes.STRING);\n         col.setSize(-1);\n-        col.setTypeName(vm.getMappingRepository().getDBDictionary()\n-            .xmlTypeName);\n+        col.setTypeIdentifier(DBIdentifier.newColumnDefinition(vm.getMappingRepository().getDBDictionary()\n+            .xmlTypeName));\n         col.setXML(true);\n         return new Column[]{ col };\n     }"},{"sha":"cd05e158f1a285c55aa0d2fd21b8d1dde1a8add2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Column.java","status":"modified","additions":111,"deletions":44,"changes":155,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Column.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Column.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Column.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -27,6 +27,8 @@\n import java.sql.Types;\n \n import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.QualifiedDBIdentifier;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n import org.apache.openjpa.jdbc.meta.VersionStrategy;\n import org.apache.openjpa.meta.JavaTypes;\n@@ -39,6 +41,7 @@\n  * @author Abe White\n  * @author Stephen Kim\n  */\n+@SuppressWarnings(\"serial\")\n public class Column\n     extends ReferenceCounter {\n \n@@ -50,13 +53,12 @@\n     public static final int FLAG_FK_UPDATE = 2 << 5;\n     public static final int FLAG_PK_JOIN = 2 << 6;\n \n-    private String _name = null;\n-    private String _fullName = null;\n+    private DBIdentifier _name = DBIdentifier.NULL;\n     private Table _table = null;\n-    private String _tableName = null;\n-    private String _schemaName = null;\n+    private DBIdentifier _tableName = DBIdentifier.NULL;\n+    private DBIdentifier _schemaName = DBIdentifier.NULL;\n     private int _type = Types.OTHER;\n-    private String _typeName = null;\n+    private DBIdentifier _typeName = DBIdentifier.NULL;\n     private int _javaType = JavaTypes.OBJECT;\n     private int _size = 0;\n     private int _decimals = 0;\n@@ -66,9 +68,10 @@\n     private boolean _autoAssign = false;\n     private boolean _rel = false;\n     private boolean _implicitRelation = false;\n-    private String _target = null;\n+    private DBIdentifier _target = DBIdentifier.NULL;\n     private String _targetField = null;\n     private int _flags = 0;\n+    private QualifiedDBIdentifier _fullPath = null;\n \n     private int _index = 0;\n     private boolean _pk = false;\n@@ -88,12 +91,17 @@ public Column() {\n      *\n      * @param name the name of the column\n      * @param table the column's table\n+     * @deprecated\n      */\n     public Column(String name, Table table) {\n-        setName(name);\n+        this(DBIdentifier.newColumn(name), table);\n+    }\n+\n+    public Column(DBIdentifier name, Table table) {\n+        setIdentifier(name);\n         if (table != null) {\n-            setTableName(table.getName());\n-            setSchemaName(table.getSchemaName());\n+            setTableIdentifier(table.getIdentifier());\n+            setSchemaIdentifier(table.getSchemaIdentifier());\n         }\n         _table = table;\n     }\n@@ -169,79 +177,118 @@ public Table getTable() {\n \n     /**\n      * The column's table name.\n+     * @deprecated\n      */\n     public String getTableName() {\n-        return _tableName;\n+        return getTableIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getTableIdentifier() {\n+        return _tableName == null ? DBIdentifier.NULL : _tableName;\n     }\n \n     /**\n      * The column's table name. You can only call this method on columns\n      * whose table object is not set.\n+     * @deprecated\n      */\n     public void setTableName(String name) {\n-        if (getTable() != null)\n-            throw new IllegalStateException();\n-        _tableName = name;\n-        _fullName = null;\n+        setTableIdentifier(DBIdentifier.newTable(name));\n     }\n-    \n+\n+    public void setTableIdentifier(DBIdentifier name) {\n+      if (getTable() != null)\n+          throw new IllegalStateException();\n+      _tableName = name == null ? DBIdentifier.NULL : name;\n+      _fullPath = null;\n+    }\n+\n     /**\n      * Reset the table name with the fully qualified table name which\n      * includes the schema name\n+     * @deprecated\n      */\n     public void resetTableName(String name) {\n-        _tableName = name;\n+        _tableName = DBIdentifier.newTable(name);\n+    }\n+    \n+    public void resetTableIdentifier(DBIdentifier table) {\n+        _tableName = table == null ? DBIdentifier.NULL : table;\n     }\n \n     /**\n      * The column's schema name.\n+     * @deprecated\n      */\n     public String getSchemaName() {\n-        return _schemaName;\n+        return getSchemaIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getSchemaIdentifier() {\n+        return _schemaName == null ? DBIdentifier.NULL : _schemaName;\n     }\n \n     /**\n      * The column's schema name. You can only call this method on columns\n      * whose table object is not set.\n+     * @deprecated use setSchemaIdentifier(DBIdentifier name)\n      */\n     public void setSchemaName(String name) {\n+        setSchemaIdentifier(DBIdentifier.newSchema(name));\n+    }\n+\n+    public void setSchemaIdentifier(DBIdentifier name) {\n         if (getTable() != null)\n             throw new IllegalStateException();\n-        _schemaName = name;\n+        _schemaName = name == null ? DBIdentifier.NULL : name;\n     }\n \n     /**\n      * Return the column's name.\n+     * @deprecated use getIdentifier()\n      */\n     public String getName() {\n-        return _name;\n+        return getIdentifier().getName();\n     }\n \n+    public DBIdentifier getIdentifier() {\n+        return _name == null ? DBIdentifier.NULL : _name;\n+    }\n+\n+    \n     /**\n      * Set the column's name. You can only call this method on columns\n      * whose table object is not set.\n+     * @deprecated use setIdentifier(DBIdentifier name)\n      */\n     public void setName(String name) {\n+        setIdentifier(DBIdentifier.newColumn(name));\n+    }\n+\n+    public void setIdentifier(DBIdentifier name) {\n         if (getTable() != null)\n             throw new IllegalStateException();\n-        _name = name;\n-        _fullName = null;\n+        _name = name == null ? DBIdentifier.NULL : name;\n+        _fullPath = null;\n     }\n \n     /**\n      * Return the column's full name, in the form &lt;table&gt;.&lt;name&gt;.\n+     * @deprecated use getFullDBIdentifier()\n      */\n     public String getFullName() {\n-        if (_fullName == null) {\n-            String name = getName();\n-            if (name == null)\n-                return null;\n-            String tname = getTableName();\n-            if (tname == null)\n-                return name;\n-            _fullName = tname + \".\" + name;\n+        return getFullDBIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getFullDBIdentifier() {\n+        return getQualifiedPath().getIdentifier();\n+    }\n+    \n+    public QualifiedDBIdentifier getQualifiedPath() {\n+        if (_fullPath  == null) {\n+            _fullPath = QualifiedDBIdentifier.newPath(getTableIdentifier(), getIdentifier() );\n         }\n-        return _fullName;\n+        return _fullPath;\n     }\n \n     /**\n@@ -262,16 +309,26 @@ public void setType(int sqlType) {\n \n     /**\n      * The database-specific SQL type of this column.\n+     * @deprecated\n      */\n     public String getTypeName() {\n-        return _typeName;\n+        return getTypeIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getTypeIdentifier() {\n+        return _typeName == null ? DBIdentifier.NULL : _typeName ;\n     }\n \n     /**\n      * The database-specific SQL type of this column.\n+     * @deprecated\n      */\n     public void setTypeName(String typeName) {\n-        _typeName = typeName;\n+        setTypeIdentifier(DBIdentifier.newColumnDefinition(typeName));\n+    }\n+\n+    public void setTypeIdentifier(DBIdentifier typeName) {\n+        _typeName = typeName == null ? DBIdentifier.NULL : typeName;\n     }\n \n     /**\n@@ -470,16 +527,26 @@ public void setRelationId(boolean rel) {\n \n     /**\n      * The name of the column this column joins to, if any. Used for mapping.\n+     * @deprecated use getTargetIdentifier()\n      */\n     public String getTarget() {\n-        return _target;\n+        return getTargetIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getTargetIdentifier() {\n+        return _target == null ? DBIdentifier.NULL : _target;\n     }\n \n     /**\n      * The name of the column this column joins to, if any. Used for mapping.\n+     * @deprecated use setTargetIdentifier(DBIdentifier target)\n      */\n     public void setTarget(String target) {\n-        _target = StringUtils.trimToNull(target);\n+        setTargetIdentifier(DBIdentifier.newColumn(StringUtils.trimToNull(target)));\n+    }\n+\n+    public void setTargetIdentifier(DBIdentifier target) {\n+        _target = target == null ? DBIdentifier.NULL : DBIdentifier.trimToNull(target);\n     }\n \n     /**\n@@ -661,7 +728,7 @@ public boolean isCompatible(int type, String typeName, int size,\n      * Returns the column name.\n      */\n     public String toString() {\n-        return getName();\n+        return getIdentifier().getName();\n     }\n \n     /**\n@@ -687,9 +754,9 @@ public boolean equalsColumn(Column col) {\n         if (col == null)\n             return false;\n \n-        if (!getFullName().equalsIgnoreCase(col.getFullName()))\n+        if (!getQualifiedPath().equals(col.getQualifiedPath()))\n             return false;\n-        if (!isCompatible(col.getType(), col.getTypeName(), col.getSize(),\n+        if (!isCompatible(col.getType(), col.getTypeIdentifier().getName(), col.getSize(),\n             col.getDecimalDigits()))\n             return false;\n         if (getType() == Types.VARCHAR && getSize() > 0 && col.getSize() > 0\n@@ -704,12 +771,12 @@ public boolean equalsColumn(Column col) {\n     public void copy(Column from) {\n         if (from == null)\n             return;\n-        if (getName() == null)\n-            setName(from.getName());\n+        if (DBIdentifier.isNull(getIdentifier()))\n+            setIdentifier(from.getIdentifier());\n         if (getType() == Types.OTHER)\n             setType(from.getType());\n-        if (getTypeName() == null)\n-            setTypeName(from.getTypeName());\n+        if (DBIdentifier.isNull(getTypeIdentifier()))\n+            setTypeIdentifier(from.getTypeIdentifier());\n         if (getJavaType() == JavaTypes.OBJECT)\n             setJavaType(from.getJavaType());\n         if (getSize() == 0)\n@@ -726,8 +793,8 @@ public void copy(Column from) {\n             setRelationId(from.isRelationId());\n         if (!isImplicitRelation())\n         \tsetImplicitRelation(from.isRelationId());\n-        if (getTarget() == null)\n-            setTarget(from.getTarget());\n+        if (DBIdentifier.isNull(getTargetIdentifier()))\n+            setTargetIdentifier(from.getTargetIdentifier());\n         if (getTargetField() == null)\n             setTargetField(from.getTargetField());\n         if (_flags == 0)\n@@ -761,7 +828,7 @@ public void setVersionStrategy(VersionStrategy strategy) {\n     }\n \n     public boolean hasComment() {\n-        return _comment != null && !_comment.equalsIgnoreCase(_name);\n+        return _comment != null && !_comment.equalsIgnoreCase(_name.toString());\n     }\n \n     public String getComment() {"},{"sha":"7e7475c4c33c5267c8b70ce13234a605cec580b5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ColumnIO.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ColumnIO.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ColumnIO.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ColumnIO.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -27,6 +27,7 @@\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public class ColumnIO\n     implements Serializable {\n "},{"sha":"db2f19287021362704bcdcce139f8a12da4d5035","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Constraint.java","status":"modified","additions":84,"deletions":29,"changes":113,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Constraint.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Constraint.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Constraint.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -18,21 +18,25 @@\n  */\n package org.apache.openjpa.jdbc.schema;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.QualifiedDBIdentifier;\n+\n /**\n  * A table constraint. This class is closely aligned with the constraint\n  * information available from {@link java.sql.DatabaseMetaData}.\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class Constraint\n     extends ReferenceCounter {\n \n-    private String _name = null;\n-    private String _fullName = null;\n+    private DBIdentifier _name = DBIdentifier.NULL;\n+    private QualifiedDBIdentifier _fullPath = null;\n     private Table _table = null;\n-    private String _tableName = null;\n-    private String _schemaName = null;\n-    private String _columnName = null;\n+    private DBIdentifier _tableName = DBIdentifier.NULL;\n+    private DBIdentifier _schemaName = DBIdentifier.NULL;\n+    private DBIdentifier _columnName = DBIdentifier.NULL;\n     private boolean _deferred = false;\n \n     /**\n@@ -46,12 +50,17 @@\n      *\n      * @param name the name of the constraint, or null if none\n      * @param table the local table of the constraint\n+     * @deprecated\n      */\n     Constraint(String name, Table table) {\n-        setName(name);\n+        this(DBIdentifier.newConstant(name), table);\n+    }\n+\n+    Constraint(DBIdentifier name, Table table) {\n+        setIdentifier(name);\n         if (table != null) {\n-            setTableName(table.getName());\n-            setSchemaName(table.getSchemaName());\n+            setTableIdentifier(table.getIdentifier());\n+            setSchemaIdentifier(table.getSchemaIdentifier());\n         }\n         _table = table;\n     }\n@@ -73,90 +82,136 @@ public Table getTable() {\n \n     /**\n      * Return the column's table name.\n+     * @deprecated\n      */\n     public String getTableName() {\n-        return _tableName;\n+        return getTableIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getTableIdentifier() {\n+        return _tableName == null ? DBIdentifier.NULL : _tableName;\n     }\n \n     /**\n      * Set the column's table name. You can only call this method on\n      * columns whose table object is not set.\n+     * @deprecated\n      */\n     public void setTableName(String name) {\n-        if (getTable() != null)\n-            throw new IllegalStateException();\n-        _tableName = name;\n-        _fullName = null;\n+        setTableIdentifier(DBIdentifier.newTable(name));\n     }\n \n+      public void setTableIdentifier(DBIdentifier name) {\n+          if (getTable() != null)\n+              throw new IllegalStateException();\n+          _tableName = name;\n+          _fullPath = null;\n+      }\n+\n+    \n     /**\n      * Return the column table's schema name.\n+     * @deprecated\n      */\n     public String getSchemaName() {\n-        return _schemaName;\n+        return getSchemaIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getSchemaIdentifier() {\n+        return _schemaName == null ? DBIdentifier.NULL : _schemaName;\n     }\n \n     /**\n      * Set the column table's schema name. You can only call this method on\n-     * columns whose tbale object is not set.\n+     * columns whose table object is not set.\n+     * @deprecated\n      */\n     public void setSchemaName(String schema) {\n+        setSchemaIdentifier(DBIdentifier.newSchema(schema));\n+    }\n+\n+    public void setSchemaIdentifier(DBIdentifier schema) {\n         if (getTable() != null)\n             throw new IllegalStateException();\n         _schemaName = schema;\n     }\n \n     /**\n      * Return the column's name.\n+     * @deprecated\n      */\n     public String getColumnName() {\n-        return _columnName;\n+        return getColumnIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getColumnIdentifier() {\n+        return _columnName == null ? DBIdentifier.NULL : _columnName;\n     }\n \n     /**\n      * Set the column's name. You can only call this method on\n      * columns whose table object is not set.\n+     * @deprecated\n      */\n     public void setColumnName(String name) {\n+        setColumnIdentifier(DBIdentifier.newColumn(name));\n+    }\n+\n+    public void setColumnIdentifier(DBIdentifier name) {\n         if (getTable() != null)\n             throw new IllegalStateException();\n         _columnName = name;\n     }\n \n     /**\n      * Return the name of the constraint.\n+     * @deprecated\n      */\n     public String getName() {\n-        return _name;\n+        return getIdentifier().getName();\n+    }\n+    \n+    public DBIdentifier getIdentifier() {\n+        return _name == null ? DBIdentifier.NULL : _name;\n     }\n \n+\n     /**\n      * Set the name of the constraint. This method cannot be called if the\n      * constraint already belongs to a table.\n+     * @deprecated\n      */\n     public void setName(String name) {\n+        setIdentifier(DBIdentifier.newConstraint(name));\n+    }\n+\n+    public void setIdentifier(DBIdentifier name) {\n         if (getTable() != null)\n             throw new IllegalStateException();\n         _name = name;\n-        _fullName = null;\n+        _fullPath = null;\n     }\n \n     /**\n      * Return the full name of the constraint.\n+     * @deprecated\n      */\n     public String getFullName() {\n-        if (_fullName == null) {\n-            String name = getName();\n-            if (name == null)\n-                return null;\n-            String tname = getTableName();\n-            if (tname == null)\n-                return name;\n-            _fullName = tname + \".\" + name;\n+        return getFullIdentifier().getName();\n+    }\n+\n+    public QualifiedDBIdentifier getQualifiedPath() {\n+        if (_fullPath == null) {\n+            _fullPath = QualifiedDBIdentifier.newPath(getTableIdentifier(), getIdentifier());\n         }\n-        return _fullName;\n+        return _fullPath;\n     }\n \n+    public DBIdentifier getFullIdentifier() {\n+        return getQualifiedPath().getIdentifier();\n+    }\n+    \n+    \n     /**\n      * Return whether this constraint is a logical constraint only; i.e.\n      * if it does not exist in the database.\n@@ -178,8 +233,8 @@ public void setDeferred(boolean deferred) {\n     }\n \n     public String toString() {\n-        if (getName() != null)\n-            return getName();\n+        if (!getIdentifier().isNull())\n+            return getIdentifier().getName();\n \n         String name = getClass().getName();\n         name = name.substring(name.lastIndexOf('.') + 1);"},{"sha":"c29401d999edb6ab2cccaf4c0176c0b4c8e4509a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DynamicSchemaFactory.java","status":"modified","additions":73,"deletions":19,"changes":92,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DynamicSchemaFactory.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DynamicSchemaFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/DynamicSchemaFactory.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -21,6 +21,9 @@\n import java.sql.Types;\n \n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.identifier.Normalizer;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.QualifiedDBIdentifier;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.lib.conf.Configurable;\n import org.apache.openjpa.lib.conf.Configuration;\n@@ -34,17 +37,18 @@\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public class DynamicSchemaFactory\n     extends SchemaGroup\n     implements SchemaFactory, Configurable {\n \n     private transient DBDictionary _dict = null;\n-    private String _schema = null;\n+    private DBIdentifier _schema = DBIdentifier.NULL;\n \n     public void setConfiguration(Configuration conf) {\n         JDBCConfiguration jconf = (JDBCConfiguration) conf;\n         _dict = jconf.getDBDictionaryInstance();\n-        _schema = jconf.getSchema();\n+        _schema = DBIdentifier.newSchema(jconf.getSchema());\n     }\n \n     public void startConfiguration() {\n@@ -69,45 +73,67 @@ public boolean isKnownTable(String name) {\n         return super.findTable(name) != null;\n     }\n \n+    public boolean isKnownTable(QualifiedDBIdentifier path) {\n+        return super.findTable(path) != null;\n+    }\n+\n     public Table findTable(String name) {\n+        return super.findTable(name);\n+    }\n+\n+    public Table findTable(DBIdentifier name) {\n         if (name == null)\n             return null;\n \n-        Table table = super.findTable(name);\n+        QualifiedDBIdentifier path = QualifiedDBIdentifier.getPath(name);\n+        return findTable(path);\n+    }\n+\n+    public Table findTable(QualifiedDBIdentifier path) {\n+        if (DBIdentifier.isNull(path))\n+            return null;\n+\n+        Table table = super.findTable(path);\n         if (table != null)\n             return table;\n \n         // if full name, split\n-        String schemaName = null;\n-        String tableName = name;\n-        int dotIdx = name.lastIndexOf('.');\n-        if (dotIdx != -1) {\n-            schemaName = name.substring(0, dotIdx);\n-            tableName = name.substring(dotIdx + 1);\n-        } else\n+        DBIdentifier schemaName = DBIdentifier.NULL;\n+        DBIdentifier tableName = path.getUnqualifiedName();\n+        if (!DBIdentifier.isNull(path.getSchemaName())) {\n+            schemaName = path.getSchemaName();\n+        } else {\n             schemaName = _schema;\n+        }\n \n         Schema schema = getSchema(schemaName);\n         if (schema == null) {\n             schema = addSchema(schemaName);\n-            // TODO: temp until a more global name scheme is implemented\n-            addDelimSchemaName(_dict.addDelimiters(schemaName), schema);\n         }\n \n         // Ensure only valid table name(s) are added to the schema\n-        if (tableName.length() > _dict.maxTableNameLength) {\n+        if (tableName.getName().length() > _dict.maxTableNameLength) {\n             return schema.addTable(tableName, \n                 _dict.getValidTableName(tableName, getSchema(schemaName)));\n         }\n \n         return schema.addTable(tableName);\n     }\n+    \n+    \n+//    protected Table newTable(String name, Schema schema) {\n+//        return new DynamicTable(name, schema);\n+//    }\n \n-    protected Table newTable(String name, Schema schema) {\n+    protected Table newTable(DBIdentifier name, Schema schema) {\n         return new DynamicTable(name, schema);\n     }\n \n-    protected Column newColumn(String name, Table table) {\n+//    protected Column newColumn(String name, Table table) {\n+//        return new DynamicColumn(name, table);\n+//    }\n+\n+    protected Column newColumn(DBIdentifier name, Table table) {\n         return new DynamicColumn(name, table);\n     }\n \n@@ -121,21 +147,42 @@ public DynamicTable(String name, Schema schema) {\n             super(name, schema);\n         }\n \n+        public DynamicTable(DBIdentifier name, Schema schema) {\n+            super(name, schema);\n+        }\n+\n+        /**\n+         * @deprecated\n+         */\n         public Column getColumn(String name) {\n             return getColumn(name, null);\n         }\n \n+        public Column getColumn(DBIdentifier name) {\n+            return getColumn(name, null);\n+        }\n+\n+        /**\n+         * @deprecated\n+         */\n         public Column getColumn(String name, DBDictionary dict) {\n             if (name == null)\n                 return null;\n+            return getColumn(DBIdentifier.newColumn(name), dict);\n+        }\n+\n+        public Column getColumn(DBIdentifier name, DBDictionary dict) {\n+            if (DBIdentifier.isNull(name))\n+                return null;\n \n-            Column col = super.getColumn(name, dict);\n+            Column col = super.getColumn(name);\n             if (col != null)\n                 return col;\n \n             // Ensure only valid column name(s) are added to the table\n-            if ((name.length() > _dict.maxColumnNameLength) ||\n-                _dict.getInvalidColumnWordSet().contains(name.toUpperCase())) {\n+            if ((name.getName().length() > _dict.maxColumnNameLength) ||\n+                _dict.getInvalidColumnWordSet().contains(\n+                    DBIdentifier.toUpper(name).getName())) {\n                 return addColumn(name, \n                     _dict.getValidColumnName(name, this));\n             }\n@@ -150,10 +197,17 @@ public Column getColumn(String name, DBDictionary dict) {\n     private class DynamicColumn\n         extends Column {\n \n+        /**\n+         * @deprecated\n+         */\n         public DynamicColumn(String name, Table table) {\n             super(name, table);\n         }\n \n+        public DynamicColumn(DBIdentifier name, Table table) {\n+            super(name, table);\n+        }\n+\n         public boolean isCompatible(int type, String typeName, int size,\n             int decimals) {\n             if (getType() != Types.OTHER)\n@@ -164,7 +218,7 @@ public boolean isCompatible(int type, String typeName, int size,\n             setType(type);\n             setSize(size);\n             if (typeName != null)\n-                setTypeName(typeName);\n+                setTypeIdentifier(DBIdentifier.newColumnDefinition(typeName));\n             if (decimals >= 0)\n                 setDecimalDigits(decimals);\n             return true;"},{"sha":"60ed28cb4138b1151649ed52ed39f2f15ab766f3","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","status":"modified","additions":82,"deletions":39,"changes":121,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/ForeignKey.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -27,6 +27,8 @@\n \n import org.apache.commons.lang.ObjectUtils;\n import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.identifier.Normalizer;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.util.Localizer;\n@@ -40,6 +42,7 @@\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public class ForeignKey\n     extends Constraint {\n \n@@ -75,9 +78,9 @@\n     private static final Localizer _loc = \n         Localizer.forPackage(ForeignKey.class);\n \n-    private String _pkTableName = null;\n-    private String _pkSchemaName = null;\n-    private String _pkColumnName = null;\n+    private DBIdentifier _pkTableName = DBIdentifier.NULL;\n+    private DBIdentifier _pkSchemaName = DBIdentifier.NULL;\n+    private DBIdentifier _pkColumnName = DBIdentifier.NULL;\n     private int _seq = 0;\n \n     private LinkedHashMap _joins = null;\n@@ -160,11 +163,16 @@ public ForeignKey() {\n      *\n      * @param name the foreign key name, if any\n      * @param table the local table of the foreign key\n+     * @deprecated\n      */\n     public ForeignKey(String name, Table table) {\n         super(name, table);\n     }\n \n+    public ForeignKey(DBIdentifier name, Table table) {\n+        super(name, table);\n+    }\n+\n     public boolean isLogical() {\n         return _delAction == ACTION_NONE;\n     }\n@@ -227,58 +235,88 @@ private boolean isPrimaryKeyAutoAssigned(List seen) {\n \n     /**\n      * The name of the primary key table.\n+     * @deprecated\n      */\n     public String getPrimaryKeyTableName() {\n+        return getPrimaryKeyTableIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getPrimaryKeyTableIdentifier() {\n         Table table = getPrimaryKeyTable();\n         if (table != null)\n-            return table.getName();\n-        return _pkTableName;\n+            return table.getIdentifier();\n+        return _pkTableName == null ? DBIdentifier.NULL : _pkTableName;\n     }\n \n     /**\n      * The name of the primary key table. You can only set the primary\n      * key table name on foreign keys that have not already been joined.\n+     * @deprecated\n      */\n     public void setPrimaryKeyTableName(String pkTableName) {\n+        setPrimaryKeyTableIdentifier(DBIdentifier.newTable(pkTableName));\n+    }\n+\n+    public void setPrimaryKeyTableIdentifier(DBIdentifier pkTableName) {\n         if (getPrimaryKeyTable() != null)\n             throw new IllegalStateException();\n         _pkTableName = pkTableName;\n     }\n \n     /**\n      * The name of the primary key table's schema.\n+     * @deprecated\n      */\n     public String getPrimaryKeySchemaName() {\n+        return getPrimaryKeySchemaIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getPrimaryKeySchemaIdentifier() {\n         Table table = getPrimaryKeyTable();\n         if (table != null)\n-            return table.getSchemaName();\n+            return table.getSchemaIdentifier();\n         return _pkSchemaName;\n     }\n \n     /**\n      * The name of the primary key table's schema. You can only set the\n      * primary key schema name on foreign keys that have not already been\n      * joined.\n+     * @deprecated\n      */\n     public void setPrimaryKeySchemaName(String pkSchemaName) {\n+        setPrimaryKeySchemaIdentifier(DBIdentifier.newSchema(pkSchemaName));\n+    }\n+\n+    public void setPrimaryKeySchemaIdentifier(DBIdentifier pkSchemaName) {\n         if (getPrimaryKeyTable() != null)\n             throw new IllegalStateException();\n         _pkSchemaName = pkSchemaName;\n     }\n \n     /**\n      * The name of the primary key column.\n+     * @deprecated\n      */\n     public String getPrimaryKeyColumnName() {\n-        return _pkColumnName;\n+        return getPrimaryKeyColumnIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getPrimaryKeyColumnIdentifier() {\n+        return _pkColumnName == null ? DBIdentifier.NULL : _pkColumnName;\n     }\n \n     /**\n      * The name of the primary key column. You can only set the\n      * primary key column name on foreign keys that have not already been\n      * joined.\n+     * @deprecated\n      */\n     public void setPrimaryKeyColumnName(String pkColumnName) {\n+        setPrimaryKeyColumnIdentifier(DBIdentifier.newColumn(pkColumnName));\n+    }\n+\n+    public void setPrimaryKeyColumnIdentifier(DBIdentifier pkColumnName) {\n         if (getPrimaryKeyTable() != null)\n             throw new IllegalStateException();\n         _pkColumnName = pkColumnName;\n@@ -729,7 +767,7 @@ private static boolean match(Column[] cols, Column[] fkCols) {\n \n     private static boolean hasColumn(Column[] cols, Column col) {\n         for (int i = 0; i < cols.length; i++)\n-            if (cols[i].getFullName().equalsIgnoreCase(col.getFullName()))\n+            if (cols[i].getQualifiedPath().equals(col.getQualifiedPath()))\n                 return true;\n         return false;\n     }\n@@ -745,36 +783,41 @@ private static boolean match(Object[] vals, Object[] fkVals) {\n     \n     /**\n      * Return the name of the foreignkey constraint as defined in the database.\n+     * @deprecated\n      */\n     public String loadNameFromDB(DBDictionary dbdict, Connection conn) {\n+        return loadIdentifierFromDB(dbdict, conn).getName();\n+    }\n+\n+    public DBIdentifier loadIdentifierFromDB(DBDictionary dbdict, Connection conn) {\n         if( isLogical() || getTable() == null)\n-            return null;\n-        String retVal = null;\n+            return DBIdentifier.NULL;\n+        DBIdentifier retVal = DBIdentifier.NULL;\n         try{\n             Schema schema = getTable().getSchema();\n             ForeignKey[] fks = dbdict.getImportedKeys(conn.getMetaData(), \n-                conn.getCatalog(), schema.getName(), \n-                getTable().getName(), conn, false);\n+                DBIdentifier.newCatalog(conn.getCatalog()), schema.getIdentifier(), \n+                getTable().getIdentifier(), conn, false);\n             for ( int i=0; i< fks.length; i++) {\n-                Table localtable = schema.getTable(fks[i].getTableName());\n+                Table localtable = schema.getTable(fks[i].getTableIdentifier());\n                 Table pkTable = schema.getTable(\n-                    fks[i].getPrimaryKeyTableName());\n+                    fks[i].getPrimaryKeyTableIdentifier());\n                 boolean addFK = false;\n                 ForeignKey fkTemp = localtable.getForeignKey(\n-                    fks[i].getName());\n+                    fks[i].getIdentifier());\n                 if( fkTemp == null) {\n                     addFK=true;\n                     fkTemp = localtable.addForeignKey(\n-                        fks[i].getName());\n+                        fks[i].getIdentifier());\n                     fkTemp.setDeferred(fks[i].isDeferred());\n                     fkTemp.setDeleteAction(fks[i].getDeleteAction());\n                 }\n                 if (fks[i].getColumns() == null || fks[i].getColumns().length == 0) {\n                     // Singular column foreign key \n                     if( ! fkTemp.containsColumn(\n-                        localtable.getColumn(fks[i].getColumnName(), dbdict)))\n-                    fkTemp.join(localtable.getColumn(fks[i].getColumnName(), dbdict), \n-                        pkTable.getColumn(fks[i].getPrimaryKeyColumnName(), dbdict));\n+                        localtable.getColumn(fks[i].getColumnIdentifier())))\n+                    fkTemp.join(localtable.getColumn(fks[i].getColumnIdentifier()), \n+                        pkTable.getColumn(fks[i].getPrimaryKeyColumnIdentifier()));\n                 } else {\n                     // Add the multi-column foreign key, joining local and pk columns in\n                     // the temporary key\n@@ -790,17 +833,17 @@ public String loadNameFromDB(DBDictionary dbdict, Connection conn) {\n                     }\n                     for (int j = 0; j < locCols.length; j++) {\n                         if( ! fkTemp.containsColumn(\n-                            localtable.getColumn(locCols[j].getName(), dbdict))) {\n-                            fkTemp.join(localtable.getColumn(locCols[j].getName(), dbdict), \n-                                pkTable.getColumn(pkCols[j].getName(), dbdict));\n+                            localtable.getColumn(locCols[j].getIdentifier()))) {\n+                            fkTemp.join(localtable.getColumn(locCols[j].getIdentifier()), \n+                                pkTable.getColumn(pkCols[j].getIdentifier()));\n                         }\n                     }\n                 }\n                 if( equalsForeignKey(fkTemp))\n                 {\n                     if(addFK)\n                         localtable.removeForeignKey(fkTemp);\n-                    retVal = fks[i].getName();\n+                    retVal = fks[i].getIdentifier();\n                     break;\n                 }\n                 if(addFK)\n@@ -825,8 +868,8 @@ public void addColumn(ForeignKey fk) {\n             // If this FK is single column key, covert to a multi-column key\n             Column[] keyCols = createKeyColumns(this);\n             if (keyCols[0] != null && keyCols[1] != null) {\n-                setPrimaryKeyColumnName(null);\n-                setColumnName(null);\n+                setPrimaryKeyColumnIdentifier(DBIdentifier.NULL);\n+                setColumnIdentifier(DBIdentifier.NULL);\n                 join(keyCols[0], keyCols[1]);\n             }\n         }\n@@ -845,19 +888,19 @@ public void addColumn(ForeignKey fk) {\n      */\n     private static Column[] createKeyColumns(ForeignKey fk) {\n         Column fkCol = null;\n-        if (!StringUtils.isEmpty(fk.getColumnName())) {\n+        if (!DBIdentifier.isEmpty(fk.getColumnIdentifier())) {\n             fkCol = new Column();\n-            fkCol.setName(fk.getColumnName());\n-            fkCol.setTableName(fk.getTableName());\n-            fkCol.setSchemaName(fk.getSchemaName());\n+            fkCol.setIdentifier(fk.getColumnIdentifier());\n+            fkCol.setTableIdentifier(fk.getTableIdentifier());\n+            fkCol.setSchemaIdentifier(fk.getSchemaIdentifier());\n         }\n         \n         Column pkCol = null;\n-        if (!StringUtils.isEmpty(fk.getPrimaryKeyColumnName())) {\n+        if (!DBIdentifier.isEmpty(fk.getPrimaryKeyColumnIdentifier())) {\n             pkCol = new Column();\n-            pkCol.setName(fk.getPrimaryKeyColumnName());\n-            pkCol.setTableName(fk.getPrimaryKeyTableName());\n-            pkCol.setSchemaName(fk.getPrimaryKeySchemaName());\n+            pkCol.setIdentifier(fk.getPrimaryKeyColumnIdentifier());\n+            pkCol.setTableIdentifier(fk.getPrimaryKeyTableIdentifier());\n+            pkCol.setSchemaIdentifier(fk.getPrimaryKeySchemaIdentifier());\n         }\n         return new Column[] { fkCol, pkCol };\n     }\n@@ -878,7 +921,7 @@ public ForeignKey getFk() {\n         }\n \n         public int hashCode() {\n-            return getFk().getName() != null ? getFk().getName().hashCode() : getFk().hashCode();\n+            return getFk().getIdentifier() != null ? getFk().getIdentifier().hashCode() : getFk().hashCode();\n         }\n         \n         public boolean equals(Object fkObj) {\n@@ -893,14 +936,14 @@ public boolean equals(Object fkObj) {\n                 return false;\n             if (getFk().isDeferred() != fk.isDeferred())\n                 return false;\n-            if (!getFk().getName().equals(fk.getName())) {\n+            if (!getFk().getIdentifier().equals(fk.getIdentifier())) {\n                 return false;\n             }\n             // Assert PK table name and schema\n-            if (!StringUtils.equals(getFk().getPrimaryKeySchemaName(), fk.getPrimaryKeySchemaName()) ||\n-                !StringUtils.equals(getFk().getPrimaryKeyTableName(), fk.getPrimaryKeyTableName()) ||\n-                !StringUtils.equals(getFk().getSchemaName(), fk.getSchemaName()) ||\n-                !StringUtils.equals(getFk().getTableName(), fk.getTableName())) {\n+            if (!getFk().getPrimaryKeySchemaIdentifier().equals(fk.getPrimaryKeySchemaIdentifier()) ||\n+                !getFk().getPrimaryKeyTableIdentifier().equals(fk.getPrimaryKeyTableIdentifier()) ||\n+                !getFk().getSchemaIdentifier().equals(fk.getSchemaIdentifier()) ||\n+                !getFk().getTableIdentifier().equals(fk.getTableIdentifier())) {\n                 return false;\n             }\n             return true;"},{"sha":"2bd283869646dadbce35c03270b085bb9569b487","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Index.java","status":"modified","additions":19,"deletions":2,"changes":21,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Index.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Index.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Index.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -18,7 +18,7 @@\n  */\n package org.apache.openjpa.jdbc.schema;\n \n-import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n \n /**\n  * Represents a database index. Can also represent a partial index,\n@@ -27,6 +27,7 @@\n  * @author Abe White\n  * @author Stephen Kim\n  */\n+@SuppressWarnings(\"serial\")\n public class Index\n     extends LocalConstraint {\n \n@@ -43,11 +44,16 @@ public Index() {\n      *\n      * @param name the name of the index\n      * @param table the table of the index\n+     * @deprecated\n      */\n     public Index(String name, Table table) {\n         super(name, table);\n     }\n \n+    public Index(DBIdentifier name, Table table) {\n+        super(name, table);\n+    }\n+\n     /**\n      * Return true if this is a UNIQUE index.\n      */\n@@ -66,6 +72,17 @@ public boolean isLogical() {\n         return false;\n     }\n \n+    /**\n+     * @deprecated\n+     */\n+    public String getFullName() {\n+        return getFullIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getFullIdentifier() {\n+        return getQualifiedPath().getIdentifier();\n+    }\n+\n     /**\n      * Indexes are equal if they have the same name, the same columns, and\n      * are both unique/not unique.\n@@ -78,7 +95,7 @@ public boolean equalsIndex(Index idx) {\n \n         if (isUnique() != idx.isUnique())\n             return false;\n-        if (!StringUtils.equalsIgnoreCase(getFullName(), idx.getFullName()))\n+        if (!getQualifiedPath().equals(idx.getQualifiedPath()))\n             return false;\n         return equalsLocalConstraint(idx);\n     }"},{"sha":"6e810e504f8fcd3dbede6f0259f9b117b565ed87","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LazySchemaFactory.java","status":"modified","additions":47,"deletions":26,"changes":73,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LazySchemaFactory.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LazySchemaFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LazySchemaFactory.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -23,9 +23,13 @@\n import java.sql.SQLException;\n \n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifierUtil;\n+import org.apache.openjpa.jdbc.identifier.QualifiedDBIdentifier;\n import org.apache.openjpa.jdbc.sql.SQLExceptions;\n import org.apache.openjpa.lib.conf.Configurable;\n import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.identifier.IdentifierRule;\n \n /**\n  * Factory that uses database metadata to construct the system schema.\n@@ -35,6 +39,7 @@\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public class LazySchemaFactory\n     extends SchemaGroup\n     implements SchemaFactory, Configurable {\n@@ -80,19 +85,49 @@ public void storeSchema(SchemaGroup schema) {\n         // nothing to do\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public Table findTable(String name) {\n         if (name == null)\n             return null;\n+        return findTable(DBIdentifier.newTable(name));\n+    }\n \n-        Table table = super.findTable(name);\n+    public Table findTable(DBIdentifier name) {\n+        if (name == null)\n+            return null;\n+        return findTable(QualifiedDBIdentifier.getPath(name));\n+    }\n+\n+    public Table findTable(QualifiedDBIdentifier path) {\n+        if (path == null)\n+            return null;\n+\n+        Table table = super.findTable(path);\n         if (table != null)\n             return table;\n \n-        generateSchemaObject(name, true);\n-        return super.findTable(name);\n+        generateSchemaObject(path, true);\n+        return super.findTable(path);\n     }\n \n+    /**\n+     * @deprecated\n+     */\n     public Sequence findSequence(String name) {\n+        if (name == null)\n+            return null;\n+        return findSequence(DBIdentifier.newSequence(name));\n+    }\n+\n+    public Sequence findSequence(DBIdentifier name) {\n+        if (name == null)\n+            return null;\n+        return findSequence(QualifiedDBIdentifier.getPath(name));\n+    }\n+        \n+    public Sequence findSequence(QualifiedDBIdentifier name) {\n         if (name == null)\n             return null;\n \n@@ -107,24 +142,10 @@ public Sequence findSequence(String name) {\n     /**\n      * Generate the table or sequence with the given name.\n      */\n-    private void generateSchemaObject(String name, boolean isTable) {\n+    private void generateSchemaObject(QualifiedDBIdentifier name, boolean isTable) {\n         // if full name, split\n-        String schemaName = null;\n-        String objectName = name;\n-\n-        // look for the standard schema separator...\n-        int dotIdx = name.indexOf('.');\n-        // ... or the dictionary schema separator\n-        if (dotIdx == -1) {\n-            String sep = _conf.getDBDictionaryInstance().catalogSeparator;\n-            if (!\".\".equals(sep))\n-                dotIdx = name.indexOf(sep);\n-        }\n-\n-        if (dotIdx != -1) {\n-            schemaName = name.substring(0, dotIdx);\n-            objectName = name.substring(dotIdx + 1);\n-        }\n+        DBIdentifier schemaName = name.getSchemaName();\n+        DBIdentifier objectName = name.getIdentifier();\n \n         // we share a single connection across all schemas, so synch\n         // on the schema group\n@@ -149,18 +170,18 @@ private void generateSchemaObject(String name, boolean isTable) {\n \n                     if (table != null) {\n                         if (_pks)\n-                            _gen.generatePrimaryKeys(table.getSchemaName(),\n-                                table.getName(), _conn, _meta);\n+                            _gen.generatePrimaryKeys(table.getSchemaIdentifier(),\n+                                table.getIdentifier(), _conn, _meta);\n                         if (_indexes)\n-                            _gen.generateIndexes(table.getSchemaName(),\n-                                table.getName(), _conn, _meta);\n+                            _gen.generateIndexes(table.getSchemaIdentifier(),\n+                                table.getIdentifier(), _conn, _meta);\n \n                         // generate foreign keys from the table; this might\n                         // end up re-calling this getTable method if the foreign\n                         // key links to a table that hasn't been loaded yet\n                         if (_fks)\n-                            _gen.generateForeignKeys(table.getSchemaName(),\n-                                table.getName(), _conn, _meta);\n+                            _gen.generateForeignKeys(table.getSchemaIdentifier(),\n+                                table.getIdentifier(), _conn, _meta);\n                     }\n                 } else\n                     _gen.generateSequences(schemaName, objectName, _conn,"},{"sha":"9126bef1698140a32fb4061ab251c8f6016638e8","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LocalConstraint.java","status":"modified","additions":10,"deletions":5,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LocalConstraint.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LocalConstraint.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/LocalConstraint.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -21,7 +21,7 @@\n import java.util.ArrayList;\n import java.util.List;\n \n-import org.apache.commons.lang.ObjectUtils;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.util.InvalidStateException;\n \n@@ -32,13 +32,14 @@\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class LocalConstraint\n     extends Constraint {\n \n     private static final Localizer _loc = Localizer.forPackage\n         (LocalConstraint.class);\n \n-    private List _colList = null;\n+    private List<Column> _colList = null;\n     private Column[] _cols = null;\n \n     /**\n@@ -52,12 +53,16 @@ public LocalConstraint() {\n      *\n      * @param name the name of the constraint, if any\n      * @param table the table of the constraint\n+     * @deprecated\n      */\n     public LocalConstraint(String name, Table table) {\n         super(name, table);\n     }\n \n-    /**\n+    public LocalConstraint(DBIdentifier name, Table table) {\n+        super(name, table);\n+    }\n+/**\n      * Called when the constraint is removed from its table.\n      */\n     void remove() {\n@@ -99,7 +104,7 @@ public void addColumn(Column col) {\n                 col == null ? null : getTable()));\n     \t\n         if (_colList == null)\n-            _colList = new ArrayList(3);\n+            _colList = new ArrayList<Column>(3);\n         else if (_colList.contains(col))\n             return;\n \n@@ -168,7 +173,7 @@ public boolean columnsMatch(Column[] ocols) {\n      */\n     private static boolean hasColumn(Column[] cols, Column col) {\n         for (int i = 0; i < cols.length; i++)\n-            if (cols[i].getFullName().equalsIgnoreCase(col.getFullName()))\n+            if (cols[i].getQualifiedPath().equals(col.getQualifiedPath()))\n                 return true;\n         return false;\n     }"},{"sha":"3cdcea3265ce8228adae1e58f3b49afb16cb0ec6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/NameSet.java","status":"modified","additions":41,"deletions":10,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/NameSet.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/NameSet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/NameSet.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -23,6 +23,8 @@\n import java.util.Set;\n \n import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n import org.apache.openjpa.lib.util.Localizer;\n \n /**\n@@ -32,30 +34,47 @@\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public class NameSet\n     implements Serializable {\n \n     private static final Localizer _loc = Localizer.forPackage(NameSet.class);\n \n-    private Set _names = null;\n+    private Set<DBIdentifier> _names = null;\n \n     /**\n      * Return true if the given name is in use already.\n+     * @deprecated\n      */\n     public boolean isNameTaken(String name) {\n-        if (name == null)\n+        return isNameTaken(DBIdentifier.toUpper(DBIdentifier.newDefault(name)));\n+    }\n+    \n+    public boolean isNameTaken(DBIdentifier name) {\n+        if (DBIdentifier.isEmpty(name)) {\n             return true;\n-        return _names != null && _names.contains(name.toUpperCase());\n+        }\n+        if (_names == null) {\n+            return false;\n+        }\n+        DBIdentifier sName = DBIdentifier.toUpper(name);\n+        return _names.contains(sName);\n     }\n \n+    /**\n+     * @deprecated\n+     */\n+    protected void addName(String name, boolean validate) {\n+        addName(DBIdentifier.newIdentifier(name, DBIdentifierType.DEFAULT, true), validate);\n+    }\n     /**\n      * Attempt to add the given name to the set.\n      *\n      * @param name the name to add\n      * @param validate if true, null or empty names will not be accepted\n      */\n-    protected void addName(String name, boolean validate) {\n-        if (StringUtils.isEmpty(name)) {\n+    protected void addName(DBIdentifier name, boolean validate) {\n+        if (DBIdentifier.isNull(name) || StringUtils.isEmpty(name.getName())) {\n             if (validate)\n                 throw new IllegalArgumentException(_loc.get(\"bad-name\", name)\n                     .getMessage());\n@@ -66,15 +85,27 @@ protected void addName(String name, boolean validate) {\n         // DBs use different namespaces for components, and it would be\n         // difficult to find a scheme that fits all and is still useful\n         if (_names == null)\n-            _names = new HashSet();\n-        _names.add(name.toUpperCase());\n+            _names = new HashSet<DBIdentifier>();\n+        DBIdentifier sName = DBIdentifier.toUpper(name);\n+        _names.add(sName);\n     }\n \n     /**\n-     * Remove the given name from the table.\n+     * @deprecated\n      */\n     protected void removeName(String name) {\n-        if (name != null && _names != null)\n-            _names.remove(name.toUpperCase());\n+        if (name != null && _names != null) {\n+            removeName(DBIdentifier.newIdentifier(name, DBIdentifierType.DEFAULT, true));\n+        }\n+    }\n+    /**\n+     * Remove the given name from the table.\n+     */\n+    protected void removeName(DBIdentifier name) {\n+        if (!DBIdentifier.isNull(name) && _names != null) {\n+            DBIdentifier sName = DBIdentifier.toUpper(name);\n+            _names.remove(sName);\n+        }\n     }\n+    \n }"},{"sha":"a51d9a9581352d2dddd735868cfd4be0fd579f87","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/PrimaryKey.java","status":"modified","additions":8,"deletions":0,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/PrimaryKey.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/PrimaryKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/PrimaryKey.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -18,13 +18,16 @@\n  */\n package org.apache.openjpa.jdbc.schema;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+\n /**\n  * Represents a table primary key. It can also represent a partial key,\n  * aligning with the key information available from\n  * {@link java.sql.DatabaseMetaData}.\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public class PrimaryKey\n     extends LocalConstraint {\n \n@@ -41,11 +44,16 @@ public PrimaryKey() {\n      *\n      * @param name the name of the primary key, if any\n      * @param table the table of the primary key\n+     * @deprecated\n      */\n     public PrimaryKey(String name, Table table) {\n         super(name, table);\n     }\n \n+    public PrimaryKey(DBIdentifier name, Table table) {\n+        super(name, table);\n+    }\n+\n     public boolean isLogical() {\n         return _logical;\n     }"},{"sha":"f59b07064b035e36cf722b1239d406da7a0d9851","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schema.java","status":"modified","additions":89,"deletions":48,"changes":137,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schema.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schema.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schema.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -22,22 +22,22 @@\n import java.util.Map;\n import java.util.TreeMap;\n \n-import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n \n /**\n  * Represents a database schema.\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public class Schema\n-    implements Comparable, Serializable {\n+    implements Comparable<Schema>, Serializable {\n \n-    private String _name = null;\n+    private DBIdentifier _name = DBIdentifier.NULL;\n     private SchemaGroup _group = null;\n-    private Map _tableMap = null;\n-    private Map _seqMap = null;\n-    // TODO: temp until a more global solution is implemented\n-    private Map<String, Sequence> _delimSeqMap = null;\n+    private Map<DBIdentifier, Table> _tableMap = null;\n+    private Map<DBIdentifier, Sequence> _seqMap = null;\n \n     // cache\n     private Table[] _tables = null;\n@@ -54,9 +54,14 @@ public Schema() {\n      *\n      * @param name the schema name, if any\n      * @param group the schema's owning group\n+     * @deprecated\n      */\n     public Schema(String name, SchemaGroup group) {\n-        setName(name);\n+        this(DBIdentifier.newSchema(name), group);\n+    }\n+\n+    public Schema(DBIdentifier name, SchemaGroup group) {\n+        setIdentifier(name);\n         _group = group;\n     }\n \n@@ -83,21 +88,31 @@ public SchemaGroup getSchemaGroup() {\n \n     /**\n      * Return the name of the schema, or null if none.\n+     * @deprecated\n      */\n     public String getName() {\n+        return getIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getIdentifier() {\n         return _name;\n     }\n \n     /**\n      * Set the name of the schema. This method can only be used for schemas\n      * not attached to a group.\n+     * @deprecated\n      */\n     public void setName(String name) {\n+        setIdentifier(DBIdentifier.trimToNull(DBIdentifier.newSchema(name)));\n+    }\n+\n+    public void setIdentifier(DBIdentifier name) {\n         if (getSchemaGroup() != null)\n             throw new IllegalStateException();\n-        _name = StringUtils.trimToNull(name);\n+        _name = DBIdentifier.trimToNull(name);\n     }\n-\n+    \n     /**\n      * Return the schema's tables.\n      */\n@@ -110,35 +125,56 @@ public void setName(String name) {\n \n     /**\n      * Return the table with the given name, or null if none.\n+     * @deprecated\n      */\n     public Table getTable(String name) {\n         if (name == null || _tableMap == null)\n             return null;\n-        return (Table) _tableMap.get(name.toUpperCase());\n+        return getTable(DBIdentifier.newIdentifier(name, DBIdentifierType.TABLE, true));\n+    }\n+\n+    public Table getTable(DBIdentifier name) {\n+        if (DBIdentifier.isNull(name) || _tableMap == null)\n+            return null;\n+        DBIdentifier sName = DBIdentifier.toUpper(name);\n+        return (Table) _tableMap.get(sName);\n     }\n \n     /**\n      * Add a table to the schema.\n+     * @deprecated\n      */\n     public Table addTable(String name) {\n+        return addTable(DBIdentifier.newTable(name));\n+    }\n+    \n+    public Table addTable(DBIdentifier name) {\n         SchemaGroup group = getSchemaGroup();\n         Table tab;\n+        name = name.getUnqualifiedName();\n         if (group != null) {\n             group.addName(name, true);\n             tab = group.newTable(name, this);\n         } else\n             tab = new Table(name, this);\n         if (_tableMap == null)\n-            _tableMap = new TreeMap();\n-        _tableMap.put(name.toUpperCase(), tab);\n+            _tableMap = new TreeMap<DBIdentifier, Table>();\n+        DBIdentifier sName = DBIdentifier.toUpper(name);\n+        _tableMap.put(sName, tab);\n         _tables = null;\n         return tab;\n     }\n+    \n \n     /**\n      * Add a table with a shortened (i.e., validated) name to the schema\n+     * @deprecated\n      */\n     public Table addTable(String name, String validName) {\n+        return addTable(DBIdentifier.newTable(name), DBIdentifier.newTable(validName));\n+    }\n+\n+    public Table addTable(DBIdentifier name, DBIdentifier validName) {\n         SchemaGroup group = getSchemaGroup();\n         Table tab;\n         if (group != null) {\n@@ -147,8 +183,9 @@ public Table addTable(String name, String validName) {\n         } else\n             tab = new Table(validName, this);\n         if (_tableMap == null)\n-            _tableMap = new TreeMap();\n-        _tableMap.put(name.toUpperCase(), tab);\n+            _tableMap = new TreeMap<DBIdentifier, Table>();\n+        DBIdentifier sName = DBIdentifier.toUpper(name);\n+        _tableMap.put(sName, tab);\n         _tables = null;\n         return tab;\n     }\n@@ -162,15 +199,16 @@ public boolean removeTable(Table tab) {\n         if (tab == null || _tableMap == null)\n             return false;\n \n-        Table cur = (Table) _tableMap.get(tab.getName().toUpperCase());\n+        DBIdentifier sName = DBIdentifier.toUpper(tab.getIdentifier());\n+        Table cur = (Table) _tableMap.get(sName);\n         if (!cur.equals(tab))\n             return false;\n \n-        _tableMap.remove(tab.getName().toUpperCase());\n+        _tableMap.remove(sName);\n         _tables = null;\n         SchemaGroup group = getSchemaGroup();\n         if (group != null)\n-            group.removeName(tab.getName());\n+            group.removeName(tab.getIdentifier());\n         tab.remove();\n         return true;\n     }\n@@ -183,7 +221,7 @@ public Table importTable(Table table) {\n         if (table == null)\n             return null;\n \n-        Table copy = addTable(table.getName());\n+        Table copy = addTable(table.getIdentifier());\n         Column[] cols = table.getColumns();\n         for (int i = 0; i < cols.length; i++)\n             copy.importColumn(cols[i]);\n@@ -204,22 +242,32 @@ public Table importTable(Table table) {\n \n     /**\n      * Return the sequence with the given name, or null if none.\n+     * @deprecated\n      */\n     public Sequence getSequence(String name) {\n         if (name == null || _seqMap == null)\n             return null;\n-        // TODO: temp until a more global solution is implemented\n-        Sequence seq = (Sequence) _seqMap.get(name.toUpperCase());\n-        if (seq == null && _delimSeqMap != null) {\n-            seq = _delimSeqMap.get(name.toUpperCase());\n-        }\n+        return getSequence(DBIdentifier.newIdentifier(name, DBIdentifierType.SEQUENCE, true));\n+    }\n+\n+    public Sequence getSequence(DBIdentifier name) {\n+        if (DBIdentifier.isNull(name) || _seqMap == null)\n+            return null;\n+        \n+        DBIdentifier sName = DBIdentifier.toUpper(name);\n+        Sequence seq = (Sequence) _seqMap.get(sName);\n         return seq;\n     }\n \n     /**\n      * Add a sequence to the schema.\n+     * @deprecated\n      */\n     public Sequence addSequence(String name) {\n+        return addSequence(DBIdentifier.newIdentifier(name, DBIdentifierType.SEQUENCE, true));\n+    }\n+\n+    public Sequence addSequence(DBIdentifier name) {\n         SchemaGroup group = getSchemaGroup();\n         Sequence seq;\n         if (group != null) {\n@@ -228,22 +276,13 @@ public Sequence addSequence(String name) {\n         } else\n             seq = new Sequence(name, this);\n         if (_seqMap == null)\n-            _seqMap = new TreeMap();\n-        _seqMap.put(name.toUpperCase(), seq);\n+            _seqMap = new TreeMap<DBIdentifier, Sequence>();\n+        \n+        DBIdentifier sName = DBIdentifier.toUpper(name);\n+        _seqMap.put(sName, seq);\n         _seqs = null;\n         return seq;\n     }\n-    \n-    public void addDelimSequenceName(String name, Sequence seq) {\n-        SchemaGroup group = getSchemaGroup();\n-        if (group != null) {\n-            group.addName(name, true);\n-        }\n-        if (_delimSeqMap == null) {\n-            _delimSeqMap = new TreeMap<String, Sequence>();\n-        }\n-        _delimSeqMap.put(name.toUpperCase(), seq);\n-    }\n \n     /**\n      * Remove the given sequence from the schema.\n@@ -254,15 +293,16 @@ public boolean removeSequence(Sequence seq) {\n         if (seq == null || _seqMap == null)\n             return false;\n \n-        Sequence cur = (Sequence) _seqMap.get(seq.getName().toUpperCase());\n+        DBIdentifier sName = DBIdentifier.toUpper(seq.getIdentifier());\n+        Sequence cur = (Sequence) _seqMap.get(sName);\n         if (!cur.equals(seq))\n             return false;\n \n-        _seqMap.remove(seq.getName().toUpperCase());\n+        _seqMap.remove(sName);\n         _seqs = null;\n         SchemaGroup group = getSchemaGroup();\n         if (group != null)\n-            group.removeName(seq.getName());\n+            group.removeName(seq.getIdentifier());\n         seq.remove();\n         return true;\n     }\n@@ -274,26 +314,27 @@ public Sequence importSequence(Sequence seq) {\n         if (seq == null)\n             return null;\n \n-        Sequence copy = addSequence(seq.getName());\n+        Sequence copy = addSequence(seq.getIdentifier());\n         copy.setInitialValue(seq.getInitialValue());\n         copy.setIncrement(seq.getIncrement());\n         copy.setAllocate(seq.getAllocate());\n         return copy;\n     }\n \n-    public int compareTo(Object other) {\n-        String name = getName();\n-        String otherName = ((Schema) other).getName();\n-        if (name == null && otherName == null)\n+    public int compareTo(Schema other) {\n+        DBIdentifier name = getIdentifier();\n+        DBIdentifier otherName = ((Schema) other).getIdentifier();\n+        if (DBIdentifier.isNull(name) && DBIdentifier.isNull(otherName)) {\n             return 0;\n-        if (name == null)\n+        }\n+        if (DBIdentifier.isNull(name))\n             return 1;\n-        if (otherName == null)\n+        if (DBIdentifier.isNull(otherName))\n             return -1;\n         return name.compareTo(otherName);\n     }\n \n     public String toString() {\n-        return getName();\n+        return getIdentifier().getName();\n     }\n }"},{"sha":"723f490754369a465c1a1bfcd5557293896b04ed","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java","status":"modified","additions":275,"deletions":171,"changes":446,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGenerator.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -34,8 +34,11 @@\n import java.util.Set;\n import javax.sql.DataSource;\n \n-import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.identifier.Normalizer;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.QualifiedDBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.lib.log.Log;\n import org.apache.openjpa.lib.util.Localizer;\n@@ -65,7 +68,7 @@\n     private boolean _openjpaTables = true;\n     private SchemaGroup _group = null;\n \n-    private List _listeners = null;\n+    private List<Listener> _listeners = null;\n     private int _schemaObjects = 0;\n \n     /**\n@@ -85,7 +88,20 @@ public SchemaGenerator(JDBCConfiguration conf) {\n         _dict = conf.getDBDictionaryInstance();\n \n         // create a table of allowed schema and tables to reflect on\n-        _allowed = parseSchemasList(conf.getSchemasList());\n+        String[] schemaArray = conf.getSchemasList();\n+        DBIdentifier[] names = new DBIdentifier[schemaArray == null ? 0 : schemaArray.length];\n+        for (int i = 0; i < names.length; i++) {\n+            String[] splitName = Normalizer.splitName(schemaArray[i]);\n+            if (splitName == null || splitName.length == 0) {\n+                continue;\n+            }\n+            if (splitName.length == 1) {\n+                names[i] = DBIdentifier.newSchema(schemaArray[i]);\n+            } else {\n+                names[i] = QualifiedDBIdentifier.newTable(schemaArray[i]);\n+            }\n+        }\n+        _allowed = parseSchemasList(names);\n     }\n \n     /**\n@@ -95,50 +111,42 @@ public SchemaGenerator(JDBCConfiguration conf) {\n      * null if no args are given. If no tables are given for a particular\n      * schema, maps the schema name to null.\n      */\n-    private static Object[][] parseSchemasList(String[] args) {\n+    private static Object[][] parseSchemasList(DBIdentifier[] args) {\n         if (args == null || args.length == 0)\n             return null;\n \n-        Map schemas = new HashMap();\n-        String schema, table;\n-        int dotIdx;\n-        Collection tables;\n+        Map<DBIdentifier, Collection<DBIdentifier>> schemas = new HashMap<DBIdentifier, Collection<DBIdentifier>>();\n+        DBIdentifier schema = DBIdentifier.NULL, table = DBIdentifier.NULL;\n+        Collection<DBIdentifier> tables = null;\n         for (int i = 0; i < args.length; i++) {\n-            dotIdx = args[i].indexOf('.');\n-            if (dotIdx == -1) {\n-                schema = args[i];\n-                table = null;\n-            } else if (dotIdx == 0) {\n-                schema = null;\n-                table = args[i].substring(1);\n-            } else {\n-                schema = args[i].substring(0, dotIdx);\n-                table = args[i].substring(dotIdx + 1);\n-            }\n+            QualifiedDBIdentifier path = QualifiedDBIdentifier.getPath(args[i]);\n+            schema = path.getSchemaName();\n+            table = path.getIdentifier();\n \n             // if just a schema name, map schema to null\n-            if (table == null && !schemas.containsKey(schema))\n+            if (DBIdentifier.isNull(table) && !schemas.containsKey(schema))\n                 schemas.put(schema, null);\n-            else if (table != null) {\n-                tables = (Collection) schemas.get(schema);\n+            else if (!DBIdentifier.isNull(table)) {\n+                tables = schemas.get(schema);\n                 if (tables == null) {\n-                    tables = new LinkedList();\n+                    tables = new LinkedList<DBIdentifier>();\n                     schemas.put(schema, tables);\n                 }\n                 tables.add(table);\n             }\n         }\n \n         Object[][] parsed = new Object[schemas.size()][2];\n-        Map.Entry entry;\n+        Map.Entry<DBIdentifier, Collection<DBIdentifier>> entry;\n         int idx = 0;\n-        for (Iterator itr = schemas.entrySet().iterator(); itr.hasNext();) {\n-            entry = (Map.Entry) itr.next();\n-            tables = (Collection) entry.getValue();\n+        for (Iterator<Map.Entry<DBIdentifier, Collection<DBIdentifier>>> itr = schemas.entrySet().iterator(); \n+            itr.hasNext();) {\n+            entry = itr.next();\n+            tables = entry.getValue();\n \n             parsed[idx][0] = entry.getKey();\n             if (tables != null)\n-                parsed[idx][1] = tables.toArray(new String[tables.size()]);\n+                parsed[idx][1] = tables.toArray(new DBIdentifier[tables.size()]);\n             idx++;\n         }\n         return parsed;\n@@ -240,16 +248,24 @@ public void setSchemaGroup(SchemaGroup group) {\n     public void generateSchemas()\n         throws SQLException {\n         fireGenerationEvent(_loc.get(\"generating-schemas\"));\n-        generateSchemas(null);\n+        generateSchemas((DBIdentifier[])null);\n     }\n \n+    /**\n+     * @deprecated\n+     */\n+    public void generateSchemas(String[] schemasAndTables)\n+        throws SQLException {        \n+        generateSchemas(DBIdentifier.toArray(schemasAndTables, DBIdentifierType.TABLE));\n+    }\n+    \n     /**\n      * Generate the schemas and/or tables named in the given strings.\n      * This method calls {@link #generateIndexes},\n      * {@link #generatePrimaryKeys}, and {@link #generateForeignKeys}\n      * automatically.\n      */\n-    public void generateSchemas(String[] schemasAndTables)\n+    public void generateSchemas(DBIdentifier[] schemasAndTables)\n         throws SQLException {\n         fireGenerationEvent(_loc.get(\"generating-schemas\"));\n \n@@ -260,39 +276,39 @@ public void generateSchemas(String[] schemasAndTables)\n             schemaMap = parseSchemasList(schemasAndTables);\n \n         if (schemaMap == null) {\n-            generateSchema(null, null);\n+            generateSchema(DBIdentifier.NULL, (DBIdentifier[])null);\n \n             // estimate the number of schema objects we will need to visit\n-            // in order to estimate progresss total for any listeners\n+            // in order to estimate progress total for any listeners\n             int numTables = getTables(null).size();\n             _schemaObjects += numTables\n                 + (_pks ? numTables : 0)\n                 + (_indexes ? numTables : 0)\n                 + (_fks ? numTables : 0);\n \n             if (_pks)\n-                generatePrimaryKeys(null, null);\n+                generatePrimaryKeys(DBIdentifier.NULL, null);\n             if (_indexes)\n-                generateIndexes(null, null);\n+                generateIndexes(DBIdentifier.NULL, null);\n             if (_fks)\n-                generateForeignKeys(null, null);\n+                generateForeignKeys(DBIdentifier.NULL, null);\n             return;\n         }\n \n         // generate all schemas and tables\n         for (int i = 0; i < schemaMap.length; i++)\n-            generateSchema((String) schemaMap[i][0],\n-                (String[]) schemaMap[i][1]);\n+            generateSchema((DBIdentifier) schemaMap[i][0],\n+                (DBIdentifier[]) schemaMap[i][1]);\n \n         // generate pks, indexes, fks\n-        String schemaName;\n-        String[] tableNames;\n+        DBIdentifier schemaName = DBIdentifier.NULL;\n+        DBIdentifier[] tableNames;\n         for (int i = 0; i < schemaMap.length; i++) {\n-            schemaName = (String) schemaMap[i][0];\n-            tableNames = (String[]) schemaMap[i][1];\n+            schemaName = (DBIdentifier) schemaMap[i][0];\n+            tableNames = (DBIdentifier[]) schemaMap[i][1];\n \n             // estimate the number of schema objects we will need to visit\n-            // in order to estimate progresss total for any listeners\n+            // in order to estimate progress total for any listeners\n             int numTables = (tableNames != null) ? tableNames.length\n                 : getTables(schemaName).size();\n             _schemaObjects += numTables\n@@ -309,6 +325,17 @@ public void generateSchemas(String[] schemasAndTables)\n         }\n     }\n \n+    /**\n+     * @param name\n+     * @param tableNames\n+     * @deprecated\n+     */\n+    public void generateSchema(String name, String[] tableNames)\n+        throws SQLException {\n+        generateSchema(DBIdentifier.newSchema(name),\n+            DBIdentifier.toArray(tableNames, DBIdentifierType.TABLE));\n+    }\n+\n     /**\n      * Add a fully-constructed {@link Schema} matching the given database\n      * schema to the current group. No foreign keys are generated because\n@@ -320,7 +347,7 @@ public void generateSchemas(String[] schemasAndTables)\n      * @param tableNames a list of tables to generate in the schema, or null\n      * to generate all tables\n      */\n-    public void generateSchema(String name, String[] tableNames)\n+    public void generateSchema(DBIdentifier name, DBIdentifier[] tableNames)\n         throws SQLException {\n         fireGenerationEvent(_loc.get(\"generating-schema\", name));\n \n@@ -329,13 +356,13 @@ public void generateSchema(String name, String[] tableNames)\n         DatabaseMetaData meta = conn.getMetaData();\n         try {\n             if (tableNames == null)\n-                generateTables(name, null, conn, meta);\n+                generateTables(name, DBIdentifier.NULL, conn, meta);\n             else\n                 for (int i = 0; i < tableNames.length; i++)\n                     generateTables(name, tableNames[i], conn, meta);\n \n             if (_seqs)\n-                generateSequences(name, null, conn, meta);\n+                generateSequences(name, DBIdentifier.NULL, conn, meta);\n         } finally {\n             // some databases require a commit after metadata to release locks\n             try {\n@@ -355,8 +382,23 @@ public void generateSchema(String name, String[] tableNames)\n      * only be called after all schemas are generated. The schema name and\n      * tables array can be null to indicate that indexes should be generated\n      * for all schemas and/or tables.\n+     * @deprecated\n      */\n     public void generatePrimaryKeys(String schemaName, String[] tableNames)\n+        throws SQLException {\n+        generatePrimaryKeys(DBIdentifier.newSchema(schemaName),\n+            DBIdentifier.toArray(tableNames, DBIdentifierType.TABLE));\n+    }\n+\n+    \n+    /**\n+     * Generate primary key information for the given schema. This method\n+     * must be called in addition to {@link #generateSchema}. It should\n+     * only be called after all schemas are generated. The schema name and\n+     * tables array can be null to indicate that indexes should be generated\n+     * for all schemas and/or tables.\n+     */\n+    public void generatePrimaryKeys(DBIdentifier schemaName, DBIdentifier[] tableNames)\n         throws SQLException {\n         fireGenerationEvent(_loc.get(\"generating-all-primaries\", schemaName));\n \n@@ -381,14 +423,28 @@ public void generatePrimaryKeys(String schemaName, String[] tableNames)\n         }\n     }\n \n+    /**\n+     * Generate index information for the given schema. This method\n+     * must be called in addition to {@link #generateSchema}. It should\n+     * only be called after all schemas are generated. The schema name and\n+     * tables array can be null to indicate that indexes should be generated\n+     * for all schemas and/or tables.\n+     * @deprecated\n+     */\n+    public void generateIndexes(String schemaName, String[] tableNames) \n+        throws SQLException {\n+        generateIndexes(DBIdentifier.newSchema(schemaName),\n+            DBIdentifier.toArray(tableNames, DBIdentifierType.TABLE));\n+    }\n+\n     /**\n      * Generate index information for the given schema. This method\n      * must be called in addition to {@link #generateSchema}. It should\n      * only be called after all schemas are generated. The schema name and\n      * tables array can be null to indicate that indexes should be generated\n      * for all schemas and/or tables.\n      */\n-    public void generateIndexes(String schemaName, String[] tableNames)\n+    public void generateIndexes(DBIdentifier schemaName, DBIdentifier[] tableNames)\n         throws SQLException {\n         fireGenerationEvent(_loc.get(\"generating-all-indexes\", schemaName));\n \n@@ -419,8 +475,23 @@ public void generateIndexes(String schemaName, String[] tableNames)\n      * only be called after all schemas are generated. The schema name and\n      * tables array can be null to indicate that indexes should be generated\n      * for all schemas and/or tables.\n+     * @deprecated\n      */\n     public void generateForeignKeys(String schemaName, String[] tableNames)\n+        throws SQLException {\n+        generateForeignKeys(DBIdentifier.newSchema(schemaName),\n+            DBIdentifier.toArray(tableNames, DBIdentifierType.TABLE));\n+    }\n+\n+    \n+    /**\n+     * Generate foreign key information for the given schema. This method\n+     * must be called in addition to {@link #generateSchema}. It should\n+     * only be called after all schemas are generated. The schema name and\n+     * tables array can be null to indicate that indexes should be generated\n+     * for all schemas and/or tables.\n+     */\n+    public void generateForeignKeys(DBIdentifier schemaName, DBIdentifier[] tableNames)\n         throws SQLException {\n         fireGenerationEvent(_loc.get(\"generating-all-foreigns\", schemaName));\n \n@@ -446,69 +517,84 @@ public void generateForeignKeys(String schemaName, String[] tableNames)\n     }\n \n     /**\n-     * Adds all tables matching the given name pattern to the schema.\n+     * @deprecated\n      */\n     public void generateTables(String schemaName, String tableName,\n+        Connection conn, DatabaseMetaData meta) \n+        throws SQLException {\n+        generateTables(DBIdentifier.newSchema(schemaName),\n+            DBIdentifier.newTable(tableName), conn, meta);\n+    }\n+\n+    /**\n+     * Adds all tables matching the given name pattern to the schema.\n+     */\n+    public void generateTables(DBIdentifier schemaName, DBIdentifier tableName,\n         Connection conn, DatabaseMetaData meta)\n         throws SQLException {\n         fireGenerationEvent(_loc.get(\"generating-columns\", schemaName,\n             tableName));\n         if (_log.isTraceEnabled())\n             _log.trace(_loc.get(\"gen-tables\", schemaName, tableName));\n \n-        Column[] cols = _dict.getColumns(meta, conn.getCatalog(), schemaName,\n+        Column[] cols = _dict.getColumns(meta, \n+            DBIdentifier.newCatalog(conn.getCatalog()), schemaName,\n             tableName, null, conn);\n \n         // when we want to get all the columns for all tables, we need to build\n         // a list of tables to verify because some databases (e.g., Postgres)\n         // will include indexes in the list of columns, and there is no way to\n         // distinguish the indexes from proper columns\n-        Set tableNames = null;\n-        if (tableName == null || \"%\".equals(tableName)) {\n-            Table[] tables = _dict.getTables(meta, conn.getCatalog(),\n+        Set<DBIdentifier> tableNames = null;\n+        if (DBIdentifier.isNull(tableName) || \"%\".equals(tableName.getName())) {\n+            Table[] tables = _dict.getTables(meta, DBIdentifier.newCatalog(conn.getCatalog()),\n                 schemaName, tableName, conn);\n-            tableNames = new HashSet();\n+            tableNames = new HashSet<DBIdentifier>();\n             for (int i = 0; tables != null && i < tables.length; i++) {\n-                if (cols == null)\n-                    tableNames.add(tables[i].getName());\n-                else\n-                    tableNames.add(tables[i].getName().toUpperCase());\n+                if (cols == null) {\n+                    tableNames.add(tables[i].getIdentifier());\n+                }\n+                else {\n+                    DBIdentifier sName = DBIdentifier.toUpper(tables[i].getIdentifier());\n+                    tableNames.add(sName);\n+                }\n             }\n         }\n \n         // if database can't handle null table name, recurse on each known name\n-        if (cols == null && tableName == null) {\n-            for (Iterator itr = tableNames.iterator(); itr.hasNext();)\n-                generateTables(schemaName, (String) itr.next(), conn, meta);\n+        if (cols == null && DBIdentifier.isNull(tableName)) {\n+            for (Iterator<DBIdentifier> itr = tableNames.iterator(); itr.hasNext();)\n+                generateTables(schemaName, itr.next(), conn, meta);\n             return;\n         }\n \n         SchemaGroup group = getSchemaGroup();\n         Schema schema;\n         Table table;\n-        String tableSchema;\n+        DBIdentifier tableSchema = DBIdentifier.NULL;\n         for (int i = 0; cols != null && i < cols.length; i++) {\n-            if (tableName == null || tableName.equals(\"%\")) {\n-                tableName = cols[i].getTableName();\n+            if (DBIdentifier.isNull(tableName) || tableName.equals(\"%\")) {\n+                tableName = cols[i].getTableIdentifier();\n             }\n-            if (schemaName == null) {\n-                tableSchema = StringUtils.trimToNull(cols[i].getSchemaName());\n+            if (DBIdentifier.isNull(schemaName)) {\n+                tableSchema = DBIdentifier.trimToNull(cols[i].getSchemaIdentifier());\n             }\n             else {\n                 tableSchema = schemaName;\n             }\n             \n             // ignore special tables\n             if (!_openjpaTables &&\n-                (tableName.toUpperCase().startsWith(\"OPENJPA_\")\n-                    || tableName.toUpperCase().startsWith(\"JDO_\"))) // legacy\n+                (tableName.getName().toUpperCase().startsWith(\"OPENJPA_\")\n+                    || tableName.getName().toUpperCase().startsWith(\"JDO_\"))) // legacy\n                 continue;\n-            if (_dict.isSystemTable(tableName, tableSchema, schemaName != null))\n+            if (_dict.isSystemTable(tableName, tableSchema, !DBIdentifier.isNull(schemaName)))\n                 continue;\n \n             // ignore tables not in list, or not allowed by schemas property\n+            \n             if (tableNames != null\n-                && !tableNames.contains(tableName.toUpperCase()))\n+                && !tableNames.contains(DBIdentifier.toUpper(tableName)))\n                 continue;\n             if (!isAllowedTable(tableSchema, tableName))\n                 continue;\n@@ -525,9 +611,9 @@ public void generateTables(String schemaName, String tableName,\n             }\n \n             if (_log.isTraceEnabled())\n-                _log.trace(_loc.get(\"gen-column\", cols[i].getName(), table));\n+                _log.trace(_loc.get(\"gen-column\", cols[i].getIdentifier(), table));\n \n-            if (table.getColumn(cols[i].getName(), _dict) == null) {\n+            if (table.getColumn(cols[i].getIdentifier()) == null) {\n                 table.importColumn(cols[i]);\n             }\n         }\n@@ -536,47 +622,55 @@ public void generateTables(String schemaName, String tableName,\n     /**\n      * Return whether the given table is allowed by the user's schema list.\n      */\n-    private boolean isAllowedTable(String schema, String table) {\n+    private boolean isAllowedTable(DBIdentifier schema, DBIdentifier table) {\n         if (_allowed == null)\n             return true;\n \n         // do case-insensitive comparison on allowed table and schema names\n-        String[] tables;\n-        String[] anySchemaTables = null;\n+        DBIdentifier[] tables;\n+        DBIdentifier[] anySchemaTables = null;\n         for (int i = 0; i < _allowed.length; i++) {\n             if (_allowed[i][0] == null) {\n-                anySchemaTables = (String[]) _allowed[i][1];\n+                anySchemaTables = (DBIdentifier[]) _allowed[i][1];\n                 if (schema == null)\n                     break;\n                 continue;\n             }\n-            if (!StringUtils.equalsIgnoreCase(schema, (String) _allowed[i][0]))\n+            if (!schema.equals((DBIdentifier) _allowed[i][0]))\n                 continue;\n \n             if (table == null)\n                 return true;\n-            tables = (String[]) _allowed[i][1];\n+            tables = (DBIdentifier[]) _allowed[i][1];\n             if (tables == null)\n                 return true;\n             for (int j = 0; j < tables.length; j++)\n-                if (StringUtils.equalsIgnoreCase(table, tables[j]))\n+                if (table.equals(tables[j]))\n                     return true;\n         }\n \n         if (anySchemaTables != null) {\n             if (table == null)\n                 return true;\n             for (int i = 0; i < anySchemaTables.length; i++)\n-                if (StringUtils.equalsIgnoreCase(table, anySchemaTables[i]))\n+                if (table.equals(anySchemaTables[i]))\n                     return true;\n         }\n         return false;\n     }\n \n     /**\n      * Generates table primary keys.\n+     * @deprecated\n      */\n     public void generatePrimaryKeys(String schemaName, String tableName,\n+        Connection conn, DatabaseMetaData meta)\n+        throws SQLException {\n+        generatePrimaryKeys(DBIdentifier.newSchema(schemaName), DBIdentifier.newTable(tableName),\n+            conn, meta);\n+    }\n+\n+    public void generatePrimaryKeys(DBIdentifier schemaName, DBIdentifier tableName,\n         Connection conn, DatabaseMetaData meta)\n         throws SQLException {\n         fireGenerationEvent(_loc.get(\"generating-primary\",\n@@ -586,53 +680,63 @@ public void generatePrimaryKeys(String schemaName, String tableName,\n \n         // if looking for a non-existant table, just return\n         SchemaGroup group = getSchemaGroup();\n-        if (tableName != null && group.findTable(tableName) == null)\n+        if (tableName != null && !tableName.isNull() && \n+                group.findTable(QualifiedDBIdentifier.getPath(tableName)) == null)\n             return;\n \n         // if the database can't use a table name wildcard, recurse on each\n         // concrete table in the requested schema(s)\n-        PrimaryKey[] pks = _dict.getPrimaryKeys(meta, conn.getCatalog(),\n+        PrimaryKey[] pks = _dict.getPrimaryKeys(meta, \n+            DBIdentifier.newCatalog(conn.getCatalog()),\n             schemaName, tableName, conn);\n         Table table;\n         if (pks == null && tableName == null) {\n-            Collection tables = getTables(schemaName);\n-            for (Iterator itr = tables.iterator(); itr.hasNext();) {\n+            Collection<Table> tables = getTables(schemaName);\n+            for (Iterator<Table> itr = tables.iterator(); itr.hasNext();) {\n                 table = (Table) itr.next();\n-                generatePrimaryKeys(table.getSchemaName(),\n-                    table.getName(), conn, meta);\n+                generatePrimaryKeys(table.getSchemaIdentifier(),\n+                    table.getIdentifier(), conn, meta);\n             }\n             return;\n         }\n \n         Schema schema;\n         PrimaryKey pk;\n-        String name;\n-        String colName;\n+        DBIdentifier name = DBIdentifier.NULL;\n+        DBIdentifier colName = DBIdentifier.NULL;\n         for (int i = 0; pks != null && i < pks.length; i++) {\n-            schemaName = StringUtils.trimToNull(pks[i].getSchemaName());\n+            schemaName = DBIdentifier.trimToNull(schemaName);\n             schema = group.getSchema(schemaName);\n             if (schema == null)\n                 continue;\n-            table = schema.getTable(pks[i].getTableName());\n+            table = schema.getTable(pks[i].getTableIdentifier());\n             if (table == null)\n                 continue;\n \n-            colName = pks[i].getColumnName();\n-            name = pks[i].getName();\n+            colName = pks[i].getColumnIdentifier();\n+            name = pks[i].getIdentifier();\n             if (_log.isTraceEnabled())\n                 _log.trace(_loc.get(\"gen-pk\", name, table, colName));\n \n             pk = table.getPrimaryKey();\n             if (pk == null)\n                 pk = table.addPrimaryKey(name);\n-            pk.addColumn(table.getColumn(colName, _dict));\n+            pk.addColumn(table.getColumn(colName));\n         }\n     }\n \n     /**\n      * Generates table indexes.\n+     * @deprecated\n      */\n     public void generateIndexes(String schemaName, String tableName,\n+        Connection conn, DatabaseMetaData meta)\n+        throws SQLException {\n+        generateIndexes(DBIdentifier.newSchema(schemaName), DBIdentifier.newTable(tableName),\n+            conn, meta);\n+    }\n+\n+    public void generateIndexes(DBIdentifier schemaName, DBIdentifier tableName,\n         Connection conn, DatabaseMetaData meta)\n         throws SQLException {\n         fireGenerationEvent(_loc.get(\"generating-indexes\",\n@@ -642,52 +746,52 @@ public void generateIndexes(String schemaName, String tableName,\n \n         // if looking for a non-existant table, just return\n         SchemaGroup group = getSchemaGroup();\n-        if (tableName != null && group.findTable(tableName) == null)\n+        if (tableName != null && group.findTable(QualifiedDBIdentifier.getPath(tableName)) == null)\n             return;\n \n         // if the database can't use a table name wildcard, recurse on each\n         // concrete table in the requested schema(s)\n-        Index[] idxs = _dict.getIndexInfo(meta, conn.getCatalog(),\n+        Index[] idxs = _dict.getIndexInfo(meta, DBIdentifier.newCatalog(conn.getCatalog()),\n             schemaName, tableName, false, true, conn);\n         Table table;\n         if (idxs == null && tableName == null) {\n-            Collection tables = getTables(schemaName);\n-            for (Iterator itr = tables.iterator(); itr.hasNext();) {\n-                table = (Table) itr.next();\n-                generateIndexes(table.getSchemaName(),\n-                    table.getName(), conn, meta);\n+            Collection<Table> tables = getTables(schemaName);\n+            for (Iterator<Table> itr = tables.iterator(); itr.hasNext();) {\n+                table = itr.next();\n+                generateIndexes(table.getSchemaIdentifier(),\n+                    table.getIdentifier(), conn, meta);\n             }\n             return;\n         }\n \n         Schema schema;\n         Index idx;\n-        String name;\n-        String colName;\n-        String pkName;\n+        DBIdentifier name = DBIdentifier.NULL;\n+        DBIdentifier colName = DBIdentifier.NULL;\n+        DBIdentifier pkName = DBIdentifier.NULL;\n         for (int i = 0; idxs != null && i < idxs.length; i++) {\n-            schemaName = StringUtils.trimToNull(idxs[i].getSchemaName());\n+            schemaName = DBIdentifier.trimToNull(idxs[i].getSchemaIdentifier());\n             schema = group.getSchema(schemaName);\n             if (schema == null)\n                 continue;\n-            table = schema.getTable(idxs[i].getTableName());\n+            table = schema.getTable(idxs[i].getTableIdentifier());\n             if (table == null)\n                 continue;\n \n             if (table.getPrimaryKey() != null)\n-                pkName = table.getPrimaryKey().getName();\n+                pkName = table.getPrimaryKey().getIdentifier();\n             else\n                 pkName = null;\n \n             // statistics don't have names; skip them\n-            name = idxs[i].getName();\n-            if (StringUtils.isEmpty(name)\n-                || (pkName != null && name.equalsIgnoreCase(pkName))\n+            name = idxs[i].getIdentifier();\n+            if (DBIdentifier.isEmpty(name)\n+                || (pkName != null && name.equals(pkName))\n                 || _dict.isSystemIndex(name, table))\n                 continue;\n \n-            colName = idxs[i].getColumnName();\n-            if (table.getColumn(colName, _dict) == null)\n+            colName = idxs[i].getColumnIdentifier();\n+            if (table.getColumn(colName) == null)\n                 continue;\n \n             if (_log.isTraceEnabled())\n@@ -699,14 +803,21 @@ public void generateIndexes(String schemaName, String tableName,\n                 idx = table.addIndex(name);\n                 idx.setUnique(idxs[i].isUnique());\n             }\n-            idx.addColumn(table.getColumn(colName, _dict));\n+            idx.addColumn(table.getColumn(colName));\n         }\n     }\n \n     /**\n      * Generates table foreign keys.\n      */\n     public void generateForeignKeys(String schemaName, String tableName,\n+        Connection conn, DatabaseMetaData meta)\n+        throws SQLException {\n+        generateForeignKeys(DBIdentifier.newSchema(schemaName), DBIdentifier.newTable(tableName),\n+            conn, meta);\n+    }\n+\n+    public void generateForeignKeys(DBIdentifier schemaName, DBIdentifier tableName,\n         Connection conn, DatabaseMetaData meta)\n         throws SQLException {\n         fireGenerationEvent(_loc.get(\"generating-foreign\",\n@@ -716,66 +827,64 @@ public void generateForeignKeys(String schemaName, String tableName,\n \n         // if looking for a non-existant table, just return\n         SchemaGroup group = getSchemaGroup();\n-        if (tableName != null && group.findTable(tableName) == null)\n+        if (!DBIdentifier.isNull(tableName) && group.findTable(QualifiedDBIdentifier.getPath(tableName)) == null)\n             return;\n \n         // if the database can't use a table name wildcard, recurse on each\n         // concrete table in the requested schema(s)\n-        ForeignKey[] fks = _dict.getImportedKeys(meta, conn.getCatalog(),\n+        ForeignKey[] fks = _dict.getImportedKeys(meta, DBIdentifier.newCatalog(conn.getCatalog()),\n             schemaName, tableName, conn);\n         Table table;\n-        if (fks == null && tableName == null) {\n-            Collection tables = getTables(schemaName);\n-            for (Iterator itr = tables.iterator(); itr.hasNext();) {\n-                table = (Table) itr.next();\n-                generateForeignKeys(table.getSchemaName(),\n-                    table.getName(), conn, meta);\n+        if (fks == null && DBIdentifier.isNull(tableName)) {\n+            Collection<Table> tables = getTables(schemaName);\n+            for (Iterator<Table> itr = tables.iterator(); itr.hasNext();) {\n+                table = itr.next();\n+                generateForeignKeys(table.getSchemaIdentifier(),\n+                    table.getIdentifier(), conn, meta);\n             }\n             return;\n         }\n \n         Schema schema;\n         Table pkTable;\n         ForeignKey fk;\n-        String name;\n-        String pkSchemaName;\n-        String pkTableName;\n-        String pkColName;\n-        String fkColName;\n+        DBIdentifier name = DBIdentifier.NULL;\n+        DBIdentifier pkSchemaName = DBIdentifier.NULL;\n+        DBIdentifier pkTableName = DBIdentifier.NULL;\n+        DBIdentifier pkColName = DBIdentifier.NULL;\n+        DBIdentifier fkColName = DBIdentifier.NULL;\n         int seq;\n         boolean seqWas0 = false; // some drivers incorrectly start at 0\n-        Collection invalids = null;\n+        Collection<ForeignKey> invalids = null;\n         for (int i = 0; fks != null && i < fks.length; i++) {\n-            schemaName = StringUtils.trimToNull(fks[i].getSchemaName());\n+            schemaName = DBIdentifier.trimToNull(fks[i].getSchemaIdentifier());\n             schema = group.getSchema(schemaName);\n             if (schema == null)\n                 continue;\n-            table = schema.getTable(fks[i].getTableName());\n+            table = schema.getTable(fks[i].getTableIdentifier());\n             if (table == null)\n                 continue;\n \n-            name = fks[i].getName();\n-            fkColName = fks[i].getColumnName();\n-            pkColName = fks[i].getPrimaryKeyColumnName();\n+            name = fks[i].getIdentifier();\n+            fkColName = fks[i].getColumnIdentifier();\n+            pkColName = fks[i].getPrimaryKeyColumnIdentifier();\n             seq = fks[i].getKeySequence();\n             if (seq == 0)\n                 seqWas0 = true;\n             if (seqWas0)\n                 seq++;\n \n             // find pk table\n-            pkSchemaName = fks[i].getPrimaryKeySchemaName();\n+            pkSchemaName = fks[i].getPrimaryKeySchemaIdentifier();\n             if(_dict.getTrimSchemaName()) {\n-                pkSchemaName= StringUtils.trimToNull(pkSchemaName);\n+                pkSchemaName= DBIdentifier.trimToNull(pkSchemaName);\n             }\n-            pkTableName = fks[i].getPrimaryKeyTableName();\n+            pkTableName = fks[i].getPrimaryKeyTableIdentifier();\n             if (_log.isTraceEnabled())\n                 _log.trace(_loc.get(\"gen-fk\", new Object[]{ name, table,\n                     fkColName, pkTableName, pkColName, seq + \"\" }));\n \n-            if (!StringUtils.isEmpty(pkSchemaName))\n-                pkTableName = pkSchemaName + \".\" + pkTableName;\n-            pkTable = group.findTable(pkTableName);\n+            pkTable = group.findTable(QualifiedDBIdentifier.newPath(pkSchemaName, pkTableName));\n             if (pkTable == null)\n                 throw new SQLException(_loc.get(\"gen-nofktable\",\n                     table, pkTableName).getMessage());\n@@ -799,36 +908,44 @@ public void generateForeignKeys(String schemaName, String tableName,\n \n             if (invalids == null || !invalids.contains(fk)) {\n                 try {\n-                    Column fkCol = table.getColumn(fkColName, _dict);\n+                    Column fkCol = table.getColumn(fkColName);\n                     if (fkCol == null) {\n                         throw new IllegalArgumentException(_loc.get(\n-                            \"no-column\", fkColName, table.getName())\n+                            \"no-column\", fkColName, table.getIdentifier())\n                             .getMessage());\n                     }\n-                    fk.join(fkCol, pkTable.getColumn(pkColName, _dict));\n+                    fk.join(fkCol, pkTable.getColumn(pkColName));\n                 } catch (IllegalArgumentException iae) {\n                     if (_log.isWarnEnabled())\n                         _log.warn(_loc.get(\"bad-join\", iae.toString()));\n                     if (invalids == null)\n-                        invalids = new HashSet();\n+                        invalids = new HashSet<ForeignKey>();\n                     invalids.add(fk);\n                 }\n             }\n         }\n \n         // remove invalid fks\n         if (invalids != null) {\n-            for (Iterator itr = invalids.iterator(); itr.hasNext();) {\n-                fk = (ForeignKey) itr.next();\n+            for (Iterator<ForeignKey> itr = invalids.iterator(); itr.hasNext();) {\n+                fk = itr.next();\n                 fk.getTable().removeForeignKey(fk);\n             }\n         }\n     }\n \n     /**\n      * Adds all sequences matching the given name pattern to the schema.\n+     * @deprecated\n      */\n     public void generateSequences(String schemaName, String sequenceName,\n+        Connection conn, DatabaseMetaData meta)\n+        throws SQLException {\n+        generateSequences(DBIdentifier.newSchema(schemaName), \n+            DBIdentifier.newSequence(sequenceName), conn, meta);\n+    }\n+    \n+    public void generateSequences(DBIdentifier schemaName, DBIdentifier sequenceName,\n         Connection conn, DatabaseMetaData meta)\n         throws SQLException {\n         fireGenerationEvent(_loc.get(\"generating-sequences\", schemaName));\n@@ -837,20 +954,21 @@ public void generateSequences(String schemaName, String sequenceName,\n \n         // since all the sequences are generated under the default schema\n         // therefore, we can use the null schemaname to search\n-        Sequence[] seqs = _dict.getSequences(meta, conn.getCatalog(),\n-            null, sequenceName, conn);\n+        Sequence[] seqs = _dict.getSequences(meta, DBIdentifier.newCatalog(conn.getCatalog()),\n+            DBIdentifier.NULL, sequenceName, conn);\n \n         SchemaGroup group = getSchemaGroup();\n         Schema schema;\n-        String sequenceSchema;\n+        DBIdentifier sequenceSchema = DBIdentifier.NULL;\n         for (int i = 0; seqs != null && i < seqs.length; i++) {\n-            sequenceName = seqs[i].getName();\n-            sequenceSchema = StringUtils.trimToNull(seqs[i].getSchemaName());\n+            sequenceName = seqs[i].getIdentifier();\n+            sequenceSchema = DBIdentifier.trimToNull(seqs[i].getSchemaIdentifier());\n \n             // ignore special tables\n+            String seqUpper = DBIdentifier.toUpper(sequenceName).getName();\n             if (!_openjpaTables &&\n-                (sequenceName.toUpperCase().startsWith(\"OPENJPA_\")\n-                    || sequenceName.toUpperCase().startsWith(\"JDO_\"))) // legacy\n+                (seqUpper.startsWith(\"OPENJPA_\")\n+                    || seqUpper.startsWith(\"JDO_\"))) // legacy\n                 continue;\n             if (_dict.isSystemSequence(sequenceName, sequenceSchema,\n                 schemaName != null))\n@@ -859,27 +977,12 @@ public void generateSequences(String schemaName, String sequenceName,\n                 continue;\n \n             schema = group.getSchema(sequenceSchema);\n-            if (schema == null) {\n-                // TODO: temp until a more global name solution is implemented\n-                schema = group.getSchema(_dict.addDelimiters(sequenceSchema));\n-//                schema = group.getSchema(_dict.delimitString(sequenceSchema, \n-//                    DBDictionary.DBIdentifiers.SEQUENCE_GEN_SCHEMA));\n-            }\n             if (schema == null) {\n                 schema = group.addSchema(sequenceSchema);\n-                // TODO: temp until a more global solution is implemented\n-//                group.addDelimSchemaName(_dict.delimitString(sequenceSchema, \n-//                    DBDictionary.DBIdentifiers.SEQUENCE_GEN_SCHEMA), schema);\n-                group.addDelimSchemaName(_dict.addDelimiters(sequenceSchema), schema);\n             }\n             if (schema.getSequence(sequenceName) == null) {\n-                Sequence seq = schema.addSequence(sequenceName);\n-                // TODO: temp until a more global solution is implemented\n-//                schema.addDelimSequenceName(_dict.delimitString(sequenceName, \n-//                    DBDictionary.DBIdentifiers.SEQUENCE_GEN_SEQ_NAME), seq);\n-                schema.addDelimSequenceName(_dict.addDelimiters(sequenceName), seq);\n+                schema.addSequence(sequenceName);\n             }\n-                \n         }\n     }\n \n@@ -895,8 +998,8 @@ private void fireGenerationEvent(Object schemaObject)\n             return;\n \n         Event e = new Event(schemaObject, _schemaObjects);\n-        for (Iterator i = _listeners.iterator(); i.hasNext();) {\n-            Listener l = (Listener) i.next();\n+        for (Iterator<Listener> i = _listeners.iterator(); i.hasNext();) {\n+            Listener l = i.next();\n             if (!l.schemaObjectGenerated(e))\n                 throw new SQLException(_loc.get(\"refresh-cancelled\")\n                     .getMessage());\n@@ -910,7 +1013,7 @@ private void fireGenerationEvent(Object schemaObject)\n      */\n     public void addListener(Listener l) {\n         if (_listeners == null)\n-            _listeners = new LinkedList();\n+            _listeners = new LinkedList<Listener>();\n         _listeners.add(l);\n     }\n \n@@ -928,17 +1031,17 @@ public boolean removeListener(Listener l) {\n      * Return all tables for the given schema name, or all tables in\n      * the schema group if null is given.\n      */\n-    private Collection getTables(String schemaName) {\n+    private Collection<Table> getTables(DBIdentifier schemaName) {\n         SchemaGroup group = getSchemaGroup();\n-        if (schemaName != null) {\n+        if (!DBIdentifier.isNull(schemaName)) {\n             Schema schema = group.getSchema(schemaName);\n             if (schema == null)\n-                return Collections.EMPTY_LIST;\n+                return Collections.emptyList();\n             return Arrays.asList(schema.getTables());\n         }\n \n         Schema[] schemas = group.getSchemas();\n-        Collection tables = new LinkedList();\n+        Collection<Table> tables = new LinkedList<Table>();\n         for (int i = 0; i < schemas.length; i++)\n             tables.addAll(Arrays.asList(schemas[i].getTables()));\n         return tables;\n@@ -955,6 +1058,7 @@ private Collection getTables(String schemaName) {\n     /**\n      * An event corresponding to the generation of a schema object.\n      */\n+    @SuppressWarnings(\"serial\")\n     public class Event\n         extends EventObject {\n "},{"sha":"195e2ea26b1af28f067703b51de306376d2ddc88","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGroup.java","status":"modified","additions":161,"deletions":79,"changes":240,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGroup.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGroup.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaGroup.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -23,17 +23,20 @@\n import java.util.LinkedList;\n import java.util.Map;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.QualifiedDBIdentifier;\n+\n /**\n  * Represents a grouping of schemas used in a database.\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public class SchemaGroup\n     extends NameSet\n     implements Cloneable {\n \n-    private Map _schemaMap = null;\n-    private Map<String, Schema> _delimSchemaMap = null;\n+    private Map<DBIdentifier, Schema> _schemaMap = null;\n \n     // cache\n     private Schema[] _schemas = null;\n@@ -50,54 +53,52 @@\n \n     /**\n      * Return the schema with the given name, or null if none.\n+     * @deprecated\n      */\n     public Schema getSchema(String name) {\n         if (_schemaMap == null)\n             return null;\n-        if (name != null)\n-            name = name.toUpperCase();\n-        // TODO: temp until a more global solution is implemented\n-        Schema schema = (Schema) _schemaMap.get(name);\n-        if (schema == null && _delimSchemaMap != null) {\n-            schema = _delimSchemaMap.get(name);\n-        }\n+        return getSchema(DBIdentifier.toUpper(DBIdentifier.newSchema(name)));\n+    }\n+\n+    public Schema getSchema(DBIdentifier name) {\n+        if (_schemaMap == null)\n+            return null;\n+        DBIdentifier sName = DBIdentifier.toUpper(name);\n+        Schema schema = (Schema) _schemaMap.get(sName);\n         return schema;\n-//        return (Schema) _schemaMap.get(name);\n     }\n \n     /**\n      * Add a schema to the group.\n      */\n     public Schema addSchema() {\n-        return addSchema(null);\n+        return addSchema(DBIdentifier.NULL);\n     }\n \n     /**\n      * Add a schema to the group.\n      */\n-    public Schema addSchema(String name) {\n+    public Schema addSchema(DBIdentifier name) {\n         addName(name, false);\n         Schema schema = newSchema(name);\n-        if (name != null)\n-            name = name.toUpperCase();\n+        DBIdentifier sName = DBIdentifier.toUpper(name);\n         if (_schemaMap == null)\n-            _schemaMap = new HashMap();\n-        _schemaMap.put(name, schema);\n+            _schemaMap = new HashMap<DBIdentifier, Schema>();\n+        _schemaMap.put(sName, schema);\n         _schemas = null;\n         return schema;\n     }\n-    \n-    // TODO: temp until a more global solution is implemented\n-    public void addDelimSchemaName(String name, Schema schema) {\n-        addName(name,false);\n-        if (name != null)\n-            name = name.toUpperCase();\n-        if (_delimSchemaMap == null) {\n-            _delimSchemaMap = new HashMap<String, Schema>();\n-        }\n-        _delimSchemaMap.put(name, schema);\n-    }\n \n+    /**\n+     * @deprecated\n+     * @param name\n+     * @return\n+     */\n+    public Schema addSchema(String name) {\n+        return addSchema(DBIdentifier.newSchema(name));\n+    }\n+    \n     /**\n      * Remove the given schema from the group.\n      *\n@@ -107,13 +108,11 @@ public boolean removeSchema(Schema schema) {\n         if (schema == null)\n             return false;\n \n-        String name = schema.getName();\n-        if (name != null)\n-            name = name.toUpperCase();\n+        DBIdentifier name = DBIdentifier.toUpper(schema.getIdentifier());\n         Schema rem = (Schema) _schemaMap.get(name);\n         if (schema.equals(rem)) {\n             _schemaMap.remove(name);\n-            removeName(schema.getName());\n+            removeName(schema.getIdentifier());\n             _schemas = null;\n             schema.remove();\n             return true;\n@@ -128,7 +127,7 @@ public Schema importSchema(Schema schema) {\n         if (schema == null)\n             return null;\n \n-        Schema copy = addSchema(schema.getName());\n+        Schema copy = addSchema(schema.getIdentifier());\n         Sequence[] seqs = schema.getSequences();\n         for (int i = 0; i < seqs.length; i++)\n             copy.importSequence(seqs[i]);\n@@ -164,39 +163,50 @@ public boolean isKnownTable(Table table) {\n      * {@link #findTable} may exhibit dynamic behavior in some schema group\n      * implementations, this method only returns true if the table has been\n      * added to this group or is known to exist in the database.\n+     * @deprecated\n      */\n     public boolean isKnownTable(String name) {\n         return findTable(name) != null;\n     }\n \n+      public boolean isKnownTable(QualifiedDBIdentifier path) {\n+          return findTable(path) != null;\n+      }\n+    \n     /**\n      * Find the equivalent of the given table in this schema group. The\n      * given table that may have come from another schema group.\n      */\n     public Table findTable(Table table) {\n-        return findTable(table.getFullName());\n+        return findTable(table.getQualifiedPath());\n     }\n \n     /**\n      * Find the table with the given name in the group, using '.' as the\n      * catalog separator. Returns null if no table found.\n+     * @deprecated\n      */\n     public Table findTable(String name) {\n         if (name == null)\n             return null;\n \n-        int dotIdx = name.indexOf('.');\n-        if (dotIdx != -1) {\n-            String schemaName = name.substring(0, dotIdx);\n-            name = name.substring(dotIdx + 1);\n-            Schema schema = getSchema(schemaName);\n+        return findTable(QualifiedDBIdentifier.getPath(DBIdentifier.newTable(name)));\n+    }\n+\n+    public Table findTable(QualifiedDBIdentifier path) {\n+        if (DBIdentifier.isNull(path)) {\n+            return null;\n+        }\n+        if (!DBIdentifier.isNull(path.getSchemaName())) {\n+            Schema schema = getSchema(path.getSchemaName());\n             if (schema != null)\n-                return schema.getTable(name);\n+                return schema.getTable(path.getUnqualifiedName());\n+            \n         } else {\n             Schema[] schemas = getSchemas();\n             Table tab;\n             for (int i = 0; i < schemas.length; i++) {\n-                tab = schemas[i].getTable(name);\n+                tab = schemas[i].getTable(path.getIdentifier());\n                 if (tab != null)\n                     return tab;\n             }\n@@ -207,30 +217,38 @@ public Table findTable(String name) {\n     /**\n      * Find the table with the given name in the group, using '.' as the catalog\n      * separator. Returns null if no table found.\n+     * @deprecated\n      */\n     public Table findTable(Schema inSchema, String name) {\n-        return findTable(inSchema, name, null);\n+        if (name == null)\n+            return null;\n+        return findTable(inSchema, DBIdentifier.newTable(name), DBIdentifier.NULL);\n+    }\n+\n+    public Table findTable(Schema inSchema, DBIdentifier name) {\n+        if (DBIdentifier.isNull(name))\n+            return null;\n+        return findTable(inSchema, QualifiedDBIdentifier.getPath(name), DBIdentifier.NULL);\n+    }\n+\n+    public Table findTable(Schema inSchema, DBIdentifier name, DBIdentifier defaultSchemaName) {\n+        if (DBIdentifier.isNull(name))\n+            return null;\n+        return findTable(inSchema, QualifiedDBIdentifier.getPath(name), defaultSchemaName);\n     }\n     \n-    /**\n-     * Find the table with the given name in the group, using '.' as the catalog\n-     * separator. Returns null if no table found.\n-     */\n-    public Table findTable(Schema inSchema, String name, String defaultSchemaName) {\n-        if (name == null)\n+    public Table findTable(Schema inSchema, QualifiedDBIdentifier path, DBIdentifier defaultSchemaName) {\n+        if (path == null)\n             return null;\n \n-        int dotIdx = name.indexOf('.');\n-        if (dotIdx != -1) {\n-            String schemaName = name.substring(0, dotIdx);\n-            name = name.substring(dotIdx + 1);\n-            Schema schema = getSchema(schemaName);\n+        if (!DBIdentifier.isNull(path.getSchemaName())) {\n+            Schema schema = getSchema(path.getSchemaName());\n             if (schema != null)\n-                return schema.getTable(name);\n+                return schema.getTable(path.getIdentifier());\n         } else {\n             Schema[] schemas = getSchemas();\n             for (int i = 0; i < schemas.length; i++) {\n-                Table tab = schemas[i].getTable(name);\n+                Table tab = schemas[i].getTable(path.getIdentifier());\n                 // if a table is found and it has the same schema\n                 // as the input schema , it means that the table\n                 // exists. However, if the input schema is null,\n@@ -239,11 +257,11 @@ public Table findTable(Schema inSchema, String name, String defaultSchemaName) {\n                 // We can't handle the case that one entity has schema name\n                 // and other entity does not have schema name but both entities\n                 // map to the same table.\n-                boolean isDefaultSchema = inSchema.getName() == null && \n-                    defaultSchemaName != null && \n-                    defaultSchemaName.equalsIgnoreCase(schemas[i].getName());\n-                boolean hasNoDefaultSchema = inSchema.getName() == null && \n-                    defaultSchemaName == null; \n+                boolean isDefaultSchema = DBIdentifier.isNull(inSchema.getIdentifier()) && \n+                    !DBIdentifier.isNull(defaultSchemaName) && \n+                    DBIdentifier.equalsIgnoreCase(defaultSchemaName, schemas[i].getIdentifier());\n+                boolean hasNoDefaultSchema = DBIdentifier.isNull(inSchema.getIdentifier()) && \n+                    DBIdentifier.isNull(defaultSchemaName); \n                 \n                 if (tab != null &&\n                     (schemas[i] == inSchema || isDefaultSchema || hasNoDefaultSchema)) \n@@ -269,39 +287,58 @@ public boolean isKnownSequence(Sequence seq) {\n      * {@link #findSequence} may exhibit dynamic behavior in some schema group\n      * implementations, this method only returns true if the sequence has been\n      * added to this group or is known to exist in the database.\n+     * @deprecated\n      */\n     public boolean isKnownSequence(String name) {\n         return findSequence(name) != null;\n     }\n \n+    public boolean isKnownSequence(DBIdentifier name) {\n+        return findSequence(QualifiedDBIdentifier.getPath(name)) != null;\n+    }\n+\n+    public boolean isKnownSequence(QualifiedDBIdentifier path) {\n+        return findSequence(path) != null;\n+    }\n+\n     /**\n      * Find the equivalent of the given sequence in this schema group. The\n      * given sequence that may have come from another schema group.\n      */\n     public Sequence findSequence(Sequence seq) {\n-        return findSequence(seq.getFullName());\n+        return findSequence(QualifiedDBIdentifier.getPath(seq.getIdentifier()));\n     }\n \n     /**\n      * Find the sequence with the given name in the group, using '.' as the\n      * catalog separator. Returns null if no sequence found.\n+     * @deprecated\n      */\n     public Sequence findSequence(String name) {\n         if (name == null)\n             return null;\n+        return findSequence(DBIdentifier.newSequence(name));\n+    }\n \n-        int dotIdx = name.indexOf('.');\n-        if (dotIdx != -1) {\n-            String schemaName = name.substring(0, dotIdx);\n-            name = name.substring(dotIdx + 1);\n-            Schema schema = getSchema(schemaName);\n+    public Sequence findSequence(DBIdentifier name) {\n+        if (DBIdentifier.isNull(name))\n+            return null;\n+        return findSequence(QualifiedDBIdentifier.getPath(name));\n+    }\n+\n+    public Sequence findSequence(QualifiedDBIdentifier path) {\n+        if (path == null)\n+            return null;\n+\n+        if (!DBIdentifier.isNull(path.getSchemaName())) {\n+            Schema schema = getSchema(path.getSchemaName());\n             if (schema != null)\n-                return schema.getSequence(name);\n+                return schema.getSequence(path.getIdentifier());\n         } else {\n             Schema[] schemas = getSchemas();\n             Sequence seq;\n             for (int i = 0; i < schemas.length; i++) {\n-                seq = schemas[i].getSequence(name);\n+                seq = schemas[i].getSequence(path.getIdentifier());\n                 if (seq != null)\n                     return seq;\n             }\n@@ -312,28 +349,32 @@ public Sequence findSequence(String name) {\n     /**\n      * Find the sequence with the given name in the group, using '.' as the\n      * catalog separator. Returns null if no sequence found.\n+     * @deprecated\n      */\n     public Sequence findSequence(Schema inSchema, String name) {\n         if (name == null)\n             return null;\n+        return findSequence(inSchema, QualifiedDBIdentifier.getPath(DBIdentifier.newSequence(name)));\n+    }\n+\n+    \n+    public Sequence findSequence(Schema inSchema, QualifiedDBIdentifier path) {\n+        if (path == null)\n+            return null;\n \n-        int dotIdx = name.indexOf('.');\n-        if (dotIdx != -1) {\n-            String schemaName = name.substring(0, dotIdx);\n-            name = name.substring(dotIdx + 1);\n-            Schema schema = getSchema(schemaName);\n+        if (!DBIdentifier.isNull(path.getSchemaName())) {\n+            Schema schema = getSchema(path.getSchemaName());\n             if (schema != null)\n-                return schema.getSequence(name);\n+                return schema.getSequence(path.getIdentifier());\n         } else {\n             Schema[] schemas = getSchemas();\n             Sequence seq;\n             for (int i = 0; i < schemas.length; i++) {\n-                seq = schemas[i].getSequence(name);\n+                seq = schemas[i].getSequence(path.getIdentifier());\n                 if ((seq != null) &&\n-                        (schemas[i] == inSchema || inSchema.getName() == null))\n+                        (schemas[i] == inSchema || DBIdentifier.isNull(inSchema.getIdentifier())))\n                     return seq;\n             }\n-\n         }\n         return null;\n     }\n@@ -349,7 +390,7 @@ public Sequence findSequence(Schema inSchema, String name) {\n         Schema[] schemas = getSchemas();\n         Table[] tabs;\n         ForeignKey[] fks;\n-        Collection exports = new LinkedList();\n+        Collection<ForeignKey> exports = new LinkedList<ForeignKey>();\n         for (int i = 0; i < schemas.length; i++) {\n             tabs = schemas[i].getTables();\n             for (int j = 0; j < tabs.length; j++) {\n@@ -436,65 +477,106 @@ protected void copy(SchemaGroup group) {\n             for (int j = 0; j < tabs.length; j++) {\n                 fks = tabs[j].getForeignKeys();\n                 for (int k = 0; k < fks.length; k++)\n-                    getSchema(schemas[i].getName()).getTable\n-                        (tabs[j].getName()).importForeignKey(fks[k]);\n+                    getSchema(schemas[i].getIdentifier()).getTable\n+                        (tabs[j].getIdentifier()).importForeignKey(fks[k]);\n             }\n         }\n     }\n \n     /**\n      * Return a new schema with the given name.\n+     * @deprecated\n      */\n     protected Schema newSchema(String name) {\n         return new Schema(name, this);\n     }\n \n+    protected Schema newSchema(DBIdentifier name) {\n+        return new Schema(name, this);\n+    }\n+\n     /**\n      * Return a new sequence with the given name and owner schema.\n+     * @deprecated\n      */\n     protected Sequence newSequence(String name, Schema schema) {\n         return new Sequence(name, schema);\n     }\n \n+    protected Sequence newSequence(DBIdentifier name, Schema schema) {\n+        return new Sequence(name, schema);\n+    }\n+\n     /**\n      * Return a new table with the given name and owner schema.\n+     * @deprecated\n      */\n     protected Table newTable(String name, Schema schema) {\n         return new Table(name, schema);\n     }\n \n+    protected Table newTable(DBIdentifier name, Schema schema) {\n+        return new Table(name, schema);\n+    }\n+\n     /**\n      * Return a new column with the given name and owner table.\n+     * @deprecated\n      */\n     protected Column newColumn(String name, Table table) {\n         return new Column(name, table);\n     }\n \n+    protected Column newColumn(DBIdentifier name, Table table) {\n+        return new Column(name, table);\n+    }\n+\n     /**\n      * Return a new primary key with the given name and owner table.\n+     * @deprecated\n      */\n     protected PrimaryKey newPrimaryKey(String name, Table table) {\n         return new PrimaryKey(name, table);\n     }\n \n+    protected PrimaryKey newPrimaryKey(DBIdentifier name, Table table) {\n+        return new PrimaryKey(name, table);\n+    }\n+\n     /**\n      * Return a new index with the given name and owner table.\n+     * @deprecated\n      */\n     protected Index newIndex(String name, Table table) {\n         return new Index(name, table);\n     }\n \n+    protected Index newIndex(DBIdentifier name, Table table) {\n+        return new Index(name, table);\n+    }\n+\n     /**\n      * Return a new unique constraint with the given name and owner table.\n+     * @deprecated\n      */\n     protected Unique newUnique(String name, Table table) {\n         return new Unique(name, table);\n     }\n \n+    protected Unique newUnique(DBIdentifier name, Table table) {\n+        return new Unique(name, table);\n+    }\n+\n     /**\n      * Return a new foreign key with the given name and owner table.\n+     * @deprecated\n      */\n     protected ForeignKey newForeignKey(String name, Table table) {\n         return new ForeignKey(name, table);\n     }\n+\n+    protected ForeignKey newForeignKey(DBIdentifier name, Table table) {\n+        return new ForeignKey(name, table);\n+    }\n+\n }"},{"sha":"8c90933dcca85282f268dc0483aa0071e9ca1ada","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java","status":"modified","additions":44,"deletions":47,"changes":91,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/SchemaTool.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -39,10 +39,13 @@\n import org.apache.openjpa.conf.OpenJPAConfiguration;\n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.SQLExceptions;\n import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.meta.MetaDataSerializer;\n import org.apache.openjpa.lib.util.Files;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.lib.util.Options;\n@@ -416,7 +419,7 @@ private void deleteTableContents()\n         throws SQLException {\n         SchemaGroup group = getSchemaGroup();\n         Schema[] schemas = group.getSchemas();\n-        Collection tables = new LinkedHashSet();\n+        Collection<Table> tables = new LinkedHashSet<Table>();\n         for (int i = 0; i < schemas.length; i++) {\n             Table[] ts = schemas[i].getTables();\n             for (int j = 0; j < ts.length; j++)\n@@ -451,14 +454,14 @@ private void add(SchemaGroup db, SchemaGroup repos)\n             for (int i = 0; i < schemas.length; i++) {\n                 seqs = schemas[i].getSequences();\n                 for (int j = 0; j < seqs.length; j++) {\n-                    if (db.findSequence(schemas[i], seqs[j].getFullName()) !=\n+                    if (db.findSequence(schemas[i], seqs[j].getQualifiedPath()) !=\n                             null)\n                         continue;\n \n                     if (createSequence(seqs[j])) {\n-                        schema = db.getSchema(seqs[j].getSchemaName());\n+                        schema = db.getSchema(seqs[j].getSchemaIdentifier());\n                         if (schema == null)\n-                            schema = db.addSchema(seqs[j].getSchemaName());\n+                            schema = db.addSchema(seqs[j].getSchemaIdentifier());\n                         schema.importSequence(seqs[j]);\n                     } else\n                         _log.warn(_loc.get(\"add-seq\", seqs[j]));\n@@ -471,31 +474,23 @@ private void add(SchemaGroup db, SchemaGroup repos)\n         Table dbTable;\n         Column[] cols;\n         Column col;\n-        String delim = _dict.getDelimiter();\n-        String defaultSchemaName = _dict.getDefaultSchemaName();\n+        DBIdentifier defaultSchemaName = DBIdentifier.newSchema(_dict.getDefaultSchemaName());\n         for (int i = 0; i < schemas.length; i++) {\n             tabs = schemas[i].getTables();\n             for (int j = 0; j < tabs.length; j++) {\n                 cols = tabs[j].getColumns();\n-                dbTable = db.findTable(schemas[i], tabs[j].getFullName(), defaultSchemaName);\n+                dbTable = db.findTable(schemas[i], tabs[j].getQualifiedPath(), defaultSchemaName);\n                 for (int k = 0; k < cols.length; k++) {\n                     if (dbTable != null) {\n-                        String colName = cols[k].getName();\n-                        boolean delimCol = false;\n-                        if (colName.startsWith(delim) \n-                                && colName.endsWith(delim)) {\n-                            colName = colName.substring(1, colName.length()-1);\n-                            delimCol = true;\n-                        }\n-                        col = dbTable.getColumn(colName, _dict);\n+                        DBIdentifier colName = cols[k].getIdentifier();\n+                        col = dbTable.getColumn(colName);\n                         if (col == null) {\n                             if (addColumn(cols[k]))\n                                 dbTable.importColumn(cols[k]);\n                             else\n                                 _log.warn(_loc.get(\"add-col\", cols[k],\n                                     tabs[j]));\n-                        // TODO: Find a way to compare these with delimCol\n-                        } else if (!delimCol && !cols[k].equalsColumn(col)) {\n+                        } else if (!cols[k].equalsColumn(col)) {\n                             _log.warn(_loc.get(\"bad-col\", new Object[]{\n                                 col, dbTable, col.getDescription(),\n                                 cols[k].getDescription() }));\n@@ -512,7 +507,7 @@ private void add(SchemaGroup db, SchemaGroup repos)\n                 tabs = schemas[i].getTables();\n                 for (int j = 0; j < tabs.length; j++) {\n                     pk = tabs[j].getPrimaryKey();\n-                    dbTable = db.findTable(schemas[i], tabs[j].getFullName());\n+                    dbTable = db.findTable(schemas[i], tabs[j].getQualifiedPath());\n                     if (pk != null && !pk.isLogical() && dbTable != null) {\n                         if (dbTable.getPrimaryKey() == null\n                             && addPrimaryKey(pk))\n@@ -528,18 +523,18 @@ else if (!pk.equalsPrimaryKey(dbTable.getPrimaryKey()))\n         }\n \n         // tables\n-        Set newTables = new HashSet();\n+        Set<Table> newTables = new HashSet<Table>();\n         for (int i = 0; i < schemas.length; i++) {\n             tabs = schemas[i].getTables();\n             for (int j = 0; j < tabs.length; j++) {\n-                if (db.findTable(schemas[i], tabs[j].getFullName()) != null)\n+                if (db.findTable(schemas[i], tabs[j].getQualifiedPath()) != null)\n                     continue;\n \n                 if (createTable(tabs[j])) {\n                     newTables.add(tabs[j]);\n-                    schema = db.getSchema(tabs[j].getSchemaName());\n+                    schema = db.getSchema(tabs[j].getSchemaIdentifier());\n                     if (schema == null)\n-                        schema = db.addSchema(tabs[j].getSchemaName());\n+                        schema = db.addSchema(tabs[j].getSchemaIdentifier());\n                     schema.importTable(tabs[j]);\n                 } else\n                     _log.warn(_loc.get(\"add-table\", tabs[j]));\n@@ -558,7 +553,7 @@ else if (!pk.equalsPrimaryKey(dbTable.getPrimaryKey()))\n                     continue;\n \n                 idxs = tabs[j].getIndexes();\n-                dbTable = db.findTable(schemas[i], tabs[j].getFullName());\n+                dbTable = db.findTable(schemas[i], tabs[j].getQualifiedPath());\n                 for (int k = 0; k < idxs.length; k++) {\n                     if (dbTable != null) {\n                         idx = findIndex(dbTable, idxs[k]);\n@@ -608,7 +603,7 @@ else if (!pk.equalsPrimaryKey(dbTable.getPrimaryKey()))\n                     continue;\n \n                 fks = tabs[j].getForeignKeys();\n-                dbTable = db.findTable(schemas[i],tabs[j].getFullName());\n+                dbTable = db.findTable(schemas[i],tabs[j].getQualifiedPath());\n                 for (int k = 0; k < fks.length; k++) {\n                     if (!fks[k].isLogical() && dbTable != null) {\n                         fk = findForeignKey(dbTable, fks[k]);\n@@ -715,7 +710,7 @@ private void retain(SchemaGroup db, SchemaGroup repos, boolean tables,\n         // columns\n         Column[] cols;\n         Column col;\n-        Collection drops = new LinkedList();\n+        Collection<Table> drops = new LinkedList<Table>();\n         for (int i = 0; i < schemas.length; i++) {\n             tabs = schemas[i].getTables();\n             for (int j = 0; j < tabs.length; j++) {\n@@ -725,7 +720,7 @@ private void retain(SchemaGroup db, SchemaGroup repos, boolean tables,\n                 reposTable = repos.findTable(tabs[j]);\n                 if (reposTable != null) {\n                     for (int k = 0; k < cols.length; k++) {\n-                        col = reposTable.getColumn(cols[k].getName(), _dict);\n+                        col = reposTable.getColumn(cols[k].getIdentifier());\n                         if (col == null || !cols[k].equalsColumn(col)) {\n                             if (tabs[j].getColumns().length == 1)\n                                 drops.add(tabs[j]);\n@@ -782,7 +777,7 @@ private void drop(SchemaGroup db, SchemaGroup repos)\n         // calculate tables to drop; we can only drop tables if we're sure\n         // the user listed the entire table definition in the stuff they want\n         // dropped; else they might just want to drop a few columns\n-        Collection drops = new LinkedList();\n+        Collection<Table> drops = new LinkedList<Table>();\n         Table[] tabs;\n         Table dbTable;\n         Column[] dbCols;\n@@ -798,7 +793,7 @@ private void drop(SchemaGroup db, SchemaGroup repos)\n \n                 dbCols = dbTable.getColumns();\n                 for (int k = 0; k < dbCols.length; k++)\n-                    if (tabs[j].getColumn(dbCols[k].getName(), _dict) == null)\n+                    if (tabs[j].getColumn(dbCols[k].getIdentifier()) == null)\n                         continue tables;\n \n                 drops.add(tabs[j]);\n@@ -838,8 +833,8 @@ private void drop(SchemaGroup db, SchemaGroup repos)\n \n             // also drop imported foreign keys for tables that will be dropped\n             Table tab;\n-            for (Iterator itr = drops.iterator(); itr.hasNext();) {\n-                tab = (Table) itr.next();\n+            for (Iterator<Table> itr = drops.iterator(); itr.hasNext();) {\n+                tab = itr.next();\n                 dbTable = db.findTable(tab);\n                 if (dbTable == null)\n                     continue;\n@@ -870,7 +865,7 @@ private void drop(SchemaGroup db, SchemaGroup repos)\n                 for (int k = 0; k < cols.length; k++) {\n                     col = null;\n                     if (dbTable != null)\n-                        col = dbTable.getColumn(cols[k].getName(), _dict);\n+                        col = dbTable.getColumn(cols[k].getIdentifier());\n                     if (dbTable == null || col == null)\n                         continue;\n \n@@ -890,17 +885,17 @@ private void drop(SchemaGroup db, SchemaGroup repos)\n      */\n     private boolean isDroppable(Table table) {\n         return _openjpaTables\n-            || (!table.getName().toUpperCase().startsWith(\"OPENJPA_\")\n-            && !table.getName().toUpperCase().startsWith(\"JDO_\")); // legacy\n+            || (!DBIdentifier.toUpper(table.getIdentifier()).getName().startsWith(\"OPENJPA_\")\n+            && !DBIdentifier.toUpper(table.getIdentifier()).getName().startsWith(\"JDO_\")); // legacy\n     }\n \n     /**\n      * Return true if the sequence is droppable.\n      */\n     private boolean isDroppable(Sequence seq) {\n         return _openjpaTables\n-            || (!seq.getName().toUpperCase().startsWith(\"OPENJPA_\")\n-            && !seq.getName().toUpperCase().startsWith(\"JDO_\")); // legacy\n+            || (!DBIdentifier.toUpper(seq.getIdentifier()).getName().startsWith(\"OPENJPA_\")\n+            && !DBIdentifier.toUpper(seq.getIdentifier()).getName().startsWith(\"JDO_\")); // legacy\n     }\n \n     /**\n@@ -933,15 +928,15 @@ private ForeignKey findForeignKey(Table dbTable, ForeignKey fk) {\n      * Remove the given collection of tables from the database schema. Orders\n      * the removals according to foreign key constraints on the tables.\n      */\n-    private void dropTables(Collection tables, SchemaGroup change)\n+    private void dropTables(Collection<Table> tables, SchemaGroup change)\n         throws SQLException {\n         if (tables.isEmpty())\n             return;\n \n         Table table;\n         Table changeTable;\n-        for (Iterator itr = tables.iterator(); itr.hasNext();) {\n-            table = (Table) itr.next();\n+        for (Iterator<Table> itr = tables.iterator(); itr.hasNext();) {\n+            table = itr.next();\n             if (dropTable(table)) {\n                 changeTable = change.findTable(table);\n                 if (changeTable != null)\n@@ -1128,22 +1123,24 @@ private SchemaGroup getDBSchemaGroup(boolean full)\n                 // group; some may not exist yet, which is OK; we just need\n                 // to make sure we can detect the changes to the ones that\n                 // do exist\n-                Collection tables = new LinkedList();\n+                Collection<DBIdentifier> tables = new LinkedList<DBIdentifier>();\n                 SchemaGroup group = assertSchemaGroup();\n                 Schema[] schemas = group.getSchemas();\n                 Table[] tabs;\n                 for (int i = 0; i < schemas.length; i++) {\n                     tabs = schemas[i].getTables();\n                     for (int j = 0; j < tabs.length; j++) {\n-                        if (tabs[j].getSchemaName() == null)\n-                            tables.add(\".\" + tabs[j].getName());\n-                        else\n-                            tables.add(tabs[j].getFullName());\n+                        if (DBIdentifier.isNull(tabs[j].getSchemaIdentifier())) {\n+                            tables.add(tabs[j].getIdentifier());\n+                        } else {\n+                            DBIdentifier sName = tabs[j].getFullIdentifier();\n+                            tables.add(sName);\n+                        }\n                     }\n                 }\n                 if (!tables.isEmpty())\n-                    gen.generateSchemas((String[]) tables.toArray\n-                        (new String[tables.size()]));\n+                    gen.generateSchemas((DBIdentifier[]) tables.toArray\n+                        (new DBIdentifier[tables.size()]));\n             }\n             _db = gen.getSchemaGroup();\n         }\n@@ -1448,7 +1445,7 @@ public static boolean run(JDBCConfiguration conf, String[] args,\n             log.info(_loc.get(\"sch-reflect-write\"));\n             SchemaSerializer ser = new XMLSchemaSerializer(conf);\n             ser.addAll(gen.getSchemaGroup());\n-            ser.serialize(flags.writer, ser.PRETTY);\n+            ser.serialize(flags.writer, MetaDataSerializer.PRETTY);\n             return true;\n         }\n \n@@ -1486,7 +1483,7 @@ public static boolean run(JDBCConfiguration conf, String[] args,\n             log.info(_loc.get(\"tool-export-write\"));\n             SchemaSerializer ser = new XMLSchemaSerializer(conf);\n             ser.addAll(schema);\n-            ser.serialize(flags.writer, ser.PRETTY);\n+            ser.serialize(flags.writer, MetaDataSerializer.PRETTY);\n             return true;\n         }\n "},{"sha":"21b0614dea90ade7b165feb860526897b56225a6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schemas.java","status":"modified","additions":16,"deletions":9,"changes":25,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schemas.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schemas.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Schemas.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -21,7 +21,10 @@\n import java.sql.Types;\n import java.util.Date;\n \n+import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.identifier.Normalizer;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n \n /**\n  * Helper class to deal with schemas.\n@@ -40,20 +43,24 @@\n     /**\n      * Return the schema name that should be used for new tables, or null if\n      * none.\n+     * @deprecated\n      */\n     public static String getNewTableSchema(JDBCConfiguration conf) {\n+        return getNewTableSchemaIdentifier(conf).getName();\n+    }\n+\n+    public static DBIdentifier getNewTableSchemaIdentifier(JDBCConfiguration conf) {\n         if (conf.getSchema() != null)\n-            return conf.getSchema();\n+            return DBIdentifier.newSchema(conf.getSchema());\n \n         String[] schemas = conf.getSchemasList();\n         if (schemas.length == 0)\n-            return null;\n-        int dotIdx = schemas[0].lastIndexOf('.');\n-        if (dotIdx == 0)\n-            return null;\n-        if (dotIdx == -1)\n-            return schemas[0];\n-        return schemas[0].substring(0, dotIdx);\n+            return DBIdentifier.NULL;\n+        String[] names = Normalizer.splitName(schemas[0]);\n+        if (names.length == 0 || StringUtils.isEmpty(names[0])) {\n+            return DBIdentifier.NULL;\n+        }\n+        return DBIdentifier.newSchema(names[0]);\n     }\n \n     /**\n@@ -190,7 +197,7 @@ public static int getJDBCType(String name) {\n     /**\n      * Return the java type for the given SQL type from {@link Types}.\n      */\n-    public static Class getJavaType(int type, int size, int decimals) {\n+    public static Class<?> getJavaType(int type, int size, int decimals) {\n         switch (type) {\n             case Types.CHAR:\n                 if (size == 1)"},{"sha":"8d89b02855f87cfd5f9cdeba2b9fd72495925c55","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Sequence.java","status":"modified","additions":63,"deletions":27,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Sequence.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Sequence.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Sequence.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -20,27 +20,32 @@\n \n import java.io.File;\n \n+import org.apache.openjpa.jdbc.identifier.Normalizer;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.QualifiedDBIdentifier;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n import org.apache.openjpa.lib.meta.SourceTracker;\n \n /**\n  * Represents a database sequence.\n  *\n  * @author Abe White\n  */\n+@SuppressWarnings(\"serial\")\n public class Sequence\n     extends ReferenceCounter\n-    implements Comparable, SourceTracker {\n+    implements Comparable<Sequence>, SourceTracker {\n \n-    private String _name = null;\n-    private String _fullName = null;\n+    private DBIdentifier _name = DBIdentifier.NULL;\n     private Schema _schema = null;\n-    private String _schemaName = null;\n+    private DBIdentifier _schemaName = DBIdentifier.NULL;\n     private int _initial = 1;\n     private int _increment = 1;\n     private int _cache = 0;\n     private int _lineNum = 0;  \n     private int _colNum = 0;  \n-\n+    private QualifiedDBIdentifier _fullPath = null;\n+    \n     // keep track of source\n     private File _source = null;\n     private int _srcType = SRC_OTHER;\n@@ -56,11 +61,16 @@ public Sequence() {\n      *\n      * @param name the sequence name\n      * @param schema the sequence schema\n+     * @deprecated\n      */\n     public Sequence(String name, Schema schema) {\n-        setName(name);\n+        this(DBIdentifier.newSequence(name), schema);\n+    }\n+\n+    public Sequence(DBIdentifier name, Schema schema) {\n+        setIdentifier(name);\n         if (schema != null)\n-            setSchemaName(schema.getName());\n+            setSchemaIdentifier(schema.getIdentifier());\n         _schema = schema;\n     }\n \n@@ -69,7 +79,7 @@ public Sequence(String name, Schema schema) {\n      */\n     void remove() {\n         _schema = null;\n-        _fullName = null;\n+        _fullPath = null;\n     }\n \n     /**\n@@ -83,51 +93,75 @@ public Schema getSchema() {\n      * The sequence's schema name.\n      */\n     public String getSchemaName() {\n-        return _schemaName;\n+        return getSchemaIdentifier().getName();\n+    }\n+    \n+    public DBIdentifier getSchemaIdentifier() {\n+        return _schemaName == null ? DBIdentifier.NULL : _schemaName;\n     }\n \n     /**\n      * The sequence's schema name. You can only call this method on sequences\n      * whose schema object is not set.\n+     * @deprecated\n      */\n     public void setSchemaName(String name) {\n+        setSchemaIdentifier(DBIdentifier.newSchema(name));\n+    }\n+\n+    public void setSchemaIdentifier(DBIdentifier name) {\n         if (getSchema() != null)\n             throw new IllegalStateException();\n         _schemaName = name;\n-        _fullName = null;\n+        _fullPath = null;\n     }\n \n     /**\n      * Return the name of the sequence.\n+     * @deprecated\n      */\n     public String getName() {\n-        return _name;\n+        return getIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getIdentifier() {\n+        return _name == null ? DBIdentifier.NULL : _name;\n     }\n \n     /**\n      * Set the name of the sequence. This method can only be called on\n      * sequences that are not part of a schema.\n+     * @deprecated\n      */\n     public void setName(String name) {\n+        setIdentifier(DBIdentifier.newSequence(name));\n+    }\n+\n+    public void setIdentifier(DBIdentifier name) {\n         if (getSchema() != null)\n             throw new IllegalStateException();\n         _name = name;\n-        _fullName = null;\n+        _fullPath = null;\n     }\n \n     /**\n      * Return the sequence name, including schema, using '.' as the\n      * catalog separator.\n+     * @deprecated\n      */\n     public String getFullName() {\n-        if (_fullName == null) {\n-            Schema schema = getSchema();\n-            if (schema == null || schema.getName() == null)\n-                _fullName = getName();\n-            else\n-                _fullName = schema.getName() + \".\" + getName();\n+        return getFullIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getFullIdentifier() {\n+        return getQualifiedPath().getIdentifier();\n+    }\n+\n+    public QualifiedDBIdentifier getQualifiedPath() {\n+        if (_fullPath  == null) {\n+            _fullPath = QualifiedDBIdentifier.newPath(_schemaName, _name );\n         }\n-        return _fullName;\n+        return _fullPath;\n     }\n \n     /**\n@@ -190,23 +224,24 @@ public void setSource(File source, int srcType) {\n     }\n \n     public String getResourceName() {\n-        return getFullName();\n+        return getFullIdentifier().getName();\n     }\n \n-    public int compareTo(Object other) {\n-        String name = getFullName();\n-        String otherName = ((Sequence) other).getFullName();\n-        if (name == null && otherName == null)\n+    public int compareTo(Sequence other) {\n+        DBIdentifier name = getIdentifier();\n+        DBIdentifier otherName = other.getIdentifier();\n+        if (DBIdentifier.isNull(name) && DBIdentifier.isNull(otherName)) {\n             return 0;\n-        if (name == null)\n+        }\n+        if (DBIdentifier.isNull(name))\n             return 1;\n-        if (otherName == null)\n+        if (DBIdentifier.isNull(otherName))\n             return -1;\n         return name.compareTo(otherName);\n     }\n \n     public String toString() {\n-        return getFullName();\n+        return getFullIdentifier().getName();\n     }\n     \n     public int getLineNumber() {\n@@ -224,4 +259,5 @@ public int getColNumber() {\n     public void setColNumber(int colNum) {\n         _colNum = colNum;\n     }\n+\n }"},{"sha":"ecf913d9b881400c7d05384322d87b645bfec4e0","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java","status":"modified","additions":201,"deletions":117,"changes":318,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Table.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -26,8 +26,13 @@\n import java.util.TreeMap;\n import java.util.LinkedHashMap;\n \n-import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.identifier.Normalizer;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifierUtilImpl;\n+import org.apache.openjpa.jdbc.identifier.QualifiedDBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n import org.apache.openjpa.lib.meta.SourceTracker;\n \n /**\n@@ -36,16 +41,17 @@\n  * @author Abe White\n  * @author Stephen Kim\n  */\n+@SuppressWarnings(\"serial\")\n public class Table\n     extends NameSet\n-    implements Comparable, SourceTracker {\n-\n-    private String _name = null;\n-    private String _schemaName = null;\n-    private Map _colMap = null;\n-    private Map _idxMap = null;\n-    private Collection _fkList = null;\n-    private Collection _unqList = null;\n+    implements Comparable<Object>, SourceTracker {\n+\n+    private DBIdentifier _name = DBIdentifier.NULL;\n+    private DBIdentifier _schemaName = DBIdentifier.NULL;\n+    private Map<DBIdentifier, Column> _colMap = null;\n+    private Map<DBIdentifier, Index> _idxMap = null;\n+    private Collection<ForeignKey> _fkList = null;\n+    private Collection<Unique> _unqList = null;\n     private Schema _schema = null;\n     private PrimaryKey _pk = null;\n \n@@ -54,7 +60,6 @@\n     private int _srcType = SRC_OTHER;\n \n     // cache\n-    private String _fullName = null;\n     private Column[] _cols = null;\n     private Column[] _autoAssign = null;\n     private Column[] _rels = null;\n@@ -65,6 +70,7 @@\n     private int _lineNum = 0;  \n     private int _colNum = 0;\n     private boolean _isAssociation = false;\n+    private QualifiedDBIdentifier _fullPath = null;\n \n     /**\n      * Default constructor.\n@@ -77,12 +83,17 @@ public Table() {\n      *\n      * @param name the table name\n      * @param schema the table schema\n+     * @deprecated\n      */\n     public Table(String name, Schema schema) {\n-        setName(name);\n+        this(DBIdentifier.newTable(name), schema);\n+    }\n+\n+    public Table(DBIdentifier name, Schema schema) {\n+        setIdentifier(name);\n         addName(name, true);\n         if (schema != null)\n-            setSchemaName(schema.getName());\n+            setSchemaIdentifier(schema.getIdentifier());\n         _schema = schema;\n     }\n \n@@ -113,8 +124,8 @@ void remove() {\n         for (int i = 0; i < cols.length; i++)\n             removeColumn(cols[i]);\n         _schema = null;\n-        _schemaName = null;\n-        _fullName = null;\n+        _schemaName = DBIdentifier.NULL;\n+        _fullPath = null;\n     }\n \n     /**\n@@ -126,53 +137,78 @@ public Schema getSchema() {\n \n     /**\n      * The table's schema name.\n+     * @deprecated\n      */\n     public String getSchemaName() {\n-        return _schemaName;\n+        return getSchemaIdentifier().getName();\n+    }\n+\n+    public DBIdentifier getSchemaIdentifier() {\n+        return _schemaName == null ? DBIdentifier.NULL : _schemaName;\n     }\n \n     /**\n      * The table's schema name. You can only call this method on tables\n      * whose schema object is not set.\n+     * @deprecated\n      */\n     public void setSchemaName(String name) {\n+        setSchemaIdentifier(DBIdentifier.newSchema(name));\n+    }\n+\n+    public void setSchemaIdentifier(DBIdentifier name) {\n         if (getSchema() != null)\n             throw new IllegalStateException();\n         _schemaName = name;\n-        _fullName = null;\n+        _fullPath = null;\n     }\n \n     /**\n      * Return the name of the table.\n+     * @deprecated\n      */\n     public String getName() {\n-        return _name;\n+        return getIdentifier().getName();\n+    }\n+    \n+    public DBIdentifier getIdentifier() {\n+        return _name == null ? DBIdentifier.NULL : _name;\n     }\n \n     /**\n      * Set the name of the table. This method can only be called on tables\n      * that are not part of a schema.\n+     * @deprecated\n      */\n     public void setName(String name) {\n+        setIdentifier(DBIdentifier.newTable(name));\n+    }\n+\n+    public void setIdentifier(DBIdentifier name) {\n         if (getSchema() != null)\n             throw new IllegalStateException();\n         _name = name;\n-        _fullName = null;\n+        _fullPath = null;\n     }\n \n     /**\n      * Return the table name, including schema, using '.' as the\n      * catalog separator.\n+     * @deprecated\n      */\n     public String getFullName() {\n-        if (_fullName == null) {\n-            Schema schema = getSchema();\n-            if (schema == null || schema.getName() == null)\n-                _fullName = getName();\n-            else\n-                _fullName = schema.getName() + \".\" + getName();\n+        return getFullIdentifier().getName();\n+    }\n+    \n+    public QualifiedDBIdentifier getQualifiedPath() {\n+        if (_fullPath  == null) {\n+            _fullPath = QualifiedDBIdentifier.newPath(_schemaName, _name );\n         }\n-        return _fullName;\n+        return _fullPath;\n+    }\n+    \n+    public DBIdentifier getFullIdentifier() {\n+        return getQualifiedPath().getIdentifier();\n     }\n \n     public File getSourceFile() {\n@@ -193,7 +229,7 @@ public void setSource(File source, int srcType) {\n     }\n \n     public String getResourceName() {\n-        return getFullName();\n+        return getFullIdentifier().getName();\n     }\n \n     /**\n@@ -205,7 +241,7 @@ public String getResourceName() {\n                 _cols = Schemas.EMPTY_COLUMNS;\n             else {\n                 Column[] cols = new Column[_colMap.size()];\n-                Iterator itr = _colMap.values().iterator();\n+                Iterator<Column> itr = _colMap.values().iterator();\n                 for (int i = 0; itr.hasNext(); i++) {\n                     cols[i] = (Column) itr.next();\n                     cols[i].setIndex(i);\n@@ -224,12 +260,12 @@ public String getResourceName() {\n             if (_colMap == null)\n                 _autoAssign = Schemas.EMPTY_COLUMNS;\n             else {\n-                Collection autos = null;\n+                Collection<Column> autos = null;\n                 Column[] cols = getColumns();\n                 for (int i = 0; i < cols.length; i++) {\n                     if (cols[i].isAutoAssigned()) {\n                         if (autos == null)\n-                            autos = new ArrayList(3);\n+                            autos = new ArrayList<Column>(3);\n                         autos.add(cols[i]);\n                     }\n                 }\n@@ -248,12 +284,12 @@ public String getResourceName() {\n             if (_colMap == null)\n                 _rels = Schemas.EMPTY_COLUMNS;\n             else {\n-                Collection rels = null;\n+                Collection<Column> rels = null;\n                 Column[] cols = getColumns();\n                 for (int i = 0; i < cols.length; i++) {\n                     if (cols[i].isRelationId()) {\n                         if (rels == null)\n-                            rels = new ArrayList(3);\n+                            rels = new ArrayList<Column>(3);\n                         rels.add(cols[i]);\n                     }\n                 }\n@@ -265,47 +301,40 @@ public String getResourceName() {\n     }\n \n     public String[] getColumnNames() {\n-        return _colMap == null ? new String[0] : \n-            (String[])_colMap.keySet().toArray(new String[_colMap.size()]);\n+        if (_colMap == null) {\n+            return new String[0];\n+        }\n+        DBIdentifier[] sNames = (DBIdentifier[])_colMap.keySet().toArray(new DBIdentifier[_colMap.size()]); \n+        return DBIdentifier.toStringArray(sNames);\n     }\n     \n     /**\n      * Return the column with the given name, or null if none.\n+     * @deprecated\n      */\n     public Column getColumn(String name) {\n-        return getColumn(name, null);\n+        return getColumn(DBIdentifier.newIdentifier(name, DBIdentifierType.COLUMN, true));\n     }\n \n-    /**\n-     * Return the column with the given name, or null if none.\n-     * @param dict the current database dictionary or null.\n-     */\n-    public Column getColumn(String name, DBDictionary dict) {\n-        if (name == null || _colMap == null)\n+    public Column getColumn(DBIdentifier name) {\n+        if (DBIdentifier.isNull(name) || _colMap == null)\n             return null;\n-        Column col = (Column)_colMap.get(name.toUpperCase());\n-        if (col == null) {\n-            String delim = null;\n-            if (dict != null) {\n-                delim = dict.getDelimiter();\n-            }\n-            else {\n-                delim = \"\\\"\";\n-            }\n-            String delimName = delim + name + delim;\n-            col = (Column) _colMap.get(delimName.toUpperCase());\n-        }\n-        \n-        return col;\n+        return _colMap.get(DBIdentifier.toUpper(name));\n     }\n+\n     \n     /**\n      * Affirms if this table contains the column of the given name without any \n      * side-effect. \n      * @see Table#getColumn(String) can have side-effect of creating a column\n      * for dynamic table implementation.\n+     * @deprecated\n      */\n     public boolean containsColumn(String name) {\n+        return containsColumn(DBIdentifier.newColumn(name), null);\n+    }\n+    \n+    public boolean containsColumn(DBIdentifier name) {\n         return containsColumn(name, null);\n     }\n \n@@ -315,53 +344,58 @@ public boolean containsColumn(String name) {\n      * @param dict the current database dictionary or null.\n      * @see Table#getColumn(String) can have side-effect of creating a column\n      * for dynamic table implementation.\n+     * @deprecated\n      */\n     public boolean containsColumn(String name, DBDictionary dict) {\n         if (name == null || _colMap == null) {\n             return false;\n         }\n-        if (_colMap.containsKey(name.toUpperCase())) {\n-            return true;\n-        }\n-        \n-        String delim = null;\n-        if (dict != null) {\n-            delim = dict.getDelimiter();\n-        }\n-        else {\n-            delim = \"\\\"\";\n-        }\n-        String delimName = delim + name + delim;\n-        if (_colMap.containsKey(delimName.toUpperCase())) {\n-            return true;\n+        return containsColumn(DBIdentifier.newIdentifier(name, DBIdentifierType.COLUMN, true));\n+    }\n+\n+    public boolean containsColumn(DBIdentifier name, DBDictionary dict) {\n+        if (DBIdentifier.isNull(name) || _colMap == null) {\n+            return false;\n         }\n-        \n-        return false;\n+        DBIdentifier sName = DBIdentifier.toUpper(name);\n+        return _colMap.containsKey(sName);\n     }\n \n     /**\n      * Add a column to the table.\n+     * @deprecated\n      */\n     public Column addColumn(String name) {\n+        return addColumn(DBIdentifier.newColumn(name));\n+    }\n+\n+    public Column addColumn(DBIdentifier name) {\n         addName(name, true);\n         Schema schema = getSchema();\n         Column col;\n-        if (schema != null && schema.getSchemaGroup() != null)\n+        if (schema != null && schema.getSchemaGroup() != null) {\n             col = schema.getSchemaGroup().newColumn(name, this);\n-        else\n+        } else {\n             col = new Column(name, this);\n+        }\n         if (_colMap == null)\n-            _colMap = new LinkedHashMap();\n-        _colMap.put(name.toUpperCase(), col);\n+            _colMap = new LinkedHashMap<DBIdentifier, Column>();\n+        DBIdentifier sName = DBIdentifier.toUpper(name);\n+        _colMap.put(sName, col);\n         _cols = null;\n         return col;\n     }\n \n \n     /**\n-     * Add a colum with a shortened (i.e., validated) name to the table\n+     * Add a column with a shortened (i.e., validated) name to the table\n+     * @deprecated\n      */\n     public Column addColumn(String name, String validName) {\n+        return addColumn(DBIdentifier.newColumn(name), DBIdentifier.newColumn(validName));\n+    }\n+\n+    public Column addColumn(DBIdentifier name, DBIdentifier validName) {\n         addName(name, true);\n         Schema schema = getSchema();\n         Column col;\n@@ -370,16 +404,22 @@ public Column addColumn(String name, String validName) {\n         else\n             col = new Column(validName, this);\n         if (_colMap == null)\n-            _colMap = new LinkedHashMap();\n-        _colMap.put(name.toUpperCase(), col);\n+            _colMap = new LinkedHashMap<DBIdentifier, Column>();\n+        DBIdentifier sName = DBIdentifier.toUpper(name);\n+        _colMap.put(sName, col);\n         _cols = null;\n         return col;\n     }\n \n     /**\n      * Add a name to this NameSet\n+     * @deprecated\n      */\n     public void addCorrectedColumnName(String name, boolean validate) {\n+        addName(DBIdentifier.newColumn(name), validate);\n+    }\n+\n+    public void addCorrectedColumnName(DBIdentifier name, boolean validate) {\n         addName(name, validate);\n     }\n \n@@ -393,12 +433,13 @@ public boolean removeColumn(Column col) {\n         if (col == null || _colMap == null)\n             return false;\n \n-        Column cur = (Column) _colMap.get(col.getName().toUpperCase());\n+        DBIdentifier sName = DBIdentifier.toUpper(col.getIdentifier());\n+        Column cur = (Column) _colMap.get(sName);\n         if (!col.equals(cur))\n             return false;\n \n-        removeName(col.getName());\n-        _colMap.remove(col.getName().toUpperCase());\n+        removeName(sName);\n+        _colMap.remove(sName);\n         _cols = null;\n         if (col.isAutoAssigned())\n             _autoAssign = null;\n@@ -415,9 +456,9 @@ public Column importColumn(Column col) {\n         if (col == null)\n             return null;\n \n-        Column copy = addColumn(col.getName());\n+        Column copy = addColumn(col.getIdentifier());\n         copy.setType(col.getType());\n-        copy.setTypeName(col.getTypeName());\n+        copy.setTypeIdentifier(col.getTypeIdentifier());\n         copy.setJavaType(col.getJavaType());\n         copy.setNotNull(col.isNotNull());\n         copy.setDefaultString(col.getDefaultString());\n@@ -438,13 +479,18 @@ public PrimaryKey getPrimaryKey() {\n      * Set the primary key for the table.\n      */\n     public PrimaryKey addPrimaryKey() {\n-        return addPrimaryKey(null);\n+        return addPrimaryKey(DBIdentifier.NULL);\n     }\n \n     /**\n      * Set the primary key for the table.\n+     * @deprecated\n      */\n     public PrimaryKey addPrimaryKey(String name) {\n+        return addPrimaryKey(DBIdentifier.newConstraint(name));\n+    }\n+\n+    public PrimaryKey addPrimaryKey(DBIdentifier name) {\n         Schema schema = getSchema();\n         if (schema != null && schema.getSchemaGroup() != null) {\n             schema.getSchemaGroup().addName(name, false);\n@@ -464,7 +510,7 @@ public boolean removePrimaryKey() {\n         if (rem) {\n             Schema schema = getSchema();\n             if (schema != null && schema.getSchemaGroup() != null)\n-                schema.getSchemaGroup().removeName(_pk.getName());\n+                schema.getSchemaGroup().removeName(_pk.getIdentifier());\n             _pk.remove();\n         }\n         _pk = null;\n@@ -478,23 +524,30 @@ public PrimaryKey importPrimaryKey(PrimaryKey pk) {\n         if (pk == null)\n             return null;\n \n-        PrimaryKey copy = addPrimaryKey(pk.getName());\n+        PrimaryKey copy = addPrimaryKey(pk.getIdentifier());\n         copy.setLogical(pk.isLogical());\n         Column[] cols = pk.getColumns();\n         for (int i = 0; i < cols.length; i++)\n-            copy.addColumn(getColumn(cols[i].getName()));\n+            copy.addColumn(getColumn(cols[i].getIdentifier()));\n         return copy;\n     }\n \n     /**\n      * Return the foreign key with the given name. If multiple foreign keys\n      * have the name, the first match is returned.\n+     * @deprecated\n      */\n     public ForeignKey getForeignKey(String name) {\n+        return getForeignKey(DBIdentifier.newForeignKey(name));\n+    }\n+\n+    public ForeignKey getForeignKey(DBIdentifier name) {\n         ForeignKey[] fks = getForeignKeys();\n-        for (int i = 0; i < fks.length; i++)\n-            if (StringUtils.equalsIgnoreCase(name, fks[i].getName()))\n+        for (int i = 0; i < fks.length; i++) {\n+            if (name.equals(fks[i].getIdentifier())) {\n                 return fks[i];\n+            }\n+        }\n         return null;\n     }\n \n@@ -507,7 +560,7 @@ public ForeignKey getForeignKey(String name) {\n                 _fks = Schemas.EMPTY_FOREIGN_KEYS;\n             else {\n                 ForeignKey[] fks = new ForeignKey[_fkList.size()];\n-                Iterator itr = _fkList.iterator();\n+                Iterator<ForeignKey> itr = _fkList.iterator();\n                 for (int i = 0; itr.hasNext(); i++) {\n                     fks[i] = (ForeignKey) itr.next();\n                     fks[i].setIndex(i);\n@@ -522,13 +575,18 @@ public ForeignKey getForeignKey(String name) {\n      * Add a foreign key to the table.\n      */\n     public ForeignKey addForeignKey() {\n-        return addForeignKey(null);\n+        return addForeignKey(DBIdentifier.NULL);\n     }\n \n     /**\n      * Add a foreign key to the table. Duplicate key names are not allowed.\n+     * @deprecated\n      */\n     public ForeignKey addForeignKey(String name) {\n+        return addForeignKey(DBIdentifier.newForeignKey(name));\n+    }\n+\n+    public ForeignKey addForeignKey(DBIdentifier name) {\n         Schema schema = getSchema();\n         ForeignKey fk;\n         if (schema != null && schema.getSchemaGroup() != null) {\n@@ -537,7 +595,7 @@ public ForeignKey addForeignKey(String name) {\n         } else\n             fk = new ForeignKey(name, this);\n         if (_fkList == null)\n-            _fkList = new ArrayList(3);\n+            _fkList = new ArrayList<ForeignKey>(3);\n         _fkList.add(fk);\n         _fks = null;\n         return fk;\n@@ -557,7 +615,7 @@ public boolean removeForeignKey(ForeignKey fk) {\n \n         Schema schema = getSchema();\n         if (schema != null && schema.getSchemaGroup() != null)\n-            schema.getSchemaGroup().removeName(fk.getName());\n+            schema.getSchemaGroup().removeName(fk.getIdentifier());\n         _fks = null;\n         fk.remove();\n         return true;\n@@ -570,7 +628,7 @@ public ForeignKey importForeignKey(ForeignKey fk) {\n         if (fk == null)\n             return null;\n \n-        ForeignKey copy = addForeignKey(fk.getName());\n+        ForeignKey copy = addForeignKey(fk.getIdentifier());\n         copy.setDeleteAction(fk.getDeleteAction());\n \n         Schema schema = getSchema();\n@@ -582,20 +640,20 @@ public ForeignKey importForeignKey(ForeignKey fk) {\n \n             Column[] cols = fk.getColumns();\n             for (int i = 0; i < cols.length; i++)\n-                copy.join(getColumn(cols[i].getName()),\n-                    joined.getColumn(pks[i].getName()));\n+                copy.join(getColumn(cols[i].getIdentifier()),\n+                    joined.getColumn(pks[i].getIdentifier()));\n \n             cols = fk.getConstantColumns();\n             for (int i = 0; i < cols.length; i++)\n-                copy.joinConstant(getColumn(cols[i].getName()),\n+                copy.joinConstant(getColumn(cols[i].getIdentifier()),\n                     fk.getPrimaryKeyConstant(cols[i]));\n \n             pks = fk.getConstantPrimaryKeyColumns();\n             if (joined == null && pks.length > 0)\n                 joined = schema.getSchemaGroup().findTable(pks[0].getTable());\n             for (int i = 0; i < pks.length; i++)\n                 copy.joinConstant(fk.getConstant(pks[i]),\n-                    joined.getColumn(pks[i].getName()));\n+                    joined.getColumn(pks[i].getIdentifier()));\n         }\n         return copy;\n     }\n@@ -612,17 +670,31 @@ public ForeignKey importForeignKey(ForeignKey fk) {\n \n     /**\n      * Return the index with the given name, or null if none.\n+     * @deprecated\n      */\n     public Index getIndex(String name) {\n         if (name == null || _idxMap == null)\n             return null;\n-        return (Index) _idxMap.get(name.toUpperCase());\n+        return getIndex(DBIdentifier.newIdentifier(name, DBIdentifierType.INDEX, true));\n+    }\n+\n+    public Index getIndex(DBIdentifier name) {\n+        if (name == null || _idxMap == null)\n+            return null;\n+        \n+        DBIdentifier sName = DBIdentifier.toUpper(name);\n+        return (Index) _idxMap.get(sName);\n     }\n \n     /**\n      * Add an index to the table.\n+     * @deprecated\n      */\n     public Index addIndex(String name) {\n+        return addIndex(DBIdentifier.newIndex(name));\n+    }\n+\n+    public Index addIndex(DBIdentifier name) {\n         Schema schema = getSchema();\n         Index idx;\n         if (schema != null && schema.getSchemaGroup() != null) {\n@@ -631,8 +703,9 @@ public Index addIndex(String name) {\n         } else\n             idx = new Index(name, this);\n         if (_idxMap == null)\n-            _idxMap = new TreeMap();\n-        _idxMap.put(name.toUpperCase(), idx);\n+            _idxMap = new TreeMap<DBIdentifier, Index>();\n+        DBIdentifier sName = DBIdentifier.toUpper(name);\n+        _idxMap.put(sName, idx);\n         _idxs = null;\n         return idx;\n     }\n@@ -646,14 +719,15 @@ public boolean removeIndex(Index idx) {\n         if (idx == null || _idxMap == null)\n             return false;\n \n-        Index cur = (Index) _idxMap.get(idx.getName().toUpperCase());\n+        DBIdentifier sName = DBIdentifier.toUpper(idx.getIdentifier());\n+        Index cur = (Index) _idxMap.get(sName);\n         if (!idx.equals(cur))\n             return false;\n \n-        _idxMap.remove(idx.getName().toUpperCase());\n+        _idxMap.remove(sName);\n         Schema schema = getSchema();\n         if (schema != null && schema.getSchemaGroup() != null)\n-            schema.getSchemaGroup().removeName(idx.getName());\n+            schema.getSchemaGroup().removeName(idx.getIdentifier());\n         idx.remove();\n         _idxs = null;\n         return true;\n@@ -666,12 +740,12 @@ public Index importIndex(Index idx) {\n         if (idx == null)\n             return null;\n \n-        Index copy = addIndex(idx.getName());\n+        Index copy = addIndex(idx.getIdentifier());\n         copy.setUnique(idx.isUnique());\n \n         Column[] cols = idx.getColumns();\n         for (int i = 0; i < cols.length; i++)\n-            copy.addColumn(getColumn(cols[i].getName()));\n+            copy.addColumn(getColumn(cols[i].getIdentifier()));\n         return copy;\n     }\n \n@@ -687,19 +761,29 @@ public Index importIndex(Index idx) {\n \n     /**\n      * Return the unique constraint with the given name, or null if none.\n+     * @deprecated\n      */\n     public Unique getUnique(String name) {\n+        return getUnique(DBIdentifier.newConstraint(name));\n+    }\n+\n+    public Unique getUnique(DBIdentifier name) {\n         Unique[] unqs = getUniques();\n         for (int i = 0; i < unqs.length; i++)\n-            if (StringUtils.equalsIgnoreCase(name, unqs[i].getName()))\n+            if (DBIdentifier.equal(name, unqs[i].getIdentifier()))\n                 return unqs[i];\n         return null;\n     }\n \n     /**\n      * Add a unique constraint to the table.\n+     * @deprecated\n      */\n     public Unique addUnique(String name) {\n+        return addUnique(DBIdentifier.newConstraint(name));\n+    }\n+\n+    public Unique addUnique(DBIdentifier name) {\n         Schema schema = getSchema();\n         Unique unq;\n         if (schema != null && schema.getSchemaGroup() != null) {\n@@ -708,7 +792,7 @@ public Unique addUnique(String name) {\n         } else\n             unq = new Unique(name, this);\n         if (_unqList == null)\n-            _unqList = new ArrayList(3);\n+            _unqList = new ArrayList<Unique>(3);\n         _unqList.add(unq);\n         _unqs = null;\n         return unq;\n@@ -728,7 +812,7 @@ public boolean removeUnique(Unique unq) {\n \n         Schema schema = getSchema();\n         if (schema != null && schema.getSchemaGroup() != null)\n-            schema.getSchemaGroup().removeName(unq.getName());\n+            schema.getSchemaGroup().removeName(unq.getIdentifier());\n         _unqs = null;\n         unq.remove();\n         return true;\n@@ -741,12 +825,12 @@ public Unique importUnique(Unique unq) {\n         if (unq == null)\n             return null;\n \n-        Unique copy = addUnique(unq.getName());\n+        Unique copy = addUnique(unq.getIdentifier());\n         copy.setDeferred(unq.isDeferred());\n \n         Column[] cols = unq.getColumns();\n         for (int i = 0; i < cols.length; i++)\n-            copy.addColumn(getColumn(cols[i].getName()));\n+            copy.addColumn(getColumn(cols[i].getIdentifier()));\n         return copy;\n     }\n \n@@ -781,23 +865,23 @@ void changeRelationId(Column col) {\n     }\n \n     public int compareTo(Object other) {\n-        String name = getFullName();\n-        String otherName = ((Table) other).getFullName();\n-        if (name == null && otherName == null)\n+        DBIdentifier name = getFullIdentifier();\n+        DBIdentifier otherName = ((Table) other).getFullIdentifier();\n+        if (DBIdentifier.isNull(name) && DBIdentifier.isNull(otherName))\n             return 0;\n-        if (name == null)\n+        if (DBIdentifier.isNull(name))\n             return 1;\n-        if (otherName == null)\n+        if (DBIdentifier.isNull(otherName))\n             return -1;\n         return name.compareTo(otherName);\n     }\n \n     public String toString() {\n-        return getFullName();\n+        return getFullIdentifier().getName();\n     }\n \n     public boolean hasComment() {\n-        return _comment != null && !_comment.equalsIgnoreCase(_name);\n+        return _comment != null && !_comment.equalsIgnoreCase(_name.getName());\n     }\n \n     public String getComment() {"},{"sha":"182a47d19fc5e962a57ae8716f89cbbeb59f3bba","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/TableSchemaFactory.java","status":"modified","additions":27,"deletions":20,"changes":47,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/TableSchemaFactory.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/TableSchemaFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/TableSchemaFactory.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -30,13 +30,17 @@\n \n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n import org.apache.openjpa.jdbc.conf.JDBCConfigurationImpl;\n+import org.apache.openjpa.jdbc.identifier.Normalizer;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.QualifiedDBIdentifier;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.jdbc.sql.SQLBuffer;\n import org.apache.openjpa.jdbc.sql.SQLExceptions;\n import org.apache.openjpa.lib.conf.Configurable;\n import org.apache.openjpa.lib.conf.Configuration;\n import org.apache.openjpa.lib.conf.Configurations;\n import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.meta.MetaDataSerializer;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.lib.util.Options;\n import org.apache.openjpa.meta.JavaTypes;\n@@ -62,9 +66,9 @@\n \n     private JDBCConfiguration _conf = null;\n     private Log _log = null;\n-    private String _table = \"OPENJPA_SCHEMA\";\n-    private String _pkColumnName = \"ID\";\n-    private String _schemaColumnName = \"SCHEMA_DEF\";\n+    private DBIdentifier _table = DBIdentifier.newTable(\"OPENJPA_SCHEMA\");\n+    private DBIdentifier _pkColumnName = DBIdentifier.newColumn(\"ID\");\n+    private DBIdentifier _schemaColumnName = DBIdentifier.newColumn(\"SCHEMA_DEF\");\n     private Column _pkColumn = null;\n     private Column _schemaColumn = null;\n \n@@ -73,15 +77,15 @@\n      * <code>OPENJPA_SCHEMA</code>.\n      */\n     public String getTable() {\n-        return _table;\n+        return _table.getName();\n     }\n \n     /**\n      * The name of the schema definition table. Defaults to\n      * <code>OPENJPA_SCHEMA</code>.\n      */\n     public void setTable(String name) {\n-        _table = name;\n+        _table = DBIdentifier.newTable(name);\n     }\n \n     /**\n@@ -97,31 +101,31 @@ public void setTableName(String name) {\n      * Defaults to <code>ID</code>.\n      */\n     public void setPrimaryKeyColumn(String name) {\n-        _pkColumnName = name;\n+        _pkColumnName = DBIdentifier.newColumn(name);\n     }\n \n     /**\n      * The name of the primary key column on the schema definition table.\n      * Defaults to <code>ID</code>.\n      */\n     public String getPrimaryKeyColumn() {\n-        return _pkColumnName;\n+        return _pkColumnName.getName();\n     }\n \n     /**\n      * The name of the schema column on the schema definition table.\n      * Defaults to <code>SCHEMA_DEF</code>.\n      */\n     public void setSchemaColumn(String name) {\n-        _schemaColumnName = name;\n+        _schemaColumnName = DBIdentifier.newColumn(name);\n     }\n \n     /**\n      * The name of the schema column on the schema definition table.\n      * Defaults to <code>SCHEMA_DEF</code>.\n      */\n     public String getSchemaColumn() {\n-        return _schemaColumnName;\n+        return _schemaColumnName.getName();\n     }\n \n     public JDBCConfiguration getConfiguration() {\n@@ -139,7 +143,7 @@ public void startConfiguration() {\n     public void endConfiguration() {\n         buildTable();\n     }\n-\n+    \n     public synchronized SchemaGroup readSchema() {\n         String schema = null;\n         try {\n@@ -154,7 +158,7 @@ public synchronized SchemaGroup readSchema() {\n         XMLSchemaParser parser = new XMLSchemaParser(_conf);\n         try {\n             parser.parse(new StringReader(schema),\n-                _schemaColumn.getFullName());\n+                _schemaColumn.getQualifiedPath().toString());\n         } catch (IOException ioe) {\n             throw new GeneralException(ioe);\n         }\n@@ -166,7 +170,7 @@ public void storeSchema(SchemaGroup schema) {\n         ser.addAll(schema);\n         Writer writer = new StringWriter();\n         try {\n-            ser.serialize(writer, ser.COMPACT);\n+            ser.serialize(writer, MetaDataSerializer.COMPACT);\n         } catch (IOException ioe) {\n             throw new GeneralException(ioe);\n         }\n@@ -232,7 +236,8 @@ public void refreshTable()\n             DBDictionary dict = _conf.getDBDictionaryInstance();\n             stmnt = conn.prepareStatement(\"INSERT INTO \"\n                 + dict.getFullName(_pkColumn.getTable(), false)\n-                + \" (\" + _pkColumn + \", \" + _schemaColumn + \") VALUES (?, ?)\");\n+                + \" (\" + dict.getColumnDBName(_pkColumn) + \", \" + \n+                dict.getColumnDBName(_schemaColumn) + \") VALUES (?, ?)\");\n             dict.setInt(stmnt, 1, 1, _pkColumn);\n             dict.setNull(stmnt, 2, _schemaColumn.getType(), _schemaColumn);\n             dict.setTimeouts(stmnt, _conf, true);\n@@ -328,11 +333,12 @@ public void writeSchemaColumn(String schema)\n         String update;\n         if (embedded)\n             update = \"UPDATE \" + dict.getFullName(_pkColumn.getTable(), false)\n-                + \" SET \" + _schemaColumn + \" = ?  WHERE \" + _pkColumn + \" = ?\";\n+                + \" SET \" + dict.getColumnDBName(_schemaColumn) + \" = ?  WHERE \" +\n+                dict.getColumnIdentifier(_pkColumn) + \" = ?\";\n         else\n-            update = \"SELECT \" + _schemaColumn + \" FROM \"\n+            update = \"SELECT \" + dict.getColumnDBName(_schemaColumn) + \" FROM \"\n                 + dict.getFullName(_pkColumn.getTable(), false)\n-                + \" WHERE \" + _pkColumn + \" = ?\";\n+                + \" WHERE \" + dict.getColumnDBName(_pkColumn) + \" = ?\";\n \n         Connection conn = getConnection();\n         PreparedStatement stmnt = null;\n@@ -392,10 +398,11 @@ else if (_schemaColumn.getType() == Types.CLOB)\n      * Creates the object-level representation of the sequence table.\n      */\n     private void buildTable() {\n-        String tableName = Strings.getClassName(_table);\n-        String schemaName = Strings.getPackageName(_table);\n-        if (schemaName.length() == 0)\n-            schemaName = Schemas.getNewTableSchema(_conf);\n+        QualifiedDBIdentifier path = QualifiedDBIdentifier.getPath(_table);\n+        DBIdentifier tableName = path.getIdentifier();\n+        DBIdentifier schemaName = path.getSchemaName();\n+        if (DBIdentifier.isEmpty(schemaName))\n+            schemaName = Schemas.getNewTableSchemaIdentifier(_conf);\n \n         // build the table in one of the designated schemas\n         SchemaGroup group = new SchemaGroup();"},{"sha":"c3c6319ae0cf93db67b848a1c118bf5e72d0fae5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Unique.java","status":"modified","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Unique.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Unique.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/Unique.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -18,12 +18,15 @@\n  */\n package org.apache.openjpa.jdbc.schema;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+\n /**\n  * Represents a unique constraint. It can also represent a partial constraint.\n  *\n  * @author Abe White\n  * @author Pinaki Poddar\n  */\n+@SuppressWarnings(\"serial\")\n public class Unique\n     extends LocalConstraint {\n \t\n@@ -36,11 +39,16 @@ public Unique() {\n      * \n      * @param name the name of the constraint, if any\n      * @param table the table of the constraint\n+     * @deprecated\n      */\n     public Unique(String name, Table table) {\n         super(name, table);\n     }\n \n+    public Unique(DBIdentifier name, Table table) {\n+        super(name, table);\n+    }\n+\n     public boolean isLogical() {\n         return false;\n     }\n@@ -59,10 +67,15 @@ public void addColumn(Column col) {\n     /**\n      * Set the name of the constraint. This method cannot be called if the\n      * constraint already belongs to a table. \n+     * @deprecated\n      */\n     public void setName(String name) {\n         super.setName(name);\n     }\n+\n+    public void setIdentifier(DBIdentifier name) {\n+        super.setIdentifier(name);\n+    }\n     \n     /**\n      * Return true if the structure of this primary key matches that of"},{"sha":"664f8c516dee739892c48827792b18057728cee3","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaParser.java","status":"modified","additions":42,"deletions":41,"changes":83,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaParser.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaParser.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -30,6 +30,7 @@\n import org.xml.sax.SAXException;\n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.lib.meta.SourceTracker;\n import org.apache.openjpa.lib.meta.XMLMetaDataParser;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.lib.util.Localizer.Message;\n@@ -115,10 +116,10 @@\n     private boolean _delay = false;\n \n     // used to collect info on schema elements before they're resolved\n-    private final Collection _pkInfos = new LinkedList();\n-    private final Collection _indexInfos = new LinkedList();\n-    private final Collection _unqInfos = new LinkedList();\n-    private final Collection _fkInfos = new LinkedList();\n+    private final Collection<PrimaryKeyInfo> _pkInfos = new LinkedList<PrimaryKeyInfo>();\n+    private final Collection<IndexInfo> _indexInfos = new LinkedList<IndexInfo>();\n+    private final Collection<UniqueInfo> _unqInfos = new LinkedList<UniqueInfo>();\n+    private final Collection<ForeignKeyInfo> _fkInfos = new LinkedList<ForeignKeyInfo>();\n \n     /**\n      * Constructor. Supply configuration.\n@@ -185,11 +186,11 @@ private void resolvePrimaryKeys() {\n         PrimaryKeyInfo pkInfo;\n         String colName;\n         Column col;\n-        for (Iterator itr = _pkInfos.iterator(); itr.hasNext();) {\n-            pkInfo = (PrimaryKeyInfo) itr.next();\n-            for (Iterator cols = pkInfo.cols.iterator(); cols.hasNext();) {\n-                colName = (String) cols.next();\n-                col = pkInfo.pk.getTable().getColumn(colName, _dict);\n+        for (Iterator<PrimaryKeyInfo> itr = _pkInfos.iterator(); itr.hasNext();) {\n+            pkInfo = itr.next();\n+            for (Iterator<String> cols = pkInfo.cols.iterator(); cols.hasNext();) {\n+                colName = cols.next();\n+                col = pkInfo.pk.getTable().getColumn(colName);\n                 if (col == null)\n                     throwUserException(_loc.get(\"pk-resolve\", new Object[]\n                         { colName, pkInfo.pk.getTable() }));\n@@ -206,11 +207,11 @@ private void resolveIndexes() {\n         IndexInfo indexInfo;\n         String colName;\n         Column col;\n-        for (Iterator itr = _indexInfos.iterator(); itr.hasNext();) {\n-            indexInfo = (IndexInfo) itr.next();\n-            for (Iterator cols = indexInfo.cols.iterator(); cols.hasNext();) {\n-                colName = (String) cols.next();\n-                col = indexInfo.index.getTable().getColumn(colName, _dict);\n+        for (Iterator<IndexInfo> itr = _indexInfos.iterator(); itr.hasNext();) {\n+            indexInfo = itr.next();\n+            for (Iterator<String> cols = indexInfo.cols.iterator(); cols.hasNext();) {\n+                colName = cols.next();\n+                col = indexInfo.index.getTable().getColumn(colName);\n                 if (col == null)\n                     throwUserException(_loc.get(\"index-resolve\", new Object[]\n                         { indexInfo.index, colName,\n@@ -232,10 +233,10 @@ private void resolveForeignKeys() {\n         Column pkCol;\n         String pkColName;\n         PrimaryKey pk;\n-        Iterator pks;\n-        Iterator cols;\n-        for (Iterator itr = _fkInfos.iterator(); itr.hasNext();) {\n-            fkInfo = (ForeignKeyInfo) itr.next();\n+        Iterator<String> pks;\n+        Iterator<String> cols;\n+        for (Iterator<ForeignKeyInfo> itr = _fkInfos.iterator(); itr.hasNext();) {\n+            fkInfo = itr.next();\n             toTable = _group.findTable(fkInfo.toTable);\n             if (toTable == null || toTable.getPrimaryKey() == null)\n                 throwUserException(_loc.get(\"fk-totable\", new Object[]\n@@ -250,13 +251,13 @@ private void resolveForeignKeys() {\n             pks = fkInfo.pks.iterator();\n             for (cols = fkInfo.cols.iterator(); cols.hasNext();) {\n                 colName = (String) cols.next();\n-                col = fkInfo.fk.getTable().getColumn(colName, _dict);\n+                col = fkInfo.fk.getTable().getColumn(colName);\n                 if (col == null)\n                     throwUserException(_loc.get(\"fk-nocol\",\n                         fkInfo.fk, colName, fkInfo.fk.getTable()));\n \n                 pkColName = (String) pks.next();\n-                pkCol = toTable.getColumn(pkColName, _dict);\n+                pkCol = toTable.getColumn(pkColName);\n                 if (pkCol == null)\n                     throwUserException(_loc.get(\"fk-nopkcol\", new Object[]\n                         { fkInfo.fk, pkColName, toTable,\n@@ -267,9 +268,9 @@ private void resolveForeignKeys() {\n \n             // make constant joins\n             cols = fkInfo.constCols.iterator();\n-            for (Iterator vals = fkInfo.consts.iterator(); vals.hasNext();) {\n-                colName = (String) cols.next();\n-                col = fkInfo.fk.getTable().getColumn(colName, _dict);\n+            for (Iterator<Object> vals = fkInfo.consts.iterator(); vals.hasNext();) {\n+                colName = cols.next();\n+                col = fkInfo.fk.getTable().getColumn(colName);\n                 if (col == null)\n                     throwUserException(_loc.get(\"fk-nocol\",\n                         fkInfo.fk, colName, fkInfo.fk.getTable()));\n@@ -278,9 +279,9 @@ private void resolveForeignKeys() {\n             }\n \n             pks = fkInfo.constColsPK.iterator();\n-            for (Iterator vals = fkInfo.constsPK.iterator(); vals.hasNext();) {\n-                pkColName = (String) pks.next();\n-                pkCol = toTable.getColumn(pkColName, _dict);\n+            for (Iterator<Object> vals = fkInfo.constsPK.iterator(); vals.hasNext();) {\n+                pkColName = pks.next();\n+                pkCol = toTable.getColumn(pkColName);\n                 if (pkCol == null)\n                     throwUserException(_loc.get(\"fk-nopkcol\", new Object[]\n                         { fkInfo.fk, pkColName, toTable,\n@@ -299,11 +300,11 @@ private void resolveUniques() {\n         UniqueInfo unqInfo;\n         String colName;\n         Column col;\n-        for (Iterator itr = _unqInfos.iterator(); itr.hasNext();) {\n-            unqInfo = (UniqueInfo) itr.next();\n-            for (Iterator cols = unqInfo.cols.iterator(); cols.hasNext();) {\n+        for (Iterator<UniqueInfo> itr = _unqInfos.iterator(); itr.hasNext();) {\n+            unqInfo = itr.next();\n+            for (Iterator<String> cols = unqInfo.cols.iterator(); cols.hasNext();) {\n                 colName = (String) cols.next();\n-                col = unqInfo.unq.getTable().getColumn(colName, _dict);\n+                col = unqInfo.unq.getTable().getColumn(colName);\n                 if (col == null)\n                     throwUserException(_loc.get(\"unq-resolve\", new Object[]\n                         { unqInfo.unq, colName, unqInfo.unq.getTable() }));\n@@ -412,7 +413,7 @@ private void startSequence(Attributes attrs) {\n             seq.setLineNumber(Numbers.valueOf(locator.getLineNumber()));\n             seq.setColNumber(Numbers.valueOf(locator.getColumnNumber()));\n         }\n-        seq.setSource(getSourceFile(), seq.SRC_XML);\n+        seq.setSource(getSourceFile(), SourceTracker.SRC_XML);\n         try {\n             String val = attrs.getValue(\"initial-value\");\n             if (val != null)\n@@ -430,7 +431,7 @@ private void startSequence(Attributes attrs) {\n \n     private void startTable(Attributes attrs) {\n         _table = _schema.addTable(attrs.getValue(\"name\"));\n-        _table.setSource(getSourceFile(), _table.SRC_XML);\n+        _table.setSource(getSourceFile(), SourceTracker.SRC_XML);\n         Locator locator = getLocation().getLocator();\n         if (locator != null) {\n             _table.setLineNumber(Numbers.valueOf(locator.getLineNumber()));\n@@ -580,7 +581,7 @@ private void throwUserException(Message msg) {\n     private static class PrimaryKeyInfo {\n \n         public PrimaryKey pk = null;\n-        public Collection cols = new LinkedList();\n+        public Collection<String> cols = new LinkedList<String>();\n     }\n \n     /**\n@@ -589,7 +590,7 @@ private void throwUserException(Message msg) {\n     private static class IndexInfo {\n \n         public Index index = null;\n-        public Collection cols = new LinkedList();\n+        public Collection<String> cols = new LinkedList<String>();\n     }\n \n     /**\n@@ -598,7 +599,7 @@ private void throwUserException(Message msg) {\n     public static class UniqueInfo {\n \n         public Unique unq = null;\n-        public Collection cols = new LinkedList();\n+        public Collection<String> cols = new LinkedList<String>();\n     }\n \n     /**\n@@ -608,11 +609,11 @@ private void throwUserException(Message msg) {\n \n         public ForeignKey fk = null;\n         public String toTable = null;\n-        public Collection cols = new LinkedList();\n-        public Collection pks = new LinkedList();\n-        public Collection consts = new LinkedList();\n-        public Collection constCols = new LinkedList();\n-        public Collection constsPK = new LinkedList();\n-        public Collection constColsPK = new LinkedList();\n+        public Collection<String> cols = new LinkedList<String>();\n+        public Collection<String> pks = new LinkedList<String>();\n+        public Collection<Object> consts = new LinkedList<Object>();\n+        public Collection<String> constCols = new LinkedList<String>();\n+        public Collection<Object> constsPK = new LinkedList<Object>();\n+        public Collection<String> constColsPK = new LinkedList<String>();\n     }\n }"},{"sha":"b45e9e75cc1b052c14b69f222e1002475c69834b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaSerializer.java","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaSerializer.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaSerializer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/schema/XMLSchemaSerializer.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -50,8 +50,8 @@\n     private static final Localizer _loc = Localizer.forPackage\n         (XMLSchemaSerializer.class);\n \n-    private final Collection _tables = new TreeSet();\n-    private final Collection _seqs = new TreeSet();\n+    private final Collection<Table> _tables = new TreeSet<Table>();\n+    private final Collection<Sequence> _seqs = new TreeSet<Sequence>();\n \n     /**\n      * Constructor. Supply configuration.\n@@ -140,7 +140,7 @@ protected Collection getObjects() {\n             return _tables;\n         if (_tables.isEmpty())\n             return _seqs;\n-        List all = new ArrayList(_seqs.size() + _tables.size());\n+        List<Object> all = new ArrayList<Object>(_seqs.size() + _tables.size());\n         all.addAll(_seqs);\n         all.addAll(_tables);\n         return all;\n@@ -180,7 +180,7 @@ protected void serialize(Collection objs)\n     /**\n      * Serializes the given objects together into the current schema.\n      */\n-    private void serializeSchema(String name, Collection objs)\n+    private void serializeSchema(String name, Collection<?> objs)\n         throws SAXException {\n         if (objs.isEmpty())\n             return;\n@@ -194,7 +194,7 @@ private void serializeSchema(String name, Collection objs)\n \n         // tables and seqs\n         Object obj;\n-        for (Iterator itr = objs.iterator(); itr.hasNext();) {\n+        for (Iterator<?> itr = objs.iterator(); itr.hasNext();) {\n             obj = itr.next();\n             if (obj instanceof Table)\n                 serializeTable((Table) obj);"},{"sha":"9652f5d2b318db22f612794b5200e962c145539c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractSQLServerDictionary.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractSQLServerDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractSQLServerDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractSQLServerDictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -25,6 +25,7 @@\n import java.sql.Types;\n import java.util.Arrays;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.Index;\n@@ -93,7 +94,8 @@ public AbstractSQLServerDictionary() {\n     }\n \n     public String getFullName(Index idx) {\n-        return getFullName(idx.getTable(), false) + \".\" + idx.getName();\n+        return toDBName(getNamingUtil().append(DBIdentifierType.INDEX,\n+            getFullIdentifier(idx.getTable(), false),idx.getIdentifier()));\n     }\n \n     public void setNull(PreparedStatement stmnt, int idx, int colType,"},{"sha":"06007022a55fd7d2f2a690aecb7297511d48cf47","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AccessDictionary.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AccessDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AccessDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AccessDictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -65,7 +65,11 @@ public AccessDictionary() {\n         maxIndexesPerTable = 32;\n \n         substringFunctionName = \"MID\";\n-    }\n+        \n+        setLeadingDelimiter(\"[\");\n+        setTrailingDelimiter(\"]\");\n+    }    \n+    \n \n     public void setLong(PreparedStatement stmnt, int idx, long val, Column col)\n         throws SQLException {"},{"sha":"dcf0f46632c6db5aa6c931d5a2df5874bbe65a43","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","status":"modified","additions":22,"deletions":8,"changes":30,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -29,10 +29,10 @@\n import java.sql.Statement;\n import java.sql.Types;\n import java.util.Arrays;\n-import java.util.EnumSet;\n import java.util.Set;\n import java.util.StringTokenizer;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n import org.apache.openjpa.jdbc.kernel.exps.Lit;\n@@ -230,17 +230,24 @@ protected void appendSelect(SQLBuffer selectSQL, Object alias, Select sel,\n         return sql;\n     }\n \n+    @Override\n     protected String getSequencesSQL(String schemaName, String sequenceName) {\n+        return getSequencesSQL(DBIdentifier.newSchema(schemaName), \n+            DBIdentifier.newSequence(sequenceName));\n+    }\n+\n+    @Override\n+    protected String getSequencesSQL(DBIdentifier schemaName, DBIdentifier sequenceName) {\n         StringBuilder buf = new StringBuilder();\n         buf.append(sequenceSQL);\n-        if (schemaName != null || sequenceName != null)\n+        if (!DBIdentifier.isNull(schemaName) || !DBIdentifier.isNull(sequenceName))\n             buf.append(\" WHERE \");\n-        if (schemaName != null) {\n+        if (!DBIdentifier.isNull(schemaName)) {\n             buf.append(sequenceSchemaSQL);\n-            if (sequenceName != null)\n+            if (!DBIdentifier.isNull(sequenceName))\n                 buf.append(\" AND \");\n         }\n-        if (sequenceName != null)\n+        if (!DBIdentifier.isNull(sequenceName))\n             buf.append(sequenceNameSQL);\n         return buf.toString();\n     }\n@@ -381,7 +388,7 @@ protected String getForUpdateClause(JDBCFetchConfiguration fetch,\n         int isolationLevel;\n         // For db2UDBV81OrEarlier and db2ISeriesV5R3OrEarlier:\n         // \"optimize for\" clause appears before \"for update\" clause.\n-        StringBuilder forUpdateString = new StringBuilder(getOptimizeClause(sel));\n+        StringBuffer forUpdateString = new StringBuffer(getOptimizeClause(sel));\n         // Determine the isolationLevel; the fetch\n         // configuration data overrides the persistence.xml value\n         if (fetch != null && fetch.getIsolation() != -1)\n@@ -889,12 +896,18 @@ public void appendCast(SQLBuffer buf, FilterValue val, int type) {\n      * Create an index if necessary for some database tables\n      */\n     public void createIndexIfNecessary(Schema schema, String table,\n+        Column pkColumn) {\n+        createIndexIfNecessary(schema, DBIdentifier.newTable(table), \n+            pkColumn);\n+    }\n+\n+    public void createIndexIfNecessary(Schema schema, DBIdentifier table,\n             Column pkColumn) {\n         if (isDB2ZOSV8xOrLater()) {\n             // build the index for the sequence tables\n             // the index name will be the fully qualified table name + _IDX\n             Table tab = schema.getTable(table);\n-            Index idx = tab.addIndex(tab.getFullName() + \"_IDX\");\n+            Index idx = tab.addIndex(DBIdentifier.append(tab.getFullIdentifier(), \"IDX\"));\n             idx.setUnique(true);\n             idx.addColumn(pkColumn);\n         }\n@@ -961,7 +974,8 @@ public void setBytes(PreparedStatement stmnt, int idx, byte[] val,\n         // for DB2, if the column was defined as CHAR for BIT DATA, then\n         // we want to use the setBytes in stead of the setBinaryStream\n         if (useSetBytesForBlobs \n-                || (col.getTypeName() != null && col.getTypeName().contains(\"BIT DATA\"))) {\n+                || (!DBIdentifier.isNull(col.getTypeIdentifier()) && \n+                col.getTypeIdentifier().getName().contains(\"BIT DATA\"))) {\n             stmnt.setBytes(idx, val);\n         } else {\n             setBinaryStream(stmnt, idx, new ByteArrayInputStream(val), val.length, col);"},{"sha":"bdae542646e5078d69aae316c8d30e2c0653b9a1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","status":"modified","additions":608,"deletions":470,"changes":1078,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -65,6 +65,12 @@\n \n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.identifier.ColumnDefIdentifierRule;\n+import org.apache.openjpa.jdbc.identifier.Normalizer;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifierRule;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifierUtil;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.kernel.exps.ExpContext;\n@@ -93,6 +99,9 @@\n import org.apache.openjpa.kernel.exps.Path;\n import org.apache.openjpa.lib.conf.Configurable;\n import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.identifier.IdentifierConfiguration;\n+import org.apache.openjpa.lib.identifier.IdentifierRule;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n import org.apache.openjpa.lib.jdbc.ConnectionDecorator;\n import org.apache.openjpa.lib.jdbc.LoggingConnectionDecorator;\n import org.apache.openjpa.lib.log.Log;\n@@ -125,14 +134,14 @@\n  */\n public class DBDictionary\n     implements Configurable, ConnectionDecorator, JoinSyntaxes,\n-    LoggingConnectionDecorator.SQLWarningHandler {\n+    LoggingConnectionDecorator.SQLWarningHandler, IdentifierConfiguration {\n \n     public static final String VENDOR_OTHER = \"other\";\n     public static final String VENDOR_DATADIRECT = \"datadirect\";\n \n-    public static final String SCHEMA_CASE_UPPER = \"upper\";\n-    public static final String SCHEMA_CASE_LOWER = \"lower\";\n-    public static final String SCHEMA_CASE_PRESERVE = \"preserve\";\n+    public static final String SCHEMA_CASE_UPPER = IdentifierUtil.CASE_UPPER;\n+    public static final String SCHEMA_CASE_LOWER = IdentifierUtil.CASE_LOWER;\n+    public static final String SCHEMA_CASE_PRESERVE = IdentifierUtil.CASE_PRESERVE;\n \n     public static final String CONS_NAME_BEFORE = \"before\";\n     public static final String CONS_NAME_MID = \"mid\";\n@@ -153,9 +162,9 @@\n     protected static final int DECI = MILLI * 100;\n     protected static final int SEC = MILLI * 1000;\n \n-    protected static final int NAME_ANY = 0;\n-    protected static final int NAME_TABLE = 1;\n-    protected static final int NAME_SEQUENCE = 2;\n+    protected static final int NAME_ANY = DBIdentifierUtil.ANY;\n+    protected static final int NAME_TABLE = DBIdentifierUtil.TABLE;\n+    protected static final int NAME_SEQUENCE = DBIdentifierUtil.SEQUENCE;\n     \n     protected static final int UNLIMITED = -1;\n     protected static final int NO_BATCH = 0;\n@@ -172,7 +181,6 @@\n     // schema data\n     public String platform = \"Generic\";\n     public String driverVendor = null;\n-    public String catalogSeparator = \".\";\n     public boolean createPrimaryKeys = true;\n     public String constraintNameMode = CONS_NAME_BEFORE;\n     public int maxTableNameLength = 128;\n@@ -347,79 +355,29 @@\n     protected Log log = null;\n     protected boolean connected = false;\n     protected boolean isJDBC3 = false;\n-    protected final Set reservedWordSet = new HashSet();\n+    protected final Set<String> reservedWordSet = new HashSet<String>();\n     // reservedWordSet subset that CANNOT be used as valid column names\n     // (i.e., without surrounding them with double-quotes)\n     protected Set<String> invalidColumnWordSet = new HashSet<String>();\n-    protected final Set systemSchemaSet = new HashSet();\n-    protected final Set systemTableSet = new HashSet();\n-    protected final Set fixedSizeTypeNameSet = new HashSet();\n-    protected final Set typeModifierSet = new HashSet();\n-    \n-    private boolean delimitIds = false;\n-    // Specifies whether or not the specific DB and version supports delimited ids\n-    public boolean supportsDelimitedIds = true;\n-    public String delimiter = \"\\\"\"; // This is public so it can be changed by a user with a property\n-    // Assume mixed case by default.\n-    protected String delimitedCase = SCHEMA_CASE_PRESERVE;\n+    protected final Set<String> systemSchemaSet = new HashSet<String>();\n+    protected final Set<String> systemTableSet = new HashSet<String>();\n+    protected final Set<String> fixedSizeTypeNameSet = new HashSet<String>();\n+    protected final Set<String> typeModifierSet = new HashSet<String>();\n+\n+    // NamingConfiguration properties\n+    private boolean delimitIdentifiers = false;\n+    public boolean supportsDelimitedIdentifiers = true;\n+    public String leadingDelimiter = \"\\\"\";\n+    public String trailingDelimiter = \"\\\"\";\n+    public String nameConcatenator = \"_\";\n+    public String delimitedCase = SCHEMA_CASE_PRESERVE;\n+    public String catalogSeparator = \".\";\n     private String defaultSchemaName = null;\n-    \n-    public static enum DBIdentifiers {\n-        TABLE_NAME,\n-        TABLE_SCHEMA,\n-        TABLE_CATALOG,\n-        COLLECTION_TABLE_NAME,\n-        COLLECTION_TABLE_SCHEMA,\n-        SECONDARY_TABLE_NAME,\n-        SECONDARY_TABLE_SCHEMA,\n-        SECONDARY_TABLE_CATALOG,\n-        TABLE_GEN_TABLE,\n-        TABLE_GEN_SCHEMA,\n-        TABLE_GEN_PK_COLUMN,\n-        TABLE_GEN_VALUE_COLUMN,\n-        COLUMN_NAME,\n-        COLUMN_COLUMN_DEFINITION,\n-        COLUMN_TABLE,\n-        MAP_KEY_COLUMN_NAME,\n-        MAP_KEY_COLUMN_COLUMN_DEFINITION,\n-        MAP_KEY_COLUMN_TABLE,\n-        JOIN_TABLE_NAME,\n-        JOIN_TABLE_SCHEMA,\n-        PRIMARY_KEY_JOIN_COLUMN_NAME,\n-        PRIMARY_KEY_JOIN_COLUMN_REFERENCED_COLUMN_NAME,\n-        PRIMARY_KEY_JOIN_COLUMN_COLUMN_DEFINITION,\n-        JOIN_COLUMN_NAME,\n-        JOIN_COLUMN_REFERENCED_COLUMN_NAME,\n-        JOIN_COLUMN_COLUMN_DEFINITION,\n-        JOIN_COLUMN_TABLE,\n-        MAP_KEY_JOIN_COLUMN_NAME,\n-        MAP_KEY_JOIN_COLUMN_REFERENCED_COLUMN_NAME,\n-        MAP_KEY_JOIN_COLUMN_COLUMN_DEFINITION,\n-        MAP_KEY_JOIN_COLUMN_TABLE,\n-        DISCRIMINATOR_COLUMN_NAME,\n-        DISCRIMINATOR_COLUMN_COLUMN_DEFINITION,\n-        FIELD_RESULT_COLUMN,\n-        COLUMN_REUSLT_NAME,\n-        SEQUENCE_GEN_SEQ_NAME,\n-        SEQUENCE_GEN_SCHEMA,\n-        UNIQUE_CONSTRAINT_NAME,\n-        UNIQUE_CONSTRAINT_COLUMN_NAMES,\n-        ORDER_COLUMN_NAME,\n-        ORDER_COLUMN_COLUMN_DEFINITION\n-        \n-    }\n-    \n-    // This is to temporarily disable support for columnDefinition elements until support is implemented.\n-    protected EnumSet<DBIdentifiers> unsupportedDelimitedIds =\n-        EnumSet.of(DBIdentifiers.COLUMN_COLUMN_DEFINITION,\n-            DBIdentifiers.DISCRIMINATOR_COLUMN_COLUMN_DEFINITION,\n-            DBIdentifiers.JOIN_COLUMN_COLUMN_DEFINITION,\n-            DBIdentifiers.MAP_KEY_COLUMN_COLUMN_DEFINITION,\n-            DBIdentifiers.MAP_KEY_JOIN_COLUMN_COLUMN_DEFINITION,\n-            DBIdentifiers.PRIMARY_KEY_JOIN_COLUMN_COLUMN_DEFINITION); \n-    \n-//    protected EnumSet<DBIdentifiers> unsupportedDelimitedIds =\n-//        EnumSet.noneOf(DBIdentifiers.class);\n+       \n+    // Naming utility and naming rules\n+    private DBIdentifierUtil namingUtil = null;\n+    private Map<String, IdentifierRule> namingRules = new HashMap<String, IdentifierRule>();\n+    private IdentifierRule defaultNamingRule = null;  // cached for performance\n     \n     /**\n      * If a native query begins with any of the values found here then it will\n@@ -484,9 +442,8 @@ public void connectedConfiguration(Connection conn)\n                         conn.getTransactionIsolation()}));\n             }\n             \n-            // While we have the metaData, set some values from it\n-            setSupportsDelimitedIds(metaData);\n-            setDelimitedCase(metaData);\n+            // Configure the naming utility\n+            configureNamingUtil(metaData);\n \n             // Auto-detect generated keys retrieval support\n             // unless user specified it.\n@@ -501,6 +458,28 @@ public void connectedConfiguration(Connection conn)\n         }\n         connected = true;\n     }\n+    \n+    private void configureNamingUtil(DatabaseMetaData metaData) {\n+        // Get the naming utility from the configuration\n+        setSupportsDelimitedIdentifiers(metaData);\n+        setDelimitedCase(metaData);\n+    }\n+\n+    /**\n+     * Configures the naming rules for this dictionary.  Subclasses should \n+     * override this method, providing their own naming rules.\n+     */\n+    protected void configureNamingRules() {\n+        // Add the default naming rule\n+        DBIdentifierRule defRule = new DBIdentifierRule(DBIdentifierType.DEFAULT, reservedWordSet);\n+        namingRules.put(defRule.getName(), defRule);\n+        // Disable delimiting of column definition.  DB platforms are very\n+        // picky about delimiters in column definitions. Base column types\n+        // do not require delimiters and will cause failures if delimited.\n+        DBIdentifierRule cdRule = new ColumnDefIdentifierRule();\n+        cdRule.setCanDelimit(false);\n+        namingRules.put(cdRule.getName(), cdRule);\n+    }\n \n     //////////////////////\n     // ResultSet wrappers\n@@ -1641,8 +1620,8 @@ public int getPreferredType(int type) {\n      * from {@link Types}.\n      */\n     public String getTypeName(Column col) {\n-        if (!StringUtils.isEmpty(col.getTypeName()))\n-            return appendSize(col, col.getTypeName());\n+        if (!DBIdentifier.isEmpty(col.getTypeIdentifier()))\n+            return appendSize(col, toDBName(col.getTypeIdentifier()));\n \n         if (col.isAutoAssigned() && autoAssignTypeName != null)\n             return appendSize(col, autoAssignTypeName);\n@@ -2079,19 +2058,20 @@ protected SQLBuffer toBulkOperation(ClassMapping mapping, Select sel,\n \n     protected SQLBuffer getDeleteTargets(Select sel) {\n       SQLBuffer deleteTargets = new SQLBuffer(this);\n-      Collection aliases = sel.getTableAliases();\n+      Collection<String> aliases = sel.getTableAliases();\n       // Assumes aliases are of the form \"TABLENAME t0\"\n-      for (Iterator itr = aliases.iterator(); itr.hasNext();) {\n-        String tableAlias = itr.next().toString();\n-        int spaceIndex = tableAlias.indexOf(' ');\n-        if (spaceIndex > 0 && spaceIndex < tableAlias.length() - 1) {\n+      // or \"\\\"TABLE NAME\\\" t0\"\n+      for (Iterator<String> itr = aliases.iterator(); itr.hasNext();) {\n+        String tableAlias = itr.next();\n+        String[] names = Normalizer.splitName(tableAlias, IdentifierUtil.SPACE);\n+        if (names.length > 1) {\n           if (allowsAliasInBulkClause) {\n-            deleteTargets.append(tableAlias.substring(spaceIndex + 1));\n+            deleteTargets.append(names[1]);\n           } else {\n-            deleteTargets.append(tableAlias.substring(0, spaceIndex));\n+            deleteTargets.append(toDBName(DBIdentifier.newTable(names[0])));\n           }\n         } else {\n-          deleteTargets.append(tableAlias);\n+          deleteTargets.append(toDBName(DBIdentifier.newTable(tableAlias)));\n         }\n         if (itr.hasNext())\n           deleteTargets.append(\", \");\n@@ -2130,7 +2110,7 @@ protected void appendUpdates(Select sel, JDBCStore store, SQLBuffer sql,\n             if (allowAlias) {\n               sql.append(sel.getColumnAlias(col));\n             } else {\n-              sql.append(col.getName());  \n+              sql.append(toDBName(col.getIdentifier()));\n             }            \n             sql.append(\" = \");\n \n@@ -2159,7 +2139,7 @@ protected void appendUpdates(Select sel, JDBCStore store, SQLBuffer sql,\n                 Map.Entry e = (Map.Entry) iter.next();\n                 Column col = (Column) e.getKey();\n                 String val = (String) e.getValue();\n-                sql.append(\", \").append(col.getName())\n+                sql.append(\", \").append(toDBName(col.getIdentifier()))\n                     .append(\" = \").append(val);\n             }\n         }\n@@ -2189,7 +2169,8 @@ protected void appendUpdates(Select sel, JDBCStore store, SQLBuffer sql,\n                 restrictConstraints.add(fks[j]);\n             }\n             \n-            deleteSQL.add(\"DELETE FROM \" + tables[i].getFullName());\n+            deleteSQL.add(\"DELETE FROM \" + \n+                toDBName(tables[i].getFullIdentifier()));\n         }\n         \n         for(ForeignKey fk : restrictConstraints) {\n@@ -2662,6 +2643,9 @@ protected SQLBuffer getSelects(Select sel, boolean distinctIdentifiers,\n         Object alias;\n         for (int i = 0; i < aliases.size(); i++) {\n             alias = aliases.get(i);\n+            if (alias instanceof String) {\n+                alias = getNamingUtil().convertAlias((String)alias);\n+            }\n             appendSelect(selectSQL, alias, sel, i);\n             if (i < aliases.size() - 1)\n                 selectSQL.append(\", \");\n@@ -2999,40 +2983,56 @@ public String addCastAsType(String func, Val val) {\n     public void refSchemaComponents(Table table) {\n     }\n \n+    /**\n+     * Returns the name of the column using database specific delimiters.\n+     */\n+    public DBIdentifier getColumnIdentifier(Column column) {\n+        if (column == null) {\n+            return DBIdentifier.NULL;\n+        }\n+        return column.getIdentifier();\n+    }\n+    \n+    public String getColumnDBName(Column column) {\n+        return toDBName(getColumnIdentifier(column));\n+    }\n+\n     /**\n      * Returns the full name of the table, including the schema (delimited\n      * by {@link #catalogSeparator}).\n      */\n+    public DBIdentifier getFullIdentifier(Table table, boolean logical) {\n+        if (!useSchemaName || DBIdentifier.isNull(table.getSchemaIdentifier()))\n+            return table.getIdentifier();\n+        return table.getFullIdentifier();\n+    }\n+        \n     public String getFullName(Table table, boolean logical) {\n-        if (!useSchemaName || table.getSchemaName() == null)\n-            return table.getName();\n-        if (logical || \".\".equals(catalogSeparator))\n-            return table.getFullName();\n-        return table.getSchemaName() + catalogSeparator + table.getName();\n+        if (!useSchemaName || DBIdentifier.isNull(table.getSchemaIdentifier()))\n+            return toDBName(table.getIdentifier());\n+        return toDBName(table.getFullIdentifier());\n     }\n-\n+    \n     /**\n      * Returns the full name of the index, including the schema (delimited\n      * by the result of {@link #catalogSeparator}).\n      */\n+\n     public String getFullName(Index index) {\n-        if (!useSchemaName || index.getSchemaName() == null)\n-            return index.getName();\n-        if (\".\".equals(catalogSeparator))\n-            return index.getFullName();\n-        return index.getSchemaName() + catalogSeparator + index.getName();\n+        if (!useSchemaName || DBIdentifier.isNull(index.getSchemaIdentifier()))\n+            return toDBName(index.getIdentifier());\n+        return toDBName(index.getFullIdentifier());\n     }\n \n     /**\n      * Returns the full name of the sequence, including the schema (delimited\n      * by the result of {@link #catalogSeparator}).\n      */\n+\n     public String getFullName(Sequence seq) {\n-        if (!useSchemaName || seq.getSchemaName() == null)\n-            return seq.getName();\n-        if (\".\".equals(catalogSeparator))\n-            return seq.getFullName();\n-        return seq.getSchemaName() + catalogSeparator + seq.getName();\n+        if (!useSchemaName || DBIdentifier.isNull(seq.getSchemaIdentifier()))\n+            return toDBName(seq.getIdentifier());\n+        return toDBName(seq.getFullIdentifier());\n     }\n \n     /**\n@@ -3050,44 +3050,75 @@ public String getFullName(Sequence seq) {\n     /**\n      * Make any necessary changes to the given table name to make it valid for\n      * the current DB.\n+     * @deprecated\n      */\n     public String getValidTableName(String name, Schema schema) {\n-        while (name.startsWith(\"_\"))\n-            name = name.substring(1);\n-        return makeNameValid(name, schema.getSchemaGroup(),\n-            maxTableNameLength, NAME_TABLE);\n+        return getValidTableName(DBIdentifier.newTable(name), schema).getName();\n+    }\n+    \n+    /**\n+     * Make any necessary changes to the given table name to make it valid for\n+     * the current DB.\n+     */\n+    public DBIdentifier getValidTableName(DBIdentifier name, Schema schema) {\n+        return namingUtil.getValidTableIdentifier(name, schema, maxTableNameLength);\n     }\n \n     /**\n      * Make any necessary changes to the given sequence name to make it valid\n      * for the current DB.\n+     * @deprecated\n      */\n     public String getValidSequenceName(String name, Schema schema) {\n-        while (name.startsWith(\"_\"))\n-            name = name.substring(1);\n-        return makeNameValid(\"S_\" + name, schema.getSchemaGroup(),\n-            maxTableNameLength, NAME_SEQUENCE);\n+        return getValidSequenceName(DBIdentifier.newSequence(name), schema).getName();\n+    }\n+\n+    /**\n+     * Make any necessary changes to the given sequence name to make it valid\n+     * for the current DB.\n+     */\n+    public DBIdentifier getValidSequenceName(DBIdentifier name, Schema schema) {\n+        return namingUtil.getValidSequenceIdentifier(name, schema, maxTableNameLength);\n     }\n \n     /**\n      * Make any necessary changes to the given column name to make it valid\n      * for the current DB.  The column name will be made unique for the\n      * specified table.\n+     * @deprecated\n      */\n     public String getValidColumnName(String name, Table table) {\n+        return getValidColumnName(DBIdentifier.newColumn(name), table, true).getName();\n+    }\n+\n+    /**\n+     * Make any necessary changes to the given column name to make it valid\n+     * for the current DB.  The column name will be made unique for the\n+     * specified table.\n+     */\n+    public DBIdentifier getValidColumnName(DBIdentifier name, Table table) {\n         return getValidColumnName(name, table, true);\n     }\n \n     /**\n      * Make any necessary changes to the given column name to make it valid\n      * for the current DB.  If checkForUniqueness is true, the column name will \n      * be made unique for the specified table.\n+     * @deprecated\n      */\n     public String getValidColumnName(String name, Table table,\n         boolean checkForUniqueness) {\n-        while (name.startsWith(\"_\"))\n-            name = name.substring(1);\n-        return makeNameValid(name, table, maxColumnNameLength, NAME_ANY,\n+        return getValidColumnName(DBIdentifier.newColumn(name), table, checkForUniqueness).toString();\n+    }\n+\n+    /**\n+     * Make any necessary changes to the given column name to make it valid\n+     * for the current DB.  If checkForUniqueness is true, the column name will \n+     * be made unique for the specified table.\n+     */\n+    public DBIdentifier getValidColumnName(DBIdentifier name, Table table,\n+        boolean checkForUniqueness) {\n+        return getNamingUtil().getValidColumnIdentifier(name, table, maxColumnNameLength, \n             checkForUniqueness);\n     }\n \n@@ -3105,74 +3136,64 @@ public String getValidPrimaryKeyName(String name, Table table) {\n     /**\n      * Make any necessary changes to the given foreign key name to make it\n      * valid for the current DB.\n+     * @deprecated\n      */\n     public String getValidForeignKeyName(String name, Table table,\n         Table toTable) {\n-        while (name.startsWith(\"_\"))\n-            name = name.substring(1);\n-        String tableName = table.getName();\n-        int len = Math.min(tableName.length(), 7);\n-        name = \"F_\" + shorten(tableName, len) + \"_\" + name;\n-        return makeNameValid(name, table.getSchema().getSchemaGroup(),\n-            maxConstraintNameLength, NAME_ANY);\n+        return getValidForeignKeyName(DBIdentifier.newForeignKey(name), table,\n+            toTable).getName();\n+    }\n+\n+    /**\n+     * Make any necessary changes to the given foreign key name to make it\n+     * valid for the current DB.\n+     */\n+    public DBIdentifier getValidForeignKeyName(DBIdentifier name, Table table,\n+        Table toTable) {\n+        return namingUtil.getValidForeignKeyIdentifier(name, table, toTable, maxConstraintNameLength);\n     }\n \n     /**\n      * Make any necessary changes to the given index name to make it valid\n      * for the current DB.\n+     * @deprecated\n      */\n     public String getValidIndexName(String name, Table table) {\n-        while (name.startsWith(\"_\"))\n-            name = name.substring(1);\n-        String tableName = table.getName();\n-        int len = Math.min(tableName.length(), 7);\n-        String shortTableName = shorten(tableName, len);\n-        name = combineNames(\"I\", shortTableName, name);\n-        \n-        return makeNameValid(name, table.getSchema().getSchemaGroup(),\n-            maxIndexNameLength, NAME_ANY);\n+        return getValidIndexName(DBIdentifier.newIndex(name), table).getName();\n+    }\n+\n+    /**\n+     * Make any necessary changes to the given index name to make it valid\n+     * for the current DB.\n+     */\n+    public DBIdentifier getValidIndexName(DBIdentifier name, Table table) {\n+        return getNamingUtil().getValidIndexIdentifier(name, table, maxIndexNameLength);\n     }\n \n     /**\n      * Make any necessary changes to the given unique constraint name to make\n      * it valid for the current DB.\n+     * @deprecated\n      */\n     public String getValidUniqueName(String name, Table table) {\n-        while (name.startsWith(\"_\"))\n-            name = name.substring(1);\n-        String tableName = table.getName();\n-        int len = Math.min(tableName.length(), 7);\n-        name = combineNames(\"U\", shorten(tableName, len), name);\n-        return makeNameValid(name, table.getSchema().getSchemaGroup(),\n-            maxConstraintNameLength, NAME_ANY);\n+        return getValidUniqueName(DBIdentifier.newConstraint(name), table).getName();\n     }\n-    \n-    public boolean isDelimited(String name) {\n-        return (name.startsWith(getDelimiter()) \n-                && name.endsWith(getDelimiter()));\n-    }\n-    \n-    public String stripDelimiters(String name) {\n-        String delimiter = getDelimiter();\n-        int delimLen = delimiter.length();\n-        if (isDelimited(name)) {\n-            return name.substring(delimLen, name.length() - delimLen);\n-        }\n-        return name;\n+\n+    /**\n+     * Make any necessary changes to the given unique constraint name to make\n+     * it valid for the current DB.\n+     */\n+    public DBIdentifier getValidUniqueName(DBIdentifier name, Table table) {\n+        return namingUtil.getValidUniqueIdentifier(name, table, maxConstraintNameLength);\n     }\n     \n-    public String addDelimiters(String name) {\n-        String delimiter = getDelimiter();\n-        return delimiter + name + delimiter;\n-    }\n-\n     /**\n      * Shorten the specified name to the specified target name. This will\n      * be done by first stripping out the vowels, and then removing\n      * characters from the middle of the word until it reaches the target\n      * length.\n      */\n-    protected static String shorten(String name, int targetLength) {\n+    public static String shorten(String name, int targetLength) {\n         if (name == null || name.length() <= targetLength)\n             return name;\n \n@@ -3187,11 +3208,10 @@ protected static String shorten(String name, int targetLength) {\n     }\n \n     /**\n-     * Remove vowels from the specified StringBuffer.\n+     * Remove vowels from the specified StringBuilder.\n      *\n      * @return true if any vowels have been removed\n      */\n-    //private static boolean stripVowel(StringBuffer name) {\n     private static boolean stripVowel(StringBuilder name) {\n         if (name == null || name.length() == 0)\n             return false;\n@@ -3214,12 +3234,26 @@ private static boolean stripVowel(StringBuilder name) {\n      * character is replace with '0', then '1', etc.\n      * Note that the given max len may be 0 if the database metadata is\n      * incomplete.\n+     * @deprecated\n      */\n     protected String makeNameValid(String name, NameSet set, int maxLen,\n         int nameType) {\n         return makeNameValid(name, set, maxLen, nameType, true);\n     }\n \n+    /**\n+     * Shortens the given name to the given maximum length, then checks that\n+     * it is not a reserved word. If it is reserved, appends a \"0\". If\n+     * the name conflicts with an existing schema component, the last\n+     * character is replace with '0', then '1', etc.\n+     * Note that the given max len may be 0 if the database metadata is\n+     * incomplete.\n+     */\n+    protected DBIdentifier makeNameValid(DBIdentifier name, NameSet set, int maxLen,\n+        int nameType) {\n+        return makeNameValid(name, set, maxLen, nameType, true);\n+    }\n+\n     /**\n      * Shortens the given name to the given maximum length, then checks that\n      * it is not a reserved word. If it is reserved, appends a \"0\". If\n@@ -3234,102 +3268,26 @@ protected String makeNameValid(String name, NameSet set, int maxLen,\n      */\n     protected String makeNameValid(String name, NameSet set, int maxLen,\n         int nameType, boolean checkForUniqueness) {\n-        boolean delimited = false;\n-        String delimiter = getDelimiter();\n-        if (name.startsWith(delimiter) && name.endsWith(delimiter)) {\n-            delimited = true;\n-        }\n-        if (maxLen < 1)\n-            maxLen = 255;\n-        if (name.length() > maxLen)\n-            name = removeEndingChars(name, name.length() - maxLen, \n-                delimited, delimiter);\n-        if (reservedWordSet.contains(name.toUpperCase())) {\n-            if (name.length() == maxLen)\n-                name = removeEndingChars(name, 1, delimited, delimiter);\n-            name = addCharsToEnd(name, \"0\", delimited, delimiter);\n-        }\n-\n-        // now make sure the name is unique\n-        if (set != null && checkForUniqueness) {\n-            outer:\n-            for (int version = 1, chars = 1; true; version++) {\n-                // for table names, we check for the table itself in case the\n-                // name set is lazy about schema reflection\n-                switch (nameType) {\n-                    case NAME_TABLE:\n-                        if (!((SchemaGroup) set).isKnownTable(name))\n-                            break outer;\n-                        break;\n-                    case NAME_SEQUENCE:\n-                        if (!((SchemaGroup) set).isKnownSequence(name))\n-                            break outer;\n-                        break;\n-                    default:\n-                        if (!set.isNameTaken(name))\n-                            break outer;\n-                }\n-\n-                // a single char for the version is probably enough, but might\n-                // as well be general about it...\n-                if (version > 1)\n-                    name = removeEndingChars(name, chars, delimited, delimiter);\n-                if (version >= Math.pow(10, chars))\n-                    chars++;\n-                if (name.length() + chars > maxLen)\n-                    name = removeEndingChars(name, \n-                        name.length() + chars - maxLen, \n-                        delimited, delimiter);\n-                name = addCharsToEnd(name, new Integer(version).toString(), \n-                    delimited, delimiter);\n-            }\n-        }\n-        \n-        if (delimited) {\n-            String delimCase = getDelimitedCase();\n-            if (delimCase.equals(SCHEMA_CASE_LOWER)) {\n-                return name.toLowerCase();\n-            }\n-            else if (delimCase.equals(SCHEMA_CASE_UPPER)) {\n-                return name.toUpperCase();\n-            }\n-            else {\n-                return name;\n-            }\n-        }\n-        return name.toUpperCase();\n+        return namingUtil.makeNameValid(name, set,\n+            maxLen, nameType, checkForUniqueness).toString();\n     }\n-    \n-    private String removeEndingChars(String name, \n-        int charsToRemove,\n-        boolean delimited, \n-        String delimiter) {\n-        if (delimited) {\n-            name = name.substring(0, name.length() - delimiter.length());\n-            name = name.substring(0, name.length() - charsToRemove);\n-            name = name + delimiter;\n-        }\n-        else {\n-            name = name.substring(0, name.length() - charsToRemove);\n-        }\n-        \n-        return name;\n-    }\n-    \n-    private String addCharsToEnd(String name,\n-        String charsToAdd,\n-        boolean delimited,\n-        String delimiter) {\n-        if (delimited) {\n-            name = name.substring(0, name.length() - delimiter.length());\n-            name = name + charsToAdd;\n-            name = name + delimiter;\n-        }\n-        else {\n-            name = name + charsToAdd;\n-        }\n-        \n-        return name;\n+\n+    /**\n+     * Shortens the given name to the given maximum length, then checks that\n+     * it is not a reserved word. If it is reserved, appends a \"0\". If\n+     * the name conflicts with an existing schema component and uniqueness\n+     * checking is enabled, the last character is replace with '0', then \n+     * '1', etc. \n+     * Note that the given max len may be 0 if the database metadata is \n+     * incomplete.\n+     * \n+     * Note: If the name is delimited, make sure the ending delimiter is\n+     * not stripped off.\n+     */\n+    protected DBIdentifier makeNameValid(DBIdentifier name, NameSet set, int maxLen,\n+        int nameType, boolean checkForUniqueness) {\n+        return namingUtil.makeIdentifierValid(name, set,\n+            maxLen, checkForUniqueness);\n     }\n \n     /**\n@@ -3391,7 +3349,6 @@ public int getBatchFetchSize(int batchFetchSize) {\n         return batchFetchSize;\n     }\n \n-    //protected StringBuffer comment(StringBuffer buf, String comment) {\n     protected StringBuilder comment(StringBuilder buf, String comment) {\n         return buf.append(\"-- \").append(comment);\n     }\n@@ -3446,11 +3403,11 @@ protected StringBuilder comment(StringBuilder buf, String comment) {\n         buf.append(\"CREATE \");\n         if (index.isUnique())\n             buf.append(\"UNIQUE \");\n-        String indexName = checkNameLength(index.getName(), maxIndexNameLength, \n+        String indexName = checkNameLength(toDBName(index.getIdentifier()), maxIndexNameLength, \n                 \"long-index-name\");\n         buf.append(\"INDEX \").append(indexName);\n         buf.append(\" ON \").append(getFullName(index.getTable(), false));\n-        buf.append(\" (\").append(Strings.join(index.getColumns(), \", \")).\n+        buf.append(\" (\").append(namingUtil.appendColumns(index.getColumns())).\n             append(\")\");\n \n         return new String[]{ buf.toString() };\n@@ -3516,11 +3473,11 @@ protected StringBuilder comment(StringBuilder buf, String comment) {\n      * &lt;pk name&gt;</code> by default.\n      */\n     public String[] getDropPrimaryKeySQL(PrimaryKey pk) {\n-        if (pk.getName() == null)\n+        if (DBIdentifier.isNull(pk.getIdentifier()))\n             return new String[0];\n         return new String[]{ \"ALTER TABLE \"\n             + getFullName(pk.getTable(), false)\n-            + \" DROP CONSTRAINT \" + pk.getName() };\n+            + \" DROP CONSTRAINT \" + toDBName(pk.getIdentifier()) };\n     }\n \n     /**\n@@ -3544,18 +3501,18 @@ protected StringBuilder comment(StringBuilder buf, String comment) {\n      * &lt;fk name&gt;</code> by default.\n      */\n     public String[] getDropForeignKeySQL(ForeignKey fk, Connection conn) {\n-        if (fk.getName() == null) {\n+        if (DBIdentifier.isNull(fk.getIdentifier())) {\n             String[] retVal;\n-            String fkName = fk.loadNameFromDB(this,conn);\n+            DBIdentifier fkName = fk.loadIdentifierFromDB(this,conn);\n             retVal = (fkName == null) ?  new String[0] :\n                 new String[]{ \"ALTER TABLE \"\n                 + getFullName(fk.getTable(), false)\n-                + \" DROP CONSTRAINT \" + fkName };\n-            return retVal;   \n+                + \" DROP CONSTRAINT \" + toDBName(fkName) };\n+            return retVal;\n         }\n         return new String[]{ \"ALTER TABLE \"\n             + getFullName(fk.getTable(), false)\n-            + \" DROP CONSTRAINT \" + fk.getName() };\n+            + \" DROP CONSTRAINT \" + toDBName(fk.getIdentifier()) };\n     }\n \n     /**\n@@ -3565,7 +3522,7 @@ protected StringBuilder comment(StringBuilder buf, String comment) {\n      */\n     protected String getDeclareColumnSQL(Column col, boolean alter) {\n         StringBuilder buf = new StringBuilder();\n-        String columnName = checkNameLength(col.getName(), maxColumnNameLength, \n+        String columnName = checkNameLength(toDBName(col.getIdentifier()), maxColumnNameLength, \n                 \"long-column-name\");\n         buf.append(columnName).append(\" \");\n         buf.append(getTypeName(col));\n@@ -3599,7 +3556,7 @@ protected String getPrimaryKeyConstraintSQL(PrimaryKey pk) {\n         if (!createPrimaryKeys)\n             return null;\n \n-        String name = pk.getName();\n+        String name = toDBName(pk.getIdentifier());\n         if (name != null && reservedWordSet.contains(name.toUpperCase()))\n             name = null;\n \n@@ -3609,7 +3566,7 @@ protected String getPrimaryKeyConstraintSQL(PrimaryKey pk) {\n         buf.append(\"PRIMARY KEY \");\n         if (name != null && CONS_NAME_MID.equals(constraintNameMode))\n             buf.append(name).append(\" \");\n-        buf.append(\"(\").append(Strings.join(pk.getColumns(), \", \")).\n+        buf.append(\"(\").append(namingUtil.appendColumns(pk.getColumns())).\n             append(\")\");\n         if (name != null && CONS_NAME_AFTER.equals(constraintNameMode))\n             buf.append(\" CONSTRAINT \").append(name);\n@@ -3652,16 +3609,16 @@ protected String getForeignKeyConstraintSQL(ForeignKey fk) {\n         String upAction = getActionName(fk.getUpdateAction());\n \n         StringBuilder buf = new StringBuilder();\n-        if (fk.getName() != null\n+        if (!DBIdentifier.isNull(fk.getIdentifier())\n             && CONS_NAME_BEFORE.equals(constraintNameMode))\n-            buf.append(\"CONSTRAINT \").append(fk.getName()).append(\" \");\n+            buf.append(\"CONSTRAINT \").append(toDBName(fk.getIdentifier())).append(\" \");\n         buf.append(\"FOREIGN KEY \");\n-        if (fk.getName() != null && CONS_NAME_MID.equals(constraintNameMode))\n-            buf.append(fk.getName()).append(\" \");\n-        buf.append(\"(\").append(Strings.join(locals, \", \")).append(\")\");\n+        if (!DBIdentifier.isNull(fk.getIdentifier()) && CONS_NAME_MID.equals(constraintNameMode))\n+            buf.append(toDBName(fk.getIdentifier())).append(\" \");\n+        buf.append(\"(\").append(namingUtil.appendColumns(locals)).append(\")\");\n         buf.append(\" REFERENCES \");\n         buf.append(getFullName(foreigns[0].getTable(), false));\n-        buf.append(\" (\").append(Strings.join(foreigns, \", \")).append(\")\");\n+        buf.append(\" (\").append(namingUtil.appendColumns(foreigns)).append(\")\");\n         if (delAction != null)\n             buf.append(\" ON DELETE \").append(delAction);\n         if (upAction != null)\n@@ -3670,9 +3627,9 @@ protected String getForeignKeyConstraintSQL(ForeignKey fk) {\n             buf.append(\" INITIALLY DEFERRED\");\n         if (supportsDeferredForeignKeyConstraints())\n             buf.append(\" DEFERRABLE\");\n-        if (fk.getName() != null\n+        if (!DBIdentifier.isNull(fk.getIdentifier())\n             && CONS_NAME_AFTER.equals(constraintNameMode))\n-            buf.append(\" CONSTRAINT \").append(fk.getName());\n+            buf.append(\" CONSTRAINT \").append(toDBName(fk.getIdentifier()));\n         return buf.toString();\n     }\n \n@@ -3757,22 +3714,22 @@ protected String getUniqueConstraintSQL(Unique unq) {\n             || (unq.isDeferred() && !supportsDeferredUniqueConstraints()))\n             return null;\n         StringBuilder buf = new StringBuilder();\n-        if (unq.getName() != null\n+        if (!DBIdentifier.isNull(unq.getIdentifier())\n             && CONS_NAME_BEFORE.equals(constraintNameMode))\n-            buf.append(\"CONSTRAINT \").append(checkNameLength(unq.getName(), \n+            buf.append(\"CONSTRAINT \").append(checkNameLength(toDBName(unq.getIdentifier()), \n                 maxConstraintNameLength, \"long-constraint-name\")).append(\" \");\n         buf.append(\"UNIQUE \");\n-        if (unq.getName() != null && CONS_NAME_MID.equals(constraintNameMode))\n-            buf.append(unq.getName()).append(\" \");\n-        buf.append(\"(\").append(Strings.join(unq.getColumns(), \", \")).\n+        if (!DBIdentifier.isNull(unq.getIdentifier()) && CONS_NAME_MID.equals(constraintNameMode))\n+            buf.append(toDBName(unq.getIdentifier())).append(\" \");\n+        buf.append(\"(\").append(namingUtil.appendColumns(unq.getColumns())).\n             append(\")\");\n         if (unq.isDeferred())\n             buf.append(\" INITIALLY DEFERRED\");\n         if (supportsDeferredUniqueConstraints())\n             buf.append(\" DEFERRABLE\");\n-        if (unq.getName() != null\n+        if (!DBIdentifier.isNull(unq.getIdentifier())\n             && CONS_NAME_AFTER.equals(constraintNameMode))\n-            buf.append(\" CONSTRAINT \").append(unq.getName());\n+            buf.append(\" CONSTRAINT \").append(toDBName(unq.getIdentifier()));\n         return buf.toString();\n     }\n \n@@ -3802,13 +3759,35 @@ protected boolean supportsDeferredUniqueConstraints() {\n      * @param schema the table schema; may be null\n      * @param targetSchema if true, then the given schema was listed by\n      * the user as one of his schemas\n+     * @deprecated\n      */\n     public boolean isSystemTable(String name, String schema,\n         boolean targetSchema) {\n-        if (systemTableSet.contains(name.toUpperCase()))\n+        return isSystemTable(DBIdentifier.newTable(name),\n+            DBIdentifier.newSchema(schema), targetSchema);\n+    }\n+\n+    /**\n+     * This method is used to filter system tables from database metadata.\n+     * Return true if the given table name represents a system table that\n+     * should not appear in the schema definition. By default, returns\n+     * true only if the given table is in the internal list of system tables,\n+     * or if the given schema is in the list of system schemas and is not\n+     * the target schema.\n+     *\n+     * @param name the table name\n+     * @param schema the table schema; may be null\n+     * @param targetSchema if true, then the given schema was listed by\n+     * the user as one of his schemas\n+     */\n+    public boolean isSystemTable(DBIdentifier name, DBIdentifier schema,\n+        boolean targetSchema) {\n+        DBIdentifier sName = DBIdentifier.toUpper(name);\n+        if (systemTableSet.contains(sName.getName()))\n             return true;\n+        DBIdentifier schName = DBIdentifier.toUpper(schema);\n         return !targetSchema && schema != null\n-            && systemSchemaSet.contains(schema.toUpperCase());\n+            && systemSchemaSet.contains(schName.getName());\n     }\n \n     /**\n@@ -3818,10 +3797,23 @@ public boolean isSystemTable(String name, String schema,\n      *\n      * @param name the index name\n      * @param table the index table\n+     * @deprecated\n      */\n     public boolean isSystemIndex(String name, Table table) {\n         return false;\n     }\n+    \n+    /**\n+     * This method is used to filter system indexes from database metadata.\n+     * Return true if the given index name represents a system index that\n+     * should not appear in the schema definition. Returns false by default.\n+     *\n+     * @param name the index name\n+     * @param table the index table\n+     */\n+    public boolean isSystemIndex(DBIdentifier name, Table table) {\n+        return false;\n+    }\n \n     /**\n      * This method is used to filter system sequences from database metadata.\n@@ -3833,23 +3825,56 @@ public boolean isSystemIndex(String name, Table table) {\n      * @param schema the table schema; may be null\n      * @param targetSchema if true, then the given schema was listed by\n      * the user as one of his schemas\n+     * @deprecated\n      */\n     public boolean isSystemSequence(String name, String schema,\n         boolean targetSchema) {\n-        return !targetSchema && schema != null\n-            && systemSchemaSet.contains(schema.toUpperCase());\n+        return isSystemSequence(DBIdentifier.newSequence(name), \n+            DBIdentifier.newSchema(schema), targetSchema);\n+    }\n+\n+    /**\n+     * This method is used to filter system sequences from database metadata.\n+     * Return true if the given sequence represents a system sequence that\n+     * should not appear in the schema definition. Returns true if system\n+     * schema by default.\n+     *\n+     * @param name the table name\n+     * @param schema the table schema; may be null\n+     * @param targetSchema if true, then the given schema was listed by\n+     * the user as one of his schemas\n+     */\n+    public boolean isSystemSequence(DBIdentifier name, DBIdentifier schema,\n+        boolean targetSchema) {\n+        return !targetSchema && !DBIdentifier.isNull(schema)\n+            && systemSchemaSet.contains(DBIdentifier.toUpper(schema).getName());\n     }\n \n     /**\n      * Reflect on the schema to find tables matching the given name pattern.\n+     * @deprecated\n      */\n     public Table[] getTables(DatabaseMetaData meta, String catalog,\n         String schemaName, String tableName, Connection conn)\n         throws SQLException {\n+        return getTables(meta, DBIdentifier.newCatalog(catalog), DBIdentifier.newSchema(schemaName),\n+            DBIdentifier.newTable(tableName), conn);\n+    }\n+\n+    \n+    /**\n+     * Reflect on the schema to find tables matching the given name pattern.\n+     */\n+    public Table[] getTables(DatabaseMetaData meta, DBIdentifier sqlCatalog,\n+        DBIdentifier sqlSchemaName, DBIdentifier sqlTableName, Connection conn)\n+        throws SQLException {\n+                \n+        String schemaName = DBIdentifier.isNull(sqlSchemaName) ? null : sqlSchemaName.getName();\n         if (!supportsSchemaForGetTables)\n             schemaName = null;\n-        else\n-            schemaName = getSchemaNameForMetadata(schemaName);\n+        else {\n+            schemaName = getSchemaNameForMetadata(sqlSchemaName);\n+        }\n \n         String[] types = Strings.split(tableTypes, \",\", 0);\n         for (int i = 0; i < types.length; i++)\n@@ -3858,8 +3883,8 @@ public boolean isSystemSequence(String name, String schema,\n         beforeMetadataOperation(conn);\n         ResultSet tables = null;\n         try {\n-            tables = meta.getTables(getCatalogNameForMetadata(catalog),\n-                schemaName, getTableNameForMetadata(tableName), types);\n+            tables = meta.getTables(getCatalogNameForMetadata(sqlCatalog),\n+                schemaName, getTableNameForMetadata(sqlTableName), types);\n             List tableList = new ArrayList();\n             while (tables != null && tables.next())\n                 tableList.add(newTable(tables));\n@@ -3879,18 +3904,27 @@ public boolean isSystemSequence(String name, String schema,\n     protected Table newTable(ResultSet tableMeta)\n         throws SQLException {\n         Table t = new Table();\n-        t.setName(tableMeta.getString(\"TABLE_NAME\"));\n+        t.setIdentifier(fromDBName(tableMeta.getString(\"TABLE_NAME\"), DBIdentifierType.TABLE));\n         return t;\n     }\n \n     /**\n      * Reflect on the schema to find sequences matching the given name pattern.\n      * Returns an empty array by default, as there is no standard way to\n      * retrieve a list of sequences.\n+     * @deprecated\n      */\n     public Sequence[] getSequences(DatabaseMetaData meta, String catalog,\n         String schemaName, String sequenceName, Connection conn)\n         throws SQLException {\n+        return getSequences(meta, DBIdentifier.newCatalog(catalog), DBIdentifier.newSchema(schemaName),\n+            DBIdentifier.newSequence(sequenceName), conn);\n+        \n+    }\n+\n+    public Sequence[] getSequences(DatabaseMetaData meta, DBIdentifier catalog,\n+        DBIdentifier schemaName, DBIdentifier sequenceName, Connection conn)\n+        throws SQLException {\n         String str = getSequencesSQL(schemaName, sequenceName);\n         if (str == null)\n             return new Sequence[0];\n@@ -3899,10 +3933,10 @@ protected Table newTable(ResultSet tableMeta)\n         ResultSet rs = null;\n         try {\n             int idx = 1;\n-            if (schemaName != null)\n-                stmnt.setString(idx++, schemaName.toUpperCase());\n-            if (sequenceName != null)\n-                stmnt.setString(idx++, sequenceName);\n+            if (!DBIdentifier.isNull(schemaName))\n+                stmnt.setString(idx++, DBIdentifier.toUpper(schemaName).getName());\n+            if (!DBIdentifier.isNull(sequenceName))\n+                stmnt.setString(idx++, sequenceName.getName());\n             setQueryTimeout(stmnt, conf.getQueryTimeout());\n             rs = executeQuery(conn, stmnt, str);\n             return getSequence(rs);            \n@@ -3926,38 +3960,62 @@ protected Table newTable(ResultSet tableMeta)\n     protected Sequence newSequence(ResultSet sequenceMeta)\n         throws SQLException {\n         Sequence seq = new Sequence();\n-        seq.setSchemaName(sequenceMeta.getString(\"SEQUENCE_SCHEMA\"));\n-        seq.setName(sequenceMeta.getString(\"SEQUENCE_NAME\"));\n+        seq.setSchemaIdentifier(fromDBName(sequenceMeta.getString(\"SEQUENCE_SCHEMA\"), DBIdentifierType.SCHEMA));\n+        seq.setIdentifier(fromDBName(sequenceMeta.getString(\"SEQUENCE_NAME\"), DBIdentifierType.SEQUENCE));\n         return seq;\n     }\n \n     /**\n      * Return the SQL needed to select the list of sequences.\n+     * @deprecated\n      */\n     protected String getSequencesSQL(String schemaName, String sequenceName) {\n         return null;\n     }\n \n+    protected String getSequencesSQL(DBIdentifier schemaName, DBIdentifier sequenceName) {\n+        return null;\n+    }\n+\n     /**\n      * Reflect on the schema to find columns matching the given table and\n      * column patterns.\n+     * @deprecated\n      */\n     public Column[] getColumns(DatabaseMetaData meta, String catalog,\n         String schemaName, String tableName, String columnName, Connection conn)\n         throws SQLException {\n-        if (tableName == null && !supportsNullTableForGetColumns)\n-            return null;\n+        return getColumns(meta, DBIdentifier.newCatalog(catalog),\n+            DBIdentifier.newSchema(schemaName),\n+            DBIdentifier.newTable(tableName),\n+            DBIdentifier.newColumn(columnName),\n+            conn);\n+    }\n \n+    /**\n+     * Reflect on the schema to find columns matching the given table and\n+     * column patterns.\n+     */\n+    public Column[] getColumns(DatabaseMetaData meta, DBIdentifier catalog,\n+        DBIdentifier schemaName, DBIdentifier tableName, DBIdentifier columnName, Connection conn)\n+        throws SQLException {\n+        if (DBIdentifier.isNull(tableName) && !supportsNullTableForGetColumns)\n+            return null;\n+        \n+        String sqlSchemaName = null;\n+        if (!DBIdentifier.isNull(schemaName)) {\n+            sqlSchemaName = schemaName.getName();\n+        }\n         if (!supportsSchemaForGetColumns)\n-            schemaName = null;\n+            sqlSchemaName = null;\n         else\n-            schemaName = getSchemaNameForMetadata(schemaName);\n+            sqlSchemaName = getSchemaNameForMetadata(schemaName);\n \n         beforeMetadataOperation(conn);\n         ResultSet cols = null;\n         try {\n             cols = meta.getColumns(getCatalogNameForMetadata(catalog),\n-                schemaName, getTableNameForMetadata(tableName),\n+                sqlSchemaName, getTableNameForMetadata(tableName),\n                 getColumnNameForMetadata(columnName));\n \n             List columnList = new ArrayList();\n@@ -3980,11 +4038,11 @@ protected String getSequencesSQL(String schemaName, String sequenceName) {\n     protected Column newColumn(ResultSet colMeta)\n         throws SQLException {\n         Column c = new Column();\n-        c.setSchemaName(colMeta.getString(\"TABLE_SCHEM\"));\n-        c.setTableName(colMeta.getString(\"TABLE_NAME\"));\n-        c.setName(colMeta.getString(\"COLUMN_NAME\"));\n+        c.setSchemaIdentifier(fromDBName(colMeta.getString(\"TABLE_SCHEM\"), DBIdentifierType.SCHEMA));\n+        c.setTableIdentifier(fromDBName(colMeta.getString(\"TABLE_NAME\"), DBIdentifierType.TABLE));\n+        c.setIdentifier(fromDBName(colMeta.getString(\"COLUMN_NAME\"), DBIdentifierType.COLUMN));\n         c.setType(colMeta.getInt(\"DATA_TYPE\"));\n-        c.setTypeName(colMeta.getString(\"TYPE_NAME\"));\n+        c.setTypeIdentifier(fromDBName(colMeta.getString(\"TYPE_NAME\"), DBIdentifierType.COLUMN_DEFINITION));\n         c.setSize(colMeta.getInt(\"COLUMN_SIZE\"));\n         c.setDecimalDigits(colMeta.getInt(\"DECIMAL_DIGITS\"));\n         c.setNotNull(colMeta.getInt(\"NULLABLE\")\n@@ -3998,10 +4056,21 @@ protected Column newColumn(ResultSet colMeta)\n \n     /**\n      * Reflect on the schema to find primary keys for the given table pattern.\n+     * @deprecated\n      */\n     public PrimaryKey[] getPrimaryKeys(DatabaseMetaData meta,\n         String catalog, String schemaName, String tableName, Connection conn)\n         throws SQLException {\n+        return getPrimaryKeys(meta, DBIdentifier.newCatalog(catalog), DBIdentifier.newSchema(schemaName),\n+            DBIdentifier.newTable(tableName), conn);\n+    }\n+\n+    /**\n+     * Reflect on the schema to find primary keys for the given table pattern.\n+     */\n+    public PrimaryKey[] getPrimaryKeys(DatabaseMetaData meta,\n+        DBIdentifier catalog, DBIdentifier schemaName, DBIdentifier tableName, Connection conn)\n+        throws SQLException {\n         if (useGetBestRowIdentifierForPrimaryKeys)\n             return getPrimaryKeysFromBestRowIdentifier(meta, catalog,\n                 schemaName, tableName, conn);\n@@ -4011,10 +4080,21 @@ protected Column newColumn(ResultSet colMeta)\n \n     /**\n      * Reflect on the schema to find primary keys for the given table pattern.\n+     * @deprecated\n      */\n     protected PrimaryKey[] getPrimaryKeysFromGetPrimaryKeys\n         (DatabaseMetaData meta, String catalog, String schemaName,\n             String tableName, Connection conn)\n+    throws SQLException {\n+        return getPrimaryKeysFromGetPrimaryKeys(meta, DBIdentifier.newCatalog(catalog),\n+            DBIdentifier.newSchema(schemaName), DBIdentifier.newTable(tableName), conn);\n+    }\n+    /**\n+     * Reflect on the schema to find primary keys for the given table pattern.\n+     */\n+    protected PrimaryKey[] getPrimaryKeysFromGetPrimaryKeys\n+        (DatabaseMetaData meta, DBIdentifier catalog, DBIdentifier schemaName,\n+            DBIdentifier tableName, Connection conn)\n         throws SQLException {\n         if (tableName == null && !supportsNullTableForGetPrimaryKeys)\n             return null;\n@@ -4046,35 +4126,46 @@ protected Column newColumn(ResultSet colMeta)\n     protected PrimaryKey newPrimaryKey(ResultSet pkMeta)\n         throws SQLException {\n         PrimaryKey pk = new PrimaryKey();\n-        pk.setSchemaName(pkMeta.getString(\"TABLE_SCHEM\"));\n-        pk.setTableName(pkMeta.getString(\"TABLE_NAME\"));\n-        pk.setColumnName(pkMeta.getString(\"COLUMN_NAME\"));\n-        pk.setName(pkMeta.getString(\"PK_NAME\"));\n+        pk.setSchemaIdentifier(fromDBName(pkMeta.getString(\"TABLE_SCHEM\"), DBIdentifierType.SCHEMA));\n+        pk.setTableIdentifier(fromDBName(pkMeta.getString(\"TABLE_NAME\"), DBIdentifierType.TABLE));\n+        pk.setColumnIdentifier(fromDBName(pkMeta.getString(\"COLUMN_NAME\"), DBIdentifierType.COLUMN));\n+        pk.setIdentifier(fromDBName(pkMeta.getString(\"PK_NAME\"), DBIdentifierType.CONSTRAINT));\n         return pk;\n     }\n \n     /**\n      * Reflect on the schema to find primary keys for the given table pattern.\n+     * @deprecated\n      */\n     protected PrimaryKey[] getPrimaryKeysFromBestRowIdentifier\n         (DatabaseMetaData meta, String catalog, String schemaName,\n-            String tableName, Connection conn)\n+            String tableName, Connection conn) throws SQLException {\n+        return getPrimaryKeysFromBestRowIdentifier(meta, DBIdentifier.newCatalog(catalog),\n+            DBIdentifier.newSchema(schemaName), DBIdentifier.newTable(tableName), conn);\n+    }\n+\n+    /**\n+     * Reflect on the schema to find primary keys for the given table pattern.\n+     */\n+    protected PrimaryKey[] getPrimaryKeysFromBestRowIdentifier\n+        (DatabaseMetaData meta, DBIdentifier catalog, DBIdentifier schemaName,\n+            DBIdentifier tableName, Connection conn)\n         throws SQLException {\n         if (tableName == null)\n             return null;\n \n         beforeMetadataOperation(conn);\n         ResultSet pks = null;\n         try {\n-            pks = meta.getBestRowIdentifier(catalog, schemaName,\n-                tableName, 0, false);\n+            pks = meta.getBestRowIdentifier(toDBName(catalog), toDBName(schemaName),\n+                toDBName(tableName), 0, false);\n \n             List pkList = new ArrayList();\n             while (pks != null && pks.next()) {\n                 PrimaryKey pk = new PrimaryKey();\n-                pk.setSchemaName(schemaName);\n-                pk.setTableName(tableName);\n-                pk.setColumnName(pks.getString(\"COLUMN_NAME\"));\n+                pk.setSchemaIdentifier(schemaName);\n+                pk.setTableIdentifier(tableName);\n+                pk.setColumnIdentifier(fromDBName(pks.getString(\"COLUMN_NAME\"), DBIdentifierType.COLUMN));\n                 pkList.add(pk);\n             }\n             return (PrimaryKey[]) pkList.toArray\n@@ -4090,11 +4181,24 @@ protected PrimaryKey newPrimaryKey(ResultSet pkMeta)\n \n     /**\n      * Reflect on the schema to find indexes matching the given table pattern.\n+     * @deprecated\n      */\n     public Index[] getIndexInfo(DatabaseMetaData meta, String catalog,\n         String schemaName, String tableName, boolean unique,\n         boolean approx, Connection conn)\n         throws SQLException {\n+        return getIndexInfo(meta, DBIdentifier.newCatalog(catalog), \n+            DBIdentifier.newSchema(schemaName), DBIdentifier.newTable(tableName), unique,\n+            approx, conn);\n+    }\n+\n+    /**\n+     * Reflect on the schema to find indexes matching the given table pattern.\n+     */\n+    public Index[] getIndexInfo(DatabaseMetaData meta, DBIdentifier catalog,\n+        DBIdentifier schemaName, DBIdentifier tableName, boolean unique,\n+        boolean approx, Connection conn)\n+        throws SQLException {\n         if (tableName == null && !supportsNullTableForGetIndexInfo)\n             return null;\n \n@@ -4124,30 +4228,53 @@ protected PrimaryKey newPrimaryKey(ResultSet pkMeta)\n     protected Index newIndex(ResultSet idxMeta)\n         throws SQLException {\n         Index idx = new Index();\n-        idx.setSchemaName(idxMeta.getString(\"TABLE_SCHEM\"));\n-        idx.setTableName(idxMeta.getString(\"TABLE_NAME\"));\n-        idx.setColumnName(idxMeta.getString(\"COLUMN_NAME\"));\n-        idx.setName(idxMeta.getString(\"INDEX_NAME\"));\n+        idx.setSchemaIdentifier(fromDBName(idxMeta.getString(\"TABLE_SCHEM\"), DBIdentifierType.SCHEMA));\n+        idx.setTableIdentifier(fromDBName(idxMeta.getString(\"TABLE_NAME\"), DBIdentifierType.TABLE));\n+        idx.setColumnIdentifier(fromDBName(idxMeta.getString(\"COLUMN_NAME\"), DBIdentifierType.COLUMN));\n+        idx.setIdentifier(fromDBName(idxMeta.getString(\"INDEX_NAME\"), DBIdentifierType.INDEX));\n         idx.setUnique(!idxMeta.getBoolean(\"NON_UNIQUE\"));\n         return idx;\n     }\n \n     /**\n      * Reflect on the schema to return foreign keys imported by the given\n      * table pattern.\n+     * @deprecated\n      */\n     public ForeignKey[] getImportedKeys(DatabaseMetaData meta, String catalog,\n         String schemaName, String tableName, Connection conn)\n         throws SQLException {\n         return getImportedKeys(meta, catalog, schemaName, tableName, conn, true);\n     }\n \n+    /**\n+     * Reflect on the schema to return foreign keys imported by the given\n+     * table pattern.\n+     */\n+    public ForeignKey[] getImportedKeys(DatabaseMetaData meta, DBIdentifier catalog,\n+        DBIdentifier schemaName, DBIdentifier tableName, Connection conn)\n+        throws SQLException {\n+        return getImportedKeys(meta, catalog, schemaName, tableName, conn, true);\n+    }\n+\n     /**\n      * Reflect on the schema to return full foreign keys imported by the given\n      * table pattern.\n+     * @deprecated\n      */\n     public ForeignKey[] getImportedKeys(DatabaseMetaData meta, String catalog,\n-        String schemaName, String tableName, Connection conn, boolean partialKeys)\n+        String schemaName, String tableName, Connection conn, boolean partialKeys) \n+        throws SQLException {\n+        return getImportedKeys(meta, DBIdentifier.newCatalog(catalog), \n+            DBIdentifier.newSchema(schemaName), DBIdentifier.newTable(tableName), conn, partialKeys);\n+    }\n+    \n+    /**\n+     * Reflect on the schema to return full foreign keys imported by the given\n+     * table pattern.\n+     */\n+    public ForeignKey[] getImportedKeys(DatabaseMetaData meta, DBIdentifier catalog,\n+        DBIdentifier schemaName, DBIdentifier tableName, Connection conn, boolean partialKeys)\n         throws SQLException {\n         if (!supportsForeignKeys)\n             return null;\n@@ -4212,13 +4339,13 @@ protected ForeignKey combineForeignKey(Map<FKMapKey, ForeignKey> fkMap,\n     protected ForeignKey newForeignKey(ResultSet fkMeta)\n         throws SQLException {\n         ForeignKey fk = new ForeignKey();\n-        fk.setSchemaName(fkMeta.getString(\"FKTABLE_SCHEM\"));\n-        fk.setTableName(fkMeta.getString(\"FKTABLE_NAME\"));\n-        fk.setColumnName(fkMeta.getString(\"FKCOLUMN_NAME\"));\n-        fk.setName(fkMeta.getString(\"FK_NAME\"));\n-        fk.setPrimaryKeySchemaName(fkMeta.getString(\"PKTABLE_SCHEM\"));\n-        fk.setPrimaryKeyTableName(fkMeta.getString(\"PKTABLE_NAME\"));\n-        fk.setPrimaryKeyColumnName(fkMeta.getString(\"PKCOLUMN_NAME\"));\n+        fk.setSchemaIdentifier(fromDBName(fkMeta.getString(\"FKTABLE_SCHEM\"), DBIdentifierType.SCHEMA));\n+        fk.setTableIdentifier(fromDBName(fkMeta.getString(\"FKTABLE_NAME\"), DBIdentifierType.TABLE));\n+        fk.setColumnIdentifier(fromDBName(fkMeta.getString(\"FKCOLUMN_NAME\"), DBIdentifierType.COLUMN));\n+        fk.setIdentifier(fromDBName(fkMeta.getString(\"FK_NAME\"), DBIdentifierType.FOREIGN_KEY));\n+        fk.setPrimaryKeySchemaIdentifier(fromDBName(fkMeta.getString(\"PKTABLE_SCHEM\"), DBIdentifierType.SCHEMA));\n+        fk.setPrimaryKeyTableIdentifier(fromDBName(fkMeta.getString(\"PKTABLE_NAME\"), DBIdentifierType.TABLE));\n+        fk.setPrimaryKeyColumnIdentifier(fromDBName(fkMeta.getString(\"PKCOLUMN_NAME\"), DBIdentifierType.COLUMN));\n         fk.setKeySequence(fkMeta.getShort(\"KEY_SEQ\"));\n         fk.setDeferred(fkMeta.getShort(\"DEFERRABILITY\")\n             == DatabaseMetaData.importedKeyInitiallyDeferred);\n@@ -4246,7 +4373,15 @@ protected ForeignKey newForeignKey(ResultSet fkMeta)\n      * from {@link DatabaseMetaData}.\n      */\n     protected String getTableNameForMetadata(String tableName) {\n-        return convertSchemaCase(tableName);\n+        return convertSchemaCase(DBIdentifier.newTable(tableName));\n+    }\n+\n+    /**\n+     * Returns the table name that will be used for obtaining information\n+     * from {@link DatabaseMetaData}.\n+     */\n+    protected String getTableNameForMetadata(DBIdentifier tableName) {\n+        return convertSchemaCase(tableName.getUnqualifiedName());\n     }\n \n     /**\n@@ -4256,6 +4391,16 @@ protected String getTableNameForMetadata(String tableName) {\n     protected String getSchemaNameForMetadata(String schemaName) {\n         if (schemaName == null)\n             schemaName = conf.getSchema();\n+        return convertSchemaCase(DBIdentifier.newSchema(schemaName));\n+    }\n+\n+    /**\n+     * Returns the schema name that will be used for obtaining information\n+     * from {@link DatabaseMetaData}.\n+     */\n+    protected String getSchemaNameForMetadata(DBIdentifier schemaName) {\n+        if (DBIdentifier.isNull(schemaName))\n+            schemaName = DBIdentifier.newSchema(conf.getSchema());\n         return convertSchemaCase(schemaName);\n     }\n \n@@ -4264,6 +4409,14 @@ protected String getSchemaNameForMetadata(String schemaName) {\n      * from {@link DatabaseMetaData}.\n      */\n     protected String getCatalogNameForMetadata(String catalogName) {\n+        return convertSchemaCase(DBIdentifier.newCatalog(catalogName));\n+    }\n+\n+    /**\n+     * Returns the catalog name that will be used for obtaining information\n+     * from {@link DatabaseMetaData}.\n+     */\n+    protected String getCatalogNameForMetadata(DBIdentifier catalogName) {\n         return convertSchemaCase(catalogName);\n     }\n \n@@ -4272,6 +4425,14 @@ protected String getCatalogNameForMetadata(String catalogName) {\n      * from {@link DatabaseMetaData}.\n      */\n     protected String getColumnNameForMetadata(String columnName) {\n+        return convertSchemaCase(DBIdentifier.newColumn(columnName));\n+    }\n+\n+    /**\n+     * Returns the column name that will be used for obtaining information\n+     * from {@link DatabaseMetaData}.\n+     */\n+    protected String getColumnNameForMetadata(DBIdentifier columnName) {\n         return convertSchemaCase(columnName);\n     }\n \n@@ -4280,28 +4441,15 @@ protected String getColumnNameForMetadata(String columnName) {\n      * be able to understand.\n      */\n     public String convertSchemaCase(String objectName) {\n-        if (objectName == null)\n-            return null;\n+        return convertSchemaCase(DBIdentifier.newIdentifier(objectName, DBIdentifierType.DEFAULT, false));\n+    }\n \n-        // Handle delimited string differently. Return unquoted name.\n-        if (isDelimitIds() || isDelimited(objectName)) {\n-            String delimCase = getDelimitedCase();\n-            if (SCHEMA_CASE_UPPER.equals(delimCase)) {\n-                objectName.toUpperCase();\n-            }\n-            else if (SCHEMA_CASE_LOWER.equals(delimCase)) {\n-                objectName.toLowerCase();\n-            }\n-            \n-            return stripDelimiters(objectName);\n-        }\n-        \n-        String scase = getSchemaCase();\n-        if (SCHEMA_CASE_LOWER.equals(scase))\n-            return objectName.toLowerCase();\n-        if (SCHEMA_CASE_PRESERVE.equals(scase))\n-            return objectName;\n-        return objectName.toUpperCase();\n+    /**\n+     * Convert the specified schema name to a name that the database will\n+     * be able to understand.\n+     */\n+    public String convertSchemaCase(DBIdentifier objectName) {\n+        return toDBName(namingUtil.convertSchemaCase(objectName), false);\n     }\n     \n     /**\n@@ -4346,7 +4494,7 @@ public Object getGeneratedKey(Column col, Connection conn)\n         if (query.indexOf('{') != -1) // only if the token is in the string\n         {\n             query = MessageFormat.format(query, new Object[]{\n-                col.getName(), getFullName(col.getTable(), false),\n+                toDBName(col.getIdentifier()), getFullName(col.getTable(), false),\n                 getGeneratedKeySequenceName(col),\n             });\n         }\n@@ -4371,18 +4519,7 @@ public Object getGeneratedKey(Column col, Connection conn)\n      * to be used for auto-assign support.\n      */\n     protected String getGeneratedKeySequenceName(Column col) {\n-        String tname = col.getTableName();\n-        String cname = col.getName();\n-        int max = maxAutoAssignNameLength;\n-        int extraChars = -max + tname.length() + 1 // <tname> + '_'\n-            + cname.length() + 4; // <cname> + '_SEQ'\n-        if (extraChars > 0) {\n-            // this assumes that tname is longer than extraChars\n-            tname = tname.substring(0, tname.length() - extraChars);\n-        }\n-        StringBuilder buf = new StringBuilder(max);\n-        buf.append(tname).append(\"_\").append(cname).append(\"_SEQ\");\n-        return buf.toString();\n+        return toDBName(namingUtil.getGeneratedKeySequenceName(col, maxAutoAssignNameLength));\n     }\n \n     ///////////////////////////////\n@@ -4393,6 +4530,11 @@ public void setConfiguration(Configuration conf) {\n         this.conf = (JDBCConfiguration) conf;\n         this.log = this.conf.getLog(JDBCConfiguration.LOG_JDBC);\n \n+        // Create the naming utility\n+        namingUtil = this.conf.getIdentifierUtilInstance();\n+        namingUtil.setIdentifierConfiguration(this);\n+        configureNamingRules();\n+\n         // warn about unsupported dicts\n         if (log.isWarnEnabled() && !isSupported())\n             log.warn(_loc.get(\"dict-not-supported\", getClass()));\n@@ -4735,7 +4877,11 @@ public SerializedData(byte[] bytes) {\n      * @return\n      */\n     public String getVersionColumn(Column column, String tableAlias) {\n-        return column.toString();\n+        return getVersionColumn(column, DBIdentifier.newTable(tableAlias)).toString();\n+    }\n+\n+    public DBIdentifier getVersionColumn(Column column, DBIdentifier tableAlias) {\n+        return column.getIdentifier();\n     }\n     \n     public void insertBlobForStreamingLoad(Row row, Column col, \n@@ -4879,10 +5025,15 @@ public String getCastFunction(Val val, String func, Column col) {\n     \n     /**\n      * Create an index if necessary for some database tables\n+     * @deprecated\n      */\n     public void createIndexIfNecessary(Schema schema, String table,\n             Column pkColumn) {\n     }\n+\n+    public void createIndexIfNecessary(Schema schema, DBIdentifier table,\n+        Column pkColumn) {\n+    }\n     \n     /**\n      * Return the batchLimit\n@@ -5011,7 +5162,7 @@ public boolean needsToCreateIndex(Index idx, Table table) {\n     }\n \n     /**\n-     * Return batched statements update succes count\n+     * Return batched statements update success count\n      * @param ps A PreparedStatement\n      * @return return update count\n      */\n@@ -5042,68 +5193,6 @@ final String checkNameLength(String name, int length, String msgKey) {\n                     length));\n         return name;\n     }\n-    \n-    public String delimitString(String name, DBIdentifiers type) {\n-        if (StringUtils.isEmpty(name) || type == null) {\n-            return name;\n-        }\n-        \n-        if (!getSupportsDelimitedIds()) {\n-            // TODO: log (or maybe log in the method itself; so maybe\n-            // merge with next if stmt\n-            return name;\n-        }\n-        \n-        if (!isDelimitIds()) {\n-            return convertQuotes(name);\n-        }\n-        // TODO: merge with if stmt above (maybe not, may want to log this)\n-        if (!supportsDelimitedId(type)) {\n-            // TODO: log\n-            return name;\n-        }\n-        return addDelimiters(name);\n-    }\n-    \n-    public void delimitArray(String[] names, DBIdentifiers type) {\n-//        String[] delimNames = new String[names.length];\n-        for (int i = 0; i < names.length; i++) {\n-            names[i] = delimitString(names[i], type);\n-        }\n-    }\n-    \n-    private String convertQuotes(String name) {\n-        if (name.startsWith(\"\\\"\") && name.endsWith(\"\\\"\")) {\n-            return getDelimiter() + name.substring(1, name.length() - 1) + getDelimiter();\n-        }\n-        \n-        return name;\n-    }\n-\n-    /**\n-     * @return the unsupportedDelimitedIds\n-     */\n-    protected EnumSet<DBIdentifiers> getUnsupportedDelimitedIds() {\n-        return unsupportedDelimitedIds;\n-    }\n-    \n-    protected boolean supportsDelimitedId(DBIdentifiers type) {\n-        if (getUnsupportedDelimitedIds().contains(type)) {\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * @return the delimiter\n-     */\n-    public String getDelimiter() {\n-        return delimiter;\n-    }\n-    \n-    protected String getDelimitedCase() {\n-        return delimitedCase;\n-    }\n \n     protected void setDelimitedCase(DatabaseMetaData metaData) {\n         try {\n@@ -5117,41 +5206,45 @@ else if (metaData.storesLowerCaseQuotedIdentifiers()) {\n                 delimitedCase = SCHEMA_CASE_LOWER;\n             }\n         } catch (SQLException e) {\n-            // TODO log this\n+            getLog().warn(\"cannot-determine-identifier-case\");\n+            if (getLog().isTraceEnabled()) {\n+                getLog().trace(e.toString(), e);\n+            }\n         }\n     }\n     \n     /**\n      * @return the supportsDelimitedIds\n      */\n-    public boolean getSupportsDelimitedIds() {\n-        return supportsDelimitedIds;\n+    public boolean getSupportsDelimitedIdentifiers() {\n+        return supportsDelimitedIdentifiers;\n     }\n \n     /**\n      * @param supportsDelimitedIds the supportsDelimitedIds to set\n      */\n-    public void setSupportsDelimitedIds(DatabaseMetaData metaData) {\n+    public void setSupportsDelimitedIdentifiers(DatabaseMetaData metaData) {\n         try {\n-            supportsDelimitedIds = \n+            supportsDelimitedIdentifiers = \n                 metaData.supportsMixedCaseQuotedIdentifiers();\n         } catch (SQLException e) {\n-            // TODO log this, or should we throw an exception?\n+            supportsDelimitedIdentifiers = false;\n+            getLog().warn(_loc.get(\"unknown-delim-support\", e));\n         }\n     }\n \n     /**\n      * @return the delimitIds\n      */\n-    public boolean isDelimitIds() {\n-        return delimitIds;\n+    public boolean getDelimitIdentifiers() {\n+        return delimitIdentifiers;\n     }\n \n     /**\n      * @param delimitIds the delimitIds to set\n      */\n-    public void setDelimitIds(boolean delimitIds) {\n-        this.delimitIds = delimitIds;\n+    public void setDelimitIdentifiers(boolean delimitIds) {\n+        delimitIdentifiers = delimitIds;\n     }\n     \n     /**\n@@ -5181,39 +5274,84 @@ public String getXMLTypeEncoding() {\n     public void setXMLTypeEncoding(String encoding) {\n         xmlTypeEncoding = encoding;\n     }\n+\n+    public Log getLog() { \n+        return log;\n+    }\n+\n+    public boolean delimitAll() {\n+        return delimitIdentifiers;\n+    }\n+\n+    public String getLeadingDelimiter() {\n+        return leadingDelimiter;\n+    }\n+\n+    public void setLeadingDelimiter(String delim) {\n+        leadingDelimiter = delim;\n+    }\n+\n+    public String getIdentifierDelimiter() {\n+        return catalogSeparator;\n+    }\n+\n+    public String getIdentifierConcatenator() {\n+        return nameConcatenator;\n+    }\n     \n-    /**\n-     * Combine a number of names into 1 name with each part separated by an underscore (\"_\").\n-     * If a name part is delimited, remove the delimiters.\n-     * @param names\n-     * @return combined name\n-     */\n-    public String combineNames(String... names) {\n-        boolean delimited = false;\n-        String combined = null;\n-        for (int i = 0; i < names.length; i++) {\n-            String name = names[i];\n-            if (isDelimited(name)) {\n-                delimited = true;\n-                name = stripDelimiters(name);\n-            }\n-            if (i == 0) {\n-                combined = name;\n-            }\n-            else {\n-                combined = combined + \"_\" + name;\n-            }\n+    public String getTrailingDelimiter() {\n+        return trailingDelimiter;\n+    }\n+\n+    public void setTrailingDelimiter(String delim) {\n+        trailingDelimiter = delim;\n+    }\n+\n+    public IdentifierRule getDefaultIdentifierRule() {\n+        if (defaultNamingRule == null) {\n+            defaultNamingRule = namingRules.get(DBIdentifierType.DEFAULT.name());\n         }\n-        \n-        if (delimited) {\n-            combined = addDelimiters(combined);\n+        return defaultNamingRule;\n+    }\n+\n+    public <T> IdentifierRule getIdentifierRule(T t) {\n+        if (t.equals(DBIdentifierType.DEFAULT.name())) {\n+            return getDefaultIdentifierRule();\n         }\n-        \n-        return combined;\n+        IdentifierRule nrule = namingRules.get(t);\n+        if (nrule == null) {\n+            return getDefaultIdentifierRule();\n+        }\n+        return nrule;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Map<String, IdentifierRule> getIdentifierRules() {\n+        return namingRules;\n+    }\n+\n+    /**\n+     * Returns the naming utility used by this dictionary instance\n+     * @return\n+     */\n+    public DBIdentifierUtil getNamingUtil() {\n+        return namingUtil;\n     }\n     \n-    public Log getLog() { \n-        return log;\n+    public String getDelimitedCase() {\n+        return delimitedCase;\n+    }\n+\n+    public String toDBName(DBIdentifier name) {\n+        return getNamingUtil().toDBName(name);\n+    }\n+\n+    public String toDBName(DBIdentifier name, boolean delimit) {\n+        return getNamingUtil().toDBName(name, delimit);\n+    }\n+\n+    public DBIdentifier fromDBName(String name, DBIdentifierType id) {\n+        return getNamingUtil().fromDBName(name, id);\n     }\n     \n     public void setDefaultSchemaName(String defaultSchemaName) {"},{"sha":"b9b589d95f1ba96e806c00c64de0d017b183f1d4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/EmpressDictionary.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/EmpressDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/EmpressDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/EmpressDictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -135,7 +135,8 @@ public SQLBuffer toSelect(SQLBuffer selects, JDBCFetchConfiguration fetch,\n         // empress wants dropped columns in the form: ALTER TABLE foo\n         // DELETE columnToDrop\n         return new String[]{ \"ALTER TABLE \"\n-            + getFullName(column.getTable(), false) + \" DELETE \" + column };\n+            + getFullName(column.getTable(), false) + \" DELETE \" + \n+            getColumnDBName(column) };\n     }\n \n     public void setFloat(PreparedStatement stmnt, int idx, float val,"},{"sha":"4eebd4cf6bd7d3c71172cae2634afaa78d6f7fb2","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FirebirdDictionary.java","status":"modified","additions":18,"deletions":4,"changes":22,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FirebirdDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FirebirdDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FirebirdDictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -29,12 +29,14 @@\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n import org.apache.openjpa.jdbc.schema.Index;\n import org.apache.openjpa.jdbc.schema.Sequence;\n import org.apache.openjpa.jdbc.schema.Unique;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.util.UnsupportedException;\n \n@@ -285,8 +287,15 @@ public String getPlaceholderValueString(Column col) {\n      */\n     @Override\n     protected String getTableNameForMetadata(String tableName) {\n-        return (tableName == null) ? \"%\" : super\n-            .getTableNameForMetadata(tableName);\n+        return (tableName == null) ? IdentifierUtil.PERCENT : \n+            getTableNameForMetadata(DBIdentifier.newTable(tableName));\n+    }\n+\n+    protected String getTableNameForMetadata(DBIdentifier tableName) {\n+        if (DBIdentifier.isNull(tableName)) {\n+            return IdentifierUtil.PERCENT;\n+        }\n+        return super.getTableNameForMetadata(tableName);\n     }\n \n     /**\n@@ -306,7 +315,7 @@ protected String getColumnNameForMetadata(String columnName) {\n     @Override\n     public String[] getDropColumnSQL(Column column) {\n         return new String[] { \"ALTER TABLE \"\n-            + getFullName(column.getTable(), false) + \" DROP \" + column };\n+            + getFullName(column.getTable(), false) + \" DROP \" + getColumnDBName(column) };\n     }\n \n     /**\n@@ -338,6 +347,11 @@ protected String getColumnNameForMetadata(String columnName) {\n      */\n     @Override\n     protected String getSequencesSQL(String schemaName, String sequenceName) {\n+        return getSequencesSQL(DBIdentifier.newSchema(schemaName), DBIdentifier.newSequence(sequenceName));\n+    }\n+\n+    @Override\n+    protected String getSequencesSQL(DBIdentifier schemaName, DBIdentifier sequenceName) {\n         StringBuilder buf = new StringBuilder(sequenceSQL);\n         if (sequenceName != null)\n             buf.append(sequenceNameSQL);\n@@ -354,7 +368,7 @@ protected String getSequencesSQL(String schemaName, String sequenceName) {\n     @Override\n     protected Sequence newSequence(ResultSet sequenceMeta) throws SQLException {\n         Sequence seq = super.newSequence(sequenceMeta);\n-        seq.setName(seq.getName().trim());\n+        seq.setIdentifier(DBIdentifier.trim(seq.getIdentifier()));\n         return seq;\n     }\n "},{"sha":"9966163936e997576bd4749a407e61a64bfa1491","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FoxProDictionary.java","status":"modified","additions":25,"deletions":1,"changes":26,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FoxProDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FoxProDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/FoxProDictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -25,6 +25,7 @@\n import java.sql.SQLException;\n import java.sql.Types;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.Index;\n import org.apache.openjpa.jdbc.schema.PrimaryKey;\n@@ -83,6 +84,7 @@ public FoxProDictionary() {\n         characterColumnSize = 240;\n     }\n \n+    @Override\n     public String getString(ResultSet rs, int column)\n         throws SQLException {\n         // foxpro doesn't auto-truncate values.\n@@ -92,6 +94,7 @@ public String getString(ResultSet rs, int column)\n         return str;\n     }\n \n+    @Override\n     public void setNull(PreparedStatement stmnt, int idx, int colType,\n         Column col)\n         throws SQLException {\n@@ -108,6 +111,7 @@ public void setNull(PreparedStatement stmnt, int idx, int colType,\n         }\n     }\n \n+    @Override\n     protected String appendSize(Column col, String typeName) {\n         // foxpro does not like unsized column declarations.\n         if (col.getSize() == 0) {\n@@ -119,19 +123,30 @@ else if (\"NUMERIC\".equals(typeName))\n         return super.appendSize(col, typeName);\n     }\n \n+    @Override\n     protected String getPrimaryKeyConstraintSQL(PrimaryKey pk) {\n         // this foxpro driver combination does not support primary keys\n         return null;\n     }\n \n+    @Override\n     public String[] getCreateIndexSQL(Index index) {\n         // foxpro JDBC access does not allow the creation of indexes\n         return new String[0];\n     }\n \n+    @Override\n     public Column[] getColumns(DatabaseMetaData meta, String catalog,\n         String schemaName, String tableName, String columnName, Connection conn)\n         throws SQLException {\n+        return getColumns(meta, DBIdentifier.newCatalog(catalog), DBIdentifier.newSchema(schemaName),\n+            DBIdentifier.newTable(tableName), DBIdentifier.newColumn(columnName), conn);\n+    }\n+    \n+    @Override\n+    public Column[] getColumns(DatabaseMetaData meta, DBIdentifier catalog,\n+        DBIdentifier schemaName, DBIdentifier tableName, DBIdentifier columnName, Connection conn)\n+        throws SQLException {\n         try {\n             Column[] cols = super.getColumns(meta, catalog, schemaName,\n                 tableName, columnName, conn);\n@@ -140,7 +155,7 @@ protected String getPrimaryKeyConstraintSQL(PrimaryKey pk) {\n                 if (cols[i].getType() == 11)\n                     cols[i].setType(Types.TIMESTAMP);\n                     // MEMO maps to LONGVARCHAR during reverse analysis\n-                else if (\"MEMO\".equals(cols[i].getTypeName()))\n+                else if (\"MEMO\".equals(cols[i].getTypeIdentifier().getName()))\n                     cols[i].setType(Types.CLOB);\n             }\n             return cols;\n@@ -153,10 +168,19 @@ else if (\"MEMO\".equals(cols[i].getTypeName()))\n         }\n     }\n \n+    @Override\n     public PrimaryKey[] getPrimaryKeys(DatabaseMetaData meta, String catalog,\n         String schemaName, String tableName, Connection conn)\n         throws SQLException {\n         // this combination does not reliably return PK information\n         return null;\n     }\n+\n+    @Override\n+    public PrimaryKey[] getPrimaryKeys(DatabaseMetaData meta, DBIdentifier catalog,\n+        DBIdentifier schemaName, DBIdentifier tableName, Connection conn)\n+        throws SQLException {\n+        // this combination does not reliably return PK information\n+        return null;\n+    }\n }"},{"sha":"8006a64864b73974dfd36bcea04704517046df97","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/H2Dictionary.java","status":"modified","additions":36,"deletions":4,"changes":40,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/H2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/H2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/H2Dictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -28,6 +28,7 @@\n import java.util.Locale;\n \n import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.PrimaryKey;\n@@ -87,6 +88,7 @@ public H2Dictionary() {\n             }));\n     }\n \n+    @Override\n     public int getJDBCType(int metaTypeCode, boolean lob) {\n         int type = super.getJDBCType(metaTypeCode, lob);\n         switch (type) {\n@@ -98,25 +100,30 @@ public int getJDBCType(int metaTypeCode, boolean lob) {\n         return type;\n     }\n \n+    @Override\n     public int getPreferredType(int type) {\n         return super.getPreferredType(type);\n     }\n \n+    @Override\n     public String[] getAddPrimaryKeySQL(PrimaryKey pk) {\n         return new String[0];\n     }\n \n+    @Override\n     public String[] getDropPrimaryKeySQL(PrimaryKey pk) {\n         return new String[0];\n     }\n \n+    @Override\n     public String[] getAddColumnSQL(Column column) {\n         return new String[] { \n             \"ALTER TABLE \" + getFullName(column.getTable(), false) \n                 + \" ADD COLUMN \" + getDeclareColumnSQL(column, true) \n         };\n     }\n \n+    @Override\n     public String[] getCreateTableSQL(Table table) {\n         StringBuilder buf = new StringBuilder();\n         buf.append(\"CREATE TABLE \").append(getFullName(table, false))\n@@ -149,6 +156,7 @@ public int getPreferredType(int type) {\n         return new String[] { buf.toString() };\n     }\n \n+    @Override\n     protected String getPrimaryKeyConstraintSQL(PrimaryKey pk) {\n         Column[] cols = pk.getColumns();\n         if (cols.length == 1 && cols[0].isAutoAssigned())\n@@ -160,30 +168,53 @@ public boolean isSystemIndex(String name, Table table) {\n         return name.toUpperCase(Locale.ENGLISH).startsWith(\"SYSTEM_\");\n     }\n \n+    public boolean isSystemIndex(DBIdentifier name, Table table) {\n+        if (DBIdentifier.isNull(name)) {\n+            return false;\n+        }\n+        return name.getName().toUpperCase(Locale.ENGLISH).startsWith(\"SYSTEM_\");\n+    }\n+    \n+    @Override\n     protected String getSequencesSQL(String schemaName, String sequenceName) {\n+        return getSequencesSQL(DBIdentifier.newSchema(schemaName), DBIdentifier.newSequence(sequenceName));\n+    }\n+\n+    @Override\n+    protected String getSequencesSQL(DBIdentifier schemaName, DBIdentifier sequenceName) {\n         StringBuilder buf = new StringBuilder();\n         buf.append(\"SELECT SEQUENCE_SCHEMA, SEQUENCE_NAME FROM \")\n             .append(\"INFORMATION_SCHEMA.SEQUENCES\");\n-        if (schemaName != null || sequenceName != null)\n+        if (!DBIdentifier.isNull(schemaName) || !DBIdentifier.isNull(sequenceName))\n             buf.append(\" WHERE \");\n-        if (schemaName != null) {\n+        if (!DBIdentifier.isNull(schemaName)) {\n             buf.append(\"SEQUENCE_SCHEMA = ?\");\n-            if (sequenceName != null)\n+            if (!DBIdentifier.isNull(sequenceName))\n                 buf.append(\" AND \");\n         }\n-        if (sequenceName != null)\n+        if (!DBIdentifier.isNull(sequenceName))\n             buf.append(\"SEQUENCE_NAME = ?\");\n         return buf.toString();\n     }\n \n+    @Override\n     public Column[] getColumns(DatabaseMetaData meta, String catalog,\n         String schemaName, String tableName, String columnName, Connection conn)\n         throws SQLException {\n+        return getColumns(meta, DBIdentifier.newCatalog(catalog), DBIdentifier.newSchema(schemaName),\n+            DBIdentifier.newTable(tableName), DBIdentifier.newColumn(columnName), conn);\n+    }\n+\n+    @Override\n+    public Column[] getColumns(DatabaseMetaData meta, DBIdentifier catalog,\n+        DBIdentifier schemaName, DBIdentifier tableName, DBIdentifier columnName, Connection conn)\n+        throws SQLException {\n         Column[] cols = super.getColumns(meta, catalog, schemaName, tableName, \n             columnName, conn);\n         return cols;\n     }\n \n+    @Override\n     protected void appendSelectRange(SQLBuffer buf, long start, long end,\n         boolean subselect) {\n         if (end != Long.MAX_VALUE)\n@@ -192,6 +223,7 @@ protected void appendSelectRange(SQLBuffer buf, long start, long end,\n             buf.append(\" OFFSET \").appendValue(start);\n     }\n \n+    @Override\n     public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n         FilterValue start) {\n         buf.append(\"(POSITION(\");"},{"sha":"d8e4635354b079f32e5899e7941d95df3cd26ce3","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/HSQLDictionary.java","status":"modified","additions":26,"deletions":1,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/HSQLDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/HSQLDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/HSQLDictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -28,6 +28,7 @@\n \n import org.apache.commons.lang.StringUtils;\n import org.hsqldb.Trace;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.PrimaryKey;\n@@ -97,6 +98,7 @@ public HSQLDictionary() {\n         }));\n     }\n \n+    @Override\n     public int getJDBCType(int metaTypeCode, boolean lob) {\n         int type = super.getJDBCType(metaTypeCode, lob);\n         switch (type) {\n@@ -108,6 +110,7 @@ public int getJDBCType(int metaTypeCode, boolean lob) {\n         return type;\n     }\n \n+    @Override\n     public int getPreferredType(int type) {\n         switch (type) {\n             case Types.CLOB:\n@@ -119,20 +122,24 @@ public int getPreferredType(int type) {\n         }\n     }\n \n+    @Override\n     public String[] getAddPrimaryKeySQL(PrimaryKey pk) {\n         return new String[0];\n     }\n \n+    @Override\n     public String[] getDropPrimaryKeySQL(PrimaryKey pk) {\n         return new String[0];\n     }\n \n+    @Override\n     public String[] getAddColumnSQL(Column column) {\n         return new String[]{ \"ALTER TABLE \"\n             + getFullName(column.getTable(), false)\n             + \" ADD COLUMN \" + getDeclareColumnSQL(column, true) };\n     }\n \n+    @Override\n     public String[] getCreateTableSQL(Table table) {\n         StringBuilder buf = new StringBuilder();\n         buf.append(\"CREATE \");\n@@ -167,6 +174,7 @@ public int getPreferredType(int type) {\n         return new String[]{ buf.toString() };\n     }\n \n+    @Override\n     protected String getPrimaryKeyConstraintSQL(PrimaryKey pk) {\n         Column[] cols = pk.getColumns();\n         if (cols.length == 1 && cols[0].isAutoAssigned())\n@@ -178,6 +186,15 @@ public boolean isSystemIndex(String name, Table table) {\n         return name.toUpperCase().startsWith(\"SYS_\");\n     }\n \n+    @Override\n+    public boolean isSystemIndex(DBIdentifier name, Table table) {\n+        if (DBIdentifier.isNull(name)) {\n+            return false;\n+        }\n+        return name.getName().toUpperCase().startsWith(\"SYS_\");\n+    }\n+\n+    @Override\n     protected String getSequencesSQL(String schemaName, String sequenceName) {\n         StringBuilder buf = new StringBuilder();\n         buf.append(\"SELECT SEQUENCE_SCHEMA, SEQUENCE_NAME FROM \").\n@@ -194,6 +211,7 @@ protected String getSequencesSQL(String schemaName, String sequenceName) {\n         return buf.toString();\n     }\n \n+    @Override\n     public SQLBuffer toOperation(String op, SQLBuffer selects,\n         SQLBuffer from, SQLBuffer where, SQLBuffer group, SQLBuffer having,\n         SQLBuffer order, boolean distinct, long start, long end,\n@@ -206,18 +224,20 @@ public SQLBuffer toOperation(String op, SQLBuffer selects,\n             order, distinct, start, end, forUpdateClause);\n     }\n \n+    @Override\n     public Column[] getColumns(DatabaseMetaData meta, String catalog,\n         String schemaName, String tableName, String columnName, Connection conn)\n         throws SQLException {\n         Column[] cols = super.getColumns(meta, catalog, schemaName, tableName,\n             columnName, conn);\n \n         for (int i = 0; cols != null && i < cols.length; i++)\n-            if (\"BOOLEAN\".equalsIgnoreCase(cols[i].getTypeName()))\n+            if (\"BOOLEAN\".equalsIgnoreCase(cols[i].getTypeIdentifier().getName()))\n                 cols[i].setType(Types.BIT);\n         return cols;\n     }\n \n+    @Override\n     public void setDouble(PreparedStatement stmnt, int idx, double val,\n         Column col)\n         throws SQLException {\n@@ -230,6 +250,7 @@ public void setDouble(PreparedStatement stmnt, int idx, double val,\n         }\n     }\n \n+    @Override\n     public void setBigDecimal(PreparedStatement stmnt, int idx, BigDecimal val,\n         Column col)\n         throws SQLException {\n@@ -251,6 +272,7 @@ public void setBigDecimal(PreparedStatement stmnt, int idx, BigDecimal val,\n         }\n     }\n \n+    @Override\n     protected void appendSelectRange(SQLBuffer buf, long start, long end,\n         boolean subselect) {\n         // HSQL doesn't parameters in range\n@@ -261,6 +283,7 @@ protected void appendSelectRange(SQLBuffer buf, long start, long end,\n             buf.append(String.valueOf(end - start));\n     }\n \n+    @Override\n     public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n         FilterValue start) {\n         buf.append(\"(LOCATE(\");\n@@ -275,6 +298,7 @@ public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n         buf.append(\") - 1)\");\n     }\n \n+    @Override\n     public String getPlaceholderValueString(Column col) {\n         String type = getTypeName(col.getType());\n         int idx = type.indexOf(\"{0}\");\n@@ -288,6 +312,7 @@ public String getPlaceholderValueString(Column col) {\n         return \"NULL AS \" + type;\n     }\n \n+    @Override\n     public OpenJPAException newStoreException(String msg, SQLException[] causes,\n         Object failed) {\n         OpenJPAException ke = super.newStoreException(msg, causes, failed);"},{"sha":"9722fe408142c6e87adbef98b88ac17a2895a010","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java","status":"modified","additions":18,"deletions":3,"changes":21,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InformixDictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -29,6 +29,7 @@\n import java.util.Collection;\n import java.util.Set;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n@@ -154,6 +155,7 @@ public InformixDictionary() {\n         trimSchemaName = true;\n     }\n \n+    @Override\n     public void connectedConfiguration(Connection conn)\n         throws SQLException {\n         super.connectedConfiguration(conn);\n@@ -185,6 +187,7 @@ public void connectedConfiguration(Connection conn)\n         }\n     }\n \n+    @Override\n     public Column[] getColumns(DatabaseMetaData meta, String catalog,\n         String schemaName, String tableName, String columnName, Connection conn)\n         throws SQLException {\n@@ -198,30 +201,34 @@ public void connectedConfiguration(Connection conn)\n         return cols;\n     }\n \n+    @Override\n     public Column newColumn(ResultSet colMeta)\n         throws SQLException {\n         Column col = super.newColumn(colMeta);\n         if (swapSchemaAndCatalog)\n-            col.setSchemaName(colMeta.getString(\"TABLE_CAT\"));\n+            col.setSchemaIdentifier(fromDBName(colMeta.getString(\"TABLE_CAT\"), DBIdentifierType.CATALOG));\n         return col;\n     }\n \n+    @Override\n     public PrimaryKey newPrimaryKey(ResultSet pkMeta)\n         throws SQLException {\n         PrimaryKey pk = super.newPrimaryKey(pkMeta);\n         if (swapSchemaAndCatalog)\n-            pk.setSchemaName(pkMeta.getString(\"TABLE_CAT\"));\n+            pk.setSchemaIdentifier(fromDBName(pkMeta.getString(\"TABLE_CAT\"), DBIdentifierType.CATALOG));\n         return pk;\n     }\n \n+    @Override\n     public Index newIndex(ResultSet idxMeta)\n         throws SQLException {\n         Index idx = super.newIndex(idxMeta);\n         if (swapSchemaAndCatalog)\n-            idx.setSchemaName(idxMeta.getString(\"TABLE_CAT\"));\n+            idx.setSchemaIdentifier(fromDBName(idxMeta.getString(\"TABLE_CAT\"), DBIdentifierType.CATALOG));\n         return idx;\n     }\n \n+    @Override\n     public void setBoolean(PreparedStatement stmnt, int idx, boolean val,\n         Column col)\n         throws SQLException {\n@@ -230,12 +237,14 @@ public void setBoolean(PreparedStatement stmnt, int idx, boolean val,\n         stmnt.setString(idx, val ? \"t\" : \"f\");\n     }\n \n+    @Override\n     public String[] getCreateTableSQL(Table table) {\n         String[] create = super.getCreateTableSQL(table);\n         create[0] = create[0] + \" LOCK MODE ROW\";\n         return create;\n     }\n \n+    @Override\n     public String[] getAddPrimaryKeySQL(PrimaryKey pk) {\n         String pksql = getPrimaryKeyConstraintSQL(pk);\n         if (pksql == null)\n@@ -244,6 +253,7 @@ public void setBoolean(PreparedStatement stmnt, int idx, boolean val,\n             + getFullName(pk.getTable(), false) + \" ADD CONSTRAINT \" + pksql };\n     }\n \n+    @Override\n     public String[] getAddForeignKeySQL(ForeignKey fk) {\n         String fksql = getForeignKeyConstraintSQL(fk);\n         if (fksql == null)\n@@ -252,12 +262,14 @@ public void setBoolean(PreparedStatement stmnt, int idx, boolean val,\n             + getFullName(fk.getTable(), false) + \" ADD CONSTRAINT \" + fksql };\n     }\n \n+    @Override\n     public boolean supportsRandomAccessResultSet(Select sel,\n         boolean forUpdate) {\n         return !forUpdate && !sel.isLob()\n             && super.supportsRandomAccessResultSet(sel, forUpdate);\n     }\n \n+    @Override\n     public Connection decorate(Connection conn)\n         throws SQLException {\n         conn = super.decorate(conn);\n@@ -303,12 +315,14 @@ public Connection decorate(Connection conn)\n         return conn;\n     }\n \n+    @Override\n     public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n         FilterValue start) {\n         throw new UnsupportedException(_loc.get(\"function-not-supported\",\n                 getClass(), \"LOCATE\"));\n     }\n \n+    @Override\n     public boolean needsToCreateIndex(Index idx, Table table) {\n        // Informix will automatically create a unique index for the \n        // primary key, so don't create another index again\n@@ -325,6 +339,7 @@ public boolean useJCC() {\n     /**\n      * Return DB specific schemaCase \n      */\n+    @Override\n     public String getSchemaCase(){\n         return schemaCase;\n     }"},{"sha":"45ae13012c814f82652555f5c31d067ed507497c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/IngresDictionary.java","status":"modified","additions":12,"deletions":4,"changes":16,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/IngresDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/IngresDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/IngresDictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -23,6 +23,7 @@\n import java.sql.ResultSet;\n import java.sql.SQLException;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n import org.apache.openjpa.jdbc.schema.Sequence;\n \n@@ -210,16 +211,21 @@ protected void appendSelectRange(SQLBuffer buf, long start, long end,\n      */\n     @Override\n     protected String getSequencesSQL(String schemaName, String sequenceName) {\n+        return getSequencesSQL(DBIdentifier.newSchema(schemaName), DBIdentifier.newSequence(sequenceName));\n+    }\n+\n+    @Override\n+    protected String getSequencesSQL(DBIdentifier schemaName, DBIdentifier sequenceName) {\n         StringBuilder buf = new StringBuilder();\n         buf.append(sequenceSQL);\n-        if (schemaName != null || sequenceName != null)\n+        if (!DBIdentifier.isNull(schemaName) || !DBIdentifier.isNull(sequenceName))\n             buf.append(\" WHERE \");\n-        if (schemaName != null) {\n+        if (!DBIdentifier.isNull(schemaName)) {\n             buf.append(sequenceSchemaSQL);\n             if (sequenceName != null)\n                 buf.append(\" AND \");\n         }\n-        if (sequenceName != null)\n+        if (!DBIdentifier.isNull(sequenceName))\n             buf.append(sequenceNameSQL);\n         return buf.toString();\n     }\n@@ -232,7 +238,7 @@ protected String getSequencesSQL(String schemaName, String sequenceName) {\n     @Override\n     protected Sequence newSequence(ResultSet sequenceMeta) throws SQLException {\n         Sequence seq = super.newSequence(sequenceMeta);\n-        seq.setName(seq.getName().trim());\n+        seq.setIdentifier(DBIdentifier.trim(seq.getIdentifier()));\n         return seq;\n     }\n     \n@@ -257,6 +263,7 @@ protected Sequence newSequence(ResultSet sequenceMeta) throws SQLException {\n      *            start at the beginning\n      */\n \n+    @Override\n     public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n         FilterValue start) {\n         buf.append(\"(POSITION((\");\n@@ -284,6 +291,7 @@ public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n      *  org.apache.openjpa.jdbc.kernel.exps.FilterValue, \n      *  org.apache.openjpa.jdbc.kernel.exps.FilterValue)\n      */\n+    @Override\n     public void substring(SQLBuffer buf, FilterValue str, FilterValue start,\n         FilterValue end) {\n         buf.append(substringFunctionName).append(\"(\");"},{"sha":"6200e4dfb9f6ae46b776245b1dd2247810cadb40","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InterbaseDictionary.java","status":"modified","additions":27,"deletions":5,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InterbaseDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InterbaseDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/InterbaseDictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -20,9 +20,11 @@\n \n import java.sql.Types;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.Index;\n+import org.apache.openjpa.lib.identifier.IdentifierUtil;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.util.StoreException;\n \n@@ -65,16 +67,33 @@ public InterbaseDictionary() {\n         stringLengthFunction = null;\n     }\n \n+    @Override\n     protected String getTableNameForMetadata(String tableName) {\n-        return (tableName == null) ? \"%\"\n-            : super.getTableNameForMetadata(tableName);\n+        return getTableNameForMetadata(DBIdentifier.newTable(tableName));\n     }\n \n+    @Override\n+    protected String getTableNameForMetadata(DBIdentifier tableName) {\n+        if (DBIdentifier.isNull(tableName)) {\n+            return IdentifierUtil.PERCENT;\n+        }\n+        return super.getTableNameForMetadata(tableName);\n+    }\n+\n+    @Override\n     protected String getColumnNameForMetadata(String columnName) {\n-        return (columnName == null) ? \"%\"\n-            : super.getColumnNameForMetadata(columnName);\n+        return getColumnNameForMetadata(DBIdentifier.newColumn(columnName));\n+    }\n+\n+    @Override\n+    protected String getColumnNameForMetadata(DBIdentifier columnName) {\n+        if (DBIdentifier.isNull(columnName)) {\n+            return IdentifierUtil.PERCENT;\n+        }\n+        return super.getColumnNameForMetadata(columnName);\n     }\n \n+    @Override\n     protected String appendSize(Column col, String typeName) {\n         if (col.isPrimaryKey() && col.getType() == Types.VARCHAR) {\n             // reduce size of varchar primary key cols proportional to the\n@@ -98,21 +117,24 @@ protected String appendSize(Column col, String typeName) {\n         return super.appendSize(col, typeName);\n     }\n \n+    @Override\n     public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n         FilterValue start) {\n         throw new StoreException(_loc.get(\"indexof-not-supported\", platform));\n     }\n \n+    @Override\n     public void substring(SQLBuffer buf, FilterValue str, FilterValue start,\n         FilterValue end) {\n         throw new StoreException(_loc.get(\"substring-not-supported\",\n             platform));\n     }\n \n+    @Override\n     public String[] getDropColumnSQL(Column column) {\n         // Interbase uses \"ALTER TABLE DROP <COLUMN_NAME>\" rather than the\n         // usual \"ALTER TABLE DROP COLUMN <COLUMN_NAME>\"\n         return new String[]{ \"ALTER TABLE \"\n-            + getFullName(column.getTable(), false) + \" DROP \" + column };\n+            + getFullName(column.getTable(), false) + \" DROP \" + getColumnDBName(column) };\n     }\n }"},{"sha":"461c73b18db09cb39d4ab19f1bc14235a380dc65","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JDataStoreDictionary.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JDataStoreDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JDataStoreDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/JDataStoreDictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -67,6 +67,7 @@ public JDataStoreDictionary() {\n         searchStringEscape = \"\";\n     }\n \n+    @Override\n     public void substring(SQLBuffer buf, FilterValue str, FilterValue start,\n         FilterValue end) {\n         buf.append(\"SUBSTRING(\");\n@@ -85,6 +86,7 @@ public void substring(SQLBuffer buf, FilterValue str, FilterValue start,\n         buf.append(\")))\");\n     }\n \n+    @Override\n     public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n         FilterValue start) {\n         buf.append(\"(POSITION(\");\n@@ -102,6 +104,7 @@ public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n         buf.append(\")\");\n     }\n \n+    @Override\n     public OpenJPAException newStoreException(String msg, SQLException[] causes,\n         Object failed) {\n         OpenJPAException ke = super.newStoreException(msg, causes, failed);"},{"sha":"be1e160134de74cf6fe8068058dc5285c323d7eb","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MySQLDictionary.java","status":"modified","additions":25,"deletions":9,"changes":34,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MySQLDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MySQLDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/MySQLDictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -30,6 +30,7 @@\n import java.util.Set;\n \n import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n@@ -47,6 +48,8 @@\n \n     public static final String SELECT_HINT = \"openjpa.hint.MySQLSelectHint\";\n \n+    public static final String DELIMITER_BACK_TICK = \"`\";\n+    \n     /**\n      * The MySQL table type to use when creating tables; defaults to innodb.\n      */\n@@ -144,11 +147,13 @@ public MySQLDictionary() {\n         typeModifierSet.addAll(Arrays.asList(new String[] { \"UNSIGNED\",\n             \"ZEROFILL\" }));\n \n-        delimiter = \"`\";\n+        setLeadingDelimiter(DELIMITER_BACK_TICK);\n+        setTrailingDelimiter(DELIMITER_BACK_TICK);\n         \n         fixedSizeTypeNameSet.remove(\"NUMERIC\");\n     }\n \n+    @Override\n     public void connectedConfiguration(Connection conn) throws SQLException {\n         super.connectedConfiguration(conn);\n \n@@ -184,6 +189,7 @@ public void connectedConfiguration(Connection conn) throws SQLException {\n             driverDeserializesBlobs = true;\n     }\n \n+    @Override\n     public Connection decorate(Connection conn)  throws SQLException {\n         conn = super.decorate(conn);\n         String driver = conf.getConnectionDriverName();\n@@ -222,13 +228,15 @@ public Connection decorate(Connection conn)  throws SQLException {\n         return new int[]{maj, min};\n     }\n \n+    @Override\n     public String[] getCreateTableSQL(Table table) {\n         String[] sql = super.getCreateTableSQL(table);\n         if (!StringUtils.isEmpty(tableType))\n             sql[0] = sql[0] + \" TYPE = \" + tableType;\n         return sql;\n     }\n \n+    @Override\n     public String[] getDropIndexSQL(Index index) {\n         return new String[]{ \"DROP INDEX \" + getFullName(index) + \" ON \"\n             + getFullName(index.getTable(), false) };\n@@ -239,7 +247,7 @@ public Connection decorate(Connection conn)  throws SQLException {\n      */\n     @Override\n     public String[] getDropPrimaryKeySQL(PrimaryKey pk) {\n-        if (pk.getName() == null)\n+        if (DBIdentifier.isNull(pk.getIdentifier()))\n             return new String[0];\n         return new String[]{ \"ALTER TABLE \"\n             + getFullName(pk.getTable(), false)\n@@ -252,19 +260,20 @@ public Connection decorate(Connection conn)  throws SQLException {\n      */\n     @Override\n     public String[] getDropForeignKeySQL(ForeignKey fk, Connection conn) {\n-        if (fk.getName() == null) {\n-            String fkName = fk.loadNameFromDB(this,conn);\n+        if (DBIdentifier.isNull(fk.getIdentifier())) {\n+            DBIdentifier fkName = fk.loadIdentifierFromDB(this,conn);\n             String[] retVal = (fkName == null) ?  new String[0] :\n                 new String[]{ \"ALTER TABLE \"\n                 + getFullName(fk.getTable(), false)\n-                + \" DROP FOREIGN KEY \" + fkName };\n+                + \" DROP FOREIGN KEY \" + toDBName(fkName) };\n             return retVal;   \n         }\n         return new String[]{ \"ALTER TABLE \"\n             + getFullName(fk.getTable(), false)\n-            + \" DROP FOREIGN KEY \" + fk.getName() };\n+            + \" DROP FOREIGN KEY \" + toDBName(fk.getIdentifier()) };\n     }\n \n+    @Override\n     public String[] getAddPrimaryKeySQL(PrimaryKey pk) {\n         String[] sql = super.getAddPrimaryKeySQL(pk);\n \n@@ -274,15 +283,16 @@ public Connection decorate(Connection conn)  throws SQLException {\n         String[] ret = new String[cols.length + sql.length];\n         for (int i = 0; i < cols.length; i++) {\n             ret[i] = \"ALTER TABLE \" + getFullName(cols[i].getTable(), false)\n-                + \" CHANGE \" + cols[i].getName()\n-                + \" \" + cols[i].getName() // name twice\n+                + \" CHANGE \" + toDBName(cols[i].getIdentifier())\n+                + \" \" + toDBName(cols[i].getIdentifier()) // name twice\n                 + \" \" + getTypeName(cols[i]) + \" NOT NULL\";\n         }\n \n         System.arraycopy(sql, 0, ret, cols.length, sql.length);\n         return ret;\n     }\n     \n+    @Override\n     public String[] getDeleteTableContentsSQL(Table[] tables,Connection conn) {\n         // mysql >= 4 supports more-optimal delete syntax\n         if (!optimizeMultiTableDeletes)\n@@ -291,14 +301,15 @@ public Connection decorate(Connection conn)  throws SQLException {\n             StringBuilder buf = new StringBuilder(tables.length * 8);\n             buf.append(\"DELETE FROM \");\n             for (int i = 0; i < tables.length; i++) {\n-                buf.append(tables[i].getFullName());\n+                buf.append(toDBName(tables[i].getFullIdentifier()));\n                 if (i < tables.length - 1)\n                     buf.append(\", \");\n             }\n             return new String[] { buf.toString() };\n         }\n     }\n \n+    @Override\n     protected void appendSelectRange(SQLBuffer buf, long start, long end,\n         boolean subselect) {\n         buf.append(\" LIMIT \").appendValue(start).append(\", \");\n@@ -308,6 +319,7 @@ protected void appendSelectRange(SQLBuffer buf, long start, long end,\n             buf.appendValue(end - start);\n     }\n \n+    @Override\n     protected Column newColumn(ResultSet colMeta)\n         throws SQLException {\n         Column col = super.newColumn(colMeta);\n@@ -316,6 +328,7 @@ protected Column newColumn(ResultSet colMeta)\n         return col;\n     }\n \n+    @Override\n     public Object getBlobObject(ResultSet rs, int column, JDBCStore store)\n         throws SQLException {\n         // if the user has set a get-blob strategy explicitly or the driver\n@@ -328,6 +341,7 @@ public Object getBlobObject(ResultSet rs, int column, JDBCStore store)\n         return rs.getObject(column);\n     }\n \n+    @Override\n     public int getPreferredType(int type) {\n         if (type == Types.CLOB && !useClobs)\n             return Types.LONGVARCHAR;\n@@ -344,6 +358,7 @@ public int getPreferredType(int type) {\n      * @param lhsxml indicates whether the left operand maps to XML\n      * @param rhsxml indicates whether the right operand maps to XML\n      */\n+    @Override\n     public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\n         FilterValue rhs, boolean lhsxml, boolean rhsxml) {\n         super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\n@@ -372,6 +387,7 @@ private void appendXmlValue(SQLBuffer buf, FilterValue val) {\n         buf.append(\"')\");\n     }\n     \n+    @Override\n     public int getBatchFetchSize(int batchFetchSize) {\n         return Integer.MIN_VALUE;\n     }"},{"sha":"248724cf6911fca644aff5233342bd715384eea9","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","status":"modified","additions":124,"deletions":45,"changes":169,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -40,6 +40,7 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n@@ -195,12 +196,14 @@ public OracleDictionary() {\n         requiresSearchStringEscapeForLike = false;\n     }\n \n+    @Override\n     public void endConfiguration() {\n         super.endConfiguration();\n         if (useTriggersForAutoAssign)\n             supportsAutoAssign = true;\n     }\n \n+    @Override\n     public void connectedConfiguration(Connection conn)\n         throws SQLException {\n         super.connectedConfiguration(conn);\n@@ -292,13 +295,15 @@ public void ensureDriverVendor() {\n         }\n     }\n \n+    @Override\n     public boolean supportsLocking(Select sel) {\n         if (!super.supportsLocking(sel))\n             return false;\n         return !requiresSubselectForRange(sel.getStartIndex(),\n             sel.getEndIndex(), sel.isDistinct(), sel.getOrdering());\n     }\n \n+    @Override\n     protected SQLBuffer getSelects(Select sel, boolean distinctIdentifiers,\n         boolean forUpdate) {\n         // if range doesn't require a subselect can use super\n@@ -337,6 +342,7 @@ protected SQLBuffer getSelects(Select sel, boolean distinctIdentifiers,\n         return selectSQL;\n     }\n \n+    @Override\n     public boolean canOuterJoin(int syntax, ForeignKey fk) {\n         if (!super.canOuterJoin(syntax, fk))\n             return false;\n@@ -349,6 +355,7 @@ public boolean canOuterJoin(int syntax, ForeignKey fk) {\n         return true;\n     }\n \n+    @Override\n     public SQLBuffer toNativeJoin(Join join) {\n         if (join.getType() != Join.TYPE_OUTER)\n             return toTraditionalJoin(join);\n@@ -386,6 +393,7 @@ public SQLBuffer toNativeJoin(Join join) {\n         return buf;\n     }\n \n+    @Override\n     protected SQLBuffer toSelect(SQLBuffer select, JDBCFetchConfiguration fetch,\n         SQLBuffer tables, SQLBuffer where, SQLBuffer group,\n         SQLBuffer having, SQLBuffer order,\n@@ -395,6 +403,7 @@ protected SQLBuffer toSelect(SQLBuffer select, JDBCFetchConfiguration fetch,\n             distinct, forUpdate, start, end, sel);\n     }\n \n+    @Override\n     protected SQLBuffer toSelect(SQLBuffer select, JDBCFetchConfiguration fetch,\n         SQLBuffer tables, SQLBuffer where, SQLBuffer group,\n         SQLBuffer having, SQLBuffer order,\n@@ -478,7 +487,7 @@ public void setString(PreparedStatement stmnt, int idx, String val,\n         // special handling to configure them correctly; see:\n         // http://www.oracle.com/technology/sample_code/tech/java/\n         // sqlj_jdbc/files/9i_jdbc/NCHARsupport4UnicodeSample/Readme.html\n-        String typeName = (col == null) ? null : col.getTypeName();\n+        String typeName = (col == null) ? null : col.getTypeIdentifier().getName();\n         if (useSetFormOfUseForUnicode && typeName != null &&\n             (typeName.toLowerCase().startsWith(\"nvarchar\") ||\n                 typeName.toLowerCase().startsWith(\"nchar\") ||\n@@ -534,20 +543,21 @@ public void setString(PreparedStatement stmnt, int idx, String val,\n         super.setString(stmnt, idx, val, col);\n     }\n \n+    @Override\n     public void setNull(PreparedStatement stmnt, int idx, int colType,\n         Column col)\n         throws SQLException {\n         if ((colType == Types.CLOB || colType == Types.BLOB) && col.isNotNull())\n-            throw new UserException(_loc.get(\"null-blob-in-not-nullable\", col\n-                .getFullName()));\n+            throw new UserException(_loc.get(\"null-blob-in-not-nullable\", toDBName(col\n+                .getFullDBIdentifier())));\n         if (colType == Types.BLOB && _driverBehavior == BEHAVE_ORACLE)\n             stmnt.setBlob(idx, getEmptyBlob());\n         else if (colType == Types.CLOB && _driverBehavior == BEHAVE_ORACLE\n             && !col.isXML())\n             stmnt.setClob(idx, getEmptyClob());\n         else if ((colType == Types.STRUCT || colType == Types.OTHER)\n-            && col != null && col.getTypeName() != null)\n-            stmnt.setNull(idx, Types.STRUCT, col.getTypeName());\n+            && col != null && !DBIdentifier.isNull(col.getTypeIdentifier()))\n+            stmnt.setNull(idx, Types.STRUCT, col.getTypeIdentifier().getName());\n             // some versions of the Oracle JDBC driver will fail if calling\n             // setNull with DATE; see bug #1171\n         else if (colType == Types.DATE)\n@@ -559,6 +569,7 @@ else if (colType == Types.OTHER || col.isXML())\n             super.setNull(stmnt, idx, colType, col);\n     }\n \n+    @Override\n     public String getClobString(ResultSet rs, int column)\n         throws SQLException {\n         if (_driverBehavior != BEHAVE_ORACLE)\n@@ -585,6 +596,7 @@ public String getClobString(ResultSet rs, int column)\n         return clob.getSubString(1, (int) clob.length());\n     }\n \n+    @Override\n     public Timestamp getTimestamp(ResultSet rs, int column, Calendar cal)\n         throws SQLException {\n         if (cal == null) {\n@@ -606,6 +618,7 @@ public Timestamp getTimestamp(ResultSet rs, int column, Calendar cal)\n         return ts;\n     }\n \n+    @Override\n     public Object getObject(ResultSet rs, int column, Map map)\n         throws SQLException {\n         // recent oracle drivers return oracle-specific types for timestamps\n@@ -642,32 +655,54 @@ private static Object convertFromOracleType(Object obj,\n     public Column[] getColumns(DatabaseMetaData meta, String catalog,\n         String schemaName, String tableName, String columnName, Connection conn)\n         throws SQLException {\n+        return getColumns(meta, \n+            DBIdentifier.newCatalog(catalog), \n+            DBIdentifier.newSchema(schemaName), \n+            DBIdentifier.newTable(tableName), \n+            DBIdentifier.newColumn(columnName),conn);\n+    }\n+\n+    public Column[] getColumns(DatabaseMetaData meta, DBIdentifier catalog,\n+        DBIdentifier schemaName, DBIdentifier tableName, DBIdentifier columnName, Connection conn)\n+        throws SQLException {\n         Column[] cols = super.getColumns(meta, catalog, schemaName, tableName,\n             columnName, conn);\n \n         for (int i = 0; cols != null && i < cols.length; i++) {\n-            if (cols[i].getTypeName() == null)\n+            String typeName = cols[i].getTypeIdentifier().getName();\n+            if (typeName == null)\n                 continue;\n-            if (cols[i].getTypeName().toUpperCase().startsWith(\"TIMESTAMP\"))\n+            if (typeName.toUpperCase().startsWith(\"TIMESTAMP\"))\n                 cols[i].setType(Types.TIMESTAMP);\n-            else if (\"BLOB\".equalsIgnoreCase(cols[i].getTypeName()))\n+            else if (\"BLOB\".equalsIgnoreCase(typeName))\n                 cols[i].setType(Types.BLOB);\n-            else if (\"CLOB\".equalsIgnoreCase(cols[i].getTypeName())\n-                || \"NCLOB\".equalsIgnoreCase(cols[i].getTypeName()))\n+            else if (\"CLOB\".equalsIgnoreCase(typeName)\n+                || \"NCLOB\".equalsIgnoreCase(typeName))\n                 cols[i].setType(Types.CLOB);\n-            else if (\"FLOAT\".equalsIgnoreCase(cols[i].getTypeName()))\n+            else if (\"FLOAT\".equalsIgnoreCase(typeName))\n                 cols[i].setType(Types.FLOAT);\n-            else if (\"NVARCHAR\".equalsIgnoreCase(cols[i].getTypeName()))\n+            else if (\"NVARCHAR\".equalsIgnoreCase(typeName))\n                 cols[i].setType(Types.VARCHAR);\n-            else if (\"NCHAR\".equalsIgnoreCase(cols[i].getTypeName()))\n+            else if (\"NCHAR\".equalsIgnoreCase(typeName))\n                 cols[i].setType(Types.CHAR);\n         }\n         return cols;\n     }\n \n+    @Override\n     public PrimaryKey[] getPrimaryKeys(DatabaseMetaData meta,\n         String catalog, String schemaName, String tableName, Connection conn)\n         throws SQLException {\n+        return getPrimaryKeys(meta,\n+            DBIdentifier.newCatalog(catalog), \n+            DBIdentifier.newSchema(schemaName), \n+            DBIdentifier.newTable(tableName), conn);\n+    }\n+\n+    @Override\n+    public PrimaryKey[] getPrimaryKeys(DatabaseMetaData meta,\n+        DBIdentifier catalog, DBIdentifier schemaName, DBIdentifier tableName, Connection conn)\n+        throws SQLException {\n         StringBuilder buf = new StringBuilder();\n         buf.append(\"SELECT t0.OWNER AS TABLE_SCHEM, \").\n             append(\"t0.TABLE_NAME AS TABLE_NAME, \").\n@@ -677,19 +712,19 @@ else if (\"NCHAR\".equalsIgnoreCase(cols[i].getTypeName()))\n             append(\"WHERE t0.OWNER = t1.OWNER \").\n             append(\"AND t0.CONSTRAINT_NAME = t1.CONSTRAINT_NAME \").\n             append(\"AND t1.CONSTRAINT_TYPE = 'P'\");\n-        if (schemaName != null)\n+        if (!DBIdentifier.isNull(schemaName))\n             buf.append(\" AND t0.OWNER = ?\");\n-        if (tableName != null)\n+        if (!DBIdentifier.isNull(tableName))\n             buf.append(\" AND t0.TABLE_NAME = ?\");\n \n         PreparedStatement stmnt = conn.prepareStatement(buf.toString());\n         ResultSet rs = null;\n         try {\n             int idx = 1;\n-            if (schemaName != null)\n-                setString(stmnt, idx++, schemaName.toUpperCase(), null);\n-            if (tableName != null)\n-                setString(stmnt, idx++, tableName.toUpperCase(), null);\n+            if (!DBIdentifier.isNull(schemaName))\n+                setString(stmnt, idx++, convertSchemaCase(schemaName), null);\n+            if (!DBIdentifier.isNull(tableName))\n+                setString(stmnt, idx++, convertSchemaCase(tableName), null);\n             setTimeouts(stmnt, conf, false);\n             rs = stmnt.executeQuery();\n             List pkList = new ArrayList();\n@@ -710,10 +745,22 @@ else if (\"NCHAR\".equalsIgnoreCase(cols[i].getTypeName()))\n         }\n     }\n \n+    @Override\n     public Index[] getIndexInfo(DatabaseMetaData meta, String catalog,\n         String schemaName, String tableName, boolean unique, boolean approx,\n         Connection conn)\n         throws SQLException {\n+        return getIndexInfo(meta,\n+            DBIdentifier.newCatalog(catalog), \n+            DBIdentifier.newSchema(schemaName), \n+            DBIdentifier.newTable(tableName), unique, approx, conn);\n+    }\n+\n+    @Override\n+    public Index[] getIndexInfo(DatabaseMetaData meta, DBIdentifier catalog,\n+        DBIdentifier schemaName, DBIdentifier tableName, boolean unique, boolean approx,\n+        Connection conn)\n+        throws SQLException {\n         StringBuilder buf = new StringBuilder();\n         buf.append(\"SELECT t0.INDEX_OWNER AS TABLE_SCHEM, \").\n             append(\"t0.TABLE_NAME AS TABLE_NAME, \").\n@@ -724,19 +771,19 @@ else if (\"NCHAR\".equalsIgnoreCase(cols[i].getTypeName()))\n             append(\"FROM ALL_IND_COLUMNS t0, ALL_INDEXES t1 \").\n             append(\"WHERE t0.INDEX_OWNER = t1.OWNER \").\n             append(\"AND t0.INDEX_NAME = t1.INDEX_NAME\");\n-        if (schemaName != null)\n+        if (!DBIdentifier.isNull(schemaName))\n             buf.append(\" AND t0.TABLE_OWNER = ?\");\n-        if (tableName != null)\n+        if (!DBIdentifier.isNull(tableName))\n             buf.append(\" AND t0.TABLE_NAME = ?\");\n \n         PreparedStatement stmnt = conn.prepareStatement(buf.toString());\n         ResultSet rs = null;\n         try {\n             int idx = 1;\n-            if (schemaName != null)\n-                setString(stmnt, idx++, schemaName.toUpperCase(), null);\n-            if (tableName != null)\n-                setString(stmnt, idx++, tableName.toUpperCase(), null);\n+            if (!DBIdentifier.isNull(schemaName))\n+                setString(stmnt, idx++, convertSchemaCase(schemaName), null);\n+            if (!DBIdentifier.isNull(tableName))\n+                setString(stmnt, idx++, convertSchemaCase(tableName), null);\n \n             setTimeouts(stmnt, conf, false);\n             rs = stmnt.executeQuery();\n@@ -757,9 +804,20 @@ else if (\"NCHAR\".equalsIgnoreCase(cols[i].getTypeName()))\n         }\n     }\n \n+    @Override\n     public ForeignKey[] getImportedKeys(DatabaseMetaData meta, String catalog,\n         String schemaName, String tableName, Connection conn, boolean partialKeys)\n         throws SQLException {\n+        return getImportedKeys(meta,\n+            DBIdentifier.newCatalog(catalog), \n+            DBIdentifier.newSchema(schemaName), \n+            DBIdentifier.newTable(tableName), conn, partialKeys);\n+    }\n+    \n+    @Override\n+    public ForeignKey[] getImportedKeys(DatabaseMetaData meta, DBIdentifier catalog,\n+        DBIdentifier schemaName, DBIdentifier tableName, Connection conn, boolean partialKeys)\n+        throws SQLException {\n         StringBuilder delAction = new StringBuilder(\"DECODE(t1.DELETE_RULE\").\n             append(\", 'NO ACTION', \").append(meta.importedKeyNoAction).\n             append(\", 'RESTRICT', \").append(meta.importedKeyRestrict).\n@@ -791,20 +849,20 @@ else if (\"NCHAR\".equalsIgnoreCase(cols[i].getTypeName()))\n             append(\"AND t1.R_OWNER = t2.OWNER \").\n             append(\"AND t1.R_CONSTRAINT_NAME = t2.CONSTRAINT_NAME \").\n             append(\"AND t0.POSITION = t2.POSITION\");\n-        if (schemaName != null)\n+        if (!DBIdentifier.isNull(schemaName))\n             buf.append(\" AND t0.OWNER = ?\");\n-        if (tableName != null)\n+        if (!DBIdentifier.isNull(tableName))\n             buf.append(\" AND t0.TABLE_NAME = ?\");\n         buf.append(\" ORDER BY t2.OWNER, t2.TABLE_NAME, t0.POSITION\");\n \n         PreparedStatement stmnt = conn.prepareStatement(buf.toString());\n         ResultSet rs = null;\n         try {\n             int idx = 1;\n-            if (schemaName != null)\n-                setString(stmnt, idx++, schemaName.toUpperCase(), null);\n-            if (tableName != null)\n-                setString(stmnt, idx++, tableName.toUpperCase(), null);\n+            if (!DBIdentifier.isNull(schemaName))\n+                setString(stmnt, idx++, convertSchemaCase(schemaName), null);\n+            if (!DBIdentifier.isNull(tableName))\n+                setString(stmnt, idx++, convertSchemaCase(tableName), null);\n             setTimeouts(stmnt, conf, false);\n             rs = stmnt.executeQuery();\n             List<ForeignKey> fkList = new ArrayList<ForeignKey>();            \n@@ -836,6 +894,7 @@ else if (\"NCHAR\".equalsIgnoreCase(cols[i].getTypeName()))\n         }\n     }\n \n+    @Override\n     public String[] getCreateTableSQL(Table table) {\n         // only override if we are simulating auto-incremenet with triggers\n         String[] create = super.getCreateTableSQL(table);\n@@ -867,9 +926,9 @@ else if (\"NCHAR\".equalsIgnoreCase(cols[i].getTypeName()))\n             // create the trigger that will insert new values into\n             // the table whenever a row is created\n             seqs.add(\"CREATE OR REPLACE TRIGGER \" + trig\n-                + \" BEFORE INSERT ON \" + table.getName()\n+                + \" BEFORE INSERT ON \" + toDBName(table.getIdentifier())\n                 + \" FOR EACH ROW BEGIN SELECT \" + seq + \".nextval INTO \"\n-                + \":new.\" + cols[i].getName() + \" FROM DUAL; \"\n+                + \":new.\" + toDBName(cols[i].getIdentifier()) + \" FROM DUAL; \"\n                 + \"END \" + trig + \";\");\n         }\n         if (seqs == null)\n@@ -883,6 +942,7 @@ else if (\"NCHAR\".equalsIgnoreCase(cols[i].getTypeName()))\n         return sql;\n     }\n \n+    @Override\n     public String[] getCreateSequenceSQL(Sequence seq) {\n         String[] sql = super.getCreateSequenceSQL(seq);\n         if (seq.getAllocate() > 1)\n@@ -900,35 +960,49 @@ public int getJDBCType(int metaTypeCode, boolean lob, int precis,\n         return getJDBCType(metaTypeCode, lob || xml, precis, scale);        \n     }\n \n-\n+    @Override\n     protected String getSequencesSQL(String schemaName, String sequenceName) {\n+        return getSequencesSQL(DBIdentifier.newSchema(schemaName), DBIdentifier.newSequence(sequenceName));\n+    }\n+\n+    @Override\n+    protected String getSequencesSQL(DBIdentifier schemaName, DBIdentifier sequenceName) {\n         StringBuilder buf = new StringBuilder();\n         buf.append(\"SELECT SEQUENCE_OWNER AS SEQUENCE_SCHEMA, \").\n             append(\"SEQUENCE_NAME FROM ALL_SEQUENCES\");\n-        if (schemaName != null || sequenceName != null)\n+        if (!DBIdentifier.isNull(schemaName) || !DBIdentifier.isNull(sequenceName))\n             buf.append(\" WHERE \");\n-        if (schemaName != null) {\n+        if (!DBIdentifier.isNull(schemaName)) {\n             buf.append(\"SEQUENCE_OWNER = ?\");\n-            if (sequenceName != null)\n+            if (!DBIdentifier.isNull(sequenceName))\n                 buf.append(\" AND \");\n         }\n-        if (sequenceName != null)\n+        if (!DBIdentifier.isNull(sequenceName))\n             buf.append(\"SEQUENCE_NAME = ?\");\n         return buf.toString();\n     }\n \n     public boolean isSystemSequence(String name, String schema,\n+        boolean targetSchema) {\n+        return isSystemSequence(DBIdentifier.newSequence(name),\n+            DBIdentifier.newSchema(schema), targetSchema);\n+    }\n+\n+    @Override\n+    public boolean isSystemSequence(DBIdentifier name, DBIdentifier schema,\n         boolean targetSchema) {\n         if (super.isSystemSequence(name, schema, targetSchema))\n             return true;\n \n         // filter out generated sequences used for auto-assign\n+        String strName = DBIdentifier.isNull(name) ? \"\" : name.getName();\n         return (autoAssignSequenceName != null\n-            && name.equalsIgnoreCase(autoAssignSequenceName))\n+            && strName.equalsIgnoreCase(autoAssignSequenceName))\n             || (autoAssignSequenceName == null\n-            && name.toUpperCase().startsWith(\"ST_\"));\n+            && strName.toUpperCase().startsWith(\"ST_\"));\n     }\n \n+    @Override\n     public Object getGeneratedKey(Column col, Connection conn)\n         throws SQLException {\n         if (!useTriggersForAutoAssign)\n@@ -971,17 +1045,19 @@ protected String getGeneratedKeyTriggerName(Column col) {\n      */\n     protected String getOpenJPA3GeneratedKeySequenceName(Column col) {\n         Table table = col.getTable();\n-        return makeNameValid(\"SEQ_\" + table.getName(), table.getSchema().\n-            getSchemaGroup(), maxTableNameLength, NAME_ANY);\n+        DBIdentifier sName = DBIdentifier.preCombine(table.getIdentifier(), \"SEQ\");\n+        return toDBName(getNamingUtil().makeIdentifierValid(sName, table.getSchema().\n+            getSchemaGroup(), maxTableNameLength, true));\n     }\n \n     /**\n      * Returns a OpenJPA 3-compatible name for an auto-assign trigger.\n      */\n     protected String getOpenJPA3GeneratedKeyTriggerName(Column col) {\n-        Table table = col.getTable();\n-        return makeNameValid(\"TRIG_\" + table.getName(), table.getSchema().\n-            getSchemaGroup(), maxTableNameLength, NAME_ANY);\n+        Table table = col.getTable();        \n+        DBIdentifier sName = DBIdentifier.preCombine(table.getIdentifier(), \"TRIG\");\n+        return toDBName(getNamingUtil().makeIdentifierValid(sName, table.getSchema().\n+            getSchemaGroup(), maxTableNameLength, true));\n     }\n \n     /**\n@@ -990,6 +1066,7 @@ protected String getOpenJPA3GeneratedKeyTriggerName(Column col) {\n      * vendor-specific class; for example Weblogic wraps oracle thin driver\n      * lobs in its own interfaces with the same methods.\n      */\n+    @Override\n     public void putBytes(Blob blob, byte[] data)\n         throws SQLException {\n         if (blob == null)\n@@ -1011,6 +1088,7 @@ public void putBytes(Blob blob, byte[] data)\n      * vendor-specific class; for example Weblogic wraps oracle thin driver\n      * lobs in its own interfaces with the same methods.\n      */\n+    @Override\n     public void putString(Clob clob, String data)\n         throws SQLException {\n         if (_putString == null) {\n@@ -1030,6 +1108,7 @@ public void putString(Clob clob, String data)\n      * vendor-specific class; for example Weblogic wraps oracle thin driver\n      * lobs in its own interfaces with the same methods.\n      */\n+    @Override\n     public void putChars(Clob clob, char[] data)\n         throws SQLException {\n         if (_putChars == null) {"},{"sha":"c89f7c480f9d5bb4cefd6cd79824ea5028898c2c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PointbaseDictionary.java","status":"modified","additions":15,"deletions":2,"changes":17,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PointbaseDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PointbaseDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PointbaseDictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -23,6 +23,8 @@\n import java.sql.SQLException;\n import java.sql.Types;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.Index;\n@@ -72,21 +74,32 @@ public int getPreferredType(int type) {\n         }\n     }\n \n+    @Override\n     public Column[] getColumns(DatabaseMetaData meta, String catalog,\n         String schemaName, String tableName, String columnName, Connection conn)\n         throws SQLException {\n+        return getColumns(meta, DBIdentifier.newCatalog(catalog), DBIdentifier.newSchema(schemaName),\n+            DBIdentifier.newTable(tableName), DBIdentifier.newColumn(columnName), conn);\n+    }\n+\n+    @Override\n+    public Column[] getColumns(DatabaseMetaData meta, DBIdentifier catalog,\n+        DBIdentifier schemaName, DBIdentifier tableName, DBIdentifier columnName, Connection conn)\n+        throws SQLException {\n         Column[] cols = super.getColumns(meta, catalog, schemaName, tableName,\n             columnName, conn);\n \n         // pointbase reports the type for a CLOB field as VARCHAR: override it\n         for (int i = 0; cols != null && i < cols.length; i++)\n-            if (cols[i].getTypeName().toUpperCase().startsWith(\"CLOB\"))\n+            if (cols[i].getTypeIdentifier().getName().toUpperCase().startsWith(\"CLOB\"))\n                 cols[i].setType(Types.CLOB);\n         return cols;\n     }\n \n+    @Override\n     public String getFullName(Index index) {\n-        return getFullName(index.getTable(), false) + \".\" + index.getName();\n+        return toDBName(getNamingUtil().append(DBIdentifierType.INDEX, \n+            getFullIdentifier(index.getTable(), false), index.getIdentifier()));\n     }\n \n     public void substring(SQLBuffer buf, FilterValue str, FilterValue start,"},{"sha":"a3cd9394185f51cc38070acf964926ba5ae85829","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java","status":"modified","additions":41,"deletions":8,"changes":49,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PostgresDictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -38,6 +38,7 @@\n import java.util.Date;\n import java.util.Map;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n@@ -209,6 +210,7 @@ public PostgresDictionary() {\n         }));\n     }\n \n+    @Override\n     public Date getDate(ResultSet rs, int column)\n         throws SQLException {\n         try {\n@@ -234,6 +236,7 @@ public Date getDate(ResultSet rs, int column)\n         }\n     }\n \n+    @Override\n     public byte getByte(ResultSet rs, int column)\n         throws SQLException {\n         // postgres does not perform automatic conversions, so attempting to\n@@ -246,6 +249,7 @@ public byte getByte(ResultSet rs, int column)\n         }\n     }\n \n+    @Override\n     public short getShort(ResultSet rs, int column)\n         throws SQLException {\n         // postgres does not perform automatic conversions, so attempting to\n@@ -258,6 +262,7 @@ public short getShort(ResultSet rs, int column)\n         }\n     }\n \n+    @Override\n     public int getInt(ResultSet rs, int column)\n         throws SQLException {\n         // postgres does not perform automatic conversions, so attempting to\n@@ -270,6 +275,7 @@ public int getInt(ResultSet rs, int column)\n         }\n     }\n \n+    @Override\n     public long getLong(ResultSet rs, int column)\n         throws SQLException {\n         // postgres does not perform automatic conversions, so attempting to\n@@ -282,6 +288,7 @@ public long getLong(ResultSet rs, int column)\n         }\n     }\n \n+    @Override\n     public void setBoolean(PreparedStatement stmnt, int idx, boolean val,\n         Column col)\n         throws SQLException {\n@@ -293,6 +300,7 @@ public void setBoolean(PreparedStatement stmnt, int idx, boolean val,\n     /**\n      * Handle XML and bytea/oid columns in a PostgreSQL way.\n      */\n+    @Override\n     public void setNull(PreparedStatement stmnt, int idx, int colType,\n         Column col)\n         throws SQLException {\n@@ -307,6 +315,7 @@ public void setNull(PreparedStatement stmnt, int idx, int colType,\n         stmnt.setNull(idx, colType);\n     }\n \n+    @Override\n     protected void appendSelectRange(SQLBuffer buf, long start, long end,\n         boolean subselect) {\n         if (end != Long.MAX_VALUE)\n@@ -315,6 +324,7 @@ protected void appendSelectRange(SQLBuffer buf, long start, long end,\n             buf.append(\" OFFSET \").appendValue(start);\n     }\n \n+    @Override\n     public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n         FilterValue start) {\n         buf.append(\"(POSITION(\");\n@@ -332,52 +342,75 @@ public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n         buf.append(\")\");\n     }\n \n+    @Override\n     public String[] getCreateSequenceSQL(Sequence seq) {\n         String[] sql = super.getCreateSequenceSQL(seq);\n         if (seq.getAllocate() > 1)\n             sql[0] += \" CACHE \" + seq.getAllocate();\n         return sql;\n     }\n \n+    @Override\n     protected boolean supportsDeferredUniqueConstraints() {\n         // Postgres only supports deferred foreign key constraints.\n         return false;\n     }\n \n     protected String getSequencesSQL(String schemaName, String sequenceName) {\n-        if (schemaName == null && sequenceName == null)\n+        return getSequencesSQL(DBIdentifier.newSchema(schemaName), DBIdentifier.newSequence(sequenceName));\n+    }\n+\n+    protected String getSequencesSQL(DBIdentifier schemaName, DBIdentifier sequenceName) {\n+        if (DBIdentifier.isNull(schemaName) && DBIdentifier.isNull(sequenceName))\n             return allSequencesSQL;\n-        else if (schemaName == null)\n+        else if (DBIdentifier.isNull(schemaName))\n             return namedSequencesFromAllSchemasSQL;\n-        else if (sequenceName == null)\n+        else if (DBIdentifier.isNull(sequenceName))\n             return allSequencesFromOneSchemaSQL;\n         else\n             return namedSequenceFromOneSchemaSQL;\n     }\n \n     public boolean isSystemSequence(String name, String schema,\n+        boolean targetSchema) {\n+        return isSystemSequence(DBIdentifier.newTable(name), DBIdentifier.newSchema(schema), targetSchema);\n+    }\n+\n+    public boolean isSystemSequence(DBIdentifier name, DBIdentifier schema,\n         boolean targetSchema) {\n         if (super.isSystemSequence(name, schema, targetSchema))\n             return true;\n \n         // filter out generated sequences used for bigserial cols, which are\n         // of the form <table>_<col>_seq\n-        int idx = name.indexOf('_');\n-        return idx != -1 && idx != name.length() - 4\n-            && name.toUpperCase().endsWith(\"_SEQ\");\n+        String strName = DBIdentifier.isNull(name) ? null : name.getName();\n+        int idx = strName.indexOf('_');\n+        return idx != -1 && idx != strName.length() - 4\n+            && strName.toUpperCase().endsWith(\"_SEQ\");\n     }\n \n     public boolean isSystemTable(String name, String schema,\n+        boolean targetSchema) {\n+        return isSystemTable(DBIdentifier.newTable(name), DBIdentifier.newSchema(schema), targetSchema);\n+    }\n+\n+    public boolean isSystemTable(DBIdentifier name, DBIdentifier schema,\n         boolean targetSchema) {\n         // names starting with \"pg_\" are reserved for Postgresql internal use\n+        String strName = DBIdentifier.isNull(name) ? null : name.getName();\n         return super.isSystemTable(name, schema, targetSchema)\n-            || (name != null && name.toLowerCase().startsWith(\"pg_\"));\n+            || (strName != null && strName.toLowerCase().startsWith(\"pg_\"));\n     }\n \n     public boolean isSystemIndex(String name, Table table) {\n+        return isSystemIndex(DBIdentifier.newIndex(name), table);\n+    }\n+\n+    public boolean isSystemIndex(DBIdentifier name, Table table) {\n         // names starting with \"pg_\" are reserved for Postgresql internal use\n+        String strName = DBIdentifier.isNull(name) ? null : name.getName();\n         return super.isSystemIndex(name, table)\n-            || (name != null && name.toLowerCase().startsWith(\"pg_\"));\n+            || (strName != null && strName.toLowerCase().startsWith(\"pg_\"));\n     }\n \n     public Connection decorate(Connection conn)"},{"sha":"04cb56fef600e1b73d671692559b3c1a255668fb","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PrimaryRow.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PrimaryRow.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PrimaryRow.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/PrimaryRow.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -342,7 +342,7 @@ protected void setObject(Column col, Object val, int metaType,\n             \t\tsuper.setObject(col, val, metaType, overrideDefault);\n             \t} else if (!isDefaultValue(val)) {\n             \t\tthrow new InvalidStateException(_loc.get(\"diff-values\",\n-            \t\t\t\tnew Object[]{ col.getFullName(),\n+            \t\t\t\tnew Object[]{ col.getFullDBIdentifier().getName(),\n                             (prev == null) ? null : prev.getClass(), prev,\n                             (val == null) ? null : val.getClass(), val })).\n             \t\t\t\tsetFatal(true);"},{"sha":"e00f59c64f48e52129f2e0bf7382285562d0dd76","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/ResultSetResult.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -38,6 +38,7 @@\n import java.util.Locale;\n import java.util.Map;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.meta.JavaSQLTypes;\n import org.apache.openjpa.jdbc.schema.Column;\n@@ -505,8 +506,8 @@ protected int findObject(Object obj, Joins joins)\n         throws SQLException {\n         try {\n           String s1 = obj.toString();\n-          s1 = _dict.stripDelimiters(s1);\n-          return getResultSet().findColumn(s1);\n+          DBIdentifier sName = DBIdentifier.newColumn(obj.toString());\n+          return getResultSet().findColumn(_dict.convertSchemaCase(sName));\n         } catch (SQLException se) {\n             return 0;\n         }"},{"sha":"576974f3255d0299c85dbe2b656645d0525c82a6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/RowImpl.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -758,7 +758,7 @@ private String getUpdateSQL(DBDictionary dict) {\n \n             if (hasVal)\n                 buf.append(\", \");\n-            buf.append(_cols[i]);\n+            buf.append(dict.getColumnDBName(_cols[i]));\n             if (_types[i] == RAW)\n                 buf.append(\" = \").append(_vals[i]);\n             else\n@@ -788,7 +788,7 @@ private String getInsertSQL(DBDictionary dict) {\n                 buf.append(\", \");\n                 vals.append(\", \");\n             }\n-            buf.append(_cols[i]);\n+            buf.append(dict.getColumnDBName(_cols[i]));\n             if (_types[i] == RAW)\n                 vals.append(_vals[i]);\n             else\n@@ -827,16 +827,16 @@ private void appendWhere(StringBuilder buf, DBDictionary dict) {\n \n             // Get platform specific version column name\n             if (_cols[i].getVersionStrategy() != null)\n-               buf.append(dict.getVersionColumn(_cols[i], _cols[i]\n-                   .getTableName())).append(\" = ?\");\n+               buf.append(dict.toDBName(dict.getVersionColumn(_cols[i], _cols[i]\n+                   .getTableIdentifier()))).append(\" = ?\");\n             // sqlserver seems to have problems using null parameters in the\n             // where clause\n             else if (_vals[getWhereIndex(_cols[i])] == NULL)\n-                buf.append(_cols[i]).append(\" IS NULL\");\n+                buf.append(dict.getColumnDBName(_cols[i])).append(\" IS NULL\");\n             else if (_types[i] == RAW)\n-                buf.append(_cols[i]).append(\" = \").append(_vals[i]);\n+                buf.append(dict.getColumnDBName(_cols[i])).append(\" = \").append(_vals[i]);\n             else\n-                buf.append(_cols[i]).append(\" = ?\");\n+                buf.append(dict.getColumnDBName(_cols[i])).append(\" = ?\");\n             hasWhere = true;\n         }\n     }"},{"sha":"9d9b150d446bcc74322b312544785affbbb7d010","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","status":"modified","additions":7,"deletions":1,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -30,6 +30,7 @@\n import java.util.List;\n \n import org.apache.commons.lang.ObjectUtils;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n import org.apache.openjpa.jdbc.kernel.exps.Val;\n import org.apache.openjpa.jdbc.schema.Column;\n@@ -182,6 +183,11 @@ else if (_cols != null)\n             }\n         }\n     }\n+    \n+    public SQLBuffer append(DBIdentifier name) {\n+        _sql.append(_dict.toDBName(name));\n+        return this;\n+    }\n \n     public SQLBuffer append(Table table) {\n         _sql.append(_dict.getFullName(table, false));\n@@ -194,7 +200,7 @@ public SQLBuffer append(Sequence seq) {\n     }\n \n     public SQLBuffer append(Column col) {\n-        _sql.append(col.getName());\n+        _sql.append(_dict.getColumnDBName(col));\n         return this;\n     }\n "},{"sha":"47144f44a7fad0cbb684efbf734ca41d767bd24a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -41,7 +41,7 @@\n import org.w3c.dom.NodeList;\n \n /**\n- * Parses XML content of SQL Error State codes to populate errro codes for\n+ * Parses XML content of SQL Error State codes to populate error codes for\n  * a given Database Dictionary.\n  * \n  * @author Pinaki Poddar"},{"sha":"1009c86712d9e67fd67671683cc51be9a60e813c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","status":"modified","additions":14,"deletions":1,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -27,6 +27,7 @@\n import java.sql.Types;\n import java.util.Set;\n \n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.kernel.JDBCStore;\n import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n import org.apache.openjpa.jdbc.schema.Column;\n@@ -35,6 +36,7 @@\n import org.apache.openjpa.meta.JavaTypes;\n import org.apache.openjpa.util.StoreException;\n \n+\n /**\n  * Dictionary for Microsoft SQL Server.\n  */\n@@ -139,12 +141,23 @@ else if (url != null &&\n     public Column[] getColumns(DatabaseMetaData meta, String catalog,\n         String schemaName, String tableName, String columnName, Connection conn)\n         throws SQLException {\n+        return getColumns(meta, DBIdentifier.newCatalog(catalog),\n+            DBIdentifier.newSchema(schemaName),\n+            DBIdentifier.newTable(tableName),\n+            DBIdentifier.newColumn(columnName),\n+            conn);\n+    }\n+\n+    public Column[] getColumns(DatabaseMetaData meta, DBIdentifier catalog,\n+        DBIdentifier schemaName, DBIdentifier tableName, DBIdentifier columnName, Connection conn)\n+        throws SQLException {\n+\n         Column[] cols = super.getColumns(meta, catalog, schemaName, tableName,\n             columnName, conn);\n \n         // for opta driver, which reports nvarchar as unknown type\n         for (int i = 0; cols != null && i < cols.length; i++) {\n-            String typeName = cols[i].getTypeName();\n+            String typeName = cols[i].getTypeIdentifier().getName();\n             if (typeName == null)\n                 continue;\n "},{"sha":"1e5dc54c9abd3bfa10980b043abc86a102ce26ce","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","status":"modified","additions":6,"deletions":7,"changes":13,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -688,7 +688,7 @@ public String getColumnAlias(Column col, Joins joins) {\n      * Return the alias for the given column.\n      */\n     private String getColumnAlias(Column col, PathJoins pj) {\n-        return getColumnAlias(col.getName(), col.getTable(), pj);\n+        return getColumnAlias(col.getIdentifier().getName(), col.getTable(), pj);\n     }\n \n     public String getColumnAlias(String col, Table table) {\n@@ -703,7 +703,6 @@ public String getColumnAlias(String col, Table table, Joins joins) {\n      * Return the alias for the give column\n      */\n     public String getColumnAlias(Column col, Object path) {\n-        String columnName = col.getName();\n         Table table = col.getTable();\n         String tableAlias = null;\n         Iterator itr = getJoinIterator();\n@@ -716,19 +715,19 @@ else if (join.getTable2() == table)\n                     tableAlias = join.getAlias2();\n                 if (tableAlias != null)\n                     return new StringBuilder(tableAlias).append(\".\").\n-                        append(columnName).toString();\n+                        append(_dict.getNamingUtil().toDBName(col.getIdentifier())).toString();\n             }\n         }\n         throw new InternalException(\"Can not resolve alias for field: \" +\n-            path.toString() + \" mapped to column: \" + columnName +\n-            \" table: \"+table.getName());\n+            path.toString() + \" mapped to column: \" + col.getIdentifier().getName() +\n+            \" table: \"+table.getIdentifier().getName());\n     }\n \n     /**\n      * Return the alias for the given column.\n      */\n     private String getColumnAlias(String col, Table table, PathJoins pj) {\n-        return getTableAlias(table, pj).append(col).toString();\n+        return getTableAlias(table, pj).append(_dict.getNamingUtil().toDBName(col)).toString();\n     }\n     \n     private StringBuilder getTableAlias(Table table, PathJoins pj) {\n@@ -1987,7 +1986,7 @@ private int getTableIndex(Table table, PathJoins pj, boolean create) {\n             return -1;\n \n         Integer i = null;\n-        Object key = table.getFullName();\n+        Object key = table.getFullIdentifier().getName();\n         if (pj != null && pj.path() != null)\n             key = new Key(pj.path().toString(), key);\n "},{"sha":"6e9d55440b71fbb819c935004446f63d1a754fc4","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java","status":"modified","additions":21,"deletions":11,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -29,6 +29,7 @@\n import java.util.Arrays;\n \n import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n import org.apache.openjpa.jdbc.schema.Index;\n@@ -164,6 +165,7 @@ public SybaseDictionary() {\n         supportsCascadeUpdateAction = false;\n     }\n \n+    @Override\n     public int getJDBCType(int metaTypeCode, boolean lob) {\n         switch (metaTypeCode) {\n             // the default mapping for BYTE is a TINYINT, but Sybase's TINYINT\n@@ -176,6 +178,7 @@ public int getJDBCType(int metaTypeCode, boolean lob) {\n         }\n     }\n \n+    @Override\n     public void setBigInteger(PreparedStatement stmnt, int idx, BigInteger val,\n         Column col)\n         throws SQLException {\n@@ -185,11 +188,13 @@ public void setBigInteger(PreparedStatement stmnt, int idx, BigInteger val,\n         setObject(stmnt, idx, new BigDecimal(val), Types.BIGINT, col);\n     }\n \n+    @Override\n     public String[] getAddForeignKeySQL(ForeignKey fk) {\n         // Sybase has problems with adding foriegn keys via ALTER TABLE command\n         return new String[0];\n     }\n \n+    @Override\n     public String[] getCreateTableSQL(Table table) {\n         if (!createIdentityColumn)\n             return super.getCreateTableSQL(table);\n@@ -230,9 +235,10 @@ public void setBigInteger(PreparedStatement stmnt, int idx, BigInteger val,\n         return new String[]{ buf.toString() };\n     }\n \n+    @Override\n     protected String getDeclareColumnSQL(Column col, boolean alter) {\n         StringBuilder buf = new StringBuilder();\n-        buf.append(col).append(\" \");\n+        buf.append(getColumnDBName(col)).append(\" \");\n         buf.append(getTypeName(col));\n \n         // can't add constraints to a column we're adding after table\n@@ -255,24 +261,27 @@ else if (!col.isPrimaryKey()) {\n         return buf.toString();\n     }\n \n+    @Override\n     public String[] getDropColumnSQL(Column column) {\n         // Sybase uses \"ALTER TABLE DROP <COLUMN_NAME>\" rather than the\n         // usual \"ALTER TABLE DROP COLUMN <COLUMN_NAME>\"\n         return new String[]{ \"ALTER TABLE \"\n-            + getFullName(column.getTable(), false) + \" DROP \" + column };\n+            + getFullName(column.getTable(), false) + \" DROP \" + getColumnDBName(column) };\n     }\n \n+    @Override\n     public void refSchemaComponents(Table table) {\n         // note that we use getColumns() rather than getting the column by name\n         // because under some circumstances this method is called under the\n         // dynamic schema factory, where getting a column by name creates\n         // that column\n         Column[] cols = table.getColumns();\n         for (int i = 0; i < cols.length; i++)\n-            if (identityColumnName.equalsIgnoreCase(cols[i].getName()))\n+            if (identityColumnName.equalsIgnoreCase(cols[i].getIdentifier().getName()))\n                 cols[i].ref();\n     }\n \n+    @Override\n     public void endConfiguration() {\n         super.endConfiguration();\n \n@@ -286,6 +295,7 @@ public void endConfiguration() {\n         }\n     }\n \n+    @Override\n     public Connection decorate(Connection conn)\n         throws SQLException {\n         conn = super.decorate(conn);\n@@ -320,10 +330,10 @@ public Connection decorate(Connection conn)\n     protected PrimaryKey newPrimaryKey(ResultSet pkMeta)\n         throws SQLException {\n         PrimaryKey pk = new PrimaryKey();\n-        pk.setSchemaName(pkMeta.getString(\"table_owner\"));\n-        pk.setTableName(pkMeta.getString(\"table_name\"));\n-        pk.setColumnName(pkMeta.getString(\"column_name\"));\n-        pk.setName(pkMeta.getString(\"index_name\"));\n+        pk.setSchemaIdentifier(fromDBName(pkMeta.getString(\"table_owner\"), DBIdentifierType.SCHEMA));\n+        pk.setTableIdentifier(fromDBName(pkMeta.getString(\"table_name\"), DBIdentifierType.TABLE));\n+        pk.setColumnIdentifier(fromDBName(pkMeta.getString(\"column_name\"), DBIdentifierType.COLUMN));\n+        pk.setIdentifier(fromDBName(pkMeta.getString(\"index_name\"), DBIdentifierType.CONSTRAINT));\n         return pk;\n     }\n \n@@ -333,10 +343,10 @@ protected PrimaryKey newPrimaryKey(ResultSet pkMeta)\n     protected Index newIndex(ResultSet idxMeta)\n         throws SQLException {\n         Index idx = new Index();\n-        idx.setSchemaName(idxMeta.getString(\"table_owner\"));\n-        idx.setTableName(idxMeta.getString(\"table_name\"));\n-        idx.setColumnName(idxMeta.getString(\"column_name\"));\n-        idx.setName(idxMeta.getString(\"index_name\"));\n+        idx.setSchemaIdentifier(fromDBName(idxMeta.getString(\"table_owner\"), DBIdentifierType.SCHEMA));\n+        idx.setTableIdentifier(fromDBName(idxMeta.getString(\"table_name\"), DBIdentifierType.TABLE));\n+        idx.setColumnIdentifier(fromDBName(idxMeta.getString(\"column_name\"), DBIdentifierType.COLUMN));\n+        idx.setIdentifier(fromDBName(idxMeta.getString(\"index_name\"), DBIdentifierType.INDEX));\n         idx.setUnique(!idxMeta.getBoolean(\"non_unique\"));\n         return idx;\n     }"},{"sha":"05c2920755842775bd66f0c766e3a88a726d35d1","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","status":"modified","additions":4,"deletions":0,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -200,3 +200,7 @@ dbcp-unwrap-failed: Unable to get underlying connection from DBCP pooled \\\n connection-unwrap-failed: Unable to get underlying connection from pooled \\\n \tconnection. Java version 6 and a version 4 capable JDBC driver \\\n \tor data source are minimum requirements to perform this operation.\n+cannot-determine-identifier-case: Unable to determine the case to use for delimited \\\n+    identifiers.  The default value of \"preserve\" will be used.\n+unknown-delim-support: Unable to determine whether delimited identifiers are supported. \\\n+    The use of delimiters will not be supported."},{"sha":"095d509388fac534141f7928411f281a347447f8","filename":"openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/sql/identifier/TestDBIdentifiers.java","status":"added","additions":275,"deletions":0,"changes":275,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/sql/identifier/TestDBIdentifiers.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/sql/identifier/TestDBIdentifiers.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/sql/identifier/TestDBIdentifiers.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,275 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql.identifier;\n+\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.QualifiedDBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test operations on DBIdentifier and QualifiedDBIdentifier.\n+ *\n+ */\n+public class TestDBIdentifiers extends TestCase {\n+\n+    public void testSchemaOps() {\n+        // Use a schema name with punctuation.  It will get normalized with\n+        // delimiters.\n+        QualifiedDBIdentifier p1 = QualifiedDBIdentifier.newPath(DBIdentifier.newSchema(\"my.schema\"));\n+        DBIdentifier s1 = DBIdentifier.newSchema(\"my.schema\");\n+        assertTrue(QualifiedDBIdentifier.equal(p1, s1));\n+        assertEquals(\"\\\"my.schema\\\"\", p1.getName());\n+        assertEquals(\"\\\"my.schema\\\"\", s1.getName());\n+        assertEquals(p1.getType(), DBIdentifierType.SCHEMA);\n+        assertEquals(s1.getType(), DBIdentifierType.SCHEMA);\n+        assertFalse(s1 instanceof QualifiedDBIdentifier);\n+\n+        QualifiedDBIdentifier p2 = QualifiedDBIdentifier.newPath(DBIdentifier.newSchema(\"SCHEMA\"));\n+        DBIdentifier s2 = DBIdentifier.newSchema(\"SCHEMA2\");\n+        assertFalse(QualifiedDBIdentifier.equal(p2, s2));\n+        assertEquals(\"SCHEMA\", p2.getName());\n+        assertEquals(\"SCHEMA2\", s2.getName());\n+        assertEquals(p2.getType(), DBIdentifierType.SCHEMA);\n+        assertEquals(s2.getType(), DBIdentifierType.SCHEMA);\n+        assertTrue(p2 instanceof QualifiedDBIdentifier);\n+        assertFalse(s2 instanceof QualifiedDBIdentifier);\n+    }\n+\n+    public void testTableOps() {\n+        DBIdentifier name = DBIdentifier.newTable(\"table\");\n+        assertEquals(\"table\", name.getName());\n+        \n+        // Assert name is normalized using delimiters\n+        name = DBIdentifier.newTable(\"my table\");\n+        assertEquals(\"\\\"my table\\\"\", name.getName());\n+        // Assert name does not get split into multiple identifiers\n+        DBIdentifier[] names = QualifiedDBIdentifier.splitPath(name);\n+        assertTableEquals(names, null, \"\\\"my table\\\"\");\n+        \n+        // Split a delimited schema qualified table name\n+        name = DBIdentifier.newTable(\"\\\"my.schema\\\".\\\"my.table\\\"\");\n+        assertEquals(\"\\\"my.schema\\\".\\\"my.table\\\"\", name.getName());\n+        names = QualifiedDBIdentifier.splitPath(name);\n+        assertTableEquals(names, \"\\\"my.schema\\\"\", \"\\\"my.table\\\"\");\n+        \n+        // Split a non-delimited schema qualified table name\n+        name = DBIdentifier.newTable(\"my_schema.my_table\");\n+        assertEquals(\"my_schema.my_table\", name.getName());\n+        names = QualifiedDBIdentifier.splitPath(name);\n+        assertTableEquals(names, \"my_schema\", \"my_table\");\n+\n+        // Use Qualified Identifier to create a compound normalized schema and table name\n+        DBIdentifier tName = DBIdentifier.newTable(\"my table\");\n+        DBIdentifier sName = DBIdentifier.newSchema(\"my schema\");\n+        QualifiedDBIdentifier path = QualifiedDBIdentifier.newPath(sName, tName);\n+        assertEquals(\"\\\"my schema\\\".\\\"my table\\\"\", path.getName());\n+        assertEquals(tName.getName(), path.getBaseName());\n+        assertEquals(sName.getName(), path.getSchemaName().getName());\n+        \n+        // Use Qualified Identifier to create a compound non-normalized schema and table name\n+        tName = DBIdentifier.newTable(\"my_table\");\n+        sName = DBIdentifier.newSchema(\"my_schema\");\n+        path = QualifiedDBIdentifier.newPath(sName, tName);\n+        assertEquals(\"my_schema.my_table\", path.getName());\n+        assertEquals(tName.getName(), path.getBaseName());\n+        assertEquals(sName.getName(), path.getSchemaName().getName());\n+        \n+        QualifiedDBIdentifier p1 = QualifiedDBIdentifier.newPath(DBIdentifier.newSchema(\"schema\"), \n+            DBIdentifier.newTable(\"my table\"));\n+        QualifiedDBIdentifier p2 = QualifiedDBIdentifier.newPath(DBIdentifier.newSchema(\"schema\"), \n+            DBIdentifier.newTable(\"\\\"my table\\\"\"));        \n+        QualifiedDBIdentifier p3 = QualifiedDBIdentifier.newPath(DBIdentifier.newSchema(\"schema\"), \n+            DBIdentifier.newTable(\"my_table\"));\n+        assertTrue(p1.equals(p2));\n+        assertFalse(p1.equals(p3));\n+        assertFalse(p2.equals(p3));\n+        assertFalse(p1.equals(null));\n+        assertFalse(p1.equals(DBIdentifier.NULL));\n+    }\n+    \n+    public void testColumnOps() {\n+        \n+        DBIdentifier c0 = DBIdentifier.newColumn(\"\\\"col.1\\\"\");\n+        assertEquals(\"\\\"col.1\\\"\", c0.getName());\n+        assertTrue (c0 instanceof QualifiedDBIdentifier);\n+        assertEquals(c0.getType(), DBIdentifierType.COLUMN);\n+        \n+        // Test 3 part column name with mixed delimiting\n+        DBIdentifier c1 = DBIdentifier.newColumn(\"column 1\");\n+        DBIdentifier t1 = DBIdentifier.newTable(\"table\");\n+        DBIdentifier s1 = DBIdentifier.newSchema(\"\\\"my schema\\\"\");\n+        \n+        DBIdentifier p1 = QualifiedDBIdentifier.newPath(s1, t1, c1);\n+        assertEquals(\"\\\"my schema\\\".table.\\\"column 1\\\"\", p1.getName());\n+        \n+        DBIdentifier c2 = DBIdentifier.newColumn(\"\\\"column_2\\\"\");\n+        // Create a new table name without delimiters, but switch on the\n+        // delimit flag.  Otherwise, it will get parsed as a multi-part name.\n+        DBIdentifier t2 = DBIdentifier.newTable(\"table.2\", true);\n+        DBIdentifier p2 = QualifiedDBIdentifier.newPath(t2, c2);\n+        assertEquals(\"\\\"table.2\\\".\\\"column_2\\\"\", p2.getName());\n+        \n+    }\n+    \n+    public void testDBIdentifierOps() {\n+        \n+        // Test truncate\n+        DBIdentifier n1 = DBIdentifier.newColumn(\"abcdefgh\");\n+        n1 = DBIdentifier.truncate(n1,6);\n+        assertEquals(\"ab\", n1.getName());\n+\n+        // Test truncate with delimiters\n+        DBIdentifier n2 = DBIdentifier.newColumn(\"\\\"abcd efgh\\\"\");\n+        n2 = DBIdentifier.truncate(n2,3);\n+        assertEquals(\"\\\"abcd e\\\"\", n2.getName());\n+\n+        // Test append\n+        DBIdentifier n3 = DBIdentifier.newColumn(\"abcdefgh\");\n+        n3 = DBIdentifier.append(n3,\"ijk\");\n+        assertEquals(\"abcdefghijk\", n3.getName());\n+\n+        // Test append with the base name delimited\n+        DBIdentifier n4 = DBIdentifier.newColumn(\"\\\"abcd efgh\\\"\");\n+        n4 = DBIdentifier.append(n4, \"i k\");\n+        assertEquals(\"\\\"abcd efghi k\\\"\", n4.getName());\n+        \n+        // Test append with both names delimited\n+        DBIdentifier n5 = DBIdentifier.newColumn(\"\\\"abcd efgh\\\"\");\n+        n5 = DBIdentifier.append(n5, \"\\\"i k\\\"\");\n+        assertEquals(\"\\\"abcd efghi k\\\"\", n5.getName());\n+\n+        // Test clone\n+        DBIdentifier cn1 = DBIdentifier.newTable(\"sch.tbl\");\n+        DBIdentifier cn2 = cn1.clone();\n+        assertFalse(cn1 == cn2);\n+        assertEquals(cn1.getName(), cn2.getName());\n+        assertEquals(cn1, cn2);\n+        \n+        DBIdentifier tbl = DBIdentifier.newTable(\"tbl\");\n+        DBIdentifier sch = DBIdentifier.newSchema(\"sch\");\n+        QualifiedDBIdentifier path = QualifiedDBIdentifier.newPath(sch, tbl);\n+        QualifiedDBIdentifier path2 = path.clone();\n+        assertEquals(tbl.getName(), path.getBaseName());\n+        assertEquals(sch, path.getSchemaName());\n+        assertEquals(tbl.getName(), path2.getBaseName());\n+        assertEquals(sch, path2.getSchemaName());\n+        \n+        DBIdentifier tbl2 = DBIdentifier.newTable(\"tbl2\");\n+        DBIdentifier sch2 = DBIdentifier.newSchema(\"sch2\");\n+        DBIdentifier col = DBIdentifier.newColumn(\"col\");\n+        QualifiedDBIdentifier cpath = QualifiedDBIdentifier.newPath(sch2, tbl2, col);\n+        QualifiedDBIdentifier cpath2 = cpath.clone();\n+        assertEquals(col.getName(), cpath2.getBaseName());\n+        assertEquals(sch2, cpath2.getSchemaName());\n+        assertEquals(tbl2, cpath2.getObjectTableName());\n+        \n+        // Test delimit operation on create\n+        DBIdentifier dName = DBIdentifier.newColumn(\"\\\"ITEMNAME\\\"\", true);\n+        assertEquals(\"\\\"ITEMNAME\\\"\", dName.getName());\n+        \n+    }\n+    \n+    public void testPathOps() {\n+        \n+        // Test equals operator with case insensitive names\n+        QualifiedDBIdentifier p1 = QualifiedDBIdentifier.newPath(DBIdentifier.newTable(\"MyTable\"), \n+            DBIdentifier.newColumn(\"mycol\"));\n+        QualifiedDBIdentifier p2 = QualifiedDBIdentifier.newPath(DBIdentifier.newTable(\"MYTABLE\"), \n+            DBIdentifier.newColumn(\"MYCOL\"));\n+        assertTrue(QualifiedDBIdentifier.equal(p1, p1));\n+        \n+        // Test equals operator with delimited, case sensitive names\n+        QualifiedDBIdentifier p3 = QualifiedDBIdentifier.newPath(DBIdentifier.newTable(\"\\\"MyTable\\\"\"), \n+            DBIdentifier.newColumn(\"\\\"mycol\\\"\"));\n+        QualifiedDBIdentifier p4 = QualifiedDBIdentifier.newPath(DBIdentifier.newTable(\"MYTABLE\"), \n+            DBIdentifier.newColumn(\"MYCOL\"));\n+        QualifiedDBIdentifier p5 = QualifiedDBIdentifier.newPath(DBIdentifier.newTable(\"\\\"MyTable\\\"\"), \n+            DBIdentifier.newColumn(\"\\\"mycol\\\"\"));\n+        assertFalse(QualifiedDBIdentifier.equal(p3, p4));\n+        assertTrue(QualifiedDBIdentifier.equal(p3, p5));\n+        \n+        // Test setPath method\n+        QualifiedDBIdentifier p6 = QualifiedDBIdentifier.newPath(DBIdentifier.newTable(\"MyTable\"), \n+            DBIdentifier.newColumn(\"mycol\"));\n+        DBIdentifier n1 = DBIdentifier.newSchema(\"Schema_1\");\n+        DBIdentifier n2 = DBIdentifier.newTable(\"Table_1\");\n+        DBIdentifier n3 = DBIdentifier.newColumn(\"Column_1\");\n+        p6.setPath(n1);\n+        assertEquals(\"Schema_1\", n1.getName());\n+        assertEquals(n1.getType(), DBIdentifierType.SCHEMA);\n+        \n+        p6.setPath(n2);\n+        assertEquals(\"Table_1\", n2.getName());\n+        assertEquals(n2.getType(), DBIdentifierType.TABLE);\n+\n+        p6.setPath(n3);\n+        assertEquals(\"Column_1\", n3.getName());\n+        assertEquals(n3.getType(), DBIdentifierType.COLUMN);\n+\n+        // Test isDelimited method\n+        QualifiedDBIdentifier p7 = QualifiedDBIdentifier.newPath(DBIdentifier.newTable(\"MyTable\"), \n+            DBIdentifier.newColumn(\"mycol\"));\n+        assertFalse(p7.isDelimited());\n+        // All identifiers not delimited\n+        QualifiedDBIdentifier p8 = QualifiedDBIdentifier.newPath(DBIdentifier.newTable(\"My Table\"), \n+            DBIdentifier.newColumn(\"mycol\"));\n+        assertFalse(p8.isDelimited());\n+        // All identifiers delimited by default\n+        QualifiedDBIdentifier p9 = QualifiedDBIdentifier.newPath(DBIdentifier.newTable(\"My Table\"), \n+            DBIdentifier.newColumn(\"my col\"));\n+        assertTrue(p9.isDelimited());\n+\n+        // All identifiers specifically delimited\n+        QualifiedDBIdentifier p10 = QualifiedDBIdentifier.newPath(DBIdentifier.newTable(\"\\\"MyTable\\\"\"), \n+            DBIdentifier.newColumn(\"\\\"my col\\\"\"));\n+        assertTrue(p10.isDelimited());\n+\n+        // All identifiers specifically delimited sch + tbl + col\n+        QualifiedDBIdentifier p11 = QualifiedDBIdentifier.newPath(DBIdentifier.newSchema(\"\\\"MySchema\\\"\"), \n+            DBIdentifier.newTable(\"\\\"my tbl\\\"\"));\n+        assertTrue(p11.isDelimited());\n+\n+        // Table identifier not delimited\n+        QualifiedDBIdentifier p12 = QualifiedDBIdentifier.newPath(DBIdentifier.newSchema(\"\\\"MySchema\\\"\"), \n+            DBIdentifier.newTable(\"mytbl\"), \n+            DBIdentifier.newColumn(\"\\\"my col\\\"\"));\n+        assertFalse(p12.isDelimited());\n+\n+    }\n+\n+    private void assertTableEquals(DBIdentifier[] names, String schema,\n+        String table) {\n+        assertNotNull(names);\n+        assertEquals((schema == null ? 1 : 2), names.length);\n+        int idx = 0;\n+        if (schema != null) {\n+            assertEquals(DBIdentifierType.SCHEMA, names[idx].getType());\n+            assertEquals(names[idx].getName(), schema);\n+            idx++;\n+        } else {\n+            assertEquals(DBIdentifierType.TABLE, names[idx].getType());\n+            String path = QualifiedDBIdentifier.join(DBIdentifier.newSchema(schema), \n+                DBIdentifier.newTable(table));\n+            assertEquals(names[idx].getName(), path);\n+        }\n+    }\n+    \n+}"},{"sha":"789af6c1c399cecc988ab7dd7a2d932e7a8d67f4","filename":"openjpa-persistence-jdbc/src/main/ant/enhancer.xml","status":"modified","additions":11,"deletions":0,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/main/ant/enhancer.xml","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/main/ant/enhancer.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/ant/enhancer.xml?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -94,6 +94,7 @@\n                 <include name=\"**/inheritance/serializable/*.class\" />\n                 <!--  include files from orm.xml -->\n                 <include name=\"**/xml/*.class\" />\n+\t\t\t\t<exclude name=\"**/persistence/delimited/identifiers/xml/*.class\"/>\n                 <exclude name=\"**/Test*.class\" />\n             </fileset>\n             <config log=\"DefaultLevel=${openjpa.loglevel}\" />\n@@ -106,6 +107,16 @@\n \t\t\t\t<include name=\"**/persistence/property/AccessModsEntity.class\"/>\n             </fileset>\n             <config log=\"DefaultLevel=${openjpa.loglevel}\" />\n+        </openjpac>\n+\t\t<!-- Enhance delimited identifiers XML-based entities separately -->\n+        <openjpac>\n+            <config propertiesFile=\"${project.build.testOutputDirectory}/META-INF/delim_persistence.xml\" />\n+            <classpath refid=\"cp\" />\n+            <fileset dir=\"${project.build.testOutputDirectory}\">\n+\t\t\t\t<include name=\"**/persistence/delimited/identifiers/xml/*.class\"/>\n+\t\t\t\t<exclude name=\"**/persistence/delimited/identifiers/xml/Test*.class\"/>\n+            </fileset>\n+            <config log=\"DefaultLevel=${openjpa.loglevel}\" />\n         </openjpac>\n     </target>\n </project>"},{"sha":"9ca47021aacf89fb48087fe800f1ddab30d762bc","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingParser.java","status":"modified","additions":184,"deletions":189,"changes":373,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingParser.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/AnnotationPersistenceMappingParser.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -62,6 +62,9 @@\n \n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.QualifiedDBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier.DBIdentifierType;\n import org.apache.openjpa.jdbc.kernel.EagerFetchModes;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.ClassMappingInfo;\n@@ -113,8 +116,8 @@\n     private static final Localizer _loc = Localizer.forPackage\n         (AnnotationPersistenceMappingParser.class);\n \n-    private static final Map<Class, MappingTag> _tags =\n-        new HashMap<Class, MappingTag>();\n+    private static final Map<Class<?>, MappingTag> _tags =\n+        new HashMap<Class<?>, MappingTag>();\n     \n     private DBDictionary _dict; \n \n@@ -255,14 +258,9 @@ private void parseTableGenerator(AnnotatedElement el, TableGenerator gen) {\n \n         meta = (SequenceMapping) getRepository().addSequenceMetaData(name);\n         meta.setSequencePlugin(SequenceMapping.IMPL_VALUE_TABLE);\n-        meta.setTable(toTableName(gen.schema(), gen.table(),\n-            DBDictionary.DBIdentifiers.TABLE_GEN_SCHEMA, DBDictionary.DBIdentifiers.TABLE_GEN_TABLE));\n-        String pkColumnName = _dict.delimitString(gen.pkColumnName(), \n-            DBDictionary.DBIdentifiers.TABLE_GEN_PK_COLUMN);\n-        meta.setPrimaryKeyColumn(pkColumnName);\n-        String valueColumnName = _dict.delimitString(gen.valueColumnName(), \n-            DBDictionary.DBIdentifiers.TABLE_GEN_VALUE_COLUMN);\n-        meta.setSequenceColumn(valueColumnName);\n+        meta.setTableIdentifier(toTableIdentifier(gen.schema(), gen.table()));\n+        meta.setPrimaryKeyColumnIdentifier(DBIdentifier.newColumn(gen.pkColumnName(), delimit()));\n+        meta.setSequenceColumnIdentifier(DBIdentifier.newColumn(gen.valueColumnName(),delimit()));\n         meta.setPrimaryKeyValue(gen.pkColumnValue());\n         meta.setInitialValue(gen.initialValue());\n         meta.setAllocate(gen.allocationSize());\n@@ -273,8 +271,10 @@ private void parseTableGenerator(AnnotatedElement el, TableGenerator gen) {\n         case 0: \n         \tbreak; // nothing to do\n         case 1: \n-        \tmeta.setUniqueColumns(gen.uniqueConstraints()[0].columnNames());\n-        \tmeta.setUniqueConstraintName(gen.uniqueConstraints()[0].name());\n+        \tmeta.setUniqueColumnsIdentifier(DBIdentifier.toArray(gen.uniqueConstraints()[0].columnNames(), \n+        \t    DBIdentifierType.COLUMN, delimit()));\n+        \tmeta.setUniqueConstraintIdentifier(DBIdentifier.newConstraint(gen.uniqueConstraints()[0].name(), \n+        \t    delimit()));\n         \tbreak;\n         default:\n         \tlog.warn(_loc.get(\"unique-many-on-seq-unsupported\", el, name));\n@@ -284,7 +284,7 @@ private void parseTableGenerator(AnnotatedElement el, TableGenerator gen) {\n     @Override\n     protected void parseClassMappingAnnotations(ClassMetaData meta) {\n         ClassMapping cm = (ClassMapping) meta;\n-        Class cls = cm.getDescribedType();\n+        Class<?> cls = cm.getDescribedType();\n \n         MappingTag tag;\n         for (Annotation anno : cls.getDeclaredAnnotations()) {\n@@ -486,13 +486,11 @@ private Column newColumn(PrimaryKeyJoinColumn join) {\n         Column col = new Column();\n         col.setFlag(Column.FLAG_PK_JOIN, true);\n         if (!StringUtils.isEmpty(join.name()))\n-            col.setName(_dict.delimitString(join.name(), DBDictionary.DBIdentifiers.PRIMARY_KEY_JOIN_COLUMN_NAME));\n+            col.setIdentifier(DBIdentifier.newColumn(join.name(), delimit()));\n         if (!StringUtils.isEmpty(join.columnDefinition()))\n-            col.setTypeName(_dict.delimitString(join.columnDefinition(), \n-                DBDictionary.DBIdentifiers.PRIMARY_KEY_JOIN_COLUMN_COLUMN_DEFINITION));\n+            col.setTypeIdentifier(DBIdentifier.newColumnDefinition(join.columnDefinition()));\n         if (!StringUtils.isEmpty(join.referencedColumnName()))\n-            col.setTarget(_dict.delimitString(join.referencedColumnName(),\n-                DBDictionary.DBIdentifiers.PRIMARY_KEY_JOIN_COLUMN_REFERENCED_COLUMN_NAME));\n+            col.setTargetIdentifier(DBIdentifier.newColumn(join.referencedColumnName(), delimit()));\n         return col;\n     }\n \n@@ -502,30 +500,25 @@ private Column newColumn(PrimaryKeyJoinColumn join) {\n     private void parseSecondaryTables(ClassMapping cm,\n         SecondaryTable... tables) {\n         ClassMappingInfo info = cm.getMappingInfo();\n-        Log log = getLog();\n \n-        String name;\n-        String schema;\n         List<Column> joins = null;\n         for (SecondaryTable table : tables) {\n-            name = _dict.delimitString(table.name(),\n-                DBDictionary.DBIdentifiers.SECONDARY_TABLE_NAME) ;\n-            if (StringUtils.isEmpty(name))\n+            DBIdentifier sName = DBIdentifier.newTable(table.name(), delimit());\n+            if (DBIdentifier.isEmpty(sName))\n                 throw new MetaDataException(_loc.get(\"second-name\", cm));\n             if (!StringUtils.isEmpty(table.schema())) {\n-                schema = _dict.delimitString(table.schema(),\n-                    DBDictionary.DBIdentifiers.SECONDARY_TABLE_SCHEMA);\n-                name = schema + \".\" + name;\n+                DBIdentifier sSchema = DBIdentifier.newSchema(table.schema(), delimit());\n+                sName = QualifiedDBIdentifier.newPath(sSchema, sName);\n             }\n             if (table.pkJoinColumns().length > 0) {\n                 joins = new ArrayList<Column>(table.pkJoinColumns().length);\n                 for (PrimaryKeyJoinColumn join : table.pkJoinColumns())\n                     joins.add(newColumn(join));\n-                info.setSecondaryTableJoinColumns(name, joins);\n+                info.setSecondaryTableJoinColumns(sName, joins);\n             } else {\n-            \tinfo.addSecondaryTable(name);\n+            \tinfo.addSecondaryTable(sName);\n             }\n-            addUniqueConstraints(name, cm, info, table.uniqueConstraints());\n+            addUniqueConstraints(sName.getName(), cm, info, table.uniqueConstraints());\n         }\n     }\n \n@@ -535,32 +528,30 @@ private void parseSecondaryTables(ClassMapping cm,\n     private void parseTable(ClassMapping cm, Table table) {\n         if (cm.isAbstract())\n             throw new UserException(_loc.get(\"table-not-allowed\", cm));\n-        String tableName = toTableName(table.schema(), table.name(),\n-            DBDictionary.DBIdentifiers.TABLE_SCHEMA, DBDictionary.DBIdentifiers.TABLE_NAME);\n-        if (tableName != null) {\n-            cm.getMappingInfo().setTableName(tableName);\n+        DBIdentifier tName = toTableIdentifier(table.schema(), table.name());\n+        if (!DBIdentifier.isNull(tName)) {\n+            cm.getMappingInfo().setTableIdentifier(tName);\n         }\n-        addUniqueConstraints(tableName, cm, cm.getMappingInfo(),\n+        addUniqueConstraints(tName.getName(), cm, cm.getMappingInfo(),\n             table.uniqueConstraints());\n     }\n     \n     Unique createUniqueConstraint(MetaDataContext ctx, UniqueConstraint anno) {\n         String[] columnNames = anno.columnNames();\n         if (columnNames == null || columnNames.length == 0)\n             throw new UserException(_loc.get(\"unique-no-column\", ctx));\n-        _dict.delimitArray(columnNames, DBDictionary.DBIdentifiers.UNIQUE_CONSTRAINT_COLUMN_NAMES);\n+        DBIdentifier[] sColNames = DBIdentifier.toArray(columnNames,DBIdentifierType.COLUMN, delimit());\n         Unique uniqueConstraint = new Unique();\n-        for (int i = 0; i < columnNames.length; i++) {\n-            if (StringUtils.isEmpty(columnNames[i]))\n+        for (int i = 0; i < sColNames.length; i++) {\n+            if (DBIdentifier.isEmpty(sColNames[i]))\n                 throw new UserException(_loc.get(\"unique-empty-column\",\n-                        Arrays.toString(columnNames), ctx));\n+                        Arrays.toString(sColNames), ctx));\n             Column column = new Column();\n-            column.setName(columnNames[i]);\n+            column.setIdentifier(sColNames[i]);\n             uniqueConstraint.addColumn(column);\n         }\n-        String name = _dict.delimitString(anno.name(), DBDictionary.DBIdentifiers.UNIQUE_CONSTRAINT_NAME);\n-        if (!StringUtils.isEmpty(name)) {\n-            uniqueConstraint.setName(name);\n+        if (!StringUtils.isEmpty(anno.name())) {\n+            uniqueConstraint.setIdentifier(DBIdentifier.newConstraint(anno.name(), delimit()));\n         }\n         return uniqueConstraint;\n     }\n@@ -569,7 +560,7 @@ void addUniqueConstraints(String table, MetaDataContext ctx,\n         MappingInfo info, UniqueConstraint... uniqueConstraints) {\n         for (UniqueConstraint anno : uniqueConstraints) {\n             Unique unique = createUniqueConstraint(ctx, anno);\n-            unique.setTableName(table);\n+            unique.setTableIdentifier(DBIdentifier.newTable(table, delimit()));\n             if (info instanceof ClassMappingInfo)\n                 ((ClassMappingInfo) info).addUnique(table, unique);\n             else if (info instanceof FieldMappingInfo)\n@@ -582,15 +573,16 @@ else if (info instanceof FieldMappingInfo)\n     /**\n      * Form a qualified table name from a schema and table name.\n      */\n-    private String toTableName(String schema, String table, \n-        DBDictionary.DBIdentifiers schemaType, DBDictionary.DBIdentifiers nameType) {\n-        if (StringUtils.isEmpty(table))\n-            return null;\n-        if (StringUtils.isEmpty(schema))\n-            return _dict.delimitString(table, nameType);\n-        String delimTable = _dict.delimitString(table, nameType);\n-        String delimSchema = _dict.delimitString(schema, schemaType);\n-        return delimSchema + \".\" + delimTable;\n+    private DBIdentifier toTableIdentifier(String schema, String table) {\n+        if (StringUtils.isEmpty(table)) {\n+            return DBIdentifier.NULL;\n+        }\n+        DBIdentifier tName = DBIdentifier.newTable(table, delimit());\n+        DBIdentifier sName = DBIdentifier.newSchema(schema, delimit());\n+        if (DBIdentifier.isEmpty(tName) || DBIdentifier.isEmpty(sName)) {\n+            return tName;\n+        }\n+        return QualifiedDBIdentifier.newPath(sName, tName);\n     }\n \n     /**\n@@ -625,14 +617,13 @@ private void parseSQLResultSetMappings(ClassMapping cm,\n                         entity.discriminatorColumn());\n \n                 for (FieldResult field : entity.fields()) {\n-                    String column = _dict.delimitString(field.column(), \n-                        DBDictionary.DBIdentifiers.FIELD_RESULT_COLUMN);\n-                    entityResult.addMapping(field.name(), column);\n+                    DBIdentifier sColName = DBIdentifier.newColumn(field.column(), delimit());\n+                    entityResult.addMapping(field.name(), sColName.getName());\n                 }\n             }\n             for (ColumnResult column : anno.columns()) {\n-                result.addColumnResult(_dict.delimitString(column.name(), \n-                    DBDictionary.DBIdentifiers.COLUMN_REUSLT_NAME));\n+                DBIdentifier sName = DBIdentifier.newColumn(column.name(), delimit());\n+                result.addColumnResult(sName.getName());\n             }\n         }\n     }\n@@ -643,11 +634,12 @@ private void parseSQLResultSetMappings(ClassMapping cm,\n     private void parseDiscriminatorColumn(ClassMapping cm,\n         DiscriminatorColumn dcol) {\n         Column col = new Column();\n-        if (!StringUtils.isEmpty(dcol.name()))\n-            col.setName(_dict.delimitString(dcol.name(), DBDictionary.DBIdentifiers.DISCRIMINATOR_COLUMN_NAME));\n-        if (!StringUtils.isEmpty(dcol.columnDefinition()))\n-            col.setTypeName(_dict.delimitString(dcol.columnDefinition(), \n-                DBDictionary.DBIdentifiers.DISCRIMINATOR_COLUMN_COLUMN_DEFINITION));\n+        if (!StringUtils.isEmpty(dcol.name())) {\n+            col.setIdentifier(DBIdentifier.newColumn(dcol.name(),delimit()));\n+        }\n+        if (!StringUtils.isEmpty(dcol.columnDefinition())) {\n+            col.setTypeIdentifier(DBIdentifier.newColumnDefinition(dcol.columnDefinition()));\n+        }\n         Discriminator discrim = cm.getDiscriminator();\n         switch (dcol.discriminatorType()) {\n             case CHAR:\n@@ -723,9 +715,9 @@ private void populate(FieldMapping fm, MappingOverride over) {\n     private void parseDataStoreIdColumn(ClassMapping cm, DataStoreIdColumn id) {\n         Column col = new Column();\n         if (!StringUtils.isEmpty(id.name()))\n-            col.setName(id.name());\n+            col.setIdentifier(DBIdentifier.newColumn(id.name(), delimit()));\n         if (!StringUtils.isEmpty(id.columnDefinition()))\n-            col.setTypeName(id.columnDefinition());\n+            col.setTypeIdentifier(DBIdentifier.newColumnDefinition(id.columnDefinition()));\n         if (id.precision() != 0)\n             col.setSize(id.precision());\n         col.setFlag(Column.FLAG_UNINSERTABLE, !id.insertable());\n@@ -760,7 +752,7 @@ protected void parseForeignKey(MappingInfo info, String name,\n         org.apache.openjpa.jdbc.schema.ForeignKey fk =\n             new org.apache.openjpa.jdbc.schema.ForeignKey();\n         if (!StringUtils.isEmpty(name))\n-            fk.setName(name);\n+            fk.setIdentifier(DBIdentifier.newForeignKey(name, delimit()));\n         fk.setDeferred(deferred);\n         fk.setDeleteAction(toForeignKeyAction(deleteAction));\n         fk.setUpdateAction(toForeignKeyAction(updateAction));\n@@ -820,7 +812,7 @@ protected void parseIndex(MappingInfo info, String name,\n         org.apache.openjpa.jdbc.schema.Index idx =\n             new org.apache.openjpa.jdbc.schema.Index();\n         if (!StringUtils.isEmpty(name))\n-            idx.setName(name);\n+            idx.setIdentifier(DBIdentifier.newConstraint(name, delimit()));\n         idx.setUnique(unique);\n         info.setIndex(idx);\n     }\n@@ -839,7 +831,7 @@ private void parseUnique(FieldMapping fm,\n         org.apache.openjpa.jdbc.schema.Unique unq = \n             new org.apache.openjpa.jdbc.schema.Unique();\n         if (!StringUtils.isEmpty(anno.name()))\n-            unq.setName(anno.name());\n+            unq.setIdentifier(DBIdentifier.newIndex(anno.name(), delimit()));\n         unq.setDeferred(anno.deferred());\n         info.setUnique(unq);\n     }\n@@ -853,27 +845,27 @@ private void parseVersionColumns(ClassMapping cm, VersionColumn... vcols) {\n \n         List<Column> cols = new ArrayList<Column>(vcols.length);\n         for (VersionColumn vcol : vcols)\n-            cols.add(newColumn(vcol));\n+            cols.add(newColumn(vcol, delimit()));\n         cm.getVersion().getMappingInfo().setColumns(cols);\n     }\n \n     /**\n      * Create a new schema column with information from the given annotation.\n      */\n-    private static Column newColumn(VersionColumn anno) {\n+    private static Column newColumn(VersionColumn anno, boolean delimit) {\n         Column col = new Column();\n-        col.setTableName(anno.table());\n+        col.setTableIdentifier(DBIdentifier.newTable(anno.table(), delimit));\n         if (!StringUtils.isEmpty(anno.name()))\n-            col.setName(anno.name());\n+            col.setIdentifier(DBIdentifier.newColumn(anno.name(), delimit));\n         if (anno.precision() != 0)\n             col.setSize(anno.precision());\n         else if (anno.length() != 255)\n             col.setSize(anno.length());\n         col.setNotNull(!anno.nullable());\n         col.setDecimalDigits(anno.scale());\n         if (!StringUtils.isEmpty(anno.columnDefinition())) {\n-            col.setTypeName(anno.columnDefinition());\n-            col.setType(Schemas.getJDBCType(col.getTypeName()));\n+            col.setTypeIdentifier(DBIdentifier.newColumnDefinition(anno.columnDefinition()));\n+            col.setType(Schemas.getJDBCType(col.getTypeIdentifier().getName()));\n             col.setJavaType(JavaTypes.getTypeCode(Schemas.getJavaType\n             \t(col.getType(), col.getSize(), col.getDecimalDigits())));\n         }\n@@ -923,7 +915,7 @@ private void parseElementColumns(FieldMapping fm, ElementColumn... pcols) {\n         List<Column> cols = new ArrayList<Column>(pcols.length);\n         int unique = 0;\n         for (int i = 0; i < pcols.length; i++) {\n-            cols.add(newColumn(pcols[i]));\n+            cols.add(newColumn(pcols[i], delimit()));\n             unique |= (pcols[i].unique()) ? TRUE : FALSE;\n         }\n         setColumns(fm, fm.getElementMapping().getValueInfo(), cols, unique);\n@@ -932,12 +924,12 @@ private void parseElementColumns(FieldMapping fm, ElementColumn... pcols) {\n     /**\n      * Create a new schema column with information from the given annotation.\n      */\n-    private static Column newColumn(ElementColumn anno) {\n+    private static Column newColumn(ElementColumn anno, boolean delimit) {\n         Column col = new Column();\n         if (!StringUtils.isEmpty(anno.name()))\n-            col.setName(anno.name());\n+            col.setIdentifier(DBIdentifier.newColumn(anno.name(), delimit));\n         if (!StringUtils.isEmpty(anno.columnDefinition()))\n-            col.setTypeName(anno.columnDefinition());\n+            col.setTypeIdentifier(DBIdentifier.newColumnDefinition(anno.columnDefinition()));\n         if (anno.precision() != 0)\n             col.setSize(anno.precision());\n         else if (anno.length() != 255)\n@@ -959,7 +951,7 @@ private void parseKeyJoinColumns(FieldMapping fm, KeyJoinColumn... joins) {\n         List<Column> cols = new ArrayList<Column>(joins.length);\n         int unique = 0;\n         for (int i = 0; i < joins.length; i++) {\n-            cols.add(newColumn(joins[i]));\n+            cols.add(newColumn(joins[i], delimit()));\n             unique |= (joins[i].unique()) ? TRUE : FALSE;\n         }\n         setColumns(fm, fm.getKeyMapping().getValueInfo(), cols, unique);\n@@ -968,14 +960,14 @@ private void parseKeyJoinColumns(FieldMapping fm, KeyJoinColumn... joins) {\n     /**\n      *  Create a new schema column with information from the given annotation.\n      */\n-    private static Column newColumn(KeyJoinColumn join) {\n+    private static Column newColumn(KeyJoinColumn join, boolean delimit) {\n         Column col = new Column();\n         if (!StringUtils.isEmpty(join.name()))\n-            col.setName(join.name());\n+            col.setIdentifier(DBIdentifier.newColumn(join.name(),delimit));\n         if (!StringUtils.isEmpty(join.columnDefinition()))\n-            col.setName(join.columnDefinition());\n+            col.setIdentifier(DBIdentifier.newColumnDefinition(join.columnDefinition()));\n         if (!StringUtils.isEmpty(join.referencedColumnName()))\n-            col.setTarget(join.referencedColumnName());\n+            col.setTargetIdentifier(DBIdentifier.newColumn(join.referencedColumnName(),delimit));\n         if (!StringUtils.isEmpty(join.referencedAttributeName()))\n             col.setTargetField(join.referencedAttributeName());\n         col.setNotNull(!join.nullable());\n@@ -1083,8 +1075,8 @@ protected void parseMemberMappingAnnotations(FieldMetaData fmd) {\n                 case KEY_EMBEDDED_MAPPING:\n                     KeyEmbeddedMapping kembed = (KeyEmbeddedMapping) anno;\n                     parseEmbeddedMapping(fm.getKeyMapping(),\n-                        kembed.nullIndicatorColumnName(),\n-                        kembed.nullIndicatorAttributeName(),\n+                        DBIdentifier.newColumn(kembed.nullIndicatorColumnName(), delimit()),\n+                        DBIdentifier.newConstant(kembed.nullIndicatorAttributeName()),\n                         kembed.overrides());\n                     break;\n                 case KEY_FK:\n@@ -1169,8 +1161,8 @@ protected void parseMemberMappingAnnotations(FieldMetaData fmd) {\n                 case ELEM_EMBEDDED_MAPPING:\n                     ElementEmbeddedMapping ee = (ElementEmbeddedMapping) anno;\n                     parseEmbeddedMapping(fm.getElementMapping(),\n-                        ee.nullIndicatorAttributeName(),\n-                        ee.nullIndicatorColumnName(),\n+                        DBIdentifier.newConstant(ee.nullIndicatorAttributeName()),\n+                        DBIdentifier.newColumn(ee.nullIndicatorColumnName(), delimit()),\n                         ee.overrides());\n                     break;\n                 case ELEM_FK:\n@@ -1228,8 +1220,8 @@ protected void parseMemberMappingAnnotations(FieldMetaData fmd) {\n                     break;\n                 case X_EMBEDDED_MAPPING:\n                     XEmbeddedMapping embed = (XEmbeddedMapping) anno;\n-                    parseEmbeddedMapping(fm, embed.nullIndicatorColumnName(),\n-                        embed.nullIndicatorAttributeName(), embed.overrides());\n+                    parseEmbeddedMapping(fm, DBIdentifier.newColumn(embed.nullIndicatorColumnName(), delimit()),\n+                        DBIdentifier.newConstant(embed.nullIndicatorAttributeName()), embed.overrides());\n                     break;\n                 case X_JOIN_COL:\n                     parseXJoinColumns(fm, fm.getValueInfo(), true,\n@@ -1553,14 +1545,14 @@ protected void parseColumns(FieldMapping fm,\n         }\n \n         int unique = 0;\n-        String secondary = null;\n+        DBIdentifier sSecondary = DBIdentifier.NULL;\n         for (int i = 0; i < pcols.length; i++) {\n             if (cols.size() > i)\n-                setupColumn((Column) cols.get(i), pcols[i], _dict);\n+                setupColumn((Column) cols.get(i), pcols[i], delimit());\n             else {\n                 if (cols.isEmpty())\n                     cols = new ArrayList<Column>(pcols.length);\n-                cols.add(newColumn(pcols[i], _dict));\n+                cols.add(newColumn(pcols[i], delimit()));\n             }\n             \n             if (xmlTypeClass != null\n@@ -1572,44 +1564,41 @@ protected void parseColumns(FieldMapping fm,\n                     .getDBDictionary();\n                 if (dict.supportsXMLColumn)\n                     // column maps to xml type\n-                    ((Column) cols.get(i)).setTypeName(dict.xmlTypeName);\n+                    ((Column) cols.get(i)).setTypeIdentifier(DBIdentifier.newColumnDefinition(dict.xmlTypeName));\n             }\n \n             unique |= (pcols[i].unique()) ? TRUE : FALSE;\n-            String secTable = _dict.delimitString(pcols[i].table(),\n-                DBDictionary.DBIdentifiers.SECONDARY_TABLE_NAME);\n-        \tsecondary = trackSecondaryTable(fm, secondary,\tsecTable, i);\n+            DBIdentifier sSecTable = DBIdentifier.newTable(pcols[i].table(), delimit());\n+        \tsSecondary = trackSecondaryTable(fm, sSecondary, sSecTable, i);\n         }\n \n         if (fm.isElementCollection())\n             setColumns(fm, fm.getElementMapping().getValueInfo(), cols, unique);\n         else\n             setColumns(fm, fm.getValueInfo(), cols, unique);\n-        if (secondary != null)\n-            fm.getMappingInfo().setTableName(secondary);\n+        if (!DBIdentifier.isNull(sSecondary))\n+            fm.getMappingInfo().setTableIdentifier(sSecondary);\n     }\n \n     /**\n      * Create a new schema column with information from the given annotation.\n      */\n     private static Column newColumn(javax.persistence.Column anno,\n-        DBDictionary dict) {\n+        boolean delimit) {\n         Column col = new Column();\n-        setupColumn(col, anno, dict);\n+        setupColumn(col, anno, delimit);\n         return col;\n     }\n \n     /**\n      * Setup the given column with information from the given annotation.\n      */\n     private static void setupColumn(Column col, javax.persistence.Column anno,\n-        DBDictionary dict) {\n+        boolean delimit) {\n         if (!StringUtils.isEmpty(anno.name()))\n-            col.setName(dict.delimitString(anno.name(),\n-                DBDictionary.DBIdentifiers.COLUMN_NAME));\n+            col.setIdentifier(DBIdentifier.newColumn(anno.name(),delimit));\n         if (!StringUtils.isEmpty(anno.columnDefinition()))\n-            col.setTypeName(dict.delimitString(anno.columnDefinition(),\n-                DBDictionary.DBIdentifiers.COLUMN_COLUMN_DEFINITION));\n+            col.setTypeIdentifier(DBIdentifier.newColumnDefinition(anno.columnDefinition()));\n         if (anno.precision() != 0)\n             col.setSize(anno.precision());\n         else if (anno.length() != 255)\n@@ -1645,13 +1634,13 @@ protected void setColumns(FieldMapping fm, MappingInfo info,\n      * @param colSecondary secondary table for current column\n      * @return secondary table for field\n      */\n-    private String trackSecondaryTable(FieldMapping fm, String secondary,\n-        String colSecondary, int col) {\n-        if (StringUtils.isEmpty(colSecondary))\n-            colSecondary = null;\n+    private DBIdentifier trackSecondaryTable(FieldMapping fm, DBIdentifier secondary,\n+        DBIdentifier colSecondary, int col) {\n+        if (DBIdentifier.isEmpty(colSecondary))\n+            colSecondary = DBIdentifier.NULL;\n         if (col == 0)\n             return colSecondary;\n-        if (!StringUtils.equalsIgnoreCase(secondary, colSecondary))\n+        if (!DBIdentifier.equalsIgnoreCase(secondary, colSecondary))\n             throw new MetaDataException(_loc.get(\"second-inconsist\", fm));\n         return secondary;\n     }\n@@ -1661,12 +1650,12 @@ private String trackSecondaryTable(FieldMapping fm, String secondary,\n      */\n     private void parseJoinTable(FieldMapping fm, JoinTable join) {\n     \tFieldMappingInfo info = fm.getMappingInfo();\n-        info.setTableName(toTableName(join.schema(), join.name(),\n-            DBDictionary.DBIdentifiers.JOIN_TABLE_SCHEMA, DBDictionary.DBIdentifiers.JOIN_TABLE_NAME));\n+    \tDBIdentifier joinTbl = toTableIdentifier(join.schema(), join.name());\n+        info.setTableIdentifier(joinTbl);\n         parseJoinColumns(fm, info, false, join.joinColumns());\n         parseJoinColumns(fm, fm.getElementMapping().getValueInfo(), false,\n             join.inverseJoinColumns());\n-        addUniqueConstraints(info.getTableName(), fm, info,  \n+        addUniqueConstraints(info.getTableIdentifier().getName(), fm, info,  \n             join.uniqueConstraints());\n     }\n \n@@ -1680,20 +1669,20 @@ private void parseJoinColumns(FieldMapping fm, MappingInfo info,\n \n         List<Column> cols = new ArrayList<Column>(joins.length);\n         int unique = 0;\n-        String secondary = null;\n+        DBIdentifier sSecondary = DBIdentifier.NULL;\n         for (int i = 0; i < joins.length; i++) {\n             cols.add(newColumn(joins[i]));\n             unique |= (joins[i].unique()) ? TRUE : FALSE;\n-            String table = _dict.delimitString(joins[i].table(), DBDictionary.DBIdentifiers.JOIN_COLUMN_TABLE);\n-            secondary = trackSecondaryTable(fm, secondary,\n-                table, i);\n-            if (!secondaryAllowed && secondary != null)\n+            DBIdentifier sTable = DBIdentifier.newTable(joins[i].table(), delimit());\n+            sSecondary = trackSecondaryTable(fm, sSecondary,\n+                sTable, i);\n+            if (!secondaryAllowed && !DBIdentifier.isNull(sSecondary))\n                 throw new MetaDataException(_loc.get(\"bad-second\", fm));\n         }\n \n         setColumns(fm, info, cols, unique);\n-        if (secondary != null)\n-            fm.getMappingInfo().setTableName(secondary);\n+        if (!DBIdentifier.isNull(sSecondary))\n+            fm.getMappingInfo().setTableIdentifier(sSecondary);\n         String mappedByIdValue = fm.getMappedByIdValue();\n         if (mappedByIdValue != null) {\n             FieldMapping[] pks = fm.getDefiningMapping().getPrimaryKeyFieldMappings();\n@@ -1717,13 +1706,11 @@ private void parseJoinColumns(FieldMapping fm, MappingInfo info,\n     private Column newColumn(JoinColumn join) {\n         Column col = new Column();\n         if (!StringUtils.isEmpty(join.name()))\n-            col.setName(_dict.delimitString(join.name(), DBDictionary.DBIdentifiers.JOIN_COLUMN_NAME));\n+            col.setIdentifier(DBIdentifier.newColumn(join.name(), delimit()));\n         if (!StringUtils.isEmpty(join.columnDefinition()))\n-            col.setTypeName(_dict.delimitString(join.columnDefinition(), \n-                DBDictionary.DBIdentifiers.JOIN_COLUMN_COLUMN_DEFINITION));\n+            col.setTypeIdentifier(DBIdentifier.newColumnDefinition(join.columnDefinition())); \n         if (!StringUtils.isEmpty(join.referencedColumnName()))\n-            col.setTarget(_dict.delimitString(join.referencedColumnName(), \n-                DBDictionary.DBIdentifiers.JOIN_COLUMN_REFERENCED_COLUMN_NAME));\n+            col.setTargetIdentifier(DBIdentifier.newColumn(join.referencedColumnName(), delimit()));\n         col.setNotNull(!join.nullable());\n         col.setFlag(Column.FLAG_UNINSERTABLE, !join.insertable());\n         col.setFlag(Column.FLAG_UNUPDATABLE, !join.updatable());\n@@ -1740,7 +1727,7 @@ private void parseKeyColumns(FieldMapping fm, KeyColumn... pcols) {\n         List<Column> cols = new ArrayList<Column>(pcols.length);\n         int unique = 0;\n         for (int i = 0; i < pcols.length; i++) {\n-            cols.add(newColumn(pcols[i]));\n+            cols.add(newColumn(pcols[i], delimit()));\n             unique |= (pcols[i].unique()) ? TRUE : FALSE;\n         }\n         setColumns(fm, fm.getKeyMapping().getValueInfo(), cols, unique);\n@@ -1749,12 +1736,12 @@ private void parseKeyColumns(FieldMapping fm, KeyColumn... pcols) {\n     /**\n      * Create a new schema column with information from the given annotation.\n      */\n-    private static Column newColumn(KeyColumn anno) {\n+    private static Column newColumn(KeyColumn anno, boolean delimit) {\n         Column col = new Column();\n         if (!StringUtils.isEmpty(anno.name()))\n-            col.setName(anno.name());\n+            col.setIdentifier(DBIdentifier.newColumn(anno.name(), delimit));\n         if (!StringUtils.isEmpty(anno.columnDefinition()))\n-            col.setTypeName(anno.columnDefinition());\n+            col.setTypeIdentifier(DBIdentifier.newColumnDefinition(anno.columnDefinition()));\n         if (anno.precision() != 0)\n             col.setSize(anno.precision());\n         else if (anno.length() != 255)\n@@ -1787,32 +1774,32 @@ protected void parseXJoinColumns(FieldMapping fm, MappingInfo info,\n \n         List<Column> cols = new ArrayList<Column>(joins.length);\n         int unique = 0;\n-        String secondary = null;\n+        DBIdentifier sSecondary = DBIdentifier.NULL;\n         for (int i = 0; i < joins.length; i++) {\n-            cols.add(newColumn(joins[i]));\n+            cols.add(newColumn(joins[i], delimit()));\n             unique |= (joins[i].unique()) ? TRUE : FALSE;\n-            secondary = trackSecondaryTable(fm, secondary,\n-                joins[i].table(), i);\n-            if (!secondaryAllowed && secondary != null)\n+            sSecondary = trackSecondaryTable(fm, sSecondary,\n+                DBIdentifier.newTable(joins[i].table(), delimit()), i);\n+            if (!secondaryAllowed && !DBIdentifier.isNull(sSecondary))\n                 throw new MetaDataException(_loc.get(\"bad-second\", fm));\n         }\n \n         setColumns(fm, info, cols, unique);\n-        if (secondary != null)\n-            fm.getMappingInfo().setTableName(secondary);\n+        if (!DBIdentifier.isNull(sSecondary))\n+            fm.getMappingInfo().setTableIdentifier(sSecondary);\n     }\n \n     /**\n      * Create a new schema column with information from the given annotation.\n      */\n-    private static Column newColumn(XJoinColumn join) {\n+    private static Column newColumn(XJoinColumn join, boolean delimit) {\n         Column col = new Column();\n         if (!StringUtils.isEmpty(join.name()))\n-            col.setName(join.name());\n+            col.setIdentifier(DBIdentifier.newColumn(join.name(), delimit));\n         if (!StringUtils.isEmpty(join.columnDefinition()))\n-            col.setTypeName(join.columnDefinition());\n+            col.setTypeIdentifier(DBIdentifier.newColumnDefinition(join.columnDefinition()));\n         if (!StringUtils.isEmpty(join.referencedColumnName()))\n-            col.setTarget(join.referencedColumnName());\n+            col.setTargetIdentifier(DBIdentifier.newColumn(join.referencedColumnName(), delimit));\n         if (!StringUtils.isEmpty(join.referencedAttributeName()))\n             col.setTargetField(join.referencedAttributeName());\n         col.setNotNull(!join.nullable());\n@@ -1838,12 +1825,12 @@ private void parseEmbeddedMapping(FieldMapping fm, EmbeddedMapping anno) {\n             populate(efm, over);\n         }\n \n-        String nullInd = null;\n+        DBIdentifier nullInd = DBIdentifier.NULL;\n         if (!StringUtils.isEmpty(anno.nullIndicatorAttributeName()))\n-            nullInd = anno.nullIndicatorAttributeName();\n+            nullInd = DBIdentifier.newConstant(anno.nullIndicatorAttributeName());\n         else if (!StringUtils.isEmpty(anno.nullIndicatorColumnName()))\n-            nullInd = anno.nullIndicatorColumnName();\n-        if (nullInd == null)\n+            nullInd = DBIdentifier.newColumn(anno.nullIndicatorColumnName(), delimit());\n+        if (DBIdentifier.isNull(nullInd))\n             return;\n \n         ValueMappingInfo info = fm.getValueInfo();\n@@ -1854,7 +1841,7 @@ else if (!StringUtils.isEmpty(anno.nullIndicatorColumnName()))\n      * Parse embedded info for the given mapping.\n      */\n     private void parseEmbeddedMapping(ValueMapping vm, \n-        String nullIndicatorAttribute, String nullIndicatorColumn,\n+        DBIdentifier nullIndicatorAttribute, DBIdentifier nullIndicatorColumn,\n         XMappingOverride[] overrides) {\n         ClassMapping embed = vm.getEmbeddedMapping();\n         if (embed == null)\n@@ -1869,25 +1856,25 @@ private void parseEmbeddedMapping(ValueMapping vm,\n             populate(efm, over);\n         }\n \n-        String nullInd = null;\n-        if (!StringUtils.isEmpty(nullIndicatorAttribute))\n+        DBIdentifier nullInd = DBIdentifier.NULL;\n+        if (!DBIdentifier.isEmpty(nullIndicatorAttribute))\n             nullInd = nullIndicatorAttribute;\n-        else if (!StringUtils.isEmpty(nullIndicatorColumn))\n+        else if (!DBIdentifier.isEmpty(nullIndicatorColumn))\n             nullInd = nullIndicatorColumn;\n-        if (nullInd == null)\n+        if (DBIdentifier.isNull(nullInd))\n             return;\n \n         ValueMappingInfo info = vm.getValueInfo();\n         populateNullIndicator(nullInd, info);\n     }\n \n-    private void populateNullIndicator(String nullInd, ValueMappingInfo info) {\n-        if (\"false\".equals(nullInd))\n+    private void populateNullIndicator(DBIdentifier nullInd, ValueMappingInfo info) {\n+        if (\"false\".equals(nullInd.getName()))\n             info.setCanIndicateNull(false);\n         else {\n             Column col = new Column();\n-            if (!\"true\".equals(nullInd))\n-                col.setName(nullInd);\n+            if (!\"true\".equals(nullInd.getName()))\n+                col.setIdentifier(nullInd);\n             info.setColumns(Arrays.asList(new Column[]{ col }));\n         }\n     }\n@@ -1896,8 +1883,8 @@ private void populateNullIndicator(String nullInd, ValueMappingInfo info) {\n      * Parse @ContainerTable.\n      */\n     protected void parseContainerTable(FieldMapping fm, ContainerTable ctbl) {\n-        fm.getMappingInfo().setTableName(toTableName(ctbl.schema(),\n-            ctbl.name(), null, null));\n+        DBIdentifier tblName = toTableIdentifier(ctbl.schema(), ctbl.name());\n+        fm.getMappingInfo().setTableIdentifier(tblName);\n         parseXJoinColumns(fm, fm.getMappingInfo(), false, ctbl.joinColumns());\n         if (ctbl.joinForeignKey().specified())\n             parseForeignKey(fm.getMappingInfo(), ctbl.joinForeignKey());\n@@ -1910,11 +1897,11 @@ protected void parseContainerTable(FieldMapping fm, ContainerTable ctbl) {\n      */\n     protected void parseCollectionTable(FieldMapping fm, CollectionTable ctbl) {\n         FieldMappingInfo info = fm.getMappingInfo(); \n-        info.setTableName(toTableName(ctbl.schema(), ctbl.name(),\n-            DBDictionary.DBIdentifiers.COLLECTION_TABLE_SCHEMA, DBDictionary.DBIdentifiers.COLLECTION_TABLE_NAME));\n+        DBIdentifier tblName = toTableIdentifier(ctbl.schema(), ctbl.name());\n+        info.setTableIdentifier(tblName);\n         //ctbl.catalog()\n         parseJoinColumns(fm, fm.getMappingInfo(), false, ctbl.joinColumns());\n-        addUniqueConstraints(info.getTableName(), fm.getDefiningMetaData(), \n+        addUniqueConstraints(info.getTableIdentifier().getName(), fm.getDefiningMetaData(), \n             info, ctbl.uniqueConstraints());\n     }\n     \n@@ -1929,10 +1916,9 @@ private void parseOrderColumn(FieldMapping fm, OrderColumn order) {\n \n         Column col = new Column();\n         if (!StringUtils.isEmpty(order.name()))\n-            col.setName(_dict.delimitString(order.name(), DBDictionary.DBIdentifiers.ORDER_COLUMN_NAME));\n+            col.setIdentifier(DBIdentifier.newColumn(order.name(), delimit()));\n         if (!StringUtils.isEmpty(order.columnDefinition()))\n-            col.setTypeName(_dict.delimitString(order.columnDefinition(), \n-                DBDictionary.DBIdentifiers.ORDER_COLUMN_COLUMN_DEFINITION));\n+            col.setTypeIdentifier(DBIdentifier.newColumnDefinition(order.columnDefinition())); \n         if (order.precision() != 0)\n             col.setSize(order.precision());\n         col.setFlag(Column.FLAG_UNINSERTABLE, !order.insertable());\n@@ -1948,10 +1934,9 @@ private void parseJavaxOrderColumn(FieldMapping fm,\n         \n         Column col = new Column();\n         if (!StringUtils.isEmpty(order.name()))\n-            col.setName(_dict.delimitString(order.name(), DBDictionary.DBIdentifiers.ORDER_COLUMN_NAME));\n+            col.setIdentifier(DBIdentifier.newColumn(order.name(), delimit()));\n         if (!StringUtils.isEmpty(order.columnDefinition()))\n-            col.setTypeName(_dict.delimitString(order.columnDefinition(), \n-                DBDictionary.DBIdentifiers.ORDER_COLUMN_COLUMN_DEFINITION));\n+            col.setTypeIdentifier(DBIdentifier.newColumnDefinition(order.columnDefinition()));\n         col.setNotNull(!order.nullable());\n         col.setFlag(Column.FLAG_UNINSERTABLE, !order.insertable());\n         col.setFlag(Column.FLAG_UNUPDATABLE, !order.updatable());\n@@ -1970,7 +1955,7 @@ protected void parseElementJoinColumns(FieldMapping fm,\n         List<Column> cols = new ArrayList<Column>(joins.length);\n         int unique = 0;\n         for (int i = 0; i < joins.length; i++) {\n-            cols.add(newColumn(joins[i]));\n+            cols.add(newColumn(joins[i], delimit()));\n             unique |= (joins[i].unique()) ? TRUE : FALSE;\n         }\n         setColumns(fm, fm.getElementMapping().getValueInfo(), cols, unique);\n@@ -1979,14 +1964,14 @@ protected void parseElementJoinColumns(FieldMapping fm,\n     /**\n      * Create a new schema column with information from the given annotation.\n      */\n-    private static Column newColumn(ElementJoinColumn join) {\n+    private static Column newColumn(ElementJoinColumn join, boolean delimit) {\n         Column col = new Column();\n         if (!StringUtils.isEmpty(join.name()))\n-            col.setName(join.name());\n+            col.setIdentifier(DBIdentifier.newColumn(join.name(), delimit));\n         if (!StringUtils.isEmpty(join.columnDefinition()))\n-            col.setTypeName(join.columnDefinition());\n+            col.setTypeIdentifier(DBIdentifier.newColumnDefinition(join.columnDefinition()));\n         if (!StringUtils.isEmpty(join.referencedColumnName()))\n-            col.setTarget(join.referencedColumnName());\n+            col.setTargetIdentifier(DBIdentifier.newColumn(join.referencedColumnName(), delimit));\n         if (!StringUtils.isEmpty(join.referencedAttributeName()))\n             col.setTargetField(join.referencedAttributeName());\n         col.setNotNull(!join.nullable());\n@@ -2002,8 +1987,7 @@ protected void parseMapKeyColumn(FieldMapping fm, MapKeyColumn anno) {\n         int unique = 0;\n         FieldMappingInfo info = fm.getMappingInfo();\n         if (anno.table() != null && anno.table().length() > 0) {\n-            String tableName = _dict.delimitString(anno.table(), DBDictionary.DBIdentifiers.MAP_KEY_COLUMN_TABLE);\n-            info.setTableName(tableName);\n+            info.setTableIdentifier(DBIdentifier.newTable(anno.table(), delimit()));\n         }\n         Column col = new Column();\n         setupMapKeyColumn(fm, col, anno);\n@@ -2017,14 +2001,12 @@ protected void parseMapKeyColumn(FieldMapping fm, MapKeyColumn anno) {\n     private void setupMapKeyColumn(FieldMapping fm, Column col, \n         MapKeyColumn anno) {\n         if (!StringUtils.isEmpty(anno.name())) {\n-            String name = _dict.delimitString(anno.name(), DBDictionary.DBIdentifiers.MAP_KEY_COLUMN_NAME);\n-            col.setName(name);\n+            col.setIdentifier(DBIdentifier.newColumn(anno.name(), delimit()));\n         }\n         else \n-            col.setName(fm.getName() + \"_\" + \"KEY\");\n+            col.setIdentifier(DBIdentifier.newColumn(fm.getName() + \"_\" + \"KEY\", delimit()));\n         if (!StringUtils.isEmpty(anno.columnDefinition()))\n-            col.setTypeName(_dict.delimitString(anno.columnDefinition(), \n-                DBDictionary.DBIdentifiers.MAP_KEY_COLUMN_COLUMN_DEFINITION));\n+            col.setTypeIdentifier(DBIdentifier.newColumnDefinition(anno.columnDefinition()));\n         if (anno.precision() != 0)\n             col.setSize(anno.precision());\n         else if (anno.length() != 255)\n@@ -2073,29 +2055,42 @@ private void parseMapKeyJoinColumns(FieldMapping fm,\n     private Column newColumn(MapKeyJoinColumn join) {\n         Column col = new Column();\n         if (!StringUtils.isEmpty(join.name()))\n-            col.setName(_dict.delimitString(join.name(), DBDictionary.DBIdentifiers.MAP_KEY_JOIN_COLUMN_NAME));\n+            col.setIdentifier(DBIdentifier.newColumn(join.name(), delimit()));\n         if (!StringUtils.isEmpty(join.columnDefinition()))\n-            col.setTypeName(_dict.delimitString(join.columnDefinition(), \n-                DBDictionary.DBIdentifiers.MAP_KEY_JOIN_COLUMN_COLUMN_DEFINITION));\n+            col.setTypeIdentifier(DBIdentifier.newColumnDefinition(join.columnDefinition())); \n         if (!StringUtils.isEmpty(join.referencedColumnName()))\n-            col.setTarget(_dict.delimitString(join.referencedColumnName(), \n-                DBDictionary.DBIdentifiers.MAP_KEY_JOIN_COLUMN_REFERENCED_COLUMN_NAME));\n+            col.setTargetIdentifier(DBIdentifier.newColumn(join.referencedColumnName(), delimit())); \n         col.setNotNull(!join.nullable());\n         col.setFlag(Column.FLAG_UNINSERTABLE, !join.insertable());\n         col.setFlag(Column.FLAG_UNUPDATABLE, !join.updatable ());\n         return col;\n     }\n+\n+    @Override\n+    protected String normalizeSequenceName(String seqName) {\n+        if (StringUtils.isEmpty(seqName)) {\n+            return seqName;\n+        }\n+        return DBIdentifier.newSequence(seqName, delimit()).getName();\n+    }\n     \n     @Override\n-    protected String delimitString(String name, DBIdentifiers type) {\n-        if (type == DBIdentifiers.SEQUENCE_GEN_SCHEMA) {\n-            return _dict.delimitString(name, DBDictionary.DBIdentifiers.SEQUENCE_GEN_SCHEMA);\n+    protected String normalizeSchemaName(String schName) {\n+        if (StringUtils.isEmpty(schName)) {\n+            return schName;\n         }\n-        else if (type == DBIdentifiers.SEQUENCE_GEN_SEQ_NAME) {\n-            return _dict.delimitString(name, DBDictionary.DBIdentifiers.SEQUENCE_GEN_SEQ_NAME);\n+        return DBIdentifier.newSchema(schName, delimit()).getName();\n+    }\n+\n+    @Override\n+    protected String normalizeCatalogName(String catName) {\n+        if (StringUtils.isEmpty(catName)) {\n+            return catName;\n         }\n-        \n-        return name;\n+        return DBIdentifier.newCatalog(catName, delimit()).getName();\n+    }\n+\n+    private boolean delimit() {\n+        return _dict.getDelimitIdentifiers();\n     }\n-    \n }"},{"sha":"48922636d4089c6fa14c1fe0c1c7f3c1cf136b01","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/MappingTag.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/MappingTag.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/MappingTag.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/MappingTag.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -39,6 +39,7 @@\n     COLLECTION_TABLE,\n     COLUMN_NAME,\n     COLUMN_RESULT,\n+    DELIMITED_IDS,\n     DISCRIM_COL,\n     DISCRIM_VAL,\n     ENTITY_RESULT,"},{"sha":"c7f5e708489f1fa0a7b6672c1820aa6d1d94236b","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingDefaults.java","status":"modified","additions":42,"deletions":28,"changes":70,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingDefaults.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingDefaults.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/PersistenceMappingDefaults.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -18,6 +18,8 @@\n  */\n package org.apache.openjpa.persistence.jdbc;\n \n+import org.apache.openjpa.jdbc.identifier.Normalizer;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.Discriminator;\n import org.apache.openjpa.jdbc.meta.FieldMapping;\n@@ -131,33 +133,38 @@ public String getTableName(ClassMapping cls, Schema schema) {\n \n     @Override\n     public String getTableName(FieldMapping fm, Schema schema) {\n+        return getTableIdentifier(fm, schema).getName();\n+    }\n+\n+    @Override\n+    public DBIdentifier getTableIdentifier(FieldMapping fm, Schema schema) {\n         // base name is table of defining type + '_'\n         ClassMapping clm = fm.getDefiningMapping();\n         Table table = getTable(clm);\n         \n-        String name = null;\n+        DBIdentifier sName = DBIdentifier.NULL;\n         if (fm.isElementCollection()) \n-            name = clm.getTypeAlias();\n+            sName = DBIdentifier.newTable(clm.getTypeAlias());\n         else \n-            name = table.getName();\n+            sName = table.getIdentifier();\n         \n         // if this is an assocation table, spec says to suffix with table of\n         // the related type. spec doesn't cover other cases; we're going to\n         // suffix with the field name\n         ClassMapping rel = fm.getElementMapping().getTypeMapping();\n         boolean assoc = rel != null && rel.getTable() != null\n             && fm.getTypeCode() != JavaTypes.MAP;\n-        String name2 = null;\n+        DBIdentifier sName2 = DBIdentifier.NULL;\n         if (assoc) {\n-            name2 = rel.getTable().getName();\n+            sName2 = rel.getTable().getIdentifier();\n         }\n         else {\n-            name2 = fm.getName();\n+            sName2 = DBIdentifier.newTable(fm.getName().replace('$', '_'));\n         }\n         \n-        name = dict.combineNames(name, name2);\n+        sName = DBIdentifier.combine(sName, sName2.getName());\n         \n-        return name.replace('$', '_');\n+        return sName;\n     }\n     \n     private Table getTable(ClassMapping clm) {\n@@ -184,26 +191,33 @@ public void populateJoinColumn(FieldMapping fm, Table local, Table foreign,\n         // if this is a bidi relation, prefix with inverse field name, else\n         // prefix with owning entity name\n         FieldMapping[] inverses = fm.getInverseMappings();\n-        String name;\n+        DBIdentifier sName = DBIdentifier.NULL;\n         if (inverses.length > 0)\n-            name = inverses[0].getName();\n+            sName = DBIdentifier.newColumn(inverses[0].getName());\n         else\n-            name = fm.getDefiningMapping().getTypeAlias();\n-        String targetName = ((Column) target).getName();\n-        String tempName = null;\n-        if ((name.length() + targetName.length()) >= dict.maxColumnNameLength)\n-            tempName = name.substring(0, dict.maxColumnNameLength\n+            sName = DBIdentifier.newColumn(fm.getDefiningMapping().getTypeAlias());\n+        DBIdentifier targetName = ((Column) target).getIdentifier();\n+        DBIdentifier tempName = DBIdentifier.NULL;\n+        if ((sName.length() + targetName.length()) >= dict.maxColumnNameLength)\n+            tempName = DBIdentifier.truncate(sName, dict.maxColumnNameLength\n                     - targetName.length() - 1);\n         // suffix with '_' + target column\n-        if (tempName == null)\n-            tempName = name;\n-        name = dict.combineNames(tempName, targetName);\n-        name = dict.getValidColumnName(name, foreign);\n-        col.setName(name);\n+        if (DBIdentifier.isNull(tempName))\n+            tempName = sName;\n+        sName = DBIdentifier.combine(tempName, targetName.getName());\n+        sName = dict.getValidColumnName(sName, foreign);\n+        col.setIdentifier(sName);\n     }\n \n     @Override\n     public void populateForeignKeyColumn(ValueMapping vm, String name,\n+        Table local, Table foreign, Column col, Object target, boolean inverse,\n+        int pos, int cols) {\n+         populateForeignKeyColumn(vm, DBIdentifier.newColumn(name), local,\n+            foreign, col, target, inverse, pos, cols);\n+    }\n+\n+    public void populateForeignKeyColumn(ValueMapping vm, DBIdentifier sName,\n         Table local, Table foreign, Column col, Object target, boolean inverse,\n         int pos, int cols) {\n         boolean elem = vm == vm.getFieldMapping().getElement()\n@@ -218,19 +232,19 @@ public void populateForeignKeyColumn(ValueMapping vm, String name,\n         // otherwise jpa always uses <field>_<pkcol> for column name, even\n         // when only one col\n         if (target instanceof Column) {\n-            if (name == null) {\n-                name = col.getName();\n+            if (DBIdentifier.isNull(sName)) {\n+                sName = col.getIdentifier();\n             } else {\n                 if (elem)\n-                    name = vm.getFieldMapping().getName();\n+                    sName = DBIdentifier.newColumn(vm.getFieldMapping().getName());\n                 if (isRemoveHungarianNotation())\n-                    name = removeHungarianNotation(name);\n-                name = dict.combineNames(name, ((Column)target).getName());\n+                    sName = DBIdentifier.newColumn(Normalizer.removeHungarianNotation(sName.getName()));\n+                sName = sName.combine(sName, ((Column)target).getIdentifier().getName());\n \n                 // No need to check for uniqueness.\n-                name = dict.getValidColumnName(name, local, false);\n+                sName = dict.getValidColumnName(sName, local, false);\n             }\n-            col.setName(name);\n+            col.setIdentifier(sName);\n         }\n     }\n \n@@ -239,7 +253,7 @@ public void populateColumns(Version vers, Table table, Column[] cols) {\n         // check for version field and use its name as column name\n         FieldMapping fm = vers.getClassMapping().getVersionFieldMapping();\n         if (fm != null && cols.length == 1)\n-            cols[0].setName(fm.getName());\n+            cols[0].setIdentifier(DBIdentifier.newColumn(fm.getName()));\n         else\n             super.populateColumns(vers, table, cols);\n     }"},{"sha":"2522952a6a5a775dce59496b1d3c6e7ab20c6559","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMLPersistenceMappingParser.java","status":"modified","additions":114,"deletions":90,"changes":204,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMLPersistenceMappingParser.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMLPersistenceMappingParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMLPersistenceMappingParser.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -33,6 +33,8 @@\n \n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.identifier.DBIdentifier;\n+import org.apache.openjpa.jdbc.identifier.QualifiedDBIdentifier;\n import org.apache.openjpa.jdbc.meta.ClassMapping;\n import org.apache.openjpa.jdbc.meta.ClassMappingInfo;\n import org.apache.openjpa.jdbc.meta.DiscriminatorMappingInfo;\n@@ -42,26 +44,23 @@\n import org.apache.openjpa.jdbc.meta.MappingRepository;\n import org.apache.openjpa.jdbc.meta.QueryResultMapping;\n import org.apache.openjpa.jdbc.meta.SequenceMapping;\n-import org.apache.openjpa.jdbc.meta.ValueMapping;\n+import org.apache.openjpa.jdbc.meta.QueryResultMapping.PCResult;\n import org.apache.openjpa.jdbc.meta.strats.EnumValueHandler;\n import org.apache.openjpa.jdbc.meta.strats.FlatClassStrategy;\n import org.apache.openjpa.jdbc.meta.strats.FullClassStrategy;\n import org.apache.openjpa.jdbc.meta.strats.NoneClassStrategy;\n import org.apache.openjpa.jdbc.meta.strats.VerticalClassStrategy;\n import org.apache.openjpa.jdbc.schema.Column;\n-import org.apache.openjpa.jdbc.schema.Table;\n import org.apache.openjpa.jdbc.schema.Unique;\n import org.apache.openjpa.jdbc.sql.DBDictionary;\n import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.meta.SourceTracker;\n import org.apache.openjpa.lib.util.Localizer;\n import org.apache.openjpa.meta.ClassMetaData;\n import org.apache.openjpa.meta.FieldMetaData;\n import org.apache.openjpa.meta.JavaTypes;\n-import org.apache.openjpa.meta.MetaDataContext;\n-import org.apache.openjpa.meta.ValueMetaData;\n import org.apache.openjpa.persistence.XMLPersistenceMetaDataParser;\n import org.apache.openjpa.util.InternalException;\n-import org.apache.openjpa.util.MetaDataException;\n import org.apache.openjpa.util.UserException;\n import org.xml.sax.Attributes;\n import org.xml.sax.Locator;\n@@ -88,6 +87,7 @@\n         _elems.put(\"column\", COL);\n         _elems.put(\"column-name\", COLUMN_NAME);\n         _elems.put(\"column-result\", COLUMN_RESULT);\n+        _elems.put(\"delimited-identifiers\", DELIMITED_IDS);\n         _elems.put(\"discriminator-column\", DISCRIM_COL);\n         _elems.put(\"discriminator-value\", DISCRIM_VAL);\n         _elems.put(\"entity-result\", ENTITY_RESULT);\n@@ -128,6 +128,7 @@\n     private DiscriminatorType _discType;\n     private Column _discCol;\n     private int _resultIdx = 0;\n+    private final DBDictionary _dict;\n \n     private final Map<Class<?>, ArrayList<DeferredEmbeddableOverrides>> \n         _deferredMappings = new HashMap<Class<?>, \n@@ -138,6 +139,7 @@\n      */\n     public XMLPersistenceMappingParser(JDBCConfiguration conf) {\n         super(conf);\n+        _dict = conf.getDBDictionaryInstance();\n     }\n \n     @Override\n@@ -297,7 +299,7 @@ private boolean endName() {\n             Object current = currentElement();\n             if (current instanceof Unique) {\n                 Unique unq = (Unique)current;\n-                unq.setName(name);\n+                unq.setIdentifier(DBIdentifier.newConstraint(name, delimit()));\n             }\n         }\n             \n@@ -372,7 +374,7 @@ protected void endClassMapping(ClassMetaData meta)\n         throws SAXException {\n         ClassMapping cm = (ClassMapping) meta;\n         if (_schema != null)\n-            cm.getMappingInfo().setSchemaName(_schema);\n+            cm.getMappingInfo().setSchemaIdentifier(DBIdentifier.newSchema(_schema, delimit()));\n \n         if (_supJoinCols != null)\n             cm.getMappingInfo().setColumns(_supJoinCols);\n@@ -413,10 +415,10 @@ private void clearClassInfo() {\n      */\n     private boolean startSecondaryTable(Attributes attrs)\n         throws SAXException {\n-        _secondaryTable = toTableName(attrs.getValue(\"schema\"),\n-            attrs.getValue(\"name\"));\n+        _secondaryTable = toTableIdentifier(attrs.getValue(\"schema\"),\n+            attrs.getValue(\"name\")).getName();\n         ((ClassMapping)currentElement()).getMappingInfo()\n-        \t.addSecondaryTable(_secondaryTable);\n+        \t.addSecondaryTable(DBIdentifier.newTable(_secondaryTable));\n         return true;\n     }\n \n@@ -426,7 +428,7 @@ private boolean startSecondaryTable(Attributes attrs)\n     private void endSecondaryTable() {\n         ClassMapping cm = (ClassMapping) currentElement();\n         ClassMappingInfo info = cm.getMappingInfo();\n-        info.setSecondaryTableJoinColumns(_secondaryTable, _joinCols);\n+        info.setSecondaryTableJoinColumns(DBIdentifier.newTable(_secondaryTable, delimit()), _joinCols);\n         clearSecondaryTableInfo();\n     }\n \n@@ -453,10 +455,10 @@ private boolean startTableGenerator(Attributes attrs) {\n         SequenceMapping seq = (SequenceMapping) getRepository().\n             addSequenceMetaData(name);\n         seq.setSequencePlugin(SequenceMapping.IMPL_VALUE_TABLE);\n-        seq.setTable(toTableName(attrs.getValue(\"schema\"),\n+        seq.setTableIdentifier(toTableIdentifier(attrs.getValue(\"schema\"),\n             attrs.getValue(\"table\")));\n-        seq.setPrimaryKeyColumn(attrs.getValue(\"pk-column-name\"));\n-        seq.setSequenceColumn(attrs.getValue(\"value-column-name\"));\n+        seq.setPrimaryKeyColumnIdentifier(DBIdentifier.newColumn(attrs.getValue(\"pk-column-name\"), delimit())); \n+        seq.setSequenceColumnIdentifier(DBIdentifier.newColumn(attrs.getValue(\"value-column-name\"), delimit())); \n         seq.setPrimaryKeyValue(attrs.getValue(\"pk-column-value\"));\n         String val = attrs.getValue(\"initial-value\");\n         if (val != null)\n@@ -468,7 +470,7 @@ private boolean startTableGenerator(Attributes attrs) {\n         Object cur = currentElement();\n         Object scope = (cur instanceof ClassMetaData)\n             ? ((ClassMetaData) cur).getDescribedType() : null;\n-        seq.setSource(getSourceFile(), scope, seq.SRC_XML);\n+        seq.setSource(getSourceFile(), scope, SourceTracker.SRC_XML);\n         Locator locator = getLocation().getLocator();\n         if (locator != null) {\n             seq.setLineNumber(Numbers.valueOf(locator.getLineNumber()));\n@@ -543,7 +545,7 @@ private void endMapKeyTemporal() {\n         if (!StringUtils.isEmpty(temp))\n             _mapKeyTemporal = Enum.valueOf(TemporalType.class, temp);\n         FieldMapping fm = (FieldMapping) currentElement();\n-        List cols = fm.getKeyMapping().getValueInfo().getColumns();\n+        List<Column> cols = fm.getKeyMapping().getValueInfo().getColumns();\n         if (cols.isEmpty()) {\n             cols = Arrays.asList(new Column[]{ new Column() });\n             fm.getKeyMapping().getValueInfo().setColumns(cols);\n@@ -633,7 +635,7 @@ protected void endFieldMapping(FieldMetaData field)\n         if (_lob || _temporal != null) {\n             int typeCode = fm.isElementCollection() ? fm.getElement().getDeclaredTypeCode() : \n                 fm.getDeclaredTypeCode();\n-            Class type = fm.isElementCollection() ? fm.getElement().getDeclaredType() : fm.getDeclaredType();  \n+            Class<?> type = fm.isElementCollection() ? fm.getElement().getDeclaredType() : fm.getDeclaredType();  \n             if (_cols == null) {\n                 _cols = new ArrayList<Column>(1);\n                 _cols.add(new Column());\n@@ -665,7 +667,7 @@ protected void endFieldMapping(FieldMetaData field)\n         if (_cols != null) {\n             switch (fm.getDeclaredTypeCode()) {\n                 case JavaTypes.ARRAY:\n-                    Class type = fm.getDeclaredType();\n+                    Class<?> type = fm.getDeclaredType();\n                     if (type == byte[].class || type == Byte[].class\n                         || type == char[].class || type == Character[].class ) {\n                         fm.getValueInfo().setColumns(_cols);\n@@ -680,7 +682,7 @@ protected void endFieldMapping(FieldMetaData field)\n                     fm.getValueInfo().setColumns(_cols);\n             }\n             if (_colTable != null)\n-                fm.getMappingInfo().setTableName(_colTable);\n+                fm.getMappingInfo().setTableIdentifier(DBIdentifier.newTable(_colTable, delimit()));\n             setUnique(fm);\n         }\n         clearColumnInfo();\n@@ -740,15 +742,15 @@ private void endAttributeOverride()\n                         getEmbeddedClassType(basefm, _override),\n                         basefm, _override, true);\n                 dfm._defCols = _cols;\n-                dfm._defTable = _colTable;\n+                dfm._defTable = DBIdentifier.newTable(_colTable, delimit());\n                 dfm._attrName = _override;\n                 dfm._unique = _unique;\n             }\n         }\n         if (fm != null && _cols != null) {\n             fm.getValueInfo().setColumns(_cols);\n             if (_colTable != null)\n-                fm.getMappingInfo().setTableName(_colTable);\n+                fm.getMappingInfo().setTableIdentifier(DBIdentifier.newTable(_colTable, delimit()));\n             setUnique(fm);\n         }\n         clearColumnInfo();\n@@ -785,10 +787,10 @@ private boolean startTable(Attributes attrs)\n         ClassMapping mapping = (ClassMapping) currentElement();\n         if (mapping.isAbstract())\n             throw new UserException(_loc.get(\"table-not-allowed\", mapping));\n-        String table = toTableName(attrs.getValue(\"schema\"),\n+        DBIdentifier table = toTableIdentifier(attrs.getValue(\"schema\"),\n             attrs.getValue(\"name\"));\n-        if (table != null)\n-            mapping.getMappingInfo().setTableName(table);\n+        if (!DBIdentifier.isNull(table))\n+            mapping.getMappingInfo().setTableIdentifier(table);\n         return true;\n     }\n \n@@ -797,9 +799,9 @@ private boolean startTable(Attributes attrs)\n      */\n     private boolean startJoinTable(Attributes attrs)\n         throws SAXException {\n-        String table = toTableName(attrs.getValue(\"schema\"),\n+        DBIdentifier sTable = toTableIdentifier(attrs.getValue(\"schema\"),\n             attrs.getValue(\"name\"));\n-        if (table != null) {\n+        if (!DBIdentifier.isNull(sTable)) {\n             Object elem = currentElement();\n             FieldMapping fm = null;\n             if (elem instanceof FieldMapping) {\n@@ -814,7 +816,7 @@ private boolean startJoinTable(Attributes attrs)\n                                 AnnotationPersistenceMappingParser.\n                                 getEmbeddedClassType(basefm, _override),\n                                 basefm, _override, true);\n-                        dfm._defTable = table;\n+                        dfm._defTable = sTable.clone();\n                         dfm._attrName = _override;\n                     }\n                 }\n@@ -823,7 +825,7 @@ private boolean startJoinTable(Attributes attrs)\n                 fm = getAttributeOverride(cm);\n             }\n             if (fm != null)\n-                fm.getMappingInfo().setTableName(table);\n+                fm.getMappingInfo().setTableIdentifier(sTable);\n         }\n         return true;\n     }\n@@ -902,7 +904,7 @@ private boolean startJoinColumn(Attributes attrs)\n         if (currentParent == COLLECTION_TABLE) {\n             FieldMapping fm = (FieldMapping) peekElement();\n             Column col = parseColumn(attrs);\n-            List colList = new ArrayList();\n+            List<Column> colList = new ArrayList<Column>();\n             colList.add(col);\n             fm.getMappingInfo().setColumns(colList);\n             return true;\n@@ -930,9 +932,9 @@ private boolean startColumn(Attributes attrs)\n             // the column is in a separate table\n             if (fm.isElementCollection() &&\n                 !fm.getElementMapping().isEmbedded()) {\n-                List list = fm.getElementMapping().getValueInfo().getColumns();\n+                List<Column> list = fm.getElementMapping().getValueInfo().getColumns();\n                 if (list.size() == 0) {\n-                    list = new ArrayList();\n+                    list = new ArrayList<Column>();\n                     fm.getElementMapping().getValueInfo().setColumns(list);\n                 }\n                 list.add(col);\n@@ -949,11 +951,11 @@ private boolean startColumn(Attributes attrs)\n      * Parse map-key-column.\n      */\n     private boolean startMapKeyColumn(Attributes attrs)\n-    throws SAXException {\n+        throws SAXException {\n         FieldMapping fm = (FieldMapping) peekElement();\n         Column col = parseColumn(attrs);\n         MappingInfo info = fm.getKeyMapping().getValueInfo();\n-        List cols = new ArrayList();\n+        List<Column> cols = new ArrayList<Column>();\n         cols.add(col);\n         info.setColumns(cols);\n         return true;\n@@ -970,10 +972,11 @@ private boolean startMapKeyJoinColumn(Attributes attrs)\n         // or field name, \"-\", \"KEY\"\n         FieldMapping fm = (FieldMapping) peekElement();\n         MappingInfo info = fm.getKeyMapping().getValueInfo();\n-        List cols = info.getColumns();\n-        Column col = (Column)cols.get(0);\n-        if (col.getName() == null)\n-            col.setName(fm.getName() + \"_\" + \"KEY\");\n+        List<Column> cols = info.getColumns();\n+        Column col = cols.get(0);\n+        if (DBIdentifier.isNull(col.getIdentifier())) {\n+            col.setIdentifier(DBIdentifier.newColumn(fm.getName() + \"_\" + \"KEY\", delimit()));\n+        }\n \n         return retVal;\n     }\n@@ -986,13 +989,13 @@ private Column parseColumn(Attributes attrs)\n         Column col = new Column();\n         String val = attrs.getValue(\"name\");\n         if (val != null)\n-            col.setName(val);\n+            col.setIdentifier(DBIdentifier.newColumn(val, delimit()));\n         val = attrs.getValue(\"referenced-column-name\");\n         if (val != null)\n-            col.setTarget(val);\n+            col.setTargetIdentifier(DBIdentifier.newColumn(val, delimit()));\n         val = attrs.getValue(\"column-definition\");\n         if (val != null)\n-            col.setTypeName(val);\n+            col.setTypeIdentifier(DBIdentifier.newColumnDefinition(val));\n         val = attrs.getValue(\"precision\");\n         if (val != null)\n             col.setSize(Integer.parseInt(val));\n@@ -1033,38 +1036,30 @@ private boolean startCollectionTable(Attributes attrs)\n         FieldMapping fm = (FieldMapping) peekElement();\n \n         FieldMappingInfo info = fm.getMappingInfo();\n-        Table ctbl = parseCollectionTable(attrs);\n-        info.setTableName(toTableName(ctbl.getSchemaName(),\n-            ctbl.getName()));\n+        DBIdentifier ctbl = parseCollectionTable(attrs);\n+        info.setTableIdentifier(ctbl);\n         return true;\n     }\n \n-    private Table parseCollectionTable(Attributes attrs) {\n-        Table table = new Table();\n-        String val = attrs.getValue(\"name\");\n-        if (val != null)\n-            table.setName(val);\n-        val = attrs.getValue(\"schema\");\n-        if (val != null)\n-            table.setSchemaName(val);\n-        //val = attrs.getValue(\"catalog\");\n-        //if (val != null)\n-        //    table.setCatalog(val);\n-                \n-        return table; \n-    }\n-  \n+    private DBIdentifier parseCollectionTable(Attributes attrs) {\n+        String tVal = attrs.getValue(\"name\");\n+        String sVal = attrs.getValue(\"schema\");\n+        return toTableIdentifier(sVal, tVal); \n+    }\n+\n     /**\n-     * Return a table name for the given attributes.\n+     * Form a qualified table name from a schema and table name.\n      */\n-    private String toTableName(String schema, String table) {\n-        if (StringUtils.isEmpty(table))\n-            return null;\n-        if (StringUtils.isEmpty(schema))\n-            schema = _schema;\n-        return (StringUtils.isEmpty(schema)) ? table : schema + \".\" + table;\n+    private DBIdentifier toTableIdentifier(String schema, String table) {\n+        DBIdentifier sName = DBIdentifier.newSchema(schema, delimit());\n+        DBIdentifier tName = DBIdentifier.newTable(table, delimit());\n+        if (DBIdentifier.isEmpty(tName) || DBIdentifier.isEmpty(sName)) {\n+            return tName;\n+        }\n+        return QualifiedDBIdentifier.newPath(sName, tName);\n     }\n \n+\n     /**\n      * Start processing <code>sql-result-set-mapping</code> node.\n      * Pushes the {@link QueryResultMapping} onto the stack as current element.\n@@ -1089,7 +1084,7 @@ private boolean startSQLResultSetMapping(Attributes attrs) {\n         Object cur = currentElement();\n         Object scope = (cur instanceof ClassMetaData)\n             ? ((ClassMetaData) cur).getDescribedType() : null;\n-        result.setSource(getSourceFile(), scope, result.SRC_XML);\n+        result.setSource(getSourceFile(), scope, SourceTracker.SRC_XML);\n         Locator locator = getLocation().getLocator();\n         if (locator != null) {\n             result.setLineNumber(Numbers.valueOf(locator.getLineNumber()));\n@@ -1111,13 +1106,13 @@ private void endSQLResultSetMapping()\n      */\n     private boolean startEntityResult(Attributes attrs)\n         throws SAXException {\n-        Class entityClass = classForName(attrs.getValue(\"entity-class\"));\n-        String discriminator = attrs.getValue(\"discriminator-column\");\n+        Class<?> entityClass = classForName(attrs.getValue(\"entity-class\"));\n+        String discriminator = DBIdentifier.newColumn(attrs.getValue(\"discriminator-column\"), delimit()).getName(); \n \n         QueryResultMapping parent = (QueryResultMapping) currentElement();\n         QueryResultMapping.PCResult result = parent.addPCResult(entityClass);\n         if (!StringUtils.isEmpty(discriminator))\n-            result.addMapping(result.DISCRIMINATOR, discriminator);\n+            result.addMapping(PCResult.DISCRIMINATOR, discriminator);\n         pushElement(result);\n         return true;\n     }\n@@ -1133,7 +1128,7 @@ private void endEntityResult()\n     private boolean startFieldResult(Attributes attrs)\n         throws SAXException {\n         String fieldName = attrs.getValue(\"name\");\n-        String columnName = attrs.getValue(\"column\");\n+        String columnName = DBIdentifier.newColumn(attrs.getValue(\"column\"), delimit()).getName();\n \n         QueryResultMapping.PCResult parent = (QueryResultMapping.PCResult)\n             currentElement();\n@@ -1161,9 +1156,9 @@ private boolean startUniqueConstraint(Attributes attrs)\n         throws SAXException {\n         Unique unique = new Unique();\n \n-        String name = attrs.getValue(\"name\");\n-        if (StringUtils.isNotEmpty(name)) {\n-            unique.setName(name);\n+        DBIdentifier name = DBIdentifier.newConstraint(attrs.getValue(\"name\"), delimit());\n+        if (!DBIdentifier.isEmpty(name)) {\n+            unique.setIdentifier(name);\n         }\n \n         pushElement(unique);\n@@ -1179,26 +1174,26 @@ private boolean startUniqueConstraint(Attributes attrs)\n     private void endUniqueConstraint() {\n         Unique unique = (Unique) popElement();\n         Object ctx = currentElement();\n-        String tableName = \"?\";\n+        DBIdentifier tableName = DBIdentifier.newTable(\"?\");\n         if (ctx instanceof ClassMapping) {\n         \tClassMappingInfo info = ((ClassMapping) ctx).getMappingInfo();\n         \ttableName = (_secondaryTable == null) \n-        \t\t? info.getTableName() : _secondaryTable;\n+        \t\t? info.getTableIdentifier() : DBIdentifier.newTable(_secondaryTable, delimit());\n         \tinfo.addUnique(tableName, unique);\n         } else if (ctx instanceof FieldMapping) {// JoinTable\n         \tFieldMappingInfo info = ((FieldMapping)ctx).getMappingInfo();\n         \tinfo.addJoinTableUnique(unique);\n         } else if (ctx instanceof SequenceMapping) {\n         \tSequenceMapping seq = (SequenceMapping)ctx;\n-        \tunique.setTableName(seq.getTable());\n+        \tunique.setTableIdentifier(seq.getTableIdentifier());\n         \tColumn[] uniqueColumns = unique.getColumns();\n-        \tString[] columnNames = new String[uniqueColumns.length];\n+        \tDBIdentifier[] columnNames = new DBIdentifier[uniqueColumns.length];\n         \tint i = 0;\n         \tfor (Column uniqueColumn : uniqueColumns)\n-        \t\tcolumnNames[i++] = uniqueColumn.getName();\n-        \tseq.setUniqueColumns(columnNames);\n-        \tif (StringUtils.isNotEmpty(unique.getName())) {\n-        \t    seq.setUniqueConstraintName(unique.getName());\n+        \t\tcolumnNames[i++] = uniqueColumn.getIdentifier().clone();\n+        \tseq.setUniqueColumnsIdentifier(columnNames);\n+        \tif (!DBIdentifier.isEmpty(unique.getIdentifier())) {\n+        \t    seq.setUniqueConstraintIdentifier(unique.getIdentifier());\n         \t}\n         } else {\n         \tthrow new InternalException();\n@@ -1214,7 +1209,7 @@ private boolean endColumnName() {\n         if (current instanceof Unique) {\n             Unique unique = (Unique) current;\n             Column column = new Column();\n-            column.setName(this.currentText());\n+            column.setIdentifier(DBIdentifier.newColumn(this.currentText(), delimit()));\n             unique.addColumn(column);\n             return true;\n         }\n@@ -1264,10 +1259,10 @@ private Column parseOrderColumn(Attributes attrs)\n         Column col = new Column();\n         String val = attrs.getValue(\"name\");\n         if (val != null)\n-            col.setName(val);\n-        val = attrs.getValue(\"column-definition\");\n+            col.setIdentifier(DBIdentifier.newColumn(val, delimit()));\n+        val = attrs.getValue(\"column-definition\"); \n         if (val != null)\n-            col.setTypeName(val);\n+            col.setTypeIdentifier(DBIdentifier.newColumnDefinition(val));\n         val = attrs.getValue(\"precision\");\n         if (val != null)\n             col.setSize(Integer.parseInt(val));\n@@ -1314,8 +1309,8 @@ protected void applyDeferredEmbeddableOverrides(Class<?> cls)\n             // Apply column, table, and unique overrides\n             if (defMap._defCols != null) {\n                 fm.getValueInfo().setColumns(defMap._defCols);\n-                if (defMap._defTable != null)\n-                    fm.getMappingInfo().setTableName(defMap._defTable);\n+                if (!DBIdentifier.isNull(defMap._defTable))\n+                    fm.getMappingInfo().setTableIdentifier(defMap._defTable);\n                 setUnique(fm, defMap._unique);\n             }\n             // Apply Join column and element join columns overrides overrides\n@@ -1334,7 +1329,7 @@ protected void applyDeferredEmbeddableOverrides(Class<?> cls)\n      * Defer overrides for the specified field mapping\n      */\n     private void deferEmbeddableOverrides(\n-        Class cls, DeferredEmbeddableOverrides defMap) {\n+        Class<?> cls, DeferredEmbeddableOverrides defMap) {\n         ArrayList<DeferredEmbeddableOverrides> defMappings = \n             _deferredMappings.get(cls);\n         if (defMappings == null) {\n@@ -1401,12 +1396,13 @@ private DeferredEmbeddableOverrides findDeferredMapping(Class<?> cls,\n         DeferredEmbeddableOverrides(FieldMapping fm, String attrName) {\n             _fm = fm;\n             _attrName = attrName;\n+            _defTable = DBIdentifier.NULL;\n         }\n         private FieldMapping _fm;\n         private List<Column> _defCols;\n         private List<Column> _defElemJoinCols;\n         private List<Column> _defJoinCols;\n-        private String _defTable;\n+        private DBIdentifier _defTable;\n         private String _attrName;\n         private EnumSet<UniqueFlag> _unique;\n     }  \n@@ -1415,7 +1411,35 @@ private DeferredEmbeddableOverrides findDeferredMapping(Class<?> cls,\n     protected boolean startDelimitedIdentifiers() {\n         JDBCConfiguration conf = (JDBCConfiguration) getConfiguration();\n         DBDictionary dict = conf.getDBDictionaryInstance();\n-        dict.setDelimitIds(true);\n+        dict.setDelimitIdentifiers(true);\n         return true;\n     }\n+    \n+    @Override\n+    protected String normalizeSequenceName(String seqName) {\n+        if (StringUtils.isEmpty(seqName)) {\n+            return seqName;\n+        }\n+        return DBIdentifier.newSequence(seqName, delimit()).getName();\n+    }\n+    \n+    @Override\n+    protected String normalizeSchemaName(String schName) {\n+        if (StringUtils.isEmpty(schName)) {\n+            return schName;\n+        }\n+        return DBIdentifier.newSchema(schName, delimit()).getName();\n+    }\n+\n+    @Override\n+    protected String normalizeCatalogName(String catName) {\n+        if (StringUtils.isEmpty(catName)) {\n+            return catName;\n+        }\n+        return DBIdentifier.newCatalog(catName, delimit()).getName();\n+    }\n+\n+    private boolean delimit() {\n+        return _dict.getDelimitIdentifiers();\n+    }\n }"},{"sha":"c6bf8dbd15e779f6fefe749a6be969518f697a6a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/Car2.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/Car2.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/Car2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/Car2.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -18,6 +18,7 @@\n  */\n package org.apache.openjpa.persistence.delimited.identifiers;\n \n+import javax.persistence.Column;\n import javax.persistence.ColumnResult;\n import javax.persistence.DiscriminatorColumn;\n import javax.persistence.Entity;\n@@ -28,7 +29,7 @@\n import javax.persistence.SqlResultSetMapping;\n import javax.persistence.Table;\n \n-@SqlResultSetMapping(name=\"CarResultSet\",\n+@SqlResultSetMapping(name=\"AnnoCarResultSet\",\n     entities={@EntityResult(entityClass=Car2.class,\n         fields={\n         @FieldResult(name=\"featureSelection\", column=\"car featureSelection\"),"},{"sha":"8560c2c7ade025ae86ce20289ee12884ac6cfeef","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/EntityA.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/EntityA.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/EntityA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/EntityA.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -62,7 +62,7 @@\n     \n     @ElementCollection\n     @OrderColumn(name=\"order col\")\n-    @CollectionTable(name=\"collection delim set\", schema=\"delim id2\")\n+    @CollectionTable(name=\"delim set\", schema=\"delim id2\")\n     private Set<String> collectionDelimSet = new HashSet<String>();\n     \n     @ElementCollection"},{"sha":"f9df31f93508830c51d90793a169c2b17c5e80a4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/TestDelimIdResultSetAnnotations.java","status":"modified","additions":3,"deletions":4,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/TestDelimIdResultSetAnnotations.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/TestDelimIdResultSetAnnotations.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/TestDelimIdResultSetAnnotations.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -52,8 +52,7 @@ public void setUp() throws Exception {\n             org.apache.openjpa.persistence.delimited.identifiers.Chevrolet.class,\n             org.apache.openjpa.persistence.delimited.identifiers.Car2.class,\n             org.apache.openjpa.persistence.delimited.identifiers.Pontiac2.class,\n-            org.apache.openjpa.persistence.delimited.identifiers.Chevrolet2.class\n-            );\n+            org.apache.openjpa.persistence.delimited.identifiers.Chevrolet2.class);\n         assertNotNull(emf);\n         \n         em = emf.createEntityManager();\n@@ -100,10 +99,10 @@ private void runQueries() {\n     \n     private void resultSetQuery() {\n         String query = \n-            \"SELECT c.id, c.\\\"car featureSelection\\\", c.\\\"car color\\\", \" +\n+            \"SELECT c.\\\"id\\\", c.\\\"car featureSelection\\\", c.\\\"car color\\\", \" +\n             \"c.\\\"discr col\\\", c.\\\"featureSelection year\\\" \" +\n             \"FROM \\\"Car\\\" c \";\n-        Query q = em.createNativeQuery(query,\"CarResultSet\");\n+        Query q = em.createNativeQuery(query,\"AnnoCarResultSet\");\n         List<Object[]> results = (List<Object[]>)q.getResultList();\n         assertEquals(2,results.size());\n         "},{"sha":"01d82ea8c326221b901693b6af8ba3014464c60f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Car.java","status":"added","additions":90,"deletions":0,"changes":90,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Car.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Car.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Car.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+public class Car {\n+    private int id;\n+    \n+    protected String featureSelection;\n+    protected String color;\n+    protected String modelYear;\n+\n+    public Car() {}\n+    \n+    public Car(int id) {\n+        this.id = id;\n+    }\n+    \n+    /**\n+     * @return the id\n+     */\n+    public int getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * @param id the id to set\n+     */\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * @return the featureSelection\n+     */\n+    public String getModel() {\n+        return featureSelection;\n+    }\n+\n+    /**\n+     * @param featureSelection the type to set\n+     */\n+    public void setModel(String featureSelection) {\n+        this.featureSelection = featureSelection;\n+    }\n+\n+    /**\n+     * @return the color\n+     */\n+    public String getColor() {\n+        return color;\n+    }\n+\n+    /**\n+     * @param color the color to set\n+     */\n+    public void setColor(String color) {\n+        this.color = color;\n+    }\n+\n+    /**\n+     * @return the modelYear\n+     */\n+    public String getModelYear() {\n+        return modelYear;\n+    }\n+\n+    /**\n+     * @param modelYear the modelYear to set\n+     */\n+    public void setModelYear(String modelYear) {\n+        this.modelYear = modelYear;\n+    }\n+\n+}"},{"sha":"aa008bea8846b5951ab0babb8b83772f6a07be88","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Car2.java","status":"added","additions":99,"deletions":0,"changes":99,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Car2.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Car2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Car2.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+import javax.persistence.ColumnResult;\n+import javax.persistence.DiscriminatorColumn;\n+import javax.persistence.Entity;\n+import javax.persistence.EntityResult;\n+import javax.persistence.FieldResult;\n+import javax.persistence.Id;\n+import javax.persistence.Inheritance;\n+import javax.persistence.SqlResultSetMapping;\n+import javax.persistence.Table;\n+\n+//@SqlResultSetMapping(name=\"CarResultSet\",\n+//    entities={@EntityResult(entityClass=Car2.class,\n+//        fields={\n+//        @FieldResult(name=\"featureSelection\", column=\"car featureSelection\"),\n+//        @FieldResult(name=\"color\", column=\"car color\")\n+//    },\n+//    discriminatorColumn=\"discr col\")},\n+//    columns={@ColumnResult(name=\"featureSelection year\")})\n+//    \n+//@Entity\n+//@Inheritance\n+//@DiscriminatorColumn(name=\"discr col\", columnDefinition=\"VARCHAR(10)\")\n+//@Table(name=\"Car2\")\n+public class Car2 {\n+//    @Id\n+    private int id;\n+    \n+    protected String featureSelection;\n+    protected String color;\n+\n+    public Car2() {}\n+    \n+    public Car2(int id) {\n+        this.id = id;\n+    }\n+    \n+    /**\n+     * @return the id\n+     */\n+    public int getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * @param id the id to set\n+     */\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * @return the featureSelection\n+     */\n+    public String getModel() {\n+        return featureSelection;\n+    }\n+\n+    /**\n+     * @param type the type to set\n+     */\n+    public void setModel(String featureSelection) {\n+        this.featureSelection = featureSelection;\n+    }\n+\n+    /**\n+     * @return the color\n+     */\n+    public String getColor() {\n+        return color;\n+    }\n+\n+    /**\n+     * @param name the name to set\n+     */\n+    public void setName(String color) {\n+        this.color = color;\n+    }\n+\n+}"},{"sha":"dae2917bdd1562c2280aacf28f30f45085d74f59","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Chevrolet.java","status":"added","additions":28,"deletions":0,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Chevrolet.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Chevrolet.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Chevrolet.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,28 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+\n+public class Chevrolet extends Car {\n+    public Chevrolet() {}\n+    \n+    public Chevrolet(int id) {\n+        super(id);\n+    }\n+}"},{"sha":"2066fadb7d70f21e5b2d12b5f40caaed65e83043","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Chevrolet2.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Chevrolet2.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Chevrolet2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Chevrolet2.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+import javax.persistence.DiscriminatorValue;\n+import javax.persistence.Entity;\n+\n+//@Entity\n+//@DiscriminatorValue(\"Chevrolet\")\n+public class Chevrolet2 extends Car2 {\n+    public Chevrolet2() {}\n+    \n+    public Chevrolet2(int id) {\n+        super(id);\n+    }\n+}"},{"sha":"85f5657697eb6415d417cb1e1f47eed713776065","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityA.java","status":"added","additions":111,"deletions":0,"changes":111,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityA.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityA.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class EntityA {\n+    private int id;\n+    private String name;\n+    \n+    private String secName;\n+    \n+    private Set<String> delimSet = new HashSet<String>();\n+    private Map<String, String> delimMap = \n+        new HashMap<String, String>();\n+    \n+    public EntityA(){\n+    }\n+    \n+    public EntityA(int id, String name) {\n+        this.name=name;\n+    }\n+    \n+    /**\n+     * @return the id\n+     */\n+    public int getId() {\n+        return id;\n+    }\n+    /**\n+     * @param id the id to set\n+     */\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+    /**\n+     * @return the name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+    /**\n+     * @param name the name to set\n+     */\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    /**\n+     * @return the secName\n+     */\n+    public String getSecName() {\n+        return secName;\n+    }\n+\n+    /**\n+     * @param secName the secName to set\n+     */\n+    public void setSecName(String secName) {\n+        this.secName = secName;\n+    }\n+\n+    public Set<String> getDelimSet() {\n+        return delimSet;\n+    }\n+\n+    public void setDelimSet(Set<String> collectionDelimSet) {\n+        this.delimSet = collectionDelimSet;\n+    }\n+    \n+    public void addDelimSet(String item) {\n+        this.delimSet.add(item);\n+    }\n+\n+    /**\n+     * @return the delimCollectionMap\n+     */\n+    public Map<String, String> getDelimMap() {\n+        return delimMap;\n+    }\n+\n+    /**\n+     * @param delimCollectionMap the delimCollectionMap to set\n+     */\n+    public void setDelimMap(Map<String, String> delimMap) {\n+        this.delimMap = delimMap;\n+    }\n+    \n+    public void addDelimMap(String key, String value) {\n+        this.delimMap.put(key, value);\n+    }\n+}"},{"sha":"91e41090ad038f41d41cddba550b12451ef68951","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityB.java","status":"added","additions":54,"deletions":0,"changes":54,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityB.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityB.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityB.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+public class EntityB {\n+    private int id;\n+    private String name;\n+    \n+    public EntityB(String name) {\n+        this.name = name;\n+    }\n+    \n+    \n+    /**\n+     * @return the id\n+     */\n+    public int getId() {\n+        return id;\n+    }\n+    /**\n+     * @param id the id to set\n+     */\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+    /**\n+     * @return the name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+    /**\n+     * @param name the name to set\n+     */\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+}"},{"sha":"4ae06b08a37b683614c217be39a5d76e98b051aa","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityH.java","status":"added","additions":152,"deletions":0,"changes":152,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityH.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityH.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityH.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+public class EntityH {\n+    private int id;\n+    private String name;\n+    \n+    private String secName;\n+    \n+    private Collection<EntityI> entityIs = new HashSet<EntityI>();\n+    \n+    private EntityI2 entityI2;\n+    \n+    Map<EntityI3,EntityI4> map = new HashMap<EntityI3,EntityI4>();\n+    \n+    Map<EntityI4,EntityI3> map2 = new HashMap<EntityI4,EntityI3>();\n+\n+    public EntityH() {}\n+    \n+    public EntityH(int id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * @return the id\n+     */\n+    public int getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * @param id the id to set\n+     */\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * @return the name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * @param name the name to set\n+     */\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    /**\n+     * @return the secName\n+     */\n+    public String getSecName() {\n+        return secName;\n+    }\n+\n+    /**\n+     * @param secName the secName to set\n+     */\n+    public void setSecName(String secName) {\n+        this.secName = secName;\n+    }\n+    \n+    public Collection<EntityI> getEntityIs() {\n+        return entityIs;\n+    }\n+    /**\n+     * @param entityIs the entityIs to set\n+     */\n+    public void setEntityIs(Collection<EntityI> entityIs) {\n+        this.entityIs = entityIs;\n+    }\n+    \n+    public void addEntityI(EntityI entityI) {\n+        entityIs.add(entityI);\n+    }\n+\n+    /**\n+     * @return the entityI2\n+     */\n+    public EntityI2 getEntityI2() {\n+        return entityI2;\n+    }\n+\n+    /**\n+     * @param entityI2 the entityI2 to set\n+     */\n+    public void setEntityI2(EntityI2 entityI2) {\n+        this.entityI2 = entityI2;\n+    }\n+\n+    /**\n+     * @return the map\n+     */\n+    public Map<EntityI3, EntityI4> getMap() {\n+        return map;\n+    }\n+\n+    /**\n+     * @param map the map to set\n+     */\n+    public void setMap(Map<EntityI3, EntityI4> map) {\n+        this.map = map;\n+    }\n+    \n+    public void addMapValues(EntityI3 key, EntityI4 value) {\n+        map.put(key, value);\n+    }\n+\n+    /**\n+     * @return the map2\n+     */\n+    public Map<EntityI4, EntityI3> getMap2() {\n+        return map2;\n+    }\n+\n+    /**\n+     * @param map2 the map2 to set\n+     */\n+    public void setMap2(Map<EntityI4, EntityI3> map2) {\n+        this.map2 = map2;\n+    }\n+    \n+    public void addMap2Values(EntityI4 key, EntityI3 value) {\n+        map2.put(key, value);\n+    }\n+\n+}"},{"sha":"5ae2155bf00e5e8dabf2cba19e59f7c077179729","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityI.java","status":"added","additions":80,"deletions":0,"changes":80,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityI.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityI.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityI.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+public class EntityI {\n+    private int id;\n+    private String name;\n+    private Collection<EntityH> entityHs = new HashSet<EntityH>();\n+    \n+    public EntityI() {}\n+    \n+    public EntityI(int id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * @return the id\n+     */\n+    public int getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * @param id the id to set\n+     */\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * @return the name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * @param name the name to set\n+     */\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    /**\n+     * @return the entityHs\n+     */\n+    public Collection<EntityH> getEntityHs() {\n+        return entityHs;\n+    }\n+\n+    /**\n+     * @param entityHs the entityHs to set\n+     */\n+    public void setEntityHs(Collection<EntityH> entityHs) {\n+        this.entityHs = entityHs;\n+    }\n+    \n+    public void addEntityH(EntityH entityH) {\n+        entityHs.add(entityH);\n+    }\n+}"},{"sha":"232ddff9e6cebda5e54acdcd5be9712a8ecc1ae9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityI2.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityI2.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityI2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityI2.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+public class EntityI2 {\n+    private int id;\n+    private String name;\n+    \n+    private EntityI3 entityI3;\n+    \n+    public EntityI2() {}\n+    \n+    public EntityI2(int id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * @return the id\n+     */\n+    public int getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * @param id the id to set\n+     */\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * @return the name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * @param name the name to set\n+     */\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    /**\n+     * @return the entityI3\n+     */\n+    public EntityI3 getEntityI3() {\n+        return entityI3;\n+    }\n+\n+    /**\n+     * @param entityI3 the entityI3 to set\n+     */\n+    public void setEntityI3(EntityI3 entityI3) {\n+        this.entityI3 = entityI3;\n+    }\n+}"},{"sha":"8fb030f326a38b6a142f7faa60dcbc9c7d98ef5f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityI3.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityI3.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityI3.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityI3.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+public class EntityI3 {\n+    int id;\n+    String name;\n+    \n+    public EntityI3() {}\n+    \n+    public EntityI3(int id) {\n+        this.id = id;\n+    }\n+    \n+    /**\n+     * @return the id\n+     */\n+    public int getId() {\n+        return id;\n+    }\n+    /**\n+     * @param id the id to set\n+     */\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+    /**\n+     * @return the name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+    /**\n+     * @param name the name to set\n+     */\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+}"},{"sha":"b0d78caac658eb77536b68fda828d4126e75423c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityI4.java","status":"added","additions":56,"deletions":0,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityI4.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityI4.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/EntityI4.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+public class EntityI4 {\n+    int id;\n+    String name;\n+    \n+    public EntityI4() {}\n+    \n+    public EntityI4(int id) {\n+        this.id = id;\n+    }\n+    \n+    /**\n+     * @return the id\n+     */\n+    public int getId() {\n+        return id;\n+    }\n+    /**\n+     * @param id the id to set\n+     */\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+    /**\n+     * @return the name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+    /**\n+     * @param name the name to set\n+     */\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+}"},{"sha":"f894a394d3740099a16b9940d6afd825cf45d528","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Pontiac.java","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Pontiac.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Pontiac.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Pontiac.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,27 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+public class Pontiac extends Car {\n+    public Pontiac() {}\n+    \n+    public Pontiac(int id) {\n+        super(id);\n+    }\n+}"},{"sha":"c9f1caac67608b022f5052dd8b21560157ddf568","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Pontiac2.java","status":"added","additions":32,"deletions":0,"changes":32,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Pontiac2.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Pontiac2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/Pontiac2.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+import javax.persistence.DiscriminatorValue;\n+import javax.persistence.Entity;\n+\n+//@Entity\n+//@DiscriminatorValue(\"Pontiac\")\n+public class Pontiac2 extends Car2 {\n+    public Pontiac2() {}\n+    \n+    public Pontiac2(int id) {\n+        super(id);\n+    }\n+}"},{"sha":"489837322d9907b22a4d3f99575ff90636460eb4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimIdResultSets.java","status":"added","additions":124,"deletions":0,"changes":124,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimIdResultSets.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimIdResultSets.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimIdResultSets.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+import java.util.List;\n+\n+import javax.persistence.Query;\n+\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n+import org.apache.openjpa.persistence.test.SQLListenerTestCase;\n+\n+public class TestXmlDelimIdResultSets \n+        extends SQLListenerTestCase {\n+    OpenJPAEntityManager em;\n+    int id = 0;\n+    Car car;\n+    Pontiac pontiac;\n+    Chevrolet chevrolet;\n+    Car2 car2;\n+    Pontiac2 pontiac2;\n+    Chevrolet2 chevrolet2;\n+    \n+    @Override\n+    public void setUp() throws Exception {\n+        setSupportedDatabases(\n+            org.apache.openjpa.jdbc.sql.DerbyDictionary.class,\n+            org.apache.openjpa.jdbc.sql.DB2Dictionary.class);\n+        if (isTestsDisabled()) {\n+            return;\n+        }\n+        \n+        super.setUp(\n+            org.apache.openjpa.persistence.delimited.identifiers.xml.Car.class,\n+            org.apache.openjpa.persistence.delimited.identifiers.xml.Pontiac.class,\n+            org.apache.openjpa.persistence.delimited.identifiers.xml.Chevrolet.class,\n+            org.apache.openjpa.persistence.delimited.identifiers.xml.Car2.class,\n+            org.apache.openjpa.persistence.delimited.identifiers.xml.Pontiac2.class,\n+            org.apache.openjpa.persistence.delimited.identifiers.xml.Chevrolet2.class,\n+            DROP_TABLES);\n+        assertNotNull(emf);\n+        \n+        em = emf.createEntityManager();\n+        assertNotNull(em);\n+    }\n+    \n+    @Override\n+    protected String getPersistenceUnitName() {\n+        return \"delimited-identifiers-result-set-xml\";\n+    }    \n+    \n+    private void createChevrolet(int id) {\n+        chevrolet = new Chevrolet(id);\n+        chevrolet.setModel(\"Malibu\");\n+        chevrolet.setColor(\"black\");\n+        chevrolet.setModelYear(\"2009\");\n+    }\n+\n+    private void createPontiac(int id) {\n+        pontiac = new Pontiac(id);\n+        pontiac.setModel(\"G6\");\n+        pontiac.setColor(\"red\");\n+        pontiac.setModelYear(\"2005\");\n+    }\n+\n+    public void testCreate() {\n+        id++;\n+        createPontiac(id);\n+        id++;\n+        createChevrolet(id);\n+        \n+        em.getTransaction().begin();\n+        em.persist(pontiac);\n+        em.persist(chevrolet);\n+        em.getTransaction().commit();\n+        \n+        runQueries();\n+    }\n+    \n+    private void runQueries() {\n+        em.clear();\n+        resultSetQuery();\n+    }\n+    \n+    private void resultSetQuery() {\n+        String query = \n+            \"SELECT c.id, c.\\\"car featureSelection\\\", c.\\\"car color\\\", \" +\n+            \"c.\\\"discr col\\\", c.\\\"featureSelection year\\\" \" +\n+            \"FROM \\\"XmlCar\\\" c \";\n+        Query q = em.createNativeQuery(query,\"XmlCarResultSet\");\n+        List<Object[]> results = (List<Object[]>)q.getResultList();\n+        assertEquals(2,results.size());\n+        \n+        for (Object[] result : results) {\n+            assertEquals(2, result.length);\n+            assertTrue(result[0] instanceof Car2);\n+            assertTrue(result[1] instanceof String);\n+            Car2 car2 = (Car2)result[0];\n+            String modelYear = (String)result[1];\n+            if (car2.getModel().equals(\"G6\")) {\n+                assertEquals(\"2005\", modelYear);\n+            }\n+            else if (car2.getModel().equals(\"Malibu\")) {\n+                assertEquals(\"2009\", modelYear);\n+            }\n+        }\n+    }\n+}"},{"sha":"eac77d937a3e5c40a8b97bcac0cb95aeb764cda7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimIdSeqGen.java","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimIdSeqGen.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimIdSeqGen.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimIdSeqGen.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\n+import org.apache.openjpa.persistence.test.SQLListenerTestCase;\n+\n+public class TestXmlDelimIdSeqGen extends SQLListenerTestCase {\n+    OpenJPAEntityManager em;\n+    JDBCConfiguration conf;\n+    DBDictionary dict;\n+    boolean supportsNativeSequence = false;\n+    \n+    EntityB entityB;\n+    \n+    @Override\n+    public void setUp() throws Exception {\n+        setSupportedDatabases(\n+            org.apache.openjpa.jdbc.sql.DB2Dictionary.class);\n+        if (isTestsDisabled()) {\n+            return;\n+        }\n+        \n+        super.setUp(org.apache.openjpa.persistence.delimited.identifiers.xml.EntityB.class, DROP_TABLES);\n+        assertNotNull(emf);\n+        \n+        conf = (JDBCConfiguration) emf.getConfiguration();\n+        dict = conf.getDBDictionaryInstance();\n+        supportsNativeSequence = dict.nextSequenceQuery != null;\n+        \n+        if (supportsNativeSequence) {\n+            em = emf.createEntityManager();\n+            assertNotNull(em);\n+        }\n+    }\n+    \n+    @Override\n+    protected String getPersistenceUnitName() {\n+        return \"delimited-identifiers-seq-gen-xml\";\n+    }    \n+    \n+    public void createEntityB() {\n+        entityB = new EntityB(\"b name\");\n+    }\n+    \n+    public void testSeqGen() {\n+        if (!supportsNativeSequence) {\n+            return;\n+        }\n+        createEntityB();\n+        \n+        em.getTransaction().begin();\n+        em.persist(entityB);\n+        em.getTransaction().commit();\n+        \n+        int genId = entityB.getId();\n+        em.clear();\n+        em.getTransaction().begin();\n+        EntityB bA = em.find(EntityB.class, genId);\n+        assertEquals(\"b name\", bA.getName());\n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+}"},{"sha":"7adc8c5b5b212fac6b78e99804c22c25abd4f8ba","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimInheritance.java","status":"added","additions":113,"deletions":0,"changes":113,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimInheritance.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimInheritance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimInheritance.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+import java.util.List;\n+\n+import javax.persistence.Query;\n+\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n+import org.apache.openjpa.persistence.test.SQLListenerTestCase;\n+\n+public class TestXmlDelimInheritance extends SQLListenerTestCase {\n+    OpenJPAEntityManager em;\n+    int id = 0;\n+    Pontiac pontiac;\n+    Chevrolet chevrolet;\n+    \n+    @Override\n+    public void setUp() throws Exception {\n+        setSupportedDatabases(\n+            org.apache.openjpa.jdbc.sql.DerbyDictionary.class,\n+            org.apache.openjpa.jdbc.sql.DB2Dictionary.class);\n+        if (isTestsDisabled()) {\n+            return;\n+        }\n+        \n+        super.setUp(\n+            org.apache.openjpa.persistence.delimited.identifiers.xml.Car.class,\n+            org.apache.openjpa.persistence.delimited.identifiers.xml.Pontiac.class,\n+            org.apache.openjpa.persistence.delimited.identifiers.xml.Chevrolet.class,\n+            DROP_TABLES);\n+        assertNotNull(emf);\n+        \n+        em = emf.createEntityManager();\n+        assertNotNull(em);\n+    }\n+    \n+    @Override\n+    protected String getPersistenceUnitName() {\n+        return \"delimited-identifiers-inheritance-xml\";\n+    }    \n+    \n+    private void createPontiac(int id) {\n+        pontiac = new Pontiac(id);\n+        pontiac.setModel(\"G6\");\n+        pontiac.setColor(\"red\");\n+    }\n+    \n+    private void createChevrolet(int id) {\n+        chevrolet = new Chevrolet(id);\n+        chevrolet.setModel(\"Malibu\");\n+        chevrolet.setColor(\"black\");\n+    }\n+    \n+    public void testCreate() {\n+        id++;\n+        createPontiac(id);\n+        id++;\n+        createChevrolet(id);\n+        \n+        em.getTransaction().begin();\n+        em.persist(pontiac);\n+        em.persist(chevrolet);\n+        em.getTransaction().commit();\n+        \n+        runQueries();\n+    }\n+    \n+    private void runQueries() {\n+        em.clear();\n+        queryChevrolet();\n+        em.clear();\n+        queryPontiac();\n+    }\n+    \n+    private void queryChevrolet() {\n+        String query =\n+            \"SELECT DISTINCT c \" +\n+            \"FROM Car c \" +\n+            \"WHERE c.featureSelection = 'Malibu'\";\n+        Query q = em.createQuery(query);\n+        List<Car> results = (List<Car>)q.getResultList();\n+        assertEquals(1,results.size());\n+    }\n+    \n+    // Use native query\n+    private void queryPontiac() {\n+        String query = \n+            \"SELECT * \" +\n+            \"FROM \\\"XICar\\\" c \" +\n+            \"WHERE c.\\\"discr col\\\" = 'Pontiac'\";\n+        Query q = em.createNativeQuery(query);\n+        List<Car> results = (List<Car>)q.getResultList();\n+        assertEquals(1,results.size());\n+    }\n+}"},{"sha":"25373dd2d59428dfaa218533792f11d52dc9faa9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimitedIdentifiers.java","status":"added","additions":74,"deletions":0,"changes":74,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimitedIdentifiers.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimitedIdentifiers.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimitedIdentifiers.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+import org.apache.openjpa.jdbc.sql.DB2Dictionary;\n+import org.apache.openjpa.jdbc.sql.DerbyDictionary;\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\n+import org.apache.openjpa.persistence.test.SQLListenerTestCase;\n+\n+public class TestXmlDelimitedIdentifiers extends SQLListenerTestCase {\n+    OpenJPAEntityManager em;\n+    int id = 0;\n+    \n+    EntityA entityA;\n+    \n+    public void setUp() throws Exception {\n+        setSupportedDatabases(DB2Dictionary.class, DerbyDictionary.class);\n+        if (isTestsDisabled())\n+            return;\n+        \n+        super.setUp(org.apache.openjpa.persistence.delimited.identifiers.xml.EntityA.class, DROP_TABLES);\n+        assertNotNull(emf);\n+        \n+        em = emf.createEntityManager();\n+        assertNotNull(em);\n+    }\n+    \n+    @Override\n+    protected String getPersistenceUnitName() {\n+        return \"delimited-identifiers-xml\";\n+    }\n+    \n+    public void createEntityA(int id) {\n+        entityA = new EntityA(id, \"aName\");\n+        entityA.setSecName(\"sec name\");\n+        entityA.addDelimSet(\"aaa\");\n+        entityA.addDelimSet(\"bbb\");\n+        entityA.addDelimMap(\"ccc\", \"ddd\");\n+    }\n+    \n+    public void testTableName() {\n+        id++;\n+        createEntityA(id);\n+        \n+        em.getTransaction().begin();\n+        em.persist(entityA);\n+        em.getTransaction().commit();\n+        \n+        int genId = entityA.getId();\n+        em.clear();\n+        em.getTransaction().begin();\n+        EntityA eA = em.find(EntityA.class, genId);\n+        assertEquals(\"aName\", eA.getName());\n+        \n+        em.getTransaction().commit();\n+        em.close();\n+    }\n+}"},{"sha":"e8fa28eb68be49c8a5344f2ced5be27030f65849","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimitedJoinAnnotation.java","status":"added","additions":161,"deletions":0,"changes":161,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimitedJoinAnnotation.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimitedJoinAnnotation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/delimited/identifiers/xml/TestXmlDelimitedJoinAnnotation.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.persistence.delimited.identifiers.xml;\n+\n+import java.util.List;\n+\n+import javax.persistence.Query;\n+\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.persistence.OpenJPAEntityManager;\n+import org.apache.openjpa.persistence.OpenJPAEntityManagerFactorySPI;\n+import org.apache.openjpa.persistence.test.SQLListenerTestCase;\n+\n+public class TestXmlDelimitedJoinAnnotation extends SQLListenerTestCase {\n+    OpenJPAEntityManager em;\n+    int id = 0;\n+    EntityH entityH;\n+    EntityI entityI;\n+    EntityI2 entityI2;\n+    EntityI3 entityI3;\n+    EntityI4 entityI4;\n+    \n+    @Override\n+    public void setUp() throws Exception {\n+        setSupportedDatabases(\n+            org.apache.openjpa.jdbc.sql.DerbyDictionary.class,\n+            org.apache.openjpa.jdbc.sql.DB2Dictionary.class);\n+        if (isTestsDisabled()) {\n+            return;\n+        }\n+        \n+        super.setUp(\n+            org.apache.openjpa.persistence.delimited.identifiers.xml.EntityH.class,\n+            org.apache.openjpa.persistence.delimited.identifiers.xml.EntityI.class,\n+            org.apache.openjpa.persistence.delimited.identifiers.xml.EntityI2.class,\n+            org.apache.openjpa.persistence.delimited.identifiers.xml.EntityI3.class,\n+            org.apache.openjpa.persistence.delimited.identifiers.xml.EntityI4.class,\n+            DROP_TABLES);\n+        assertNotNull(emf);\n+        \n+        em = emf.createEntityManager();\n+        assertNotNull(em);\n+    }\n+    \n+    @Override\n+    protected String getPersistenceUnitName() {\n+        return \"delimited-identifiers-joins-xml\";\n+    }    \n+    \n+    public void createHandI(int id) {\n+        entityH = new EntityH(id);\n+        entityH.setName(\"eh\");\n+        entityH.setSecName(\"secName1\");\n+        \n+        entityI = new EntityI(id);\n+        entityI.setName(\"ei\");\n+        \n+        entityI2 = new EntityI2(id);\n+        entityI2.setName(\"ei2\");\n+        \n+        entityI3 = new EntityI3(id);\n+        entityI3.setName(\"ei3\");\n+        \n+        entityI4 = new EntityI4(id);\n+        entityI4.setName(\"ei4\");\n+        \n+        entityH.addEntityI(entityI);\n+        entityI.addEntityH(entityH);\n+        \n+        entityH.setEntityI2(entityI2);\n+        \n+        entityH.addMapValues(entityI3, entityI4);\n+        entityH.addMap2Values(entityI4, entityI3);\n+        \n+        entityI2.setEntityI3(entityI3);\n+    }\n+\n+    public void testCreate() {\n+        id++;\n+        createHandI(id);\n+        \n+        em.getTransaction().begin();\n+        em.persist(entityH);\n+        em.persist(entityI);\n+        em.persist(entityI2);\n+        em.persist(entityI3);\n+        em.persist(entityI4);\n+        em.getTransaction().commit();\n+        \n+        runQueries();\n+    }\n+    \n+    private void runQueries() {\n+        em.clear();\n+        queryJoinTable();\n+        em.clear();\n+        queryJoinColumn();\n+        em.clear();\n+        querySecondaryTableValue();\n+        em.clear();\n+        queryMapValue();\n+    }\n+    \n+    private void queryJoinTable() {\n+        String query =\n+            \"SELECT h \" +\n+            \"FROM EntityH h JOIN h.entityIs i \" +\n+            \"WHERE i.name = 'ei'\";\n+        Query q = em.createQuery(query);\n+        List<EntityH> results = (List<EntityH>)q.getResultList();\n+        assertEquals(1,results.size());\n+    }\n+\n+    private void queryJoinColumn() {\n+        String query = \n+            \"SELECT h \" +\n+            \"FROM EntityH h JOIN h.entityI2 i2 \" +\n+            \"WHERE i2.name = 'ei2'\";\n+        Query q = em.createQuery(query);\n+        List<EntityH> results = (List<EntityH>)q.getResultList();\n+        assertEquals(1,results.size());\n+    }\n+\n+    private void querySecondaryTableValue() {\n+        String query = \n+            \"SELECT h \" +\n+            \"FROM EntityH h \" +\n+            \"WHERE h.secName = 'secName1'\";\n+        Query q = em.createQuery(query);\n+        List<EntityH> results = (List<EntityH>)q.getResultList();\n+        assertEquals(1,results.size());\n+    }\n+\n+    private void queryMapValue() {\n+        String query =\n+            \"SELECT h \" +\n+            \"FROM EntityH h, IN(h.map2) m \" +\n+            \"WHERE m.name = 'ei3'\";\n+        Query q = em.createQuery(query);\n+        List<EntityH> results = (List<EntityH>)q.getResultList();\n+        assertEquals(1,results.size());\n+    }\n+    \n+    \n+}"},{"sha":"b5abaa3e5bc3957b869879a13148dada9778a2db","filename":"openjpa-persistence-jdbc/src/test/resources/META-INF/delim_persistence.xml","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/resources/META-INF/delim_persistence.xml","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/resources/META-INF/delim_persistence.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/resources/META-INF/delim_persistence.xml?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,39 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+ Licensed to the Apache Software Foundation (ASF) under one\n+ or more contributor license agreements.  See the NOTICE file\n+ distributed with this work for additional information\n+ regarding copyright ownership.  The ASF licenses this file\n+ to you under the Apache License, Version 2.0 (the\n+ \"License\"); you may not use this file except in compliance\n+ with the License.  You may obtain a copy of the License at\n+ \n+ http://www.apache.org/licenses/LICENSE-2.0\n+ \n+ Unless required by applicable law or agreed to in writing,\n+ software distributed under the License is distributed on an\n+ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ KIND, either express or implied.  See the License for the\n+ specific language governing permissions and limitations\n+ under the License.   \n+-->\n+<persistence xmlns=\"http://java.sun.com/xml/ns/persistence\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    version=\"2.0\">\n+    <persistence-unit name=\"delim-persistence-unit\">\n+        <description>\n+            Special PU for enhancing XML-defined entities used in delimited\n+            identifiers tests.  Mixing them in the default xml PU caused problems\n+            on databases such as Oracle and MySQL which do not behave well when\n+            a non-default schema name is specified in the mapping information.\n+        </description>\n+        <mapping-file>META-INF/delimited-identifiers-joins-orm.xml</mapping-file>\n+        <mapping-file>META-INF/delimited-identifiers-result-set-orm.xml</mapping-file>\n+        <mapping-file>META-INF/delimited-identifiers-xml-orm.xml</mapping-file>\n+        <mapping-file>META-INF/delimited-identifiers-seq-gen-xml-orm.xml</mapping-file>\n+        <properties>\n+            <property name=\"openjpa.jdbc.SynchronizeMappings\"\n+                value=\"buildSchema(ForeignKeys=true)\"/>\n+        </properties>\n+    </persistence-unit>\n+</persistence>\n\\ No newline at end of file"},{"sha":"3ae57ef5c423c0fd50bc8e7e85812cc73bc2f7ec","filename":"openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-inheritance-xml-orm.xml","status":"added","additions":51,"deletions":0,"changes":51,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-inheritance-xml-orm.xml","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-inheritance-xml-orm.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-inheritance-xml-orm.xml?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,51 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+ Licensed to the Apache Software Foundation (ASF) under one\n+ or more contributor license agreements.  See the NOTICE file\n+ distributed with this work for additional information\n+ regarding copyright ownership.  The ASF licenses this file\n+ to you under the Apache License, Version 2.0 (the\n+ \"License\"); you may not use this file except in compliance\n+ with the License.  You may obtain a copy of the License at\n+ \n+ http://www.apache.org/licenses/LICENSE-2.0\n+ \n+ Unless required by applicable law or agreed to in writing,\n+ software distributed under the License is distributed on an\n+ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ KIND, either express or implied.  See the License for the\n+ specific language governing permissions and limitations\n+ under the License.   \n+-->\n+<entity-mappings xmlns=\"http://java.sun.com/xml/ns/persistence/orm\" \n+xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n+xsi:schemaLocation=\"http://java.sun.com/xml/ns/persistence/orm\n+                    http://java.sun.com/xml/ns/persistence/orm_2_0.xsd\" \n+version=\"2.0\">\n+\t<entity class=\"org.apache.openjpa.persistence.delimited.identifiers.xml.Car\">\n+\t\t<table name=\"&quot;XICar&quot;\"/>\n+\t\t<inheritance/>\n+\t\t<discriminator-column name=\"&quot;discr col&quot;\" column-definition=\"VARCHAR(10)\"/>\n+\t\t<attributes>\n+\t\t\t<id name=\"id\"/>\n+\t\t\t<basic name=\"featureSelection\">\n+\t\t\t\t<column name=\"&quot;car featureSelection&quot;\"/>\n+\t\t\t</basic>\n+\t\t\t<basic name=\"color\">\n+\t\t\t\t<column name=\"&quot;car color&quot;\"/>\n+\t\t\t</basic>\n+\t\t\t<basic name=\"modelYear\">\n+\t\t\t\t<column name=\"&quot;featureSelection year&quot;\"/>\n+\t\t\t</basic>\n+\t\t</attributes>\n+\t</entity>\t\n+\t\n+\t<entity class=\"org.apache.openjpa.persistence.delimited.identifiers.xml.Pontiac\">\n+\t\t<discriminator-value>Pontiac</discriminator-value>\n+\t</entity>\n+\t\n+\t<entity class=\"org.apache.openjpa.persistence.delimited.identifiers.xml.Chevrolet\">\n+\t\t<discriminator-value>Chevrolet</discriminator-value>\n+\t</entity>\n+\n+</entity-mappings>\n\\ No newline at end of file"},{"sha":"c48aa68fe4b3a90d0942ee384a4001eadc6f03a1","filename":"openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-joins-orm.xml","status":"added","additions":104,"deletions":0,"changes":104,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-joins-orm.xml","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-joins-orm.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-joins-orm.xml?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,104 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+ Licensed to the Apache Software Foundation (ASF) under one\n+ or more contributor license agreements.  See the NOTICE file\n+ distributed with this work for additional information\n+ regarding copyright ownership.  The ASF licenses this file\n+ to you under the Apache License, Version 2.0 (the\n+ \"License\"); you may not use this file except in compliance\n+ with the License.  You may obtain a copy of the License at\n+ \n+ http://www.apache.org/licenses/LICENSE-2.0\n+ \n+ Unless required by applicable law or agreed to in writing,\n+ software distributed under the License is distributed on an\n+ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ KIND, either express or implied.  See the License for the\n+ specific language governing permissions and limitations\n+ under the License.   \n+-->\n+<entity-mappings xmlns=\"http://java.sun.com/xml/ns/persistence/orm\" \n+xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n+xsi:schemaLocation=\"http://java.sun.com/xml/ns/persistence/orm\n+                    http://java.sun.com/xml/ns/persistence/orm_2_0.xsd\" \n+version=\"2.0\">\n+\t<entity class=\"org.apache.openjpa.persistence.delimited.identifiers.xml.EntityH\">\n+\t\t<table name=\"&quot;entity h&quot;\" schema=\"&quot;delim xml&quot;\"/>\n+\t\t<secondary-table name=\"&quot;h sec join table&quot;\" schema=\"&quot;delim xml&quot;\">\n+\t\t\t<primary-key-join-column name=\"&quot;entity h&quot;\" referenced-column-name=\"&quot;h id&quot;\"/>\n+\t\t</secondary-table>\n+\t\t<attributes>\n+\t\t\t<id name=\"id\">\n+\t\t\t\t<column name=\"&quot;h id&quot;\"/>\n+\t\t\t</id>\n+\t\t\t<basic name=\"name\"/>\n+\t\t\t<basic name=\"secName\">\n+\t\t\t\t<column name=\"&quot;h sec join table&quot;\"/>\n+\t\t\t</basic>\n+\t\t\t\n+\t\t\t<one-to-one name=\"entityI2\">\n+\t\t\t\t<join-column name=\"&quot;enti2 id&quot;\" referenced-column-name=\"&quot;entityI2 id&quot;\"\n+\t\t\t\t\ttable=\"&quot;join column&quot;\"/>\n+\t\t\t</one-to-one>\n+\t\t\t\n+\t\t\t<many-to-many name=\"entityIs\">\n+\t\t\t\t<join-table name=\"&quot;h i&quot;\" schema=\"&quot;delim xml&quot;\"/>\n+\t\t\t</many-to-many>\n+\t\t\t\n+\t\t\t<many-to-many name=\"map\">\n+\t\t\t\t<map-key-join-column name=\"&quot;map_ei3&quot;\" referenced-column-name=\"&quot;entityI3 id&quot;\"/>\n+\t\t\t\t<join-table name=\"&quot;map3 join table&quot;\" schema=\"&quot;delim xml&quot;\"/>\n+\t\t\t</many-to-many>\n+\t\t\t\n+\t\t\t<many-to-many name=\"map2\">\n+\t\t\t\t<map-key-join-column name=\"&quot;map ei4&quot;\" referenced-column-name=\"&quot;entityI4 id&quot;\"\n+\t\t\t\t\ttable=\"&quot;map key join column&quot;\"/>\n+\t\t\t\t<join-table name=\"&quot;map4 join table&quot;\" schema=\"&quot;delim xml&quot;\"/>\n+\t\t\t</many-to-many>\n+\t\t</attributes>\n+\t</entity>\t\n+\t\n+\t<entity class=\"org.apache.openjpa.persistence.delimited.identifiers.xml.EntityI\">\n+\t\t<table name=\"&quot;entity i&quot;\" schema=\"&quot;delim xml&quot;\"/>\n+\t\t<attributes>\n+\t\t\t<id name=\"id\"/>\n+\t\t\t<many-to-many name=\"entityHs\" mapped-by=\"entityIs\"/>\n+\t\t</attributes>\n+\t</entity>\n+\t\n+\t<entity class=\"org.apache.openjpa.persistence.delimited.identifiers.xml.EntityI2\">\n+\t\t<table name=\"&quot;entity i2&quot;\" schema=\"&quot;delim xml&quot;\"/>\n+\t\t<attributes>\n+\t\t\t<id name=\"id\">\n+\t\t\t\t<column name=\"&quot;entityI2 id&quot;\"/>\n+\t\t\t</id>\n+\t\t\t<basic name=\"name\"/>\n+\t\t\t<one-to-one name=\"entityI3\">\n+\t\t\t\t<primary-key-join-column/>\n+\t\t\t</one-to-one>\n+\t\t</attributes>\n+\t</entity>\n+\t\n+\t<entity class=\"org.apache.openjpa.persistence.delimited.identifiers.xml.EntityI3\">\n+\t\t<table name=\"&quot;entity i3&quot;\" schema=\"&quot;delim xml&quot;\"/>\n+\t\t<attributes>\n+\t\t\t<id name=\"id\">\n+\t\t\t\t<column name=\"&quot;entityI3 id&quot;\"/>\n+\t\t\t</id>\n+\t\t\t<basic name=\"name\"/>\n+\t\t</attributes>\n+\t</entity>\n+\t\n+\t<entity class=\"org.apache.openjpa.persistence.delimited.identifiers.xml.EntityI4\">\n+\t\t<table name=\"&quot;entity i4&quot;\" schema=\"&quot;delim xml&quot;\"/>\n+\t\t<attributes>\n+\t\t\t<id name=\"id\">\n+\t\t\t\t<column name=\"&quot;entityI4 id&quot;\"/>\n+\t\t\t</id>\n+\t\t\t<basic name=\"name\"/>\n+\t\t</attributes>\n+\t</entity>\n+\t\n+\t\n+\n+</entity-mappings>\n\\ No newline at end of file"},{"sha":"0a46011a95a7f80e07c539d475e44092cb4475a0","filename":"openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-result-set-orm.xml","status":"added","additions":79,"deletions":0,"changes":79,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-result-set-orm.xml","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-result-set-orm.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-result-set-orm.xml?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,79 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+ Licensed to the Apache Software Foundation (ASF) under one\n+ or more contributor license agreements.  See the NOTICE file\n+ distributed with this work for additional information\n+ regarding copyright ownership.  The ASF licenses this file\n+ to you under the Apache License, Version 2.0 (the\n+ \"License\"); you may not use this file except in compliance\n+ with the License.  You may obtain a copy of the License at\n+ \n+ http://www.apache.org/licenses/LICENSE-2.0\n+ \n+ Unless required by applicable law or agreed to in writing,\n+ software distributed under the License is distributed on an\n+ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ KIND, either express or implied.  See the License for the\n+ specific language governing permissions and limitations\n+ under the License.   \n+-->\n+<entity-mappings xmlns=\"http://java.sun.com/xml/ns/persistence/orm\" \n+xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n+xsi:schemaLocation=\"http://java.sun.com/xml/ns/persistence/orm\n+                    http://java.sun.com/xml/ns/persistence/orm_2_0.xsd\" \n+version=\"2.0\">\n+\t<sql-result-set-mapping name=\"XmlCarResultSet\">\n+\t\t<entity-result entity-class=\"org.apache.openjpa.persistence.delimited.identifiers.xml.Car2\"\n+\t\t\t\tdiscriminator-column=\"&quot;discr col&quot;\">\n+\t\t\t<field-result name=\"featureSelection\" column=\"&quot;car featureSelection&quot;\"/>\n+\t\t\t<field-result name=\"color\" column=\"&quot;car color&quot;\"/>\n+\t\t</entity-result>\n+\t\t<column-result name=\"&quot;featureSelection year&quot;\"/>\n+\t</sql-result-set-mapping>\n+\n+\t<entity class=\"org.apache.openjpa.persistence.delimited.identifiers.xml.Car\">\n+\t\t<table name=\"&quot;XmlCar&quot;\"/>\n+\t\t<inheritance/>\n+\t\t<discriminator-column name=\"&quot;discr col&quot;\" column-definition=\"VARCHAR(10)\"/>\n+\t\t<attributes>\n+\t\t\t<id name=\"id\"/>\n+\t\t\t<basic name=\"featureSelection\">\n+\t\t\t\t<column name=\"&quot;car featureSelection&quot;\"/>\n+\t\t\t</basic>\n+\t\t\t<basic name=\"color\">\n+\t\t\t\t<column name=\"&quot;car color&quot;\"/>\n+\t\t\t</basic>\n+\t\t\t<basic name=\"modelYear\">\n+\t\t\t\t<column name=\"&quot;featureSelection year&quot;\"/>\n+\t\t\t</basic>\n+\t\t</attributes>\n+\t</entity>\n+\t\n+\t<entity class=\"org.apache.openjpa.persistence.delimited.identifiers.xml.Car2\">\n+\t\t<table name=\"&quot;XmlCar2&quot;\"/>\n+\t\t<inheritance/>\n+\t\t<discriminator-column name=\"&quot;discr col&quot;\" column-definition=\"VARCHAR(10)\"/>\n+\t\t<attributes>\n+\t\t\t<id name=\"id\"/>\n+\t\t\t<basic name=\"color\"/>\n+\t\t\t<basic name=\"featureSelection\"/>\n+\t\t</attributes>\n+\t</entity>\n+\t\n+\t<entity class=\"org.apache.openjpa.persistence.delimited.identifiers.xml.Pontiac\">\n+\t\t<discriminator-value>Pontiac</discriminator-value>\n+\t</entity>\n+\t\n+\t<entity class=\"org.apache.openjpa.persistence.delimited.identifiers.xml.Chevrolet\">\n+\t\t<discriminator-value>Chevrolet</discriminator-value>\n+\t</entity>\n+\t\n+\t<entity class=\"org.apache.openjpa.persistence.delimited.identifiers.xml.Pontiac2\">\n+\t\t<discriminator-value>Pontiac</discriminator-value>\n+\t</entity>\n+\t\n+\t<entity class=\"org.apache.openjpa.persistence.delimited.identifiers.xml.Chevrolet2\">\n+\t\t<discriminator-value>Chevrolet</discriminator-value>\n+\t</entity>\n+\n+</entity-mappings>\n\\ No newline at end of file"},{"sha":"12289cdf9289da0c9d758fc3845c83b27a9c5547","filename":"openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-seq-gen-xml-orm.xml","status":"added","additions":39,"deletions":0,"changes":39,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-seq-gen-xml-orm.xml","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-seq-gen-xml-orm.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-seq-gen-xml-orm.xml?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,39 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+ Licensed to the Apache Software Foundation (ASF) under one\n+ or more contributor license agreements.  See the NOTICE file\n+ distributed with this work for additional information\n+ regarding copyright ownership.  The ASF licenses this file\n+ to you under the Apache License, Version 2.0 (the\n+ \"License\"); you may not use this file except in compliance\n+ with the License.  You may obtain a copy of the License at\n+ \n+ http://www.apache.org/licenses/LICENSE-2.0\n+ \n+ Unless required by applicable law or agreed to in writing,\n+ software distributed under the License is distributed on an\n+ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ KIND, either express or implied.  See the License for the\n+ specific language governing permissions and limitations\n+ under the License.   \n+-->\n+<entity-mappings xmlns=\"http://java.sun.com/xml/ns/persistence/orm\" \n+xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n+xsi:schemaLocation=\"http://java.sun.com/xml/ns/persistence/orm\n+                    http://java.sun.com/xml/ns/persistence/orm_2_0.xsd\" \n+version=\"2.0\">\n+\t<entity class=\"org.apache.openjpa.persistence.delimited.identifiers.xml.EntityB\">\n+\t\t<table name=\"&quot;entityB xml&quot;\" schema=\"&quot;delim xml&quot;\"/>\n+\t\t<attributes>\n+\t\t\t<id name=\"id\">\n+\t\t\t\t<generated-value strategy=\"SEQUENCE\" generator=\"xml-seq-gen\"/>\n+\t\t\t\t<sequence-generator name=\"xml-seq-gen\" sequence-name=\"&quot;xml seq gen&quot;\"\n+\t\t\t\t\tschema=\"&quot;delim xml&quot;\"/>\n+\t\t\t</id>\n+\t\t\t<basic name=\"name\">\n+\t\t\t\t<column name=\"&quot;b name&quot;\"/>\n+\t\t\t</basic>\n+\t\t</attributes>\n+\t</entity>\t\n+\n+</entity-mappings>\n\\ No newline at end of file"},{"sha":"ce4e9e28c82a0d14d4fcd94bc5c487d291bcc1c4","filename":"openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-xml-orm.xml","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-xml-orm.xml","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-xml-orm.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/resources/META-INF/delimited-identifiers-xml-orm.xml?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b","patch":"@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+ Licensed to the Apache Software Foundation (ASF) under one\n+ or more contributor license agreements.  See the NOTICE file\n+ distributed with this work for additional information\n+ regarding copyright ownership.  The ASF licenses this file\n+ to you under the Apache License, Version 2.0 (the\n+ \"License\"); you may not use this file except in compliance\n+ with the License.  You may obtain a copy of the License at\n+ \n+ http://www.apache.org/licenses/LICENSE-2.0\n+ \n+ Unless required by applicable law or agreed to in writing,\n+ software distributed under the License is distributed on an\n+ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ KIND, either express or implied.  See the License for the\n+ specific language governing permissions and limitations\n+ under the License.   \n+-->\n+<entity-mappings xmlns=\"http://java.sun.com/xml/ns/persistence/orm\" \n+xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n+xsi:schemaLocation=\"http://java.sun.com/xml/ns/persistence/orm\n+                    http://java.sun.com/xml/ns/persistence/orm_2_0.xsd\" \n+version=\"2.0\">\n+\t<entity class=\"org.apache.openjpa.persistence.delimited.identifiers.xml.EntityA\">\n+\t\t<table name=\"&quot;xml entityA&quot;\" schema=\"&quot;delim xml&quot;\"/>\n+\t\t<secondary-table name=\"&quot;sec tbl A xml&quot;\" schema=\"&quot;delim xml&quot;\">\n+\t\t\t<unique-constraint name=\"&quot;xml sec unq&quot;\">\n+\t\t\t\t<column-name>&quot;sec col name&quot;</column-name>\n+\t\t\t</unique-constraint>\n+\t\t</secondary-table>\n+\t\t<attributes>\n+\t\t\t<id name=\"id\">\n+\t\t\t\t<generated-value strategy=\"TABLE\" generator=\"xml-id-gen\"/>\n+\t\t\t\t<table-generator name=\"xml-id-gen\" table=\"&quot;xml id gen&quot;\" schema=\"&quot;delim xml&quot;\"\n+\t\t\t\t\tpk-column-name=\"&quot;xml gen pk&quot;\" value-column-name=\"&quot;xml gen value&quot;\"/>\n+\t\t\t</id>\n+\t\t\t<basic name=\"name\">\n+\t\t\t\t<column name=\"&quot;pri col name&quot;\" column-definition=\"VARCHAR\"/>\n+\t\t\t</basic>\n+\t\t\t<basic name=\"secName\">\n+\t\t\t\t<column name=\"&quot;sec col name&quot;\" table=\"&quot;sec tbl A xml&quot;\"/>\n+\t\t\t</basic>\n+\t\t\t<element-collection name=\"delimSet\">\n+\t\t\t\t<order-column name=\"&quot;order col xml&quot;\"/>\n+\t\t\t\t<collection-table name=\"&quot;xml delim set&quot;\" schema=\"&quot;delim xml&quot;\"/>\n+\t\t\t</element-collection>\n+\t\t\t<element-collection name=\"delimMap\">\n+\t\t\t\t<map-key-column name=\"&quot;xml map key&quot;\" column-definition=\"VARCHAR(20)\"\n+\t\t\t\t\ttable=\"&quot;xml map key table&quot;\"/>\n+\t\t\t</element-collection>\n+\t\t</attributes>\n+\t</entity>\n+\n+</entity-mappings>\n\\ No newline at end of file"},{"sha":"f64663a5c6e12e469905b46d131817b55ddd4cc6","filename":"openjpa-persistence-jdbc/src/test/resources/META-INF/persistence.xml","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/resources/META-INF/persistence.xml","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence-jdbc/src/test/resources/META-INF/persistence.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/resources/META-INF/persistence.xml?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b"},{"sha":"a07b934a7b29a5ca157588fd58c7e2ba713fb98f","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","status":"modified","additions":17,"deletions":11,"changes":28,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b"},{"sha":"e72d591d4aae27572f55e1ca34bd95aca3faeb62","filename":"openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","status":"modified","additions":25,"deletions":2,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","raw_url":"https://github.com/apache/openjpa/raw/fadd48fe5b68577a3a75d86fb7e51746d6662c3b/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java?ref=fadd48fe5b68577a3a75d86fb7e51746d6662c3b"}]}

