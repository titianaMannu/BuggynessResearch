{"url":"https://api.github.com/repos/apache/openjpa/compare/1.2.1...1.2.2","html_url":"https://github.com/apache/openjpa/compare/1.2.1...1.2.2","permalink_url":"https://github.com/apache/openjpa/compare/apache:26dbc39...apache:9d34ef9","diff_url":"https://github.com/apache/openjpa/compare/1.2.1...1.2.2.diff","patch_url":"https://github.com/apache/openjpa/compare/1.2.1...1.2.2.patch","base_commit":{"sha":"26dbc39431ad73a66752053fb278bb5027edc07e","node_id":"MDY6Q29tbWl0MjA2MzY0OjI2ZGJjMzk0MzFhZDczYTY2NzUyMDUzZmIyNzhiYjUwMjdlZGMwN2U=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-13T14:14:21Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-13T14:14:21Z"},"message":"remove extra dir\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/tags/1.2.1@753278 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"22a38e864bcb517a217564335d933e0fb9dc7c3d","url":"https://api.github.com/repos/apache/openjpa/git/trees/22a38e864bcb517a217564335d933e0fb9dc7c3d"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/26dbc39431ad73a66752053fb278bb5027edc07e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/26dbc39431ad73a66752053fb278bb5027edc07e","html_url":"https://github.com/apache/openjpa/commit/26dbc39431ad73a66752053fb278bb5027edc07e","comments_url":"https://api.github.com/repos/apache/openjpa/commits/26dbc39431ad73a66752053fb278bb5027edc07e/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"e9c0347cfa97a7310ca6a56fbc50db83b97974e7","url":"https://api.github.com/repos/apache/openjpa/commits/e9c0347cfa97a7310ca6a56fbc50db83b97974e7","html_url":"https://github.com/apache/openjpa/commit/e9c0347cfa97a7310ca6a56fbc50db83b97974e7"}]},"merge_base_commit":{"sha":"26dbc39431ad73a66752053fb278bb5027edc07e","node_id":"MDY6Q29tbWl0MjA2MzY0OjI2ZGJjMzk0MzFhZDczYTY2NzUyMDUzZmIyNzhiYjUwMjdlZGMwN2U=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-13T14:14:21Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-13T14:14:21Z"},"message":"remove extra dir\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/tags/1.2.1@753278 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"22a38e864bcb517a217564335d933e0fb9dc7c3d","url":"https://api.github.com/repos/apache/openjpa/git/trees/22a38e864bcb517a217564335d933e0fb9dc7c3d"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/26dbc39431ad73a66752053fb278bb5027edc07e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/26dbc39431ad73a66752053fb278bb5027edc07e","html_url":"https://github.com/apache/openjpa/commit/26dbc39431ad73a66752053fb278bb5027edc07e","comments_url":"https://api.github.com/repos/apache/openjpa/commits/26dbc39431ad73a66752053fb278bb5027edc07e/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"e9c0347cfa97a7310ca6a56fbc50db83b97974e7","url":"https://api.github.com/repos/apache/openjpa/commits/e9c0347cfa97a7310ca6a56fbc50db83b97974e7","html_url":"https://github.com/apache/openjpa/commit/e9c0347cfa97a7310ca6a56fbc50db83b97974e7"}]},"status":"ahead","ahead_by":58,"behind_by":0,"total_commits":58,"commits":[{"sha":"cf631dedfef71253f985973234d0c8e0682fba5d","node_id":"MDY6Q29tbWl0MjA2MzY0OmNmNjMxZGVkZmVmNzEyNTNmOTg1OTczMjM0ZDBjOGUwNjgyZmJhNWQ=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-03T23:17:26Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-03T23:17:26Z"},"message":"Update version to the next snapshot level\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@749831 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"864df7eb3ec2c89d7d09b2151e0596a0f0c50d80","url":"https://api.github.com/repos/apache/openjpa/git/trees/864df7eb3ec2c89d7d09b2151e0596a0f0c50d80"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/cf631dedfef71253f985973234d0c8e0682fba5d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/cf631dedfef71253f985973234d0c8e0682fba5d","html_url":"https://github.com/apache/openjpa/commit/cf631dedfef71253f985973234d0c8e0682fba5d","comments_url":"https://api.github.com/repos/apache/openjpa/commits/cf631dedfef71253f985973234d0c8e0682fba5d/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"a5f15860f810bbb730166f290271c5e8fd8e2f6b","url":"https://api.github.com/repos/apache/openjpa/commits/a5f15860f810bbb730166f290271c5e8fd8e2f6b","html_url":"https://github.com/apache/openjpa/commit/a5f15860f810bbb730166f290271c5e8fd8e2f6b"}]},{"sha":"06b71ddbd8294494c2d8ddbe5450025bf03997ee","node_id":"MDY6Q29tbWl0MjA2MzY0OjA2YjcxZGRiZDgyOTQ0OTRjMmQ4ZGRiZTU0NTAwMjViZjAzOTk3ZWU=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-04T14:40:58Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-04T14:40:58Z"},"message":"Fix version of commons-dbcp\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@750026 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"613d919c18e32128d59a71571bbc5e32845f4503","url":"https://api.github.com/repos/apache/openjpa/git/trees/613d919c18e32128d59a71571bbc5e32845f4503"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/06b71ddbd8294494c2d8ddbe5450025bf03997ee","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/06b71ddbd8294494c2d8ddbe5450025bf03997ee","html_url":"https://github.com/apache/openjpa/commit/06b71ddbd8294494c2d8ddbe5450025bf03997ee","comments_url":"https://api.github.com/repos/apache/openjpa/commits/06b71ddbd8294494c2d8ddbe5450025bf03997ee/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"cf631dedfef71253f985973234d0c8e0682fba5d","url":"https://api.github.com/repos/apache/openjpa/commits/cf631dedfef71253f985973234d0c8e0682fba5d","html_url":"https://github.com/apache/openjpa/commit/cf631dedfef71253f985973234d0c8e0682fba5d"}]},{"sha":"5bf64d1f681670265a18992bfd07574033adb5fc","node_id":"MDY6Q29tbWl0MjA2MzY0OjViZjY0ZDFmNjgxNjcwMjY1YTE4OTkyYmZkMDc1NzQwMzNhZGI1ZmM=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-08T18:15:26Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-08T18:15:26Z"},"message":"Rollback release\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@751490 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"5d7ba648a1b904c98544c99a716f74e23c8a2ce7","url":"https://api.github.com/repos/apache/openjpa/git/trees/5d7ba648a1b904c98544c99a716f74e23c8a2ce7"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/5bf64d1f681670265a18992bfd07574033adb5fc","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/5bf64d1f681670265a18992bfd07574033adb5fc","html_url":"https://github.com/apache/openjpa/commit/5bf64d1f681670265a18992bfd07574033adb5fc","comments_url":"https://api.github.com/repos/apache/openjpa/commits/5bf64d1f681670265a18992bfd07574033adb5fc/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"06b71ddbd8294494c2d8ddbe5450025bf03997ee","url":"https://api.github.com/repos/apache/openjpa/commits/06b71ddbd8294494c2d8ddbe5450025bf03997ee","html_url":"https://github.com/apache/openjpa/commit/06b71ddbd8294494c2d8ddbe5450025bf03997ee"}]},{"sha":"5f49357c193dc5f5fd87220a7465019a7440033a","node_id":"MDY6Q29tbWl0MjA2MzY0OjVmNDkzNTdjMTkzZGM1ZjVmZDg3MjIwYTc0NjUwMTlhNzQ0MDAzM2E=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-11T22:37:51Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-11T22:37:51Z"},"message":"OPENJPA-679. Committing Fay's patch\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@752663 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"8c3aac49748b94f14a0bb86f78150d9b0471a1e6","url":"https://api.github.com/repos/apache/openjpa/git/trees/8c3aac49748b94f14a0bb86f78150d9b0471a1e6"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/5f49357c193dc5f5fd87220a7465019a7440033a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/5f49357c193dc5f5fd87220a7465019a7440033a","html_url":"https://github.com/apache/openjpa/commit/5f49357c193dc5f5fd87220a7465019a7440033a","comments_url":"https://api.github.com/repos/apache/openjpa/commits/5f49357c193dc5f5fd87220a7465019a7440033a/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"5bf64d1f681670265a18992bfd07574033adb5fc","url":"https://api.github.com/repos/apache/openjpa/commits/5bf64d1f681670265a18992bfd07574033adb5fc","html_url":"https://github.com/apache/openjpa/commit/5bf64d1f681670265a18992bfd07574033adb5fc"}]},{"sha":"70016d17f04c73c9af2144c181ca27cf664deab5","node_id":"MDY6Q29tbWl0MjA2MzY0OjcwMDE2ZDE3ZjA0YzczYzlhZjIxNDRjMTgxY2EyN2NmNjY0ZGVhYjU=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-12T00:13:16Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-12T00:13:16Z"},"message":"[maven-release-plugin] prepare release 1.2.1\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@752700 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6ee7444380c71779700637d23c7dee98d3170701","url":"https://api.github.com/repos/apache/openjpa/git/trees/6ee7444380c71779700637d23c7dee98d3170701"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/70016d17f04c73c9af2144c181ca27cf664deab5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/70016d17f04c73c9af2144c181ca27cf664deab5","html_url":"https://github.com/apache/openjpa/commit/70016d17f04c73c9af2144c181ca27cf664deab5","comments_url":"https://api.github.com/repos/apache/openjpa/commits/70016d17f04c73c9af2144c181ca27cf664deab5/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"5f49357c193dc5f5fd87220a7465019a7440033a","url":"https://api.github.com/repos/apache/openjpa/commits/5f49357c193dc5f5fd87220a7465019a7440033a","html_url":"https://github.com/apache/openjpa/commit/5f49357c193dc5f5fd87220a7465019a7440033a"}]},{"sha":"b277dab6b41ba8ad3e9212e5063791b3540b1a43","node_id":"MDY6Q29tbWl0MjA2MzY0OmIyNzdkYWI2YjQxYmE4YWQzZTkyMTJlNTA2Mzc5MWIzNTQwYjFhNDM=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-12T00:53:02Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-12T00:53:02Z"},"message":"Update release notes and changes\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@752731 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"22a38e864bcb517a217564335d933e0fb9dc7c3d","url":"https://api.github.com/repos/apache/openjpa/git/trees/22a38e864bcb517a217564335d933e0fb9dc7c3d"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/b277dab6b41ba8ad3e9212e5063791b3540b1a43","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/b277dab6b41ba8ad3e9212e5063791b3540b1a43","html_url":"https://github.com/apache/openjpa/commit/b277dab6b41ba8ad3e9212e5063791b3540b1a43","comments_url":"https://api.github.com/repos/apache/openjpa/commits/b277dab6b41ba8ad3e9212e5063791b3540b1a43/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"70016d17f04c73c9af2144c181ca27cf664deab5","url":"https://api.github.com/repos/apache/openjpa/commits/70016d17f04c73c9af2144c181ca27cf664deab5","html_url":"https://github.com/apache/openjpa/commit/70016d17f04c73c9af2144c181ca27cf664deab5"}]},{"sha":"e786a08bd27dc43a060ddd29ebbd6095a8c92ffb","node_id":"MDY6Q29tbWl0MjA2MzY0OmU3ODZhMDhiZDI3ZGM0M2EwNjBkZGQyOWViYmQ2MDk1YThjOTJmZmI=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-12T00:55:10Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-12T00:55:10Z"},"message":"Update version to 1.2.2-SNAPSHOT\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@752733 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"2c82f34091ea6209c3317c26f9ff63ec743127a6","url":"https://api.github.com/repos/apache/openjpa/git/trees/2c82f34091ea6209c3317c26f9ff63ec743127a6"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/e786a08bd27dc43a060ddd29ebbd6095a8c92ffb","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/e786a08bd27dc43a060ddd29ebbd6095a8c92ffb","html_url":"https://github.com/apache/openjpa/commit/e786a08bd27dc43a060ddd29ebbd6095a8c92ffb","comments_url":"https://api.github.com/repos/apache/openjpa/commits/e786a08bd27dc43a060ddd29ebbd6095a8c92ffb/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"b277dab6b41ba8ad3e9212e5063791b3540b1a43","url":"https://api.github.com/repos/apache/openjpa/commits/b277dab6b41ba8ad3e9212e5063791b3540b1a43","html_url":"https://github.com/apache/openjpa/commit/b277dab6b41ba8ad3e9212e5063791b3540b1a43"}]},{"sha":"115af5954d8ba917d83b7dceb181b01257c359ab","node_id":"MDY6Q29tbWl0MjA2MzY0OjExNWFmNTk1NGQ4YmE5MTdkODNiN2RjZWIxODFiMDEyNTdjMzU5YWI=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-22T23:51:28Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-22T23:51:28Z"},"message":"OPENJPA-896. Setting eol-style:native and removing windows eol characters from source files.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@757282 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ab319d3032f3fa17ec07fc7036deedcd8f73f16c","url":"https://api.github.com/repos/apache/openjpa/git/trees/ab319d3032f3fa17ec07fc7036deedcd8f73f16c"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/115af5954d8ba917d83b7dceb181b01257c359ab","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/115af5954d8ba917d83b7dceb181b01257c359ab","html_url":"https://github.com/apache/openjpa/commit/115af5954d8ba917d83b7dceb181b01257c359ab","comments_url":"https://api.github.com/repos/apache/openjpa/commits/115af5954d8ba917d83b7dceb181b01257c359ab/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"e786a08bd27dc43a060ddd29ebbd6095a8c92ffb","url":"https://api.github.com/repos/apache/openjpa/commits/e786a08bd27dc43a060ddd29ebbd6095a8c92ffb","html_url":"https://github.com/apache/openjpa/commit/e786a08bd27dc43a060ddd29ebbd6095a8c92ffb"}]},{"sha":"72f4ebcda0e2086c8699580100976a7f8a7d5f8a","node_id":"MDY6Q29tbWl0MjA2MzY0OjcyZjRlYmNkYTBlMjA4NmM4Njk5NTgwMTAwOTc2YTdmOGE3ZDVmOGE=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-23T12:42:37Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-03-23T12:42:37Z"},"message":"OPENJPA-896. Setting eol-style:native and removing windows eol characters from XML files.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@757387 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"fee2c977e7c9a04f4e04048e95f65b84a2361c4e","url":"https://api.github.com/repos/apache/openjpa/git/trees/fee2c977e7c9a04f4e04048e95f65b84a2361c4e"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/72f4ebcda0e2086c8699580100976a7f8a7d5f8a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/72f4ebcda0e2086c8699580100976a7f8a7d5f8a","html_url":"https://github.com/apache/openjpa/commit/72f4ebcda0e2086c8699580100976a7f8a7d5f8a","comments_url":"https://api.github.com/repos/apache/openjpa/commits/72f4ebcda0e2086c8699580100976a7f8a7d5f8a/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"115af5954d8ba917d83b7dceb181b01257c359ab","url":"https://api.github.com/repos/apache/openjpa/commits/115af5954d8ba917d83b7dceb181b01257c359ab","html_url":"https://github.com/apache/openjpa/commit/115af5954d8ba917d83b7dceb181b01257c359ab"}]},{"sha":"058836c6e474f204654651bfb89aae6d77fcad64","node_id":"MDY6Q29tbWl0MjA2MzY0OjA1ODgzNmM2ZTQ3NGYyMDQ2NTQ2NTFiZmI4OWFhZTZkNzdmY2FkNjQ=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-04-01T15:11:05Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-04-01T15:11:05Z"},"message":"OPENJPA-975. Committing changes provided by B.J. Reed\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@760912 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"e7a76a09e51e7f4d284fd0abe7fd680cb93139e8","url":"https://api.github.com/repos/apache/openjpa/git/trees/e7a76a09e51e7f4d284fd0abe7fd680cb93139e8"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/058836c6e474f204654651bfb89aae6d77fcad64","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/058836c6e474f204654651bfb89aae6d77fcad64","html_url":"https://github.com/apache/openjpa/commit/058836c6e474f204654651bfb89aae6d77fcad64","comments_url":"https://api.github.com/repos/apache/openjpa/commits/058836c6e474f204654651bfb89aae6d77fcad64/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"72f4ebcda0e2086c8699580100976a7f8a7d5f8a","url":"https://api.github.com/repos/apache/openjpa/commits/72f4ebcda0e2086c8699580100976a7f8a7d5f8a","html_url":"https://github.com/apache/openjpa/commit/72f4ebcda0e2086c8699580100976a7f8a7d5f8a"}]},{"sha":"2adb4f03d1f0e38b7b0cd020691a4510c3ec2c0c","node_id":"MDY6Q29tbWl0MjA2MzY0OjJhZGI0ZjAzZDFmMGUzOGI3YjBjZDAyMDY5MWE0NTEwYzNlYzJjMGM=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-04-02T19:24:01Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-04-02T19:24:01Z"},"message":"OPENJPA-975 clean up manual\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@761392 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"2f81f7f8f84bc5f5f7ef79bf180393098badcca9","url":"https://api.github.com/repos/apache/openjpa/git/trees/2f81f7f8f84bc5f5f7ef79bf180393098badcca9"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/2adb4f03d1f0e38b7b0cd020691a4510c3ec2c0c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/2adb4f03d1f0e38b7b0cd020691a4510c3ec2c0c","html_url":"https://github.com/apache/openjpa/commit/2adb4f03d1f0e38b7b0cd020691a4510c3ec2c0c","comments_url":"https://api.github.com/repos/apache/openjpa/commits/2adb4f03d1f0e38b7b0cd020691a4510c3ec2c0c/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"058836c6e474f204654651bfb89aae6d77fcad64","url":"https://api.github.com/repos/apache/openjpa/commits/058836c6e474f204654651bfb89aae6d77fcad64","html_url":"https://github.com/apache/openjpa/commit/058836c6e474f204654651bfb89aae6d77fcad64"}]},{"sha":"ca334ebb76e966848ff21a5279d5148e2018e0ee","node_id":"MDY6Q29tbWl0MjA2MzY0OmNhMzM0ZWJiNzZlOTY2ODQ4ZmYyMWE1Mjc5ZDUxNDhlMjAxOGUwZWU=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-04-07T12:36:38Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-04-07T12:36:38Z"},"message":"OPENJPA-1023\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@762747 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0b2f1cb3604c3af1d92f9dd80a8db0e8bf62d1e4","url":"https://api.github.com/repos/apache/openjpa/git/trees/0b2f1cb3604c3af1d92f9dd80a8db0e8bf62d1e4"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/ca334ebb76e966848ff21a5279d5148e2018e0ee","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/ca334ebb76e966848ff21a5279d5148e2018e0ee","html_url":"https://github.com/apache/openjpa/commit/ca334ebb76e966848ff21a5279d5148e2018e0ee","comments_url":"https://api.github.com/repos/apache/openjpa/commits/ca334ebb76e966848ff21a5279d5148e2018e0ee/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"2adb4f03d1f0e38b7b0cd020691a4510c3ec2c0c","url":"https://api.github.com/repos/apache/openjpa/commits/2adb4f03d1f0e38b7b0cd020691a4510c3ec2c0c","html_url":"https://github.com/apache/openjpa/commit/2adb4f03d1f0e38b7b0cd020691a4510c3ec2c0c"}]},{"sha":"552868ab955adc2a44c4b468184e1e7d7569cd58","node_id":"MDY6Q29tbWl0MjA2MzY0OjU1Mjg2OGFiOTU1YWRjMmE0NGM0YjQ2ODE4NGUxZTdkNzU2OWNkNTg=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-04-30T15:39:42Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-04-30T15:39:42Z"},"message":"OPENJPA-1025 Implementing subList in subclasses of AbstractResultList, based on patch provided by B.J. Reed\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@770291 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0e3fe2d9101205dd90ad2de959607d935161fb96","url":"https://api.github.com/repos/apache/openjpa/git/trees/0e3fe2d9101205dd90ad2de959607d935161fb96"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/552868ab955adc2a44c4b468184e1e7d7569cd58","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/552868ab955adc2a44c4b468184e1e7d7569cd58","html_url":"https://github.com/apache/openjpa/commit/552868ab955adc2a44c4b468184e1e7d7569cd58","comments_url":"https://api.github.com/repos/apache/openjpa/commits/552868ab955adc2a44c4b468184e1e7d7569cd58/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"ca334ebb76e966848ff21a5279d5148e2018e0ee","url":"https://api.github.com/repos/apache/openjpa/commits/ca334ebb76e966848ff21a5279d5148e2018e0ee","html_url":"https://github.com/apache/openjpa/commit/ca334ebb76e966848ff21a5279d5148e2018e0ee"}]},{"sha":"656ad7c9597449820b2b9ffe3f8b9bf1ad634113","node_id":"MDY6Q29tbWl0MjA2MzY0OjY1NmFkN2M5NTk3NDQ5ODIwYjJiOWZmZTNmOGI5YmYxYWQ2MzQxMTM=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-01T15:49:23Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-01T15:49:23Z"},"message":"OPENJPA-1045. L2 cache included / excluded types may be specified via configuration properties\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@770730 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b37e0d88cddbfec03621812291c765def708ed48","url":"https://api.github.com/repos/apache/openjpa/git/trees/b37e0d88cddbfec03621812291c765def708ed48"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/656ad7c9597449820b2b9ffe3f8b9bf1ad634113","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/656ad7c9597449820b2b9ffe3f8b9bf1ad634113","html_url":"https://github.com/apache/openjpa/commit/656ad7c9597449820b2b9ffe3f8b9bf1ad634113","comments_url":"https://api.github.com/repos/apache/openjpa/commits/656ad7c9597449820b2b9ffe3f8b9bf1ad634113/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"552868ab955adc2a44c4b468184e1e7d7569cd58","url":"https://api.github.com/repos/apache/openjpa/commits/552868ab955adc2a44c4b468184e1e7d7569cd58","html_url":"https://github.com/apache/openjpa/commit/552868ab955adc2a44c4b468184e1e7d7569cd58"}]},{"sha":"05c13cde979c0e3cbbf90ff6747a55ed125255f8","node_id":"MDY6Q29tbWl0MjA2MzY0OjA1YzEzY2RlOTc5YzBlM2NiYmY5MGZmNjc0N2E1NWVkMTI1MjU1Zjg=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-04T16:26:47Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-04T16:26:47Z"},"message":"OPENJPA-1045 remove system.out.format eyecatcher\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@771347 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"58857cde2d6e5a15c5929761d0f8ed5f885ea0e5","url":"https://api.github.com/repos/apache/openjpa/git/trees/58857cde2d6e5a15c5929761d0f8ed5f885ea0e5"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/05c13cde979c0e3cbbf90ff6747a55ed125255f8","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/05c13cde979c0e3cbbf90ff6747a55ed125255f8","html_url":"https://github.com/apache/openjpa/commit/05c13cde979c0e3cbbf90ff6747a55ed125255f8","comments_url":"https://api.github.com/repos/apache/openjpa/commits/05c13cde979c0e3cbbf90ff6747a55ed125255f8/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"656ad7c9597449820b2b9ffe3f8b9bf1ad634113","url":"https://api.github.com/repos/apache/openjpa/commits/656ad7c9597449820b2b9ffe3f8b9bf1ad634113","html_url":"https://github.com/apache/openjpa/commit/656ad7c9597449820b2b9ffe3f8b9bf1ad634113"}]},{"sha":"d048ae23179cc54c40cbd9997055538c43509f73","node_id":"MDY6Q29tbWl0MjA2MzY0OmQwNDhhZTIzMTc5Y2M1NGM0MGNiZDk5OTcwNTU1MzhjNDM1MDlmNzM=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-06T22:40:46Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-06T22:40:46Z"},"message":"OPENJPA-1067. Do not call setQueryTimeout for DB2 on Z/OS\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@772457 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6c1867d36bc9eafac2f2a42ce0523815a2d237ae","url":"https://api.github.com/repos/apache/openjpa/git/trees/6c1867d36bc9eafac2f2a42ce0523815a2d237ae"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/d048ae23179cc54c40cbd9997055538c43509f73","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/d048ae23179cc54c40cbd9997055538c43509f73","html_url":"https://github.com/apache/openjpa/commit/d048ae23179cc54c40cbd9997055538c43509f73","comments_url":"https://api.github.com/repos/apache/openjpa/commits/d048ae23179cc54c40cbd9997055538c43509f73/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"05c13cde979c0e3cbbf90ff6747a55ed125255f8","url":"https://api.github.com/repos/apache/openjpa/commits/05c13cde979c0e3cbbf90ff6747a55ed125255f8","html_url":"https://github.com/apache/openjpa/commit/05c13cde979c0e3cbbf90ff6747a55ed125255f8"}]},{"sha":"584420e2273d5e2cbaf041e192cd1c849cf8ff49","node_id":"MDY6Q29tbWl0MjA2MzY0OjU4NDQyMGUyMjczZDVlMmNiYWYwNDFlMTkyY2QxYzg0OWNmOGZmNDk=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-11T17:57:11Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-11T17:57:11Z"},"message":"OPENJPA-1071. Set derby deadlockTimeout and waitTimeout\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@773630 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4b559a9c780511661cbf62633b2cbc211770482d","url":"https://api.github.com/repos/apache/openjpa/git/trees/4b559a9c780511661cbf62633b2cbc211770482d"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/584420e2273d5e2cbaf041e192cd1c849cf8ff49","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/584420e2273d5e2cbaf041e192cd1c849cf8ff49","html_url":"https://github.com/apache/openjpa/commit/584420e2273d5e2cbaf041e192cd1c849cf8ff49","comments_url":"https://api.github.com/repos/apache/openjpa/commits/584420e2273d5e2cbaf041e192cd1c849cf8ff49/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"d048ae23179cc54c40cbd9997055538c43509f73","url":"https://api.github.com/repos/apache/openjpa/commits/d048ae23179cc54c40cbd9997055538c43509f73","html_url":"https://github.com/apache/openjpa/commit/d048ae23179cc54c40cbd9997055538c43509f73"}]},{"sha":"95ad3cdb48adc57f13c68d8ff695acd8e61ec85a","node_id":"MDY6Q29tbWl0MjA2MzY0Ojk1YWQzY2RiNDhhZGM1N2YxM2M2OGQ4ZmY2OTVhY2Q4ZTYxZWM4NWE=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-19T19:20:11Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-19T19:20:11Z"},"message":"OPENJPA-975 committing patch from B.J. Reed\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@776422 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0c1b9f43883f27cc30e40c836a59879c3556182d","url":"https://api.github.com/repos/apache/openjpa/git/trees/0c1b9f43883f27cc30e40c836a59879c3556182d"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/95ad3cdb48adc57f13c68d8ff695acd8e61ec85a","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/95ad3cdb48adc57f13c68d8ff695acd8e61ec85a","html_url":"https://github.com/apache/openjpa/commit/95ad3cdb48adc57f13c68d8ff695acd8e61ec85a","comments_url":"https://api.github.com/repos/apache/openjpa/commits/95ad3cdb48adc57f13c68d8ff695acd8e61ec85a/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"584420e2273d5e2cbaf041e192cd1c849cf8ff49","url":"https://api.github.com/repos/apache/openjpa/commits/584420e2273d5e2cbaf041e192cd1c849cf8ff49","html_url":"https://github.com/apache/openjpa/commit/584420e2273d5e2cbaf041e192cd1c849cf8ff49"}]},{"sha":"a2eadade978c1904db78c1632c2fc91c368a94df","node_id":"MDY6Q29tbWl0MjA2MzY0OmEyZWFkYWRlOTc4YzE5MDRkYjc4YzE2MzJjMmZjOTFjMzY4YTk0ZGY=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-19T21:23:50Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-19T21:23:50Z"},"message":"OPENJPA-1067. Restoring original behavior pending JDBC spec interpretation with DB2.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@776467 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6be96d4e52f99a82006700822529156ab87ff734","url":"https://api.github.com/repos/apache/openjpa/git/trees/6be96d4e52f99a82006700822529156ab87ff734"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/a2eadade978c1904db78c1632c2fc91c368a94df","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/a2eadade978c1904db78c1632c2fc91c368a94df","html_url":"https://github.com/apache/openjpa/commit/a2eadade978c1904db78c1632c2fc91c368a94df","comments_url":"https://api.github.com/repos/apache/openjpa/commits/a2eadade978c1904db78c1632c2fc91c368a94df/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"95ad3cdb48adc57f13c68d8ff695acd8e61ec85a","url":"https://api.github.com/repos/apache/openjpa/commits/95ad3cdb48adc57f13c68d8ff695acd8e61ec85a","html_url":"https://github.com/apache/openjpa/commit/95ad3cdb48adc57f13c68d8ff695acd8e61ec85a"}]},{"sha":"a545b73d0cd6faaa54cee7dc11eefbaa08306899","node_id":"MDY6Q29tbWl0MjA2MzY0OmE1NDViNzNkMGNkNmZhYWE1NGNlZTdkYzExZWVmYmFhMDgzMDY4OTk=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-26T19:11:36Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-26T19:11:36Z"},"message":"OPENJPA-1067. Merely log SQLException from setQueryTimeout for DB2 on Z/OS\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@778850 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0278e2cb02344dac8a6d1d55abcccd6d0ca19b40","url":"https://api.github.com/repos/apache/openjpa/git/trees/0278e2cb02344dac8a6d1d55abcccd6d0ca19b40"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/a545b73d0cd6faaa54cee7dc11eefbaa08306899","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/a545b73d0cd6faaa54cee7dc11eefbaa08306899","html_url":"https://github.com/apache/openjpa/commit/a545b73d0cd6faaa54cee7dc11eefbaa08306899","comments_url":"https://api.github.com/repos/apache/openjpa/commits/a545b73d0cd6faaa54cee7dc11eefbaa08306899/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"a2eadade978c1904db78c1632c2fc91c368a94df","url":"https://api.github.com/repos/apache/openjpa/commits/a2eadade978c1904db78c1632c2fc91c368a94df","html_url":"https://github.com/apache/openjpa/commit/a2eadade978c1904db78c1632c2fc91c368a94df"}]},{"sha":"48c988cfefee62d3913322a6cd749d0f4bcf851e","node_id":"MDY6Q29tbWl0MjA2MzY0OjQ4Yzk4OGNmZWZlZTYyZDM5MTMzMjJhNmNkNzQ5ZDBmNGJjZjg1MWU=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-26T21:49:16Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-26T21:49:16Z"},"message":"OPENJPA-1067. Merely log SQLException from setQueryTimeout for DB2 on Z/OS\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@778902 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"72fa7f33a7decc4f81b0403e9b5fc658057a1117","url":"https://api.github.com/repos/apache/openjpa/git/trees/72fa7f33a7decc4f81b0403e9b5fc658057a1117"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/48c988cfefee62d3913322a6cd749d0f4bcf851e","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/48c988cfefee62d3913322a6cd749d0f4bcf851e","html_url":"https://github.com/apache/openjpa/commit/48c988cfefee62d3913322a6cd749d0f4bcf851e","comments_url":"https://api.github.com/repos/apache/openjpa/commits/48c988cfefee62d3913322a6cd749d0f4bcf851e/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"a545b73d0cd6faaa54cee7dc11eefbaa08306899","url":"https://api.github.com/repos/apache/openjpa/commits/a545b73d0cd6faaa54cee7dc11eefbaa08306899","html_url":"https://github.com/apache/openjpa/commit/a545b73d0cd6faaa54cee7dc11eefbaa08306899"}]},{"sha":"3bfc93d1529efa1f429dc9a9a0aff273b66ae83f","node_id":"MDY6Q29tbWl0MjA2MzY0OjNiZmM5M2QxNTI5ZWZhMWY0MjlkYzlhOWEwYWZmMjczYjY2YWU4M2Y=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-27T03:04:40Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-05-27T03:04:40Z"},"message":"OPENJPA-1092. Enable testcase\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@778978 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"88c474abaa5c6065304a66f0d3e8994d8e873e08","url":"https://api.github.com/repos/apache/openjpa/git/trees/88c474abaa5c6065304a66f0d3e8994d8e873e08"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/3bfc93d1529efa1f429dc9a9a0aff273b66ae83f","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/3bfc93d1529efa1f429dc9a9a0aff273b66ae83f","html_url":"https://github.com/apache/openjpa/commit/3bfc93d1529efa1f429dc9a9a0aff273b66ae83f","comments_url":"https://api.github.com/repos/apache/openjpa/commits/3bfc93d1529efa1f429dc9a9a0aff273b66ae83f/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"48c988cfefee62d3913322a6cd749d0f4bcf851e","url":"https://api.github.com/repos/apache/openjpa/commits/48c988cfefee62d3913322a6cd749d0f4bcf851e","html_url":"https://github.com/apache/openjpa/commit/48c988cfefee62d3913322a6cd749d0f4bcf851e"}]},{"sha":"f16d420ddc04bd41926fcabfa3a86b02b2bf63dd","node_id":"MDY6Q29tbWl0MjA2MzY0OmYxNmQ0MjBkZGMwNGJkNDE5MjZmY2FiZmEzYTg2YjAyYjJiZjYzZGQ=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-06-11T21:12:38Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-06-11T21:12:38Z"},"message":"Adding .gitignore for git users.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@783909 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"dfaf3441a2d386b0a8cfb9bc0aa3ce8d6902d14f","url":"https://api.github.com/repos/apache/openjpa/git/trees/dfaf3441a2d386b0a8cfb9bc0aa3ce8d6902d14f"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/f16d420ddc04bd41926fcabfa3a86b02b2bf63dd","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/f16d420ddc04bd41926fcabfa3a86b02b2bf63dd","html_url":"https://github.com/apache/openjpa/commit/f16d420ddc04bd41926fcabfa3a86b02b2bf63dd","comments_url":"https://api.github.com/repos/apache/openjpa/commits/f16d420ddc04bd41926fcabfa3a86b02b2bf63dd/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"3bfc93d1529efa1f429dc9a9a0aff273b66ae83f","url":"https://api.github.com/repos/apache/openjpa/commits/3bfc93d1529efa1f429dc9a9a0aff273b66ae83f","html_url":"https://github.com/apache/openjpa/commit/3bfc93d1529efa1f429dc9a9a0aff273b66ae83f"}]},{"sha":"b59ec01682a937aebc60d793425b9b19482f6c26","node_id":"MDY6Q29tbWl0MjA2MzY0OmI1OWVjMDE2ODJhOTM3YWViYzYwZDc5MzQyNWI5YjE5NDgyZjZjMjY=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-06-11T21:20:52Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-06-11T21:20:52Z"},"message":"OPENJPA-1136 adding eolstyle for .gitignore\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@783915 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"dfaf3441a2d386b0a8cfb9bc0aa3ce8d6902d14f","url":"https://api.github.com/repos/apache/openjpa/git/trees/dfaf3441a2d386b0a8cfb9bc0aa3ce8d6902d14f"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/b59ec01682a937aebc60d793425b9b19482f6c26","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/b59ec01682a937aebc60d793425b9b19482f6c26","html_url":"https://github.com/apache/openjpa/commit/b59ec01682a937aebc60d793425b9b19482f6c26","comments_url":"https://api.github.com/repos/apache/openjpa/commits/b59ec01682a937aebc60d793425b9b19482f6c26/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"f16d420ddc04bd41926fcabfa3a86b02b2bf63dd","url":"https://api.github.com/repos/apache/openjpa/commits/f16d420ddc04bd41926fcabfa3a86b02b2bf63dd","html_url":"https://github.com/apache/openjpa/commit/f16d420ddc04bd41926fcabfa3a86b02b2bf63dd"}]},{"sha":"355f338e2c49f675c4dafe00cf19b1954112b246","node_id":"MDY6Q29tbWl0MjA2MzY0OjM1NWYzMzhlMmM0OWY2NzVjNGRhZmUwMGNmMTliMTk1NDExMmIyNDY=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-06-22T18:03:55Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-06-22T18:03:55Z"},"message":"OPENJPA-873 committing patch from Jody Grassel based on Fay's changes for trunk & 1.3.x\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@787335 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"924138c38090db4689cc282da93d93f8dd2918fc","url":"https://api.github.com/repos/apache/openjpa/git/trees/924138c38090db4689cc282da93d93f8dd2918fc"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/355f338e2c49f675c4dafe00cf19b1954112b246","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/355f338e2c49f675c4dafe00cf19b1954112b246","html_url":"https://github.com/apache/openjpa/commit/355f338e2c49f675c4dafe00cf19b1954112b246","comments_url":"https://api.github.com/repos/apache/openjpa/commits/355f338e2c49f675c4dafe00cf19b1954112b246/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"b59ec01682a937aebc60d793425b9b19482f6c26","url":"https://api.github.com/repos/apache/openjpa/commits/b59ec01682a937aebc60d793425b9b19482f6c26","html_url":"https://github.com/apache/openjpa/commit/b59ec01682a937aebc60d793425b9b19482f6c26"}]},{"sha":"f7463a50bf23090222878e01dd075d2a17055552","node_id":"MDY6Q29tbWl0MjA2MzY0OmY3NDYzYTUwYmYyMzA5MDIyMjg3OGUwMWRkMDc1ZDJhMTcwNTU1NTI=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-06-30T01:15:19Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-06-30T01:15:19Z"},"message":"OPENJPA-1061 committing patch from Jody Grassel.\n\tmodified:   openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java\n\tmodified:   openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestInheritanceWithMSCID.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/TestMappedSuperclass.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/EntityMapping.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/PrimitiveIDMappedSuperclass.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/chardiscriminator/PIdJTCDMSCEntityB.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/chardiscriminator/PIdJTCDMSCEntityD.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/chardiscriminator/PIdJTCDMSCLeafA.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/chardiscriminator/PIdJTCDMSCLeafB1.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/chardiscriminator/PIdJTCDMSCLeafB2.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/chardiscriminator/PIdJTCDMSCLeafC.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/chardiscriminator/PIdJTCDMSCLeafD1.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/chardiscriminator/PIdJTCDMSCLeafD2.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/chardiscriminator/PIdJTCDMSCMappedSuperclass.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/chardiscriminator/PIdJTCDMSCRootEntity.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/intdiscriminator/PIdJTIDMSCEntityB.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/intdiscriminator/PIdJTIDMSCEntityD.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/intdiscriminator/PIdJTIDMSCLeafA.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/intdiscriminator/PIdJTIDMSCLeafB1.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/intdiscriminator/PIdJTIDMSCLeafB2.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/intdiscriminator/PIdJTIDMSCLeafC.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/intdiscriminator/PIdJTIDMSCLeafD1.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/intdiscriminator/PIdJTIDMSCLeafD2.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/intdiscriminator/PIdJTIDMSCMappedSuperclass.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/intdiscriminator/PIdJTIDMSCRootEntity.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/stringdiscriminator/PIdJTSDMSCEntityB.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/stringdiscriminator/PIdJTSDMSCEntityD.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/stringdiscriminator/PIdJTSDMSCLeafA.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/stringdiscriminator/PIdJTSDMSCLeafB1.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/stringdiscriminator/PIdJTSDMSCLeafB2.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/stringdiscriminator/PIdJTSDMSCLeafC.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/stringdiscriminator/PIdJTSDMSCLeafD1.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/stringdiscriminator/PIdJTSDMSCLeafD2.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/stringdiscriminator/PIdJTSDMSCMappedSuperclass.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/jointable/stringdiscriminator/PIdJTSDMSCRootEntity.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/chardiscriminator/PIdSTCDMSCEntityB.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/chardiscriminator/PIdSTCDMSCEntityD.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/chardiscriminator/PIdSTCDMSCLeafA.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/chardiscriminator/PIdSTCDMSCLeafB1.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/chardiscriminator/PIdSTCDMSCLeafB2.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/chardiscriminator/PIdSTCDMSCLeafC.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/chardiscriminator/PIdSTCDMSCLeafD1.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/chardiscriminator/PIdSTCDMSCLeafD2.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/chardiscriminator/PIdSTCDMSCMappedSuperclass.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/chardiscriminator/PIdSTCDMSCRootEntity.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/intdiscriminator/PIdSTIDMSCEntityB.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/intdiscriminator/PIdSTIDMSCEntityD.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/intdiscriminator/PIdSTIDMSCLeafA.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/intdiscriminator/PIdSTIDMSCLeafB1.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/intdiscriminator/PIdSTIDMSCLeafB2.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/intdiscriminator/PIdSTIDMSCLeafC.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/intdiscriminator/PIdSTIDMSCLeafD1.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/intdiscriminator/PIdSTIDMSCLeafD2.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/intdiscriminator/PIdSTIDMSCMappedSuperclass.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/intdiscriminator/PIdSTIDMSCRootEntity.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/stringdiscriminator/PIdSTSDMSCEntityB.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/stringdiscriminator/PIdSTSDMSCEntityD.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/stringdiscriminator/PIdSTSDMSCLeafA.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/stringdiscriminator/PIdSTSDMSCLeafB1.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/stringdiscriminator/PIdSTSDMSCLeafB2.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/stringdiscriminator/PIdSTSDMSCLeafC.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/stringdiscriminator/PIdSTSDMSCLeafD1.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/stringdiscriminator/PIdSTSDMSCLeafD2.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/stringdiscriminator/PIdSTSDMSCMappedSuperclass.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/idmsc/primitiveidentity/singletable/stringdiscriminator/PIdSTSDMSCRootEntity.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/EntityB.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/EntityD.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafA.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafB1.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafB2.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafC.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafD1.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/LeafD2.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/MSC.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/inheritance/entities/testinterfaces/RootEntity.java\n\tmodified:   openjpa-persistence/src/main/java/org/apache/openjpa/persistence/AnnotationPersistenceMetaDataParser.java\n\tmodified:   openjpa-persistence/src/main/java/org/apache/openjpa/persistence/XMLPersistenceMetaDataParser.java\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@789524 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0313b0fddb8d41f3bcecc1eaf5ada9a64373a859","url":"https://api.github.com/repos/apache/openjpa/git/trees/0313b0fddb8d41f3bcecc1eaf5ada9a64373a859"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/f7463a50bf23090222878e01dd075d2a17055552","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/f7463a50bf23090222878e01dd075d2a17055552","html_url":"https://github.com/apache/openjpa/commit/f7463a50bf23090222878e01dd075d2a17055552","comments_url":"https://api.github.com/repos/apache/openjpa/commits/f7463a50bf23090222878e01dd075d2a17055552/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"355f338e2c49f675c4dafe00cf19b1954112b246","url":"https://api.github.com/repos/apache/openjpa/commits/355f338e2c49f675c4dafe00cf19b1954112b246","html_url":"https://github.com/apache/openjpa/commit/355f338e2c49f675c4dafe00cf19b1954112b246"}]},{"sha":"7dfcead7d49e2ce2e23d301ec09dfa9f77c6da0b","node_id":"MDY6Q29tbWl0MjA2MzY0OjdkZmNlYWQ3ZDQ5ZTJjZTJlMjNkMzAxZWMwOWRmYTlmNzdjNmRhMGI=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-06-30T01:16:36Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-06-30T01:16:36Z"},"message":"OPENJPA-1061. Setting eol-style (skipped by git)\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@789525 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0313b0fddb8d41f3bcecc1eaf5ada9a64373a859","url":"https://api.github.com/repos/apache/openjpa/git/trees/0313b0fddb8d41f3bcecc1eaf5ada9a64373a859"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/7dfcead7d49e2ce2e23d301ec09dfa9f77c6da0b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/7dfcead7d49e2ce2e23d301ec09dfa9f77c6da0b","html_url":"https://github.com/apache/openjpa/commit/7dfcead7d49e2ce2e23d301ec09dfa9f77c6da0b","comments_url":"https://api.github.com/repos/apache/openjpa/commits/7dfcead7d49e2ce2e23d301ec09dfa9f77c6da0b/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"f7463a50bf23090222878e01dd075d2a17055552","url":"https://api.github.com/repos/apache/openjpa/commits/f7463a50bf23090222878e01dd075d2a17055552","html_url":"https://github.com/apache/openjpa/commit/f7463a50bf23090222878e01dd075d2a17055552"}]},{"sha":"4b6c0c99f462fddcb83df044aceff2f2ee51a08c","node_id":"MDY6Q29tbWl0MjA2MzY0OjRiNmMwYzk5ZjQ2MmZkZGNiODNkZjA0NGFjZWZmMmYyZWU1MWEwOGM=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-07-06T22:53:46Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-07-06T22:53:46Z"},"message":"OPENJPA-1156. Refactoring test code from OPENJPA-1061 to avoid path length problems in some environments. Specifically I've removed the primitiveidentity component of the package since it was not adding any semantic meaning to the tests. Further refactoring may be needed, but this should prevent the specific problem that was reported.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@791644 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"d3171ec31fd5a264559ba2af8851d0774c842dac","url":"https://api.github.com/repos/apache/openjpa/git/trees/d3171ec31fd5a264559ba2af8851d0774c842dac"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/4b6c0c99f462fddcb83df044aceff2f2ee51a08c","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/4b6c0c99f462fddcb83df044aceff2f2ee51a08c","html_url":"https://github.com/apache/openjpa/commit/4b6c0c99f462fddcb83df044aceff2f2ee51a08c","comments_url":"https://api.github.com/repos/apache/openjpa/commits/4b6c0c99f462fddcb83df044aceff2f2ee51a08c/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"7dfcead7d49e2ce2e23d301ec09dfa9f77c6da0b","url":"https://api.github.com/repos/apache/openjpa/commits/7dfcead7d49e2ce2e23d301ec09dfa9f77c6da0b","html_url":"https://github.com/apache/openjpa/commit/7dfcead7d49e2ce2e23d301ec09dfa9f77c6da0b"}]},{"sha":"4d687228b515cb4371d11860c9e02b374eb0e8e5","node_id":"MDY6Q29tbWl0MjA2MzY0OjRkNjg3MjI4YjUxNWNiNDM3MWQxMTg2MGM5ZTAyYjM3NGViMGU4ZTU=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-07-08T17:47:24Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-07-08T17:47:24Z"},"message":"OPENJPA-1029:\nUpdate SQLServerDictionary to handle Microsoft JDBC Driver.\nMerging changes made to trunk in revision 765841.\nSubmitted By: Donald Woods\n\n\n\tmodified:   openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@792241 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"280a351ea0db20a1231320e8e0ad47a443e5723c","url":"https://api.github.com/repos/apache/openjpa/git/trees/280a351ea0db20a1231320e8e0ad47a443e5723c"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/4d687228b515cb4371d11860c9e02b374eb0e8e5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/4d687228b515cb4371d11860c9e02b374eb0e8e5","html_url":"https://github.com/apache/openjpa/commit/4d687228b515cb4371d11860c9e02b374eb0e8e5","comments_url":"https://api.github.com/repos/apache/openjpa/commits/4d687228b515cb4371d11860c9e02b374eb0e8e5/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"4b6c0c99f462fddcb83df044aceff2f2ee51a08c","url":"https://api.github.com/repos/apache/openjpa/commits/4b6c0c99f462fddcb83df044aceff2f2ee51a08c","html_url":"https://github.com/apache/openjpa/commit/4b6c0c99f462fddcb83df044aceff2f2ee51a08c"}]},{"sha":"aba32ee812acbf8be51a574fd89fbfbfdbf7748b","node_id":"MDY6Q29tbWl0MjA2MzY0OmFiYTMyZWU4MTJhY2JmOGJlNTFhNTc0ZmQ4OWZiZmJmZGJmNzc0OGI=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-07-10T02:44:49Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-07-10T02:44:49Z"},"message":"OPENJPA-732:\nPrevent duplicate events from being fired (stored in Sets instead of Lists)\nChanges originally made by Albert Lee were merged to 1.2.x.\nSubmitted by: B. J. Reed.\n\tmodified:   openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/Message.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/MessageListenerImpl.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/callbacks/TestMessageListeners.java\n\tmodified:   openjpa-persistence-jdbc/src/test/resources/META-INF/listener-orm.xml\n\tmodified:   openjpa-persistence-jdbc/src/test/resources/META-INF/persistence.xml\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@792787 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"0b86d514708134a51ef57561bc4688858361f333","url":"https://api.github.com/repos/apache/openjpa/git/trees/0b86d514708134a51ef57561bc4688858361f333"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/aba32ee812acbf8be51a574fd89fbfbfdbf7748b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/aba32ee812acbf8be51a574fd89fbfbfdbf7748b","html_url":"https://github.com/apache/openjpa/commit/aba32ee812acbf8be51a574fd89fbfbfdbf7748b","comments_url":"https://api.github.com/repos/apache/openjpa/commits/aba32ee812acbf8be51a574fd89fbfbfdbf7748b/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"4d687228b515cb4371d11860c9e02b374eb0e8e5","url":"https://api.github.com/repos/apache/openjpa/commits/4d687228b515cb4371d11860c9e02b374eb0e8e5","html_url":"https://github.com/apache/openjpa/commit/4d687228b515cb4371d11860c9e02b374eb0e8e5"}]},{"sha":"a73ef8bcd6edc205998cc2fcc0bc8f65d2273594","node_id":"MDY6Q29tbWl0MjA2MzY0OmE3M2VmOGJjZDZlZGMyMDU5OThjYzJmY2MwYmM4ZjY1ZDIyNzM1OTQ=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-07-27T15:52:26Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-07-27T15:52:26Z"},"message":"OPENJPA-1197:\nUpgrade test profile to use MySQL JDBC driver v 5.1.6.\nResolves problems executing native queries.\n\tmodified:   openjpa-persistence-jdbc/pom.xml\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@798195 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"842e01c567a1ca74ea4c00f957774dabe5463494","url":"https://api.github.com/repos/apache/openjpa/git/trees/842e01c567a1ca74ea4c00f957774dabe5463494"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/a73ef8bcd6edc205998cc2fcc0bc8f65d2273594","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/a73ef8bcd6edc205998cc2fcc0bc8f65d2273594","html_url":"https://github.com/apache/openjpa/commit/a73ef8bcd6edc205998cc2fcc0bc8f65d2273594","comments_url":"https://api.github.com/repos/apache/openjpa/commits/a73ef8bcd6edc205998cc2fcc0bc8f65d2273594/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"aba32ee812acbf8be51a574fd89fbfbfdbf7748b","url":"https://api.github.com/repos/apache/openjpa/commits/aba32ee812acbf8be51a574fd89fbfbfdbf7748b","html_url":"https://github.com/apache/openjpa/commit/aba32ee812acbf8be51a574fd89fbfbfdbf7748b"}]},{"sha":"31e89d7abac95ece5d737250c785fcae095e5710","node_id":"MDY6Q29tbWl0MjA2MzY0OjMxZTg5ZDdhYmFjOTVlY2U1ZDczNzI1MGM3ODVmY2FlMDk1ZTU3MTA=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-07-27T21:37:31Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-07-27T21:37:31Z"},"message":"OPENJPA-991: Disabling unreliable testcase in 1.2.x\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@798295 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"1f4aba4fe4ef0afb17e0525d194eb6a8258469af","url":"https://api.github.com/repos/apache/openjpa/git/trees/1f4aba4fe4ef0afb17e0525d194eb6a8258469af"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/31e89d7abac95ece5d737250c785fcae095e5710","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/31e89d7abac95ece5d737250c785fcae095e5710","html_url":"https://github.com/apache/openjpa/commit/31e89d7abac95ece5d737250c785fcae095e5710","comments_url":"https://api.github.com/repos/apache/openjpa/commits/31e89d7abac95ece5d737250c785fcae095e5710/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"a73ef8bcd6edc205998cc2fcc0bc8f65d2273594","url":"https://api.github.com/repos/apache/openjpa/commits/a73ef8bcd6edc205998cc2fcc0bc8f65d2273594","html_url":"https://github.com/apache/openjpa/commit/a73ef8bcd6edc205998cc2fcc0bc8f65d2273594"}]},{"sha":"0b5fc5f4b03cdeb4d881e7f838dbf6a5fbad2849","node_id":"MDY6Q29tbWl0MjA2MzY0OjBiNWZjNWY0YjAzY2RlYjRkODgxZTdmODM4ZGJmNmE1ZmJhZDI4NDk=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-07-30T18:00:09Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-07-30T18:00:09Z"},"message":"OPENJPA-1210:\nAdd properties for derby timeouts to pom.xml.\n\tmodified:   openjpa-persistence-jdbc/pom.xml\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@799385 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"10e25a8be3668fcb0c3c536027f809c872fc945a","url":"https://api.github.com/repos/apache/openjpa/git/trees/10e25a8be3668fcb0c3c536027f809c872fc945a"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/0b5fc5f4b03cdeb4d881e7f838dbf6a5fbad2849","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/0b5fc5f4b03cdeb4d881e7f838dbf6a5fbad2849","html_url":"https://github.com/apache/openjpa/commit/0b5fc5f4b03cdeb4d881e7f838dbf6a5fbad2849","comments_url":"https://api.github.com/repos/apache/openjpa/commits/0b5fc5f4b03cdeb4d881e7f838dbf6a5fbad2849/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"31e89d7abac95ece5d737250c785fcae095e5710","url":"https://api.github.com/repos/apache/openjpa/commits/31e89d7abac95ece5d737250c785fcae095e5710","html_url":"https://github.com/apache/openjpa/commit/31e89d7abac95ece5d737250c785fcae095e5710"}]},{"sha":"402d93a4d777df3304d0c9be93cd9c133e32f1eb","node_id":"MDY6Q29tbWl0MjA2MzY0OjQwMmQ5M2E0ZDc3N2RmMzMwNGQwYzliZTkzY2Q5YzEzM2UzMmYxZWI=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-08-28T20:21:06Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-08-28T20:21:06Z"},"message":"OPENJPA-466:\nSynchronize call to obtain next sequence value.\nSubmitted By: B.J. Reed, original changes by Tim McConnell\n\tmodified:   openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.java\n\tmodified:   openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/sequence/EntityEmployee.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/sequence/EntityPerson.java\n\tnew file:   openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/sequence/TestSequence.java\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@809017 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"6119604d224daaafc346a469998c1df350b40938","url":"https://api.github.com/repos/apache/openjpa/git/trees/6119604d224daaafc346a469998c1df350b40938"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/402d93a4d777df3304d0c9be93cd9c133e32f1eb","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/402d93a4d777df3304d0c9be93cd9c133e32f1eb","html_url":"https://github.com/apache/openjpa/commit/402d93a4d777df3304d0c9be93cd9c133e32f1eb","comments_url":"https://api.github.com/repos/apache/openjpa/commits/402d93a4d777df3304d0c9be93cd9c133e32f1eb/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"0b5fc5f4b03cdeb4d881e7f838dbf6a5fbad2849","url":"https://api.github.com/repos/apache/openjpa/commits/0b5fc5f4b03cdeb4d881e7f838dbf6a5fbad2849","html_url":"https://github.com/apache/openjpa/commit/0b5fc5f4b03cdeb4d881e7f838dbf6a5fbad2849"}]},{"sha":"dae276b033f79f5c4f914da4258a32daf8ecf38b","node_id":"MDY6Q29tbWl0MjA2MzY0OmRhZTI3NmIwMzNmNzlmNWM0ZjkxNGRhNDI1OGEzMmRhZjhlY2YzOGI=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-10-03T23:40:26Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-10-03T23:40:26Z"},"message":"OPENJPA-1328:\nCheck cacheabiity in ClassMetaData instead of AbstractDataCache.\nSubmitted By: Jody Grassel\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@821449 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"55babdaeb9880e0adedac47064e50052b085242d","url":"https://api.github.com/repos/apache/openjpa/git/trees/55babdaeb9880e0adedac47064e50052b085242d"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/dae276b033f79f5c4f914da4258a32daf8ecf38b","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/dae276b033f79f5c4f914da4258a32daf8ecf38b","html_url":"https://github.com/apache/openjpa/commit/dae276b033f79f5c4f914da4258a32daf8ecf38b","comments_url":"https://api.github.com/repos/apache/openjpa/commits/dae276b033f79f5c4f914da4258a32daf8ecf38b/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"402d93a4d777df3304d0c9be93cd9c133e32f1eb","url":"https://api.github.com/repos/apache/openjpa/commits/402d93a4d777df3304d0c9be93cd9c133e32f1eb","html_url":"https://github.com/apache/openjpa/commit/402d93a4d777df3304d0c9be93cd9c133e32f1eb"}]},{"sha":"83ffa271068e4cb48eb10e20ae1825f548abe1fe","node_id":"MDY6Q29tbWl0MjA2MzY0OjgzZmZhMjcxMDY4ZTRjYjQ4ZWIxMGUyMGFlMTgyNWY1NDhhYmUxZmU=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-10-21T18:35:27Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-10-21T18:35:27Z"},"message":"OPENJPA-1308:\nRemove extraneous cast of VARCHAR to VARCHAR for DB2.\nSubmitted By: B.J. Reed\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@828135 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"2ff7ddb45771f592a01b6aef2ac1f97188036302","url":"https://api.github.com/repos/apache/openjpa/git/trees/2ff7ddb45771f592a01b6aef2ac1f97188036302"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/83ffa271068e4cb48eb10e20ae1825f548abe1fe","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/83ffa271068e4cb48eb10e20ae1825f548abe1fe","html_url":"https://github.com/apache/openjpa/commit/83ffa271068e4cb48eb10e20ae1825f548abe1fe","comments_url":"https://api.github.com/repos/apache/openjpa/commits/83ffa271068e4cb48eb10e20ae1825f548abe1fe/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"dae276b033f79f5c4f914da4258a32daf8ecf38b","url":"https://api.github.com/repos/apache/openjpa/commits/dae276b033f79f5c4f914da4258a32daf8ecf38b","html_url":"https://github.com/apache/openjpa/commit/dae276b033f79f5c4f914da4258a32daf8ecf38b"}]},{"sha":"23ba9e0c63f0beff3fc71308bd8f2c541e644ab5","node_id":"MDY6Q29tbWl0MjA2MzY0OjIzYmE5ZTBjNjNmMGJlZmYzZmM3MTMwOGJkOGYyYzU0MWU2NDRhYjU=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-10-28T17:36:58Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-10-28T17:36:58Z"},"message":"OPENJPA-1141: \nOptionally reorder MetaData resolution for entities which use derived IDs\nSubmitted By: Jody Grassel\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@830694 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"9b72c5e45b683c0dc4eb5622a21a7c58f9e09b55","url":"https://api.github.com/repos/apache/openjpa/git/trees/9b72c5e45b683c0dc4eb5622a21a7c58f9e09b55"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/23ba9e0c63f0beff3fc71308bd8f2c541e644ab5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/23ba9e0c63f0beff3fc71308bd8f2c541e644ab5","html_url":"https://github.com/apache/openjpa/commit/23ba9e0c63f0beff3fc71308bd8f2c541e644ab5","comments_url":"https://api.github.com/repos/apache/openjpa/commits/23ba9e0c63f0beff3fc71308bd8f2c541e644ab5/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"83ffa271068e4cb48eb10e20ae1825f548abe1fe","url":"https://api.github.com/repos/apache/openjpa/commits/83ffa271068e4cb48eb10e20ae1825f548abe1fe","html_url":"https://github.com/apache/openjpa/commit/83ffa271068e4cb48eb10e20ae1825f548abe1fe"}]},{"sha":"87bf3e21c5b1ba0a020adfee29e1ceea030b9d68","node_id":"MDY6Q29tbWl0MjA2MzY0Ojg3YmYzZTIxYzViMWJhMGEwMjBhZGZlZTI5ZTFjZWVhMDMwYjlkNjg=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-11-17T23:09:42Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-11-17T23:09:42Z"},"message":"OPENJPA-1384:\nTry current classloader when loading DBDictionary.\nSubmitted By: B.J. Reed\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@881612 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"c4a0f99ae9eeb96894874485143313c0920eb59d","url":"https://api.github.com/repos/apache/openjpa/git/trees/c4a0f99ae9eeb96894874485143313c0920eb59d"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/87bf3e21c5b1ba0a020adfee29e1ceea030b9d68","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/87bf3e21c5b1ba0a020adfee29e1ceea030b9d68","html_url":"https://github.com/apache/openjpa/commit/87bf3e21c5b1ba0a020adfee29e1ceea030b9d68","comments_url":"https://api.github.com/repos/apache/openjpa/commits/87bf3e21c5b1ba0a020adfee29e1ceea030b9d68/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"23ba9e0c63f0beff3fc71308bd8f2c541e644ab5","url":"https://api.github.com/repos/apache/openjpa/commits/23ba9e0c63f0beff3fc71308bd8f2c541e644ab5","html_url":"https://github.com/apache/openjpa/commit/23ba9e0c63f0beff3fc71308bd8f2c541e644ab5"}]},{"sha":"127e14669806ab8f287a06eb6384d97d99f149b2","node_id":"MDY6Q29tbWl0MjA2MzY0OjEyN2UxNDY2OTgwNmFiOGYyODdhMDZlYjYzODRkOTdkOTlmMTQ5YjI=","commit":{"author":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T14:59:28Z"},"committer":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T14:59:28Z"},"message":"OPENJPA-1400: Fix PersistenceCapable.pcIsDetached() when using no statemanager and version is zero.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@888422 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"95c7bc550d8660fc7e3e5bfc6c3b459e7d31b47e","url":"https://api.github.com/repos/apache/openjpa/git/trees/95c7bc550d8660fc7e3e5bfc6c3b459e7d31b47e"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/127e14669806ab8f287a06eb6384d97d99f149b2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/127e14669806ab8f287a06eb6384d97d99f149b2","html_url":"https://github.com/apache/openjpa/commit/127e14669806ab8f287a06eb6384d97d99f149b2","comments_url":"https://api.github.com/repos/apache/openjpa/commits/127e14669806ab8f287a06eb6384d97d99f149b2/comments","author":null,"committer":null,"parents":[{"sha":"87bf3e21c5b1ba0a020adfee29e1ceea030b9d68","url":"https://api.github.com/repos/apache/openjpa/commits/87bf3e21c5b1ba0a020adfee29e1ceea030b9d68","html_url":"https://github.com/apache/openjpa/commit/87bf3e21c5b1ba0a020adfee29e1ceea030b9d68"}]},{"sha":"34543baadc29708822275065561baf395c08f3ca","node_id":"MDY6Q29tbWl0MjA2MzY0OjM0NTQzYmFhZGMyOTcwODgyMjI3NTA2NTU2MWJhZjM5NWMwOGYzY2E=","commit":{"author":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T15:15:37Z"},"committer":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T15:15:37Z"},"message":"OPENJPA-1171: Replace StringBuffer with StringBuilder in SQLBuffer to reduce synchronization. Original change by Mike Dick.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@888433 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"099328d21a774d7bbd3577ba68b37877d15487af","url":"https://api.github.com/repos/apache/openjpa/git/trees/099328d21a774d7bbd3577ba68b37877d15487af"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/34543baadc29708822275065561baf395c08f3ca","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/34543baadc29708822275065561baf395c08f3ca","html_url":"https://github.com/apache/openjpa/commit/34543baadc29708822275065561baf395c08f3ca","comments_url":"https://api.github.com/repos/apache/openjpa/commits/34543baadc29708822275065561baf395c08f3ca/comments","author":null,"committer":null,"parents":[{"sha":"127e14669806ab8f287a06eb6384d97d99f149b2","url":"https://api.github.com/repos/apache/openjpa/commits/127e14669806ab8f287a06eb6384d97d99f149b2","html_url":"https://github.com/apache/openjpa/commit/127e14669806ab8f287a06eb6384d97d99f149b2"}]},{"sha":"e5ddb3de5d61b297f0a2df09563cd6bac3f5ad55","node_id":"MDY6Q29tbWl0MjA2MzY0OmU1ZGRiM2RlNWQ2MWIyOTdmMGEyZGYwOTU2M2NkNmJhYzNmNWFkNTU=","commit":{"author":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T15:25:46Z"},"committer":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T15:25:46Z"},"message":"OPENJPA-1172: Use ConcurrentHashMap instead of synchronized HashMap in ClassMapping.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@888445 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"422f887f647161b329878e2770166b07200a056e","url":"https://api.github.com/repos/apache/openjpa/git/trees/422f887f647161b329878e2770166b07200a056e"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/e5ddb3de5d61b297f0a2df09563cd6bac3f5ad55","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/e5ddb3de5d61b297f0a2df09563cd6bac3f5ad55","html_url":"https://github.com/apache/openjpa/commit/e5ddb3de5d61b297f0a2df09563cd6bac3f5ad55","comments_url":"https://api.github.com/repos/apache/openjpa/commits/e5ddb3de5d61b297f0a2df09563cd6bac3f5ad55/comments","author":null,"committer":null,"parents":[{"sha":"34543baadc29708822275065561baf395c08f3ca","url":"https://api.github.com/repos/apache/openjpa/commits/34543baadc29708822275065561baf395c08f3ca","html_url":"https://github.com/apache/openjpa/commit/34543baadc29708822275065561baf395c08f3ca"}]},{"sha":"4bacdf4c3c01b0a391266e32ec41f1401ff332e4","node_id":"MDY6Q29tbWl0MjA2MzY0OjRiYWNkZjRjM2MwMWIwYTM5MTI2NmUzMmVjNDFmMTQwMWZmMzMyZTQ=","commit":{"author":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T15:48:31Z"},"committer":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T15:48:31Z"},"message":"OPENJPA-1415: Suppress batched OLE messages.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@888449 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"4d8857dd23a883ed51a9cdbeb2b7ab5da79c9122","url":"https://api.github.com/repos/apache/openjpa/git/trees/4d8857dd23a883ed51a9cdbeb2b7ab5da79c9122"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/4bacdf4c3c01b0a391266e32ec41f1401ff332e4","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/4bacdf4c3c01b0a391266e32ec41f1401ff332e4","html_url":"https://github.com/apache/openjpa/commit/4bacdf4c3c01b0a391266e32ec41f1401ff332e4","comments_url":"https://api.github.com/repos/apache/openjpa/commits/4bacdf4c3c01b0a391266e32ec41f1401ff332e4/comments","author":null,"committer":null,"parents":[{"sha":"e5ddb3de5d61b297f0a2df09563cd6bac3f5ad55","url":"https://api.github.com/repos/apache/openjpa/commits/e5ddb3de5d61b297f0a2df09563cd6bac3f5ad55","html_url":"https://github.com/apache/openjpa/commit/e5ddb3de5d61b297f0a2df09563cd6bac3f5ad55"}]},{"sha":"f2e51da5971b1840fd78cb9f8ef267f103dd64b7","node_id":"MDY6Q29tbWl0MjA2MzY0OmYyZTUxZGE1OTcxYjE4NDBmZDc4Y2I5ZjhlZjI2N2YxMDNkZDY0Yjc=","commit":{"author":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T16:20:55Z"},"committer":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T16:20:55Z"},"message":"OPENJPA-1414: Performance improvements for detach processing. Patch contributed by Dianne Richards.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@888463 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"bc95a72ad14dc57b3c8caeca8e3d46ed3f87fa5a","url":"https://api.github.com/repos/apache/openjpa/git/trees/bc95a72ad14dc57b3c8caeca8e3d46ed3f87fa5a"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/f2e51da5971b1840fd78cb9f8ef267f103dd64b7","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/f2e51da5971b1840fd78cb9f8ef267f103dd64b7","html_url":"https://github.com/apache/openjpa/commit/f2e51da5971b1840fd78cb9f8ef267f103dd64b7","comments_url":"https://api.github.com/repos/apache/openjpa/commits/f2e51da5971b1840fd78cb9f8ef267f103dd64b7/comments","author":null,"committer":null,"parents":[{"sha":"4bacdf4c3c01b0a391266e32ec41f1401ff332e4","url":"https://api.github.com/repos/apache/openjpa/commits/4bacdf4c3c01b0a391266e32ec41f1401ff332e4","html_url":"https://github.com/apache/openjpa/commit/4bacdf4c3c01b0a391266e32ec41f1401ff332e4"}]},{"sha":"eaf25282aa910886487e42e3b9c835bb461887f2","node_id":"MDY6Q29tbWl0MjA2MzY0OmVhZjI1MjgyYWE5MTA4ODY0ODdlNDJlM2I5YzgzNWJiNDYxODg3ZjI=","commit":{"author":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T18:46:40Z"},"committer":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T18:46:40Z"},"message":"OPENJPA-1421: Reduce lock contention in JDBCStoreManager\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@888513 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"b41ff773dd7db2e238ab51fc58486d48b60240a5","url":"https://api.github.com/repos/apache/openjpa/git/trees/b41ff773dd7db2e238ab51fc58486d48b60240a5"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/eaf25282aa910886487e42e3b9c835bb461887f2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/eaf25282aa910886487e42e3b9c835bb461887f2","html_url":"https://github.com/apache/openjpa/commit/eaf25282aa910886487e42e3b9c835bb461887f2","comments_url":"https://api.github.com/repos/apache/openjpa/commits/eaf25282aa910886487e42e3b9c835bb461887f2/comments","author":null,"committer":null,"parents":[{"sha":"f2e51da5971b1840fd78cb9f8ef267f103dd64b7","url":"https://api.github.com/repos/apache/openjpa/commits/f2e51da5971b1840fd78cb9f8ef267f103dd64b7","html_url":"https://github.com/apache/openjpa/commit/f2e51da5971b1840fd78cb9f8ef267f103dd64b7"}]},{"sha":"ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5","node_id":"MDY6Q29tbWl0MjA2MzY0OmVjOGViNTRhOGU3NWJiZjBiZTQ0M2JmYjk4MmUxYWRiMmU1YzMyYjU=","commit":{"author":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T21:51:26Z"},"committer":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2009-12-08T21:51:26Z"},"message":"OPENJPA-250: Committing to 1.2.x. Submitted by Patrick Linskey, Simon Droscher, and Rick Curtis.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@888586 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ea69906e7730ae0eddd004116042a6ad876014a6","url":"https://api.github.com/repos/apache/openjpa/git/trees/ea69906e7730ae0eddd004116042a6ad876014a6"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5","html_url":"https://github.com/apache/openjpa/commit/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5","comments_url":"https://api.github.com/repos/apache/openjpa/commits/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5/comments","author":null,"committer":null,"parents":[{"sha":"eaf25282aa910886487e42e3b9c835bb461887f2","url":"https://api.github.com/repos/apache/openjpa/commits/eaf25282aa910886487e42e3b9c835bb461887f2","html_url":"https://github.com/apache/openjpa/commit/eaf25282aa910886487e42e3b9c835bb461887f2"}]},{"sha":"762eb8e7198ca4c3e775f9f7aea5df549633da24","node_id":"MDY6Q29tbWl0MjA2MzY0Ojc2MmViOGU3MTk4Y2E0YzNlNzc1ZjlmN2FlYTVkZjU0OTYzM2RhMjQ=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-12-10T17:09:25Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-12-10T17:09:25Z"},"message":"Doc update for connectionRetainMode always\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@889338 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"2762e99dab67d71bcf640287c90b3ceb920da7ce","url":"https://api.github.com/repos/apache/openjpa/git/trees/2762e99dab67d71bcf640287c90b3ceb920da7ce"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/762eb8e7198ca4c3e775f9f7aea5df549633da24","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/762eb8e7198ca4c3e775f9f7aea5df549633da24","html_url":"https://github.com/apache/openjpa/commit/762eb8e7198ca4c3e775f9f7aea5df549633da24","comments_url":"https://api.github.com/repos/apache/openjpa/commits/762eb8e7198ca4c3e775f9f7aea5df549633da24/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5","url":"https://api.github.com/repos/apache/openjpa/commits/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5","html_url":"https://github.com/apache/openjpa/commit/ec8eb54a8e75bbf0be443bfb982e1adb2e5c32b5"}]},{"sha":"31401265e37721feed9624e1f7fadbaf838e9a5d","node_id":"MDY6Q29tbWl0MjA2MzY0OjMxNDAxMjY1ZTM3NzIxZmVlZDk2MjRlMWY3ZmFkYmFmODM4ZTlhNWQ=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-12-11T19:06:29Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-12-11T19:06:29Z"},"message":"OPENJPA-1326:\nSet schema names for Sybase when creating new indexes and primary keys\nSubmitted By : BJ Reed\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@889769 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"aa9e4653f80ade308d9c8c24feb00b5dab0a79a4","url":"https://api.github.com/repos/apache/openjpa/git/trees/aa9e4653f80ade308d9c8c24feb00b5dab0a79a4"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/31401265e37721feed9624e1f7fadbaf838e9a5d","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/31401265e37721feed9624e1f7fadbaf838e9a5d","html_url":"https://github.com/apache/openjpa/commit/31401265e37721feed9624e1f7fadbaf838e9a5d","comments_url":"https://api.github.com/repos/apache/openjpa/commits/31401265e37721feed9624e1f7fadbaf838e9a5d/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"762eb8e7198ca4c3e775f9f7aea5df549633da24","url":"https://api.github.com/repos/apache/openjpa/commits/762eb8e7198ca4c3e775f9f7aea5df549633da24","html_url":"https://github.com/apache/openjpa/commit/762eb8e7198ca4c3e775f9f7aea5df549633da24"}]},{"sha":"ff6ac29d8c6ad81a49d82975d8a75281a37a2615","node_id":"MDY6Q29tbWl0MjA2MzY0OmZmNmFjMjlkOGM2YWQ4MWE0OWQ4Mjk3NWQ4YTc1MjgxYTM3YTI2MTU=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-12-16T04:17:27Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-12-16T04:17:27Z"},"message":"OPENJPA-714:\nCheck l1 cache when looking for managed instances when cascading.\nSubmitted By: Jody Grassel\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@891119 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"7075f25a8b6a5e072d073f90be2a51b22b20433b","url":"https://api.github.com/repos/apache/openjpa/git/trees/7075f25a8b6a5e072d073f90be2a51b22b20433b"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/ff6ac29d8c6ad81a49d82975d8a75281a37a2615","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/ff6ac29d8c6ad81a49d82975d8a75281a37a2615","html_url":"https://github.com/apache/openjpa/commit/ff6ac29d8c6ad81a49d82975d8a75281a37a2615","comments_url":"https://api.github.com/repos/apache/openjpa/commits/ff6ac29d8c6ad81a49d82975d8a75281a37a2615/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"31401265e37721feed9624e1f7fadbaf838e9a5d","url":"https://api.github.com/repos/apache/openjpa/commits/31401265e37721feed9624e1f7fadbaf838e9a5d","html_url":"https://github.com/apache/openjpa/commit/31401265e37721feed9624e1f7fadbaf838e9a5d"}]},{"sha":"68ec48446ced9626cc8a0a76f7bfb5e972460aa2","node_id":"MDY6Q29tbWl0MjA2MzY0OjY4ZWM0ODQ0NmNlZDk2MjZjYzhhMGE3NmY3YmZiNWU5NzI0NjBhYTI=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-12-17T01:29:28Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2009-12-17T01:29:28Z"},"message":"OPENJPA-1397:\nAllow some columns of compound keys to be null.\nMerged from trunk commit by Pinaki Poddar.\nTestcase Submitted By: Michael Vorburger.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@891510 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a0f01007938ab6327e7caa4942bd06f5b3caa2f8","url":"https://api.github.com/repos/apache/openjpa/git/trees/a0f01007938ab6327e7caa4942bd06f5b3caa2f8"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/68ec48446ced9626cc8a0a76f7bfb5e972460aa2","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/68ec48446ced9626cc8a0a76f7bfb5e972460aa2","html_url":"https://github.com/apache/openjpa/commit/68ec48446ced9626cc8a0a76f7bfb5e972460aa2","comments_url":"https://api.github.com/repos/apache/openjpa/commits/68ec48446ced9626cc8a0a76f7bfb5e972460aa2/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"ff6ac29d8c6ad81a49d82975d8a75281a37a2615","url":"https://api.github.com/repos/apache/openjpa/commits/ff6ac29d8c6ad81a49d82975d8a75281a37a2615","html_url":"https://github.com/apache/openjpa/commit/ff6ac29d8c6ad81a49d82975d8a75281a37a2615"}]},{"sha":"a342b0563b775fde4aebfc5c7d57acd5468864e8","node_id":"MDY6Q29tbWl0MjA2MzY0OmEzNDJiMDU2M2I3NzVmZGU0YWViZmM1YzdkNTdhY2Q1NDY4ODY0ZTg=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-01-07T20:40:56Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-01-07T20:40:56Z"},"message":"OPENJPA-1441: \nSet pcVersionInit FieldMetaData to transient in PCEnhancer - merged to 1.2.x.\nSubmitted By: Rick Curtis\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@897009 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"18d1ed2cbfad0e81bfe5faad0e25fc911e3aa9df","url":"https://api.github.com/repos/apache/openjpa/git/trees/18d1ed2cbfad0e81bfe5faad0e25fc911e3aa9df"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/a342b0563b775fde4aebfc5c7d57acd5468864e8","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/a342b0563b775fde4aebfc5c7d57acd5468864e8","html_url":"https://github.com/apache/openjpa/commit/a342b0563b775fde4aebfc5c7d57acd5468864e8","comments_url":"https://api.github.com/repos/apache/openjpa/commits/a342b0563b775fde4aebfc5c7d57acd5468864e8/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"68ec48446ced9626cc8a0a76f7bfb5e972460aa2","url":"https://api.github.com/repos/apache/openjpa/commits/68ec48446ced9626cc8a0a76f7bfb5e972460aa2","html_url":"https://github.com/apache/openjpa/commit/68ec48446ced9626cc8a0a76f7bfb5e972460aa2"}]},{"sha":"cf28eea9d393dffdc2983ae7bb6b5fb56d17f1bd","node_id":"MDY6Q29tbWl0MjA2MzY0OmNmMjhlZWE5ZDM5M2RmZmRjMjk4M2FlN2JiNmI1ZmI1NmQxN2YxYmQ=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-01-12T20:45:04Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-01-12T20:45:04Z"},"message":" Update changes.txt and release-notes.html for 1.2.2 release\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@898501 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"7229738be02bd27c6e664951492125d582d14f07","url":"https://api.github.com/repos/apache/openjpa/git/trees/7229738be02bd27c6e664951492125d582d14f07"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/cf28eea9d393dffdc2983ae7bb6b5fb56d17f1bd","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/cf28eea9d393dffdc2983ae7bb6b5fb56d17f1bd","html_url":"https://github.com/apache/openjpa/commit/cf28eea9d393dffdc2983ae7bb6b5fb56d17f1bd","comments_url":"https://api.github.com/repos/apache/openjpa/commits/cf28eea9d393dffdc2983ae7bb6b5fb56d17f1bd/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"a342b0563b775fde4aebfc5c7d57acd5468864e8","url":"https://api.github.com/repos/apache/openjpa/commits/a342b0563b775fde4aebfc5c7d57acd5468864e8","html_url":"https://github.com/apache/openjpa/commit/a342b0563b775fde4aebfc5c7d57acd5468864e8"}]},{"sha":"89375719446b648b7ba5e1848427bb9bb75f18a8","node_id":"MDY6Q29tbWl0MjA2MzY0Ojg5Mzc1NzE5NDQ2YjY0OGI3YmE1ZTE4NDg0MjdiYjliYjc1ZjE4YTg=","commit":{"author":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2010-01-12T21:55:57Z"},"committer":{"name":"Richard G. Curtis","email":"curtisr7@apache.org","date":"2010-01-12T21:55:57Z"},"message":"OPENJPA-1414: Committing test case. Patch contributed by Dianne Richards.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@898537 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"ceb93a6eed655693f624b4ebc4a35b5d4107b323","url":"https://api.github.com/repos/apache/openjpa/git/trees/ceb93a6eed655693f624b4ebc4a35b5d4107b323"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/89375719446b648b7ba5e1848427bb9bb75f18a8","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/89375719446b648b7ba5e1848427bb9bb75f18a8","html_url":"https://github.com/apache/openjpa/commit/89375719446b648b7ba5e1848427bb9bb75f18a8","comments_url":"https://api.github.com/repos/apache/openjpa/commits/89375719446b648b7ba5e1848427bb9bb75f18a8/comments","author":null,"committer":null,"parents":[{"sha":"cf28eea9d393dffdc2983ae7bb6b5fb56d17f1bd","url":"https://api.github.com/repos/apache/openjpa/commits/cf28eea9d393dffdc2983ae7bb6b5fb56d17f1bd","html_url":"https://github.com/apache/openjpa/commit/cf28eea9d393dffdc2983ae7bb6b5fb56d17f1bd"}]},{"sha":"44dddb46ec91de66beaa25b8a3c79e90893676c1","node_id":"MDY6Q29tbWl0MjA2MzY0OjQ0ZGRkYjQ2ZWM5MWRlNjZiZWFhMjViOGEzYzc5ZTkwODkzNjc2YzE=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-01-12T23:08:36Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-01-12T23:08:36Z"},"message":"Add missing license headers and update rat excludes to skip eclipse files\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@898569 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"a4fce2734fda4f17ccfe50dc03cd2684315d6efd","url":"https://api.github.com/repos/apache/openjpa/git/trees/a4fce2734fda4f17ccfe50dc03cd2684315d6efd"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/44dddb46ec91de66beaa25b8a3c79e90893676c1","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/44dddb46ec91de66beaa25b8a3c79e90893676c1","html_url":"https://github.com/apache/openjpa/commit/44dddb46ec91de66beaa25b8a3c79e90893676c1","comments_url":"https://api.github.com/repos/apache/openjpa/commits/44dddb46ec91de66beaa25b8a3c79e90893676c1/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"89375719446b648b7ba5e1848427bb9bb75f18a8","url":"https://api.github.com/repos/apache/openjpa/commits/89375719446b648b7ba5e1848427bb9bb75f18a8","html_url":"https://github.com/apache/openjpa/commit/89375719446b648b7ba5e1848427bb9bb75f18a8"}]},{"sha":"a2142d80d31eaf00cc25678b387b3f78a3b55338","node_id":"MDY6Q29tbWl0MjA2MzY0OmEyMTQyZDgwZDMxZWFmMDBjYzI1Njc4YjM4N2IzZjc4YTNiNTUzMzg=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-01-13T16:44:55Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-01-13T16:44:55Z"},"message":"Update release plugin version\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@898832 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"64c7af07de4e769e21efa1e2879f1f532c09d87b","url":"https://api.github.com/repos/apache/openjpa/git/trees/64c7af07de4e769e21efa1e2879f1f532c09d87b"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/a2142d80d31eaf00cc25678b387b3f78a3b55338","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/a2142d80d31eaf00cc25678b387b3f78a3b55338","html_url":"https://github.com/apache/openjpa/commit/a2142d80d31eaf00cc25678b387b3f78a3b55338","comments_url":"https://api.github.com/repos/apache/openjpa/commits/a2142d80d31eaf00cc25678b387b3f78a3b55338/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"44dddb46ec91de66beaa25b8a3c79e90893676c1","url":"https://api.github.com/repos/apache/openjpa/commits/44dddb46ec91de66beaa25b8a3c79e90893676c1","html_url":"https://github.com/apache/openjpa/commit/44dddb46ec91de66beaa25b8a3c79e90893676c1"}]},{"sha":"97b1dd3294e7ec560ea9af479a37a91bd6a2eb59","node_id":"MDY6Q29tbWl0MjA2MzY0Ojk3YjFkZDMyOTRlN2VjNTYwZWE5YWY0NzlhMzdhOTFiZDZhMmViNTk=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-01-13T19:21:12Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-01-13T19:21:12Z"},"message":"OPENJPA-1457: \nRemove java.net maven repository from tck pom.xml file. TCK profile will use geronimo spec jar.\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@898903 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"1278f27c27e66254e637e70a427ab345ec590fb2","url":"https://api.github.com/repos/apache/openjpa/git/trees/1278f27c27e66254e637e70a427ab345ec590fb2"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/97b1dd3294e7ec560ea9af479a37a91bd6a2eb59","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/97b1dd3294e7ec560ea9af479a37a91bd6a2eb59","html_url":"https://github.com/apache/openjpa/commit/97b1dd3294e7ec560ea9af479a37a91bd6a2eb59","comments_url":"https://api.github.com/repos/apache/openjpa/commits/97b1dd3294e7ec560ea9af479a37a91bd6a2eb59/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"a2142d80d31eaf00cc25678b387b3f78a3b55338","url":"https://api.github.com/repos/apache/openjpa/commits/a2142d80d31eaf00cc25678b387b3f78a3b55338","html_url":"https://github.com/apache/openjpa/commit/a2142d80d31eaf00cc25678b387b3f78a3b55338"}]},{"sha":"08672c35f878f1de98ec1719eca850c41aa989a0","node_id":"MDY6Q29tbWl0MjA2MzY0OjA4NjcyYzM1Zjg3OGYxZGU5OGVjMTcxOWVjYTg1MGM0MWFhOTg5YTA=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-01-13T19:59:30Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-01-13T19:59:30Z"},"message":"[maven-release-plugin] prepare release 1.2.2\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/branches/1.2.x@898921 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"325c1cf7148a4f90bf7a12fd3e521c5b0363f4a0","url":"https://api.github.com/repos/apache/openjpa/git/trees/325c1cf7148a4f90bf7a12fd3e521c5b0363f4a0"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/08672c35f878f1de98ec1719eca850c41aa989a0","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/08672c35f878f1de98ec1719eca850c41aa989a0","html_url":"https://github.com/apache/openjpa/commit/08672c35f878f1de98ec1719eca850c41aa989a0","comments_url":"https://api.github.com/repos/apache/openjpa/commits/08672c35f878f1de98ec1719eca850c41aa989a0/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"97b1dd3294e7ec560ea9af479a37a91bd6a2eb59","url":"https://api.github.com/repos/apache/openjpa/commits/97b1dd3294e7ec560ea9af479a37a91bd6a2eb59","html_url":"https://github.com/apache/openjpa/commit/97b1dd3294e7ec560ea9af479a37a91bd6a2eb59"}]},{"sha":"2e7a9e50a687cc2c6e4098885cf2f781e3e7eb40","node_id":"MDY6Q29tbWl0MjA2MzY0OjJlN2E5ZTUwYTY4N2NjMmM2ZTQwOTg4ODVjZjJmNzgxZTNlN2ViNDA=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-01-13T19:59:38Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-01-13T19:59:38Z"},"message":"[maven-scm] copy for tag 1.2.2\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/tags/1.2.2@898922 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"22a38e864bcb517a217564335d933e0fb9dc7c3d","url":"https://api.github.com/repos/apache/openjpa/git/trees/22a38e864bcb517a217564335d933e0fb9dc7c3d"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/2e7a9e50a687cc2c6e4098885cf2f781e3e7eb40","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/2e7a9e50a687cc2c6e4098885cf2f781e3e7eb40","html_url":"https://github.com/apache/openjpa/commit/2e7a9e50a687cc2c6e4098885cf2f781e3e7eb40","comments_url":"https://api.github.com/repos/apache/openjpa/commits/2e7a9e50a687cc2c6e4098885cf2f781e3e7eb40/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"26dbc39431ad73a66752053fb278bb5027edc07e","url":"https://api.github.com/repos/apache/openjpa/commits/26dbc39431ad73a66752053fb278bb5027edc07e","html_url":"https://github.com/apache/openjpa/commit/26dbc39431ad73a66752053fb278bb5027edc07e"}]},{"sha":"9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","node_id":"MDY6Q29tbWl0MjA2MzY0OjlkMzRlZjlkZmMyN2Y5ZmQ1ZTcxMmUxYWZlN2YzYWMyNWQxMTk2NzU=","commit":{"author":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-01-13T20:45:02Z"},"committer":{"name":"Michael Dick","email":"mikedd@apache.org","date":"2010-01-13T20:45:02Z"},"message":"Copy for tag 1.2.2\n\ngit-svn-id: https://svn.apache.org/repos/asf/openjpa/tags/1.2.2@898935 13f79535-47bb-0310-9956-ffa450edef68","tree":{"sha":"325c1cf7148a4f90bf7a12fd3e521c5b0363f4a0","url":"https://api.github.com/repos/apache/openjpa/git/trees/325c1cf7148a4f90bf7a12fd3e521c5b0363f4a0"},"url":"https://api.github.com/repos/apache/openjpa/git/commits/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/apache/openjpa/commits/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","html_url":"https://github.com/apache/openjpa/commit/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","comments_url":"https://api.github.com/repos/apache/openjpa/commits/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/comments","author":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"committer":{"login":"mikedd","id":669432,"node_id":"MDQ6VXNlcjY2OTQzMg==","avatar_url":"https://avatars.githubusercontent.com/u/669432?v=4","gravatar_id":"","url":"https://api.github.com/users/mikedd","html_url":"https://github.com/mikedd","followers_url":"https://api.github.com/users/mikedd/followers","following_url":"https://api.github.com/users/mikedd/following{/other_user}","gists_url":"https://api.github.com/users/mikedd/gists{/gist_id}","starred_url":"https://api.github.com/users/mikedd/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikedd/subscriptions","organizations_url":"https://api.github.com/users/mikedd/orgs","repos_url":"https://api.github.com/users/mikedd/repos","events_url":"https://api.github.com/users/mikedd/events{/privacy}","received_events_url":"https://api.github.com/users/mikedd/received_events","type":"User","site_admin":false},"parents":[{"sha":"2e7a9e50a687cc2c6e4098885cf2f781e3e7eb40","url":"https://api.github.com/repos/apache/openjpa/commits/2e7a9e50a687cc2c6e4098885cf2f781e3e7eb40","html_url":"https://github.com/apache/openjpa/commit/2e7a9e50a687cc2c6e4098885cf2f781e3e7eb40"},{"sha":"08672c35f878f1de98ec1719eca850c41aa989a0","url":"https://api.github.com/repos/apache/openjpa/commits/08672c35f878f1de98ec1719eca850c41aa989a0","html_url":"https://github.com/apache/openjpa/commit/08672c35f878f1de98ec1719eca850c41aa989a0"}]}],"files":[{"sha":"319471629e60386304c42cc9b73dbd3288e1754a","filename":".gitignore","status":"added","additions":6,"deletions":0,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/.gitignore","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/.gitignore","contents_url":"https://api.github.com/repos/apache/openjpa/contents/.gitignore?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -0,0 +1,6 @@\n+.settings\n+.project\n+.classpath\n+target\n+velocity.log\n+derby.log"},{"sha":"e0432061444ccf54fff567a77c0791089ecc9d00","filename":"openjpa-all/pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-all/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-all/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-all/pom.xml?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -29,7 +29,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-parent</artifactId>\n-        <version>1.2.1</version>\n+        <version>1.2.2</version>\n     </parent>\n \n     <build>"},{"sha":"c1854535c0e932fbe6e551a28e5ff45ced597c1b","filename":"openjpa-examples/pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-examples/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-examples/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-examples/pom.xml?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -32,7 +32,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-parent</artifactId>\n-        <version>1.2.1</version>\n+        <version>1.2.2</version>\n     </parent>\n     <dependencies>\n         <dependency>"},{"sha":"a2d0026a09e2f69bd2c1e8d6932603925a916a16","filename":"openjpa-integration/examples/pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-integration/examples/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-integration/examples/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-integration/examples/pom.xml?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -38,7 +38,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-integration</artifactId>\n-        <version>1.2.1</version>\n+        <version>1.2.2</version>\n     </parent>\n \n     <profiles>"},{"sha":"e8cd5eaca4e397dacce9d167ba3d542e05c9e079","filename":"openjpa-integration/pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-integration/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-integration/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-integration/pom.xml?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -29,7 +29,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-parent</artifactId>\n-        <version>1.2.1</version>\n+        <version>1.2.2</version>\n     </parent>\n     <modules>\n         <module>examples</module>"},{"sha":"a78b9dd876d63fbf1842b4cb02d510b0893c639e","filename":"openjpa-integration/tck/pom.xml","status":"modified","additions":5,"deletions":15,"changes":20,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-integration/tck/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-integration/tck/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-integration/tck/pom.xml?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -61,7 +61,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-integration</artifactId>\n-        <version>1.2.1</version>\n+        <version>1.2.2</version>\n     </parent>\n \n     <profiles>\n@@ -269,22 +269,12 @@ databaseName=${db.name}\n     </profile>\n     </profiles>\n \n-    <repositories>\n-        <repository>\n-            <id>java.net</id>\n-            <name>Java.net Maven Repository</name>\n-            <url>https://maven-repository.dev.java.net/nonav/repository</url>\n-            <layout>legacy</layout>\n-        </repository>\n-    </repositories>\n-\n     <dependencies>\n-        <!-- use the authoritative javax.persistence API for testing -->\n         <dependency>\n-            <groupId>javax.persistence</groupId>\n-            <artifactId>persistence-api</artifactId>\n-            <version>1.0b</version>\n-        </dependency>\n+            <groupId>org.apache.geronimo.specs</groupId>\n+            <artifactId>geronimo-jpa_3.0_spec</artifactId>\n+            <version>1.1.1</version>\n+        </dependency> \n         <dependency>\n             <groupId>org.apache.openjpa</groupId>\n             <artifactId>openjpa-kernel</artifactId>"},{"sha":"a2d825137715b834da29d2f22f0733fffded6bd3","filename":"openjpa-jdbc/pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/pom.xml?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -31,7 +31,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-parent</artifactId>\n-        <version>1.2.1</version>\n+        <version>1.2.2</version>\n     </parent>\n     <dependencies>\n         <dependency>"},{"sha":"110d17efbfa0e5e8dcf13a17bff0f3c44a3760ac","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/AbstractJDBCSeq.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -57,8 +57,9 @@ public void setType(int type) {\n     public Object next(StoreContext ctx, ClassMetaData meta) {\n         JDBCStore store = getStore(ctx);\n         try {\n-            current = nextInternal(store, (ClassMapping) meta);\n-            return current;\n+            Object currentLocal = nextInternal(store, (ClassMapping) meta);\n+            current = currentLocal;\n+            return currentLocal;\n         } catch (OpenJPAException ke) {\n             throw ke;\n         } catch (SQLException se) {"},{"sha":"c445fdb8461789a8d3bb30f1b107db5626b04aa1","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","status":"modified","additions":545,"deletions":545,"changes":1090,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/ConstraintUpdateManager.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,546 +1,546 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import java.sql.Connection;\r\n-import java.sql.SQLException;\r\n-import java.util.Collection;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n-import org.apache.openjpa.jdbc.schema.Column;\r\n-import org.apache.openjpa.jdbc.schema.ForeignKey;\r\n-import org.apache.openjpa.jdbc.schema.Table;\r\n-import org.apache.openjpa.jdbc.sql.PrimaryRow;\r\n-import org.apache.openjpa.jdbc.sql.Row;\r\n-import org.apache.openjpa.jdbc.sql.RowImpl;\r\n-import org.apache.openjpa.jdbc.sql.RowManager;\r\n-import org.apache.openjpa.jdbc.sql.RowManagerImpl;\r\n-import org.apache.openjpa.jdbc.sql.SQLExceptions;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.lib.graph.DepthFirstAnalysis;\r\n-import org.apache.openjpa.lib.graph.Edge;\r\n-import org.apache.openjpa.lib.graph.Graph;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.OpenJPAException;\r\n-import org.apache.openjpa.util.UserException;\r\n-\r\n-/**\r\n- * <p>Standard update manager, capable of foreign key constraint evaluation.</p>\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class ConstraintUpdateManager\r\n-    extends AbstractUpdateManager {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (ConstraintUpdateManager.class);\r\n-\r\n-    public boolean orderDirty() {\r\n-        return true;\r\n-    }\r\n-\r\n-    protected PreparedStatementManager newPreparedStatementManager\r\n-        (JDBCStore store, Connection conn) {\r\n-        return new PreparedStatementManagerImpl(store, conn);\r\n-    }\r\n-\r\n-    protected RowManager newRowManager() {\r\n-        return new RowManagerImpl(false);\r\n-    }\r\n-\r\n-    protected Collection flush(RowManager rowMgr,\r\n-        PreparedStatementManager psMgr, Collection exceps) {\r\n-        RowManagerImpl rmimpl = (RowManagerImpl) rowMgr;\r\n-\r\n-        // first take care of all secondary table deletes and 'all row' deletes\r\n-        // (which are probably secondary table deletes), since no foreign\r\n-        // keys ever rely on secondary table pks\r\n-        flush(rmimpl.getAllRowDeletes(), psMgr);\r\n-        flush(rmimpl.getSecondaryDeletes(), psMgr);\r\n-\r\n-        // now do any 'all row' updates\r\n-        flush(rmimpl.getAllRowUpdates(), psMgr);\r\n-\r\n-        // analyze foreign keys\r\n-        Collection inserts = rmimpl.getInserts();\r\n-        Collection updates = rmimpl.getUpdates();\r\n-        Collection deletes = rmimpl.getDeletes();\r\n-        Graph[] graphs = new Graph[2];    // insert graph, delete graph\r\n-        analyzeForeignKeys(inserts, updates, deletes, rmimpl, graphs);\r\n-\r\n-        // flush insert graph, if any\r\n-        boolean autoAssign = rmimpl.hasAutoAssignConstraints();\r\n-        try {\r\n-            flushGraph(graphs[0], psMgr, autoAssign);\r\n-        } catch (SQLException se) {\r\n-            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\r\n-        } catch (OpenJPAException ke) {\r\n-            exceps = addException(exceps, ke);\r\n-        }\r\n-\r\n-        // flush the rest of the inserts and updates; inserts before updates\r\n-        // because some update fks might reference pks that have to be inserted\r\n-        flush(inserts, psMgr);\r\n-        flush(updates, psMgr);\r\n-\r\n-        // flush the delete graph, if any\r\n-        try {\r\n-            flushGraph(graphs[1], psMgr, autoAssign);\r\n-        } catch (SQLException se) {\r\n-            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\r\n-        } catch (OpenJPAException ke) {\r\n-            exceps = addException(exceps, ke);\r\n-        }\r\n-\r\n-        // put the remainder of the deletes after updates because some updates\r\n-        // may be nulling fks to rows that are going to be deleted\r\n-        flush(deletes, psMgr);\r\n-\r\n-        // take care of all secondary table inserts and updates last, since\r\n-        // they may rely on previous inserts or updates, but nothing relies\r\n-        // on them\r\n-        flush(rmimpl.getSecondaryUpdates(), psMgr);\r\n-\r\n-        // flush any left over prepared statements\r\n-        psMgr.flush();\r\n-        return exceps;\r\n-    }\r\n-\r\n-    /**\r\n-     * Analyze foreign key dependencies on the given rows\r\n-     * and create an insert and a delete graph to execute.  The insert\r\n-     * graph will be flushed before all other rows, and the delete graph will\r\n-     * be flushed after them.\r\n-     */\r\n-    private void analyzeForeignKeys(Collection inserts, Collection updates,\r\n-        Collection deletes, RowManagerImpl rowMgr, Graph[] graphs) {\r\n-        // if there are any deletes, we have to map the insert objects on their\r\n-        // oids so we'll be able to detect delete-then-insert-same-pk cases\r\n-        Map insertMap = null;\r\n-        OpenJPAStateManager sm;\r\n-        if (!deletes.isEmpty() && !inserts.isEmpty()) {\r\n-            insertMap = new HashMap((int) (inserts.size() * 1.33 + 1));\r\n-            for (Iterator itr = inserts.iterator(); itr.hasNext();) {\r\n-                sm = ((Row) itr.next()).getPrimaryKey();\r\n-                if (sm != null && sm.getObjectId() != null)\r\n-                    insertMap.put(sm.getObjectId(), sm);\r\n-            }\r\n-        }\r\n-\r\n-        // first construct the graph for deletes; this may expand to include\r\n-        // inserts and updates as well if there are any inserts that rely on\r\n-        // deletes (delete-then-insert-same-pk cases)\r\n-        PrimaryRow row;\r\n-        Row row2;\r\n-        ForeignKey[] fks;\r\n-        OpenJPAStateManager fkVal;\r\n-        boolean ignoreUpdates = true;\r\n-        for (Iterator itr = deletes.iterator(); itr.hasNext();) {\r\n-            row = (PrimaryRow) itr.next();\r\n-            if (!row.isValid())\r\n-                continue;\r\n-\r\n-            row2 = getInsertRow(insertMap, rowMgr, row);\r\n-            if (row2 != null) {\r\n-                ignoreUpdates = false;\r\n-                graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row, null);\r\n-            }\r\n-\r\n-            // now check this row's fks against other deletes\r\n-            fks = row.getTable().getForeignKeys();\r\n-            for (int j = 0; j < fks.length; j++) {\r\n-                // when deleting ref fks they'll just set a where value, so\r\n-                // check both for fk updates (relation fks) and wheres (ref fks)\r\n-                fkVal = row.getForeignKeySet(fks[j]);\r\n-                if (fkVal == null)\r\n-                    fkVal = row.getForeignKeyWhere(fks[j]);\r\n-                if (fkVal == null)\r\n-                    continue;\r\n-\r\n-                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\r\n-                    Row.ACTION_DELETE, fkVal, false);\r\n-                if (row2 != null && row2.isValid() && row2 != row)\r\n-                    graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row,\r\n-                        fks[j]);\r\n-            }\r\n-        }\r\n-\r\n-        if (ignoreUpdates)\r\n-            graphs[0] = analyzeAgainstInserts(inserts, rowMgr, graphs[0]);\r\n-        else {\r\n-            // put inserts *and updates* in the delete graph; they all rely\r\n-            // on each other\r\n-            graphs[1] = analyzeAgainstInserts(updates, rowMgr, graphs[1]);\r\n-            graphs[1] = analyzeAgainstInserts(inserts, rowMgr, graphs[1]);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if there is an insert for for the same table and primary\r\n-     * key values as the given delete row.\r\n-     */\r\n-    private Row getInsertRow(Map insertMap, RowManagerImpl rowMgr, Row row) {\r\n-        if (insertMap == null)\r\n-            return null;\r\n-\r\n-        OpenJPAStateManager sm = row.getPrimaryKey();\r\n-        if (sm == null)\r\n-            return null;\r\n-\r\n-        // look for a new object whose insert id is the same as this delete one\r\n-        Object oid = sm.getObjectId();\r\n-        OpenJPAStateManager nsm = (OpenJPAStateManager) insertMap.get(oid);\r\n-        if (nsm == null)\r\n-            return null;\r\n-\r\n-        // found new object; get its row\r\n-        row = rowMgr.getRow(row.getTable(), Row.ACTION_INSERT, nsm, false);\r\n-        return (row == null || row.isValid()) ? row : null;\r\n-    }\r\n-\r\n-    /**\r\n-     * Analyze the given rows against the inserts, placing dependencies\r\n-     * in the given graph.\r\n-     */\r\n-    private Graph analyzeAgainstInserts(Collection rows, RowManagerImpl rowMgr,\r\n-        Graph graph) {\r\n-        PrimaryRow row;\r\n-        Row row2;\r\n-        ForeignKey[] fks;\r\n-        Column[] cols;\r\n-        for (Iterator itr = rows.iterator(); itr.hasNext();) {\r\n-            row = (PrimaryRow) itr.next();\r\n-            if (!row.isValid())\r\n-                continue;\r\n-\r\n-            // check this row's fks against inserts; a logical fk to an auto-inc\r\n-            // column is treated just as actual database fk because the result\r\n-            // is the same: the pk row has to be inserted before the fk row\r\n-            fks = row.getTable().getForeignKeys();\r\n-            for (int j = 0; j < fks.length; j++) {\r\n-                if (row.getForeignKeySet(fks[j]) == null)\r\n-                    continue;\r\n-\r\n-                // see if this row is dependent on another.  if it's only\r\n-                // depenent on itself, see if the fk is logical or deferred, in\r\n-                // which case it must be an auto-inc because otherwise we\r\n-                // wouldn't have recorded it\r\n-                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\r\n-                    Row.ACTION_INSERT, row.getForeignKeySet(fks[j]), false);\r\n-                if (row2 != null && row2.isValid() && (row2 != row\r\n-                    || fks[j].isDeferred() || fks[j].isLogical()))\r\n-                    graph = addEdge(graph, row, (PrimaryRow) row2, fks[j]);\r\n-            }\r\n-\r\n-            // see if there are any relation id columns dependent on\r\n-            // auto-inc objects\r\n-            cols = row.getTable().getRelationIdColumns();\r\n-            for (int j = 0; j < cols.length; j++) {\r\n-                OpenJPAStateManager sm = row.getRelationIdSet(cols[j]);\r\n-                if (sm == null)\r\n-                    continue;\r\n-\r\n-                row2 = rowMgr.getRow(getBaseTable(sm), Row.ACTION_INSERT,\r\n-                    sm, false);\r\n-                if (row2 != null && row2.isValid())\r\n-                    graph = addEdge(graph, row, (PrimaryRow) row2, cols[j]);\r\n-            }\r\n-        }\r\n-        return graph;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the base table for the given instance.\r\n-     */\r\n-    private static Table getBaseTable(OpenJPAStateManager sm) {\r\n-        ClassMapping cls = (ClassMapping) sm.getMetaData();\r\n-        while (cls.getJoinablePCSuperclassMapping() != null)\r\n-            cls = cls.getJoinablePCSuperclassMapping();\r\n-        return cls.getTable();\r\n-    }\r\n-\r\n-    /**\r\n-     * Add an edge between the given rows in the given foreign key graph.\r\n-     */\r\n-    private Graph addEdge(Graph graph, PrimaryRow row1, PrimaryRow row2,\r\n-        Object fk) {\r\n-        // delay creation of the graph\r\n-        if (graph == null)\r\n-            graph = new Graph();\r\n-\r\n-        row1.setDependent(true);\r\n-        row2.setDependent(true);\r\n-        graph.addNode(row1);\r\n-        graph.addNode(row2);\r\n-\r\n-        // add an edge from row1 to row2, and set the fk causing the\r\n-        // dependency as the user object so we can retrieve it when resolving\r\n-        // circular constraints\r\n-        Edge edge = new Edge(row1, row2, true);\r\n-        edge.setUserObject(fk);\r\n-        graph.addEdge(edge);\r\n-\r\n-        return graph;\r\n-    }\r\n-\r\n-    /**\r\n-     * Flush the given graph of rows in the proper order.\r\n-     * @param graph The graph of statements to be walked\r\n-     * @param psMgr The prepared statement manager to use to issue the\r\n-     * statements\r\n-     * @param autoAssign Whether any of the rows in the graph have any\r\n-     * auto-assign constraints\r\n-     */\r\n-    protected void flushGraph(Graph graph, PreparedStatementManager psMgr,\r\n-        boolean autoAssign)\r\n-        throws SQLException {\r\n-        if (graph == null)\r\n-            return;\r\n-\r\n-        DepthFirstAnalysis dfa = newDepthFirstAnalysis(graph, autoAssign);\r\n-        Collection insertUpdates = new LinkedList();\r\n-        Collection deleteUpdates = new LinkedList();\r\n-        boolean recalculate;\r\n-\r\n-        // Handle circular constraints:\r\n-        // - if deleted row A has a ciricular fk to deleted row B, \r\n-        //   then use an update statement to null A's fk to B before flushing, \r\n-        //   and then flush\r\n-        // - if inserted row A has a circular fk to updated/inserted row B,\r\n-        //   then null the fk in the B row object, then flush,\r\n-        //   and after flushing, use an update to set the fk back to A\r\n-        // Depending on where circular dependencies are broken, the  \r\n-        // topological order of the graph nodes has to be re-calculated.\r\n-        recalculate = resolveCycles(graph, dfa.getEdges(Edge.TYPE_BACK),\r\n-                deleteUpdates, insertUpdates);\r\n-        recalculate |= resolveCycles(graph, dfa.getEdges(Edge.TYPE_FORWARD),\r\n-                deleteUpdates, insertUpdates);\r\n-\r\n-        if (recalculate) {\r\n-            dfa = recalculateDepthFirstAnalysis(graph, autoAssign);\r\n-        }\r\n-\r\n-        // flush delete updates to null fks, then all rows in order, then\r\n-        // the insert updates to set circular fk values\r\n-        flush(deleteUpdates, psMgr);\r\n-        Collection nodes = dfa.getSortedNodes();\r\n-        for (Iterator itr = nodes.iterator(); itr.hasNext();)\r\n-            psMgr.flush((RowImpl) itr.next());\r\n-        flush(insertUpdates, psMgr);\r\n-    }\r\n-\r\n-    /**\r\n-     * Break a circular dependency caused by delete operations.\r\n-     * If deleted row A has a ciricular fk to deleted row B, then use an update \r\n-     * statement to null A's fk to B before deleting B, then delete A.\r\n-     * @param edge Edge in the dependency graph corresponding to a foreign key\r\n-     * constraint. This dependency is broken by nullifying the foreign key.\r\n-     * @param deleteUpdates Collection of update statements that are executed\r\n-     * before the delete operations are flushed \r\n-     */\r\n-    private void addDeleteUpdate(Edge edge, Collection deleteUpdates)\r\n-        throws SQLException {\r\n-        PrimaryRow row;\r\n-        RowImpl update;\r\n-        ForeignKey fk;\r\n-\r\n-        // copy where conditions into new update that nulls the fk\r\n-        row = (PrimaryRow) edge.getTo();\r\n-        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\r\n-        row.copyInto(update, true);\r\n-        if (edge.getUserObject() instanceof ForeignKey) {\r\n-            fk = (ForeignKey) edge.getUserObject();\r\n-            update.setForeignKey(fk, row.getForeignKeyIO(fk), null);\r\n-        } else\r\n-            update.setNull((Column) edge.getUserObject());\r\n-\r\n-        deleteUpdates.add(update);\r\n-    }\r\n-\r\n-    /**\r\n-     * Break a circular dependency caused by insert operations.\r\n-     * If inserted row A has a circular fk to updated/inserted row B,\r\n-     * then null the fk in the B row object, then flush,\r\n-     * and after flushing, use an update to set the fk back to A.\r\n-     * @param row Row to be flushed\r\n-     * @param edge Edge in the dependency graph corresponding to a foreign key\r\n-     * constraint. This dependency is broken by nullifying the foreign key.\r\n-     * @param insertUpdates Collection of update statements that are executed\r\n-     * after the insert/update operations are flushed \r\n-     */\r\n-    private void addInsertUpdate(PrimaryRow row, Edge edge,\r\n-        Collection insertUpdates) throws SQLException {\r\n-        RowImpl update;\r\n-        ForeignKey fk;\r\n-        Column col;\r\n-\r\n-        // copy where conditions into new update that sets the fk\r\n-        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\r\n-        if (row.getAction() == Row.ACTION_INSERT) {\r\n-            if (row.getPrimaryKey() == null)\r\n-                throw new InternalException(_loc.get(\"ref-cycle\"));\r\n-            update.wherePrimaryKey(row.getPrimaryKey());\r\n-        } else {\r\n-            // Row.ACTION_UPDATE\r\n-            row.copyInto(update, true);\r\n-        }\r\n-        if (edge.getUserObject() instanceof ForeignKey) {\r\n-            fk = (ForeignKey) edge.getUserObject();\r\n-            update.setForeignKey(fk, row.getForeignKeyIO(fk),\r\n-                row.getForeignKeySet(fk));\r\n-            row.clearForeignKey(fk);\r\n-        } else {\r\n-            col = (Column) edge.getUserObject();\r\n-            update.setRelationId(col, row.getRelationIdSet(col),\r\n-                row.getRelationIdCallback(col));\r\n-            row.clearRelationId(col);\r\n-        }\r\n-\r\n-        insertUpdates.add(update);\r\n-    }\r\n-\r\n-    /**\r\n-     * Finds a nullable foreign key by walking the dependency cycle. \r\n-     * Circular dependencies can be broken at this point.\r\n-     * @param cycle Cycle in the dependency graph.\r\n-     * @return Edge corresponding to a nullable foreign key.\r\n-     */\r\n-    private Edge findBreakableLink(List cycle) {\r\n-        Edge breakableLink = null;\r\n-        for (Iterator iter = cycle.iterator(); iter.hasNext(); ) {\r\n-            Edge edge = (Edge) iter.next();\r\n-            Object userObject = edge.getUserObject();\r\n-            if (userObject instanceof ForeignKey) {\r\n-                 if (!((ForeignKey) userObject).hasNotNullColumns()) {\r\n-                     breakableLink = edge;\r\n-                     break;\r\n-                 }\r\n-            } else if (userObject instanceof Column) {\r\n-                if (!((Column) userObject).isNotNull()) {\r\n-                    breakableLink = edge;\r\n-                    break;\r\n-                }\r\n-            }\r\n-        }\r\n-        return breakableLink;\r\n-    }\r\n-\r\n-    /**\r\n-     * Re-calculates the DepthFirstSearch analysis of the graph \r\n-     * after some of the edges have been removed. Ensures\r\n-     * that the dependency graph is cycle free.\r\n-     * @param graph The graph of statements to be walked\r\n-     * @param autoAssign Whether any of the rows in the graph have any\r\n-     * auto-assign constraints\r\n-     */\r\n-    private DepthFirstAnalysis recalculateDepthFirstAnalysis(Graph graph,\r\n-        boolean autoAssign) {\r\n-        DepthFirstAnalysis dfa;\r\n-        // clear previous traversal data\r\n-        graph.clearTraversal();\r\n-        dfa = newDepthFirstAnalysis(graph, autoAssign);\r\n-        // make sure that the graph is non-cyclic now\r\n-        assert (dfa.hasNoCycles()): _loc.get(\"graph-not-cycle-free\");\r\n-        return dfa;\r\n-    }\r\n-\r\n-    /**\r\n-     * Resolve circular dependencies by identifying and breaking\r\n-     * a nullable foreign key.\r\n-     * @param graph Dependency graph.\r\n-     * @param edges Collection of edges. Each edge indicates a possible \r\n-     * circular dependency\r\n-     * @param deleteUpdates Collection of update operations (nullifying \r\n-     * foreign keys) to be filled. These updates will be executed before \r\n-     * the rows in the dependency graph are flushed\r\n-     * @param insertUpdates CCollection of update operations (nullifying \r\n-     * foreign keys) to be filled. These updates will be executed after \r\n-     * the rows in the dependency graph are flushed\r\n-     * @return Depending on where circular dependencies are broken, the  \r\n-     * topological order of the graph nodes has to be re-calculated.\r\n-     */\r\n-    private boolean resolveCycles(Graph graph, Collection edges,\r\n-        Collection deleteUpdates, Collection insertUpdates)\r\n-        throws SQLException {\r\n-        boolean recalculate = false;\r\n-        for (Iterator itr = edges.iterator(); itr.hasNext();) {\r\n-            Edge edge = (Edge) itr.next();\r\n-            List cycle = edge.getCycle();\r\n-\r\n-            if (cycle != null) {\r\n-                // find a nullable foreign key\r\n-                Edge breakableLink = findBreakableLink(cycle);\r\n-                if (breakableLink == null) {\r\n-                    throw new UserException(_loc.get(\"no-nullable-fk\"));\r\n-                }\r\n-\r\n-                // topologic node order must be re-calculated,  if the\r\n-                // breakable link is different from the edge where\r\n-                // the circular dependency was originally detected\r\n-                if (edge != breakableLink) {\r\n-                    recalculate = true;\r\n-                }\r\n-\r\n-                if (!breakableLink.isRemovedFromGraph()) {\r\n-\r\n-                    // use a primary row update to prevent setting pk and fk values\r\n-                    // until after flush, to get latest auto-increment values\r\n-                    PrimaryRow row = (PrimaryRow) breakableLink.getFrom();\r\n-                    if (row.getAction() == Row.ACTION_DELETE) {\r\n-                        addDeleteUpdate(breakableLink, deleteUpdates);\r\n-                    } else {\r\n-                        addInsertUpdate(row, breakableLink, insertUpdates);\r\n-                    }\r\n-                    graph.removeEdge(breakableLink);\r\n-                }\r\n-            }\r\n-        }\r\n-        return recalculate;\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new {@link DepthFirstAnalysis} suitable for the given graph\r\n-     * and auto-assign settings.\r\n-     */\r\n-    protected DepthFirstAnalysis newDepthFirstAnalysis(Graph graph,\r\n-        boolean autoAssign) {\r\n-        return new DepthFirstAnalysis(graph);\r\n-    }\r\n-\r\n-    /**\r\n-     * Flush the given collection of secondary rows.\r\n-     */\r\n-    protected void flush(Collection rows, PreparedStatementManager psMgr) {\r\n-        if (rows.size() == 0)\r\n-            return;\r\n-\r\n-        RowImpl row;\r\n-        for (Iterator itr = rows.iterator(); itr.hasNext(); ) {\r\n-            row = (RowImpl) itr.next();\r\n-            if (row.isValid() && !row.isDependent())\r\n-                psMgr.flush(row);\r\n-        }\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.jdbc.sql.PrimaryRow;\n+import org.apache.openjpa.jdbc.sql.Row;\n+import org.apache.openjpa.jdbc.sql.RowImpl;\n+import org.apache.openjpa.jdbc.sql.RowManager;\n+import org.apache.openjpa.jdbc.sql.RowManagerImpl;\n+import org.apache.openjpa.jdbc.sql.SQLExceptions;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.lib.graph.DepthFirstAnalysis;\n+import org.apache.openjpa.lib.graph.Edge;\n+import org.apache.openjpa.lib.graph.Graph;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * <p>Standard update manager, capable of foreign key constraint evaluation.</p>\n+ *\n+ * @since 1.0.0\n+ */\n+public class ConstraintUpdateManager\n+    extends AbstractUpdateManager {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (ConstraintUpdateManager.class);\n+\n+    public boolean orderDirty() {\n+        return true;\n+    }\n+\n+    protected PreparedStatementManager newPreparedStatementManager\n+        (JDBCStore store, Connection conn) {\n+        return new PreparedStatementManagerImpl(store, conn);\n+    }\n+\n+    protected RowManager newRowManager() {\n+        return new RowManagerImpl(false);\n+    }\n+\n+    protected Collection flush(RowManager rowMgr,\n+        PreparedStatementManager psMgr, Collection exceps) {\n+        RowManagerImpl rmimpl = (RowManagerImpl) rowMgr;\n+\n+        // first take care of all secondary table deletes and 'all row' deletes\n+        // (which are probably secondary table deletes), since no foreign\n+        // keys ever rely on secondary table pks\n+        flush(rmimpl.getAllRowDeletes(), psMgr);\n+        flush(rmimpl.getSecondaryDeletes(), psMgr);\n+\n+        // now do any 'all row' updates\n+        flush(rmimpl.getAllRowUpdates(), psMgr);\n+\n+        // analyze foreign keys\n+        Collection inserts = rmimpl.getInserts();\n+        Collection updates = rmimpl.getUpdates();\n+        Collection deletes = rmimpl.getDeletes();\n+        Graph[] graphs = new Graph[2];    // insert graph, delete graph\n+        analyzeForeignKeys(inserts, updates, deletes, rmimpl, graphs);\n+\n+        // flush insert graph, if any\n+        boolean autoAssign = rmimpl.hasAutoAssignConstraints();\n+        try {\n+            flushGraph(graphs[0], psMgr, autoAssign);\n+        } catch (SQLException se) {\n+            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\n+        } catch (OpenJPAException ke) {\n+            exceps = addException(exceps, ke);\n+        }\n+\n+        // flush the rest of the inserts and updates; inserts before updates\n+        // because some update fks might reference pks that have to be inserted\n+        flush(inserts, psMgr);\n+        flush(updates, psMgr);\n+\n+        // flush the delete graph, if any\n+        try {\n+            flushGraph(graphs[1], psMgr, autoAssign);\n+        } catch (SQLException se) {\n+            exceps = addException(exceps, SQLExceptions.getStore(se, dict));\n+        } catch (OpenJPAException ke) {\n+            exceps = addException(exceps, ke);\n+        }\n+\n+        // put the remainder of the deletes after updates because some updates\n+        // may be nulling fks to rows that are going to be deleted\n+        flush(deletes, psMgr);\n+\n+        // take care of all secondary table inserts and updates last, since\n+        // they may rely on previous inserts or updates, but nothing relies\n+        // on them\n+        flush(rmimpl.getSecondaryUpdates(), psMgr);\n+\n+        // flush any left over prepared statements\n+        psMgr.flush();\n+        return exceps;\n+    }\n+\n+    /**\n+     * Analyze foreign key dependencies on the given rows\n+     * and create an insert and a delete graph to execute.  The insert\n+     * graph will be flushed before all other rows, and the delete graph will\n+     * be flushed after them.\n+     */\n+    private void analyzeForeignKeys(Collection inserts, Collection updates,\n+        Collection deletes, RowManagerImpl rowMgr, Graph[] graphs) {\n+        // if there are any deletes, we have to map the insert objects on their\n+        // oids so we'll be able to detect delete-then-insert-same-pk cases\n+        Map insertMap = null;\n+        OpenJPAStateManager sm;\n+        if (!deletes.isEmpty() && !inserts.isEmpty()) {\n+            insertMap = new HashMap((int) (inserts.size() * 1.33 + 1));\n+            for (Iterator itr = inserts.iterator(); itr.hasNext();) {\n+                sm = ((Row) itr.next()).getPrimaryKey();\n+                if (sm != null && sm.getObjectId() != null)\n+                    insertMap.put(sm.getObjectId(), sm);\n+            }\n+        }\n+\n+        // first construct the graph for deletes; this may expand to include\n+        // inserts and updates as well if there are any inserts that rely on\n+        // deletes (delete-then-insert-same-pk cases)\n+        PrimaryRow row;\n+        Row row2;\n+        ForeignKey[] fks;\n+        OpenJPAStateManager fkVal;\n+        boolean ignoreUpdates = true;\n+        for (Iterator itr = deletes.iterator(); itr.hasNext();) {\n+            row = (PrimaryRow) itr.next();\n+            if (!row.isValid())\n+                continue;\n+\n+            row2 = getInsertRow(insertMap, rowMgr, row);\n+            if (row2 != null) {\n+                ignoreUpdates = false;\n+                graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row, null);\n+            }\n+\n+            // now check this row's fks against other deletes\n+            fks = row.getTable().getForeignKeys();\n+            for (int j = 0; j < fks.length; j++) {\n+                // when deleting ref fks they'll just set a where value, so\n+                // check both for fk updates (relation fks) and wheres (ref fks)\n+                fkVal = row.getForeignKeySet(fks[j]);\n+                if (fkVal == null)\n+                    fkVal = row.getForeignKeyWhere(fks[j]);\n+                if (fkVal == null)\n+                    continue;\n+\n+                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\n+                    Row.ACTION_DELETE, fkVal, false);\n+                if (row2 != null && row2.isValid() && row2 != row)\n+                    graphs[1] = addEdge(graphs[1], (PrimaryRow) row2, row,\n+                        fks[j]);\n+            }\n+        }\n+\n+        if (ignoreUpdates)\n+            graphs[0] = analyzeAgainstInserts(inserts, rowMgr, graphs[0]);\n+        else {\n+            // put inserts *and updates* in the delete graph; they all rely\n+            // on each other\n+            graphs[1] = analyzeAgainstInserts(updates, rowMgr, graphs[1]);\n+            graphs[1] = analyzeAgainstInserts(inserts, rowMgr, graphs[1]);\n+        }\n+    }\n+\n+    /**\n+     * Check to see if there is an insert for for the same table and primary\n+     * key values as the given delete row.\n+     */\n+    private Row getInsertRow(Map insertMap, RowManagerImpl rowMgr, Row row) {\n+        if (insertMap == null)\n+            return null;\n+\n+        OpenJPAStateManager sm = row.getPrimaryKey();\n+        if (sm == null)\n+            return null;\n+\n+        // look for a new object whose insert id is the same as this delete one\n+        Object oid = sm.getObjectId();\n+        OpenJPAStateManager nsm = (OpenJPAStateManager) insertMap.get(oid);\n+        if (nsm == null)\n+            return null;\n+\n+        // found new object; get its row\n+        row = rowMgr.getRow(row.getTable(), Row.ACTION_INSERT, nsm, false);\n+        return (row == null || row.isValid()) ? row : null;\n+    }\n+\n+    /**\n+     * Analyze the given rows against the inserts, placing dependencies\n+     * in the given graph.\n+     */\n+    private Graph analyzeAgainstInserts(Collection rows, RowManagerImpl rowMgr,\n+        Graph graph) {\n+        PrimaryRow row;\n+        Row row2;\n+        ForeignKey[] fks;\n+        Column[] cols;\n+        for (Iterator itr = rows.iterator(); itr.hasNext();) {\n+            row = (PrimaryRow) itr.next();\n+            if (!row.isValid())\n+                continue;\n+\n+            // check this row's fks against inserts; a logical fk to an auto-inc\n+            // column is treated just as actual database fk because the result\n+            // is the same: the pk row has to be inserted before the fk row\n+            fks = row.getTable().getForeignKeys();\n+            for (int j = 0; j < fks.length; j++) {\n+                if (row.getForeignKeySet(fks[j]) == null)\n+                    continue;\n+\n+                // see if this row is dependent on another.  if it's only\n+                // depenent on itself, see if the fk is logical or deferred, in\n+                // which case it must be an auto-inc because otherwise we\n+                // wouldn't have recorded it\n+                row2 = rowMgr.getRow(fks[j].getPrimaryKeyTable(),\n+                    Row.ACTION_INSERT, row.getForeignKeySet(fks[j]), false);\n+                if (row2 != null && row2.isValid() && (row2 != row\n+                    || fks[j].isDeferred() || fks[j].isLogical()))\n+                    graph = addEdge(graph, row, (PrimaryRow) row2, fks[j]);\n+            }\n+\n+            // see if there are any relation id columns dependent on\n+            // auto-inc objects\n+            cols = row.getTable().getRelationIdColumns();\n+            for (int j = 0; j < cols.length; j++) {\n+                OpenJPAStateManager sm = row.getRelationIdSet(cols[j]);\n+                if (sm == null)\n+                    continue;\n+\n+                row2 = rowMgr.getRow(getBaseTable(sm), Row.ACTION_INSERT,\n+                    sm, false);\n+                if (row2 != null && row2.isValid())\n+                    graph = addEdge(graph, row, (PrimaryRow) row2, cols[j]);\n+            }\n+        }\n+        return graph;\n+    }\n+\n+    /**\n+     * Return the base table for the given instance.\n+     */\n+    private static Table getBaseTable(OpenJPAStateManager sm) {\n+        ClassMapping cls = (ClassMapping) sm.getMetaData();\n+        while (cls.getJoinablePCSuperclassMapping() != null)\n+            cls = cls.getJoinablePCSuperclassMapping();\n+        return cls.getTable();\n+    }\n+\n+    /**\n+     * Add an edge between the given rows in the given foreign key graph.\n+     */\n+    private Graph addEdge(Graph graph, PrimaryRow row1, PrimaryRow row2,\n+        Object fk) {\n+        // delay creation of the graph\n+        if (graph == null)\n+            graph = new Graph();\n+\n+        row1.setDependent(true);\n+        row2.setDependent(true);\n+        graph.addNode(row1);\n+        graph.addNode(row2);\n+\n+        // add an edge from row1 to row2, and set the fk causing the\n+        // dependency as the user object so we can retrieve it when resolving\n+        // circular constraints\n+        Edge edge = new Edge(row1, row2, true);\n+        edge.setUserObject(fk);\n+        graph.addEdge(edge);\n+\n+        return graph;\n+    }\n+\n+    /**\n+     * Flush the given graph of rows in the proper order.\n+     * @param graph The graph of statements to be walked\n+     * @param psMgr The prepared statement manager to use to issue the\n+     * statements\n+     * @param autoAssign Whether any of the rows in the graph have any\n+     * auto-assign constraints\n+     */\n+    protected void flushGraph(Graph graph, PreparedStatementManager psMgr,\n+        boolean autoAssign)\n+        throws SQLException {\n+        if (graph == null)\n+            return;\n+\n+        DepthFirstAnalysis dfa = newDepthFirstAnalysis(graph, autoAssign);\n+        Collection insertUpdates = new LinkedList();\n+        Collection deleteUpdates = new LinkedList();\n+        boolean recalculate;\n+\n+        // Handle circular constraints:\n+        // - if deleted row A has a ciricular fk to deleted row B, \n+        //   then use an update statement to null A's fk to B before flushing, \n+        //   and then flush\n+        // - if inserted row A has a circular fk to updated/inserted row B,\n+        //   then null the fk in the B row object, then flush,\n+        //   and after flushing, use an update to set the fk back to A\n+        // Depending on where circular dependencies are broken, the  \n+        // topological order of the graph nodes has to be re-calculated.\n+        recalculate = resolveCycles(graph, dfa.getEdges(Edge.TYPE_BACK),\n+                deleteUpdates, insertUpdates);\n+        recalculate |= resolveCycles(graph, dfa.getEdges(Edge.TYPE_FORWARD),\n+                deleteUpdates, insertUpdates);\n+\n+        if (recalculate) {\n+            dfa = recalculateDepthFirstAnalysis(graph, autoAssign);\n+        }\n+\n+        // flush delete updates to null fks, then all rows in order, then\n+        // the insert updates to set circular fk values\n+        flush(deleteUpdates, psMgr);\n+        Collection nodes = dfa.getSortedNodes();\n+        for (Iterator itr = nodes.iterator(); itr.hasNext();)\n+            psMgr.flush((RowImpl) itr.next());\n+        flush(insertUpdates, psMgr);\n+    }\n+\n+    /**\n+     * Break a circular dependency caused by delete operations.\n+     * If deleted row A has a ciricular fk to deleted row B, then use an update \n+     * statement to null A's fk to B before deleting B, then delete A.\n+     * @param edge Edge in the dependency graph corresponding to a foreign key\n+     * constraint. This dependency is broken by nullifying the foreign key.\n+     * @param deleteUpdates Collection of update statements that are executed\n+     * before the delete operations are flushed \n+     */\n+    private void addDeleteUpdate(Edge edge, Collection deleteUpdates)\n+        throws SQLException {\n+        PrimaryRow row;\n+        RowImpl update;\n+        ForeignKey fk;\n+\n+        // copy where conditions into new update that nulls the fk\n+        row = (PrimaryRow) edge.getTo();\n+        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\n+        row.copyInto(update, true);\n+        if (edge.getUserObject() instanceof ForeignKey) {\n+            fk = (ForeignKey) edge.getUserObject();\n+            update.setForeignKey(fk, row.getForeignKeyIO(fk), null);\n+        } else\n+            update.setNull((Column) edge.getUserObject());\n+\n+        deleteUpdates.add(update);\n+    }\n+\n+    /**\n+     * Break a circular dependency caused by insert operations.\n+     * If inserted row A has a circular fk to updated/inserted row B,\n+     * then null the fk in the B row object, then flush,\n+     * and after flushing, use an update to set the fk back to A.\n+     * @param row Row to be flushed\n+     * @param edge Edge in the dependency graph corresponding to a foreign key\n+     * constraint. This dependency is broken by nullifying the foreign key.\n+     * @param insertUpdates Collection of update statements that are executed\n+     * after the insert/update operations are flushed \n+     */\n+    private void addInsertUpdate(PrimaryRow row, Edge edge,\n+        Collection insertUpdates) throws SQLException {\n+        RowImpl update;\n+        ForeignKey fk;\n+        Column col;\n+\n+        // copy where conditions into new update that sets the fk\n+        update = new PrimaryRow(row.getTable(), Row.ACTION_UPDATE, null);\n+        if (row.getAction() == Row.ACTION_INSERT) {\n+            if (row.getPrimaryKey() == null)\n+                throw new InternalException(_loc.get(\"ref-cycle\"));\n+            update.wherePrimaryKey(row.getPrimaryKey());\n+        } else {\n+            // Row.ACTION_UPDATE\n+            row.copyInto(update, true);\n+        }\n+        if (edge.getUserObject() instanceof ForeignKey) {\n+            fk = (ForeignKey) edge.getUserObject();\n+            update.setForeignKey(fk, row.getForeignKeyIO(fk),\n+                row.getForeignKeySet(fk));\n+            row.clearForeignKey(fk);\n+        } else {\n+            col = (Column) edge.getUserObject();\n+            update.setRelationId(col, row.getRelationIdSet(col),\n+                row.getRelationIdCallback(col));\n+            row.clearRelationId(col);\n+        }\n+\n+        insertUpdates.add(update);\n+    }\n+\n+    /**\n+     * Finds a nullable foreign key by walking the dependency cycle. \n+     * Circular dependencies can be broken at this point.\n+     * @param cycle Cycle in the dependency graph.\n+     * @return Edge corresponding to a nullable foreign key.\n+     */\n+    private Edge findBreakableLink(List cycle) {\n+        Edge breakableLink = null;\n+        for (Iterator iter = cycle.iterator(); iter.hasNext(); ) {\n+            Edge edge = (Edge) iter.next();\n+            Object userObject = edge.getUserObject();\n+            if (userObject instanceof ForeignKey) {\n+                 if (!((ForeignKey) userObject).hasNotNullColumns()) {\n+                     breakableLink = edge;\n+                     break;\n+                 }\n+            } else if (userObject instanceof Column) {\n+                if (!((Column) userObject).isNotNull()) {\n+                    breakableLink = edge;\n+                    break;\n+                }\n+            }\n+        }\n+        return breakableLink;\n+    }\n+\n+    /**\n+     * Re-calculates the DepthFirstSearch analysis of the graph \n+     * after some of the edges have been removed. Ensures\n+     * that the dependency graph is cycle free.\n+     * @param graph The graph of statements to be walked\n+     * @param autoAssign Whether any of the rows in the graph have any\n+     * auto-assign constraints\n+     */\n+    private DepthFirstAnalysis recalculateDepthFirstAnalysis(Graph graph,\n+        boolean autoAssign) {\n+        DepthFirstAnalysis dfa;\n+        // clear previous traversal data\n+        graph.clearTraversal();\n+        dfa = newDepthFirstAnalysis(graph, autoAssign);\n+        // make sure that the graph is non-cyclic now\n+        assert (dfa.hasNoCycles()): _loc.get(\"graph-not-cycle-free\");\n+        return dfa;\n+    }\n+\n+    /**\n+     * Resolve circular dependencies by identifying and breaking\n+     * a nullable foreign key.\n+     * @param graph Dependency graph.\n+     * @param edges Collection of edges. Each edge indicates a possible \n+     * circular dependency\n+     * @param deleteUpdates Collection of update operations (nullifying \n+     * foreign keys) to be filled. These updates will be executed before \n+     * the rows in the dependency graph are flushed\n+     * @param insertUpdates CCollection of update operations (nullifying \n+     * foreign keys) to be filled. These updates will be executed after \n+     * the rows in the dependency graph are flushed\n+     * @return Depending on where circular dependencies are broken, the  \n+     * topological order of the graph nodes has to be re-calculated.\n+     */\n+    private boolean resolveCycles(Graph graph, Collection edges,\n+        Collection deleteUpdates, Collection insertUpdates)\n+        throws SQLException {\n+        boolean recalculate = false;\n+        for (Iterator itr = edges.iterator(); itr.hasNext();) {\n+            Edge edge = (Edge) itr.next();\n+            List cycle = edge.getCycle();\n+\n+            if (cycle != null) {\n+                // find a nullable foreign key\n+                Edge breakableLink = findBreakableLink(cycle);\n+                if (breakableLink == null) {\n+                    throw new UserException(_loc.get(\"no-nullable-fk\"));\n+                }\n+\n+                // topologic node order must be re-calculated,  if the\n+                // breakable link is different from the edge where\n+                // the circular dependency was originally detected\n+                if (edge != breakableLink) {\n+                    recalculate = true;\n+                }\n+\n+                if (!breakableLink.isRemovedFromGraph()) {\n+\n+                    // use a primary row update to prevent setting pk and fk values\n+                    // until after flush, to get latest auto-increment values\n+                    PrimaryRow row = (PrimaryRow) breakableLink.getFrom();\n+                    if (row.getAction() == Row.ACTION_DELETE) {\n+                        addDeleteUpdate(breakableLink, deleteUpdates);\n+                    } else {\n+                        addInsertUpdate(row, breakableLink, insertUpdates);\n+                    }\n+                    graph.removeEdge(breakableLink);\n+                }\n+            }\n+        }\n+        return recalculate;\n+    }\n+\n+    /**\n+     * Create a new {@link DepthFirstAnalysis} suitable for the given graph\n+     * and auto-assign settings.\n+     */\n+    protected DepthFirstAnalysis newDepthFirstAnalysis(Graph graph,\n+        boolean autoAssign) {\n+        return new DepthFirstAnalysis(graph);\n+    }\n+\n+    /**\n+     * Flush the given collection of secondary rows.\n+     */\n+    protected void flush(Collection rows, PreparedStatementManager psMgr) {\n+        if (rows.size() == 0)\n+            return;\n+\n+        RowImpl row;\n+        for (Iterator itr = rows.iterator(); itr.hasNext(); ) {\n+            row = (RowImpl) itr.next();\n+            if (row.isValid() && !row.isDependent())\n+                psMgr.flush(row);\n+        }\n+    }\n }\n\\ No newline at end of file"},{"sha":"d1eda4e92084551003ff194530a53dfeb60652df","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","status":"modified","additions":7,"deletions":3,"changes":10,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/JDBCStoreManager.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -502,15 +502,19 @@ private Result getInitializeStateResult(OpenJPAStateManager sm,\n         if (sel == null) return null;\n         return sel.execute(this, fetch, params);\n     }\n-\n+    \n+    Map<SelectKey, Select> selectImplCacheMap = null;\n     private Select newSelect(OpenJPAStateManager sm,\n         ClassMapping mapping, JDBCFetchConfiguration fetch, int subs,\n         List params) {\n         if (!_isQuerySQLCache) \n             return newSelect(sm, mapping, fetch, subs);       \n            \n-        Map<SelectKey, Select> selectImplCacheMap = \n-            getCacheMapFromQuerySQLCache(JDBCStoreManager.class);\n+        if (selectImplCacheMap == null) {\n+            selectImplCacheMap =\n+                getCacheMapFromQuerySQLCache(JDBCStoreManager.class);\n+        }\n+         \n         JDBCFetchConfiguration fetchClone = new JDBCFetchConfigurationImpl();\n         fetchClone.copy(fetch);\n         SelectKey selKey = new SelectKey(mapping, null, fetchClone);"},{"sha":"8c2d39b6811ec5f2f3a57aa0f4098a298c18fb00","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/NativeJDBCSeq.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -281,7 +281,9 @@ private long getSequence(Connection conn)\n         ResultSet rs = null;\n         try {\n             stmnt = conn.prepareStatement(_select);\n-            rs = stmnt.executeQuery();\n+            synchronized(this) {\n+                rs = stmnt.executeQuery();\n+            }\n             if (rs.next())\n                 return rs.getLong(1);\n "},{"sha":"8a5bef5ea7c602d857e7532d942028cbb6c9a059","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","status":"modified","additions":14,"deletions":1,"changes":15,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/PessimisticLockManager.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -187,7 +187,20 @@ protected void setTimeout(PreparedStatement stmnt, int timeout)\n                 if (log.isWarnEnabled())\n                     log.warn(_loc.get(\"millis-query-timeout\"));\n             }\n-            stmnt.setQueryTimeout(timeout / 1000);\n+            try { \n+                stmnt.setQueryTimeout(timeout / 1000);\n+            }\n+            catch(SQLException e) { \n+                if(! dict.ignoreSQLExceptionOnSetQueryTimeout) { \n+                    throw e;\n+                }\n+                else { \n+                    if (log.isTraceEnabled()) {\n+                        log.trace(_loc.get(\"error-setting-query-timeout\",\n+                            timeout, e.getMessage()), e);\n+                    }\n+                }\n+            }\n         }\n     }\n     "},{"sha":"6a444257211adcda1fe20a2a7e7d81bdcd2fdadb","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/JDBCExpressionFactory.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -218,9 +218,12 @@ public Expression matches(Value v1, Value v2,\n         String single, String multi, String esc) {\n         if (!(v2 instanceof Const))\n             throw new UserException(_loc.get(\"const-only\", \"matches\"));\n-        return new MatchesExpression((Val) v1, (Const) v2, single, multi,\n-            esc != null ? esc : _type.getMappingRepository().\n-                getDBDictionary().searchStringEscape);\n+        if (esc == null && _type.getMappingRepository().\n+                getDBDictionary().requiresSearchStringEscapeForLike == true) { \n+            esc = _type.getMappingRepository().\n+                getDBDictionary().searchStringEscape;\n+        }        \n+        return new MatchesExpression((Val) v1, (Const) v2, single, multi, esc);\n     }\n \n     public Subquery newSubquery(ClassMetaData candidate, boolean subs,"},{"sha":"82fce7277ab19dcefb8e3ff3a70072b26fbe653b","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToLowerCase.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -43,7 +43,11 @@ public void appendTo(Select sel, ExpContext ctx, ExpState state,\n         DBDictionary dict = ctx.store.getDBDictionary();\n         String func = dict.toLowerCaseFunction;\n         dict.assertSupport(func != null, \"ToLowerCaseFunction\");\n-        func = dict.getCastFunction(getValue(), func);\n+        if (getValue() instanceof PCPath) {\n+            func = dict.getCastFunction(getValue(), func, ((PCPath) getValue()).getFieldMapping(state).getColumns()[0]);\n+        } else {\n+            func = dict.getCastFunction(getValue(), func);\n+        }\n \n         int idx = func.indexOf(\"{0}\");\n         buf.append(func.substring(0, idx));"},{"sha":"3914ff1e40457795c42c171da2855d92575c3091","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java","status":"modified","additions":5,"deletions":1,"changes":6,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/kernel/exps/ToUpperCase.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -43,7 +43,11 @@ public void appendTo(Select sel, ExpContext ctx, ExpState state,\n         DBDictionary dict = ctx.store.getDBDictionary();\n         String func = dict.toUpperCaseFunction;\n         dict.assertSupport(func != null, \"ToUpperCaseFunction\");\n-        func = dict.getCastFunction(getValue(), func);\n+        if (getValue() instanceof PCPath) {\n+            func = dict.getCastFunction(getValue(), func, ((PCPath) getValue()).getFieldMapping(state).getColumns()[0]);\n+        } else {\n+            func = dict.getCastFunction(getValue(), func);\n+        }\n \n         int idx = func.indexOf(\"{0}\");\n         buf.append(func.substring(0, idx));"},{"sha":"84e8a6ead042513062e03274f7a05a93506d6a2a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","status":"modified","additions":7,"deletions":5,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/ClassMapping.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -22,13 +22,12 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashMap;\n import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import org.apache.openjpa.enhance.PersistenceCapable;\n import org.apache.openjpa.enhance.Reflection;\n@@ -88,7 +87,7 @@\n     private ClassMapping[] _assignMaps = null;\n \n     // maps columns to joinables\n-    private final Map _joinables = Collections.synchronizedMap(new HashMap());\n+    private final Map _joinables = new ConcurrentHashMap();\n \n     /**\n      * Constructor. Supply described type and owning repository.\n@@ -173,6 +172,7 @@ private Object getObjectId(ClassMapping cls, JDBCStore store, Result res,\n         FieldMapping fm;\n         Joinable join;\n         int pkIdx;\n+        boolean isNullPK = true;\n         for (int i = 0; i < pks.length; i++) {\n             // we know that all pk column join mappings use primary key fields,\n             // cause this mapping uses the oid as its primary key (we recursed\n@@ -187,10 +187,12 @@ private Object getObjectId(ClassMapping cls, JDBCStore store, Result res,\n                 vals[pkIdx] = join.getPrimaryKeyValue(res, join.getColumns(),\n                     fk, store, joins);\n                 res.endDataRequest();\n-                if (vals[pkIdx] == null)\n-                    return null;\n+                isNullPK = isNullPK && vals[pkIdx] == null;\n             }\n         }\n+        if (isNullPK) {\n+            return null;\n+        }\n \n         // the oid data is loaded by the base type, but if discriminator data\n         // is present, make sure to use it to construct the actual oid instance"},{"sha":"72f633a67cefcb430abc2cf3c12a0ccdb192f141","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","status":"modified","additions":108,"deletions":29,"changes":137,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/MappingRepository.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -143,7 +143,15 @@ public void setMappingDefaults(MappingDefaults defaults) {\n     /**\n      * Representation of the database schema.\n      */\n-    public synchronized SchemaGroup getSchemaGroup() {\n+    public SchemaGroup getSchemaGroup() {\n+        if(_locking){\n+            synchronized(this){\n+                if (_schema == null)\n+                    _schema = ((JDBCConfiguration) getConfiguration()).\n+                        getSchemaFactoryInstance().readSchema();\n+                return _schema;                \n+            }\n+        }\n         if (_schema == null)\n             _schema = ((JDBCConfiguration) getConfiguration()).\n                 getSchemaFactoryInstance().readSchema();\n@@ -153,33 +161,59 @@ public synchronized SchemaGroup getSchemaGroup() {\n     /**\n      * Representation of the database schema.\n      */\n-    public synchronized void setSchemaGroup(SchemaGroup schema) {\n-        _schema = schema;\n+    public void setSchemaGroup(SchemaGroup schema) {\n+        if (_locking) {\n+            synchronized (this) {\n+                _schema = schema;\n+            }\n+        } else {\n+            _schema = schema;\n+        }\n     }\n \n     /**\n      * Installs mapping strategies on components.\n      */\n-    public synchronized StrategyInstaller getStrategyInstaller() {\n-        if (_installer == null)\n-            _installer = new RuntimeStrategyInstaller(this);\n-        return _installer;\n+    public StrategyInstaller getStrategyInstaller() {\n+        if (_locking) {\n+            synchronized (this) {\n+                if (_installer == null)\n+                    _installer = new RuntimeStrategyInstaller(this);\n+                return _installer;\n+            }\n+        } else {\n+            if (_installer == null)\n+                _installer = new RuntimeStrategyInstaller(this);\n+            return _installer;\n+        }\n     }\n \n     /**\n      * Installs mapping strategies on components.\n      */\n-    public synchronized void setStrategyInstaller(StrategyInstaller installer) {\n-        _installer = installer;\n+    public void setStrategyInstaller(StrategyInstaller installer) {\n+        if (_locking) {\n+            synchronized (this) {\n+                _installer = installer;\n+            }\n+        } else {\n+            _installer = installer;\n+        }\n     }\n \n     /**\n      * Return the query result mapping for the given name.\n      */\n-    public synchronized QueryResultMapping getQueryResultMapping(Class cls,\n+    public QueryResultMapping getQueryResultMapping(Class cls,\n         String name, ClassLoader envLoader, boolean mustExist) {\n-        QueryResultMapping res = getQueryResultMappingInternal(cls, name,\n-            envLoader);\n+        QueryResultMapping res = null;\n+        if (_locking) {\n+            synchronized (this) {\n+                res = getQueryResultMappingInternal(cls, name, envLoader);\n+            }\n+        } else {\n+            res = getQueryResultMappingInternal(cls, name, envLoader);\n+        }\n         if (res == null && mustExist)\n             throw new MetaDataException(_loc.get(\"no-query-res\", cls, name));\n         return res;\n@@ -219,26 +253,49 @@ private QueryResultMapping getQueryResultMappingInternal(Class cls,\n     /**\n      * Return all cached query result mappings.\n      */\n-    public synchronized QueryResultMapping[] getQueryResultMappings() {\n-        Collection values = _results.values();\n-        return (QueryResultMapping[]) values.toArray\n-            (new QueryResultMapping[values.size()]);\n+    public QueryResultMapping[] getQueryResultMappings() {\n+        if (_locking) {\n+            synchronized (this) {\n+                Collection values = _results.values();\n+                return (QueryResultMapping[]) values.toArray(new QueryResultMapping[values.size()]);\n+            }\n+        } else {\n+            Collection values = _results.values();\n+            return (QueryResultMapping[]) values.toArray(new QueryResultMapping[values.size()]);\n+        }\n     }\n \n     /**\n      * Return the cached query result mapping with the given name, or null if\n      * none.\n      */\n-    public synchronized QueryResultMapping getCachedQueryResultMapping\n+    public QueryResultMapping getCachedQueryResultMapping\n         (Class cls, String name) {\n-        return (QueryResultMapping) _results.get(getQueryResultKey(cls, name));\n+        if (_locking) {\n+            synchronized (this) {\n+                return (QueryResultMapping) _results.get(getQueryResultKey(cls, name));\n+            }\n+        } else {\n+            return (QueryResultMapping) _results.get(getQueryResultKey(cls, name));\n+        }\n     }\n \n     /**\n      * Add a query result mapping.\n      */\n-    public synchronized QueryResultMapping addQueryResultMapping(Class cls,\n+    public QueryResultMapping addQueryResultMapping(Class cls,\n         String name) {\n+        if (_locking) {\n+            return addQueryResultMappingLocking(cls, name);\n+        } else {\n+            return addQueryResultMappingInternal(cls, name);\n+        }\n+    }\n+    private synchronized QueryResultMapping addQueryResultMappingLocking(Class cls, String name) {\n+        return addQueryResultMappingInternal(cls, name);\n+    }\n+\n+    private QueryResultMapping addQueryResultMappingInternal(Class cls, String name) {\n         QueryResultMapping res = new QueryResultMapping(name, this);\n         res.setDefiningType(cls);\n         _results.put(getQueryResultKey(res), res);\n@@ -248,19 +305,33 @@ public synchronized QueryResultMapping addQueryResultMapping(Class cls,\n     /**\n      * Remove a query result mapping.\n      */\n-    public synchronized boolean removeQueryResultMapping\n+    public boolean removeQueryResultMapping\n         (QueryResultMapping res) {\n-        return _results.remove(getQueryResultKey(res)) != null;\n+        if (_locking) {\n+            synchronized (this) {\n+                return _results.remove(getQueryResultKey(res)) != null;\n+            }\n+        } else {\n+            return _results.remove(getQueryResultKey(res)) != null;\n+        }\n     }\n \n     /**\n      * Remove a query result mapping.\n      */\n-    public synchronized boolean removeQueryResultMapping(Class cls,\n+    public boolean removeQueryResultMapping(Class cls,\n         String name) {\n-        if (name == null)\n-            return false;\n-        return _results.remove(getQueryResultKey(cls, name)) != null;\n+        if (_locking) {\n+            synchronized (this) {\n+                if (name == null)\n+                    return false;\n+                return _results.remove(getQueryResultKey(cls, name)) != null;\n+            }\n+        } else {\n+            if (name == null)\n+                return false;\n+            return _results.remove(getQueryResultKey(cls, name)) != null;\n+        }\n     }\n \n     /**\n@@ -300,10 +371,18 @@ public ClassMapping getMapping(Object oid, ClassLoader envLoader,\n             mustExist);\n     }\n \n-    public synchronized void clear() {\n-        super.clear();\n-        _schema = null;\n-        _results.clear();\n+    public void clear() {\n+        if (_locking) {\n+            synchronized (this) {\n+                super.clear();\n+                _schema = null;\n+                _results.clear();\n+            }\n+        } else {\n+            super.clear();\n+            _schema = null;\n+            _results.clear();\n+        }\n     }\n \n     protected void prepareMapping(ClassMetaData meta) {"},{"sha":"0559d61e68a53bf8b9035b949ec244ae7d28c8ee","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java","status":"modified","additions":183,"deletions":183,"changes":366,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/ElementEmbedValueHandler.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,183 +1,183 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.lib.util.*;\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.util.*;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-\r\n-/**\r\n- * <p>Handler for embedded objects as elements of a collection or map.  For\r\n- * embedded objects as fields, use the more powerful\r\n- * {@link EmbedFieldStrategy}.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- * @nojavadoc\r\n- */\r\n-public class ElementEmbedValueHandler\r\n-    extends EmbedValueHandler\r\n-    implements RelationId {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (ElementEmbedValueHandler.class);\r\n-\r\n-    private ValueMapping _vm = null;\r\n-    private Column[] _cols = null;\r\n-    private Object[] _args = null;\r\n-    private int _nullIdx = -1;\r\n-    private boolean _synthetic = false;\r\n-\r\n-    public Column[] map(ValueMapping vm, String name, ColumnIO io,\r\n-        boolean adapt) {\r\n-        LinkedList cols = new LinkedList();\r\n-        LinkedList args = new LinkedList();\r\n-        super.map(vm, name, io, adapt, cols, args);\r\n-\r\n-        ValueMappingInfo vinfo = vm.getValueInfo();\r\n-        Column nullInd = vinfo.getNullIndicatorColumn(vm, name,\r\n-            vm.getFieldMapping().getTable(), adapt);\r\n-        if (nullInd != null)\r\n-            vm.setColumns(new Column[]{ nullInd });\r\n-\r\n-        // record index of null indicator column and whether it is synthetic\r\n-        if (nullInd != null) {\r\n-            _nullIdx = cols.indexOf(nullInd);\r\n-            if (_nullIdx == -1) {\r\n-                cols.addFirst(nullInd);\r\n-                args.addFirst(null);\r\n-                _nullIdx = 0;\r\n-                _synthetic = true;\r\n-            }\r\n-        }\r\n-\r\n-        _vm = vm;\r\n-        _cols = (Column[]) cols.toArray(new Column[cols.size()]);\r\n-        _args = args.toArray();\r\n-        return _cols;\r\n-    }\r\n-\r\n-    public boolean objectValueRequiresLoad(ValueMapping vm) {\r\n-        return true;\r\n-    }\r\n-\r\n-    public Object getResultArgument(ValueMapping vm) {\r\n-        return _args;\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(ValueMapping vm, Object val,\r\n-        JDBCStore store) {\r\n-        OpenJPAStateManager em = store.getContext().getStateManager(val);\r\n-        Object rval = null;\r\n-        if (_cols.length > 1)\r\n-            rval = new Object[_cols.length];\r\n-\r\n-        // set null indicator column\r\n-        int idx = 0;\r\n-        if (_synthetic) {\r\n-            Object cval = ((EmbeddedClassStrategy) vm.getEmbeddedMapping().\r\n-                getStrategy()).getNullIndicatorValue(em);\r\n-            if (_cols.length == 1)\r\n-                return cval;\r\n-            ((Object[]) rval)[idx++] = cval;\r\n-        }\r\n-\r\n-        return super.toDataStoreValue(em, vm, store, _cols, rval, idx);\r\n-    }\r\n-\r\n-    public Object toObjectValue(ValueMapping vm, Object val,\r\n-        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch)\r\n-        throws SQLException {\r\n-        if (sm == null)\r\n-            throw new InvalidStateException(_loc.get(\"cant-project-owned\",\r\n-                vm));\r\n-\r\n-        // check null indicator first\r\n-        if (_nullIdx != -1) {\r\n-            Object nval;\r\n-            if (_cols.length == 1)\r\n-                nval = val;\r\n-            else\r\n-                nval = ((Object[]) val)[_nullIdx];\r\n-            if (((EmbeddedClassStrategy) vm.getEmbeddedMapping().\r\n-                getStrategy()).indicatesNull(nval))\r\n-                return null;\r\n-        }\r\n-\r\n-        // create embedded instance\r\n-        OpenJPAStateManager em = store.getContext().embed(null, null, sm, vm);\r\n-        int idx = (_synthetic) ? 1 : 0;\r\n-        super.toObjectValue(em, vm, val, store, fetch, _cols, idx);\r\n-\r\n-        // after loading everything from result, load the rest of the\r\n-        // configured fields\r\n-        em.load(fetch);\r\n-        return em.getManagedInstance();\r\n-    }\r\n-\r\n-    /////////////////////////////\r\n-    // RelationId implementation\r\n-    /////////////////////////////\r\n-\r\n-    public Object toRelationDataStoreValue(OpenJPAStateManager sm, Column col) {\r\n-        return toRelationDataStoreValue(sm, col, 0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Recursive helper.\r\n-     */\r\n-    private Object toRelationDataStoreValue(OpenJPAStateManager sm, Column col,\r\n-        int idx) {\r\n-        FieldMapping field = findField(col, idx);\r\n-        if (field == null)\r\n-            throw new InternalException();\r\n-\r\n-        if (field.getHandler() instanceof RelationId)\r\n-            return ((RelationId) field.getStrategy()).\r\n-                toRelationDataStoreValue(sm, col);\r\n-        if (field.getStrategy() instanceof RelationId)\r\n-            return ((RelationId) field.getStrategy()).\r\n-                toRelationDataStoreValue(sm, col);\r\n-        return toRelationDataStoreValue(sm, col, field.getIndex() + 1);\r\n-    }\r\n-\r\n-    /**\r\n-     * Find the first field mapping that uses the given column starting with\r\n-     * the given field index.\r\n-     */\r\n-    private FieldMapping findField(Column col, int idx) {\r\n-        FieldMapping[] fms = _vm.getEmbeddedMapping().getFieldMappings();\r\n-        Column[] cols;\r\n-        for (int i = idx; i < fms.length; i++) {\r\n-            if (fms[i].getManagement() != FieldMapping.MANAGE_PERSISTENT)\r\n-                continue;\r\n-            cols = ((Embeddable) fms[i]).getColumns();\r\n-            for (int j = 0; j < cols.length; j++)\r\n-                if (cols[j] == col)\r\n-                    return fms[i];\r\n-        }\r\n-        return null;\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.util.*;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+\n+/**\n+ * <p>Handler for embedded objects as elements of a collection or map.  For\n+ * embedded objects as fields, use the more powerful\n+ * {@link EmbedFieldStrategy}.</p>\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ * @nojavadoc\n+ */\n+public class ElementEmbedValueHandler\n+    extends EmbedValueHandler\n+    implements RelationId {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (ElementEmbedValueHandler.class);\n+\n+    private ValueMapping _vm = null;\n+    private Column[] _cols = null;\n+    private Object[] _args = null;\n+    private int _nullIdx = -1;\n+    private boolean _synthetic = false;\n+\n+    public Column[] map(ValueMapping vm, String name, ColumnIO io,\n+        boolean adapt) {\n+        LinkedList cols = new LinkedList();\n+        LinkedList args = new LinkedList();\n+        super.map(vm, name, io, adapt, cols, args);\n+\n+        ValueMappingInfo vinfo = vm.getValueInfo();\n+        Column nullInd = vinfo.getNullIndicatorColumn(vm, name,\n+            vm.getFieldMapping().getTable(), adapt);\n+        if (nullInd != null)\n+            vm.setColumns(new Column[]{ nullInd });\n+\n+        // record index of null indicator column and whether it is synthetic\n+        if (nullInd != null) {\n+            _nullIdx = cols.indexOf(nullInd);\n+            if (_nullIdx == -1) {\n+                cols.addFirst(nullInd);\n+                args.addFirst(null);\n+                _nullIdx = 0;\n+                _synthetic = true;\n+            }\n+        }\n+\n+        _vm = vm;\n+        _cols = (Column[]) cols.toArray(new Column[cols.size()]);\n+        _args = args.toArray();\n+        return _cols;\n+    }\n+\n+    public boolean objectValueRequiresLoad(ValueMapping vm) {\n+        return true;\n+    }\n+\n+    public Object getResultArgument(ValueMapping vm) {\n+        return _args;\n+    }\n+\n+    public Object toDataStoreValue(ValueMapping vm, Object val,\n+        JDBCStore store) {\n+        OpenJPAStateManager em = store.getContext().getStateManager(val);\n+        Object rval = null;\n+        if (_cols.length > 1)\n+            rval = new Object[_cols.length];\n+\n+        // set null indicator column\n+        int idx = 0;\n+        if (_synthetic) {\n+            Object cval = ((EmbeddedClassStrategy) vm.getEmbeddedMapping().\n+                getStrategy()).getNullIndicatorValue(em);\n+            if (_cols.length == 1)\n+                return cval;\n+            ((Object[]) rval)[idx++] = cval;\n+        }\n+\n+        return super.toDataStoreValue(em, vm, store, _cols, rval, idx);\n+    }\n+\n+    public Object toObjectValue(ValueMapping vm, Object val,\n+        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch)\n+        throws SQLException {\n+        if (sm == null)\n+            throw new InvalidStateException(_loc.get(\"cant-project-owned\",\n+                vm));\n+\n+        // check null indicator first\n+        if (_nullIdx != -1) {\n+            Object nval;\n+            if (_cols.length == 1)\n+                nval = val;\n+            else\n+                nval = ((Object[]) val)[_nullIdx];\n+            if (((EmbeddedClassStrategy) vm.getEmbeddedMapping().\n+                getStrategy()).indicatesNull(nval))\n+                return null;\n+        }\n+\n+        // create embedded instance\n+        OpenJPAStateManager em = store.getContext().embed(null, null, sm, vm);\n+        int idx = (_synthetic) ? 1 : 0;\n+        super.toObjectValue(em, vm, val, store, fetch, _cols, idx);\n+\n+        // after loading everything from result, load the rest of the\n+        // configured fields\n+        em.load(fetch);\n+        return em.getManagedInstance();\n+    }\n+\n+    /////////////////////////////\n+    // RelationId implementation\n+    /////////////////////////////\n+\n+    public Object toRelationDataStoreValue(OpenJPAStateManager sm, Column col) {\n+        return toRelationDataStoreValue(sm, col, 0);\n+    }\n+\n+    /**\n+     * Recursive helper.\n+     */\n+    private Object toRelationDataStoreValue(OpenJPAStateManager sm, Column col,\n+        int idx) {\n+        FieldMapping field = findField(col, idx);\n+        if (field == null)\n+            throw new InternalException();\n+\n+        if (field.getHandler() instanceof RelationId)\n+            return ((RelationId) field.getStrategy()).\n+                toRelationDataStoreValue(sm, col);\n+        if (field.getStrategy() instanceof RelationId)\n+            return ((RelationId) field.getStrategy()).\n+                toRelationDataStoreValue(sm, col);\n+        return toRelationDataStoreValue(sm, col, field.getIndex() + 1);\n+    }\n+\n+    /**\n+     * Find the first field mapping that uses the given column starting with\n+     * the given field index.\n+     */\n+    private FieldMapping findField(Column col, int idx) {\n+        FieldMapping[] fms = _vm.getEmbeddedMapping().getFieldMappings();\n+        Column[] cols;\n+        for (int i = idx; i < fms.length; i++) {\n+            if (fms[i].getManagement() != FieldMapping.MANAGE_PERSISTENT)\n+                continue;\n+            cols = ((Embeddable) fms[i]).getColumns();\n+            for (int j = 0; j < cols.length; j++)\n+                if (cols[j] == col)\n+                    return fms[i];\n+        }\n+        return null;\n+\t}\n+}"},{"sha":"dd15e30c548420973c17eae46d888e15c4873b8c","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java","status":"modified","additions":250,"deletions":250,"changes":500,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerCollectionTableFieldStrategy.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,250 +1,250 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.lib.util.*;\r\n-\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.util.*;\r\n-import org.apache.openjpa.meta.*;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-import org.apache.openjpa.jdbc.sql.*;\r\n-\r\n-/**\r\n- * <p>Mapping for a collection of values in a separate table controlled by a\r\n- * {@link ValueHandler}.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- */\r\n-public class HandlerCollectionTableFieldStrategy\r\n-    extends StoreCollectionFieldStrategy\r\n-    implements LRSCollectionFieldStrategy {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (HandlerCollectionTableFieldStrategy.class);\r\n-\r\n-    private Column[] _cols = null;\r\n-    private ColumnIO _io = null;\r\n-    private boolean _load = false;\r\n-    private boolean _lob = false;\r\n-    private boolean _embed = false;\r\n-\r\n-    public FieldMapping getFieldMapping() {\r\n-        return field;\r\n-    }\r\n-\r\n-    public ClassMapping[] getIndependentElementMappings(boolean traverse) {\r\n-        return ClassMapping.EMPTY_MAPPINGS;\r\n-    }\r\n-\r\n-    public Column[] getElementColumns(ClassMapping elem) {\r\n-        return _cols;\r\n-    }\r\n-\r\n-    public ForeignKey getJoinForeignKey(ClassMapping elem) {\r\n-        return field.getJoinForeignKey();\r\n-    }\r\n-\r\n-    public void selectElement(Select sel, ClassMapping elem, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, int eagerMode, Joins joins) {\r\n-        sel.select(_cols, joins);\r\n-    }\r\n-\r\n-    public Object loadElement(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        return HandlerStrategies.loadObject(field.getElementMapping(),\r\n-            sm, store, fetch, res, joins, _cols, _load);\r\n-    }\r\n-\r\n-    protected Joins join(Joins joins, ClassMapping elem) {\r\n-        return join(joins, false);\r\n-    }\r\n-\r\n-    public Joins joinElementRelation(Joins joins, ClassMapping elem) {\r\n-        return joinRelation(joins, false, false);\r\n-    }\r\n-\r\n-    protected Proxy newLRSProxy() {\r\n-        return new LRSProxyCollection(this);\r\n-    }\r\n-\r\n-    public void map(boolean adapt) {\r\n-        if (field.getTypeCode() != JavaTypes.COLLECTION\r\n-            && field.getTypeCode() != JavaTypes.ARRAY)\r\n-            throw new MetaDataException(_loc.get(\"not-coll\", field));\r\n-\r\n-        assertNotMappedBy();\r\n-        field.getValueInfo().assertNoSchemaComponents(field, !adapt);\r\n-        field.getKeyMapping().getValueInfo().assertNoSchemaComponents\r\n-            (field.getKey(), !adapt);\r\n-\r\n-        ValueMapping elem = field.getElementMapping();\r\n-        if (elem.getHandler() == null)\r\n-            throw new MetaDataException(_loc.get(\"no-handler\", elem));\r\n-\r\n-        field.mapJoin(adapt, true);\r\n-        _io = new ColumnIO();\r\n-        _cols = HandlerStrategies.map(elem, \"element\", _io, adapt);\r\n-\r\n-        FieldMappingInfo finfo = field.getMappingInfo();\r\n-        Column orderCol = finfo.getOrderColumn(field, field.getTable(), adapt);\r\n-        field.setOrderColumn(orderCol);\r\n-        field.setOrderColumnIO(finfo.getColumnIO());\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    public void initialize() {\r\n-        for (int i = 0; !_lob && i < _cols.length; i++)\r\n-            _lob = _cols[i].isLob();\r\n-\r\n-        ValueMapping elem = field.getElementMapping();\r\n-        _embed = elem.getEmbeddedMetaData() != null;\r\n-        _load = elem.getHandler().objectValueRequiresLoad(elem);\r\n-    }\r\n-\r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        insert(sm, store, rm, sm.fetchObject(field.getIndex()));\r\n-    }\r\n-\r\n-    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\r\n-        Object vals)\r\n-        throws SQLException {\r\n-        Collection coll;\r\n-        if (field.getTypeCode() == JavaTypes.ARRAY)\r\n-            coll = JavaTypes.toList(vals, field.getElement().getType(),\r\n-                false);\r\n-        else\r\n-            coll = (Collection) vals;\r\n-        if (coll == null || coll.isEmpty())\r\n-            return;\r\n-\r\n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\r\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\r\n-            sm);\r\n-\r\n-        ValueMapping elem = field.getElementMapping();\r\n-        Column order = field.getOrderColumn();\r\n-        boolean setOrder = field.getOrderColumnIO().isInsertable(order, false);\r\n-        int idx = 0;\r\n-        for (Iterator itr = coll.iterator(); itr.hasNext(); idx++) {\r\n-            HandlerStrategies.set(elem, itr.next(), store, row, _cols,\r\n-                _io, true);\r\n-            if (setOrder)\r\n-                row.setInt(order, idx);\r\n-            rm.flushSecondaryRow(row);\r\n-        }\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Object obj = sm.fetchObject(field.getIndex());\r\n-        ChangeTracker ct = null;\r\n-        if (obj instanceof Proxy) {\r\n-            Proxy proxy = (Proxy) obj;\r\n-            if (Proxies.isOwner(proxy, sm, field.getIndex()))\r\n-                ct = proxy.getChangeTracker();\r\n-        }\r\n-\r\n-        // if no fine-grained change tracking then just delete and reinsert\r\n-        if (ct == null || !ct.isTracking()) {\r\n-            delete(sm, store, rm);\r\n-            insert(sm, store, rm, obj);\r\n-            return;\r\n-        }\r\n-\r\n-        // delete the removes\r\n-        ValueMapping elem = field.getElementMapping();\r\n-        Collection rem = ct.getRemoved();\r\n-        if (!rem.isEmpty()) {\r\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_DELETE);\r\n-            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-            for (Iterator itr = rem.iterator(); itr.hasNext();) {\r\n-                HandlerStrategies.where(elem, itr.next(), store, delRow,\r\n-                    _cols);\r\n-                rm.flushSecondaryRow(delRow);\r\n-            }\r\n-        }\r\n-\r\n-        // insert the adds\r\n-        Collection add = ct.getAdded();\r\n-        if (!add.isEmpty()) {\r\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_INSERT);\r\n-            addRow.setForeignKey(field.getJoinForeignKey(),\r\n-                field.getJoinColumnIO(), sm);\r\n-\r\n-            int seq = ct.getNextSequence();\r\n-            Column order = field.getOrderColumn();\r\n-            boolean setOrder = field.getOrderColumnIO().isInsertable(order,\r\n-                false);\r\n-            for (Iterator itr = add.iterator(); itr.hasNext(); seq++) {\r\n-                HandlerStrategies.set(elem, itr.next(), store, addRow, _cols,\r\n-                    _io, true);\r\n-                if (setOrder)\r\n-                    addRow.setInt(order, seq);\r\n-                rm.flushSecondaryRow(addRow);\r\n-            }\r\n-            if (order != null)\r\n-                ct.setNextSequence(seq);\r\n-        }\r\n-    }\r\n-\r\n-    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Row row = rm.getAllRows(field.getTable(), Row.ACTION_DELETE);\r\n-        row.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-        rm.flushAllRows(row);\r\n-    }\r\n-\r\n-    public int supportsSelect(Select sel, int type, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch) {\r\n-        // can't do any combined select with lobs, since they don't allow\r\n-        // select distinct.  cant select eager parallel on embedded, because\r\n-        // during parallel result processing the owning sm won't be available\r\n-        // for each elem\r\n-        if (_lob || (_embed && type == Select.EAGER_PARALLEL))\r\n-            return 0;\r\n-        return super.supportsSelect(sel, type, sm, store, fetch);\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\r\n-        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\r\n-            val, _cols, store);\r\n-    }\r\n-\r\n-    public Joins join(Joins joins, boolean forceOuter) {\r\n-        return field.join(joins, forceOuter, true);\r\n-    }\r\n-\r\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        if (traverse)\r\n-            HandlerStrategies.assertJoinable(field.getElementMapping());\r\n-        return joins;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.util.*;\n+import org.apache.openjpa.meta.*;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+import org.apache.openjpa.jdbc.sql.*;\n+\n+/**\n+ * <p>Mapping for a collection of values in a separate table controlled by a\n+ * {@link ValueHandler}.</p>\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ */\n+public class HandlerCollectionTableFieldStrategy\n+    extends StoreCollectionFieldStrategy\n+    implements LRSCollectionFieldStrategy {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (HandlerCollectionTableFieldStrategy.class);\n+\n+    private Column[] _cols = null;\n+    private ColumnIO _io = null;\n+    private boolean _load = false;\n+    private boolean _lob = false;\n+    private boolean _embed = false;\n+\n+    public FieldMapping getFieldMapping() {\n+        return field;\n+    }\n+\n+    public ClassMapping[] getIndependentElementMappings(boolean traverse) {\n+        return ClassMapping.EMPTY_MAPPINGS;\n+    }\n+\n+    public Column[] getElementColumns(ClassMapping elem) {\n+        return _cols;\n+    }\n+\n+    public ForeignKey getJoinForeignKey(ClassMapping elem) {\n+        return field.getJoinForeignKey();\n+    }\n+\n+    public void selectElement(Select sel, ClassMapping elem, JDBCStore store,\n+        JDBCFetchConfiguration fetch, int eagerMode, Joins joins) {\n+        sel.select(_cols, joins);\n+    }\n+\n+    public Object loadElement(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        return HandlerStrategies.loadObject(field.getElementMapping(),\n+            sm, store, fetch, res, joins, _cols, _load);\n+    }\n+\n+    protected Joins join(Joins joins, ClassMapping elem) {\n+        return join(joins, false);\n+    }\n+\n+    public Joins joinElementRelation(Joins joins, ClassMapping elem) {\n+        return joinRelation(joins, false, false);\n+    }\n+\n+    protected Proxy newLRSProxy() {\n+        return new LRSProxyCollection(this);\n+    }\n+\n+    public void map(boolean adapt) {\n+        if (field.getTypeCode() != JavaTypes.COLLECTION\n+            && field.getTypeCode() != JavaTypes.ARRAY)\n+            throw new MetaDataException(_loc.get(\"not-coll\", field));\n+\n+        assertNotMappedBy();\n+        field.getValueInfo().assertNoSchemaComponents(field, !adapt);\n+        field.getKeyMapping().getValueInfo().assertNoSchemaComponents\n+            (field.getKey(), !adapt);\n+\n+        ValueMapping elem = field.getElementMapping();\n+        if (elem.getHandler() == null)\n+            throw new MetaDataException(_loc.get(\"no-handler\", elem));\n+\n+        field.mapJoin(adapt, true);\n+        _io = new ColumnIO();\n+        _cols = HandlerStrategies.map(elem, \"element\", _io, adapt);\n+\n+        FieldMappingInfo finfo = field.getMappingInfo();\n+        Column orderCol = finfo.getOrderColumn(field, field.getTable(), adapt);\n+        field.setOrderColumn(orderCol);\n+        field.setOrderColumnIO(finfo.getColumnIO());\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    public void initialize() {\n+        for (int i = 0; !_lob && i < _cols.length; i++)\n+            _lob = _cols[i].isLob();\n+\n+        ValueMapping elem = field.getElementMapping();\n+        _embed = elem.getEmbeddedMetaData() != null;\n+        _load = elem.getHandler().objectValueRequiresLoad(elem);\n+    }\n+\n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        insert(sm, store, rm, sm.fetchObject(field.getIndex()));\n+    }\n+\n+    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n+        Object vals)\n+        throws SQLException {\n+        Collection coll;\n+        if (field.getTypeCode() == JavaTypes.ARRAY)\n+            coll = JavaTypes.toList(vals, field.getElement().getType(),\n+                false);\n+        else\n+            coll = (Collection) vals;\n+        if (coll == null || coll.isEmpty())\n+            return;\n+\n+        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n+        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n+            sm);\n+\n+        ValueMapping elem = field.getElementMapping();\n+        Column order = field.getOrderColumn();\n+        boolean setOrder = field.getOrderColumnIO().isInsertable(order, false);\n+        int idx = 0;\n+        for (Iterator itr = coll.iterator(); itr.hasNext(); idx++) {\n+            HandlerStrategies.set(elem, itr.next(), store, row, _cols,\n+                _io, true);\n+            if (setOrder)\n+                row.setInt(order, idx);\n+            rm.flushSecondaryRow(row);\n+        }\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Object obj = sm.fetchObject(field.getIndex());\n+        ChangeTracker ct = null;\n+        if (obj instanceof Proxy) {\n+            Proxy proxy = (Proxy) obj;\n+            if (Proxies.isOwner(proxy, sm, field.getIndex()))\n+                ct = proxy.getChangeTracker();\n+        }\n+\n+        // if no fine-grained change tracking then just delete and reinsert\n+        if (ct == null || !ct.isTracking()) {\n+            delete(sm, store, rm);\n+            insert(sm, store, rm, obj);\n+            return;\n+        }\n+\n+        // delete the removes\n+        ValueMapping elem = field.getElementMapping();\n+        Collection rem = ct.getRemoved();\n+        if (!rem.isEmpty()) {\n+            Row delRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_DELETE);\n+            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+            for (Iterator itr = rem.iterator(); itr.hasNext();) {\n+                HandlerStrategies.where(elem, itr.next(), store, delRow,\n+                    _cols);\n+                rm.flushSecondaryRow(delRow);\n+            }\n+        }\n+\n+        // insert the adds\n+        Collection add = ct.getAdded();\n+        if (!add.isEmpty()) {\n+            Row addRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_INSERT);\n+            addRow.setForeignKey(field.getJoinForeignKey(),\n+                field.getJoinColumnIO(), sm);\n+\n+            int seq = ct.getNextSequence();\n+            Column order = field.getOrderColumn();\n+            boolean setOrder = field.getOrderColumnIO().isInsertable(order,\n+                false);\n+            for (Iterator itr = add.iterator(); itr.hasNext(); seq++) {\n+                HandlerStrategies.set(elem, itr.next(), store, addRow, _cols,\n+                    _io, true);\n+                if (setOrder)\n+                    addRow.setInt(order, seq);\n+                rm.flushSecondaryRow(addRow);\n+            }\n+            if (order != null)\n+                ct.setNextSequence(seq);\n+        }\n+    }\n+\n+    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Row row = rm.getAllRows(field.getTable(), Row.ACTION_DELETE);\n+        row.whereForeignKey(field.getJoinForeignKey(), sm);\n+        rm.flushAllRows(row);\n+    }\n+\n+    public int supportsSelect(Select sel, int type, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch) {\n+        // can't do any combined select with lobs, since they don't allow\n+        // select distinct.  cant select eager parallel on embedded, because\n+        // during parallel result processing the owning sm won't be available\n+        // for each elem\n+        if (_lob || (_embed && type == Select.EAGER_PARALLEL))\n+            return 0;\n+        return super.supportsSelect(sel, type, sm, store, fetch);\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\n+            val, _cols, store);\n+    }\n+\n+    public Joins join(Joins joins, boolean forceOuter) {\n+        return field.join(joins, forceOuter, true);\n+    }\n+\n+    public Joins joinRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        if (traverse)\n+            HandlerStrategies.assertJoinable(field.getElementMapping());\n+        return joins;\n+    }\n+}"},{"sha":"0fed898fe8195931a9d1971a2d953046b9f7cb1a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","status":"modified","additions":246,"deletions":246,"changes":492,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerHandlerMapTableFieldStrategy.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,246 +1,246 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-import org.apache.openjpa.jdbc.sql.*;\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.lib.util.*;\r\n-import org.apache.openjpa.util.*;\r\n-\r\n-/**\r\n- * Mapping for a map of keys and values both controlled by\r\n- * {@link ValueHandler}s.\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- */\r\n-public class HandlerHandlerMapTableFieldStrategy\r\n-    extends MapTableFieldStrategy {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (HandlerHandlerMapTableFieldStrategy.class);\r\n-\r\n-    private Column[] _kcols = null;\r\n-    private ColumnIO _kio = null;\r\n-    private boolean _kload = false;\r\n-    private Column[] _vcols = null;\r\n-    private ColumnIO _vio = null;\r\n-    private boolean _vload = false;\r\n-\r\n-    public Column[] getKeyColumns(ClassMapping cls) {\r\n-        return _kcols;\r\n-    }\r\n-\r\n-    public Column[] getValueColumns(ClassMapping cls) {\r\n-        return _vcols;\r\n-    }\r\n-\r\n-    public void selectKey(Select sel, ClassMapping cls, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\r\n-        sel.select(_kcols, joins);\r\n-    }\r\n-\r\n-    public void selectValue(Select sel, ClassMapping cls,\r\n-        OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\r\n-        sel.select(_vcols, joins);\r\n-    }\r\n-\r\n-    public Result[] getResults(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, int eagerMode, Joins[] joins, boolean lrs)\r\n-        throws SQLException {\r\n-        Select sel = store.getSQLFactory().newSelect();\r\n-        sel.setLRS(lrs);\r\n-        sel.select(_kcols);\r\n-        sel.select(_vcols);\r\n-        sel.whereForeignKey(field.getJoinForeignKey(), sm.getObjectId(),\r\n-            field.getDefiningMapping(), store);\r\n-        Result res = sel.execute(store, fetch);\r\n-        return new Result[]{ res, res };\r\n-    }\r\n-\r\n-    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        return HandlerStrategies.loadObject(field.getKeyMapping(),\r\n-            sm, store, fetch, res, joins, _kcols, _kload);\r\n-    }\r\n-\r\n-    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        return HandlerStrategies.loadObject(field.getElementMapping(),\r\n-            sm, store, fetch, res, joins, _vcols, _vload);\r\n-    }\r\n-\r\n-    public void map(boolean adapt) {\r\n-        super.map(adapt);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        if (key.getHandler() == null)\r\n-            throw new MetaDataException(_loc.get(\"no-handler\", key));\r\n-        ValueMapping val = field.getElementMapping();\r\n-        if (val.getHandler() == null)\r\n-            throw new MetaDataException(_loc.get(\"no-handler\", val));\r\n-        assertNotMappedBy();\r\n-\r\n-        field.mapJoin(adapt, true);\r\n-        _kio = new ColumnIO();\r\n-        DBDictionary dict = field.getMappingRepository().getDBDictionary();\r\n-        _kcols = HandlerStrategies.map(key, \r\n-            dict.getValidColumnName(\"key\", field.getTable()), _kio, adapt);\r\n-\r\n-        _vio = new ColumnIO();\r\n-        _vcols = HandlerStrategies.map(val, \"value\", _vio, adapt);\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    public void initialize() {\r\n-        _kload = field.getKeyMapping().getHandler().\r\n-            objectValueRequiresLoad(field.getKeyMapping());\r\n-        _vload = field.getElementMapping().getHandler().\r\n-            objectValueRequiresLoad(field.getElementMapping());\r\n-    }\r\n-\r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\r\n-    }\r\n-\r\n-    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\r\n-        Map map)\r\n-        throws SQLException {\r\n-        if (map == null || map.isEmpty())\r\n-            return;\r\n-\r\n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\r\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\r\n-            sm);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ValueMapping val = field.getElementMapping();\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            HandlerStrategies.set(key, entry.getKey(), store, row, _kcols,\r\n-                _kio, true);\r\n-            HandlerStrategies.set(val, entry.getValue(), store, row, _vcols,\r\n-                _vio, true);\r\n-            rm.flushSecondaryRow(row);\r\n-        }\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Map map = (Map) sm.fetchObject(field.getIndex());\r\n-        ChangeTracker ct = null;\r\n-        if (map instanceof Proxy) {\r\n-            Proxy proxy = (Proxy) map;\r\n-            if (Proxies.isOwner(proxy, sm, field.getIndex()))\r\n-                ct = proxy.getChangeTracker();\r\n-        }\r\n-\r\n-        // if no fine-grained change tracking then just delete and reinsert\r\n-        if (ct == null || !ct.isTracking()) {\r\n-            delete(sm, store, rm);\r\n-            insert(sm, store, rm, map);\r\n-            return;\r\n-        }\r\n-\r\n-        // delete the removes\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        Collection rem = ct.getRemoved();\r\n-        if (!rem.isEmpty()) {\r\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_DELETE);\r\n-            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-            for (Iterator itr = rem.iterator(); itr.hasNext();) {\r\n-                HandlerStrategies.where(key, itr.next(), store, delRow,\r\n-                    _kcols);\r\n-                rm.flushSecondaryRow(delRow);\r\n-            }\r\n-        }\r\n-\r\n-        // insert the adds\r\n-        ValueMapping val = field.getElementMapping();\r\n-        Collection add = ct.getAdded();\r\n-        Object mkey;\r\n-        if (!add.isEmpty()) {\r\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_INSERT);\r\n-            addRow.setForeignKey(field.getJoinForeignKey(),\r\n-                field.getJoinColumnIO(), sm);\r\n-\r\n-            for (Iterator itr = add.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                HandlerStrategies.set(key, mkey, store, addRow, _kcols,\r\n-                    _kio, true);\r\n-                HandlerStrategies.set(val, map.get(mkey), store, addRow,\r\n-                    _vcols, _vio, true);\r\n-                rm.flushSecondaryRow(addRow);\r\n-            }\r\n-        }\r\n-\r\n-        // update the changes\r\n-        Collection change = ct.getChanged();\r\n-        if (!change.isEmpty()) {\r\n-            Row changeRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_UPDATE);\r\n-            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                HandlerStrategies.where(key, mkey, store, changeRow, _kcols);\r\n-                HandlerStrategies.set(val, map.get(mkey), store, changeRow,\r\n-                    _vcols, _vio, true);\r\n-                rm.flushSecondaryRow(changeRow);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\r\n-        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\r\n-            val, _vcols, store);\r\n-    }\r\n-\r\n-    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\r\n-        return HandlerStrategies.toDataStoreValue(field.getKeyMapping(), val,\r\n-            _kcols, store);\r\n-    }\r\n-\r\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        if (traverse)\r\n-            HandlerStrategies.assertJoinable(field.getElementMapping());\r\n-        return joins;\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        if (traverse)\r\n-            HandlerStrategies.assertJoinable(field.getKeyMapping());\r\n-        return joins;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+import org.apache.openjpa.jdbc.sql.*;\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.util.*;\n+\n+/**\n+ * Mapping for a map of keys and values both controlled by\n+ * {@link ValueHandler}s.\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ */\n+public class HandlerHandlerMapTableFieldStrategy\n+    extends MapTableFieldStrategy {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (HandlerHandlerMapTableFieldStrategy.class);\n+\n+    private Column[] _kcols = null;\n+    private ColumnIO _kio = null;\n+    private boolean _kload = false;\n+    private Column[] _vcols = null;\n+    private ColumnIO _vio = null;\n+    private boolean _vload = false;\n+\n+    public Column[] getKeyColumns(ClassMapping cls) {\n+        return _kcols;\n+    }\n+\n+    public Column[] getValueColumns(ClassMapping cls) {\n+        return _vcols;\n+    }\n+\n+    public void selectKey(Select sel, ClassMapping cls, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n+        sel.select(_kcols, joins);\n+    }\n+\n+    public void selectValue(Select sel, ClassMapping cls,\n+        OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n+        sel.select(_vcols, joins);\n+    }\n+\n+    public Result[] getResults(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, int eagerMode, Joins[] joins, boolean lrs)\n+        throws SQLException {\n+        Select sel = store.getSQLFactory().newSelect();\n+        sel.setLRS(lrs);\n+        sel.select(_kcols);\n+        sel.select(_vcols);\n+        sel.whereForeignKey(field.getJoinForeignKey(), sm.getObjectId(),\n+            field.getDefiningMapping(), store);\n+        Result res = sel.execute(store, fetch);\n+        return new Result[]{ res, res };\n+    }\n+\n+    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        return HandlerStrategies.loadObject(field.getKeyMapping(),\n+            sm, store, fetch, res, joins, _kcols, _kload);\n+    }\n+\n+    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        return HandlerStrategies.loadObject(field.getElementMapping(),\n+            sm, store, fetch, res, joins, _vcols, _vload);\n+    }\n+\n+    public void map(boolean adapt) {\n+        super.map(adapt);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        if (key.getHandler() == null)\n+            throw new MetaDataException(_loc.get(\"no-handler\", key));\n+        ValueMapping val = field.getElementMapping();\n+        if (val.getHandler() == null)\n+            throw new MetaDataException(_loc.get(\"no-handler\", val));\n+        assertNotMappedBy();\n+\n+        field.mapJoin(adapt, true);\n+        _kio = new ColumnIO();\n+        DBDictionary dict = field.getMappingRepository().getDBDictionary();\n+        _kcols = HandlerStrategies.map(key, \n+            dict.getValidColumnName(\"key\", field.getTable()), _kio, adapt);\n+\n+        _vio = new ColumnIO();\n+        _vcols = HandlerStrategies.map(val, \"value\", _vio, adapt);\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    public void initialize() {\n+        _kload = field.getKeyMapping().getHandler().\n+            objectValueRequiresLoad(field.getKeyMapping());\n+        _vload = field.getElementMapping().getHandler().\n+            objectValueRequiresLoad(field.getElementMapping());\n+    }\n+\n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\n+    }\n+\n+    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n+        Map map)\n+        throws SQLException {\n+        if (map == null || map.isEmpty())\n+            return;\n+\n+        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n+        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n+            sm);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        ValueMapping val = field.getElementMapping();\n+        Map.Entry entry;\n+        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            HandlerStrategies.set(key, entry.getKey(), store, row, _kcols,\n+                _kio, true);\n+            HandlerStrategies.set(val, entry.getValue(), store, row, _vcols,\n+                _vio, true);\n+            rm.flushSecondaryRow(row);\n+        }\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Map map = (Map) sm.fetchObject(field.getIndex());\n+        ChangeTracker ct = null;\n+        if (map instanceof Proxy) {\n+            Proxy proxy = (Proxy) map;\n+            if (Proxies.isOwner(proxy, sm, field.getIndex()))\n+                ct = proxy.getChangeTracker();\n+        }\n+\n+        // if no fine-grained change tracking then just delete and reinsert\n+        if (ct == null || !ct.isTracking()) {\n+            delete(sm, store, rm);\n+            insert(sm, store, rm, map);\n+            return;\n+        }\n+\n+        // delete the removes\n+        ValueMapping key = field.getKeyMapping();\n+        Collection rem = ct.getRemoved();\n+        if (!rem.isEmpty()) {\n+            Row delRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_DELETE);\n+            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+            for (Iterator itr = rem.iterator(); itr.hasNext();) {\n+                HandlerStrategies.where(key, itr.next(), store, delRow,\n+                    _kcols);\n+                rm.flushSecondaryRow(delRow);\n+            }\n+        }\n+\n+        // insert the adds\n+        ValueMapping val = field.getElementMapping();\n+        Collection add = ct.getAdded();\n+        Object mkey;\n+        if (!add.isEmpty()) {\n+            Row addRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_INSERT);\n+            addRow.setForeignKey(field.getJoinForeignKey(),\n+                field.getJoinColumnIO(), sm);\n+\n+            for (Iterator itr = add.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                HandlerStrategies.set(key, mkey, store, addRow, _kcols,\n+                    _kio, true);\n+                HandlerStrategies.set(val, map.get(mkey), store, addRow,\n+                    _vcols, _vio, true);\n+                rm.flushSecondaryRow(addRow);\n+            }\n+        }\n+\n+        // update the changes\n+        Collection change = ct.getChanged();\n+        if (!change.isEmpty()) {\n+            Row changeRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_UPDATE);\n+            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                HandlerStrategies.where(key, mkey, store, changeRow, _kcols);\n+                HandlerStrategies.set(val, map.get(mkey), store, changeRow,\n+                    _vcols, _vio, true);\n+                rm.flushSecondaryRow(changeRow);\n+            }\n+        }\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\n+            val, _vcols, store);\n+    }\n+\n+    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\n+        return HandlerStrategies.toDataStoreValue(field.getKeyMapping(), val,\n+            _kcols, store);\n+    }\n+\n+    public Joins joinRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        if (traverse)\n+            HandlerStrategies.assertJoinable(field.getElementMapping());\n+        return joins;\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        if (traverse)\n+            HandlerStrategies.assertJoinable(field.getKeyMapping());\n+        return joins;\n+    }\n+}"},{"sha":"3731c0620982c87c17cdbdcae618c174cdbf2ace","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","status":"modified","additions":315,"deletions":315,"changes":630,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/HandlerRelationMapTableFieldStrategy.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,315 +1,315 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.lib.util.*;\r\n-import org.apache.openjpa.meta.*;\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.util.*;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-import org.apache.openjpa.jdbc.sql.*;\r\n-\r\n-/**\r\n- * <p>Mapping for a map whose keys are controlled by a {@link ValueHandler}\r\n- * and whose values are relations to other persistent objects.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- */\r\n-public class HandlerRelationMapTableFieldStrategy\r\n-    extends MapTableFieldStrategy {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (HandlerRelationMapTableFieldStrategy.class);\r\n-\r\n-    private Column[] _kcols = null;\r\n-    private ColumnIO _kio = null;\r\n-    private boolean _kload = false;\r\n-\r\n-    public Column[] getKeyColumns(ClassMapping cls) {\r\n-        return _kcols;\r\n-    }\r\n-\r\n-    public Column[] getValueColumns(ClassMapping cls) {\r\n-        return field.getElementMapping().getColumns();\r\n-    }\r\n-\r\n-    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\r\n-        sel.select(_kcols, joins);\r\n-    }\r\n-\r\n-    public void selectValue(Select sel, ClassMapping val,\r\n-        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \r\n-        Joins joins) {\r\n-        sel.select(val, field.getElementMapping().getSelectSubclasses(),\r\n-            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\r\n-    }\r\n-\r\n-    public Result[] getResults(final OpenJPAStateManager sm,\r\n-        final JDBCStore store, final JDBCFetchConfiguration fetch,\r\n-        final int eagerMode, final Joins[] resJoins, boolean lrs)\r\n-        throws SQLException {\r\n-        ValueMapping elem = field.getElementMapping();\r\n-        final ClassMapping[] vals = elem.getIndependentTypeMappings();\r\n-        Union union = store.getSQLFactory().newUnion(vals.length);\r\n-        if (fetch.getSubclassFetchMode(elem.getTypeMapping())\r\n-            != JDBCFetchConfiguration.EAGER_JOIN)\r\n-            union.abortUnion();\r\n-        union.setLRS(lrs);\r\n-        union.select(new Union.Selector() {\r\n-            public void select(Select sel, int idx) {\r\n-                sel.select(_kcols);\r\n-                sel.whereForeignKey(field.getJoinForeignKey(),\r\n-                    sm.getObjectId(), field.getDefiningMapping(), store);\r\n-\r\n-                Joins joins = joinValueRelation(sel.newJoins(), vals[idx]);\r\n-                sel.select(vals[idx], field.getElementMapping().\r\n-                    getSelectSubclasses(), store, fetch, eagerMode, joins);\r\n-\r\n-                //### cheat: result joins only care about the relation path;\r\n-                //### thus we can use first mapping of union only\r\n-                if (idx == 0)\r\n-                    resJoins[1] = joins;\r\n-            }\r\n-        });\r\n-        Result res = union.execute(store, fetch);\r\n-        return new Result[]{ res, res };\r\n-    }\r\n-\r\n-    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        return HandlerStrategies.loadObject(field.getKeyMapping(),\r\n-            sm, store, fetch, res, joins, _kcols, _kload);\r\n-    }\r\n-\r\n-    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        ClassMapping val = res.getBaseMapping();\r\n-        if (val == null)\r\n-            val = field.getElementMapping().getIndependentTypeMappings()[0];\r\n-        return res.load(val, store, fetch, joins);\r\n-    }\r\n-\r\n-    public Joins joinValueRelation(Joins joins, ClassMapping val) {\r\n-        ValueMapping vm = field.getElementMapping();\r\n-        return joins.joinRelation(field.getName(), vm.getForeignKey(val), val,\r\n-            vm.getSelectSubclasses(), false, false);\r\n-    }\r\n-\r\n-    public void map(boolean adapt) {\r\n-        super.map(adapt);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        if (key.getHandler() == null)\r\n-            throw new MetaDataException(_loc.get(\"no-handler\", key));\r\n-        ValueMapping val = field.getElementMapping();\r\n-        if (val.getTypeCode() != JavaTypes.PC || val.isEmbeddedPC())\r\n-            throw new MetaDataException(_loc.get(\"not-relation\", val));\r\n-        assertNotMappedBy();\r\n-\r\n-        field.mapJoin(adapt, true);\r\n-        _kio = new ColumnIO();\r\n-        DBDictionary dict = field.getMappingRepository().getDBDictionary();\r\n-        _kcols = HandlerStrategies.map(key, \r\n-            dict.getValidColumnName(\"key\", field.getTable()), _kio, adapt);\r\n-\r\n-        if (val.getTypeMapping().isMapped()) {\r\n-            ValueMappingInfo vinfo = val.getValueInfo();\r\n-            ForeignKey fk = vinfo.getTypeJoin(val, \"value\", false, adapt);\r\n-            val.setForeignKey(fk);\r\n-            val.setColumnIO(vinfo.getColumnIO());\r\n-        } else\r\n-            RelationStrategies.mapRelationToUnmappedPC(val, \"value\", adapt);\r\n-\r\n-        val.mapConstraints(\"value\", adapt);\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    public void initialize() {\r\n-        _kload = field.getKeyMapping().getHandler().\r\n-            objectValueRequiresLoad(field.getKeyMapping());\r\n-    }\r\n-\r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\r\n-    }\r\n-\r\n-    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\r\n-        Map map)\r\n-        throws SQLException {\r\n-        if (map == null || map.isEmpty())\r\n-            return;\r\n-\r\n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\r\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\r\n-            sm);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ValueMapping val = field.getElementMapping();\r\n-        StoreContext ctx = store.getContext();\r\n-        OpenJPAStateManager valsm;\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            HandlerStrategies.set(key, entry.getKey(), store, row, _kcols,\r\n-                _kio, true);\r\n-            valsm = RelationStrategies.getStateManager(entry.getValue(),\r\n-                ctx);\r\n-            val.setForeignKey(row, valsm);\r\n-            rm.flushSecondaryRow(row);\r\n-        }\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Map map = (Map) sm.fetchObject(field.getIndex());\r\n-        ChangeTracker ct = null;\r\n-        if (map instanceof Proxy) {\r\n-            Proxy proxy = (Proxy) map;\r\n-            if (Proxies.isOwner(proxy, sm, field.getIndex()))\r\n-                ct = proxy.getChangeTracker();\r\n-        }\r\n-\r\n-        // if no fine-grained change tracking then just delete and reinsert\r\n-        if (ct == null || !ct.isTracking()) {\r\n-            delete(sm, store, rm);\r\n-            insert(sm, store, rm, map);\r\n-            return;\r\n-        }\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ValueMapping val = field.getElementMapping();\r\n-        StoreContext ctx = store.getContext();\r\n-        OpenJPAStateManager valsm;\r\n-\r\n-        // update the changes; note that we have to featureSelection changes as\r\n-        // delete-then-insert if we have a foreign key action, because\r\n-        // secondary row updates aren't part of the constraint graph\r\n-        Collection change = ct.getChanged();\r\n-        boolean canChange = val.getForeignKey().isLogical();\r\n-        Object mkey;\r\n-        if (canChange && !change.isEmpty()) {\r\n-            Row changeRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_UPDATE);\r\n-            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                HandlerStrategies.where(key, mkey, store, changeRow, _kcols);\r\n-                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\r\n-                val.setForeignKey(changeRow, valsm);\r\n-                rm.flushSecondaryRow(changeRow);\r\n-            }\r\n-        }\r\n-\r\n-        // delete the removes\r\n-        Collection rem = ct.getRemoved();\r\n-        if (!rem.isEmpty() || (!canChange && !change.isEmpty())) {\r\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_DELETE);\r\n-            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = rem.iterator(); itr.hasNext();) {\r\n-                HandlerStrategies.where(key, itr.next(), store, delRow,\r\n-                    _kcols);\r\n-                rm.flushSecondaryRow(delRow);\r\n-            }\r\n-            if (!canChange && !change.isEmpty()) {\r\n-                for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                    HandlerStrategies.where(key, itr.next(), store, delRow,\r\n-                        _kcols);\r\n-                    rm.flushSecondaryRow(delRow);\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        // insert the adds\r\n-        Collection add = ct.getAdded();\r\n-        if (!add.isEmpty() || (!canChange && !change.isEmpty())) {\r\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_INSERT);\r\n-            addRow.setForeignKey(field.getJoinForeignKey(),\r\n-                field.getJoinColumnIO(), sm);\r\n-\r\n-            for (Iterator itr = add.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                HandlerStrategies.set(key, mkey, store, addRow, _kcols,\r\n-                    _kio, true);\r\n-                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\r\n-                val.setForeignKey(addRow, valsm);\r\n-                rm.flushSecondaryRow(addRow);\r\n-            }\r\n-            if (!canChange && !change.isEmpty()) {\r\n-                for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                    mkey = itr.next();\r\n-                    HandlerStrategies.set(key, mkey, store, addRow, _kcols,\r\n-                        _kio, true);\r\n-                    valsm = RelationStrategies.getStateManager(map.get(mkey),\r\n-                        ctx);\r\n-                    val.setForeignKey(addRow, valsm);\r\n-                    rm.flushSecondaryRow(addRow);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        ValueMapping val = field.getElementMapping();\r\n-        ClassMapping[] clss = val.getIndependentTypeMappings();\r\n-        if (clss.length != 1) {\r\n-            if (traverse)\r\n-                throw RelationStrategies.unjoinable(val);\r\n-            return joins;\r\n-        }\r\n-        if (forceOuter)\r\n-            return joins.outerJoinRelation(field.getName(),\r\n-                val.getForeignKey(clss[0]), clss[0], val.getSelectSubclasses(),\r\n-                false, false);\r\n-        return joins.joinRelation(field.getName(),\r\n-            val.getForeignKey(clss[0]), clss[0], val.getSelectSubclasses(), \r\n-            false, false);\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        if (traverse)\r\n-            HandlerStrategies.assertJoinable(field.getKeyMapping());\r\n-        return joins;\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\r\n-        return RelationStrategies.toDataStoreValue(field.getElementMapping(),\r\n-            val, store);\r\n-    }\r\n-\r\n-    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\r\n-        return HandlerStrategies.toDataStoreValue(field.getKeyMapping(), val,\r\n-            _kcols, store);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.meta.*;\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.util.*;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+import org.apache.openjpa.jdbc.sql.*;\n+\n+/**\n+ * <p>Mapping for a map whose keys are controlled by a {@link ValueHandler}\n+ * and whose values are relations to other persistent objects.</p>\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ */\n+public class HandlerRelationMapTableFieldStrategy\n+    extends MapTableFieldStrategy {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (HandlerRelationMapTableFieldStrategy.class);\n+\n+    private Column[] _kcols = null;\n+    private ColumnIO _kio = null;\n+    private boolean _kload = false;\n+\n+    public Column[] getKeyColumns(ClassMapping cls) {\n+        return _kcols;\n+    }\n+\n+    public Column[] getValueColumns(ClassMapping cls) {\n+        return field.getElementMapping().getColumns();\n+    }\n+\n+    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n+        sel.select(_kcols, joins);\n+    }\n+\n+    public void selectValue(Select sel, ClassMapping val,\n+        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \n+        Joins joins) {\n+        sel.select(val, field.getElementMapping().getSelectSubclasses(),\n+            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\n+    }\n+\n+    public Result[] getResults(final OpenJPAStateManager sm,\n+        final JDBCStore store, final JDBCFetchConfiguration fetch,\n+        final int eagerMode, final Joins[] resJoins, boolean lrs)\n+        throws SQLException {\n+        ValueMapping elem = field.getElementMapping();\n+        final ClassMapping[] vals = elem.getIndependentTypeMappings();\n+        Union union = store.getSQLFactory().newUnion(vals.length);\n+        if (fetch.getSubclassFetchMode(elem.getTypeMapping())\n+            != JDBCFetchConfiguration.EAGER_JOIN)\n+            union.abortUnion();\n+        union.setLRS(lrs);\n+        union.select(new Union.Selector() {\n+            public void select(Select sel, int idx) {\n+                sel.select(_kcols);\n+                sel.whereForeignKey(field.getJoinForeignKey(),\n+                    sm.getObjectId(), field.getDefiningMapping(), store);\n+\n+                Joins joins = joinValueRelation(sel.newJoins(), vals[idx]);\n+                sel.select(vals[idx], field.getElementMapping().\n+                    getSelectSubclasses(), store, fetch, eagerMode, joins);\n+\n+                //### cheat: result joins only care about the relation path;\n+                //### thus we can use first mapping of union only\n+                if (idx == 0)\n+                    resJoins[1] = joins;\n+            }\n+        });\n+        Result res = union.execute(store, fetch);\n+        return new Result[]{ res, res };\n+    }\n+\n+    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        return HandlerStrategies.loadObject(field.getKeyMapping(),\n+            sm, store, fetch, res, joins, _kcols, _kload);\n+    }\n+\n+    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        ClassMapping val = res.getBaseMapping();\n+        if (val == null)\n+            val = field.getElementMapping().getIndependentTypeMappings()[0];\n+        return res.load(val, store, fetch, joins);\n+    }\n+\n+    public Joins joinValueRelation(Joins joins, ClassMapping val) {\n+        ValueMapping vm = field.getElementMapping();\n+        return joins.joinRelation(field.getName(), vm.getForeignKey(val), val,\n+            vm.getSelectSubclasses(), false, false);\n+    }\n+\n+    public void map(boolean adapt) {\n+        super.map(adapt);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        if (key.getHandler() == null)\n+            throw new MetaDataException(_loc.get(\"no-handler\", key));\n+        ValueMapping val = field.getElementMapping();\n+        if (val.getTypeCode() != JavaTypes.PC || val.isEmbeddedPC())\n+            throw new MetaDataException(_loc.get(\"not-relation\", val));\n+        assertNotMappedBy();\n+\n+        field.mapJoin(adapt, true);\n+        _kio = new ColumnIO();\n+        DBDictionary dict = field.getMappingRepository().getDBDictionary();\n+        _kcols = HandlerStrategies.map(key, \n+            dict.getValidColumnName(\"key\", field.getTable()), _kio, adapt);\n+\n+        if (val.getTypeMapping().isMapped()) {\n+            ValueMappingInfo vinfo = val.getValueInfo();\n+            ForeignKey fk = vinfo.getTypeJoin(val, \"value\", false, adapt);\n+            val.setForeignKey(fk);\n+            val.setColumnIO(vinfo.getColumnIO());\n+        } else\n+            RelationStrategies.mapRelationToUnmappedPC(val, \"value\", adapt);\n+\n+        val.mapConstraints(\"value\", adapt);\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    public void initialize() {\n+        _kload = field.getKeyMapping().getHandler().\n+            objectValueRequiresLoad(field.getKeyMapping());\n+    }\n+\n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\n+    }\n+\n+    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n+        Map map)\n+        throws SQLException {\n+        if (map == null || map.isEmpty())\n+            return;\n+\n+        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n+        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n+            sm);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        ValueMapping val = field.getElementMapping();\n+        StoreContext ctx = store.getContext();\n+        OpenJPAStateManager valsm;\n+        Map.Entry entry;\n+        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            HandlerStrategies.set(key, entry.getKey(), store, row, _kcols,\n+                _kio, true);\n+            valsm = RelationStrategies.getStateManager(entry.getValue(),\n+                ctx);\n+            val.setForeignKey(row, valsm);\n+            rm.flushSecondaryRow(row);\n+        }\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Map map = (Map) sm.fetchObject(field.getIndex());\n+        ChangeTracker ct = null;\n+        if (map instanceof Proxy) {\n+            Proxy proxy = (Proxy) map;\n+            if (Proxies.isOwner(proxy, sm, field.getIndex()))\n+                ct = proxy.getChangeTracker();\n+        }\n+\n+        // if no fine-grained change tracking then just delete and reinsert\n+        if (ct == null || !ct.isTracking()) {\n+            delete(sm, store, rm);\n+            insert(sm, store, rm, map);\n+            return;\n+        }\n+\n+        ValueMapping key = field.getKeyMapping();\n+        ValueMapping val = field.getElementMapping();\n+        StoreContext ctx = store.getContext();\n+        OpenJPAStateManager valsm;\n+\n+        // update the changes; note that we have to featureSelection changes as\n+        // delete-then-insert if we have a foreign key action, because\n+        // secondary row updates aren't part of the constraint graph\n+        Collection change = ct.getChanged();\n+        boolean canChange = val.getForeignKey().isLogical();\n+        Object mkey;\n+        if (canChange && !change.isEmpty()) {\n+            Row changeRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_UPDATE);\n+            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                HandlerStrategies.where(key, mkey, store, changeRow, _kcols);\n+                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n+                val.setForeignKey(changeRow, valsm);\n+                rm.flushSecondaryRow(changeRow);\n+            }\n+        }\n+\n+        // delete the removes\n+        Collection rem = ct.getRemoved();\n+        if (!rem.isEmpty() || (!canChange && !change.isEmpty())) {\n+            Row delRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_DELETE);\n+            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = rem.iterator(); itr.hasNext();) {\n+                HandlerStrategies.where(key, itr.next(), store, delRow,\n+                    _kcols);\n+                rm.flushSecondaryRow(delRow);\n+            }\n+            if (!canChange && !change.isEmpty()) {\n+                for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                    HandlerStrategies.where(key, itr.next(), store, delRow,\n+                        _kcols);\n+                    rm.flushSecondaryRow(delRow);\n+                }\n+            }\n+        }\n+\n+        // insert the adds\n+        Collection add = ct.getAdded();\n+        if (!add.isEmpty() || (!canChange && !change.isEmpty())) {\n+            Row addRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_INSERT);\n+            addRow.setForeignKey(field.getJoinForeignKey(),\n+                field.getJoinColumnIO(), sm);\n+\n+            for (Iterator itr = add.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                HandlerStrategies.set(key, mkey, store, addRow, _kcols,\n+                    _kio, true);\n+                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n+                val.setForeignKey(addRow, valsm);\n+                rm.flushSecondaryRow(addRow);\n+            }\n+            if (!canChange && !change.isEmpty()) {\n+                for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                    mkey = itr.next();\n+                    HandlerStrategies.set(key, mkey, store, addRow, _kcols,\n+                        _kio, true);\n+                    valsm = RelationStrategies.getStateManager(map.get(mkey),\n+                        ctx);\n+                    val.setForeignKey(addRow, valsm);\n+                    rm.flushSecondaryRow(addRow);\n+                }\n+            }\n+        }\n+    }\n+\n+    public Joins joinRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        ValueMapping val = field.getElementMapping();\n+        ClassMapping[] clss = val.getIndependentTypeMappings();\n+        if (clss.length != 1) {\n+            if (traverse)\n+                throw RelationStrategies.unjoinable(val);\n+            return joins;\n+        }\n+        if (forceOuter)\n+            return joins.outerJoinRelation(field.getName(),\n+                val.getForeignKey(clss[0]), clss[0], val.getSelectSubclasses(),\n+                false, false);\n+        return joins.joinRelation(field.getName(),\n+            val.getForeignKey(clss[0]), clss[0], val.getSelectSubclasses(), \n+            false, false);\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        if (traverse)\n+            HandlerStrategies.assertJoinable(field.getKeyMapping());\n+        return joins;\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return RelationStrategies.toDataStoreValue(field.getElementMapping(),\n+            val, store);\n+    }\n+\n+    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\n+        return HandlerStrategies.toDataStoreValue(field.getKeyMapping(), val,\n+            _kcols, store);\n+    }\n+}"},{"sha":"5af8420cd27e5f3602782dd8db5b02413212406e","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java","status":"modified","additions":219,"deletions":219,"changes":438,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/LobFieldStrategy.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,219 +1,219 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.io.InputStream;\r\n-import java.io.Reader;\r\n-import java.sql.SQLException;\r\n-import java.sql.Types;\r\n-\r\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\r\n-import org.apache.openjpa.jdbc.kernel.JDBCStore;\r\n-import org.apache.openjpa.jdbc.meta.FieldMapping;\r\n-import org.apache.openjpa.jdbc.meta.ValueMappingInfo;\r\n-import org.apache.openjpa.jdbc.schema.Column;\r\n-import org.apache.openjpa.jdbc.sql.PostgresDictionary;\r\n-import org.apache.openjpa.jdbc.sql.Result;\r\n-import org.apache.openjpa.jdbc.sql.Row;\r\n-import org.apache.openjpa.jdbc.sql.RowManager;\r\n-import org.apache.openjpa.jdbc.sql.Select;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-\r\n-/**\r\n- * Direct mapping from a stream value to a column.\r\n- *\r\n- * @author Ignacio Andreu\r\n- * @since 1.1.0\r\n- */\r\n-public class LobFieldStrategy extends AbstractFieldStrategy {\r\n-\r\n-    private int fieldType;\r\n-    private boolean isBlob;\r\n-\r\n-    public void map(boolean adapt) {\r\n-        assertNotMappedBy();\r\n-        field.mapJoin(adapt, false);\r\n-        field.getKeyMapping().getValueInfo().assertNoSchemaComponents\r\n-            (field.getKey(), !adapt);\r\n-        field.getElementMapping().getValueInfo().assertNoSchemaComponents\r\n-            (field.getElement(), !adapt);\r\n-        field.setStream(true);\r\n-        ValueMappingInfo vinfo = field.getValueInfo();\r\n-        vinfo.assertNoJoin(field, true);\r\n-        vinfo.assertNoForeignKey(field, !adapt);\r\n-        Column tmpCol = new Column();\r\n-        tmpCol.setName(field.getName());\r\n-        tmpCol.setType(fieldType);\r\n-        tmpCol.setJavaType(field.getTypeCode());\r\n-        \r\n-        tmpCol.setSize(-1);\r\n-\r\n-        Column[] cols = vinfo.getColumns(field, field.getName(),\r\n-            new Column[]{ tmpCol }, field.getTable(), adapt);\r\n-\r\n-        field.setColumns(cols);\r\n-        field.setColumnIO(vinfo.getColumnIO());\r\n-        field.mapConstraints(field.getName(), adapt);\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    public Boolean isCustomInsert(OpenJPAStateManager sm, JDBCStore store) {\r\n-        return null;\r\n-    }\r\n-\r\n-    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Select sel = createSelect(sm, store);\r\n-        store.getDBDictionary().deleteStream(store, sel);\r\n-    }\r\n-    \r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Object ob = toDataStoreValue(sm.fetchObjectField\r\n-            (field.getIndex()), store);\r\n-        Row row = field.getRow(sm, store, rm, Row.ACTION_INSERT);\r\n-        if (field.getColumnIO().isInsertable(0, ob == null)) {\r\n-            Select sel = createSelect(sm, store);\r\n-            if (isBlob) {\r\n-                store.getDBDictionary().insertBlobForStreamingLoad\r\n-                    (row, field.getColumns()[0], store, ob, sel);\r\n-            } else {\r\n-                store.getDBDictionary().insertClobForStreamingLoad\r\n-                    (row, field.getColumns()[0], ob);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void customInsert(OpenJPAStateManager sm, JDBCStore store)\r\n-        throws SQLException {\r\n-        Object ob = toDataStoreValue(sm.fetchObjectField\r\n-            (field.getIndex()), store);\r\n-        if (field.getColumnIO().isInsertable(0, ob == null)) {\r\n-            if (ob != null) {\r\n-                Select sel = createSelect(sm, store);\r\n-                if (isBlob) {\r\n-                    store.getDBDictionary().updateBlob\r\n-                        (sel, store, (InputStream)ob);\r\n-                } else {\r\n-                    store.getDBDictionary().updateClob\r\n-                        (sel, store, (Reader)ob);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    \r\n-    public Boolean isCustomUpdate(OpenJPAStateManager sm, JDBCStore store) {\r\n-        return null;\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Object ob = toDataStoreValue(sm.fetchObjectField\r\n-            (field.getIndex()), store);\r\n-        if (field.getColumnIO().isUpdatable(0, ob == null)) {\r\n-            Row row = field.getRow(sm, store, rm, Row.ACTION_UPDATE);\r\n-            Select sel = createSelect(sm, store);\r\n-            if (isBlob) {\r\n-                store.getDBDictionary().insertBlobForStreamingLoad\r\n-                    (row, field.getColumns()[0], store, ob, sel);\r\n-            } else {\r\n-                store.getDBDictionary().insertClobForStreamingLoad\r\n-                    (row, field.getColumns()[0], sel);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void customUpdate(OpenJPAStateManager sm, JDBCStore store)\r\n-        throws SQLException {\r\n-        Object ob = toDataStoreValue(sm.fetchObjectField\r\n-                (field.getIndex()), store);\r\n-        if (field.getColumnIO().isUpdatable(0, ob == null)) {\r\n-            if (ob != null) {\r\n-                Select sel = createSelect(sm, store);\r\n-                if (isBlob) {\r\n-                    store.getDBDictionary().updateBlob\r\n-                        (sel, store, (InputStream)ob);\r\n-                } else {\r\n-                    store.getDBDictionary().updateClob\r\n-                        (sel, store, (Reader)ob);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public int supportsSelect(Select sel, int type, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch) {\r\n-        if (type == Select.TYPE_JOINLESS && sel.isSelected(field.getTable()))\r\n-            return 1;\r\n-        return 0;\r\n-    }\r\n-\r\n-    public int select(Select sel, OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, int eagerMode) {\r\n-        sel.select(field.getColumns()[0], field.join(sel));\r\n-        return 1;\r\n-    }\r\n-\r\n-    public void load(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res) throws SQLException {\r\n-        Column col = field.getColumns()[0];\r\n-        if (res.contains(col)) {\r\n-            if (isBlob) {\r\n-                sm.storeObject(field.getIndex(), res.getLOBStream(store, col));\r\n-            } else {\r\n-                sm.storeObject(field.getIndex(), res.getCharacterStream(col));\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    protected void assertNotMappedBy() {\r\n-        if (field != null && field.getMappedBy() != null)\r\n-            throw new UnsupportedOperationException();\r\n-    }\r\n-\r\n-    public void setFieldMapping(FieldMapping owner) {\r\n-        field = owner;\r\n-        if (owner.getElementMapping().getMappingRepository().getDBDictionary()\r\n-            instanceof PostgresDictionary) {\r\n-            fieldType = Types.INTEGER;\r\n-            isBlob = true;\r\n-            field.setTypeCode(JavaTypes.INT);\r\n-        } else {\r\n-            if (owner.getType().isAssignableFrom(InputStream.class)) {\r\n-                isBlob = true;\r\n-                fieldType = Types.BLOB;\r\n-            } else if (owner.getType().isAssignableFrom(Reader.class)) {\r\n-                isBlob = false;\r\n-                fieldType = Types.CLOB;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private Select createSelect(OpenJPAStateManager sm, JDBCStore store) {\r\n-        Select sel = store.getSQLFactory().newSelect();\r\n-        sel.select(field.getColumns()[0]);\r\n-        sel.selectPrimaryKey(field.getDefiningMapping());\r\n-        sel.wherePrimaryKey\r\n-            (sm.getObjectId(), field.getDefiningMapping(), store);\r\n-        sel.setLob(true);\r\n-        return sel;\r\n-    }\r\n-    \r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.JDBCStore;\n+import org.apache.openjpa.jdbc.meta.FieldMapping;\n+import org.apache.openjpa.jdbc.meta.ValueMappingInfo;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.sql.PostgresDictionary;\n+import org.apache.openjpa.jdbc.sql.Result;\n+import org.apache.openjpa.jdbc.sql.Row;\n+import org.apache.openjpa.jdbc.sql.RowManager;\n+import org.apache.openjpa.jdbc.sql.Select;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.meta.JavaTypes;\n+\n+/**\n+ * Direct mapping from a stream value to a column.\n+ *\n+ * @author Ignacio Andreu\n+ * @since 1.1.0\n+ */\n+public class LobFieldStrategy extends AbstractFieldStrategy {\n+\n+    private int fieldType;\n+    private boolean isBlob;\n+\n+    public void map(boolean adapt) {\n+        assertNotMappedBy();\n+        field.mapJoin(adapt, false);\n+        field.getKeyMapping().getValueInfo().assertNoSchemaComponents\n+            (field.getKey(), !adapt);\n+        field.getElementMapping().getValueInfo().assertNoSchemaComponents\n+            (field.getElement(), !adapt);\n+        field.setStream(true);\n+        ValueMappingInfo vinfo = field.getValueInfo();\n+        vinfo.assertNoJoin(field, true);\n+        vinfo.assertNoForeignKey(field, !adapt);\n+        Column tmpCol = new Column();\n+        tmpCol.setName(field.getName());\n+        tmpCol.setType(fieldType);\n+        tmpCol.setJavaType(field.getTypeCode());\n+        \n+        tmpCol.setSize(-1);\n+\n+        Column[] cols = vinfo.getColumns(field, field.getName(),\n+            new Column[]{ tmpCol }, field.getTable(), adapt);\n+\n+        field.setColumns(cols);\n+        field.setColumnIO(vinfo.getColumnIO());\n+        field.mapConstraints(field.getName(), adapt);\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    public Boolean isCustomInsert(OpenJPAStateManager sm, JDBCStore store) {\n+        return null;\n+    }\n+\n+    public void delete(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Select sel = createSelect(sm, store);\n+        store.getDBDictionary().deleteStream(store, sel);\n+    }\n+    \n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Object ob = toDataStoreValue(sm.fetchObjectField\n+            (field.getIndex()), store);\n+        Row row = field.getRow(sm, store, rm, Row.ACTION_INSERT);\n+        if (field.getColumnIO().isInsertable(0, ob == null)) {\n+            Select sel = createSelect(sm, store);\n+            if (isBlob) {\n+                store.getDBDictionary().insertBlobForStreamingLoad\n+                    (row, field.getColumns()[0], store, ob, sel);\n+            } else {\n+                store.getDBDictionary().insertClobForStreamingLoad\n+                    (row, field.getColumns()[0], ob);\n+            }\n+        }\n+    }\n+\n+    public void customInsert(OpenJPAStateManager sm, JDBCStore store)\n+        throws SQLException {\n+        Object ob = toDataStoreValue(sm.fetchObjectField\n+            (field.getIndex()), store);\n+        if (field.getColumnIO().isInsertable(0, ob == null)) {\n+            if (ob != null) {\n+                Select sel = createSelect(sm, store);\n+                if (isBlob) {\n+                    store.getDBDictionary().updateBlob\n+                        (sel, store, (InputStream)ob);\n+                } else {\n+                    store.getDBDictionary().updateClob\n+                        (sel, store, (Reader)ob);\n+                }\n+            }\n+        }\n+    }\n+    \n+    public Boolean isCustomUpdate(OpenJPAStateManager sm, JDBCStore store) {\n+        return null;\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Object ob = toDataStoreValue(sm.fetchObjectField\n+            (field.getIndex()), store);\n+        if (field.getColumnIO().isUpdatable(0, ob == null)) {\n+            Row row = field.getRow(sm, store, rm, Row.ACTION_UPDATE);\n+            Select sel = createSelect(sm, store);\n+            if (isBlob) {\n+                store.getDBDictionary().insertBlobForStreamingLoad\n+                    (row, field.getColumns()[0], store, ob, sel);\n+            } else {\n+                store.getDBDictionary().insertClobForStreamingLoad\n+                    (row, field.getColumns()[0], sel);\n+            }\n+        }\n+    }\n+\n+    public void customUpdate(OpenJPAStateManager sm, JDBCStore store)\n+        throws SQLException {\n+        Object ob = toDataStoreValue(sm.fetchObjectField\n+                (field.getIndex()), store);\n+        if (field.getColumnIO().isUpdatable(0, ob == null)) {\n+            if (ob != null) {\n+                Select sel = createSelect(sm, store);\n+                if (isBlob) {\n+                    store.getDBDictionary().updateBlob\n+                        (sel, store, (InputStream)ob);\n+                } else {\n+                    store.getDBDictionary().updateClob\n+                        (sel, store, (Reader)ob);\n+                }\n+            }\n+        }\n+    }\n+\n+    public int supportsSelect(Select sel, int type, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch) {\n+        if (type == Select.TYPE_JOINLESS && sel.isSelected(field.getTable()))\n+            return 1;\n+        return 0;\n+    }\n+\n+    public int select(Select sel, OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, int eagerMode) {\n+        sel.select(field.getColumns()[0], field.join(sel));\n+        return 1;\n+    }\n+\n+    public void load(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res) throws SQLException {\n+        Column col = field.getColumns()[0];\n+        if (res.contains(col)) {\n+            if (isBlob) {\n+                sm.storeObject(field.getIndex(), res.getLOBStream(store, col));\n+            } else {\n+                sm.storeObject(field.getIndex(), res.getCharacterStream(col));\n+            }\n+        }\n+    }\n+\n+    protected void assertNotMappedBy() {\n+        if (field != null && field.getMappedBy() != null)\n+            throw new UnsupportedOperationException();\n+    }\n+\n+    public void setFieldMapping(FieldMapping owner) {\n+        field = owner;\n+        if (owner.getElementMapping().getMappingRepository().getDBDictionary()\n+            instanceof PostgresDictionary) {\n+            fieldType = Types.INTEGER;\n+            isBlob = true;\n+            field.setTypeCode(JavaTypes.INT);\n+        } else {\n+            if (owner.getType().isAssignableFrom(InputStream.class)) {\n+                isBlob = true;\n+                fieldType = Types.BLOB;\n+            } else if (owner.getType().isAssignableFrom(Reader.class)) {\n+                isBlob = false;\n+                fieldType = Types.CLOB;\n+            }\n+        }\n+    }\n+\n+    private Select createSelect(OpenJPAStateManager sm, JDBCStore store) {\n+        Select sel = store.getSQLFactory().newSelect();\n+        sel.select(field.getColumns()[0]);\n+        sel.selectPrimaryKey(field.getDefiningMapping());\n+        sel.wherePrimaryKey\n+            (sm.getObjectId(), field.getDefiningMapping(), store);\n+        sel.setLob(true);\n+        return sel;\n+    }\n+    \n+}"},{"sha":"de51ad531fc306460de12f7a8f3d0513fb4aea57","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NanoPrecisionTimestampVersionStrategy.java","status":"modified","additions":41,"deletions":41,"changes":82,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NanoPrecisionTimestampVersionStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NanoPrecisionTimestampVersionStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/NanoPrecisionTimestampVersionStrategy.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,41 +1,41 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import org.apache.openjpa.lib.util.TimestampHelper;\r\n-\r\n-/**\r\n- * Uses a timestamp for optimistic versioning with nanosecond\r\n- * precision.\r\n- *\r\n- * @author Albert Lee\r\n- */\r\n-public class NanoPrecisionTimestampVersionStrategy\r\n-    extends TimestampVersionStrategy {\r\n-\r\n-    public static final String ALIAS = \"nano-timestamp\";\r\n-\r\n-    public String getAlias() {\r\n-        return ALIAS;\r\n-    }\r\n-\r\n-    protected Object nextVersion(Object version) {\r\n-        return TimestampHelper.getNanoPrecisionTimestamp();\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import org.apache.openjpa.lib.util.TimestampHelper;\n+\n+/**\n+ * Uses a timestamp for optimistic versioning with nanosecond\n+ * precision.\n+ *\n+ * @author Albert Lee\n+ */\n+public class NanoPrecisionTimestampVersionStrategy\n+    extends TimestampVersionStrategy {\n+\n+    public static final String ALIAS = \"nano-timestamp\";\n+\n+    public String getAlias() {\n+        return ALIAS;\n+    }\n+\n+    protected Object nextVersion(Object version) {\n+        return TimestampHelper.getNanoPrecisionTimestamp();\n+    }\n+}"},{"sha":"2ef9aa273cf75cfd5d0599e2a12a8a4f14c46682","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","status":"modified","additions":7,"deletions":4,"changes":11,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationFieldStrategy.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -598,7 +598,8 @@ public void load(OpenJPAStateManager sm, JDBCStore store,\n         else\n             sm.setIntermediate(field.getIndex(), oid);\n     }\n-\n+    \n+    Map<JDBCStoreManager.SelectKey, Object[]> relationFieldUnionCache = null;\n     public void load(final OpenJPAStateManager sm, final JDBCStore store,\n         final JDBCFetchConfiguration fetch)\n         throws SQLException {\n@@ -625,9 +626,11 @@ public void load(final OpenJPAStateManager sm, final JDBCStore store,\n         if (!((JDBCStoreManager)store).isQuerySQLCacheOn())\n             union = newUnion(sm, store, fetch, rels, subs, resJoins);\n         else {\n-            Map<JDBCStoreManager.SelectKey, Object[]> relationFieldUnionCache = \n-                ((JDBCStoreManager)store).getCacheMapFromQuerySQLCache(\n-                RelationFieldStrategy.class);\n+            if (relationFieldUnionCache == null) {\n+                relationFieldUnionCache =\n+                    ((JDBCStoreManager) store)\n+                        .getCacheMapFromQuerySQLCache(RelationFieldStrategy.class);\n+            }\n             boolean found = true;\n             JDBCFetchConfiguration fetchClone = new JDBCFetchConfigurationImpl();\n             fetchClone.copy(fetch);"},{"sha":"35a3a1c619765a5acee6dd0a3de6f37190526a75","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationHandlerMapTableFieldStrategy.java","status":"modified","additions":290,"deletions":290,"changes":580,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationHandlerMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationHandlerMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationHandlerMapTableFieldStrategy.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,290 +1,290 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.lib.util.*;\r\n-import org.apache.openjpa.meta.*;\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.util.*;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-import org.apache.openjpa.jdbc.sql.*;\r\n-\r\n-/**\r\n- * <p>Mapping for a map whose keys are relations to other persistent objects\r\n- * and whose values are controlled by a {@link ValueHandler}.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- */\r\n-public class RelationHandlerMapTableFieldStrategy\r\n-    extends MapTableFieldStrategy {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (RelationHandlerMapTableFieldStrategy.class);\r\n-\r\n-    private Column[] _vcols = null;\r\n-    private ColumnIO _vio = null;\r\n-    private boolean _vload = false;\r\n-\r\n-    public Column[] getKeyColumns(ClassMapping cls) {\r\n-        return field.getKeyMapping().getColumns();\r\n-    }\r\n-\r\n-    public Column[] getValueColumns(ClassMapping cls) {\r\n-        return _vcols;\r\n-    }\r\n-\r\n-    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\r\n-        sel.select(key, field.getKeyMapping().getSelectSubclasses(),\r\n-            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\r\n-    }\r\n-\r\n-    public void selectValue(Select sel, ClassMapping val,\r\n-        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \r\n-        Joins joins) {\r\n-        sel.select(_vcols, joins);\r\n-    }\r\n-\r\n-    public Result[] getResults(final OpenJPAStateManager sm,\r\n-        final JDBCStore store, final JDBCFetchConfiguration fetch,\r\n-        final int eagerMode, final Joins[] resJoins, boolean lrs)\r\n-        throws SQLException {\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        final ClassMapping[] keys = key.getIndependentTypeMappings();\r\n-        Union union = store.getSQLFactory().newUnion(keys.length);\r\n-        if (fetch.getSubclassFetchMode(key.getTypeMapping()) \r\n-            != JDBCFetchConfiguration.EAGER_JOIN)\r\n-            union.abortUnion();\r\n-        union.setLRS(lrs);\r\n-        union.select(new Union.Selector() {\r\n-            public void select(Select sel, int idx) {\r\n-                sel.select(_vcols);\r\n-                sel.whereForeignKey(field.getJoinForeignKey(),\r\n-                    sm.getObjectId(), field.getDefiningMapping(), store);\r\n-\r\n-                Joins joins = joinKeyRelation(sel.newJoins(), keys[idx]);\r\n-                sel.select(keys[idx], field.getKeyMapping().\r\n-                    getSelectSubclasses(), store, fetch, eagerMode, joins);\r\n-\r\n-                //### cheat: result joins only care about the relation path;\r\n-                //### thus we can use first mapping of union only\r\n-                if (idx == 0)\r\n-                    resJoins[0] = joins;\r\n-            }\r\n-        });\r\n-        Result res = union.execute(store, fetch);\r\n-        return new Result[]{ res, res };\r\n-    }\r\n-\r\n-    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        ClassMapping key = res.getBaseMapping();\r\n-        if (key == null)\r\n-            key = field.getKeyMapping().getIndependentTypeMappings()[0];\r\n-        return res.load(key, store, fetch, joins);\r\n-    }\r\n-\r\n-    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        return HandlerStrategies.loadObject(field.getElementMapping(),\r\n-            sm, store, fetch, res, joins, _vcols, _vload);\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, ClassMapping key) {\r\n-        ValueMapping vm = field.getKeyMapping();\r\n-        return joins.joinRelation(field.getName(), vm.getForeignKey(key), key,\r\n-            vm.getSelectSubclasses(), false, false);\r\n-    }\r\n-\r\n-    public void map(boolean adapt) {\r\n-        super.map(adapt);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        if (key.getTypeCode() != JavaTypes.PC || key.isEmbeddedPC())\r\n-            throw new MetaDataException(_loc.get(\"not-relation\", key));\r\n-        ValueMapping val = field.getElementMapping();\r\n-        if (val.getHandler() == null)\r\n-            throw new MetaDataException(_loc.get(\"no-handler\", val));\r\n-        assertNotMappedBy();\r\n-\r\n-        field.mapJoin(adapt, true);\r\n-        _vio = new ColumnIO();\r\n-        _vcols = HandlerStrategies.map(val, \"value\", _vio, adapt);\r\n-\r\n-        if (key.getTypeMapping().isMapped()) {\r\n-            ValueMappingInfo vinfo = key.getValueInfo();\r\n-            ForeignKey fk = vinfo.getTypeJoin(key, \"key\", false, adapt);\r\n-            key.setForeignKey(fk);\r\n-            key.setColumnIO(vinfo.getColumnIO());\r\n-        } else\r\n-            RelationStrategies.mapRelationToUnmappedPC(key, \"key\", adapt);\r\n-\r\n-        key.mapConstraints(\"key\", adapt);\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    public void initialize() {\r\n-        _vload = field.getElementMapping().getHandler().\r\n-            objectValueRequiresLoad(field.getElementMapping());\r\n-    }\r\n-\r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\r\n-    }\r\n-\r\n-    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\r\n-        Map map)\r\n-        throws SQLException {\r\n-        if (map == null || map.isEmpty())\r\n-            return;\r\n-\r\n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\r\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\r\n-            sm);\r\n-\r\n-        ValueMapping val = field.getElementMapping();\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        StoreContext ctx = store.getContext();\r\n-        OpenJPAStateManager keysm;\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            keysm = RelationStrategies.getStateManager(entry.getKey(), ctx);\r\n-            key.setForeignKey(row, keysm);\r\n-            HandlerStrategies.set(val, entry.getValue(), store, row, _vcols,\r\n-                _vio, true);\r\n-            rm.flushSecondaryRow(row);\r\n-        }\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Map map = (Map) sm.fetchObject(field.getIndex());\r\n-        ChangeTracker ct = null;\r\n-        if (map instanceof Proxy) {\r\n-            Proxy proxy = (Proxy) map;\r\n-            if (Proxies.isOwner(proxy, sm, field.getIndex()))\r\n-                ct = proxy.getChangeTracker();\r\n-        }\r\n-\r\n-        // if no fine-grained change tracking then just delete and reinsert\r\n-        if (ct == null || !ct.isTracking()) {\r\n-            delete(sm, store, rm);\r\n-            insert(sm, store, rm, map);\r\n-            return;\r\n-        }\r\n-\r\n-        // delete the removes\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        StoreContext ctx = store.getContext();\r\n-        Collection rem = ct.getRemoved();\r\n-        OpenJPAStateManager keysm;\r\n-        if (!rem.isEmpty()) {\r\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_DELETE);\r\n-            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-            for (Iterator itr = rem.iterator(); itr.hasNext();) {\r\n-                keysm = RelationStrategies.getStateManager(itr.next(), ctx);\r\n-                key.whereForeignKey(delRow, keysm);\r\n-                rm.flushSecondaryRow(delRow);\r\n-            }\r\n-        }\r\n-\r\n-        // insert the adds\r\n-        ValueMapping val = field.getElementMapping();\r\n-        Collection add = ct.getAdded();\r\n-        Object mkey;\r\n-        if (!add.isEmpty()) {\r\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_INSERT);\r\n-            addRow.setForeignKey(field.getJoinForeignKey(),\r\n-                field.getJoinColumnIO(), sm);\r\n-\r\n-            for (Iterator itr = add.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                keysm = RelationStrategies.getStateManager(mkey, ctx);\r\n-                key.setForeignKey(addRow, keysm);\r\n-                HandlerStrategies.set(val, map.get(mkey), store, addRow,\r\n-                    _vcols, _vio, true);\r\n-                rm.flushSecondaryRow(addRow);\r\n-            }\r\n-        }\r\n-\r\n-        // update the changes\r\n-        Collection change = ct.getChanged();\r\n-        if (!change.isEmpty()) {\r\n-            Row changeRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_UPDATE);\r\n-            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                keysm = RelationStrategies.getStateManager(mkey, ctx);\r\n-                key.whereForeignKey(changeRow, keysm);\r\n-                HandlerStrategies.set(val, map.get(mkey), store, changeRow,\r\n-                    _vcols, _vio, true);\r\n-                rm.flushSecondaryRow(changeRow);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        if (traverse)\r\n-            HandlerStrategies.assertJoinable(field.getElementMapping());\r\n-        return joins;\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ClassMapping[] clss = key.getIndependentTypeMappings();\r\n-        if (clss.length != 1) {\r\n-            if (traverse)\r\n-                throw RelationStrategies.unjoinable(field.getKeyMapping());\r\n-            return joins;\r\n-        }\r\n-        if (forceOuter)\r\n-            return joins.outerJoinRelation(field.getName(),\r\n-                key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\r\n-                false, false);\r\n-        return joins.joinRelation(field.getName(),\r\n-            key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\r\n-            false, false);\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\r\n-        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\r\n-            val, _vcols, store);\r\n-    }\r\n-\r\n-    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\r\n-        return RelationStrategies.toDataStoreValue(field.getKeyMapping(), val,\r\n-            store);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.meta.*;\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.util.*;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+import org.apache.openjpa.jdbc.sql.*;\n+\n+/**\n+ * <p>Mapping for a map whose keys are relations to other persistent objects\n+ * and whose values are controlled by a {@link ValueHandler}.</p>\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ */\n+public class RelationHandlerMapTableFieldStrategy\n+    extends MapTableFieldStrategy {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (RelationHandlerMapTableFieldStrategy.class);\n+\n+    private Column[] _vcols = null;\n+    private ColumnIO _vio = null;\n+    private boolean _vload = false;\n+\n+    public Column[] getKeyColumns(ClassMapping cls) {\n+        return field.getKeyMapping().getColumns();\n+    }\n+\n+    public Column[] getValueColumns(ClassMapping cls) {\n+        return _vcols;\n+    }\n+\n+    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n+        sel.select(key, field.getKeyMapping().getSelectSubclasses(),\n+            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\n+    }\n+\n+    public void selectValue(Select sel, ClassMapping val,\n+        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \n+        Joins joins) {\n+        sel.select(_vcols, joins);\n+    }\n+\n+    public Result[] getResults(final OpenJPAStateManager sm,\n+        final JDBCStore store, final JDBCFetchConfiguration fetch,\n+        final int eagerMode, final Joins[] resJoins, boolean lrs)\n+        throws SQLException {\n+        ValueMapping key = field.getKeyMapping();\n+        final ClassMapping[] keys = key.getIndependentTypeMappings();\n+        Union union = store.getSQLFactory().newUnion(keys.length);\n+        if (fetch.getSubclassFetchMode(key.getTypeMapping()) \n+            != JDBCFetchConfiguration.EAGER_JOIN)\n+            union.abortUnion();\n+        union.setLRS(lrs);\n+        union.select(new Union.Selector() {\n+            public void select(Select sel, int idx) {\n+                sel.select(_vcols);\n+                sel.whereForeignKey(field.getJoinForeignKey(),\n+                    sm.getObjectId(), field.getDefiningMapping(), store);\n+\n+                Joins joins = joinKeyRelation(sel.newJoins(), keys[idx]);\n+                sel.select(keys[idx], field.getKeyMapping().\n+                    getSelectSubclasses(), store, fetch, eagerMode, joins);\n+\n+                //### cheat: result joins only care about the relation path;\n+                //### thus we can use first mapping of union only\n+                if (idx == 0)\n+                    resJoins[0] = joins;\n+            }\n+        });\n+        Result res = union.execute(store, fetch);\n+        return new Result[]{ res, res };\n+    }\n+\n+    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        ClassMapping key = res.getBaseMapping();\n+        if (key == null)\n+            key = field.getKeyMapping().getIndependentTypeMappings()[0];\n+        return res.load(key, store, fetch, joins);\n+    }\n+\n+    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        return HandlerStrategies.loadObject(field.getElementMapping(),\n+            sm, store, fetch, res, joins, _vcols, _vload);\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, ClassMapping key) {\n+        ValueMapping vm = field.getKeyMapping();\n+        return joins.joinRelation(field.getName(), vm.getForeignKey(key), key,\n+            vm.getSelectSubclasses(), false, false);\n+    }\n+\n+    public void map(boolean adapt) {\n+        super.map(adapt);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        if (key.getTypeCode() != JavaTypes.PC || key.isEmbeddedPC())\n+            throw new MetaDataException(_loc.get(\"not-relation\", key));\n+        ValueMapping val = field.getElementMapping();\n+        if (val.getHandler() == null)\n+            throw new MetaDataException(_loc.get(\"no-handler\", val));\n+        assertNotMappedBy();\n+\n+        field.mapJoin(adapt, true);\n+        _vio = new ColumnIO();\n+        _vcols = HandlerStrategies.map(val, \"value\", _vio, adapt);\n+\n+        if (key.getTypeMapping().isMapped()) {\n+            ValueMappingInfo vinfo = key.getValueInfo();\n+            ForeignKey fk = vinfo.getTypeJoin(key, \"key\", false, adapt);\n+            key.setForeignKey(fk);\n+            key.setColumnIO(vinfo.getColumnIO());\n+        } else\n+            RelationStrategies.mapRelationToUnmappedPC(key, \"key\", adapt);\n+\n+        key.mapConstraints(\"key\", adapt);\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    public void initialize() {\n+        _vload = field.getElementMapping().getHandler().\n+            objectValueRequiresLoad(field.getElementMapping());\n+    }\n+\n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        insert(sm, store, rm, (Map) sm.fetchObject(field.getIndex()));\n+    }\n+\n+    private void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm,\n+        Map map)\n+        throws SQLException {\n+        if (map == null || map.isEmpty())\n+            return;\n+\n+        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n+        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n+            sm);\n+\n+        ValueMapping val = field.getElementMapping();\n+        ValueMapping key = field.getKeyMapping();\n+        StoreContext ctx = store.getContext();\n+        OpenJPAStateManager keysm;\n+        Map.Entry entry;\n+        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            keysm = RelationStrategies.getStateManager(entry.getKey(), ctx);\n+            key.setForeignKey(row, keysm);\n+            HandlerStrategies.set(val, entry.getValue(), store, row, _vcols,\n+                _vio, true);\n+            rm.flushSecondaryRow(row);\n+        }\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Map map = (Map) sm.fetchObject(field.getIndex());\n+        ChangeTracker ct = null;\n+        if (map instanceof Proxy) {\n+            Proxy proxy = (Proxy) map;\n+            if (Proxies.isOwner(proxy, sm, field.getIndex()))\n+                ct = proxy.getChangeTracker();\n+        }\n+\n+        // if no fine-grained change tracking then just delete and reinsert\n+        if (ct == null || !ct.isTracking()) {\n+            delete(sm, store, rm);\n+            insert(sm, store, rm, map);\n+            return;\n+        }\n+\n+        // delete the removes\n+        ValueMapping key = field.getKeyMapping();\n+        StoreContext ctx = store.getContext();\n+        Collection rem = ct.getRemoved();\n+        OpenJPAStateManager keysm;\n+        if (!rem.isEmpty()) {\n+            Row delRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_DELETE);\n+            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+            for (Iterator itr = rem.iterator(); itr.hasNext();) {\n+                keysm = RelationStrategies.getStateManager(itr.next(), ctx);\n+                key.whereForeignKey(delRow, keysm);\n+                rm.flushSecondaryRow(delRow);\n+            }\n+        }\n+\n+        // insert the adds\n+        ValueMapping val = field.getElementMapping();\n+        Collection add = ct.getAdded();\n+        Object mkey;\n+        if (!add.isEmpty()) {\n+            Row addRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_INSERT);\n+            addRow.setForeignKey(field.getJoinForeignKey(),\n+                field.getJoinColumnIO(), sm);\n+\n+            for (Iterator itr = add.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                keysm = RelationStrategies.getStateManager(mkey, ctx);\n+                key.setForeignKey(addRow, keysm);\n+                HandlerStrategies.set(val, map.get(mkey), store, addRow,\n+                    _vcols, _vio, true);\n+                rm.flushSecondaryRow(addRow);\n+            }\n+        }\n+\n+        // update the changes\n+        Collection change = ct.getChanged();\n+        if (!change.isEmpty()) {\n+            Row changeRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_UPDATE);\n+            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                keysm = RelationStrategies.getStateManager(mkey, ctx);\n+                key.whereForeignKey(changeRow, keysm);\n+                HandlerStrategies.set(val, map.get(mkey), store, changeRow,\n+                    _vcols, _vio, true);\n+                rm.flushSecondaryRow(changeRow);\n+            }\n+        }\n+    }\n+\n+    public Joins joinRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        if (traverse)\n+            HandlerStrategies.assertJoinable(field.getElementMapping());\n+        return joins;\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        ValueMapping key = field.getKeyMapping();\n+        ClassMapping[] clss = key.getIndependentTypeMappings();\n+        if (clss.length != 1) {\n+            if (traverse)\n+                throw RelationStrategies.unjoinable(field.getKeyMapping());\n+            return joins;\n+        }\n+        if (forceOuter)\n+            return joins.outerJoinRelation(field.getName(),\n+                key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\n+                false, false);\n+        return joins.joinRelation(field.getName(),\n+            key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\n+            false, false);\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return HandlerStrategies.toDataStoreValue(field.getElementMapping(),\n+            val, _vcols, store);\n+    }\n+\n+    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\n+        return RelationStrategies.toDataStoreValue(field.getKeyMapping(), val,\n+            store);\n+    }\n+}"},{"sha":"14a15da3e8e378216122c8979dc92e4d1800e29a","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","status":"modified","additions":375,"deletions":375,"changes":750,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,375 +1,375 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.meta.strats;\r\n-\r\n-import java.sql.*;\r\n-import java.util.*;\r\n-\r\n-import org.apache.openjpa.lib.util.*;\r\n-import org.apache.openjpa.meta.*;\r\n-import org.apache.openjpa.kernel.*;\r\n-import org.apache.openjpa.util.*;\r\n-import org.apache.openjpa.jdbc.meta.*;\r\n-import org.apache.openjpa.jdbc.kernel.*;\r\n-import org.apache.openjpa.jdbc.schema.*;\r\n-import org.apache.openjpa.jdbc.sql.*;\r\n-\r\n-/**\r\n- * <p>Mapping for a map whose keys and values are both relations to other\r\n- * persistent objects.</p>\r\n- *\r\n- * @author Abe White\r\n- * @since 0.4.0, 1.1.0\r\n- */\r\n-public class RelationRelationMapTableFieldStrategy\r\n-    extends MapTableFieldStrategy {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (RelationRelationMapTableFieldStrategy.class);\r\n-\r\n-    private String _keyRelationName = null;\r\n-\r\n-    public Column[] getKeyColumns(ClassMapping cls) {\r\n-        return field.getKeyMapping().getColumns();\r\n-    }\r\n-\r\n-    public Column[] getValueColumns(ClassMapping cls) {\r\n-        return field.getElementMapping().getColumns();\r\n-    }\r\n-\r\n-    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\r\n-        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\r\n-        sel.select(key, field.getKeyMapping().getSelectSubclasses(),\r\n-            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\r\n-    }\r\n-\r\n-    public void selectValue(Select sel, ClassMapping val,\r\n-        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \r\n-        Joins joins) {\r\n-        sel.select(val, field.getElementMapping().getSelectSubclasses(),\r\n-            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\r\n-    }\r\n-\r\n-    public Result[] getResults(final OpenJPAStateManager sm,\r\n-        final JDBCStore store, final JDBCFetchConfiguration fetch,\r\n-        final int eagerMode, final Joins[] resJoins, boolean lrs)\r\n-        throws SQLException {\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        final ClassMapping[] keys = key.getIndependentTypeMappings();\r\n-        Union kunion = store.getSQLFactory().newUnion(keys.length);\r\n-        if (fetch.getSubclassFetchMode(key.getTypeMapping())\r\n-            != JDBCFetchConfiguration.EAGER_JOIN)\r\n-            kunion.abortUnion();\r\n-        kunion.setLRS(lrs);\r\n-        kunion.select(new Union.Selector() {\r\n-            public void select(Select sel, int idx) {\r\n-                sel.whereForeignKey(field.getJoinForeignKey(),\r\n-                    sm.getObjectId(), field.getDefiningMapping(), store);\r\n-\r\n-                // order before select in case we're faking union with\r\n-                // multiple selects; order vals used to merge results\r\n-                Joins joins = joinKeyRelation(sel.newJoins(), keys[idx]);\r\n-                sel.orderBy(field.getKeyMapping().getColumns(), true, true);\r\n-                sel.select(keys[idx], field.getKeyMapping().\r\n-                    getSelectSubclasses(), store, fetch, eagerMode, joins);\r\n-\r\n-                //### cheat: result joins only care about the relation path;\r\n-                //### thus we can use first mapping of union only\r\n-                if (idx == 0)\r\n-                    resJoins[0] = joins;\r\n-            }\r\n-        });\r\n-\r\n-        ValueMapping val = field.getElementMapping();\r\n-        final ClassMapping[] vals = val.getIndependentTypeMappings();\r\n-        Union vunion = store.getSQLFactory().newUnion(vals.length);\r\n-        if (fetch.getSubclassFetchMode(val.getTypeMapping())\r\n-            != JDBCFetchConfiguration.EAGER_JOIN)\r\n-            vunion.abortUnion();\r\n-        vunion.setLRS(lrs);\r\n-        vunion.select(new Union.Selector() {\r\n-            public void select(Select sel, int idx) {\r\n-                sel.whereForeignKey(field.getJoinForeignKey(),\r\n-                    sm.getObjectId(), field.getDefiningMapping(), store);\r\n-\r\n-                // order before select in case we're faking union with\r\n-                // multiple selects; order vals used to merge results\r\n-                Joins joins = joinValueRelation(sel.newJoins(), vals[idx]);\r\n-                sel.orderBy(field.getKeyMapping().getColumns(), true, true);\r\n-                sel.select(vals[idx], field.getElementMapping().\r\n-                    getSelectSubclasses(), store, fetch, eagerMode, joins);\r\n-\r\n-                //### cheat: result joins only care about the relation path;\r\n-                //### thus we can use first mapping of union only\r\n-                if (idx == 0)\r\n-                    resJoins[1] = joins;\r\n-            }\r\n-        });\r\n-\r\n-        Result kres = null;\r\n-        Result vres = null;\r\n-        try {\r\n-            kres = kunion.execute(store, fetch);\r\n-            vres = vunion.execute(store, fetch);\r\n-            return new Result[]{ kres, vres };\r\n-        } catch (SQLException se) {\r\n-            if (kres != null)\r\n-                kres.close();\r\n-            if (vres != null)\r\n-                vres.close();\r\n-            throw se;\r\n-        }\r\n-    }\r\n-\r\n-    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        ClassMapping key = res.getBaseMapping();\r\n-        if (key == null)\r\n-            key = field.getKeyMapping().getIndependentTypeMappings()[0];\r\n-        return res.load(key, store, fetch, joins);\r\n-    }\r\n-\r\n-    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\r\n-        JDBCFetchConfiguration fetch, Result res, Joins joins)\r\n-        throws SQLException {\r\n-        ClassMapping val = res.getBaseMapping();\r\n-        if (val == null)\r\n-            val = field.getElementMapping().getIndependentTypeMappings()[0];\r\n-        return res.load(val, store, fetch, joins);\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, ClassMapping key) {\r\n-        ValueMapping vm = field.getKeyMapping();\r\n-        return joins.joinRelation(_keyRelationName, vm.getForeignKey(key), key,\r\n-            vm.getSelectSubclasses(), false, false);\r\n-    }\r\n-\r\n-    public Joins joinValueRelation(Joins joins, ClassMapping val) {\r\n-        ValueMapping vm = field.getElementMapping();\r\n-        return joins.joinRelation(field.getName(), vm.getForeignKey(val), val,\r\n-            vm.getSelectSubclasses(), false, false);\r\n-    }\r\n-\r\n-    public void map(boolean adapt) {\r\n-        super.map(adapt);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        if (key.getTypeCode() != JavaTypes.PC || key.isEmbeddedPC())\r\n-            throw new MetaDataException(_loc.get(\"not-relation\", key));\r\n-        ValueMapping val = field.getElementMapping();\r\n-        if (val.getTypeCode() != JavaTypes.PC || val.isEmbeddedPC())\r\n-            throw new MetaDataException(_loc.get(\"not-relation\", val));\r\n-        assertNotMappedBy();\r\n-\r\n-        field.mapJoin(adapt, true);\r\n-        mapTypeJoin(key, \"key\", adapt);\r\n-        mapTypeJoin(val, \"value\", adapt);\r\n-\r\n-        field.mapPrimaryKey(adapt);\r\n-    }\r\n-\r\n-    /**\r\n-     * Map the given value's join to its persistent type.\r\n-     */\r\n-    private void mapTypeJoin(ValueMapping vm, String name, boolean adapt) {\r\n-        if (vm.getTypeMapping().isMapped()) {\r\n-            ValueMappingInfo vinfo = vm.getValueInfo();\r\n-            ForeignKey fk = vinfo.getTypeJoin(vm, name, false, adapt);\r\n-            vm.setForeignKey(fk);\r\n-            vm.setColumnIO(vinfo.getColumnIO());\r\n-        } else\r\n-            RelationStrategies.mapRelationToUnmappedPC(vm, name, adapt);\r\n-        vm.mapConstraints(name, adapt);\r\n-    }\r\n-\r\n-    public void initialize() {\r\n-        _keyRelationName = field.getName() + \":key\";\r\n-    }\r\n-\r\n-    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        insert(sm, rm, (Map) sm.fetchObject(field.getIndex()));\r\n-    }\r\n-\r\n-    private void insert(OpenJPAStateManager sm, RowManager rm, Map map)\r\n-        throws SQLException {\r\n-        if (map == null || map.isEmpty())\r\n-            return;\r\n-\r\n-        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\r\n-        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\r\n-            sm);\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ValueMapping val = field.getElementMapping();\r\n-        StoreContext ctx = sm.getContext();\r\n-        OpenJPAStateManager keysm, valsm;\r\n-        Map.Entry entry;\r\n-        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\r\n-            entry = (Map.Entry) itr.next();\r\n-            keysm = RelationStrategies.getStateManager(entry.getKey(), ctx);\r\n-            valsm = RelationStrategies.getStateManager(entry.getValue(), ctx);\r\n-            key.setForeignKey(row, keysm);\r\n-            val.setForeignKey(row, valsm);\r\n-            rm.flushSecondaryRow(row);\r\n-        }\r\n-    }\r\n-\r\n-    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\r\n-        throws SQLException {\r\n-        Map map = (Map) sm.fetchObject(field.getIndex());\r\n-        ChangeTracker ct = null;\r\n-        if (map instanceof Proxy) {\r\n-            Proxy proxy = (Proxy) map;\r\n-            if (Proxies.isOwner(proxy, sm, field.getIndex()))\r\n-                ct = proxy.getChangeTracker();\r\n-        }\r\n-\r\n-        // if no fine-grained change tracking then just delete and reinsert\r\n-        if (ct == null || !ct.isTracking()) {\r\n-            delete(sm, store, rm);\r\n-            insert(sm, rm, map);\r\n-            return;\r\n-        }\r\n-\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ValueMapping val = field.getElementMapping();\r\n-        StoreContext ctx = store.getContext();\r\n-        OpenJPAStateManager keysm, valsm;\r\n-\r\n-        // update the changes; note that we have to featureSelection changes as\r\n-        // delete-then-insert if we have a foreign key action, because\r\n-        // secondary row updates aren't part of the constraint graph\r\n-        Collection change = ct.getChanged();\r\n-        boolean canChange = val.getForeignKey().isLogical();\r\n-        Object mkey;\r\n-        if (canChange && !change.isEmpty()) {\r\n-            Row changeRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_UPDATE);\r\n-            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                keysm = RelationStrategies.getStateManager(mkey, ctx);\r\n-                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\r\n-                key.whereForeignKey(changeRow, keysm);\r\n-                val.setForeignKey(changeRow, valsm);\r\n-                rm.flushSecondaryRow(changeRow);\r\n-            }\r\n-        }\r\n-\r\n-        // delete the removes\r\n-        Collection rem = ct.getRemoved();\r\n-        if (!rem.isEmpty() || (!canChange && !change.isEmpty())) {\r\n-            Row delRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_DELETE);\r\n-            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\r\n-\r\n-            for (Iterator itr = rem.iterator(); itr.hasNext();) {\r\n-                keysm = RelationStrategies.getStateManager(itr.next(), ctx);\r\n-                key.whereForeignKey(delRow, keysm);\r\n-                rm.flushSecondaryRow(delRow);\r\n-            }\r\n-            if (!canChange && !change.isEmpty()) {\r\n-                for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                    keysm = RelationStrategies.getStateManager(itr.next(),\r\n-                        ctx);\r\n-                    key.whereForeignKey(delRow, keysm);\r\n-                    rm.flushSecondaryRow(delRow);\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        // insert the adds\r\n-        Collection add = ct.getAdded();\r\n-        if (!add.isEmpty() || (!canChange && !change.isEmpty())) {\r\n-            Row addRow = rm.getSecondaryRow(field.getTable(),\r\n-                Row.ACTION_INSERT);\r\n-            addRow.setForeignKey(field.getJoinForeignKey(),\r\n-                field.getJoinColumnIO(), sm);\r\n-\r\n-            for (Iterator itr = add.iterator(); itr.hasNext();) {\r\n-                mkey = itr.next();\r\n-                keysm = RelationStrategies.getStateManager(mkey, ctx);\r\n-                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\r\n-                key.setForeignKey(addRow, keysm);\r\n-                val.setForeignKey(addRow, valsm);\r\n-                rm.flushSecondaryRow(addRow);\r\n-            }\r\n-            if (!canChange && !change.isEmpty()) {\r\n-                for (Iterator itr = change.iterator(); itr.hasNext();) {\r\n-                    mkey = itr.next();\r\n-                    keysm = RelationStrategies.getStateManager(mkey, ctx);\r\n-                    valsm = RelationStrategies.getStateManager(map.get(mkey),\r\n-                        ctx);\r\n-                    key.setForeignKey(addRow, keysm);\r\n-                    val.setForeignKey(addRow, valsm);\r\n-                    rm.flushSecondaryRow(addRow);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public Joins joinRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        ValueMapping val = field.getElementMapping();\r\n-        ClassMapping[] clss = val.getIndependentTypeMappings();\r\n-        if (clss.length != 1) {\r\n-            if (traverse)\r\n-                throw RelationStrategies.unjoinable(val);\r\n-            return joins;\r\n-        }\r\n-        if (forceOuter)\r\n-            return joins.outerJoinRelation(field.getName(),\r\n-                val.getForeignKey(clss[0]), clss[0], val.getSelectSubclasses(),\r\n-                false, false);\r\n-        return joins.joinRelation(field.getName(),\r\n-            val.getForeignKey(clss[0]), clss[0], val.getSelectSubclasses(),\r\n-            false, false);\r\n-    }\r\n-\r\n-    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\r\n-        boolean traverse) {\r\n-        ValueMapping key = field.getKeyMapping();\r\n-        ClassMapping[] clss = key.getIndependentTypeMappings();\r\n-        if (clss.length != 1) {\r\n-            if (traverse)\r\n-                throw RelationStrategies.unjoinable(key);\r\n-            return joins;\r\n-        }\r\n-        if (forceOuter)\r\n-            return joins.outerJoinRelation(field.getName(),\r\n-                key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\r\n-                false, false);\r\n-        return joins.joinRelation(_keyRelationName,\r\n-            key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(), \r\n-            false, false);\r\n-    }\r\n-\r\n-    public Object toDataStoreValue(Object val, JDBCStore store) {\r\n-        return RelationStrategies.toDataStoreValue(field.getElementMapping(),\r\n-            val, store);\r\n-    }\r\n-\r\n-    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\r\n-        return RelationStrategies.toDataStoreValue(field.getKeyMapping(),\r\n-            val, store);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.meta.strats;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+import org.apache.openjpa.lib.util.*;\n+import org.apache.openjpa.meta.*;\n+import org.apache.openjpa.kernel.*;\n+import org.apache.openjpa.util.*;\n+import org.apache.openjpa.jdbc.meta.*;\n+import org.apache.openjpa.jdbc.kernel.*;\n+import org.apache.openjpa.jdbc.schema.*;\n+import org.apache.openjpa.jdbc.sql.*;\n+\n+/**\n+ * <p>Mapping for a map whose keys and values are both relations to other\n+ * persistent objects.</p>\n+ *\n+ * @author Abe White\n+ * @since 0.4.0, 1.1.0\n+ */\n+public class RelationRelationMapTableFieldStrategy\n+    extends MapTableFieldStrategy {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (RelationRelationMapTableFieldStrategy.class);\n+\n+    private String _keyRelationName = null;\n+\n+    public Column[] getKeyColumns(ClassMapping cls) {\n+        return field.getKeyMapping().getColumns();\n+    }\n+\n+    public Column[] getValueColumns(ClassMapping cls) {\n+        return field.getElementMapping().getColumns();\n+    }\n+\n+    public void selectKey(Select sel, ClassMapping key, OpenJPAStateManager sm,\n+        JDBCStore store, JDBCFetchConfiguration fetch, Joins joins) {\n+        sel.select(key, field.getKeyMapping().getSelectSubclasses(),\n+            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\n+    }\n+\n+    public void selectValue(Select sel, ClassMapping val,\n+        OpenJPAStateManager sm, JDBCStore store, JDBCFetchConfiguration fetch, \n+        Joins joins) {\n+        sel.select(val, field.getElementMapping().getSelectSubclasses(),\n+            store, fetch, JDBCFetchConfiguration.EAGER_NONE, joins);\n+    }\n+\n+    public Result[] getResults(final OpenJPAStateManager sm,\n+        final JDBCStore store, final JDBCFetchConfiguration fetch,\n+        final int eagerMode, final Joins[] resJoins, boolean lrs)\n+        throws SQLException {\n+        ValueMapping key = field.getKeyMapping();\n+        final ClassMapping[] keys = key.getIndependentTypeMappings();\n+        Union kunion = store.getSQLFactory().newUnion(keys.length);\n+        if (fetch.getSubclassFetchMode(key.getTypeMapping())\n+            != JDBCFetchConfiguration.EAGER_JOIN)\n+            kunion.abortUnion();\n+        kunion.setLRS(lrs);\n+        kunion.select(new Union.Selector() {\n+            public void select(Select sel, int idx) {\n+                sel.whereForeignKey(field.getJoinForeignKey(),\n+                    sm.getObjectId(), field.getDefiningMapping(), store);\n+\n+                // order before select in case we're faking union with\n+                // multiple selects; order vals used to merge results\n+                Joins joins = joinKeyRelation(sel.newJoins(), keys[idx]);\n+                sel.orderBy(field.getKeyMapping().getColumns(), true, true);\n+                sel.select(keys[idx], field.getKeyMapping().\n+                    getSelectSubclasses(), store, fetch, eagerMode, joins);\n+\n+                //### cheat: result joins only care about the relation path;\n+                //### thus we can use first mapping of union only\n+                if (idx == 0)\n+                    resJoins[0] = joins;\n+            }\n+        });\n+\n+        ValueMapping val = field.getElementMapping();\n+        final ClassMapping[] vals = val.getIndependentTypeMappings();\n+        Union vunion = store.getSQLFactory().newUnion(vals.length);\n+        if (fetch.getSubclassFetchMode(val.getTypeMapping())\n+            != JDBCFetchConfiguration.EAGER_JOIN)\n+            vunion.abortUnion();\n+        vunion.setLRS(lrs);\n+        vunion.select(new Union.Selector() {\n+            public void select(Select sel, int idx) {\n+                sel.whereForeignKey(field.getJoinForeignKey(),\n+                    sm.getObjectId(), field.getDefiningMapping(), store);\n+\n+                // order before select in case we're faking union with\n+                // multiple selects; order vals used to merge results\n+                Joins joins = joinValueRelation(sel.newJoins(), vals[idx]);\n+                sel.orderBy(field.getKeyMapping().getColumns(), true, true);\n+                sel.select(vals[idx], field.getElementMapping().\n+                    getSelectSubclasses(), store, fetch, eagerMode, joins);\n+\n+                //### cheat: result joins only care about the relation path;\n+                //### thus we can use first mapping of union only\n+                if (idx == 0)\n+                    resJoins[1] = joins;\n+            }\n+        });\n+\n+        Result kres = null;\n+        Result vres = null;\n+        try {\n+            kres = kunion.execute(store, fetch);\n+            vres = vunion.execute(store, fetch);\n+            return new Result[]{ kres, vres };\n+        } catch (SQLException se) {\n+            if (kres != null)\n+                kres.close();\n+            if (vres != null)\n+                vres.close();\n+            throw se;\n+        }\n+    }\n+\n+    public Object loadKey(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        ClassMapping key = res.getBaseMapping();\n+        if (key == null)\n+            key = field.getKeyMapping().getIndependentTypeMappings()[0];\n+        return res.load(key, store, fetch, joins);\n+    }\n+\n+    public Object loadValue(OpenJPAStateManager sm, JDBCStore store,\n+        JDBCFetchConfiguration fetch, Result res, Joins joins)\n+        throws SQLException {\n+        ClassMapping val = res.getBaseMapping();\n+        if (val == null)\n+            val = field.getElementMapping().getIndependentTypeMappings()[0];\n+        return res.load(val, store, fetch, joins);\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, ClassMapping key) {\n+        ValueMapping vm = field.getKeyMapping();\n+        return joins.joinRelation(_keyRelationName, vm.getForeignKey(key), key,\n+            vm.getSelectSubclasses(), false, false);\n+    }\n+\n+    public Joins joinValueRelation(Joins joins, ClassMapping val) {\n+        ValueMapping vm = field.getElementMapping();\n+        return joins.joinRelation(field.getName(), vm.getForeignKey(val), val,\n+            vm.getSelectSubclasses(), false, false);\n+    }\n+\n+    public void map(boolean adapt) {\n+        super.map(adapt);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        if (key.getTypeCode() != JavaTypes.PC || key.isEmbeddedPC())\n+            throw new MetaDataException(_loc.get(\"not-relation\", key));\n+        ValueMapping val = field.getElementMapping();\n+        if (val.getTypeCode() != JavaTypes.PC || val.isEmbeddedPC())\n+            throw new MetaDataException(_loc.get(\"not-relation\", val));\n+        assertNotMappedBy();\n+\n+        field.mapJoin(adapt, true);\n+        mapTypeJoin(key, \"key\", adapt);\n+        mapTypeJoin(val, \"value\", adapt);\n+\n+        field.mapPrimaryKey(adapt);\n+    }\n+\n+    /**\n+     * Map the given value's join to its persistent type.\n+     */\n+    private void mapTypeJoin(ValueMapping vm, String name, boolean adapt) {\n+        if (vm.getTypeMapping().isMapped()) {\n+            ValueMappingInfo vinfo = vm.getValueInfo();\n+            ForeignKey fk = vinfo.getTypeJoin(vm, name, false, adapt);\n+            vm.setForeignKey(fk);\n+            vm.setColumnIO(vinfo.getColumnIO());\n+        } else\n+            RelationStrategies.mapRelationToUnmappedPC(vm, name, adapt);\n+        vm.mapConstraints(name, adapt);\n+    }\n+\n+    public void initialize() {\n+        _keyRelationName = field.getName() + \":key\";\n+    }\n+\n+    public void insert(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        insert(sm, rm, (Map) sm.fetchObject(field.getIndex()));\n+    }\n+\n+    private void insert(OpenJPAStateManager sm, RowManager rm, Map map)\n+        throws SQLException {\n+        if (map == null || map.isEmpty())\n+            return;\n+\n+        Row row = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n+        row.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(),\n+            sm);\n+\n+        ValueMapping key = field.getKeyMapping();\n+        ValueMapping val = field.getElementMapping();\n+        StoreContext ctx = sm.getContext();\n+        OpenJPAStateManager keysm, valsm;\n+        Map.Entry entry;\n+        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n+            entry = (Map.Entry) itr.next();\n+            keysm = RelationStrategies.getStateManager(entry.getKey(), ctx);\n+            valsm = RelationStrategies.getStateManager(entry.getValue(), ctx);\n+            key.setForeignKey(row, keysm);\n+            val.setForeignKey(row, valsm);\n+            rm.flushSecondaryRow(row);\n+        }\n+    }\n+\n+    public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm)\n+        throws SQLException {\n+        Map map = (Map) sm.fetchObject(field.getIndex());\n+        ChangeTracker ct = null;\n+        if (map instanceof Proxy) {\n+            Proxy proxy = (Proxy) map;\n+            if (Proxies.isOwner(proxy, sm, field.getIndex()))\n+                ct = proxy.getChangeTracker();\n+        }\n+\n+        // if no fine-grained change tracking then just delete and reinsert\n+        if (ct == null || !ct.isTracking()) {\n+            delete(sm, store, rm);\n+            insert(sm, rm, map);\n+            return;\n+        }\n+\n+        ValueMapping key = field.getKeyMapping();\n+        ValueMapping val = field.getElementMapping();\n+        StoreContext ctx = store.getContext();\n+        OpenJPAStateManager keysm, valsm;\n+\n+        // update the changes; note that we have to featureSelection changes as\n+        // delete-then-insert if we have a foreign key action, because\n+        // secondary row updates aren't part of the constraint graph\n+        Collection change = ct.getChanged();\n+        boolean canChange = val.getForeignKey().isLogical();\n+        Object mkey;\n+        if (canChange && !change.isEmpty()) {\n+            Row changeRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_UPDATE);\n+            changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                keysm = RelationStrategies.getStateManager(mkey, ctx);\n+                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n+                key.whereForeignKey(changeRow, keysm);\n+                val.setForeignKey(changeRow, valsm);\n+                rm.flushSecondaryRow(changeRow);\n+            }\n+        }\n+\n+        // delete the removes\n+        Collection rem = ct.getRemoved();\n+        if (!rem.isEmpty() || (!canChange && !change.isEmpty())) {\n+            Row delRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_DELETE);\n+            delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n+\n+            for (Iterator itr = rem.iterator(); itr.hasNext();) {\n+                keysm = RelationStrategies.getStateManager(itr.next(), ctx);\n+                key.whereForeignKey(delRow, keysm);\n+                rm.flushSecondaryRow(delRow);\n+            }\n+            if (!canChange && !change.isEmpty()) {\n+                for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                    keysm = RelationStrategies.getStateManager(itr.next(),\n+                        ctx);\n+                    key.whereForeignKey(delRow, keysm);\n+                    rm.flushSecondaryRow(delRow);\n+                }\n+            }\n+        }\n+\n+        // insert the adds\n+        Collection add = ct.getAdded();\n+        if (!add.isEmpty() || (!canChange && !change.isEmpty())) {\n+            Row addRow = rm.getSecondaryRow(field.getTable(),\n+                Row.ACTION_INSERT);\n+            addRow.setForeignKey(field.getJoinForeignKey(),\n+                field.getJoinColumnIO(), sm);\n+\n+            for (Iterator itr = add.iterator(); itr.hasNext();) {\n+                mkey = itr.next();\n+                keysm = RelationStrategies.getStateManager(mkey, ctx);\n+                valsm = RelationStrategies.getStateManager(map.get(mkey), ctx);\n+                key.setForeignKey(addRow, keysm);\n+                val.setForeignKey(addRow, valsm);\n+                rm.flushSecondaryRow(addRow);\n+            }\n+            if (!canChange && !change.isEmpty()) {\n+                for (Iterator itr = change.iterator(); itr.hasNext();) {\n+                    mkey = itr.next();\n+                    keysm = RelationStrategies.getStateManager(mkey, ctx);\n+                    valsm = RelationStrategies.getStateManager(map.get(mkey),\n+                        ctx);\n+                    key.setForeignKey(addRow, keysm);\n+                    val.setForeignKey(addRow, valsm);\n+                    rm.flushSecondaryRow(addRow);\n+                }\n+            }\n+        }\n+    }\n+\n+    public Joins joinRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        ValueMapping val = field.getElementMapping();\n+        ClassMapping[] clss = val.getIndependentTypeMappings();\n+        if (clss.length != 1) {\n+            if (traverse)\n+                throw RelationStrategies.unjoinable(val);\n+            return joins;\n+        }\n+        if (forceOuter)\n+            return joins.outerJoinRelation(field.getName(),\n+                val.getForeignKey(clss[0]), clss[0], val.getSelectSubclasses(),\n+                false, false);\n+        return joins.joinRelation(field.getName(),\n+            val.getForeignKey(clss[0]), clss[0], val.getSelectSubclasses(),\n+            false, false);\n+    }\n+\n+    public Joins joinKeyRelation(Joins joins, boolean forceOuter,\n+        boolean traverse) {\n+        ValueMapping key = field.getKeyMapping();\n+        ClassMapping[] clss = key.getIndependentTypeMappings();\n+        if (clss.length != 1) {\n+            if (traverse)\n+                throw RelationStrategies.unjoinable(key);\n+            return joins;\n+        }\n+        if (forceOuter)\n+            return joins.outerJoinRelation(field.getName(),\n+                key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(),\n+                false, false);\n+        return joins.joinRelation(_keyRelationName,\n+            key.getForeignKey(clss[0]), clss[0], key.getSelectSubclasses(), \n+            false, false);\n+    }\n+\n+    public Object toDataStoreValue(Object val, JDBCStore store) {\n+        return RelationStrategies.toDataStoreValue(field.getElementMapping(),\n+            val, store);\n+    }\n+\n+    public Object toKeyDataStoreValue(Object val, JDBCStore store) {\n+        return RelationStrategies.toDataStoreValue(field.getKeyMapping(),\n+            val, store);\n+    }\n+}"},{"sha":"49ff908876e070c60ee8b47af761892913afe6e5","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","status":"modified","additions":2,"deletions":5,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/AbstractDB2Dictionary.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -38,13 +38,9 @@ public AbstractDB2Dictionary() {\n \n         // DB2-based databases have restrictions on having uncast parameters\n         // in string functions\n-        toUpperCaseFunction = \"UPPER(CAST({0} AS VARCHAR(\" + varcharCastLength\n-            + \")))\";\n-        toLowerCaseFunction = \"LOWER(CAST({0} AS VARCHAR(\" + varcharCastLength\n-            + \")))\";\n         stringLengthFunction = \"LENGTH({0})\";\n         concatenateFunction = \"(CAST({0} AS VARCHAR(\" + varcharCastLength\n-            + \")))||(CAST({1} AS VARCHAR(1000)))\";\n+            + \")))||(CAST({1} AS VARCHAR(\" + varcharCastLength + \")))\";\n \n         trimLeadingFunction = \"LTRIM({0})\";\n         trimTrailingFunction = \"RTRIM({0})\";\n@@ -60,6 +56,7 @@ public AbstractDB2Dictionary() {\n         supportsLockingWithOuterJoin = false;\n         supportsLockingWithInnerJoin = false;\n         supportsLockingWithSelectRange = true;\n+        supportsCaseConversionForLob = true;\n \n         requiresAutoCommitForMetaData = true;\n         requiresAliasForSubselect = true;"},{"sha":"6e2bcb1237adfcc3af9e883d6ee2e97ea5341fa7","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","status":"modified","additions":859,"deletions":831,"changes":1690,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DB2Dictionary.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,831 +1,859 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.jdbc.sql;\r\n-\r\n-import java.lang.reflect.Method;\r\n-import java.sql.Connection;\r\n-import java.sql.DatabaseMetaData;\r\n-import java.sql.SQLException;\r\n-import java.sql.Types;\r\n-import java.util.Arrays;\r\n-import java.util.StringTokenizer;\r\n-\r\n-import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\r\n-import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\r\n-import org.apache.openjpa.jdbc.kernel.exps.Lit;\r\n-import org.apache.openjpa.jdbc.kernel.exps.Param;\r\n-import org.apache.openjpa.jdbc.kernel.exps.Val;\r\n-import org.apache.openjpa.jdbc.schema.Column;\r\n-import org.apache.openjpa.jdbc.schema.Index;\r\n-import org.apache.openjpa.jdbc.schema.Schema;\r\n-import org.apache.openjpa.jdbc.schema.Sequence;\r\n-import org.apache.openjpa.jdbc.schema.Table;\r\n-import org.apache.openjpa.kernel.Filters;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.util.OpenJPAException;\r\n-import org.apache.openjpa.util.UnsupportedException;\r\n-\r\n-import serp.util.Strings;\r\n-\r\n-/**\r\n- * Dictionary for IBM DB2 database.\r\n- */\r\n-public class DB2Dictionary\r\n-    extends AbstractDB2Dictionary {\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (DB2Dictionary.class);\r\n-\r\n-    public String optimizeClause = \"optimize for\";\r\n-    public String rowClause = \"row\";\r\n-    protected int db2ServerType = 0;\r\n-    public static final int db2ISeriesV5R3OrEarlier = 1;\r\n-    public static final int db2UDBV81OrEarlier = 2;\r\n-    public static final int db2ZOSV8xOrLater = 3;\r\n-    public static final int db2UDBV82OrLater = 4;\r\n-    public static final int db2ISeriesV5R4OrLater = 5;\r\n-\tprotected static final String forUpdate = \"FOR UPDATE\";\r\n-    protected static final String withURClause = \"WITH UR\";\r\n-    protected static final String withCSClause = \"WITH CS\";\r\n-    protected static final String withRSClause = \"WITH RS\";\r\n-    protected static final String withRRClause = \"WITH RR\";\r\n-    protected static final String useKeepShareLockClause\r\n-        = \"USE AND KEEP SHARE LOCKS\";\r\n-    protected static final String useKeepUpdateLockClause\r\n-        = \"USE AND KEEP UPDATE LOCKS\";\r\n-    protected static final String useKeepExclusiveLockClause\r\n-        = \"USE AND KEEP EXCLUSIVE LOCKS\";\r\n-    protected static final String forReadOnlyClause = \"FOR READ ONLY\";\r\n-    protected String databaseProductName = \"\";\r\n-    protected String databaseProductVersion = \"\";\r\n-    protected int maj = 0;\r\n-    protected int min = 0;\r\n-    \r\n-    private int defaultBatchLimit = 100;\r\n-\r\n-    public DB2Dictionary() {\r\n-        platform = \"DB2\";\r\n-        validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\r\n-            + \"SYSIBM.SYSTABLES\";\r\n-        supportsSelectEndIndex = true;\r\n-\r\n-        nextSequenceQuery = \"VALUES NEXTVAL FOR {0}\";\r\n-\r\n-        sequenceSQL = \"SELECT SEQSCHEMA AS SEQUENCE_SCHEMA, \"\r\n-            + \"SEQNAME AS SEQUENCE_NAME FROM SYSCAT.SEQUENCES\";\r\n-        sequenceSchemaSQL = \"SEQSCHEMA = ?\";\r\n-        sequenceNameSQL = \"SEQNAME = ?\";\r\n-        characterColumnSize = 254;\r\n-\r\n-        binaryTypeName = \"BLOB(1M)\";\r\n-        longVarbinaryTypeName = \"BLOB(1M)\";\r\n-        varbinaryTypeName = \"BLOB(1M)\";\r\n-        clobTypeName = \"CLOB(1M)\";\r\n-        longVarcharTypeName = \"LONG VARCHAR\";\r\n-        datePrecision = MICRO;\r\n-        storeCharsAsNumbers = false;\r\n-\r\n-        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\r\n-            \"LONG VARCHAR FOR BIT DATA\", \"LONG VARCHAR\", \"LONG VARGRAPHIC\",\r\n-        }));\r\n-        systemSchemas = new String(\r\n-                \"SYSCAT,SYSIBM,SYSSTAT,SYSIBMADM,SYSTOOLS\");\r\n-        maxConstraintNameLength = 18;\r\n-        maxIndexNameLength = 18;\r\n-        maxColumnNameLength = 30;\r\n-        supportsDeferredConstraints = false;\r\n-        supportsDefaultDeleteAction = false;\r\n-        supportsAlterTableWithDropColumn = false;\r\n-\r\n-        supportsNullTableForGetColumns = false;\r\n-        requiresCastForMathFunctions = true;\r\n-        requiresCastForComparisons = true;\r\n-\r\n-        reservedWordSet.addAll(Arrays.asList(new String[]{\r\n-            \"AFTER\", \"ALIAS\", \"ALLOW\", \"APPLICATION\", \"ASSOCIATE\", \"ASUTIME\",\r\n-            \"AUDIT\", \"AUX\", \"AUXILIARY\", \"BEFORE\", \"BINARY\", \"BUFFERPOOL\",\r\n-            \"CACHE\", \"CALL\", \"CALLED\", \"CAPTURE\", \"CARDINALITY\", \"CCSID\",\r\n-            \"CLUSTER\", \"COLLECTION\", \"COLLID\", \"COMMENT\", \"CONCAT\",\r\n-            \"CONDITION\", \"CONTAINS\", \"COUNT_BIG\", \"CURRENT_LC_CTYPE\",\r\n-            \"CURRENT_PATH\", \"CURRENT_SERVER\", \"CURRENT_TIMEZONE\", \"CYCLE\",\r\n-            \"DATA\", \"DATABASE\", \"DAYS\", \"DB2GENERAL\", \"DB2GENRL\", \"DB2SQL\",\r\n-            \"DBINFO\", \"DEFAULTS\", \"DEFINITION\", \"DETERMINISTIC\", \"DISALLOW\",\r\n-            \"DO\", \"DSNHATTR\", \"DSSIZE\", \"DYNAMIC\", \"EACH\", \"EDITPROC\", \"ELSEIF\",\r\n-            \"ENCODING\", \"END-EXEC1\", \"ERASE\", \"EXCLUDING\", \"EXIT\", \"FENCED\",\r\n-            \"FIELDPROC\", \"FILE\", \"FINAL\", \"FREE\", \"FUNCTION\", \"GENERAL\",\r\n-            \"GENERATED\", \"GRAPHIC\", \"HANDLER\", \"HOLD\", \"HOURS\", \"IF\",\r\n-            \"INCLUDING\", \"INCREMENT\", \"INDEX\", \"INHERIT\", \"INOUT\", \"INTEGRITY\",\r\n-            \"ISOBID\", \"ITERATE\", \"JAR\", \"JAVA\", \"LABEL\", \"LC_CTYPE\", \"LEAVE\",\r\n-            \"LINKTYPE\", \"LOCALE\", \"LOCATOR\", \"LOCATORS\", \"LOCK\", \"LOCKMAX\",\r\n-            \"LOCKSIZE\", \"LONG\", \"LOOP\", \"MAXVALUE\", \"MICROSECOND\",\r\n-            \"MICROSECONDS\", \"MINUTES\", \"MINVALUE\", \"MODE\", \"MODIFIES\", \"MONTHS\",\r\n-            \"NEW\", \"NEW_TABLE\", \"NOCACHE\", \"NOCYCLE\", \"NODENAME\", \"NODENUMBER\",\r\n-            \"NOMAXVALUE\", \"NOMINVALUE\", \"NOORDER\", \"NULLS\", \"NUMPARTS\", \"OBID\",\r\n-            \"OLD\", \"OLD_TABLE\", \"OPTIMIZATION\", \"OPTIMIZE\", \"OUT\", \"OVERRIDING\",\r\n-            \"PACKAGE\", \"PARAMETER\", \"PART\", \"PARTITION\", \"PATH\", \"PIECESIZE\",\r\n-            \"PLAN\", \"PRIQTY\", \"PROGRAM\", \"PSID\", \"QUERYNO\", \"READS\", \"RECOVERY\",\r\n-            \"REFERENCING\", \"RELEASE\", \"RENAME\", \"REPEAT\", \"RESET\", \"RESIGNAL\",\r\n-            \"RESTART\", \"RESULT\", \"RESULT_SET_LOCATOR\", \"RETURN\", \"RETURNS\",\r\n-            \"ROUTINE\", \"ROW\", \"RRN\", \"RUN\", \"SAVEPOINT\", \"SCRATCHPAD\",\r\n-            \"SECONDS\", \"SECQTY\", \"SECURITY\", \"SENSITIVE\", \"SIGNAL\", \"SIMPLE\",\r\n-            \"SOURCE\", \"SPECIFIC\", \"SQLID\", \"STANDARD\", \"START\", \"STATIC\",\r\n-            \"STAY\", \"STOGROUP\", \"STORES\", \"STYLE\", \"SUBPAGES\", \"SYNONYM\",\r\n-            \"SYSFUN\", \"SYSIBM\", \"SYSPROC\", \"SYSTEM\", \"TABLESPACE\", \"TRIGGER\",\r\n-            \"TYPE\", \"UNDO\", \"UNTIL\", \"VALIDPROC\", \"VARIABLE\", \"VARIANT\", \"VCAT\",\r\n-            \"VOLUMES\", \"WHILE\", \"WLM\", \"YEARS\",\r\n-        }));\r\n-        \r\n-        super.setBatchLimit(defaultBatchLimit);\r\n-        \r\n-        selectWordSet.add(\"WITH\");\r\n-    }\r\n-\r\n-    public boolean supportsRandomAccessResultSet(Select sel,\r\n-        boolean forUpdate) {\r\n-        return !forUpdate\r\n-            && super.supportsRandomAccessResultSet(sel, forUpdate);\r\n-    }\r\n-\r\n-    protected void appendSelectRange(SQLBuffer buf, long start, long end,\r\n-        boolean subselect) {\r\n-        // appends the literal range string, since DB2 is unable to handle\r\n-        // a bound parameter for it\r\n-        // do not generate FETCH FIRST clause for subselect\r\n-        if (!subselect)\r\n-            buf.append(\" FETCH FIRST \").append(Long.toString(end)).\r\n-                append(\" ROWS ONLY\");\r\n-    }\r\n-\r\n-    protected void appendSelect(SQLBuffer selectSQL, Object alias, Select sel,\r\n-        int idx) {\r\n-        // if this is a literal value, add a cast...\r\n-        Object val = sel.getSelects().get(idx);\r\n-        if (val instanceof Lit)\r\n-            selectSQL.append(\"CAST(\");\r\n-\r\n-        // ... and add the select per super's behavior...\r\n-        super.appendSelect(selectSQL, alias, sel, idx);\r\n-\r\n-        // ... and finish the cast\r\n-        if (val instanceof Lit) {\r\n-            Class c = ((Lit) val).getType();\r\n-            int javaTypeCode = JavaTypes.getTypeCode(c);\r\n-            int jdbcTypeCode = getJDBCType(javaTypeCode, false);\r\n-            String typeName = getTypeName(jdbcTypeCode);\r\n-            selectSQL.append(\" AS \" + typeName);\r\n-\r\n-            // if the literal is a string, use the default char col size\r\n-            // in the cast statement.\r\n-            if (String.class.equals(c))\r\n-                selectSQL.append(\"(\" + characterColumnSize + \")\");\r\n-\r\n-            selectSQL.append(\")\");\r\n-        }\r\n-    }\r\n-\r\n-    public String[] getCreateSequenceSQL(Sequence seq) {\r\n-        String[] sql = super.getCreateSequenceSQL(seq);\r\n-        if (seq.getAllocate() > 1)\r\n-            sql[0] += \" CACHE \" + seq.getAllocate();\r\n-        return sql;\r\n-    }\r\n-\r\n-    protected String getSequencesSQL(String schemaName, String sequenceName) {\r\n-        StringBuffer buf = new StringBuffer();\r\n-        buf.append(sequenceSQL);\r\n-        if (schemaName != null || sequenceName != null)\r\n-            buf.append(\" WHERE \");\r\n-        if (schemaName != null) {\r\n-            buf.append(sequenceSchemaSQL);\r\n-            if (sequenceName != null)\r\n-                buf.append(\" AND \");\r\n-        }\r\n-        if (sequenceName != null)\r\n-            buf.append(sequenceNameSQL);\r\n-        return buf.toString();\r\n-    }\r\n-\r\n-    public Connection decorate(Connection conn)\r\n-        throws SQLException {\r\n-        // some versions of the DB2 driver seem to default to\r\n-        // READ_UNCOMMITTED, which will prevent locking from working\r\n-        // (multiple SELECT ... FOR UPDATE statements are allowed on\r\n-        // the same instance); if we have not overridden the\r\n-        // transaction isolation in the configuration, default to\r\n-        // TRANSACTION_READ_COMMITTED\r\n-        conn = super.decorate(conn);\r\n-\r\n-        if (conf.getTransactionIsolationConstant() == -1\r\n-            && conn.getTransactionIsolation() < conn.TRANSACTION_READ_COMMITTED)\r\n-            conn.setTransactionIsolation(conn.TRANSACTION_READ_COMMITTED);\r\n-\r\n-        return conn;\r\n-    }\r\n-\r\n-    public void connectedConfiguration(Connection conn) throws SQLException {\r\n-    \tsuper.connectedConfiguration(conn);\r\n-\r\n-    \tDatabaseMetaData metaData = conn.getMetaData();\r\n-        databaseProductName = nullSafe(metaData.getDatabaseProductName());\r\n-        databaseProductVersion = nullSafe(metaData.getDatabaseProductVersion());\r\n-        \r\n-        // Determine the type of DB2 database\r\n-        // First check for AS/400\r\n-        getProductVersionMajorMinorForISeries();\r\n-\r\n-        if (maj > 0) {\r\n-            if (isDB2ISeriesV5R3OrEarlier())\r\n-                db2ServerType = db2ISeriesV5R3OrEarlier;\r\n-            else if (isDB2ISeriesV5R4OrLater())\r\n-                db2ServerType = db2ISeriesV5R4OrLater;\r\n-        }\r\n-        \r\n-    \tif (db2ServerType == 0) {\r\n-    \t    if (isJDBC3) {\r\n-    \t        maj = metaData.getDatabaseMajorVersion();\r\n-    \t        min = metaData.getDatabaseMinorVersion();\r\n-    \t    }\r\n-    \t    else\r\n-    \t        getProductVersionMajorMinor();\r\n-\r\n-    \t    // Determine the type of DB2 database for ZOS & UDB\r\n-    \t    if (isDB2UDBV81OrEarlier())\r\n-    \t        db2ServerType = db2UDBV81OrEarlier;\r\n-    \t    else if (isDB2ZOSV8xOrLater())\r\n-    \t        db2ServerType = db2ZOSV8xOrLater;\r\n-    \t    else if (isDB2UDBV82OrLater())\r\n-    \t        db2ServerType = db2UDBV82OrLater;\r\n-        }\r\n-\r\n-        // verify that databae product is supported\r\n-        if (db2ServerType == 0 || maj == 0)\r\n-            throw new UnsupportedException(_loc.get(\"db-not-supported\",\r\n-                new Object[] {databaseProductName, databaseProductVersion }));                    \r\n-\r\n-    \tif (maj >= 9 || (maj == 8 && min >= 2)) {\r\n-    \t    supportsLockingWithMultipleTables = true;\r\n-    \t    supportsLockingWithInnerJoin = true;\r\n-    \t    supportsLockingWithOuterJoin = true;\r\n-    \t    forUpdateClause = \"WITH RR USE AND KEEP UPDATE LOCKS\";\r\n-    \t    if (maj >=9)\r\n-    \t        supportsXMLColumn = true;\r\n-    \t}\r\n-\r\n-        // platform specific settings\r\n-        switch (db2ServerType) {\r\n-        case  db2ZOSV8xOrLater:\r\n-            // DB2 Z/OS \r\n-            characterColumnSize = 255;\r\n-            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            sequenceSQL = \"SELECT SCHEMA AS SEQUENCE_SCHEMA, \"\r\n-                + \"NAME AS SEQUENCE_NAME FROM SYSIBM.SYSSEQUENCES\";\r\n-            sequenceSchemaSQL = \"SCHEMA = ?\";\r\n-            sequenceNameSQL = \"NAME = ?\";\r\n-            if (maj == 8)\r\n-                // DB2 Z/OS Version 8: no bigint support, hence map Java\r\n-                // long to decimal\r\n-                bigintTypeName = \"DECIMAL(31,0)\";\r\n-            break;\r\n-        case db2ISeriesV5R3OrEarlier:\r\n-        case db2ISeriesV5R4OrLater:\r\n-            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\r\n-                + \"SYSIBM.SYSDUMMY1\";\r\n-            validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\r\n-                + \"QSYS2.SYSTABLES\";\r\n-            sequenceSQL = \"SELECT SEQUENCE_SCHEMA, \"\r\n-                + \"SEQUENCE_NAME FROM QSYS2.SYSSEQUENCES\";\r\n-            sequenceSchemaSQL = \"SEQUENCE_SCHEMA = ?\";\r\n-            sequenceNameSQL = \"SEQUENCE_NAME = ?\";\r\n-            break;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Get the update clause for the query based on the\r\n-     * updateClause and isolationLevel hints\r\n-     */\r\n-    protected String getForUpdateClause(JDBCFetchConfiguration fetch,\r\n-        boolean isForUpdate, Select sel) {\r\n-        int isolationLevel;\r\n-        // For db2UDBV81OrEarlier and db2ISeriesV5R3OrEarlier:\r\n-        // \"optimize for\" clause appears before \"for update\" clause.\r\n-        StringBuffer forUpdateString = new StringBuffer(\r\n-            getOptimizeClause(sel));\r\n-        try {\r\n-            // Determine the isolationLevel; the fetch\r\n-            // configuration data overrides the persistence.xml value\r\n-            if (fetch != null && fetch.getIsolation() != -1)\r\n-                isolationLevel = fetch.getIsolation();\r\n-            else\r\n-                isolationLevel = conf.getTransactionIsolationConstant();\r\n-\r\n-            if (isForUpdate) {\r\n-                switch(db2ServerType) {\r\n-                case db2ISeriesV5R3OrEarlier:\r\n-                case db2UDBV81OrEarlier:\r\n-                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE)\r\n-                        forUpdateString.append(\" \").append(forUpdateClause);\r\n-                    else \r\n-                        forUpdateString.append(\" \").append(forUpdate)\r\n-                            .append(\" \").append(withRSClause);\r\n-                    break;\r\n-                case db2ZOSV8xOrLater:\r\n-                case db2UDBV82OrLater:\r\n-                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\r\n-                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                            .append(\" \").append(withRRClause)\r\n-                            .append(\" \").append(useKeepUpdateLockClause);   \r\n-                    } else {\r\n-                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                            .append(\" \").append(withRSClause)\r\n-                            .append(\" \").append(useKeepUpdateLockClause);                            \r\n-                    }\r\n-                    break;\r\n-                case db2ISeriesV5R4OrLater:\r\n-                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\r\n-                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                            .append(\" \").append(withRRClause)\r\n-                            .append(\" \").append(useKeepExclusiveLockClause);       \r\n-                    } else {\r\n-                        forUpdateString.append(\" \").append(forReadOnlyClause)\r\n-                            .append(\" \").append(withRSClause)\r\n-                            .append(\" \").append(useKeepExclusiveLockClause);\r\n-                    }\r\n-                    break;\r\n-                }\r\n-            }\r\n-        }\r\n-        catch (Exception e) {\r\n-            if (log.isTraceEnabled())\r\n-                log.error(e.toString(),e);\r\n-        }\r\n-        return forUpdateString.toString();\r\n-    }\r\n-\r\n-    public boolean isDB2UDBV82OrLater() {\r\n-        return (databaseProductVersion.indexOf(\"SQL\") != -1\r\n-             || databaseProductName.indexOf(\"DB2/\") != -1)\r\n-             && ((maj == 8 && min >= 2) || (maj >= 9));\r\n-    }\r\n-\r\n-    public boolean isDB2ZOSV8xOrLater() {\r\n-       return (databaseProductVersion.indexOf(\"DSN\") != -1\r\n-            || databaseProductName.indexOf(\"DB2/\") == -1)\r\n-            && maj >= 8;\r\n-           \r\n-    }\r\n-\r\n-    public boolean isDB2ISeriesV5R3OrEarlier() {\r\n-       return (databaseProductName.indexOf(\"AS\") != -1\r\n-           && ((maj == 5 && min <=3) || maj < 5));\r\n-    }\r\n-\r\n-    public boolean isDB2ISeriesV5R4OrLater() {\r\n-       return databaseProductName.indexOf(\"AS\") != -1\r\n-           && (maj >=6 || (maj == 5 && min >=4));\r\n-    }\r\n-\r\n-    public boolean isDB2UDBV81OrEarlier() {\r\n-        return (databaseProductVersion.indexOf(\"SQL\") != -1 \r\n-            || databaseProductName.indexOf(\"DB2/\") != -1) \r\n-            && ((maj == 8 && min <= 1) || maj < 8);\r\n-    }\r\n-\r\n-    /** Get the version Major/Minor for the ISeries\r\n-     */\r\n-    private void getProductVersionMajorMinorForISeries() {\r\n-        // ISeries    DBProdName                 DB2 UDB for AS/400\r\n-        //   (Toolbox)DBProdVersion              05.04.0000 V5R4m0\r\n-        // ISeries                               DB2 UDB for AS/400\r\n-        //   (Native)                            V5R4M0\r\n-        // new jcc    DBProdVersion              QSQ05040 or QSQ06010\r\n-        if (databaseProductName.indexOf(\"AS\") != -1) {\r\n-            // default to V5R4\r\n-            maj = 5;\r\n-            min = 4;\r\n-            int index = databaseProductVersion.indexOf('V');\r\n-            if (index != -1) {\r\n-                String s = databaseProductVersion.substring(index);\r\n-                s = s.toUpperCase();\r\n-\r\n-                StringTokenizer stringtokenizer = new StringTokenizer(s, \"VRM\"\r\n-                    , false);\r\n-                if (stringtokenizer.countTokens() == 3) {\r\n-                    String s1 = stringtokenizer.nextToken();\r\n-                    maj = Integer.parseInt(s1);\r\n-                    String s2 =  stringtokenizer.nextToken();\r\n-                    min = Integer.parseInt(s2);\r\n-                }\r\n-            } else {\r\n-                index = databaseProductVersion.indexOf('0');\r\n-                if (index != -1) {\r\n-                    String s = databaseProductVersion.substring(index);\r\n-                    s = s.toUpperCase();\r\n-\r\n-                    StringTokenizer stringtokenizer = new StringTokenizer(s, \"0\"\r\n-                        , false);                    \r\n-                    if (stringtokenizer.countTokens() == 2) {\r\n-                        String s1 = stringtokenizer.nextToken();\r\n-                        maj = Integer.parseInt(s1);\r\n-                        String s2 =  stringtokenizer.nextToken();\r\n-                        min = Integer.parseInt(s2);\r\n-                    }\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    \r\n-    private void getProductVersionMajorMinor() {\r\n-        // Incase JDBC driver version is lower than 3\r\n-        // use following info to determine Major and Minor \r\n-        //                        CLI    vs      JCC\r\n-        // ZDBV8 DBProdName       DB2            DB2\r\n-        //       DBProdVersion    08.01.0005     DSN08015\r\n-        // ZDBV9                  DB2            DB2\r\n-        //                        09.01.0005     DSN09015\r\n-        // WinV9                  DB2/NT         DB2/NT\r\n-        //                        09.01.0000     SQL09010\r\n-        // SolarisV9                             DB2/SUN64\r\n-        //                                       SQL0901\r\n-        // Linux                  DB2/LINUX      DB2/LINUX\r\n-        //                        09.01.0000     SQL0901\r\n-        if (databaseProductVersion.indexOf(\"09\") != -1) {\r\n-            maj = 9;\r\n-            if (databaseProductVersion.indexOf(\"01\") != -1) {\r\n-                min = 1;\r\n-            }\r\n-        } else if (databaseProductVersion.indexOf(\"08\") != -1) {\r\n-            maj = 8;\r\n-            min = 2;\r\n-            if (databaseProductVersion.indexOf(\"01\") != -1) {\r\n-                min = 1;\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    protected String getOptimizeClause(Select sel) {\r\n-        if (sel != null && sel.getExpectedResultCount() > 0) {\r\n-            StringBuffer buf = new StringBuffer();\r\n-            buf.append(\" \").append(optimizeClause).append(\" \")\r\n-                .append(String.valueOf(sel.getExpectedResultCount()))\r\n-                .append(\" \").append(rowClause);\r\n-            return buf.toString();\r\n-        }\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-    public OpenJPAException newStoreException(String msg, SQLException[] causes,\r\n-        Object failed) {\r\n-        if (causes != null && causes.length > 0)\r\n-            msg = appendExtendedExceptionMsg(msg, causes[0]);\r\n-        return super.newStoreException(msg, causes, failed);\r\n-    }\r\n-\r\n-    /**\r\n-     *  Append exception information from SQLCA to the exsisting\r\n-     *  exception meassage\r\n-     */\r\n-    private String appendExtendedExceptionMsg(String msg, SQLException sqle){\r\n-       final String GETSQLCA =\"getSqlca\";\r\n-       String exceptionMsg = new String();\r\n-       try {\r\n-            Method sqlcaM2 = sqle.getNextException().getClass()\r\n-                             .getMethod(GETSQLCA,null);\r\n-            Object sqlca = sqlcaM2.invoke(sqle.getNextException(),\r\n-                                          new Object[] {});\r\n-            Method  getSqlErrpMethd = sqlca.getClass().\r\n-            getMethod(\"getSqlErrp\", null);\r\n-            Method  getSqlWarnMethd = sqlca.getClass().\r\n-            getMethod(\"getSqlWarn\", null);\r\n-            Method  getSqlErrdMethd = sqlca.getClass().\r\n-            getMethod(\"getSqlErrd\", null);\r\n-            StringBuffer errdStr = new StringBuffer();\r\n-\r\n-            int[] errds = (int[]) getSqlErrdMethd.invoke(sqlca, new Object[]{});\r\n-            for (int i = 0; i < errds.length; i++)\r\n-                errdStr.append(errdStr.length() > 0 ? \", \" : \"\").\r\n-                    append(errds[i]);\r\n-            exceptionMsg = exceptionMsg.concat( \"SQLCA OUTPUT\" +\r\n-                    \"[Errp=\" + getSqlErrpMethd.invoke(sqlca, new Object[]{})\r\n-                    + \", Errd=\" + errdStr);\r\n-\r\n-            String Warn = new String((char[]) getSqlWarnMethd.\r\n-                    invoke(sqlca, new Object[]{}));\r\n-            if (Warn.trim().length() != 0)\r\n-                exceptionMsg = exceptionMsg.concat(\", Warn=\" +Warn + \"]\" );\r\n-            else\r\n-                exceptionMsg = exceptionMsg.concat( \"]\" );\r\n-            msg = msg.concat(exceptionMsg);\r\n-            \r\n-            // for batched execution failures, SQLExceptions are nested\r\n-            SQLException sqle2 = sqle.getNextException();\r\n-            while (sqle2 != null) {                \r\n-                msg = msg.concat(\"\\n\" + sqle2.getMessage());\r\n-                sqle2 = sqle2.getNextException();\r\n-            }\r\n-            \r\n-            return msg;\r\n-        } catch (Throwable t) {\r\n-            return sqle.getMessage();\r\n-        }\r\n-    }\r\n-\r\n-    public int getDb2ServerType() {\r\n-        return db2ServerType;\r\n-    }\r\n-    \r\n-    protected void appendLength(SQLBuffer buf, int type) {\r\n-        if (type == Types.VARCHAR)\r\n-            buf.append(\"(\").append(Integer.toString(characterColumnSize)).\r\n-                append(\")\");\r\n-    }\r\n-\r\n-    /**\r\n-     * If this dictionary supports XML type,\r\n-     * use this method to append xml predicate.\r\n-     * \r\n-     * @param buf the SQL buffer to write the comparison\r\n-     * @param op the comparison operation to perform\r\n-     * @param lhs the left hand side of the comparison\r\n-     * @param rhs the right hand side of the comparison\r\n-     * @param lhsxml indicates whether the left operand maps to xml\r\n-     * @param rhsxml indicates whether the right operand maps to xml\r\n-     */\r\n-    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\r\n-        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\r\n-        super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\r\n-        if (lhsxml && rhsxml)\r\n-            appendXmlComparison2(buf, op, lhs, rhs);\r\n-        else if (lhsxml)\r\n-            appendXmlComparison1(buf, op, lhs, rhs);\r\n-        else \r\n-            appendXmlComparison1(buf, op, rhs, lhs);\r\n-    }\r\n-\r\n-    /**\r\n-     * Append an xml comparison predicate.\r\n-     *\r\n-     * @param buf the SQL buffer to write the comparison\r\n-     * @param op the comparison operation to perform\r\n-     * @param lhs the left hand side of the comparison (maps to xml column)\r\n-     * @param rhs the right hand side of the comparison\r\n-     */\r\n-    private void appendXmlComparison1(SQLBuffer buf, String op, \r\n-            FilterValue lhs, FilterValue rhs) {\r\n-        boolean castrhs = false;\r\n-        Class rc = Filters.wrap(rhs.getType());\r\n-        int type = 0;\r\n-        if (rhs.isConstant()) {\r\n-            type = getJDBCType(JavaTypes.getTypeCode(rc), false);\r\n-            castrhs = true;\r\n-        }\r\n-        \r\n-        appendXmlExists(buf, lhs);\r\n-\r\n-        buf.append(\" \").append(op).append(\" \");\r\n-        \r\n-        buf.append(\"$\");\r\n-        if (castrhs)\r\n-            buf.append(\"Parm\");\r\n-        else\r\n-            rhs.appendTo(buf);\r\n-        \r\n-        buf.append(\"]' PASSING \");\r\n-        appendXmlVar(buf, lhs);\r\n-        buf.append(\", \");\r\n-        \r\n-        if (castrhs)\r\n-            appendCast(buf, rhs, type);\r\n-        else\r\n-            rhs.appendTo(buf);\r\n-        \r\n-        buf.append(\" AS \\\"\");\r\n-        if (castrhs)\r\n-            buf.append(\"Parm\");\r\n-        else\r\n-            rhs.appendTo(buf);\r\n-        buf.append(\"\\\")\");\r\n-    }\r\n-    \r\n-    /**\r\n-     * Append an xml comparison predicate. (both operands map to xml column)\r\n-     *\r\n-     * @param buf the SQL buffer to write the comparison\r\n-     * @param op the comparison operation to perform\r\n-     * @param lhs the left hand side of the comparison (maps to xml column)\r\n-     * @param rhs the right hand side of the comparison (maps to xml column)\r\n-     */\r\n-    private void appendXmlComparison2(SQLBuffer buf, String op, \r\n-            FilterValue lhs, FilterValue rhs) {\r\n-        appendXmlExists(buf, lhs);\r\n-        \r\n-        buf.append(\" \").append(op).append(\" \");\r\n-        \r\n-        buf.append(\"$\").append(rhs.getColumnAlias(\r\n-            rhs.getFieldMapping().getColumns()[0])).\r\n-            append(\"/*/\");\r\n-        rhs.appendTo(buf);\r\n-        \r\n-        buf.append(\"]' PASSING \");\r\n-        appendXmlVar(buf, lhs);\r\n-        buf.append(\", \");\r\n-        appendXmlVar(buf, rhs);\r\n-        buf.append(\")\");\r\n-    }\r\n-    \r\n-    private void appendXmlVar(SQLBuffer buf, FilterValue val) {\r\n-        buf.append(val.getColumnAlias(\r\n-            val.getFieldMapping().getColumns()[0])).\r\n-            append(\" AS \").\r\n-            append(\"\\\"\").append(val.getColumnAlias(\r\n-            val.getFieldMapping().getColumns()[0])).\r\n-            append(\"\\\"\");        \r\n-    }\r\n-    \r\n-    private void appendXmlExists(SQLBuffer buf, FilterValue val) {\r\n-        buf.append(\"XMLEXISTS('\");\r\n-        buf.append(\"$\").append(val.getColumnAlias(\r\n-            val.getFieldMapping().getColumns()[0])).\r\n-            append(\"/*[\");\r\n-        val.appendTo(buf);        \r\n-    }\r\n-    \r\n-    /**\r\n-     * add CAST for a scalar function where operand is a param\r\n-     * \r\n-     * @param func original string\r\n-     * @param target substring to look for\r\n-     * @param asString \r\n-     * @return updated string (func)\r\n-     */\r\n-    private String addCastAsString(String func, String target, \r\n-            String asString) {\r\n-        String fstring = func;\r\n-        if (func.indexOf(target) != -1)\r\n-            fstring = Strings.replace(\r\n-                func, target, \"CAST(\" + target + asString + \")\");\r\n-        return fstring;\r\n-    }\r\n-\r\n-    /**\r\n-     * add CAST for a function operator where operand is a param\r\n-     * \r\n-     * @param func function name\r\n-     * @param val type\r\n-     * @return updated string (func)\r\n-     */\r\n-    public String addCastAsType(String func, Val val) {\r\n-        String fstring = null;\r\n-        String type = getTypeName(getJDBCType(JavaTypes.getTypeCode(val\r\n-            .getType()), false));\r\n-        if (String.class.equals(val.getType()))\r\n-            type = type + \"(\" + characterColumnSize + \")\";\r\n-        fstring = \"CAST(? AS \" + type + \")\";\r\n-        return fstring;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the batch limit. If the batchLimit is -1, change it to 100 for\r\n-     * best performance\r\n-     */\r\n-    public int getBatchLimit() {\r\n-        int limit = super.getBatchLimit();\r\n-        if (limit == UNLIMITED) {\r\n-            limit = defaultBatchLimit;\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(_loc.get(\"batch_unlimit\", String.valueOf(limit)));\r\n-        }\r\n-        return limit;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the correct CAST function syntax\r\n-     * \r\n-     * @param val operand of cast\r\n-     * @param func original string\r\n-     * @return a String with the correct CAST function syntax\r\n-     */\r\n-    public String getCastFunction(Val val, String func) {\r\n-        if (val instanceof Lit || val instanceof Param)\r\n-            if (func.indexOf(\"VARCHAR\") == -1)\r\n-                func = addCastAsString(func, \"{0}\", \" AS VARCHAR(1000)\");\r\n-        return func;\r\n-    }\r\n-\r\n-    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\r\n-            FilterValue start) {\r\n-        if (find.getValue() != null) { // non constants\r\n-            buf.append(\"(LOCATE(CAST((\");\r\n-            find.appendTo(buf);\r\n-            buf.append(\") AS VARCHAR(1000)), \");\r\n-        } else {\r\n-            // this is a constant\r\n-            buf.append(\"(LOCATE(\");\r\n-            find.appendTo(buf);\r\n-            buf.append(\", \");\r\n-        }\r\n-        if (str.getValue() != null) {\r\n-            buf.append(\"CAST((\");\r\n-            str.appendTo(buf);\r\n-            buf.append(\") AS VARCHAR(1000))\");\r\n-        } else {\r\n-            str.appendTo(buf);\r\n-        }\r\n-        if (start != null) {\r\n-            if (start.getValue() == null) {\r\n-                buf.append(\", CAST((\");\r\n-                start.appendTo(buf);\r\n-                buf.append(\") AS INTEGER) + 1\");\r\n-            } else {\r\n-                buf.append(\", \");\r\n-                start.appendTo(buf);\r\n-            }\r\n-        }\r\n-        buf.append(\") - 1)\");\r\n-    }\r\n-    \r\n-    /** \r\n-     * Cast the specified value to the specified type.\r\n-     *\r\n-     * @param buf the buffer to append the cast to\r\n-     * @param val the value to cast\r\n-     * @param type the type of the case, e.g. {@link Types#NUMERIC}\r\n-     */\r\n-    public void appendCast(SQLBuffer buf, FilterValue val, int type) {\r\n-\r\n-        // Convert the cast function: \"CAST({0} AS {1})\"\r\n-        int firstParam = castFunction.indexOf(\"{0}\");\r\n-        String pre = castFunction.substring(0, firstParam); // \"CAST(\"\r\n-        String mid = castFunction.substring(firstParam + 3);\r\n-        int secondParam = mid.indexOf(\"{1}\");\r\n-        String post;\r\n-        if (secondParam > -1) {\r\n-            post = mid.substring(secondParam + 3); // \")\"\r\n-            mid = mid.substring(0, secondParam); // \" AS \"\r\n-        } else\r\n-            post = \"\";\r\n-\r\n-        // No need to add CAST if the value is a constant\r\n-        if (val instanceof Lit || val instanceof Param) {\r\n-            buf.append(pre);\r\n-            val.appendTo(buf);\r\n-            buf.append(mid);\r\n-            buf.append(getTypeName(type));\r\n-            appendLength(buf, type);\r\n-            buf.append(post);\r\n-        } else {\r\n-            val.appendTo(buf);\r\n-            String sqlString = buf.getSQL(false);\r\n-            if (sqlString.endsWith(\"?\")) {\r\n-                // case \"(?\" - convert to \"CAST(? AS type\"\r\n-                String typeName = getTypeName(type);\r\n-                if (String.class.equals(val.getType()))\r\n-                    typeName = typeName + \"(\" + characterColumnSize + \")\";\r\n-                String str = \"CAST(? AS \" + typeName + \")\";\r\n-                buf.replaceSqlString(sqlString.length() - 1,\r\n-                        sqlString.length(), str);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Create an index if necessary for some database tables\r\n-     */\r\n-    public void createIndexIfNecessary(Schema schema, String table,\r\n-            Column pkColumn) {\r\n-        if (isDB2ZOSV8xOrLater()) {\r\n-            // build the index for the sequence tables\r\n-            // the index name will the fully qualified table name + _IDX\r\n-            Table tab = schema.getTable(table);\r\n-            Index idx = tab.addIndex(tab.getFullName() + \"_IDX\");\r\n-            idx.setUnique(true);\r\n-            idx.addColumn(pkColumn);\r\n-        }\r\n-    }\r\n-    \r\n-    String nullSafe(String s) {\r\n-    \treturn s == null ? \"\" : s;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.lang.reflect.Method;\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.Arrays;\n+import java.util.StringTokenizer;\n+\n+import org.apache.openjpa.jdbc.kernel.JDBCFetchConfiguration;\n+import org.apache.openjpa.jdbc.kernel.exps.FilterValue;\n+import org.apache.openjpa.jdbc.kernel.exps.Lit;\n+import org.apache.openjpa.jdbc.kernel.exps.Param;\n+import org.apache.openjpa.jdbc.kernel.exps.Val;\n+import org.apache.openjpa.jdbc.schema.Column;\n+import org.apache.openjpa.jdbc.schema.Index;\n+import org.apache.openjpa.jdbc.schema.Schema;\n+import org.apache.openjpa.jdbc.schema.Sequence;\n+import org.apache.openjpa.jdbc.schema.Table;\n+import org.apache.openjpa.kernel.Filters;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.OpenJPAException;\n+import org.apache.openjpa.util.UnsupportedException;\n+\n+import serp.util.Strings;\n+\n+/**\n+ * Dictionary for IBM DB2 database.\n+ */\n+public class DB2Dictionary\n+    extends AbstractDB2Dictionary {\n+    private static final Localizer _loc = Localizer.forPackage\n+        (DB2Dictionary.class);\n+\n+    public String optimizeClause = \"optimize for\";\n+    public String rowClause = \"row\";\n+    protected int db2ServerType = 0;\n+    public static final int db2ISeriesV5R3OrEarlier = 1;\n+    public static final int db2UDBV81OrEarlier = 2;\n+    public static final int db2ZOSV8xOrLater = 3;\n+    public static final int db2UDBV82OrLater = 4;\n+    public static final int db2ISeriesV5R4OrLater = 5;\n+\tprotected static final String forUpdate = \"FOR UPDATE\";\n+    protected static final String withURClause = \"WITH UR\";\n+    protected static final String withCSClause = \"WITH CS\";\n+    protected static final String withRSClause = \"WITH RS\";\n+    protected static final String withRRClause = \"WITH RR\";\n+    protected static final String useKeepShareLockClause\n+        = \"USE AND KEEP SHARE LOCKS\";\n+    protected static final String useKeepUpdateLockClause\n+        = \"USE AND KEEP UPDATE LOCKS\";\n+    protected static final String useKeepExclusiveLockClause\n+        = \"USE AND KEEP EXCLUSIVE LOCKS\";\n+    protected static final String forReadOnlyClause = \"FOR READ ONLY\";\n+    protected String databaseProductName = \"\";\n+    protected String databaseProductVersion = \"\";\n+    protected int maj = 0;\n+    protected int min = 0;\n+    \n+    private int defaultBatchLimit = 100;\n+\n+    public DB2Dictionary() {\n+        platform = \"DB2\";\n+        validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\n+            + \"SYSIBM.SYSTABLES\";\n+        supportsSelectEndIndex = true;\n+\n+        nextSequenceQuery = \"VALUES NEXTVAL FOR {0}\";\n+\n+        sequenceSQL = \"SELECT SEQSCHEMA AS SEQUENCE_SCHEMA, \"\n+            + \"SEQNAME AS SEQUENCE_NAME FROM SYSCAT.SEQUENCES\";\n+        sequenceSchemaSQL = \"SEQSCHEMA = ?\";\n+        sequenceNameSQL = \"SEQNAME = ?\";\n+        characterColumnSize = 254;\n+\n+        binaryTypeName = \"BLOB(1M)\";\n+        longVarbinaryTypeName = \"BLOB(1M)\";\n+        varbinaryTypeName = \"BLOB(1M)\";\n+        clobTypeName = \"CLOB(1M)\";\n+        longVarcharTypeName = \"LONG VARCHAR\";\n+        datePrecision = MICRO;\n+        storeCharsAsNumbers = false;\n+\n+        fixedSizeTypeNameSet.addAll(Arrays.asList(new String[]{\n+            \"LONG VARCHAR FOR BIT DATA\", \"LONG VARCHAR\", \"LONG VARGRAPHIC\",\n+        }));\n+        systemSchemas = new String(\n+                \"SYSCAT,SYSIBM,SYSSTAT,SYSIBMADM,SYSTOOLS\");\n+        maxConstraintNameLength = 18;\n+        maxIndexNameLength = 18;\n+        maxColumnNameLength = 30;\n+        supportsDeferredConstraints = false;\n+        supportsDefaultDeleteAction = false;\n+        supportsAlterTableWithDropColumn = false;\n+\n+        supportsNullTableForGetColumns = false;\n+        requiresCastForMathFunctions = true;\n+        requiresCastForComparisons = true;\n+\n+        reservedWordSet.addAll(Arrays.asList(new String[]{\n+            \"AFTER\", \"ALIAS\", \"ALLOW\", \"APPLICATION\", \"ASSOCIATE\", \"ASUTIME\",\n+            \"AUDIT\", \"AUX\", \"AUXILIARY\", \"BEFORE\", \"BINARY\", \"BUFFERPOOL\",\n+            \"CACHE\", \"CALL\", \"CALLED\", \"CAPTURE\", \"CARDINALITY\", \"CCSID\",\n+            \"CLUSTER\", \"COLLECTION\", \"COLLID\", \"COMMENT\", \"CONCAT\",\n+            \"CONDITION\", \"CONTAINS\", \"COUNT_BIG\", \"CURRENT_LC_CTYPE\",\n+            \"CURRENT_PATH\", \"CURRENT_SERVER\", \"CURRENT_TIMEZONE\", \"CYCLE\",\n+            \"DATA\", \"DATABASE\", \"DAYS\", \"DB2GENERAL\", \"DB2GENRL\", \"DB2SQL\",\n+            \"DBINFO\", \"DEFAULTS\", \"DEFINITION\", \"DETERMINISTIC\", \"DISALLOW\",\n+            \"DO\", \"DSNHATTR\", \"DSSIZE\", \"DYNAMIC\", \"EACH\", \"EDITPROC\", \"ELSEIF\",\n+            \"ENCODING\", \"END-EXEC1\", \"ERASE\", \"EXCLUDING\", \"EXIT\", \"FENCED\",\n+            \"FIELDPROC\", \"FILE\", \"FINAL\", \"FREE\", \"FUNCTION\", \"GENERAL\",\n+            \"GENERATED\", \"GRAPHIC\", \"HANDLER\", \"HOLD\", \"HOURS\", \"IF\",\n+            \"INCLUDING\", \"INCREMENT\", \"INDEX\", \"INHERIT\", \"INOUT\", \"INTEGRITY\",\n+            \"ISOBID\", \"ITERATE\", \"JAR\", \"JAVA\", \"LABEL\", \"LC_CTYPE\", \"LEAVE\",\n+            \"LINKTYPE\", \"LOCALE\", \"LOCATOR\", \"LOCATORS\", \"LOCK\", \"LOCKMAX\",\n+            \"LOCKSIZE\", \"LONG\", \"LOOP\", \"MAXVALUE\", \"MICROSECOND\",\n+            \"MICROSECONDS\", \"MINUTES\", \"MINVALUE\", \"MODE\", \"MODIFIES\", \"MONTHS\",\n+            \"NEW\", \"NEW_TABLE\", \"NOCACHE\", \"NOCYCLE\", \"NODENAME\", \"NODENUMBER\",\n+            \"NOMAXVALUE\", \"NOMINVALUE\", \"NOORDER\", \"NULLS\", \"NUMPARTS\", \"OBID\",\n+            \"OLD\", \"OLD_TABLE\", \"OPTIMIZATION\", \"OPTIMIZE\", \"OUT\", \"OVERRIDING\",\n+            \"PACKAGE\", \"PARAMETER\", \"PART\", \"PARTITION\", \"PATH\", \"PIECESIZE\",\n+            \"PLAN\", \"PRIQTY\", \"PROGRAM\", \"PSID\", \"QUERYNO\", \"READS\", \"RECOVERY\",\n+            \"REFERENCING\", \"RELEASE\", \"RENAME\", \"REPEAT\", \"RESET\", \"RESIGNAL\",\n+            \"RESTART\", \"RESULT\", \"RESULT_SET_LOCATOR\", \"RETURN\", \"RETURNS\",\n+            \"ROUTINE\", \"ROW\", \"RRN\", \"RUN\", \"SAVEPOINT\", \"SCRATCHPAD\",\n+            \"SECONDS\", \"SECQTY\", \"SECURITY\", \"SENSITIVE\", \"SIGNAL\", \"SIMPLE\",\n+            \"SOURCE\", \"SPECIFIC\", \"SQLID\", \"STANDARD\", \"START\", \"STATIC\",\n+            \"STAY\", \"STOGROUP\", \"STORES\", \"STYLE\", \"SUBPAGES\", \"SYNONYM\",\n+            \"SYSFUN\", \"SYSIBM\", \"SYSPROC\", \"SYSTEM\", \"TABLESPACE\", \"TRIGGER\",\n+            \"TYPE\", \"UNDO\", \"UNTIL\", \"VALIDPROC\", \"VARIABLE\", \"VARIANT\", \"VCAT\",\n+            \"VOLUMES\", \"WHILE\", \"WLM\", \"YEARS\",\n+        }));\n+        \n+        super.setBatchLimit(defaultBatchLimit);\n+        \n+        selectWordSet.add(\"WITH\");\n+    }\n+\n+    public boolean supportsRandomAccessResultSet(Select sel,\n+        boolean forUpdate) {\n+        return !forUpdate\n+            && super.supportsRandomAccessResultSet(sel, forUpdate);\n+    }\n+\n+    protected void appendSelectRange(SQLBuffer buf, long start, long end,\n+        boolean subselect) {\n+        // appends the literal range string, since DB2 is unable to handle\n+        // a bound parameter for it\n+        // do not generate FETCH FIRST clause for subselect\n+        if (!subselect)\n+            buf.append(\" FETCH FIRST \").append(Long.toString(end)).\n+                append(\" ROWS ONLY\");\n+    }\n+\n+    protected void appendSelect(SQLBuffer selectSQL, Object alias, Select sel,\n+        int idx) {\n+        // if this is a literal value, add a cast...\n+        Object val = sel.getSelects().get(idx);\n+        if (val instanceof Lit)\n+            selectSQL.append(\"CAST(\");\n+\n+        // ... and add the select per super's behavior...\n+        super.appendSelect(selectSQL, alias, sel, idx);\n+\n+        // ... and finish the cast\n+        if (val instanceof Lit) {\n+            Class c = ((Lit) val).getType();\n+            int javaTypeCode = JavaTypes.getTypeCode(c);\n+            int jdbcTypeCode = getJDBCType(javaTypeCode, false);\n+            String typeName = getTypeName(jdbcTypeCode);\n+            selectSQL.append(\" AS \" + typeName);\n+\n+            // if the literal is a string, use the default char col size\n+            // in the cast statement.\n+            if (String.class.equals(c))\n+                selectSQL.append(\"(\" + characterColumnSize + \")\");\n+\n+            selectSQL.append(\")\");\n+        }\n+    }\n+\n+    public String[] getCreateSequenceSQL(Sequence seq) {\n+        String[] sql = super.getCreateSequenceSQL(seq);\n+        if (seq.getAllocate() > 1)\n+            sql[0] += \" CACHE \" + seq.getAllocate();\n+        return sql;\n+    }\n+\n+    protected String getSequencesSQL(String schemaName, String sequenceName) {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(sequenceSQL);\n+        if (schemaName != null || sequenceName != null)\n+            buf.append(\" WHERE \");\n+        if (schemaName != null) {\n+            buf.append(sequenceSchemaSQL);\n+            if (sequenceName != null)\n+                buf.append(\" AND \");\n+        }\n+        if (sequenceName != null)\n+            buf.append(sequenceNameSQL);\n+        return buf.toString();\n+    }\n+\n+    public Connection decorate(Connection conn)\n+        throws SQLException {\n+        // some versions of the DB2 driver seem to default to\n+        // READ_UNCOMMITTED, which will prevent locking from working\n+        // (multiple SELECT ... FOR UPDATE statements are allowed on\n+        // the same instance); if we have not overridden the\n+        // transaction isolation in the configuration, default to\n+        // TRANSACTION_READ_COMMITTED\n+        conn = super.decorate(conn);\n+\n+        if (conf.getTransactionIsolationConstant() == -1\n+            && conn.getTransactionIsolation() < conn.TRANSACTION_READ_COMMITTED)\n+            conn.setTransactionIsolation(conn.TRANSACTION_READ_COMMITTED);\n+\n+        return conn;\n+    }\n+\n+    public void connectedConfiguration(Connection conn) throws SQLException {\n+    \tsuper.connectedConfiguration(conn);\n+\n+    \tDatabaseMetaData metaData = conn.getMetaData();\n+        databaseProductName = nullSafe(metaData.getDatabaseProductName());\n+        databaseProductVersion = nullSafe(metaData.getDatabaseProductVersion());\n+        \n+        // Determine the type of DB2 database\n+        // First check for AS/400\n+        getProductVersionMajorMinorForISeries();\n+\n+        if (maj > 0) {\n+            if (isDB2ISeriesV5R3OrEarlier())\n+                db2ServerType = db2ISeriesV5R3OrEarlier;\n+            else if (isDB2ISeriesV5R4OrLater())\n+                db2ServerType = db2ISeriesV5R4OrLater;\n+        }\n+        \n+    \tif (db2ServerType == 0) {\n+    \t    if (isJDBC3) {\n+    \t        maj = metaData.getDatabaseMajorVersion();\n+    \t        min = metaData.getDatabaseMinorVersion();\n+    \t    }\n+    \t    else\n+    \t        getProductVersionMajorMinor();\n+\n+    \t    // Determine the type of DB2 database for ZOS & UDB\n+    \t    if (isDB2UDBV81OrEarlier())\n+    \t        db2ServerType = db2UDBV81OrEarlier;\n+    \t    else if (isDB2ZOSV8xOrLater())\n+    \t        db2ServerType = db2ZOSV8xOrLater;\n+    \t    else if (isDB2UDBV82OrLater())\n+    \t        db2ServerType = db2UDBV82OrLater;\n+        }\n+\n+        // verify that databae product is supported\n+        if (db2ServerType == 0 || maj == 0)\n+            throw new UnsupportedException(_loc.get(\"db-not-supported\",\n+                new Object[] {databaseProductName, databaseProductVersion }));                    \n+\n+    \tif (maj >= 9 || (maj == 8 && min >= 2)) {\n+    \t    supportsLockingWithMultipleTables = true;\n+    \t    supportsLockingWithInnerJoin = true;\n+    \t    supportsLockingWithOuterJoin = true;\n+    \t    forUpdateClause = \"WITH RR USE AND KEEP UPDATE LOCKS\";\n+    \t    if (maj >=9)\n+    \t        supportsXMLColumn = true;\n+    \t}\n+\n+        // platform specific settings\n+        switch (db2ServerType) {\n+        case  db2ZOSV8xOrLater:\n+            // DB2 Z/OS \n+            characterColumnSize = 255;\n+            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            sequenceSQL = \"SELECT SCHEMA AS SEQUENCE_SCHEMA, \"\n+                + \"NAME AS SEQUENCE_NAME FROM SYSIBM.SYSSEQUENCES\";\n+            sequenceSchemaSQL = \"SCHEMA = ?\";\n+            sequenceNameSQL = \"NAME = ?\";\n+            if (maj == 8) {\n+                // DB2 Z/OS Version 8: no bigint support, hence map Java\n+                // long to decimal\n+                bigintTypeName = \"DECIMAL(31,0)\";\n+            }\n+            ignoreSQLExceptionOnSetQueryTimeout = true; \n+            break;\n+        case db2ISeriesV5R3OrEarlier:\n+        case db2ISeriesV5R4OrLater:\n+            lastGeneratedKeyQuery = \"SELECT IDENTITY_VAL_LOCAL() FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            nextSequenceQuery = \"SELECT NEXTVAL FOR {0} FROM \"\n+                + \"SYSIBM.SYSDUMMY1\";\n+            validationSQL = \"SELECT DISTINCT(CURRENT TIMESTAMP) FROM \"\n+                + \"QSYS2.SYSTABLES\";\n+            sequenceSQL = \"SELECT SEQUENCE_SCHEMA, \"\n+                + \"SEQUENCE_NAME FROM QSYS2.SYSSEQUENCES\";\n+            sequenceSchemaSQL = \"SEQUENCE_SCHEMA = ?\";\n+            sequenceNameSQL = \"SEQUENCE_NAME = ?\";\n+            break;\n+        }\n+    }\n+\n+    /**\n+     * Get the update clause for the query based on the\n+     * updateClause and isolationLevel hints\n+     */\n+    protected String getForUpdateClause(JDBCFetchConfiguration fetch,\n+        boolean isForUpdate, Select sel) {\n+        int isolationLevel;\n+        // For db2UDBV81OrEarlier and db2ISeriesV5R3OrEarlier:\n+        // \"optimize for\" clause appears before \"for update\" clause.\n+        StringBuffer forUpdateString = new StringBuffer(\n+            getOptimizeClause(sel));\n+        try {\n+            // Determine the isolationLevel; the fetch\n+            // configuration data overrides the persistence.xml value\n+            if (fetch != null && fetch.getIsolation() != -1)\n+                isolationLevel = fetch.getIsolation();\n+            else\n+                isolationLevel = conf.getTransactionIsolationConstant();\n+\n+            if (isForUpdate) {\n+                switch(db2ServerType) {\n+                case db2ISeriesV5R3OrEarlier:\n+                case db2UDBV81OrEarlier:\n+                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE)\n+                        forUpdateString.append(\" \").append(forUpdateClause);\n+                    else \n+                        forUpdateString.append(\" \").append(forUpdate)\n+                            .append(\" \").append(withRSClause);\n+                    break;\n+                case db2ZOSV8xOrLater:\n+                case db2UDBV82OrLater:\n+                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\n+                            .append(\" \").append(withRRClause)\n+                            .append(\" \").append(useKeepUpdateLockClause);   \n+                    } else {\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\n+                            .append(\" \").append(withRSClause)\n+                            .append(\" \").append(useKeepUpdateLockClause);                            \n+                    }\n+                    break;\n+                case db2ISeriesV5R4OrLater:\n+                    if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\n+                            .append(\" \").append(withRRClause)\n+                            .append(\" \").append(useKeepExclusiveLockClause);       \n+                    } else {\n+                        forUpdateString.append(\" \").append(forReadOnlyClause)\n+                            .append(\" \").append(withRSClause)\n+                            .append(\" \").append(useKeepExclusiveLockClause);\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+        catch (Exception e) {\n+            if (log.isTraceEnabled())\n+                log.error(e.toString(),e);\n+        }\n+        return forUpdateString.toString();\n+    }\n+\n+    public boolean isDB2UDBV82OrLater() {\n+        return (databaseProductVersion.indexOf(\"SQL\") != -1\n+             || databaseProductName.indexOf(\"DB2/\") != -1)\n+             && ((maj == 8 && min >= 2) || (maj >= 9));\n+    }\n+\n+    public boolean isDB2ZOSV8xOrLater() {\n+       return (databaseProductVersion.indexOf(\"DSN\") != -1\n+            || databaseProductName.indexOf(\"DB2/\") == -1)\n+            && maj >= 8;\n+    }\n+\n+    public boolean isDB2ISeriesV5R3OrEarlier() {\n+       return (databaseProductName.indexOf(\"AS\") != -1\n+           && ((maj == 5 && min <=3) || maj < 5));\n+    }\n+\n+    public boolean isDB2ISeriesV5R4OrLater() {\n+       return databaseProductName.indexOf(\"AS\") != -1\n+           && (maj >=6 || (maj == 5 && min >=4));\n+    }\n+\n+    public boolean isDB2UDBV81OrEarlier() {\n+        return (databaseProductVersion.indexOf(\"SQL\") != -1 \n+            || databaseProductName.indexOf(\"DB2/\") != -1) \n+            && ((maj == 8 && min <= 1) || maj < 8);\n+    }\n+\n+    /** Get the version Major/Minor for the ISeries\n+     */\n+    private void getProductVersionMajorMinorForISeries() {\n+        // ISeries    DBProdName                 DB2 UDB for AS/400\n+        //   (Toolbox)DBProdVersion              05.04.0000 V5R4m0\n+        // ISeries                               DB2 UDB for AS/400\n+        //   (Native)                            V5R4M0\n+        // new jcc    DBProdVersion              QSQ05040 or QSQ06010\n+        if (databaseProductName.indexOf(\"AS\") != -1) {\n+            // default to V5R4\n+            maj = 5;\n+            min = 4;\n+            int index = databaseProductVersion.indexOf('V');\n+            if (index != -1) {\n+                String s = databaseProductVersion.substring(index);\n+                s = s.toUpperCase();\n+\n+                StringTokenizer stringtokenizer = new StringTokenizer(s, \"VRM\"\n+                    , false);\n+                if (stringtokenizer.countTokens() == 3) {\n+                    String s1 = stringtokenizer.nextToken();\n+                    maj = Integer.parseInt(s1);\n+                    String s2 =  stringtokenizer.nextToken();\n+                    min = Integer.parseInt(s2);\n+                }\n+            } else {\n+                index = databaseProductVersion.indexOf('0');\n+                if (index != -1) {\n+                    String s = databaseProductVersion.substring(index);\n+                    s = s.toUpperCase();\n+\n+                    StringTokenizer stringtokenizer = new StringTokenizer(s, \"0\"\n+                        , false);                    \n+                    if (stringtokenizer.countTokens() == 2) {\n+                        String s1 = stringtokenizer.nextToken();\n+                        maj = Integer.parseInt(s1);\n+                        String s2 =  stringtokenizer.nextToken();\n+                        min = Integer.parseInt(s2);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    \n+    private void getProductVersionMajorMinor() {\n+        // Incase JDBC driver version is lower than 3\n+        // use following info to determine Major and Minor \n+        //                        CLI    vs      JCC\n+        // ZDBV8 DBProdName       DB2            DB2\n+        //       DBProdVersion    08.01.0005     DSN08015\n+        // ZDBV9                  DB2            DB2\n+        //                        09.01.0005     DSN09015\n+        // WinV9                  DB2/NT         DB2/NT\n+        //                        09.01.0000     SQL09010\n+        // SolarisV9                             DB2/SUN64\n+        //                                       SQL0901\n+        // Linux                  DB2/LINUX      DB2/LINUX\n+        //                        09.01.0000     SQL0901\n+        if (databaseProductVersion.indexOf(\"09\") != -1) {\n+            maj = 9;\n+            if (databaseProductVersion.indexOf(\"01\") != -1) {\n+                min = 1;\n+            }\n+        } else if (databaseProductVersion.indexOf(\"08\") != -1) {\n+            maj = 8;\n+            min = 2;\n+            if (databaseProductVersion.indexOf(\"01\") != -1) {\n+                min = 1;\n+            }\n+        }\n+    }\n+\n+    protected String getOptimizeClause(Select sel) {\n+        if (sel != null && sel.getExpectedResultCount() > 0) {\n+            StringBuffer buf = new StringBuffer();\n+            buf.append(\" \").append(optimizeClause).append(\" \")\n+                .append(String.valueOf(sel.getExpectedResultCount()))\n+                .append(\" \").append(rowClause);\n+            return buf.toString();\n+        }\n+\n+        return \"\";\n+    }\n+\n+    public OpenJPAException newStoreException(String msg, SQLException[] causes,\n+        Object failed) {\n+        if (causes != null && causes.length > 0)\n+            msg = appendExtendedExceptionMsg(msg, causes[0]);\n+        return super.newStoreException(msg, causes, failed);\n+    }\n+\n+    /**\n+     *  Append exception information from SQLCA to the exsisting\n+     *  exception meassage\n+     */\n+    private String appendExtendedExceptionMsg(String msg, SQLException sqle){\n+       final String GETSQLCA =\"getSqlca\";\n+       String exceptionMsg = new String();\n+       try {\n+            Method sqlcaM2 = sqle.getNextException().getClass()\n+                             .getMethod(GETSQLCA,null);\n+            Object sqlca = sqlcaM2.invoke(sqle.getNextException(),\n+                                          new Object[] {});\n+            Method  getSqlErrpMethd = sqlca.getClass().\n+            getMethod(\"getSqlErrp\", null);\n+            Method  getSqlWarnMethd = sqlca.getClass().\n+            getMethod(\"getSqlWarn\", null);\n+            Method  getSqlErrdMethd = sqlca.getClass().\n+            getMethod(\"getSqlErrd\", null);\n+            StringBuffer errdStr = new StringBuffer();\n+\n+            int[] errds = (int[]) getSqlErrdMethd.invoke(sqlca, new Object[]{});\n+            for (int i = 0; i < errds.length; i++)\n+                errdStr.append(errdStr.length() > 0 ? \", \" : \"\").\n+                    append(errds[i]);\n+            exceptionMsg = exceptionMsg.concat( \"SQLCA OUTPUT\" +\n+                    \"[Errp=\" + getSqlErrpMethd.invoke(sqlca, new Object[]{})\n+                    + \", Errd=\" + errdStr);\n+\n+            String Warn = new String((char[]) getSqlWarnMethd.\n+                    invoke(sqlca, new Object[]{}));\n+            if (Warn.trim().length() != 0)\n+                exceptionMsg = exceptionMsg.concat(\", Warn=\" +Warn + \"]\" );\n+            else\n+                exceptionMsg = exceptionMsg.concat( \"]\" );\n+            msg = msg.concat(exceptionMsg);\n+            \n+            // for batched execution failures, SQLExceptions are nested\n+            SQLException sqle2 = sqle.getNextException();\n+            while (sqle2 != null) {                \n+                msg = msg.concat(\"\\n\" + sqle2.getMessage());\n+                sqle2 = sqle2.getNextException();\n+            }\n+            \n+            return msg;\n+        } catch (Throwable t) {\n+            return sqle.getMessage();\n+        }\n+    }\n+\n+    public int getDb2ServerType() {\n+        return db2ServerType;\n+    }\n+    \n+    protected void appendLength(SQLBuffer buf, int type) {\n+        if (type == Types.VARCHAR)\n+            buf.append(\"(\").append(Integer.toString(characterColumnSize)).\n+                append(\")\");\n+    }\n+\n+    /**\n+     * If this dictionary supports XML type,\n+     * use this method to append xml predicate.\n+     * \n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison\n+     * @param rhs the right hand side of the comparison\n+     * @param lhsxml indicates whether the left operand maps to xml\n+     * @param rhsxml indicates whether the right operand maps to xml\n+     */\n+    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\n+        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\n+        super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\n+        if (lhsxml && rhsxml)\n+            appendXmlComparison2(buf, op, lhs, rhs);\n+        else if (lhsxml)\n+            appendXmlComparison1(buf, op, lhs, rhs);\n+        else \n+            appendXmlComparison1(buf, op, rhs, lhs);\n+    }\n+\n+    /**\n+     * Append an xml comparison predicate.\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison\n+     */\n+    private void appendXmlComparison1(SQLBuffer buf, String op, \n+            FilterValue lhs, FilterValue rhs) {\n+        boolean castrhs = false;\n+        Class rc = Filters.wrap(rhs.getType());\n+        int type = 0;\n+        if (rhs.isConstant()) {\n+            type = getJDBCType(JavaTypes.getTypeCode(rc), false);\n+            castrhs = true;\n+        }\n+        \n+        appendXmlExists(buf, lhs);\n+\n+        buf.append(\" \").append(op).append(\" \");\n+        \n+        buf.append(\"$\");\n+        if (castrhs)\n+            buf.append(\"Parm\");\n+        else\n+            rhs.appendTo(buf);\n+        \n+        buf.append(\"]' PASSING \");\n+        appendXmlVar(buf, lhs);\n+        buf.append(\", \");\n+        \n+        if (castrhs)\n+            appendCast(buf, rhs, type);\n+        else\n+            rhs.appendTo(buf);\n+        \n+        buf.append(\" AS \\\"\");\n+        if (castrhs)\n+            buf.append(\"Parm\");\n+        else\n+            rhs.appendTo(buf);\n+        buf.append(\"\\\")\");\n+    }\n+    \n+    /**\n+     * Append an xml comparison predicate. (both operands map to xml column)\n+     *\n+     * @param buf the SQL buffer to write the comparison\n+     * @param op the comparison operation to perform\n+     * @param lhs the left hand side of the comparison (maps to xml column)\n+     * @param rhs the right hand side of the comparison (maps to xml column)\n+     */\n+    private void appendXmlComparison2(SQLBuffer buf, String op, \n+            FilterValue lhs, FilterValue rhs) {\n+        appendXmlExists(buf, lhs);\n+        \n+        buf.append(\" \").append(op).append(\" \");\n+        \n+        buf.append(\"$\").append(rhs.getColumnAlias(\n+            rhs.getFieldMapping().getColumns()[0])).\n+            append(\"/*/\");\n+        rhs.appendTo(buf);\n+        \n+        buf.append(\"]' PASSING \");\n+        appendXmlVar(buf, lhs);\n+        buf.append(\", \");\n+        appendXmlVar(buf, rhs);\n+        buf.append(\")\");\n+    }\n+    \n+    private void appendXmlVar(SQLBuffer buf, FilterValue val) {\n+        buf.append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\" AS \").\n+            append(\"\\\"\").append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\"\\\"\");        \n+    }\n+    \n+    private void appendXmlExists(SQLBuffer buf, FilterValue val) {\n+        buf.append(\"XMLEXISTS('\");\n+        buf.append(\"$\").append(val.getColumnAlias(\n+            val.getFieldMapping().getColumns()[0])).\n+            append(\"/*[\");\n+        val.appendTo(buf);        \n+    }\n+    \n+    /**\n+     * add CAST for a scalar function where operand is a param\n+     * \n+     * @param func original string\n+     * @param target substring to look for\n+     * @param asString \n+     * @return updated string (func)\n+     */\n+    private String addCastAsString(String func, String target, \n+            String asString) {\n+        String fstring = func;\n+        if (func.indexOf(target) != -1)\n+            fstring = Strings.replace(\n+                func, target, \"CAST(\" + target + asString + \")\");\n+        return fstring;\n+    }\n+\n+    /**\n+     * add CAST for a function operator where operand is a param\n+     * \n+     * @param func function name\n+     * @param val type\n+     * @return updated string (func)\n+     */\n+    public String addCastAsType(String func, Val val) {\n+        String fstring = null;\n+        String type = getTypeName(getJDBCType(JavaTypes.getTypeCode(val\n+            .getType()), false));\n+        if (String.class.equals(val.getType()))\n+            type = type + \"(\" + characterColumnSize + \")\";\n+        fstring = \"CAST(? AS \" + type + \")\";\n+        return fstring;\n+    }\n+\n+    /**\n+     * Return the batch limit. If the batchLimit is -1, change it to 100 for\n+     * best performance\n+     */\n+    public int getBatchLimit() {\n+        int limit = super.getBatchLimit();\n+        if (limit == UNLIMITED) {\n+            limit = defaultBatchLimit;\n+            if (log.isTraceEnabled())\n+                log.trace(_loc.get(\"batch_unlimit\", String.valueOf(limit)));\n+        }\n+        return limit;\n+    }\n+\n+    /**\n+     * Return the correct CAST function syntax\n+     * \n+     * @param val operand of cast\n+     * @param func original string\n+     * @return a String with the correct CAST function syntax\n+     */\n+    public String getCastFunction(Val val, String func) {\n+        if (val instanceof Lit || val instanceof Param) {\n+            if (func.indexOf(\"VARCHAR\") == -1) {\n+                func = addCastAsString(func, \"{0}\", \" AS VARCHAR(\" + varcharCastLength + \")\");\n+            }\n+        }\n+        return func;\n+    }\n+    \n+    /**\n+     * Return the correct CAST function syntax\n+     * \n+     * @param val operand of cast\n+     * @param func original string\n+     * @param col database column\n+     * @return a String with the correct CAST function syntax\n+     */\n+    public String getCastFunction(Val val, String func, Column col) {\n+        boolean doCast = false;\n+        if (val instanceof Lit || val instanceof Param) {\n+        \tdoCast = true;\n+        }\n+        // cast anything not already a VARCHAR to VARCHAR\n+        if (col.getType() != Types.VARCHAR) {\n+            doCast = true;\n+        }\n+        if (doCast == true) {\n+            if (func.indexOf(\"VARCHAR\") == -1) {\n+                func = addCastAsString(func, \"{0}\", \" AS VARCHAR(\" + varcharCastLength + \")\");\n+            }\n+        }\n+        return func;\n+    }\n+\n+    public void indexOf(SQLBuffer buf, FilterValue str, FilterValue find,\n+            FilterValue start) {\n+        if (find.getValue() != null) { // non constants\n+            buf.append(\"(LOCATE(CAST((\");\n+            find.appendTo(buf);\n+            buf.append(\") AS VARCHAR(1000)), \");\n+        } else {\n+            // this is a constant\n+            buf.append(\"(LOCATE(\");\n+            find.appendTo(buf);\n+            buf.append(\", \");\n+        }\n+        if (str.getValue() != null) {\n+            buf.append(\"CAST((\");\n+            str.appendTo(buf);\n+            buf.append(\") AS VARCHAR(1000))\");\n+        } else {\n+            str.appendTo(buf);\n+        }\n+        if (start != null) {\n+            if (start.getValue() == null) {\n+                buf.append(\", CAST((\");\n+                start.appendTo(buf);\n+                buf.append(\") AS INTEGER) + 1\");\n+            } else {\n+                buf.append(\", \");\n+                start.appendTo(buf);\n+            }\n+        }\n+        buf.append(\") - 1)\");\n+    }\n+    \n+    /** \n+     * Cast the specified value to the specified type.\n+     *\n+     * @param buf the buffer to append the cast to\n+     * @param val the value to cast\n+     * @param type the type of the case, e.g. {@link Types#NUMERIC}\n+     */\n+    public void appendCast(SQLBuffer buf, FilterValue val, int type) {\n+\n+        // Convert the cast function: \"CAST({0} AS {1})\"\n+        int firstParam = castFunction.indexOf(\"{0}\");\n+        String pre = castFunction.substring(0, firstParam); // \"CAST(\"\n+        String mid = castFunction.substring(firstParam + 3);\n+        int secondParam = mid.indexOf(\"{1}\");\n+        String post;\n+        if (secondParam > -1) {\n+            post = mid.substring(secondParam + 3); // \")\"\n+            mid = mid.substring(0, secondParam); // \" AS \"\n+        } else\n+            post = \"\";\n+\n+        // No need to add CAST if the value is a constant\n+        if (val instanceof Lit || val instanceof Param) {\n+            buf.append(pre);\n+            val.appendTo(buf);\n+            buf.append(mid);\n+            buf.append(getTypeName(type));\n+            appendLength(buf, type);\n+            buf.append(post);\n+        } else {\n+            val.appendTo(buf);\n+            String sqlString = buf.getSQL(false);\n+            if (sqlString.endsWith(\"?\")) {\n+                // case \"(?\" - convert to \"CAST(? AS type\"\n+                String typeName = getTypeName(type);\n+                if (String.class.equals(val.getType()))\n+                    typeName = typeName + \"(\" + characterColumnSize + \")\";\n+                String str = \"CAST(? AS \" + typeName + \")\";\n+                buf.replaceSqlString(sqlString.length() - 1,\n+                        sqlString.length(), str);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Create an index if necessary for some database tables\n+     */\n+    public void createIndexIfNecessary(Schema schema, String table,\n+            Column pkColumn) {\n+        if (isDB2ZOSV8xOrLater()) {\n+            // build the index for the sequence tables\n+            // the index name will the fully qualified table name + _IDX\n+            Table tab = schema.getTable(table);\n+            Index idx = tab.addIndex(tab.getFullName() + \"_IDX\");\n+            idx.setUnique(true);\n+            idx.addColumn(pkColumn);\n+        }\n+    }\n+    \n+    String nullSafe(String s) {\n+    \treturn s == null ? \"\" : s;\n+    }\n+}"},{"sha":"96cf76fbef1bba2997326af5eb63c7a94b904538","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","status":"modified","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionary.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -232,12 +232,14 @@\n     public boolean requiresTargetForDelete = false;\n     public boolean allowsAliasInBulkClause = true;\n     public boolean supportsMultipleNontransactionalResultSets = true;\n+    public boolean requiresSearchStringEscapeForLike = true;\n     public String searchStringEscape = \"\\\\\";\n     public boolean requiresCastForMathFunctions = false;\n     public boolean requiresCastForComparisons = false;\n     public boolean supportsModOperator = false;\n     public boolean supportsXMLColumn = false;\n     public boolean reportsSuccessNoInfoOnBatchUpdates = false;\n+    public boolean supportsCaseConversionForLob = false;\n     \n     /**\n      * Some Databases append whitespace after the schema name \n@@ -341,6 +343,18 @@\n     protected final Set systemTableSet = new HashSet();\n     protected final Set fixedSizeTypeNameSet = new HashSet();\n     protected final Set typeModifierSet = new HashSet();\n+    \n+    /**\n+     * Some JDBC drivers - ie DB2 type 2 on Z/OS throw exceptions on\n+     * setQueryTimeout when provided specific input values.\n+     * To remain consistent with earlier versions of the driver we should ignore\n+     * the exception.\n+     * \n+     * This variable will be removed in future releases when we can handle the\n+     * exception properly.\n+     */ \n+    @Deprecated\n+    public boolean ignoreSQLExceptionOnSetQueryTimeout = false; \n \n     /**\n      * If a native query begins with any of the values found here then it will\n@@ -4387,6 +4401,19 @@ protected long copy(Reader reader, Writer writer) throws IOException {\n     public String getCastFunction(Val val, String func) {\n         return func;\n     }\n+\n+    /**\n+     * Return the correct CAST function syntax.  This should be overriden by subclasses\n+     * that need access to the Column information.\n+     * \n+     * @param val operand of cast\n+     * @param func original string\n+     * @param col database column\n+     * @return a String with the correct CAST function syntax\n+     */\n+    public String getCastFunction(Val val, String func, Column col) {\n+    \treturn getCastFunction (val, func);\n+    }\n     \n     /**\n      * Create an index if necessary for some database tables"},{"sha":"aab3ed77b500b039a59743a223ea8ff0559f5db6","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionaryFactory.java","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionaryFactory.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionaryFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DBDictionaryFactory.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -122,6 +122,18 @@ private static DBDictionary newDBDictionary(JDBCConfiguration conf,\n                         DBDictionary.class)));\n             dict = (DBDictionary) AccessController.doPrivileged(\n                 J2DoPrivHelper.newInstanceAction(c));\n+        } catch (ClassNotFoundException cnfe) {\n+            // if the dictionary was not found, make another attempt\n+            // at loading the dictionary using the current thread.\n+            try {\n+                Class c = Thread.currentThread().getContextClassLoader().loadClass(dclass);\n+                dict = (DBDictionary) AccessController.doPrivileged(\n+                        J2DoPrivHelper.newInstanceAction(c));\n+            } catch (Exception e) {\n+                if (e instanceof PrivilegedActionException)\n+                    e = ((PrivilegedActionException) e).getException();\n+                throw new UserException(e).setFatal(true);\n+            }\n         } catch (Exception e) {\n             if (e instanceof PrivilegedActionException)\n                 e = ((PrivilegedActionException) e).getException();"},{"sha":"3dee559500785a6c4e61cc14f44fca366210254f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/DerbyDictionary.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -45,6 +45,8 @@ public DerbyDictionary() {\n         validationSQL = \"VALUES(1)\";\n         stringLengthFunction = \"LENGTH({0})\";\n         substringFunctionName = \"SUBSTR\";\n+        toUpperCaseFunction = \"UPPER(CAST({0} AS VARCHAR(\" + varcharCastLength + \")))\";\n+        toLowerCaseFunction = \"LOWER(CAST({0} AS VARCHAR(\" + varcharCastLength + \")))\";\n \n         maxConstraintNameLength = 18;\n         maxIndexNameLength = 128;"},{"sha":"14a011c65979e73ba771064ea6081c9586b8fe01","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/OracleDictionary.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -167,6 +167,7 @@ public OracleDictionary() {\n         super.setBatchLimit(defaultBatchLimit);\n         selectWordSet.add(\"WITH\");\n         reportsSuccessNoInfoOnBatchUpdates = true;\n+        requiresSearchStringEscapeForLike = false;\n     }\n \n     public void endConfiguration() {"},{"sha":"307194c2a4c15d745ab990880ea9a56bddbe8e48","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLBuffer.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -52,7 +52,7 @@\n     private static final String PARAMETER_TOKEN = \"?\";\n \n     private final DBDictionary _dict;\n-    private final StringBuffer _sql = new StringBuffer();\n+    private final StringBuilder _sql = new StringBuilder();\n     private List _subsels = null;\n     private List _params = null;\n     private List _cols = null;\n@@ -407,7 +407,7 @@ public String getSQL(boolean replaceParams) {\n         if (!replaceParams || _params == null || _params.isEmpty())\n             return sql;\n \n-        StringBuffer buf = new StringBuffer();\n+        StringBuilder buf = new StringBuilder();\n         Iterator pi = _params.iterator();\n         for (int i = 0; i < sql.length(); i++) {\n             if (sql.charAt(i) != '?') {"},{"sha":"dece0a3254493b20a68b722f1110e9eec408da7f","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","status":"modified","additions":155,"deletions":155,"changes":310,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLErrorCodeReader.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,155 +1,155 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.sql;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.util.ArrayList;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-import javax.xml.parsers.DocumentBuilder;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.xml.XMLFactory;\r\n-import org.apache.openjpa.util.StoreException;\r\n-import org.w3c.dom.Document;\r\n-import org.w3c.dom.Element;\r\n-import org.w3c.dom.NamedNodeMap;\r\n-import org.w3c.dom.Node;\r\n-import org.w3c.dom.NodeList;\r\n-\r\n-/**\r\n- * Parses XML content of SQL Error State codes to populate errro codes for\r\n- * a given Database Dictionary.\r\n- * \r\n- * @author Pinaki Poddar\r\n- * \r\n- */\r\n-public class SQLErrorCodeReader {\r\n-\tprivate Log log = null;\r\n-\tpublic static final String ERROR_CODE_DELIMITER = \",\";\r\n-\tpublic static final Map<String, Integer> storeErrorTypes = \r\n-\t\tnew HashMap<String, Integer>();\r\n-\tstatic {\r\n-\t\tstoreErrorTypes.put(\"lock\", StoreException.LOCK);\r\n-\t\tstoreErrorTypes.put(\"object-exists\", StoreException.OBJECT_EXISTS);\r\n-\t\tstoreErrorTypes\r\n-\t\t\t\t.put(\"object-not-found\", StoreException.OBJECT_NOT_FOUND);\r\n-\t\tstoreErrorTypes.put(\"optimistic\", StoreException.OPTIMISTIC);\r\n-\t\tstoreErrorTypes.put(\"referential-integrity\",\r\n-\t\t\t\tStoreException.REFERENTIAL_INTEGRITY);\r\n-\r\n-\t}\r\n-\t\r\n-\tprivate static final Localizer _loc = \r\n-\t\tLocalizer.forPackage(SQLErrorCodeReader.class);\r\n-\t\r\n-\tpublic List<String> getDictionaries(InputStream in) {\r\n-\t\tList<String> result = new ArrayList<String>();\r\n-\t\tDocumentBuilder builder = XMLFactory.getDOMParser(false, false);\r\n-\t\ttry {\r\n-\t\t\tDocument doc = builder.parse(in);\r\n-\t\t\tElement root = doc.getDocumentElement();\r\n-\t\t\tNodeList nodes = root.getElementsByTagName(\"dictionary\");\r\n-\t\t\tfor (int i = 0; i < nodes.getLength(); i++) {\r\n-\t\t\t\tNode node = nodes.item(i);\r\n-\t\t\t\tNamedNodeMap attrs = node.getAttributes();\r\n-\t\t\t\tNode dictionary = attrs.getNamedItem(\"class\");\r\n-\t\t\t\tif (dictionary != null) {\r\n-\t\t\t\t   result.add(dictionary.getNodeValue());\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\tif (log.isWarnEnabled()) {\r\n-\t\t\t\tlog.error(_loc.get(\"error-code-parse-error\"));\r\n-\t\t\t}\r\n-\t\t} finally {\r\n-\t\t\ttry {\r\n-\t\t\t\tin.close();\r\n-\t\t\t} catch (IOException e) {\r\n-\t\t\t\t// ignore\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\treturn result;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Parses given stream of XML content for error codes of the given database\r\n-\t * dictionary name. Populates the given dictionary with the error codes.\r\n-\t * \r\n-\t */\r\n-\tpublic void parse(InputStream in, String dictName, DBDictionary dict) {\r\n-\t\tif (in == null || dict == null)\r\n-\t\t\treturn;\r\n-\t\tlog = dict.conf.getLog(JDBCConfiguration.LOG_JDBC);\r\n-\t\tDocumentBuilder builder = XMLFactory.getDOMParser(false, false);\r\n-\t\ttry {\r\n-\t\t\tDocument doc = builder.parse(in);\r\n-\t\t\tElement root = doc.getDocumentElement();\r\n-\t\t\tNodeList nodes = root.getElementsByTagName(\"dictionary\");\r\n-\t\t\tfor (int i = 0; i < nodes.getLength(); i++) {\r\n-\t\t\t\tNode node = nodes.item(i);\r\n-\t\t\t\tNamedNodeMap attrs = node.getAttributes();\r\n-\t\t\t\tNode dictionary = attrs.getNamedItem(\"class\");\r\n-\t\t\t\tif (dictionary != null \r\n-\t\t\t\t && dictionary.getNodeValue().equals(dictName)) {\r\n-\t\t\t\t\treadErrorCodes(node, dict);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t} catch (Throwable e) {\r\n-\t\t\tif (log.isWarnEnabled()) {\r\n-\t\t\t\tlog.error(_loc.get(\"error-code-parse-error\"));\r\n-\t\t\t}\r\n-\t\t} finally {\r\n-\t\t\ttry {\r\n-\t\t\t\tin.close();\r\n-\t\t\t} catch (IOException e) {\r\n-\t\t\t\t// ignore\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tstatic void readErrorCodes(Node node, DBDictionary dict) {\r\n-\t\tNodeList children = node.getChildNodes();\r\n-\t\tfor (int i = 0; i < children.getLength(); i++) {\r\n-\t\t\tNode child = children.item(i);\r\n-\t\t\tshort nodeType = child.getNodeType();\r\n-\t\t\tif (nodeType == Node.ELEMENT_NODE) {\r\n-\t\t\t\tString errorType = child.getNodeName();\r\n-\t\t\t\tNode textNode = child.getFirstChild();\r\n-\t\t\t\tif (storeErrorTypes.containsKey(errorType) && textNode != null){\r\n-\t\t\t\t\tString errorCodes = textNode.getNodeValue();\r\n-\t\t\t\t\tif (!StringUtils.isEmpty(errorCodes)) {\r\n-\t\t\t\t\t\tString[] codes = errorCodes.split(ERROR_CODE_DELIMITER);\r\n-\t\t\t\t\t\tfor (String code : codes) {\r\n-\t\t\t\t\t\t\tdict.addErrorCode(storeErrorTypes.get(errorType),\r\n-\t\t\t\t\t\t\t\t\tcode.trim());\r\n-\t\t\t\t\t\t}\r\n-\t\t\t\t\t}\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.sql;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.xml.XMLFactory;\n+import org.apache.openjpa.util.StoreException;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.NamedNodeMap;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * Parses XML content of SQL Error State codes to populate errro codes for\n+ * a given Database Dictionary.\n+ * \n+ * @author Pinaki Poddar\n+ * \n+ */\n+public class SQLErrorCodeReader {\n+\tprivate Log log = null;\n+\tpublic static final String ERROR_CODE_DELIMITER = \",\";\n+\tpublic static final Map<String, Integer> storeErrorTypes = \n+\t\tnew HashMap<String, Integer>();\n+\tstatic {\n+\t\tstoreErrorTypes.put(\"lock\", StoreException.LOCK);\n+\t\tstoreErrorTypes.put(\"object-exists\", StoreException.OBJECT_EXISTS);\n+\t\tstoreErrorTypes\n+\t\t\t\t.put(\"object-not-found\", StoreException.OBJECT_NOT_FOUND);\n+\t\tstoreErrorTypes.put(\"optimistic\", StoreException.OPTIMISTIC);\n+\t\tstoreErrorTypes.put(\"referential-integrity\",\n+\t\t\t\tStoreException.REFERENTIAL_INTEGRITY);\n+\n+\t}\n+\t\n+\tprivate static final Localizer _loc = \n+\t\tLocalizer.forPackage(SQLErrorCodeReader.class);\n+\t\n+\tpublic List<String> getDictionaries(InputStream in) {\n+\t\tList<String> result = new ArrayList<String>();\n+\t\tDocumentBuilder builder = XMLFactory.getDOMParser(false, false);\n+\t\ttry {\n+\t\t\tDocument doc = builder.parse(in);\n+\t\t\tElement root = doc.getDocumentElement();\n+\t\t\tNodeList nodes = root.getElementsByTagName(\"dictionary\");\n+\t\t\tfor (int i = 0; i < nodes.getLength(); i++) {\n+\t\t\t\tNode node = nodes.item(i);\n+\t\t\t\tNamedNodeMap attrs = node.getAttributes();\n+\t\t\t\tNode dictionary = attrs.getNamedItem(\"class\");\n+\t\t\t\tif (dictionary != null) {\n+\t\t\t\t   result.add(dictionary.getNodeValue());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable e) {\n+\t\t\tif (log.isWarnEnabled()) {\n+\t\t\t\tlog.error(_loc.get(\"error-code-parse-error\"));\n+\t\t\t}\n+\t\t} finally {\n+\t\t\ttry {\n+\t\t\t\tin.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\t/**\n+\t * Parses given stream of XML content for error codes of the given database\n+\t * dictionary name. Populates the given dictionary with the error codes.\n+\t * \n+\t */\n+\tpublic void parse(InputStream in, String dictName, DBDictionary dict) {\n+\t\tif (in == null || dict == null)\n+\t\t\treturn;\n+\t\tlog = dict.conf.getLog(JDBCConfiguration.LOG_JDBC);\n+\t\tDocumentBuilder builder = XMLFactory.getDOMParser(false, false);\n+\t\ttry {\n+\t\t\tDocument doc = builder.parse(in);\n+\t\t\tElement root = doc.getDocumentElement();\n+\t\t\tNodeList nodes = root.getElementsByTagName(\"dictionary\");\n+\t\t\tfor (int i = 0; i < nodes.getLength(); i++) {\n+\t\t\t\tNode node = nodes.item(i);\n+\t\t\t\tNamedNodeMap attrs = node.getAttributes();\n+\t\t\t\tNode dictionary = attrs.getNamedItem(\"class\");\n+\t\t\t\tif (dictionary != null \n+\t\t\t\t && dictionary.getNodeValue().equals(dictName)) {\n+\t\t\t\t\treadErrorCodes(node, dict);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable e) {\n+\t\t\tif (log.isWarnEnabled()) {\n+\t\t\t\tlog.error(_loc.get(\"error-code-parse-error\"));\n+\t\t\t}\n+\t\t} finally {\n+\t\t\ttry {\n+\t\t\t\tin.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tstatic void readErrorCodes(Node node, DBDictionary dict) {\n+\t\tNodeList children = node.getChildNodes();\n+\t\tfor (int i = 0; i < children.getLength(); i++) {\n+\t\t\tNode child = children.item(i);\n+\t\t\tshort nodeType = child.getNodeType();\n+\t\t\tif (nodeType == Node.ELEMENT_NODE) {\n+\t\t\t\tString errorType = child.getNodeName();\n+\t\t\t\tNode textNode = child.getFirstChild();\n+\t\t\t\tif (storeErrorTypes.containsKey(errorType) && textNode != null){\n+\t\t\t\t\tString errorCodes = textNode.getNodeValue();\n+\t\t\t\t\tif (!StringUtils.isEmpty(errorCodes)) {\n+\t\t\t\t\t\tString[] codes = errorCodes.split(ERROR_CODE_DELIMITER);\n+\t\t\t\t\t\tfor (String code : codes) {\n+\t\t\t\t\t\t\tdict.addErrorCode(storeErrorTypes.get(errorType),\n+\t\t\t\t\t\t\t\t\tcode.trim());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}"},{"sha":"7f9a4bd4ec80d4b4c7340139c243d5540900acac","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","status":"modified","additions":55,"deletions":31,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SQLServerDictionary.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -64,49 +64,73 @@ public SQLServerDictionary() {\n     public void connectedConfiguration(Connection conn)\n         throws SQLException {\n         super.connectedConfiguration(conn);\n-\n+        boolean requiresWarnings = true;\n         DatabaseMetaData meta = conn.getMetaData();\n         String driverName = meta.getDriverName();\n         String url = meta.getURL();\n         if (driverVendor == null) {\n-            if (\"NetDirect JSQLConnect\".equals(driverName))\n-                driverVendor = VENDOR_NETDIRECT;\n-            else if (driverName != null && driverName.startsWith(\"jTDS\"))\n-                driverVendor = VENDOR_JTDS;\n-            else if (\"SQLServer\".equals(driverName)) {\n-                if (url != null && url.startsWith(\"jdbc:microsoft:sqlserver:\"))\n-                    driverVendor = VENDOR_MICROSOFT;\n-                else if (url != null\n-                    && url.startsWith(\"jdbc:datadirect:sqlserver:\"))\n-                    driverVendor = VENDOR_DATADIRECT;\n-                else\n-                    driverVendor = VENDOR_OTHER;\n-            } else\n+            if (driverName != null) {\n+                if (driverName.startsWith(\"Microsoft SQL Server\")) {\n+                    // v1.1, 1.2 or 2.0 driver\n+                    driverVendor = VENDOR_MICROSOFT;                \n+                    // serverMajorVersion of 8==2000, 9==2005, 10==2008\n+                    if (meta.getDatabaseMajorVersion() >= 9)\n+                        supportsXMLColumn = true;\n+                    if (meta.getDriverMajorVersion() >= 2) {\n+                        // see http://blogs.msdn.com/jdbcteam/archive/2007/05/\\\n+                        // 02/what-is-adaptive-response-buffering-and-why-\\\n+                        // should-i-use-it.aspx\n+                        // 2.0 driver connectURL automatically includes \n+                        // responseBuffering=adaptive\n+                        // and disableStatementPooling=true\n+                        requiresWarnings = false;\n+                    }\n+                } else {\n+                    if (\"NetDirect JSQLConnect\".equals(driverName))\n+                        driverVendor = VENDOR_NETDIRECT;\n+                    else if (driverName.startsWith(\"jTDS\"))\n+                        driverVendor = VENDOR_JTDS;\n+                    else if (\"SQLServer\".equals(driverName)) {\n+                        if (url != null &&\n+                            url.startsWith(\"jdbc:microsoft:sqlserver:\"))\n+                            driverVendor = VENDOR_MICROSOFT;\n+                        else if (url != null\n+                            && url.startsWith(\"jdbc:datadirect:sqlserver:\"))\n+                            driverVendor = VENDOR_DATADIRECT;\n+                        else\n+                            driverVendor = VENDOR_OTHER;\n+                    }\n+                    // old way of determining xml support\n+                    if (driverName.indexOf(platform) != -1) {\n+                        String versionString = driverName.\n+                            substring(platform.length() + 1);\n+                        if (versionString.indexOf(\" \") != -1)\n+                            versionString = versionString.substring(0,\n+                                versionString.indexOf(\" \"));\n+                        int version = Integer.parseInt(versionString);\n+                        if (version >= 2005)\n+                            supportsXMLColumn = true;\n+                    }\n+                }\n+            } else {\n                 driverVendor = VENDOR_OTHER;\n-            if (driverName.indexOf(platform) != -1) {\n-                String versionString = driverName.\n-                    substring(platform.length() + 1);\n-                if (versionString.indexOf(\" \") != -1)\n-                    versionString = versionString.substring(0,\n-                        versionString.indexOf(\" \"));\n-                int version = Integer.parseInt(versionString);\n-                if (version >= 2005)\n-                    supportsXMLColumn = true;\n             }\n         }\n \n-        // warn about using cursors\n-        if ((VENDOR_MICROSOFT.equalsIgnoreCase(driverVendor)\n+        // warn about not using cursors for pre-2.0 MS driver\n+        // as connectURL includes selectMethod=direct\n+        if (((VENDOR_MICROSOFT.equalsIgnoreCase(driverVendor)\n+            && requiresWarnings) \n             || VENDOR_DATADIRECT.equalsIgnoreCase(driverVendor))\n-            && url.toLowerCase().indexOf(\"selectmethod=cursor\") == -1)\n+            && (url.toLowerCase().indexOf(\"selectmethod=cursor\") == -1))\n             log.warn(_loc.get(\"sqlserver-cursor\", url));\n \n-        // warn about prepared statement caching if using ms driver\n+        // warn about prepared statement caching if using pre-2.0 MS drivers\n+        // as connectURL includes responseBuffering=full\n         String props = conf.getConnectionFactoryProperties();\n-        if (props == null)\n-            props = \"\";\n-        if (VENDOR_MICROSOFT.equalsIgnoreCase(driverVendor)\n-            && props.toLowerCase().indexOf(\"maxcachedstatements=0\") == -1)\n+        if ((props != null) && \n+            VENDOR_MICROSOFT.equalsIgnoreCase(driverVendor) && requiresWarnings\n+            && (props.toLowerCase().indexOf(\"maxcachedstatements=0\") == -1))\n             log.warn(_loc.get(\"sqlserver-cachedstmnts\"));\n     }\n "},{"sha":"3c492d3a6e4dc449b86cd99f7fd6bad30a777569","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","status":"modified","additions":15,"deletions":2,"changes":17,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SelectImpl.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -476,13 +476,26 @@ protected void setTimeout(PreparedStatement stmnt, boolean forUpdate,\n         if (forUpdate && _dict.supportsQueryTimeout && fetch != null \n             && fetch.getLockTimeout() > stmnt.getQueryTimeout() * 1000) {\n             int timeout = fetch.getLockTimeout();\n+            Log log = _conf.getLog(JDBCConfiguration.LOG_JDBC);\n             if (timeout < 1000) {\n                 timeout = 1000; \n-                Log log = _conf.getLog(JDBCConfiguration.LOG_JDBC);\n                 if (log.isWarnEnabled())\n                     log.warn(_loc.get(\"millis-query-timeout\"));\n             }\n-            stmnt.setQueryTimeout(timeout / 1000);\n+            try { \n+                stmnt.setQueryTimeout(fetch.getLockTimeout() / 1000);\n+            }\n+            catch(SQLException e) { \n+                if(_dict.ignoreSQLExceptionOnSetQueryTimeout) { \n+                    if (log.isTraceEnabled()) {\n+                        log.trace(_loc.get(\"error-setting-query-timeout\",\n+                            new Integer(timeout), e.getMessage()), e);\n+                    }   \n+                }\n+                else { \n+                    throw e;\n+                }\n+            }\n         }\n     }\n "},{"sha":"7c59d7fcdfcc7ed61b54c41ed5933a3bc23634af","filename":"openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java","status":"modified","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/sql/SybaseDictionary.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -22,13 +22,15 @@\n import java.math.BigInteger;\n import java.sql.Connection;\n import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n import java.sql.SQLException;\n import java.sql.Types;\n import java.util.Arrays;\n \n import org.apache.commons.lang.StringUtils;\n import org.apache.openjpa.jdbc.schema.Column;\n import org.apache.openjpa.jdbc.schema.ForeignKey;\n+import org.apache.openjpa.jdbc.schema.Index;\n import org.apache.openjpa.jdbc.schema.PrimaryKey;\n import org.apache.openjpa.jdbc.schema.Table;\n import org.apache.openjpa.jdbc.schema.Unique;\n@@ -280,6 +282,33 @@ public Connection decorate(Connection conn)\n         return new SybaseConnection(conn);\n     }\n \n+    /**\n+     * Create a new primary key from the information in the schema metadata.\n+     */\n+    protected PrimaryKey newPrimaryKey(ResultSet pkMeta)\n+        throws SQLException {\n+        PrimaryKey pk = new PrimaryKey();\n+        pk.setSchemaName(pkMeta.getString(\"table_owner\"));\n+        pk.setTableName(pkMeta.getString(\"table_name\"));\n+        pk.setColumnName(pkMeta.getString(\"column_name\"));\n+        pk.setName(pkMeta.getString(\"index_name\"));\n+        return pk;\n+    }\n+\n+    /**\n+     * Create a new index from the information in the index metadata.\n+     */\n+    protected Index newIndex(ResultSet idxMeta)\n+        throws SQLException {\n+        Index idx = new Index();\n+        idx.setSchemaName(idxMeta.getString(\"table_owner\"));\n+        idx.setTableName(idxMeta.getString(\"table_name\"));\n+        idx.setColumnName(idxMeta.getString(\"column_name\"));\n+        idx.setName(idxMeta.getString(\"index_name\"));\n+        idx.setUnique(!idxMeta.getBoolean(\"non_unique\"));\n+        return idx;\n+    }\n+\n     /**\n      * Connection wrapper to cache the {@link Connection#getCatalog} result,\n      * which takes a very long time with the Sybase Connection (and"},{"sha":"337655fb74e8f57f2298651aeb760a4eedeccca6","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","status":"modified","additions":6,"deletions":1,"changes":7,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/kernel/localizer.properties?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -114,4 +114,9 @@ batch_limit: The batch limit is set to {0}.\n batch_update_info: ExecuteBatch command returns update count {0} for \\\n \tstatement {1}.\n cache-hit: SQL Cache hit with key: {0} in {1}\n-cache-missed: SQL Cache missed with key: {0} in {1}    \n+cache-missed: SQL Cache missed with key: {0} in {1}  \n+error-setting-query-timeout: A SQLException was thrown when trying to set the \\\n+\tqueryTimeout to {0}. We believe the exception is not fatal and will \\\n+    continue processing. If this is a benign error you may disable it entirely \\\n+\tby setting the supportsQueryTimeout attribute on the DBDictionary to false.\\\n+\tThe exception thrown was {1}."},{"sha":"efd7747bde8dc747e696e0df32f94811eab8608e","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","status":"modified","additions":7,"deletions":1,"changes":8,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/localizer.properties?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -176,4 +176,10 @@ batch-update-success-count: ExecuteBatch command returns update success count {0\n connection-defaults: Initial connection autoCommit: {0}, holdability: {1}, \\\n     TransactionIsolation: {2}\n null-blob-in-not-nullable: Can not set null value on column \"{0}\" \\\n-\tbecause the corresponding field is set to be non-nullable.\n\\ No newline at end of file\n+\tbecause the corresponding field is set to be non-nullable.\n+error-setting-query-timeout: A SQLException was thrown when trying to set the \\\n+\tqueryTimeout to {0}. We believe the exception is not fatal and will \\\n+    continue processing. If this is a benign error you may disable it entirely \\\n+\tby setting the supportsQueryTimeout attribute on the DBDictionary to false.\\\n+\tThe exception thrown was {1}.\n+\t\n\\ No newline at end of file"},{"sha":"cb3f2c8830b213e11f6d9d7c666780af5381be79","filename":"openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-error-state-codes.xml","status":"modified","additions":145,"deletions":145,"changes":290,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-error-state-codes.xml","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-error-state-codes.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/main/resources/org/apache/openjpa/jdbc/sql/sql-error-state-codes.xml?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,146 +1,146 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n-<!--\r\n- Licensed to the Apache Software Foundation (ASF) under one\r\n- or more contributor license agreements.  See the NOTICE file\r\n- distributed with this work for additional information\r\n- regarding copyright ownership.  The ASF licenses this file\r\n- to you under the Apache License, Version 2.0 (the\r\n- \"License\"); you may not use this file except in compliance\r\n- with the License.  You may obtain a copy of the License at\r\n- \r\n- http://www.apache.org/licenses/LICENSE-2.0\r\n- \r\n- Unless required by applicable law or agreed to in writing,\r\n- software distributed under the License is distributed on an\r\n- \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- KIND, either express or implied.  See the License for the\r\n- specific language governing permissions and limitations\r\n- under the License.   \r\n--->\r\n-<!-- ======================================================================= -->\r\n-<!-- Lists SQL Error State codes for specific type of faults per database    -->\r\n-<!-- dictionary.                                                             -->\r\n-<!-- SQL Exceptions raised by JDBC should carry standard error state code    -->\r\n-<!-- but they hardly do. Hence, the error state codes for specific type of   -->\r\n-<!-- database error can be listed here. These codes help to narrow down the  -->\r\n-<!-- cause of failure at JDBC layer and bubbles up as more intelligible      -->\r\n-<!-- exception to the application.                                           -->\r\n-<!-- ======================================================================= -->\r\n-<sql-state-codes>\r\n-\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.DB2Dictionary\">\r\n-\t\t<lock>-911,-913</lock>\r\n-\t\t<referential-integrity>-407,-530,-531,-532,-543,-544,-545,-603,-667,-803</referential-integrity>\r\n-\t\t<object-exists></object-exists>\r\n-\t\t<object-not-found></object-not-found>\r\n-\t\t<optimistic></optimistic>\r\n-\t</dictionary>\r\n-\t\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.DerbyDictionary\">\r\n-\t\t<lock>40001</lock>\r\n-\t\t<referential-integrity>22001,22005,23502,23503,23513,X0Y32</referential-integrity>\r\n-\t\t<object-exists>23505</object-exists>\r\n-\t\t<object-not-found></object-not-found>\r\n-\t\t<optimistic>40XL1,40001</optimistic>\r\n-\t</dictionary>\r\n-\t\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.SQLServerDictionary\">\r\n-\t\t<lock>1205</lock>\r\n-\t\t<referential-integrity>544,2601,2627,8114,8115</referential-integrity>\r\n-\t\t<optimistic>1205</optimistic>\r\n-\t</dictionary>\r\n-\t\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.SybaseDictionary\">\r\n-\t\t<lock>1205</lock>\r\n-\t\t<referential-integrity>423,511,515,530,547,2601,2615,2714</referential-integrity>\r\n-\t\t<object-exists></object-exists>\r\n-\t\t<object-not-found></object-not-found>\r\n-\t\t<optimistic>1205</optimistic>\r\n-\t</dictionary>\r\n-\t\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.AccessDictionary\">\r\n-\t\t<lock>40001</lock>\r\n-\t\t<referential-integrity>22001,22005,23502,23503,23513,X0Y32</referential-integrity>\r\n-\t\t<object-exists>23505,456c</object-exists>\r\n-\t\t<object-not-found></object-not-found>\r\n-\t\t<optimistic>40XL1,40001</optimistic>\r\n-\t</dictionary>\r\n-\t\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.CacheDictionary\">\r\n-\t\t<lock>40001</lock>\r\n-\t\t<referential-integrity>22001,22005,23502,23503,23513,X0Y32</referential-integrity>\r\n-\t\t<object-exists>23505,456c</object-exists>\r\n-\t\t<object-not-found></object-not-found>\r\n-\t\t<optimistic>40XL1,40001</optimistic>\r\n-\t</dictionary>\r\n-\t\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.EmpressDictionary\">\r\n-\t\t<lock>40001</lock>\r\n-\t\t<referential-integrity>22001,22005,23502,23503,23513,X0Y32</referential-integrity>\r\n-\t\t<object-exists>23505,456c</object-exists>\r\n-\t\t<object-not-found></object-not-found>\r\n-\t\t<optimistic>40XL1,40001</optimistic>\r\n-\t</dictionary>\r\n-\t\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.FoxProDictionary\">\r\n-\t\t<lock>40001</lock>\r\n-\t\t<referential-integrity>22001,22005,23502,23503,23513,X0Y32</referential-integrity>\r\n-\t\t<object-exists>23505,456c</object-exists>\r\n-\t\t<object-not-found></object-not-found>\r\n-\t\t<optimistic>40XL1,40001</optimistic>\r\n-\t</dictionary>\r\n-\t\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.H2Dictionary\">\r\n-\t\t<referential-integrity>22003,22012,22025,23000,23001</referential-integrity>\r\n-\t</dictionary>\r\n-\t\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.HSQLDictionary\">\r\n-\t\t<referential-integrity>-9</referential-integrity>\r\n-\t</dictionary>\r\n-\t\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.InformixDictionary\">\r\n-\t\t<referential-integrity>-239,-268,-692,-11030</referential-integrity>\r\n-\t</dictionary>\r\n-\t\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.InterbaseDictionary\">\r\n-\t</dictionary>\r\n-\t\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.FirebirdDictionary\">\r\n-\t</dictionary>\r\n-\t\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.JDataStoreDictionary\">\r\n-\t</dictionary>\r\n-\t\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.MySQLDictionary\">\r\n-\t\t<lock>1213</lock>\r\n-\t\t<referential-integrity>630,839,840,893,1062,1169,1215,1216,1217,1451,1452,1557</referential-integrity>\r\n-\t\t<object-exists>23000</object-exists>\r\n-\t\t<object-not-found></object-not-found>\r\n-\t\t<optimistic>41000,1205,1213</optimistic>\r\n-\t</dictionary>\r\n-\t\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.OracleDictionary\">\r\n-\t\t<lock></lock>\r\n-\t\t<referential-integrity>1,1400,1722,2291,2292</referential-integrity>\r\n-\t\t<object-exists></object-exists>\r\n-\t\t<object-not-found></object-not-found>\r\n-\t\t<optimistic></optimistic>\r\n-\t</dictionary>\r\n-\t\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.PointbaseDictionary\">\r\n-\t\t<lock></lock>\r\n-\t\t<referential-integrity>22001,22005,23502,23503,23513,X0Y32</referential-integrity>\r\n-\t\t<object-exists></object-exists>\r\n-\t\t<object-not-found></object-not-found>\r\n-\t\t<optimistic></optimistic>\r\n-\t</dictionary>\r\n-\t\r\n-\t<dictionary class=\"org.apache.openjpa.jdbc.sql.PostgresDictionary\">\r\n-\t\t<lock>55P03,40P01</lock>\r\n-\t\t<referential-integrity>23000,23502,23503,23505,23514</referential-integrity>\r\n-\t\t<object-exists></object-exists>\r\n-\t\t<object-not-found></object-not-found>\r\n-\t\t<optimistic>55P03</optimistic>\r\n-\t</dictionary>\r\n-\t\r\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+ Licensed to the Apache Software Foundation (ASF) under one\n+ or more contributor license agreements.  See the NOTICE file\n+ distributed with this work for additional information\n+ regarding copyright ownership.  The ASF licenses this file\n+ to you under the Apache License, Version 2.0 (the\n+ \"License\"); you may not use this file except in compliance\n+ with the License.  You may obtain a copy of the License at\n+ \n+ http://www.apache.org/licenses/LICENSE-2.0\n+ \n+ Unless required by applicable law or agreed to in writing,\n+ software distributed under the License is distributed on an\n+ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ KIND, either express or implied.  See the License for the\n+ specific language governing permissions and limitations\n+ under the License.   \n+-->\n+<!-- ======================================================================= -->\n+<!-- Lists SQL Error State codes for specific type of faults per database    -->\n+<!-- dictionary.                                                             -->\n+<!-- SQL Exceptions raised by JDBC should carry standard error state code    -->\n+<!-- but they hardly do. Hence, the error state codes for specific type of   -->\n+<!-- database error can be listed here. These codes help to narrow down the  -->\n+<!-- cause of failure at JDBC layer and bubbles up as more intelligible      -->\n+<!-- exception to the application.                                           -->\n+<!-- ======================================================================= -->\n+<sql-state-codes>\n+\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.DB2Dictionary\">\n+\t\t<lock>-911,-913</lock>\n+\t\t<referential-integrity>-407,-530,-531,-532,-543,-544,-545,-603,-667,-803</referential-integrity>\n+\t\t<object-exists></object-exists>\n+\t\t<object-not-found></object-not-found>\n+\t\t<optimistic></optimistic>\n+\t</dictionary>\n+\t\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.DerbyDictionary\">\n+\t\t<lock>40001</lock>\n+\t\t<referential-integrity>22001,22005,23502,23503,23513,X0Y32</referential-integrity>\n+\t\t<object-exists>23505</object-exists>\n+\t\t<object-not-found></object-not-found>\n+\t\t<optimistic>40XL1,40001</optimistic>\n+\t</dictionary>\n+\t\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.SQLServerDictionary\">\n+\t\t<lock>1205</lock>\n+\t\t<referential-integrity>544,2601,2627,8114,8115</referential-integrity>\n+\t\t<optimistic>1205</optimistic>\n+\t</dictionary>\n+\t\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.SybaseDictionary\">\n+\t\t<lock>1205</lock>\n+\t\t<referential-integrity>423,511,515,530,547,2601,2615,2714</referential-integrity>\n+\t\t<object-exists></object-exists>\n+\t\t<object-not-found></object-not-found>\n+\t\t<optimistic>1205</optimistic>\n+\t</dictionary>\n+\t\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.AccessDictionary\">\n+\t\t<lock>40001</lock>\n+\t\t<referential-integrity>22001,22005,23502,23503,23513,X0Y32</referential-integrity>\n+\t\t<object-exists>23505,456c</object-exists>\n+\t\t<object-not-found></object-not-found>\n+\t\t<optimistic>40XL1,40001</optimistic>\n+\t</dictionary>\n+\t\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.CacheDictionary\">\n+\t\t<lock>40001</lock>\n+\t\t<referential-integrity>22001,22005,23502,23503,23513,X0Y32</referential-integrity>\n+\t\t<object-exists>23505,456c</object-exists>\n+\t\t<object-not-found></object-not-found>\n+\t\t<optimistic>40XL1,40001</optimistic>\n+\t</dictionary>\n+\t\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.EmpressDictionary\">\n+\t\t<lock>40001</lock>\n+\t\t<referential-integrity>22001,22005,23502,23503,23513,X0Y32</referential-integrity>\n+\t\t<object-exists>23505,456c</object-exists>\n+\t\t<object-not-found></object-not-found>\n+\t\t<optimistic>40XL1,40001</optimistic>\n+\t</dictionary>\n+\t\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.FoxProDictionary\">\n+\t\t<lock>40001</lock>\n+\t\t<referential-integrity>22001,22005,23502,23503,23513,X0Y32</referential-integrity>\n+\t\t<object-exists>23505,456c</object-exists>\n+\t\t<object-not-found></object-not-found>\n+\t\t<optimistic>40XL1,40001</optimistic>\n+\t</dictionary>\n+\t\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.H2Dictionary\">\n+\t\t<referential-integrity>22003,22012,22025,23000,23001</referential-integrity>\n+\t</dictionary>\n+\t\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.HSQLDictionary\">\n+\t\t<referential-integrity>-9</referential-integrity>\n+\t</dictionary>\n+\t\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.InformixDictionary\">\n+\t\t<referential-integrity>-239,-268,-692,-11030</referential-integrity>\n+\t</dictionary>\n+\t\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.InterbaseDictionary\">\n+\t</dictionary>\n+\t\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.FirebirdDictionary\">\n+\t</dictionary>\n+\t\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.JDataStoreDictionary\">\n+\t</dictionary>\n+\t\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.MySQLDictionary\">\n+\t\t<lock>1213</lock>\n+\t\t<referential-integrity>630,839,840,893,1062,1169,1215,1216,1217,1451,1452,1557</referential-integrity>\n+\t\t<object-exists>23000</object-exists>\n+\t\t<object-not-found></object-not-found>\n+\t\t<optimistic>41000,1205,1213</optimistic>\n+\t</dictionary>\n+\t\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.OracleDictionary\">\n+\t\t<lock></lock>\n+\t\t<referential-integrity>1,1400,1722,2291,2292</referential-integrity>\n+\t\t<object-exists></object-exists>\n+\t\t<object-not-found></object-not-found>\n+\t\t<optimistic></optimistic>\n+\t</dictionary>\n+\t\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.PointbaseDictionary\">\n+\t\t<lock></lock>\n+\t\t<referential-integrity>22001,22005,23502,23503,23513,X0Y32</referential-integrity>\n+\t\t<object-exists></object-exists>\n+\t\t<object-not-found></object-not-found>\n+\t\t<optimistic></optimistic>\n+\t</dictionary>\n+\t\n+\t<dictionary class=\"org.apache.openjpa.jdbc.sql.PostgresDictionary\">\n+\t\t<lock>55P03,40P01</lock>\n+\t\t<referential-integrity>23000,23502,23503,23505,23514</referential-integrity>\n+\t\t<object-exists></object-exists>\n+\t\t<object-not-found></object-not-found>\n+\t\t<optimistic>55P03</optimistic>\n+\t</dictionary>\n+\t\n </sql-state-codes>\n\\ No newline at end of file"},{"sha":"c6f72508032ef3c8519795656ef15a9a6a180414","filename":"openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java","status":"modified","additions":882,"deletions":882,"changes":1764,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestUpdateManagerFlushException.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,882 +1,882 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.jdbc.kernel;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.ObjectOutput;\r\n-import java.sql.CallableStatement;\r\n-import java.sql.Connection;\r\n-import java.sql.DatabaseMetaData;\r\n-import java.sql.PreparedStatement;\r\n-import java.sql.SQLException;\r\n-import java.sql.SQLWarning;\r\n-import java.sql.Savepoint;\r\n-import java.sql.Statement;\r\n-import java.util.ArrayList;\r\n-import java.util.BitSet;\r\n-import java.util.Collection;\r\n-import java.util.Iterator;\r\n-import java.util.Map;\r\n-\r\n-import junit.framework.TestCase;\r\n-\r\n-import org.apache.openjpa.enhance.PersistenceCapable;\r\n-import org.apache.openjpa.enhance.StateManager;\r\n-import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\r\n-import org.apache.openjpa.jdbc.meta.ClassMapping;\r\n-import org.apache.openjpa.jdbc.meta.Strategy;\r\n-import org.apache.openjpa.jdbc.meta.ValueMapping;\r\n-import org.apache.openjpa.jdbc.sql.DBDictionary;\r\n-import org.apache.openjpa.jdbc.sql.RowManager;\r\n-import org.apache.openjpa.jdbc.sql.SQLFactory;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.PCState;\r\n-import org.apache.openjpa.kernel.StoreContext;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.util.Id;\r\n-\r\n-/**\r\n- * <p>\r\n- * Tests AbstractUpdateManager flush's method exception return behavior.\r\n- * </p>\r\n- * \r\n- * @author Albert Lee\r\n- */\r\n-public class TestUpdateManagerFlushException extends /* Abstract */TestCase {\r\n-\r\n-    private TestUpdateManager updMgr;\r\n-\r\n-    public void setUp() {\r\n-        updMgr = new TestUpdateManager();\r\n-    }\r\n-\r\n-    /**\r\n-     * Tests exception collection returns from UpdateManager flush method is in\r\n-     * the order the original exceptions are thrown.\r\n-     */\r\n-    public void testAddRetrieve() {\r\n-        \r\n-        Collection states = new ArrayList<OpenJPAStateManager>();\r\n-        states.add(new TestOpenJPAStateManager());\r\n-\r\n-        Collection exceps = updMgr.flush(states, new TestJDBCStore());\r\n-\r\n-        assertEquals(3, exceps.size());\r\n-        \r\n-        Iterator<Exception> itr = exceps.iterator();\r\n-        assertEquals(itr.next().getMessage(),\r\n-            \"TestUpdateManager.populateRowManager\");\r\n-        assertEquals(itr.next().getMessage(),\r\n-            \"TestUpdateManager.flush\");\r\n-        assertEquals(itr.next().getMessage(),\r\n-            \"TestUpdateManager.customInsert\");\r\n-    }\r\n-\r\n-    /*\r\n-     * Scaffolding test update manager.\r\n-     */\r\n-    class TestUpdateManager extends AbstractUpdateManager {\r\n-\r\n-        protected Collection flush(RowManager rowMgr,\r\n-            PreparedStatementManager psMgr, Collection exceps) {\r\n-\r\n-            exceps.add(new SQLException(\"TestUpdateManager.flush\"));\r\n-\r\n-            return exceps;\r\n-        }\r\n-\r\n-        protected PreparedStatementManager newPreparedStatementManager(\r\n-            JDBCStore store, Connection conn) {\r\n-            return new PreparedStatementManagerImpl(store, conn);\r\n-        }\r\n-\r\n-        protected RowManager newRowManager() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean orderDirty() {\r\n-            return false;\r\n-        }\r\n-\r\n-        protected Collection populateRowManager(OpenJPAStateManager sm,\r\n-            RowManager rowMgr, JDBCStore store, Collection exceps,\r\n-            Collection customs) {\r\n-            \r\n-            exceps.add(new SQLException(\r\n-                \"TestUpdateManager.populateRowManager\"));\r\n-            customs.add(new CustomMapping(CustomMapping.INSERT, sm,\r\n-                new Strategy() {\r\n-                    public void customDelete(OpenJPAStateManager sm,\r\n-                        JDBCStore store) throws SQLException {\r\n-                    }\r\n-\r\n-                    public void customInsert(OpenJPAStateManager sm,\r\n-                        JDBCStore store) throws SQLException {\r\n-                        throw new SQLException(\r\n-                            \"TestUpdateManager.customInsert\");\r\n-                    }\r\n-\r\n-                    public void customUpdate(OpenJPAStateManager sm,\r\n-                        JDBCStore store) throws SQLException {\r\n-                    }\r\n-\r\n-                    public void delete(OpenJPAStateManager sm, JDBCStore store,\r\n-                        RowManager rm) throws SQLException {\r\n-                    }\r\n-\r\n-                    public String getAlias() {\r\n-                        return null;\r\n-                    }\r\n-\r\n-                    public void initialize() {\r\n-                    }\r\n-\r\n-                    public void insert(OpenJPAStateManager sm, JDBCStore store,\r\n-                        RowManager rm) throws SQLException {\r\n-\r\n-                    }\r\n-\r\n-                    public Boolean isCustomDelete(OpenJPAStateManager sm,\r\n-                        JDBCStore store) {\r\n-                        return null;\r\n-                    }\r\n-\r\n-                    public Boolean isCustomInsert(OpenJPAStateManager sm,\r\n-                        JDBCStore store) {\r\n-                        return null;\r\n-                    }\r\n-\r\n-                    public Boolean isCustomUpdate(OpenJPAStateManager sm,\r\n-                        JDBCStore store) {\r\n-                        return null;\r\n-                    }\r\n-\r\n-                    public void map(boolean adapt) {\r\n-                    }\r\n-\r\n-                    public void update(OpenJPAStateManager sm, JDBCStore store,\r\n-                        RowManager rm) throws SQLException {\r\n-                    }\r\n-                }));\r\n-            return exceps;\r\n-        }\r\n-    }\r\n-\r\n-    /*\r\n-     * Scaffolding test state manager.\r\n-     */\r\n-    class TestOpenJPAStateManager implements OpenJPAStateManager {\r\n-\r\n-        public boolean assignObjectId(boolean flush) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean beforeRefresh(boolean refreshAll) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public void dirty(int field) {\r\n-        }\r\n-\r\n-        public Object fetch(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean fetchBoolean(int field) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public byte fetchByte(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public char fetchChar(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public double fetchDouble(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Object fetchField(int field, boolean transitions) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public float fetchFloat(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Object fetchInitialField(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public int fetchInt(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public long fetchLong(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Object fetchObject(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public short fetchShort(int field) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public String fetchString(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public StoreContext getContext() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public BitSet getDirty() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public BitSet getFlushed() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getId() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getImplData() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getImplData(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getIntermediate(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public BitSet getLoaded() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getLock() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getManagedInstance() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public ClassMetaData getMetaData() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getObjectId() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public OpenJPAStateManager getOwner() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public int getOwnerIndex() {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public PCState getPCState() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PersistenceCapable getPersistenceCapable() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public BitSet getUnloaded(FetchConfiguration fetch) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getVersion() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void initialize(Class forType, PCState state) {\r\n-        }\r\n-\r\n-        public boolean isDefaultValue(int field) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isEmbedded() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isFlushed() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isFlushedDirty() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isImplDataCacheable() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isImplDataCacheable(int field) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isProvisional() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isVersionCheckRequired() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isVersionUpdateRequired() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public void load(FetchConfiguration fetch) {\r\n-        }\r\n-\r\n-        public Object newFieldProxy(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object newProxy(int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void removed(int field, Object removed, boolean key) {\r\n-        }\r\n-\r\n-        public Object setImplData(Object data, boolean cacheable) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object setImplData(int field, Object data) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void setIntermediate(int field, Object value) {\r\n-        }\r\n-\r\n-        public void setLock(Object lock) {\r\n-        }\r\n-\r\n-        public void setNextVersion(Object version) {\r\n-        }\r\n-\r\n-        public void setObjectId(Object oid) {\r\n-        }\r\n-\r\n-        public void setRemote(int field, Object value) {\r\n-        }\r\n-\r\n-        public void setVersion(Object version) {\r\n-        }\r\n-\r\n-        public void store(int field, Object value) {\r\n-        }\r\n-\r\n-        public void storeBoolean(int field, boolean externalVal) {\r\n-        }\r\n-\r\n-        public void storeByte(int field, byte externalVal) {\r\n-        }\r\n-\r\n-        public void storeChar(int field, char externalVal) {\r\n-        }\r\n-\r\n-        public void storeDouble(int field, double externalVal) {\r\n-        }\r\n-\r\n-        public void storeField(int field, Object value) {\r\n-        }\r\n-\r\n-        public void storeFloat(int field, float externalVal) {\r\n-        }\r\n-\r\n-        public void storeInt(int field, int externalVal) {\r\n-        }\r\n-\r\n-        public void storeLong(int field, long externalVal) {\r\n-        }\r\n-\r\n-        public void storeObject(int field, Object externalVal) {\r\n-        }\r\n-\r\n-        public void storeShort(int field, short externalVal) {\r\n-        }\r\n-\r\n-        public void storeString(int field, String externalVal) {\r\n-        }\r\n-\r\n-        public void accessingField(int idx) {\r\n-        }\r\n-\r\n-        public void dirty(String field) {\r\n-        }\r\n-\r\n-        public Object fetchObjectId() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getGenericContext() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Object getPCPrimaryKey(Object oid, int field) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean isDeleted() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isDetached() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isDirty() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isNew() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isPersistent() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isTransactional() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public void providedBooleanField(PersistenceCapable pc, int idx,\r\n-            boolean cur) {\r\n-        }\r\n-\r\n-        public void providedByteField(PersistenceCapable pc, int idx,\r\n-            byte cur) {\r\n-        }\r\n-\r\n-        public void providedCharField(PersistenceCapable pc, int idx, \r\n-            char cur) {\r\n-        }\r\n-\r\n-        public void providedDoubleField(PersistenceCapable pc, int idx,\r\n-            double cur) {\r\n-        }\r\n-\r\n-        public void providedFloatField(PersistenceCapable pc, int idx,\r\n-            float cur) {\r\n-        }\r\n-\r\n-        public void providedIntField(PersistenceCapable pc, int idx, \r\n-            int cur) {\r\n-        }\r\n-\r\n-        public void providedLongField(PersistenceCapable pc, int idx, \r\n-            long cur) {\r\n-        }\r\n-\r\n-        public void providedObjectField(PersistenceCapable pc, int idx,\r\n-            Object cur) {\r\n-        }\r\n-\r\n-        public void providedShortField(PersistenceCapable pc, int idx, \r\n-            short cur) {\r\n-        }\r\n-\r\n-        public void providedStringField(PersistenceCapable pc, int idx,\r\n-            String cur) {\r\n-        }\r\n-\r\n-        public void proxyDetachedDeserialized(int idx) {\r\n-        }\r\n-\r\n-        public boolean replaceBooleanField(PersistenceCapable pc, int idx) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public byte replaceByteField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public char replaceCharField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public double replaceDoubleField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public float replaceFloatField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public int replaceIntField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public long replaceLongField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Object replaceObjectField(PersistenceCapable pc, int idx) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public short replaceShortField(PersistenceCapable pc, int idx) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public StateManager replaceStateManager(StateManager sm) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public String replaceStringField(PersistenceCapable pc, int idx) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean serializing() {\r\n-            return false;\r\n-        }\r\n-\r\n-        public void settingBooleanField(PersistenceCapable pc, int idx,\r\n-            boolean cur, boolean next, int set) {\r\n-        }\r\n-\r\n-        public void settingByteField(PersistenceCapable pc, int idx, byte cur,\r\n-            byte next, int set) {\r\n-        }\r\n-\r\n-        public void settingCharField(PersistenceCapable pc, int idx, char cur,\r\n-            char next, int set) {\r\n-        }\r\n-\r\n-        public void settingDoubleField(PersistenceCapable pc, int idx,\r\n-            double cur, double next, int set) {\r\n-        }\r\n-\r\n-        public void settingFloatField(PersistenceCapable pc, int idx,\r\n-            float cur, float next, int set) {\r\n-        }\r\n-\r\n-        public void settingIntField(PersistenceCapable pc, int idx, int cur,\r\n-            int next, int set) {\r\n-        }\r\n-\r\n-        public void settingLongField(PersistenceCapable pc, int idx, long cur,\r\n-            long next, int set) {\r\n-        }\r\n-\r\n-        public void settingObjectField(PersistenceCapable pc, int idx,\r\n-            Object cur, Object next, int set) {\r\n-        }\r\n-\r\n-        public void settingShortField(PersistenceCapable pc, int idx,\r\n-            short cur, short next, int set) {\r\n-        }\r\n-\r\n-        public void settingStringField(PersistenceCapable pc, int idx,\r\n-            String cur, String next, int set) {\r\n-        }\r\n-\r\n-        public boolean writeDetached(ObjectOutput out) throws IOException {\r\n-            return false;\r\n-        }\r\n-\r\n-        public void storeBooleanField(int fieldIndex, boolean value) {\r\n-        }\r\n-\r\n-        public void storeByteField(int fieldIndex, byte value) {\r\n-        }\r\n-\r\n-        public void storeCharField(int fieldIndex, char value) {\r\n-        }\r\n-\r\n-        public void storeDoubleField(int fieldIndex, double value) {\r\n-        }\r\n-\r\n-        public void storeFloatField(int fieldIndex, float value) {\r\n-        }\r\n-\r\n-        public void storeIntField(int fieldIndex, int value) {\r\n-        }\r\n-\r\n-        public void storeLongField(int fieldIndex, long value) {\r\n-        }\r\n-\r\n-        public void storeObjectField(int fieldIndex, Object value) {\r\n-        }\r\n-\r\n-        public void storeShortField(int fieldIndex, short value) {\r\n-        }\r\n-\r\n-        public void storeStringField(int fieldIndex, String value) {\r\n-        }\r\n-\r\n-        public boolean fetchBooleanField(int fieldIndex) {\r\n-            return false;\r\n-        }\r\n-\r\n-        public byte fetchByteField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public char fetchCharField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public double fetchDoubleField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public float fetchFloatField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public int fetchIntField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public long fetchLongField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Object fetchObjectField(int fieldIndex) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public short fetchShortField(int fieldIndex) {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public String fetchStringField(int fieldIndex) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    /*\r\n-     * Scaffolding test connection.\r\n-     */\r\n-    class TestConnection implements Connection {\r\n-\r\n-        public void clearWarnings() throws SQLException {\r\n-        }\r\n-\r\n-        public void close() throws SQLException {\r\n-        }\r\n-\r\n-        public void commit() throws SQLException {\r\n-        }\r\n-\r\n-        public Statement createStatement() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Statement createStatement(int resultSetType,\r\n-            int resultSetConcurrency) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Statement createStatement(int resultSetType,\r\n-            int resultSetConcurrency, int resultSetHoldability)\r\n-            throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean getAutoCommit() throws SQLException {\r\n-            return false;\r\n-        }\r\n-\r\n-        public String getCatalog() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public int getHoldability() throws SQLException {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public DatabaseMetaData getMetaData() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public int getTransactionIsolation() throws SQLException {\r\n-            return 0;\r\n-        }\r\n-\r\n-        public Map<String, Class<?>> getTypeMap() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public SQLWarning getWarnings() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public boolean isClosed() throws SQLException {\r\n-            return false;\r\n-        }\r\n-\r\n-        public boolean isReadOnly() throws SQLException {\r\n-            return false;\r\n-        }\r\n-\r\n-        public String nativeSQL(String sql) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public CallableStatement prepareCall(String sql) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public CallableStatement prepareCall(String sql, int resultSetType,\r\n-            int resultSetConcurrency) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public CallableStatement prepareCall(String sql, int resultSetType,\r\n-            int resultSetConcurrency, int resultSetHoldability)\r\n-            throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql)\r\n-            throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql,\r\n-            int autoGeneratedKeys) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql,\r\n-            int[] columnIndexes) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql,\r\n-            String[] columnNames) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql,\r\n-            int resultSetType, int resultSetConcurrency) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public PreparedStatement prepareStatement(String sql,\r\n-            int resultSetType, int resultSetConcurrency,\r\n-            int resultSetHoldability) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void releaseSavepoint(Savepoint savepoint) throws SQLException {\r\n-        }\r\n-\r\n-        public void rollback() throws SQLException {\r\n-        }\r\n-\r\n-        public void rollback(Savepoint savepoint) throws SQLException {\r\n-        }\r\n-\r\n-        public void setAutoCommit(boolean autoCommit) throws SQLException {\r\n-        }\r\n-\r\n-        public void setCatalog(String catalog) throws SQLException {\r\n-        }\r\n-\r\n-        public void setHoldability(int holdability) throws SQLException {\r\n-        }\r\n-\r\n-        public void setReadOnly(boolean readOnly) throws SQLException {\r\n-        }\r\n-\r\n-        public Savepoint setSavepoint() throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Savepoint setSavepoint(String name) throws SQLException {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void setTransactionIsolation(int level) throws SQLException {\r\n-        }\r\n-\r\n-        public void setTypeMap(Map<String, Class<?>> map) throws SQLException {\r\n-        }\r\n-    }\r\n-\r\n-    /*\r\n-     * Scaffolding test store manager.\r\n-     */\r\n-    class TestJDBCStore implements JDBCStore {\r\n-\r\n-        public Object find(Object oid, ValueMapping vm,\r\n-            JDBCFetchConfiguration fetch) {\r\n-            return null;\r\n-        }\r\n-\r\n-        public JDBCConfiguration getConfiguration() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public Connection getConnection() {\r\n-            return new TestConnection();\r\n-        }\r\n-\r\n-        public StoreContext getContext() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public DBDictionary getDBDictionary() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public JDBCFetchConfiguration getFetchConfiguration() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public JDBCLockManager getLockManager() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public SQLFactory getSQLFactory() {\r\n-            return null;\r\n-        }\r\n-\r\n-        public void loadSubclasses(ClassMapping mapping) {\r\n-\r\n-        }\r\n-\r\n-        public Id newDataStoreId(long id, ClassMapping mapping, boolean subs) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.jdbc.kernel;\n+\n+import java.io.IOException;\n+import java.io.ObjectOutput;\n+import java.sql.CallableStatement;\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.sql.SQLWarning;\n+import java.sql.Savepoint;\n+import java.sql.Statement;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.openjpa.enhance.PersistenceCapable;\n+import org.apache.openjpa.enhance.StateManager;\n+import org.apache.openjpa.jdbc.conf.JDBCConfiguration;\n+import org.apache.openjpa.jdbc.meta.ClassMapping;\n+import org.apache.openjpa.jdbc.meta.Strategy;\n+import org.apache.openjpa.jdbc.meta.ValueMapping;\n+import org.apache.openjpa.jdbc.sql.DBDictionary;\n+import org.apache.openjpa.jdbc.sql.RowManager;\n+import org.apache.openjpa.jdbc.sql.SQLFactory;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.PCState;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.util.Id;\n+\n+/**\n+ * <p>\n+ * Tests AbstractUpdateManager flush's method exception return behavior.\n+ * </p>\n+ * \n+ * @author Albert Lee\n+ */\n+public class TestUpdateManagerFlushException extends /* Abstract */TestCase {\n+\n+    private TestUpdateManager updMgr;\n+\n+    public void setUp() {\n+        updMgr = new TestUpdateManager();\n+    }\n+\n+    /**\n+     * Tests exception collection returns from UpdateManager flush method is in\n+     * the order the original exceptions are thrown.\n+     */\n+    public void testAddRetrieve() {\n+        \n+        Collection states = new ArrayList<OpenJPAStateManager>();\n+        states.add(new TestOpenJPAStateManager());\n+\n+        Collection exceps = updMgr.flush(states, new TestJDBCStore());\n+\n+        assertEquals(3, exceps.size());\n+        \n+        Iterator<Exception> itr = exceps.iterator();\n+        assertEquals(itr.next().getMessage(),\n+            \"TestUpdateManager.populateRowManager\");\n+        assertEquals(itr.next().getMessage(),\n+            \"TestUpdateManager.flush\");\n+        assertEquals(itr.next().getMessage(),\n+            \"TestUpdateManager.customInsert\");\n+    }\n+\n+    /*\n+     * Scaffolding test update manager.\n+     */\n+    class TestUpdateManager extends AbstractUpdateManager {\n+\n+        protected Collection flush(RowManager rowMgr,\n+            PreparedStatementManager psMgr, Collection exceps) {\n+\n+            exceps.add(new SQLException(\"TestUpdateManager.flush\"));\n+\n+            return exceps;\n+        }\n+\n+        protected PreparedStatementManager newPreparedStatementManager(\n+            JDBCStore store, Connection conn) {\n+            return new PreparedStatementManagerImpl(store, conn);\n+        }\n+\n+        protected RowManager newRowManager() {\n+            return null;\n+        }\n+\n+        public boolean orderDirty() {\n+            return false;\n+        }\n+\n+        protected Collection populateRowManager(OpenJPAStateManager sm,\n+            RowManager rowMgr, JDBCStore store, Collection exceps,\n+            Collection customs) {\n+            \n+            exceps.add(new SQLException(\n+                \"TestUpdateManager.populateRowManager\"));\n+            customs.add(new CustomMapping(CustomMapping.INSERT, sm,\n+                new Strategy() {\n+                    public void customDelete(OpenJPAStateManager sm,\n+                        JDBCStore store) throws SQLException {\n+                    }\n+\n+                    public void customInsert(OpenJPAStateManager sm,\n+                        JDBCStore store) throws SQLException {\n+                        throw new SQLException(\n+                            \"TestUpdateManager.customInsert\");\n+                    }\n+\n+                    public void customUpdate(OpenJPAStateManager sm,\n+                        JDBCStore store) throws SQLException {\n+                    }\n+\n+                    public void delete(OpenJPAStateManager sm, JDBCStore store,\n+                        RowManager rm) throws SQLException {\n+                    }\n+\n+                    public String getAlias() {\n+                        return null;\n+                    }\n+\n+                    public void initialize() {\n+                    }\n+\n+                    public void insert(OpenJPAStateManager sm, JDBCStore store,\n+                        RowManager rm) throws SQLException {\n+\n+                    }\n+\n+                    public Boolean isCustomDelete(OpenJPAStateManager sm,\n+                        JDBCStore store) {\n+                        return null;\n+                    }\n+\n+                    public Boolean isCustomInsert(OpenJPAStateManager sm,\n+                        JDBCStore store) {\n+                        return null;\n+                    }\n+\n+                    public Boolean isCustomUpdate(OpenJPAStateManager sm,\n+                        JDBCStore store) {\n+                        return null;\n+                    }\n+\n+                    public void map(boolean adapt) {\n+                    }\n+\n+                    public void update(OpenJPAStateManager sm, JDBCStore store,\n+                        RowManager rm) throws SQLException {\n+                    }\n+                }));\n+            return exceps;\n+        }\n+    }\n+\n+    /*\n+     * Scaffolding test state manager.\n+     */\n+    class TestOpenJPAStateManager implements OpenJPAStateManager {\n+\n+        public boolean assignObjectId(boolean flush) {\n+            return false;\n+        }\n+\n+        public boolean beforeRefresh(boolean refreshAll) {\n+            return false;\n+        }\n+\n+        public void dirty(int field) {\n+        }\n+\n+        public Object fetch(int field) {\n+            return null;\n+        }\n+\n+        public boolean fetchBoolean(int field) {\n+            return false;\n+        }\n+\n+        public byte fetchByte(int field) {\n+            return 0;\n+        }\n+\n+        public char fetchChar(int field) {\n+            return 0;\n+        }\n+\n+        public double fetchDouble(int field) {\n+            return 0;\n+        }\n+\n+        public Object fetchField(int field, boolean transitions) {\n+            return null;\n+        }\n+\n+        public float fetchFloat(int field) {\n+            return 0;\n+        }\n+\n+        public Object fetchInitialField(int field) {\n+            return null;\n+        }\n+\n+        public int fetchInt(int field) {\n+            return 0;\n+        }\n+\n+        public long fetchLong(int field) {\n+            return 0;\n+        }\n+\n+        public Object fetchObject(int field) {\n+            return null;\n+        }\n+\n+        public short fetchShort(int field) {\n+            return 0;\n+        }\n+\n+        public String fetchString(int field) {\n+            return null;\n+        }\n+\n+        public StoreContext getContext() {\n+            return null;\n+        }\n+\n+        public BitSet getDirty() {\n+            return null;\n+        }\n+\n+        public BitSet getFlushed() {\n+            return null;\n+        }\n+\n+        public Object getId() {\n+            return null;\n+        }\n+\n+        public Object getImplData() {\n+            return null;\n+        }\n+\n+        public Object getImplData(int field) {\n+            return null;\n+        }\n+\n+        public Object getIntermediate(int field) {\n+            return null;\n+        }\n+\n+        public BitSet getLoaded() {\n+            return null;\n+        }\n+\n+        public Object getLock() {\n+            return null;\n+        }\n+\n+        public Object getManagedInstance() {\n+            return null;\n+        }\n+\n+        public ClassMetaData getMetaData() {\n+            return null;\n+        }\n+\n+        public Object getObjectId() {\n+            return null;\n+        }\n+\n+        public OpenJPAStateManager getOwner() {\n+            return null;\n+        }\n+\n+        public int getOwnerIndex() {\n+            return 0;\n+        }\n+\n+        public PCState getPCState() {\n+            return null;\n+        }\n+\n+        public PersistenceCapable getPersistenceCapable() {\n+            return null;\n+        }\n+\n+        public BitSet getUnloaded(FetchConfiguration fetch) {\n+            return null;\n+        }\n+\n+        public Object getVersion() {\n+            return null;\n+        }\n+\n+        public void initialize(Class forType, PCState state) {\n+        }\n+\n+        public boolean isDefaultValue(int field) {\n+            return false;\n+        }\n+\n+        public boolean isEmbedded() {\n+            return false;\n+        }\n+\n+        public boolean isFlushed() {\n+            return false;\n+        }\n+\n+        public boolean isFlushedDirty() {\n+            return false;\n+        }\n+\n+        public boolean isImplDataCacheable() {\n+            return false;\n+        }\n+\n+        public boolean isImplDataCacheable(int field) {\n+            return false;\n+        }\n+\n+        public boolean isProvisional() {\n+            return false;\n+        }\n+\n+        public boolean isVersionCheckRequired() {\n+            return false;\n+        }\n+\n+        public boolean isVersionUpdateRequired() {\n+            return false;\n+        }\n+\n+        public void load(FetchConfiguration fetch) {\n+        }\n+\n+        public Object newFieldProxy(int field) {\n+            return null;\n+        }\n+\n+        public Object newProxy(int field) {\n+            return null;\n+        }\n+\n+        public void removed(int field, Object removed, boolean key) {\n+        }\n+\n+        public Object setImplData(Object data, boolean cacheable) {\n+            return null;\n+        }\n+\n+        public Object setImplData(int field, Object data) {\n+            return null;\n+        }\n+\n+        public void setIntermediate(int field, Object value) {\n+        }\n+\n+        public void setLock(Object lock) {\n+        }\n+\n+        public void setNextVersion(Object version) {\n+        }\n+\n+        public void setObjectId(Object oid) {\n+        }\n+\n+        public void setRemote(int field, Object value) {\n+        }\n+\n+        public void setVersion(Object version) {\n+        }\n+\n+        public void store(int field, Object value) {\n+        }\n+\n+        public void storeBoolean(int field, boolean externalVal) {\n+        }\n+\n+        public void storeByte(int field, byte externalVal) {\n+        }\n+\n+        public void storeChar(int field, char externalVal) {\n+        }\n+\n+        public void storeDouble(int field, double externalVal) {\n+        }\n+\n+        public void storeField(int field, Object value) {\n+        }\n+\n+        public void storeFloat(int field, float externalVal) {\n+        }\n+\n+        public void storeInt(int field, int externalVal) {\n+        }\n+\n+        public void storeLong(int field, long externalVal) {\n+        }\n+\n+        public void storeObject(int field, Object externalVal) {\n+        }\n+\n+        public void storeShort(int field, short externalVal) {\n+        }\n+\n+        public void storeString(int field, String externalVal) {\n+        }\n+\n+        public void accessingField(int idx) {\n+        }\n+\n+        public void dirty(String field) {\n+        }\n+\n+        public Object fetchObjectId() {\n+            return null;\n+        }\n+\n+        public Object getGenericContext() {\n+            return null;\n+        }\n+\n+        public Object getPCPrimaryKey(Object oid, int field) {\n+            return null;\n+        }\n+\n+        public boolean isDeleted() {\n+            return false;\n+        }\n+\n+        public boolean isDetached() {\n+            return false;\n+        }\n+\n+        public boolean isDirty() {\n+            return false;\n+        }\n+\n+        public boolean isNew() {\n+            return false;\n+        }\n+\n+        public boolean isPersistent() {\n+            return false;\n+        }\n+\n+        public boolean isTransactional() {\n+            return false;\n+        }\n+\n+        public void providedBooleanField(PersistenceCapable pc, int idx,\n+            boolean cur) {\n+        }\n+\n+        public void providedByteField(PersistenceCapable pc, int idx,\n+            byte cur) {\n+        }\n+\n+        public void providedCharField(PersistenceCapable pc, int idx, \n+            char cur) {\n+        }\n+\n+        public void providedDoubleField(PersistenceCapable pc, int idx,\n+            double cur) {\n+        }\n+\n+        public void providedFloatField(PersistenceCapable pc, int idx,\n+            float cur) {\n+        }\n+\n+        public void providedIntField(PersistenceCapable pc, int idx, \n+            int cur) {\n+        }\n+\n+        public void providedLongField(PersistenceCapable pc, int idx, \n+            long cur) {\n+        }\n+\n+        public void providedObjectField(PersistenceCapable pc, int idx,\n+            Object cur) {\n+        }\n+\n+        public void providedShortField(PersistenceCapable pc, int idx, \n+            short cur) {\n+        }\n+\n+        public void providedStringField(PersistenceCapable pc, int idx,\n+            String cur) {\n+        }\n+\n+        public void proxyDetachedDeserialized(int idx) {\n+        }\n+\n+        public boolean replaceBooleanField(PersistenceCapable pc, int idx) {\n+            return false;\n+        }\n+\n+        public byte replaceByteField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public char replaceCharField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public double replaceDoubleField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public float replaceFloatField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public int replaceIntField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public long replaceLongField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public Object replaceObjectField(PersistenceCapable pc, int idx) {\n+            return null;\n+        }\n+\n+        public short replaceShortField(PersistenceCapable pc, int idx) {\n+            return 0;\n+        }\n+\n+        public StateManager replaceStateManager(StateManager sm) {\n+            return null;\n+        }\n+\n+        public String replaceStringField(PersistenceCapable pc, int idx) {\n+            return null;\n+        }\n+\n+        public boolean serializing() {\n+            return false;\n+        }\n+\n+        public void settingBooleanField(PersistenceCapable pc, int idx,\n+            boolean cur, boolean next, int set) {\n+        }\n+\n+        public void settingByteField(PersistenceCapable pc, int idx, byte cur,\n+            byte next, int set) {\n+        }\n+\n+        public void settingCharField(PersistenceCapable pc, int idx, char cur,\n+            char next, int set) {\n+        }\n+\n+        public void settingDoubleField(PersistenceCapable pc, int idx,\n+            double cur, double next, int set) {\n+        }\n+\n+        public void settingFloatField(PersistenceCapable pc, int idx,\n+            float cur, float next, int set) {\n+        }\n+\n+        public void settingIntField(PersistenceCapable pc, int idx, int cur,\n+            int next, int set) {\n+        }\n+\n+        public void settingLongField(PersistenceCapable pc, int idx, long cur,\n+            long next, int set) {\n+        }\n+\n+        public void settingObjectField(PersistenceCapable pc, int idx,\n+            Object cur, Object next, int set) {\n+        }\n+\n+        public void settingShortField(PersistenceCapable pc, int idx,\n+            short cur, short next, int set) {\n+        }\n+\n+        public void settingStringField(PersistenceCapable pc, int idx,\n+            String cur, String next, int set) {\n+        }\n+\n+        public boolean writeDetached(ObjectOutput out) throws IOException {\n+            return false;\n+        }\n+\n+        public void storeBooleanField(int fieldIndex, boolean value) {\n+        }\n+\n+        public void storeByteField(int fieldIndex, byte value) {\n+        }\n+\n+        public void storeCharField(int fieldIndex, char value) {\n+        }\n+\n+        public void storeDoubleField(int fieldIndex, double value) {\n+        }\n+\n+        public void storeFloatField(int fieldIndex, float value) {\n+        }\n+\n+        public void storeIntField(int fieldIndex, int value) {\n+        }\n+\n+        public void storeLongField(int fieldIndex, long value) {\n+        }\n+\n+        public void storeObjectField(int fieldIndex, Object value) {\n+        }\n+\n+        public void storeShortField(int fieldIndex, short value) {\n+        }\n+\n+        public void storeStringField(int fieldIndex, String value) {\n+        }\n+\n+        public boolean fetchBooleanField(int fieldIndex) {\n+            return false;\n+        }\n+\n+        public byte fetchByteField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public char fetchCharField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public double fetchDoubleField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public float fetchFloatField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public int fetchIntField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public long fetchLongField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public Object fetchObjectField(int fieldIndex) {\n+            return null;\n+        }\n+\n+        public short fetchShortField(int fieldIndex) {\n+            return 0;\n+        }\n+\n+        public String fetchStringField(int fieldIndex) {\n+            return null;\n+        }\n+    }\n+\n+    /*\n+     * Scaffolding test connection.\n+     */\n+    class TestConnection implements Connection {\n+\n+        public void clearWarnings() throws SQLException {\n+        }\n+\n+        public void close() throws SQLException {\n+        }\n+\n+        public void commit() throws SQLException {\n+        }\n+\n+        public Statement createStatement() throws SQLException {\n+            return null;\n+        }\n+\n+        public Statement createStatement(int resultSetType,\n+            int resultSetConcurrency) throws SQLException {\n+            return null;\n+        }\n+\n+        public Statement createStatement(int resultSetType,\n+            int resultSetConcurrency, int resultSetHoldability)\n+            throws SQLException {\n+            return null;\n+        }\n+\n+        public boolean getAutoCommit() throws SQLException {\n+            return false;\n+        }\n+\n+        public String getCatalog() throws SQLException {\n+            return null;\n+        }\n+\n+        public int getHoldability() throws SQLException {\n+            return 0;\n+        }\n+\n+        public DatabaseMetaData getMetaData() throws SQLException {\n+            return null;\n+        }\n+\n+        public int getTransactionIsolation() throws SQLException {\n+            return 0;\n+        }\n+\n+        public Map<String, Class<?>> getTypeMap() throws SQLException {\n+            return null;\n+        }\n+\n+        public SQLWarning getWarnings() throws SQLException {\n+            return null;\n+        }\n+\n+        public boolean isClosed() throws SQLException {\n+            return false;\n+        }\n+\n+        public boolean isReadOnly() throws SQLException {\n+            return false;\n+        }\n+\n+        public String nativeSQL(String sql) throws SQLException {\n+            return null;\n+        }\n+\n+        public CallableStatement prepareCall(String sql) throws SQLException {\n+            return null;\n+        }\n+\n+        public CallableStatement prepareCall(String sql, int resultSetType,\n+            int resultSetConcurrency) throws SQLException {\n+            return null;\n+        }\n+\n+        public CallableStatement prepareCall(String sql, int resultSetType,\n+            int resultSetConcurrency, int resultSetHoldability)\n+            throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql)\n+            throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql,\n+            int autoGeneratedKeys) throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql,\n+            int[] columnIndexes) throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql,\n+            String[] columnNames) throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql,\n+            int resultSetType, int resultSetConcurrency) throws SQLException {\n+            return null;\n+        }\n+\n+        public PreparedStatement prepareStatement(String sql,\n+            int resultSetType, int resultSetConcurrency,\n+            int resultSetHoldability) throws SQLException {\n+            return null;\n+        }\n+\n+        public void releaseSavepoint(Savepoint savepoint) throws SQLException {\n+        }\n+\n+        public void rollback() throws SQLException {\n+        }\n+\n+        public void rollback(Savepoint savepoint) throws SQLException {\n+        }\n+\n+        public void setAutoCommit(boolean autoCommit) throws SQLException {\n+        }\n+\n+        public void setCatalog(String catalog) throws SQLException {\n+        }\n+\n+        public void setHoldability(int holdability) throws SQLException {\n+        }\n+\n+        public void setReadOnly(boolean readOnly) throws SQLException {\n+        }\n+\n+        public Savepoint setSavepoint() throws SQLException {\n+            return null;\n+        }\n+\n+        public Savepoint setSavepoint(String name) throws SQLException {\n+            return null;\n+        }\n+\n+        public void setTransactionIsolation(int level) throws SQLException {\n+        }\n+\n+        public void setTypeMap(Map<String, Class<?>> map) throws SQLException {\n+        }\n+    }\n+\n+    /*\n+     * Scaffolding test store manager.\n+     */\n+    class TestJDBCStore implements JDBCStore {\n+\n+        public Object find(Object oid, ValueMapping vm,\n+            JDBCFetchConfiguration fetch) {\n+            return null;\n+        }\n+\n+        public JDBCConfiguration getConfiguration() {\n+            return null;\n+        }\n+\n+        public Connection getConnection() {\n+            return new TestConnection();\n+        }\n+\n+        public StoreContext getContext() {\n+            return null;\n+        }\n+\n+        public DBDictionary getDBDictionary() {\n+            return null;\n+        }\n+\n+        public JDBCFetchConfiguration getFetchConfiguration() {\n+            return null;\n+        }\n+\n+        public JDBCLockManager getLockManager() {\n+            return null;\n+        }\n+\n+        public SQLFactory getSQLFactory() {\n+            return null;\n+        }\n+\n+        public void loadSubclasses(ClassMapping mapping) {\n+\n+        }\n+\n+        public Id newDataStoreId(long id, ClassMapping mapping, boolean subs) {\n+            return null;\n+        }\n+    }\n+}"},{"sha":"03d21d6c8bcabc5da148c2f8d5f1e1eb5eb9e575","filename":"openjpa-kernel/pom.xml","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/pom.xml?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -31,7 +31,7 @@\n     <parent>\n         <groupId>org.apache.openjpa</groupId>\n         <artifactId>openjpa-parent</artifactId>\n-        <version>1.2.1</version>\n+        <version>1.2.2</version>\n     </parent>\n     <dependencies>\n         <dependency>"},{"sha":"8d1bf94ad53d916c4461e21230ecc51d9565ea79","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java","status":"modified","additions":91,"deletions":91,"changes":182,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshaller.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,92 +1,92 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-\r\n-/**\r\n- * Responsible for marshalling and unmarshalling objects between memory and\r\n- * durable cache.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public interface CacheMarshaller {\r\n-\r\n-    /**\r\n-     * Load and return an instance of the type handled by this marshaller.\r\n-     * If the type implements {@link Configurable}, then this method will invoke\r\n-     * {@link Configurable#setConfiguration}, \r\n-     * {@link Configurable#startConfiguration()}, and\r\n-     * {@link Configurable#endConfiguration()} on the instance before returning.\r\n-     */\r\n-    public Object load();\r\n-\r\n-    /**\r\n-     * Store <code>o</code> into the cache.\r\n-     */\r\n-    public void store(Object o);\r\n-\r\n-    /**\r\n-     * The id that this marshaller is responsible for.\r\n-     * A value for this parameter is required.\r\n-     */\r\n-    public void setId(String id);\r\n-\r\n-    /**\r\n-     * The id that this marshaller is responsible for.\r\n-     */\r\n-    public String getId();\r\n-\r\n-    /**\r\n-     * The {@link ValidationPolicy} that this marshaller should use.\r\n-     * A value for this parameter is required. The class will be instantiated\r\n-     * via the {@link org.apache.openjpa.lib.conf.Configurations} mechanism, ensuring that if the class\r\n-     * implements {@link Configurable} or {@link org.apache.openjpa.lib.conf.GenericConfigurable}, it will\r\n-     * be taken through the appropriate lifecycle.\r\n-     */\r\n-    public void setValidationPolicy(String policy)\r\n-        throws InstantiationException, IllegalAccessException;\r\n-\r\n-    /**\r\n-     * Validation policies are responsible for computing whether or not a\r\n-     * cached data structure is valid for the current context.\r\n-     * <p/>\r\n-     * <code>getValidCachedData(getCacheableData(o), conf)</code> should\r\n-     * return an object equivalent to <code>o</code> in the expected case.\r\n-     * <p/>\r\n-     * Implementations of this class will often also implement\r\n-     * {@link Configurable} in order to receive the current\r\n-     * {@link Configuration}.\r\n-     */\r\n-    public interface ValidationPolicy {\r\n-        /**\r\n-         * Returns an object that this policy considers to be valid, based\r\n-         * on <code>o</code>. If <code>o</code> is not valid, this method\r\n-         * will return <code>null</code>.\r\n-         */\r\n-        public Object getValidData(Object o);\r\n-\r\n-        /**\r\n-         * Return an object that the {@link CacheMarshaller} should store.\r\n-         */\r\n-        public Object getCacheableData(Object o);\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+\n+/**\n+ * Responsible for marshalling and unmarshalling objects between memory and\n+ * durable cache.\n+ *\n+ * @since 1.1.0\n+ */\n+public interface CacheMarshaller {\n+\n+    /**\n+     * Load and return an instance of the type handled by this marshaller.\n+     * If the type implements {@link Configurable}, then this method will invoke\n+     * {@link Configurable#setConfiguration}, \n+     * {@link Configurable#startConfiguration()}, and\n+     * {@link Configurable#endConfiguration()} on the instance before returning.\n+     */\n+    public Object load();\n+\n+    /**\n+     * Store <code>o</code> into the cache.\n+     */\n+    public void store(Object o);\n+\n+    /**\n+     * The id that this marshaller is responsible for.\n+     * A value for this parameter is required.\n+     */\n+    public void setId(String id);\n+\n+    /**\n+     * The id that this marshaller is responsible for.\n+     */\n+    public String getId();\n+\n+    /**\n+     * The {@link ValidationPolicy} that this marshaller should use.\n+     * A value for this parameter is required. The class will be instantiated\n+     * via the {@link org.apache.openjpa.lib.conf.Configurations} mechanism, ensuring that if the class\n+     * implements {@link Configurable} or {@link org.apache.openjpa.lib.conf.GenericConfigurable}, it will\n+     * be taken through the appropriate lifecycle.\n+     */\n+    public void setValidationPolicy(String policy)\n+        throws InstantiationException, IllegalAccessException;\n+\n+    /**\n+     * Validation policies are responsible for computing whether or not a\n+     * cached data structure is valid for the current context.\n+     * <p/>\n+     * <code>getValidCachedData(getCacheableData(o), conf)</code> should\n+     * return an object equivalent to <code>o</code> in the expected case.\n+     * <p/>\n+     * Implementations of this class will often also implement\n+     * {@link Configurable} in order to receive the current\n+     * {@link Configuration}.\n+     */\n+    public interface ValidationPolicy {\n+        /**\n+         * Returns an object that this policy considers to be valid, based\n+         * on <code>o</code>. If <code>o</code> is not valid, this method\n+         * will return <code>null</code>.\n+         */\n+        public Object getValidData(Object o);\n+\n+        /**\n+         * Return an object that the {@link CacheMarshaller} should store.\n+         */\n+        public Object getCacheableData(Object o);\n+    }\n }\n\\ No newline at end of file"},{"sha":"40684bb0fb541b822fec70ab67d85ca4e22a14f0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java","status":"modified","additions":253,"deletions":253,"changes":506,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallerImpl.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,253 +1,253 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.io.BufferedInputStream;\r\n-import java.io.BufferedOutputStream;\r\n-import java.io.File;\r\n-import java.io.FileOutputStream;\r\n-import java.io.IOException;\r\n-import java.io.ObjectInputStream;\r\n-import java.io.ObjectOutputStream;\r\n-import java.io.OutputStream;\r\n-import java.net.URL;\r\n-import java.util.Enumeration;\r\n-import java.util.List;\r\n-import java.util.ArrayList;\r\n-\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.conf.Configurations;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.util.InternalException;\r\n-\r\n-/**\r\n- * Default {@link CacheMarshaller} implementation that writes data\r\n- * to a specified file and reads data from a specified file or URL.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class CacheMarshallerImpl\r\n-    implements CacheMarshaller, Configurable {\r\n-\r\n-    private static final Localizer _loc =\r\n-        Localizer.forPackage(CacheMarshallerImpl.class);\r\n-\r\n-    private String _id;\r\n-    private ValidationPolicy _validationPolicy;\r\n-    private OpenJPAConfiguration _conf;\r\n-    private Log _log;\r\n-    private File _outputFile;\r\n-    private URL _inputURL;\r\n-\r\n-    // temporary storage for resource location specification\r\n-    private String _inputResourceLocation;\r\n-    \r\n-    private boolean _consumeErrors = true;\r\n-\r\n-    public Object load() {\r\n-        if (_inputURL == null) {\r\n-            _log.trace(_loc.get(\"cache-marshaller-no-inputs\", getId()));\r\n-            return null;\r\n-        }\r\n-\r\n-        Object o = null;\r\n-        ObjectInputStream in = null;\r\n-        try {\r\n-            in = new ObjectInputStream(new BufferedInputStream(\r\n-                _inputURL.openStream()));\r\n-\r\n-            o = in.readObject();\r\n-            o = _validationPolicy.getValidData(o);\r\n-\r\n-            if (o != null && o.getClass().isArray()) {\r\n-                Object[] array = (Object[]) o;\r\n-                for (int i = 0; i < array.length; i++)\r\n-                    configure(array[i]);\r\n-            } else {\r\n-                configure(o);\r\n-            }\r\n-\r\n-            if (_log.isTraceEnabled())\r\n-                _log.trace(_loc.get(\"cache-marshaller-loaded\",\r\n-                    o == null ? null : o.getClass().getName(), _inputURL));\r\n-        } catch (Exception e) {\r\n-            if (_consumeErrors) {\r\n-                if (_log.isWarnEnabled())\r\n-                    _log.warn(_loc.get(\"cache-marshaller-load-exception-ignore\",\r\n-                        _inputURL), e);\r\n-            } else {\r\n-                throw new InternalException(\r\n-                    _loc.get(\"cache-marshaller-load-exception-fatal\",\r\n-                        _inputURL),\r\n-                    e);\r\n-            }\r\n-        } finally {\r\n-            if (in != null)\r\n-                try { in.close(); } catch (IOException e) { }\r\n-        }\r\n-\r\n-        return o;\r\n-    }\r\n-\r\n-    private void configure(Object o) {\r\n-        if (o instanceof Configurable) {\r\n-            ((Configurable) o).setConfiguration(_conf);\r\n-            ((Configurable) o).startConfiguration();\r\n-            ((Configurable) o).endConfiguration();\r\n-        }\r\n-    }\r\n-\r\n-    public void store(Object o) {\r\n-        if (_outputFile == null) {\r\n-            _log.trace(_loc.get(\"cache-marshaller-no-output-file\", getId()));\r\n-            return;\r\n-        }\r\n-        OutputStream out = null;\r\n-        try {\r\n-            out = new FileOutputStream(_outputFile);\r\n-            ObjectOutputStream oos =\r\n-                new ObjectOutputStream(new BufferedOutputStream(out));\r\n-            Object toStore = _validationPolicy.getCacheableData(o);\r\n-            oos.writeObject(toStore);\r\n-            oos.flush();\r\n-            out.flush();\r\n-            if (_log.isTraceEnabled())\r\n-                _log.trace(_loc.get(\"cache-marshaller-stored\",\r\n-                    o.getClass().getName(), _outputFile));\r\n-        } catch (Exception e) {\r\n-            if (_consumeErrors) {\r\n-                if (_log.isWarnEnabled())\r\n-                    _log.warn(_loc.get(\"cache-marshaller-store-exception\",\r\n-                        o.getClass().getName(), _outputFile), e);\r\n-            } else {\r\n-                throw new InternalException(\r\n-                    _loc.get(\"cache-marshaller-store-exception\",\r\n-                        o.getClass().getName(), _outputFile),\r\n-                    e);\r\n-            }\r\n-        } finally {\r\n-            if (out != null) {\r\n-                try { out.close(); } catch (IOException ioe) { }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void setOutputFile(File file) {\r\n-        _outputFile = file;\r\n-    }\r\n-\r\n-    public File getOutputFile() {\r\n-        return _outputFile;\r\n-    }\r\n-\r\n-    public void setInputURL(URL url) {\r\n-        _inputURL = url;\r\n-    }\r\n-\r\n-    public void setInputResource(String resource) {\r\n-        _inputResourceLocation = resource;\r\n-    }\r\n-\r\n-    public void setConsumeSerializationErrors(boolean consume) {\r\n-        _consumeErrors = consume;\r\n-    }\r\n-\r\n-    public String getId() {\r\n-        return _id;\r\n-    }\r\n-\r\n-    public void setId(String id) {\r\n-        _id = id;\r\n-    }\r\n-\r\n-    public void setValidationPolicy(String policy)\r\n-        throws InstantiationException, IllegalAccessException {\r\n-        String name = Configurations.getClassName(policy);\r\n-        String props = Configurations.getProperties(policy);\r\n-        _validationPolicy = (ValidationPolicy)\r\n-            Configurations.newInstance(name, _conf, props, null);\r\n-    }\r\n-\r\n-    public ValidationPolicy getValidationPolicy() {\r\n-        return _validationPolicy;\r\n-    }\r\n-\r\n-    public void setConfiguration(Configuration conf) {\r\n-        _conf = (OpenJPAConfiguration) conf;\r\n-        _log = conf.getConfigurationLog();\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-        if (_inputResourceLocation != null && _inputURL != null)\r\n-            throw new IllegalStateException(\r\n-                _loc.get(\"cache-marshaller-input-url-and-resource-specified\")\r\n-                    .getMessage());\r\n-        if (_inputResourceLocation != null)\r\n-            setInputUrlFromResourceLocation();\r\n-\r\n-        if (_validationPolicy == null)\r\n-            throw new IllegalStateException(\r\n-                _loc.get(\"cache-marshaller-null-validation-policy\",\r\n-                    getClass().getName()).getMessage());\r\n-        if (_id == null)\r\n-            throw new IllegalStateException(\r\n-                _loc.get(\"cache-marshaller-null-id\",\r\n-                    getClass().getName()).getMessage());\r\n-    }\r\n-\r\n-    private void setInputUrlFromResourceLocation() {\r\n-        try {\r\n-            ClassLoader cl = _conf.getClassResolverInstance()\r\n-                .getClassLoader(getClass(), null);\r\n-            List list = new ArrayList();\r\n-            for (Enumeration e = cl.getResources(_inputResourceLocation);\r\n-                e.hasMoreElements(); )\r\n-                list.add(e);\r\n-\r\n-            if (list.size() > 1) {\r\n-                if (_consumeErrors) {\r\n-                    if (_log.isWarnEnabled())\r\n-                        _log.warn(_loc.get(\r\n-                            \"cache-marshaller-multiple-resources-warn\",\r\n-                            getId(), _inputResourceLocation, list)\r\n-                            .getMessage());\r\n-                } else {\r\n-                    throw new IllegalStateException(\r\n-                        _loc.get(\"cache-marshaller-multiple-resources\",\r\n-                            getId(), _inputResourceLocation, list)\r\n-                            .getMessage());\r\n-                }\r\n-            }\r\n-\r\n-            if (!list.isEmpty())\r\n-                _inputURL = (URL) list.get(0);\r\n-        } catch (IOException ioe) {\r\n-            IllegalStateException ise = new IllegalStateException(\r\n-                _loc.get(\"cache-marshaller-bad-url\", getId(),\r\n-                    _inputResourceLocation).getMessage());\r\n-            ise.initCause(ioe);\r\n-            throw ise;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.net.URL;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.Configurations;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.util.InternalException;\n+\n+/**\n+ * Default {@link CacheMarshaller} implementation that writes data\n+ * to a specified file and reads data from a specified file or URL.\n+ *\n+ * @since 1.1.0\n+ */\n+public class CacheMarshallerImpl\n+    implements CacheMarshaller, Configurable {\n+\n+    private static final Localizer _loc =\n+        Localizer.forPackage(CacheMarshallerImpl.class);\n+\n+    private String _id;\n+    private ValidationPolicy _validationPolicy;\n+    private OpenJPAConfiguration _conf;\n+    private Log _log;\n+    private File _outputFile;\n+    private URL _inputURL;\n+\n+    // temporary storage for resource location specification\n+    private String _inputResourceLocation;\n+    \n+    private boolean _consumeErrors = true;\n+\n+    public Object load() {\n+        if (_inputURL == null) {\n+            _log.trace(_loc.get(\"cache-marshaller-no-inputs\", getId()));\n+            return null;\n+        }\n+\n+        Object o = null;\n+        ObjectInputStream in = null;\n+        try {\n+            in = new ObjectInputStream(new BufferedInputStream(\n+                _inputURL.openStream()));\n+\n+            o = in.readObject();\n+            o = _validationPolicy.getValidData(o);\n+\n+            if (o != null && o.getClass().isArray()) {\n+                Object[] array = (Object[]) o;\n+                for (int i = 0; i < array.length; i++)\n+                    configure(array[i]);\n+            } else {\n+                configure(o);\n+            }\n+\n+            if (_log.isTraceEnabled())\n+                _log.trace(_loc.get(\"cache-marshaller-loaded\",\n+                    o == null ? null : o.getClass().getName(), _inputURL));\n+        } catch (Exception e) {\n+            if (_consumeErrors) {\n+                if (_log.isWarnEnabled())\n+                    _log.warn(_loc.get(\"cache-marshaller-load-exception-ignore\",\n+                        _inputURL), e);\n+            } else {\n+                throw new InternalException(\n+                    _loc.get(\"cache-marshaller-load-exception-fatal\",\n+                        _inputURL),\n+                    e);\n+            }\n+        } finally {\n+            if (in != null)\n+                try { in.close(); } catch (IOException e) { }\n+        }\n+\n+        return o;\n+    }\n+\n+    private void configure(Object o) {\n+        if (o instanceof Configurable) {\n+            ((Configurable) o).setConfiguration(_conf);\n+            ((Configurable) o).startConfiguration();\n+            ((Configurable) o).endConfiguration();\n+        }\n+    }\n+\n+    public void store(Object o) {\n+        if (_outputFile == null) {\n+            _log.trace(_loc.get(\"cache-marshaller-no-output-file\", getId()));\n+            return;\n+        }\n+        OutputStream out = null;\n+        try {\n+            out = new FileOutputStream(_outputFile);\n+            ObjectOutputStream oos =\n+                new ObjectOutputStream(new BufferedOutputStream(out));\n+            Object toStore = _validationPolicy.getCacheableData(o);\n+            oos.writeObject(toStore);\n+            oos.flush();\n+            out.flush();\n+            if (_log.isTraceEnabled())\n+                _log.trace(_loc.get(\"cache-marshaller-stored\",\n+                    o.getClass().getName(), _outputFile));\n+        } catch (Exception e) {\n+            if (_consumeErrors) {\n+                if (_log.isWarnEnabled())\n+                    _log.warn(_loc.get(\"cache-marshaller-store-exception\",\n+                        o.getClass().getName(), _outputFile), e);\n+            } else {\n+                throw new InternalException(\n+                    _loc.get(\"cache-marshaller-store-exception\",\n+                        o.getClass().getName(), _outputFile),\n+                    e);\n+            }\n+        } finally {\n+            if (out != null) {\n+                try { out.close(); } catch (IOException ioe) { }\n+            }\n+        }\n+    }\n+\n+    public void setOutputFile(File file) {\n+        _outputFile = file;\n+    }\n+\n+    public File getOutputFile() {\n+        return _outputFile;\n+    }\n+\n+    public void setInputURL(URL url) {\n+        _inputURL = url;\n+    }\n+\n+    public void setInputResource(String resource) {\n+        _inputResourceLocation = resource;\n+    }\n+\n+    public void setConsumeSerializationErrors(boolean consume) {\n+        _consumeErrors = consume;\n+    }\n+\n+    public String getId() {\n+        return _id;\n+    }\n+\n+    public void setId(String id) {\n+        _id = id;\n+    }\n+\n+    public void setValidationPolicy(String policy)\n+        throws InstantiationException, IllegalAccessException {\n+        String name = Configurations.getClassName(policy);\n+        String props = Configurations.getProperties(policy);\n+        _validationPolicy = (ValidationPolicy)\n+            Configurations.newInstance(name, _conf, props, null);\n+    }\n+\n+    public ValidationPolicy getValidationPolicy() {\n+        return _validationPolicy;\n+    }\n+\n+    public void setConfiguration(Configuration conf) {\n+        _conf = (OpenJPAConfiguration) conf;\n+        _log = conf.getConfigurationLog();\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+        if (_inputResourceLocation != null && _inputURL != null)\n+            throw new IllegalStateException(\n+                _loc.get(\"cache-marshaller-input-url-and-resource-specified\")\n+                    .getMessage());\n+        if (_inputResourceLocation != null)\n+            setInputUrlFromResourceLocation();\n+\n+        if (_validationPolicy == null)\n+            throw new IllegalStateException(\n+                _loc.get(\"cache-marshaller-null-validation-policy\",\n+                    getClass().getName()).getMessage());\n+        if (_id == null)\n+            throw new IllegalStateException(\n+                _loc.get(\"cache-marshaller-null-id\",\n+                    getClass().getName()).getMessage());\n+    }\n+\n+    private void setInputUrlFromResourceLocation() {\n+        try {\n+            ClassLoader cl = _conf.getClassResolverInstance()\n+                .getClassLoader(getClass(), null);\n+            List list = new ArrayList();\n+            for (Enumeration e = cl.getResources(_inputResourceLocation);\n+                e.hasMoreElements(); )\n+                list.add(e);\n+\n+            if (list.size() > 1) {\n+                if (_consumeErrors) {\n+                    if (_log.isWarnEnabled())\n+                        _log.warn(_loc.get(\n+                            \"cache-marshaller-multiple-resources-warn\",\n+                            getId(), _inputResourceLocation, list)\n+                            .getMessage());\n+                } else {\n+                    throw new IllegalStateException(\n+                        _loc.get(\"cache-marshaller-multiple-resources\",\n+                            getId(), _inputResourceLocation, list)\n+                            .getMessage());\n+                }\n+            }\n+\n+            if (!list.isEmpty())\n+                _inputURL = (URL) list.get(0);\n+        } catch (IOException ioe) {\n+            IllegalStateException ise = new IllegalStateException(\n+                _loc.get(\"cache-marshaller-bad-url\", getId(),\n+                    _inputResourceLocation).getMessage());\n+            ise.initCause(ioe);\n+            throw ise;\n+        }\n+    }\n+}"},{"sha":"e0efef07e32d41743f552706ff487e660d72aac0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java","status":"modified","additions":121,"deletions":121,"changes":242,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/CacheMarshallersValue.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,121 +1,121 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.util.HashMap;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.conf.PluginListValue;\r\n-import org.apache.openjpa.conf.NoOpCacheMarshaller;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-\r\n-/**\r\n- * A configuration value for handling and accessing cache marshallers.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class CacheMarshallersValue\r\n-    extends PluginListValue {\r\n-\r\n-    private static final String KEY = \"CacheMarshallers\";\r\n-    private static final CacheMarshaller NO_OP_CACHE_MARSHALLER\r\n-        = new NoOpCacheMarshaller();\r\n-    private static final Localizer _loc =\r\n-        Localizer.forPackage(CacheMarshallersValue.class);\r\n-\r\n-    private Configuration _conf;\r\n-    private Map _marshallers;\r\n-    private boolean _initialized;\r\n-\r\n-    public CacheMarshallersValue(Configuration conf) {\r\n-        super(KEY);\r\n-        _conf = conf;\r\n-        setAlias(\"default\", CacheMarshallerImpl.class.getName());\r\n-        setAlias(\"none\", null);\r\n-        setDefault(\"none\");\r\n-        setString(\"none\");\r\n-        setScope(getClass());\r\n-    }\r\n-\r\n-    public Object instantiate(Class elemType, Configuration conf,\r\n-        boolean fatal) {\r\n-        CacheMarshaller[] ms = (CacheMarshaller[])\r\n-            super.instantiate(elemType, conf, fatal);\r\n-        if (ms != null) {\r\n-            _marshallers = new HashMap();\r\n-            for (int i = 0; i < ms.length; i++) {\r\n-                String mid = ms[i].getId();\r\n-                if (mid != null)\r\n-                    _marshallers.put(mid, ms[i]);\r\n-            }\r\n-        } else {\r\n-            _marshallers = null;\r\n-        }\r\n-        return ms;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the {@link CacheMarshaller} to use for caching metadata of id\r\n-     * <code>id</code>. If no marshaller exists for the id, returns\r\n-     * {@link NoOpCacheMarshaller}.\r\n-     */\r\n-    public CacheMarshaller getMarshallerById(String id) {\r\n-        initialize();\r\n-\r\n-        CacheMarshaller cm = (CacheMarshaller) _marshallers.get(id);\r\n-        if (cm == null) {\r\n-            if (getLog().isTraceEnabled())\r\n-                getLog().trace(_loc.get(\"cache-marshaller-not-found\", id));\r\n-            return NO_OP_CACHE_MARSHALLER;\r\n-        } else {\r\n-            if (getLog().isTraceEnabled())\r\n-                getLog().trace(_loc.get(\"cache-marshaller-found\", id,\r\n-                    cm.getClass().getName()));\r\n-            return cm;\r\n-        }\r\n-    }\r\n-\r\n-    private Log getLog() {\r\n-        return _conf.getConfigurationLog();\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the {@link CacheMarshaller} to use for caching metadata of id\r\n-     * <code>id</code>. If no marshaller exists for the id, returns\r\n-     * {@link NoOpCacheMarshaller}.\r\n-     */\r\n-    public static CacheMarshaller getMarshallerById(Configuration c, String id){\r\n-        CacheMarshallersValue v =\r\n-            ((OpenJPAConfigurationImpl) c).cacheMarshallerPlugins;\r\n-        return v.getMarshallerById(id);\r\n-    }\r\n-\r\n-    public Map getInstancesAsMap() {\r\n-        return _marshallers;\r\n-    }\r\n-\r\n-    protected synchronized void initialize() {\r\n-        if (!_initialized) {\r\n-            instantiate(CacheMarshaller.class, _conf);\r\n-            _initialized = true;\r\n-        }\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.conf.PluginListValue;\n+import org.apache.openjpa.conf.NoOpCacheMarshaller;\n+import org.apache.openjpa.lib.conf.Configuration;\n+\n+/**\n+ * A configuration value for handling and accessing cache marshallers.\n+ *\n+ * @since 1.1.0\n+ */\n+public class CacheMarshallersValue\n+    extends PluginListValue {\n+\n+    private static final String KEY = \"CacheMarshallers\";\n+    private static final CacheMarshaller NO_OP_CACHE_MARSHALLER\n+        = new NoOpCacheMarshaller();\n+    private static final Localizer _loc =\n+        Localizer.forPackage(CacheMarshallersValue.class);\n+\n+    private Configuration _conf;\n+    private Map _marshallers;\n+    private boolean _initialized;\n+\n+    public CacheMarshallersValue(Configuration conf) {\n+        super(KEY);\n+        _conf = conf;\n+        setAlias(\"default\", CacheMarshallerImpl.class.getName());\n+        setAlias(\"none\", null);\n+        setDefault(\"none\");\n+        setString(\"none\");\n+        setScope(getClass());\n+    }\n+\n+    public Object instantiate(Class elemType, Configuration conf,\n+        boolean fatal) {\n+        CacheMarshaller[] ms = (CacheMarshaller[])\n+            super.instantiate(elemType, conf, fatal);\n+        if (ms != null) {\n+            _marshallers = new HashMap();\n+            for (int i = 0; i < ms.length; i++) {\n+                String mid = ms[i].getId();\n+                if (mid != null)\n+                    _marshallers.put(mid, ms[i]);\n+            }\n+        } else {\n+            _marshallers = null;\n+        }\n+        return ms;\n+    }\n+\n+    /**\n+     * Return the {@link CacheMarshaller} to use for caching metadata of id\n+     * <code>id</code>. If no marshaller exists for the id, returns\n+     * {@link NoOpCacheMarshaller}.\n+     */\n+    public CacheMarshaller getMarshallerById(String id) {\n+        initialize();\n+\n+        CacheMarshaller cm = (CacheMarshaller) _marshallers.get(id);\n+        if (cm == null) {\n+            if (getLog().isTraceEnabled())\n+                getLog().trace(_loc.get(\"cache-marshaller-not-found\", id));\n+            return NO_OP_CACHE_MARSHALLER;\n+        } else {\n+            if (getLog().isTraceEnabled())\n+                getLog().trace(_loc.get(\"cache-marshaller-found\", id,\n+                    cm.getClass().getName()));\n+            return cm;\n+        }\n+    }\n+\n+    private Log getLog() {\n+        return _conf.getConfigurationLog();\n+    }\n+\n+    /**\n+     * Return the {@link CacheMarshaller} to use for caching metadata of id\n+     * <code>id</code>. If no marshaller exists for the id, returns\n+     * {@link NoOpCacheMarshaller}.\n+     */\n+    public static CacheMarshaller getMarshallerById(Configuration c, String id){\n+        CacheMarshallersValue v =\n+            ((OpenJPAConfigurationImpl) c).cacheMarshallerPlugins;\n+        return v.getMarshallerById(id);\n+    }\n+\n+    public Map getInstancesAsMap() {\n+        return _marshallers;\n+    }\n+\n+    protected synchronized void initialize() {\n+        if (!_initialized) {\n+            instantiate(CacheMarshaller.class, _conf);\n+            _initialized = true;\n+        }\n+    }\n+}"},{"sha":"1ba0aef775679642613caabd9550cc6b54a0cf5f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","status":"modified","additions":52,"deletions":1,"changes":53,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/Compatibility.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -55,7 +55,9 @@\n     private boolean _nonOptimisticVersionCheck = false;\n     private int _jpql = JPQL_WARN;\n     private boolean _storeMapCollectionInEntityAsBlob = false;\n-    private boolean _flushBeforeDetach = true; \n+    private boolean _flushBeforeDetach = true;\n+    private boolean _reorderMetaDataResolution = false;\n+    private boolean _reloadOnDetach = true;\n \n     /**\n      * Whether to require exact identity value types when creating object\n@@ -268,5 +270,54 @@ public boolean getFlushBeforeDetach() {\n     public void setFlushBeforeDetach(boolean beforeDetach) {\n         _flushBeforeDetach = beforeDetach;\n     }\n+    \n+    \n+    /**\n+     * Whether OpenJPA should reorder entities in MetaDataRepository.processBuffer() to ensure that the MetaData for \n+     * entities with foreign keys in their identity are processed after the entities they depend on.\n+     * \n+     * @return true if the reordering should be performed, false if not.\n+     */\n+    public boolean getReorderMetaDataResolution() {\n+    \treturn _reorderMetaDataResolution;\n+    }\n+    \n+    /**\n+     * Whether OpenJPA should reorder entities in MetaDataRepository.processBuffer() to ensure that the MetaData for \n+     * entities with foreign keys in their identity are processed after the entities they depend on.\n+     * \n+     * @param reorderProcessBuffer true if the reordering should be performed, false if not.\n+     */\n+    public void setReorderMetaDataResolution(boolean reorderProcessBuffer) {\n+        _reorderMetaDataResolution = reorderProcessBuffer;\n+    }\n+\n+    /**\n+     * Whether OpenJPA should attempt to load fields when the DetachState\n+     * option is set to loaded. This also determines whether a\n+     * redundant copy of the version field is made. Defaults to true.\n+     * \n+     * @return the _reloadOnDetach\n+     * \n+     * @since 1.2.2\n+     */\n+    public boolean getReloadOnDetach() {\n+        return _reloadOnDetach;\n+    }\n+\n+    /**\n+     * Whether OpenJPA should attempt to load fields when the DetachState\n+     * option is set to loaded. This also determines whether a\n+     * redundant copy of the version field is made. Defaults to true.\n+     * \n+     * @param reloadOnDetach the _reloadOnDetach to set\n+     * \n+     * @since 1.2.2\n+     */\n+    public void setReloadOnDetach(boolean reloadOnDetach) {\n+        _reloadOnDetach = reloadOnDetach;\n+    }   \n+\n+    \n \n }"},{"sha":"854f1a64843d8521f52481bd35c43975ca4ce3db","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java","status":"modified","additions":202,"deletions":202,"changes":404,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataCacheMaintenance.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,202 +1,202 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.util.Collection;\r\n-import java.util.Iterator;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.kernel.Bootstrap;\r\n-import org.apache.openjpa.kernel.Broker;\r\n-import org.apache.openjpa.kernel.BrokerFactory;\r\n-import org.apache.openjpa.kernel.Query;\r\n-import org.apache.openjpa.lib.util.Options;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.conf.MapConfigurationProvider;\r\n-import org.apache.openjpa.lib.conf.ConfigurationProvider;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-import org.apache.openjpa.meta.QueryMetaData;\r\n-import org.apache.openjpa.meta.SequenceMetaData;\r\n-\r\n-/**\r\n- * Performs maintenance tasks on the metadata caches accessible via the\r\n- * {@link CacheMarshaller} architecture.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class MetaDataCacheMaintenance {\r\n-\r\n-    private final BrokerFactory factory;\r\n-    private final OpenJPAConfiguration conf;\r\n-    private final boolean devpath;\r\n-    private Log log;\r\n-\r\n-    public static void main(String[] args) {\r\n-        Options opts = new Options();\r\n-        args = opts.setFromCmdLine(args);\r\n-        boolean devpath = opts.getBooleanProperty(\"scanDevPath\", \"ScanDevPath\",\r\n-            true);\r\n-\r\n-        ConfigurationProvider cp = new MapConfigurationProvider(opts);\r\n-        BrokerFactory factory = Bootstrap.newBrokerFactory(cp, null);\r\n-        try {\r\n-            MetaDataCacheMaintenance maint = new MetaDataCacheMaintenance(\r\n-                factory, devpath);\r\n-\r\n-            if (args.length != 1) {\r\n-                usage();\r\n-                return;\r\n-            }\r\n-\r\n-            if (\"store\".equals(args[0]))\r\n-                maint.store();\r\n-            else if (\"dump\".equals(args[0]))\r\n-                maint.dump();\r\n-            else\r\n-                usage();\r\n-        } finally {\r\n-            factory.close();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @deprecated logging is routed to the logging system now.\r\n-     */\r\n-    public MetaDataCacheMaintenance(BrokerFactory factory, boolean devpath,\r\n-        boolean verbose) {\r\n-        this(factory, devpath);\r\n-    }\r\n-\r\n-    /**\r\n-     * @param factory The {@link BrokerFactory} for which cached metadata\r\n-     * should be built.\r\n-     * @param devpath Whether or not to scan the development environment paths\r\n-     * to find persistent types to store.\r\n-     */\r\n-    public MetaDataCacheMaintenance(BrokerFactory factory, boolean devpath) {\r\n-        this.factory = factory;\r\n-        this.conf = factory.getConfiguration();\r\n-        this.devpath = devpath;\r\n-        this.log = conf.getLog(OpenJPAConfiguration.LOG_TOOL);\r\n-    }\r\n-\r\n-    public void setLog(Log log) {\r\n-        this.log = log;\r\n-    }\r\n-\r\n-    private static int usage() {\r\n-        System.err.println(\"Usage: java MetaDataCacheMaintenance \" +\r\n-            \"[-scanDevPath t|f] [-<openjpa.PropertyName> value] store | dump\");\r\n-        return -1;\r\n-    }\r\n-\r\n-    /**\r\n-     * The metadata repository for the factory that this instance was\r\n-     * constructed with will be serialized, along with any query\r\n-     * compilations etc. that have been created for the factory.\r\n-     */\r\n-    public void store() {\r\n-        MetaDataRepository repos = conf.getMetaDataRepositoryInstance();\r\n-        repos.setSourceMode(MetaDataRepository.MODE_ALL);\r\n-        Collection types = repos.loadPersistentTypes(devpath, null);\r\n-        for (Iterator iter = types.iterator(); iter.hasNext(); )\r\n-            repos.getMetaData((Class) iter.next(), null, true);\r\n-\r\n-        loadQueries();\r\n-\r\n-        log.info(\"The following data will be stored: \");\r\n-        log(repos, conf.getQueryCompilationCacheInstance());\r\n-\r\n-        CacheMarshallersValue.getMarshallerById(conf, getClass().getName())\r\n-            .store(new Object[] {\r\n-                repos, conf.getQueryCompilationCacheInstance()\r\n-            });\r\n-    }\r\n-\r\n-    private void loadQueries() {\r\n-        Broker broker = factory.newBroker();\r\n-        try {\r\n-            QueryMetaData[] qmds =\r\n-                conf.getMetaDataRepositoryInstance().getQueryMetaDatas();\r\n-            for (int i = 0; i < qmds.length; i++)\r\n-                loadQuery(broker, qmds[i]);\r\n-        } finally {\r\n-            broker.close();\r\n-        }\r\n-    }\r\n-\r\n-    private void loadQuery(Broker broker, QueryMetaData qmd) {\r\n-        try {\r\n-            Query q = broker.newQuery(qmd.getLanguage(), null);\r\n-            qmd.setInto(q);\r\n-            q.compile();\r\n-        } catch (Exception e) {\r\n-            if (log.isTraceEnabled()) {\r\n-                log.warn(\"Skipping named query \" + qmd.getName() + \": \"\r\n-                    + e.getMessage(), e);\r\n-            } else {\r\n-                log.warn(\"Skipping named query \" + qmd.getName() + \": \"\r\n-                    + e.getMessage());\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void dump() {\r\n-        Object[] os = (Object[])\r\n-            CacheMarshallersValue.getMarshallerById(conf, getClass().getName())\r\n-            .load();\r\n-        if (os == null) {\r\n-            log.info(\"No cached data was found\");\r\n-            return;\r\n-        }\r\n-        MetaDataRepository repos = (MetaDataRepository) os[0];\r\n-        Map qcc = (Map) os[1];\r\n-\r\n-        log.info(\"The following data was found: \");\r\n-        log(repos, qcc);\r\n-    }\r\n-\r\n-    private void log(MetaDataRepository repos, Map qcc) {\r\n-        ClassMetaData[] metas = repos.getMetaDatas();\r\n-        log.info(\"  Types: \" + metas.length);\r\n-        if (log.isTraceEnabled())\r\n-            for (int i = 0; i < metas.length; i++)\r\n-                log.trace(\"    \" + metas[i].getDescribedType().getName());\r\n-\r\n-        QueryMetaData[] qmds = repos.getQueryMetaDatas();\r\n-        log.info(\"  Queries: \" + qmds.length);\r\n-        if (log.isTraceEnabled())\r\n-            for (int i = 0; i < qmds.length; i++)\r\n-                log.trace(\"    \" + qmds[i].getName() + \": \"\r\n-                    + qmds[i].getQueryString());\r\n-\r\n-        SequenceMetaData[] smds = repos.getSequenceMetaDatas();\r\n-        log.info(\"  Sequences: \" + smds.length);\r\n-        if (log.isTraceEnabled())\r\n-            for (int i = 0; i < smds.length; i++)\r\n-                log.trace(\"    \" + smds[i].getName());\r\n-\r\n-        log.info(\"  Compiled queries: \"\r\n-            + (qcc == null ? \"0\" : \"\" + qcc.size()));\r\n-        if (log.isTraceEnabled() && qcc != null)\r\n-            for (Iterator iter = qcc.keySet().iterator(); iter.hasNext(); )\r\n-                log.trace(\"    \" + iter.next());\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.openjpa.kernel.Bootstrap;\n+import org.apache.openjpa.kernel.Broker;\n+import org.apache.openjpa.kernel.BrokerFactory;\n+import org.apache.openjpa.kernel.Query;\n+import org.apache.openjpa.lib.util.Options;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.conf.MapConfigurationProvider;\n+import org.apache.openjpa.lib.conf.ConfigurationProvider;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.meta.QueryMetaData;\n+import org.apache.openjpa.meta.SequenceMetaData;\n+\n+/**\n+ * Performs maintenance tasks on the metadata caches accessible via the\n+ * {@link CacheMarshaller} architecture.\n+ *\n+ * @since 1.1.0\n+ */\n+public class MetaDataCacheMaintenance {\n+\n+    private final BrokerFactory factory;\n+    private final OpenJPAConfiguration conf;\n+    private final boolean devpath;\n+    private Log log;\n+\n+    public static void main(String[] args) {\n+        Options opts = new Options();\n+        args = opts.setFromCmdLine(args);\n+        boolean devpath = opts.getBooleanProperty(\"scanDevPath\", \"ScanDevPath\",\n+            true);\n+\n+        ConfigurationProvider cp = new MapConfigurationProvider(opts);\n+        BrokerFactory factory = Bootstrap.newBrokerFactory(cp, null);\n+        try {\n+            MetaDataCacheMaintenance maint = new MetaDataCacheMaintenance(\n+                factory, devpath);\n+\n+            if (args.length != 1) {\n+                usage();\n+                return;\n+            }\n+\n+            if (\"store\".equals(args[0]))\n+                maint.store();\n+            else if (\"dump\".equals(args[0]))\n+                maint.dump();\n+            else\n+                usage();\n+        } finally {\n+            factory.close();\n+        }\n+    }\n+\n+    /**\n+     * @deprecated logging is routed to the logging system now.\n+     */\n+    public MetaDataCacheMaintenance(BrokerFactory factory, boolean devpath,\n+        boolean verbose) {\n+        this(factory, devpath);\n+    }\n+\n+    /**\n+     * @param factory The {@link BrokerFactory} for which cached metadata\n+     * should be built.\n+     * @param devpath Whether or not to scan the development environment paths\n+     * to find persistent types to store.\n+     */\n+    public MetaDataCacheMaintenance(BrokerFactory factory, boolean devpath) {\n+        this.factory = factory;\n+        this.conf = factory.getConfiguration();\n+        this.devpath = devpath;\n+        this.log = conf.getLog(OpenJPAConfiguration.LOG_TOOL);\n+    }\n+\n+    public void setLog(Log log) {\n+        this.log = log;\n+    }\n+\n+    private static int usage() {\n+        System.err.println(\"Usage: java MetaDataCacheMaintenance \" +\n+            \"[-scanDevPath t|f] [-<openjpa.PropertyName> value] store | dump\");\n+        return -1;\n+    }\n+\n+    /**\n+     * The metadata repository for the factory that this instance was\n+     * constructed with will be serialized, along with any query\n+     * compilations etc. that have been created for the factory.\n+     */\n+    public void store() {\n+        MetaDataRepository repos = conf.getMetaDataRepositoryInstance();\n+        repos.setSourceMode(MetaDataRepository.MODE_ALL);\n+        Collection types = repos.loadPersistentTypes(devpath, null);\n+        for (Iterator iter = types.iterator(); iter.hasNext(); )\n+            repos.getMetaData((Class) iter.next(), null, true);\n+\n+        loadQueries();\n+\n+        log.info(\"The following data will be stored: \");\n+        log(repos, conf.getQueryCompilationCacheInstance());\n+\n+        CacheMarshallersValue.getMarshallerById(conf, getClass().getName())\n+            .store(new Object[] {\n+                repos, conf.getQueryCompilationCacheInstance()\n+            });\n+    }\n+\n+    private void loadQueries() {\n+        Broker broker = factory.newBroker();\n+        try {\n+            QueryMetaData[] qmds =\n+                conf.getMetaDataRepositoryInstance().getQueryMetaDatas();\n+            for (int i = 0; i < qmds.length; i++)\n+                loadQuery(broker, qmds[i]);\n+        } finally {\n+            broker.close();\n+        }\n+    }\n+\n+    private void loadQuery(Broker broker, QueryMetaData qmd) {\n+        try {\n+            Query q = broker.newQuery(qmd.getLanguage(), null);\n+            qmd.setInto(q);\n+            q.compile();\n+        } catch (Exception e) {\n+            if (log.isTraceEnabled()) {\n+                log.warn(\"Skipping named query \" + qmd.getName() + \": \"\n+                    + e.getMessage(), e);\n+            } else {\n+                log.warn(\"Skipping named query \" + qmd.getName() + \": \"\n+                    + e.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void dump() {\n+        Object[] os = (Object[])\n+            CacheMarshallersValue.getMarshallerById(conf, getClass().getName())\n+            .load();\n+        if (os == null) {\n+            log.info(\"No cached data was found\");\n+            return;\n+        }\n+        MetaDataRepository repos = (MetaDataRepository) os[0];\n+        Map qcc = (Map) os[1];\n+\n+        log.info(\"The following data was found: \");\n+        log(repos, qcc);\n+    }\n+\n+    private void log(MetaDataRepository repos, Map qcc) {\n+        ClassMetaData[] metas = repos.getMetaDatas();\n+        log.info(\"  Types: \" + metas.length);\n+        if (log.isTraceEnabled())\n+            for (int i = 0; i < metas.length; i++)\n+                log.trace(\"    \" + metas[i].getDescribedType().getName());\n+\n+        QueryMetaData[] qmds = repos.getQueryMetaDatas();\n+        log.info(\"  Queries: \" + qmds.length);\n+        if (log.isTraceEnabled())\n+            for (int i = 0; i < qmds.length; i++)\n+                log.trace(\"    \" + qmds[i].getName() + \": \"\n+                    + qmds[i].getQueryString());\n+\n+        SequenceMetaData[] smds = repos.getSequenceMetaDatas();\n+        log.info(\"  Sequences: \" + smds.length);\n+        if (log.isTraceEnabled())\n+            for (int i = 0; i < smds.length; i++)\n+                log.trace(\"    \" + smds[i].getName());\n+\n+        log.info(\"  Compiled queries: \"\n+            + (qcc == null ? \"0\" : \"\" + qcc.size()));\n+        if (log.isTraceEnabled() && qcc != null)\n+            for (Iterator iter = qcc.keySet().iterator(); iter.hasNext(); )\n+                log.trace(\"    \" + iter.next());\n+    }\n+}"},{"sha":"c027a5271c0d1b73161c75f08a698830accbc227","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","status":"modified","additions":74,"deletions":74,"changes":148,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/MetaDataRepositoryValue.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,74 +1,74 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.conf.PluginValue;\r\n-import org.apache.openjpa.conf.CacheMarshallersValue;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-\r\n-/**\r\n- * A {@link PluginValue} that interacts with the {@link CacheMarshaller}\r\n- * to cache the metadata repository between executions.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class MetaDataRepositoryValue\r\n-    extends PluginValue {\r\n-\r\n-    private static final String KEY = \"MetaDataRepository\";\r\n-\r\n-    public MetaDataRepositoryValue() {\r\n-        super(KEY, false);\r\n-        String[] aliases = new String[] {\r\n-            \"default\",\r\n-            MetaDataRepository.class.getName()\r\n-        };\r\n-        setAliases(aliases);\r\n-        setDefault(aliases[0]);\r\n-        setString(aliases[0]);\r\n-    }\r\n-\r\n-    public Object instantiate(Class type, Configuration c, boolean fatal) {\r\n-        MetaDataRepository repos = null;\r\n-        OpenJPAConfiguration conf = (OpenJPAConfiguration) c;\r\n-\r\n-        Object[] os = (Object[]) CacheMarshallersValue.getMarshallerById(\r\n-            conf, MetaDataCacheMaintenance.class.getName())\r\n-            .load();\r\n-        if (os != null) {\r\n-            repos = (MetaDataRepository) os[0];\r\n-            if (os[1] != null)\r\n-                // It's a bit odd that we do this in MetaDataRepositoryValue.\r\n-                // We need to serialize all the various bits of configuration\r\n-                // together; maybe we can move the caching logic somewhere\r\n-                // else?\r\n-                conf.getQueryCompilationCacheInstance().putAll((Map) os[1]);\r\n-        }\r\n-\r\n-        if (repos == null)\r\n-            return super.instantiate(type, c, fatal);\r\n-        else\r\n-            return repos;\r\n-    }\r\n-\r\n-\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import org.apache.openjpa.conf.CacheMarshallersValue;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+\n+/**\n+ * A {@link PluginValue} that interacts with the {@link CacheMarshaller}\n+ * to cache the metadata repository between executions.\n+ *\n+ * @since 1.1.0\n+ */\n+public class MetaDataRepositoryValue\n+    extends PluginValue {\n+\n+    private static final String KEY = \"MetaDataRepository\";\n+\n+    public MetaDataRepositoryValue() {\n+        super(KEY, false);\n+        String[] aliases = new String[] {\n+            \"default\",\n+            MetaDataRepository.class.getName()\n+        };\n+        setAliases(aliases);\n+        setDefault(aliases[0]);\n+        setString(aliases[0]);\n+    }\n+\n+    public Object instantiate(Class type, Configuration c, boolean fatal) {\n+        MetaDataRepository repos = null;\n+        OpenJPAConfiguration conf = (OpenJPAConfiguration) c;\n+\n+        Object[] os = (Object[]) CacheMarshallersValue.getMarshallerById(\n+            conf, MetaDataCacheMaintenance.class.getName())\n+            .load();\n+        if (os != null) {\n+            repos = (MetaDataRepository) os[0];\n+            if (os[1] != null)\n+                // It's a bit odd that we do this in MetaDataRepositoryValue.\n+                // We need to serialize all the various bits of configuration\n+                // together; maybe we can move the caching logic somewhere\n+                // else?\n+                conf.getQueryCompilationCacheInstance().putAll((Map) os[1]);\n+        }\n+\n+        if (repos == null)\n+            return super.instantiate(type, c, fatal);\n+        else\n+            return repos;\n+    }\n+\n+\n+}"},{"sha":"3413add2a563d0da4016caef5419766c0a5bd10f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java","status":"modified","additions":48,"deletions":48,"changes":96,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/NoOpCacheMarshaller.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,48 +1,48 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-/**\r\n- * Implementation of {@link CacheMarshaller} that does nothing.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class NoOpCacheMarshaller\r\n-    implements CacheMarshaller {\r\n-\r\n-    private String id;\r\n-\r\n-    public Object load() {\r\n-        return null;\r\n-    }\r\n-\r\n-    public void setId(String id) {\r\n-        this.id = id;\r\n-    }\r\n-\r\n-    public String getId() {\r\n-        return id;\r\n-    }\r\n-\r\n-    public void setValidationPolicy(String policy) {\r\n-    }\r\n-\r\n-    public void store(Object o) {\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+/**\n+ * Implementation of {@link CacheMarshaller} that does nothing.\n+ *\n+ * @since 1.1.0\n+ */\n+public class NoOpCacheMarshaller\n+    implements CacheMarshaller {\n+\n+    private String id;\n+\n+    public Object load() {\n+        return null;\n+    }\n+\n+    public void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public void setValidationPolicy(String policy) {\n+    }\n+\n+    public void store(Object o) {\n+    }\n+}"},{"sha":"218ae07b52688ec7027f1e54adb2eeabff3c8012","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAConfigurationImpl.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -126,7 +126,7 @@\n     public BooleanValue multithreaded;\n     public StringValue mapping;\n     public PluginValue metaFactoryPlugin;\n-    public ObjectValue metaRepositoryPlugin;\n+    public MetaDataRepositoryValue metaRepositoryPlugin;\n     public ObjectValue lockManagerPlugin;\n     public ObjectValue inverseManagerPlugin;\n     public ObjectValue savepointManagerPlugin;\n@@ -303,7 +303,7 @@ public OpenJPAConfigurationImpl(boolean derivations, boolean loadGlobals) {\n         mapping = addString(\"Mapping\");\n         metaFactoryPlugin = addPlugin(\"MetaDataFactory\", false);\n \n-        metaRepositoryPlugin = (ObjectValue)\n+        metaRepositoryPlugin = (MetaDataRepositoryValue)\n             addValue(new MetaDataRepositoryValue());\n \n         connectionFactory = addObject(\"ConnectionFactory\");"},{"sha":"a8e5bb124bc013c11c3e4a2172f39148dd737a23","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","status":"modified","additions":43,"deletions":43,"changes":86,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAProductDerivation.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,43 +1,43 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import org.apache.openjpa.lib.conf.ProductDerivation;\r\n-import java.util.Map;\r\n-\r\n-/**\r\n- * Adds datastore based extension to ProductDerivation.  \r\n- *\r\n- * @since 0.4.1\r\n- * @author Pinaki Poddar\r\n- */\r\n-public interface OpenJPAProductDerivation extends ProductDerivation {\r\n-\r\n-    public static final int TYPE_SPEC = 0;\r\n-    public static final int TYPE_STORE = 200;\r\n-    public static final int TYPE_SPEC_STORE = 300;\r\n-    public static final int TYPE_PRODUCT_STORE = 400;\r\n-\r\n-    /**\r\n-     * Load default alias options into the given map.  Each entry maps an\r\n-     * alias to a broker factory class name.  Replace anything previously \r\n-     * under the desired keys.\r\n-     */\r\n-    public void putBrokerFactoryAliases(Map aliases);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.conf;\n+\n+import org.apache.openjpa.lib.conf.ProductDerivation;\n+import java.util.Map;\n+\n+/**\n+ * Adds datastore based extension to ProductDerivation.  \n+ *\n+ * @since 0.4.1\n+ * @author Pinaki Poddar\n+ */\n+public interface OpenJPAProductDerivation extends ProductDerivation {\n+\n+    public static final int TYPE_SPEC = 0;\n+    public static final int TYPE_STORE = 200;\n+    public static final int TYPE_SPEC_STORE = 300;\n+    public static final int TYPE_PRODUCT_STORE = 400;\n+\n+    /**\n+     * Load default alias options into the given map.  Each entry maps an\n+     * alias to a broker factory class name.  Replace anything previously \n+     * under the desired keys.\n+     */\n+    public void putBrokerFactoryAliases(Map aliases);\n+}"},{"sha":"df3cd84bdb3baa1fd3f379059a7954cd65cc11aa","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersionAndConfigurationTypeValidationPolicy.java","status":"modified","additions":66,"deletions":66,"changes":132,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersionAndConfigurationTypeValidationPolicy.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersionAndConfigurationTypeValidationPolicy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/OpenJPAVersionAndConfigurationTypeValidationPolicy.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,66 +1,66 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import org.apache.openjpa.conf.CacheMarshaller.ValidationPolicy;\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-\r\n-/**\r\n- * Compute validity based on whether or not the cached data is from the same\r\n- * version of Kodo as the current install. This also checks OpenJPA version\r\n- * information in case the OpenJPA jars were independently updated.\r\n- *\r\n- * @since 1.1.0\r\n- */\r\n-public class OpenJPAVersionAndConfigurationTypeValidationPolicy\r\n-    implements ValidationPolicy, Configurable {\r\n-\r\n-    private String confClassName;\r\n-\r\n-    public Object getCacheableData(Object o) {\r\n-        return new Object[] {\r\n-            OpenJPAVersion.VERSION_ID,\r\n-            confClassName,\r\n-            o,\r\n-        };\r\n-    }\r\n-\r\n-    public Object getValidData(Object o) {\r\n-        Object[] array = (Object[]) o;\r\n-        if (array.length != 3)\r\n-            return null;\r\n-\r\n-        if (OpenJPAVersion.VERSION_ID.equals(array[0])\r\n-            && confClassName.equals(array[1]))\r\n-            return array[2];\r\n-        else\r\n-            return null;\r\n-    }\r\n-\r\n-    public void setConfiguration(Configuration conf) {\r\n-        confClassName = conf.getClass().getName();\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.conf;\n+\n+import org.apache.openjpa.conf.CacheMarshaller.ValidationPolicy;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+\n+/**\n+ * Compute validity based on whether or not the cached data is from the same\n+ * version of Kodo as the current install. This also checks OpenJPA version\n+ * information in case the OpenJPA jars were independently updated.\n+ *\n+ * @since 1.1.0\n+ */\n+public class OpenJPAVersionAndConfigurationTypeValidationPolicy\n+    implements ValidationPolicy, Configurable {\n+\n+    private String confClassName;\n+\n+    public Object getCacheableData(Object o) {\n+        return new Object[] {\n+            OpenJPAVersion.VERSION_ID,\n+            confClassName,\n+            o,\n+        };\n+    }\n+\n+    public Object getValidData(Object o) {\n+        Object[] array = (Object[]) o;\n+        if (array.length != 3)\n+            return null;\n+\n+        if (OpenJPAVersion.VERSION_ID.equals(array[0])\n+            && confClassName.equals(array[1]))\n+            return array[2];\n+        else\n+            return null;\n+    }\n+\n+    public void setConfiguration(Configuration conf) {\n+        confClassName = conf.getClass().getName();\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+    }\n+}"},{"sha":"c7546b4abe705c72f28028ba71ef505054f02860","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","status":"modified","additions":95,"deletions":95,"changes":190,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/conf/QueryCompilationCacheValue.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,95 +1,95 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.conf;\r\n-\r\n-import java.util.Collections;\r\n-import java.util.Hashtable;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.conf.PluginValue;\r\n-import java.util.concurrent.ConcurrentHashMap;\r\n-import org.apache.openjpa.lib.util.ParseException;\r\n-import org.apache.openjpa.util.CacheMap;\r\n-\r\n-/**\r\n- * A cache of compiled queries.\r\n- *\r\n- * @author Abe White\r\n- * @since 0.9.6 (also existed in prior versions of Kodo)\r\n- * @nojavadoc\r\n- */\r\n-public class QueryCompilationCacheValue\r\n-    extends PluginValue {\r\n-\r\n-    public static final String[] ALIASES = {\r\n-        \"true\", CacheMap.class.getName(),\r\n-        \"all\", ConcurrentHashMap.class.getName(),\r\n-        \"false\", null,\r\n-    };\r\n-\r\n-    public QueryCompilationCacheValue(String prop) {\r\n-        super(prop, true);\r\n-        setAliases(ALIASES);\r\n-        setDefault(ALIASES[0]);\r\n-        setClassName(ALIASES[1]);\r\n-    }\r\n-\r\n-    public Object newInstance(String clsName, Class type,\r\n-        Configuration conf, boolean fatal) {\r\n-        // make sure map handles concurrency\r\n-        Map map;\r\n-        \r\n-        try {\r\n-            map = (Map) super.newInstance(clsName, type, conf, fatal);\r\n-        } catch (ParseException pe) {\r\n-            // OPENJPA256: this class differs from most plugins in that\r\n-            // the plugin type is the standard java interface Map.class (rather\r\n-            // than an openjpa-specific interface), which means that the\r\n-            // ClassLoader used to load the implementation will be the system\r\n-            // class loader; this presents a problem if OpenJPA is not in the\r\n-            // system classpath, so work around the problem by catching\r\n-            // the ParseException (which is what we wrap the\r\n-            // ClassNotFoundException in) and try again, this time using\r\n-            // this class' ClassLoader.\r\n-            map = (Map) super.newInstance(clsName,\r\n-                QueryCompilationCacheValue.class, conf, fatal);\r\n-        } catch (IllegalArgumentException iae) {\r\n-            // OPENJPA256: this class differs from most plugins in that\r\n-            // the plugin type is the standard java interface Map.class (rather\r\n-            // than an openjpa-specific interface), which means that the\r\n-            // ClassLoader used to load the implementation will be the system\r\n-            // class loader; this presents a problem if OpenJPA is not in the\r\n-            // system classpath, so work around the problem by catching\r\n-            // the IllegalArgumentException (which is what we wrap the\r\n-            // ClassNotFoundException in) and try again, this time using\r\n-            // this class' ClassLoader.\r\n-            map = (Map) super.newInstance(clsName,\r\n-                QueryCompilationCacheValue.class, conf, fatal);\r\n-        }\r\n-\r\n-        if (map != null && !(map instanceof Hashtable)\r\n-            && !(map instanceof CacheMap)\r\n-            && !(map instanceof\r\n-                    org.apache.openjpa.lib.util.concurrent.ConcurrentMap)\r\n-            && !(map instanceof java.util.concurrent.ConcurrentMap))\r\n-            map = Collections.synchronizedMap(map);\r\n-        return map;\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.conf;\n+\n+import java.util.Collections;\n+import java.util.Hashtable;\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.conf.PluginValue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.openjpa.lib.util.ParseException;\n+import org.apache.openjpa.util.CacheMap;\n+\n+/**\n+ * A cache of compiled queries.\n+ *\n+ * @author Abe White\n+ * @since 0.9.6 (also existed in prior versions of Kodo)\n+ * @nojavadoc\n+ */\n+public class QueryCompilationCacheValue\n+    extends PluginValue {\n+\n+    public static final String[] ALIASES = {\n+        \"true\", CacheMap.class.getName(),\n+        \"all\", ConcurrentHashMap.class.getName(),\n+        \"false\", null,\n+    };\n+\n+    public QueryCompilationCacheValue(String prop) {\n+        super(prop, true);\n+        setAliases(ALIASES);\n+        setDefault(ALIASES[0]);\n+        setClassName(ALIASES[1]);\n+    }\n+\n+    public Object newInstance(String clsName, Class type,\n+        Configuration conf, boolean fatal) {\n+        // make sure map handles concurrency\n+        Map map;\n+        \n+        try {\n+            map = (Map) super.newInstance(clsName, type, conf, fatal);\n+        } catch (ParseException pe) {\n+            // OPENJPA256: this class differs from most plugins in that\n+            // the plugin type is the standard java interface Map.class (rather\n+            // than an openjpa-specific interface), which means that the\n+            // ClassLoader used to load the implementation will be the system\n+            // class loader; this presents a problem if OpenJPA is not in the\n+            // system classpath, so work around the problem by catching\n+            // the ParseException (which is what we wrap the\n+            // ClassNotFoundException in) and try again, this time using\n+            // this class' ClassLoader.\n+            map = (Map) super.newInstance(clsName,\n+                QueryCompilationCacheValue.class, conf, fatal);\n+        } catch (IllegalArgumentException iae) {\n+            // OPENJPA256: this class differs from most plugins in that\n+            // the plugin type is the standard java interface Map.class (rather\n+            // than an openjpa-specific interface), which means that the\n+            // ClassLoader used to load the implementation will be the system\n+            // class loader; this presents a problem if OpenJPA is not in the\n+            // system classpath, so work around the problem by catching\n+            // the IllegalArgumentException (which is what we wrap the\n+            // ClassNotFoundException in) and try again, this time using\n+            // this class' ClassLoader.\n+            map = (Map) super.newInstance(clsName,\n+                QueryCompilationCacheValue.class, conf, fatal);\n+        }\n+\n+        if (map != null && !(map instanceof Hashtable)\n+            && !(map instanceof CacheMap)\n+            && !(map instanceof\n+                    org.apache.openjpa.lib.util.concurrent.ConcurrentMap)\n+            && !(map instanceof java.util.concurrent.ConcurrentMap))\n+            map = Collections.synchronizedMap(map);\n+        return map;\n+\t}\n+}"},{"sha":"1627d11afbb839732ecedbba7d1645a9997f9823","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","status":"modified","additions":492,"deletions":455,"changes":947,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractDataCache.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,455 +1,492 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.BitSet;\r\n-import java.util.Collection;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.event.RemoteCommitEvent;\r\n-import org.apache.openjpa.event.RemoteCommitListener;\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\r\n-\r\n-/**\r\n- * Abstract {@link DataCache} implementation that provides various\r\n- * statistics, logging, and timeout functionality common across cache\r\n- * implementations.\r\n- *\r\n- * @author Patrick Linskey\r\n- * @author Abe White\r\n- */\r\n-public abstract class AbstractDataCache\r\n-    extends AbstractConcurrentEventManager\r\n-    implements DataCache, Configurable {\r\n-\r\n-    private static final BitSet EMPTY_BITSET = new BitSet(0);\r\n-\r\n-    private static final Localizer s_loc =\r\n-        Localizer.forPackage(AbstractDataCache.class);\r\n-\r\n-    /**\r\n-     * The configuration set by the system.\r\n-     */\r\n-    protected OpenJPAConfiguration conf;\r\n-\r\n-    /**\r\n-     * The log to use.\r\n-     */\r\n-    protected Log log;\r\n-\r\n-    private String _name = null;\r\n-    private boolean _closed = false;\r\n-    private String _schedule = null;\r\n-\r\n-    public String getName() {\r\n-        return _name;\r\n-    }\r\n-\r\n-    public void setName(String name) {\r\n-        _name = name;\r\n-    }\r\n-\r\n-    public String getEvictionSchedule() {\r\n-        return _schedule;\r\n-    }\r\n-\r\n-    public void setEvictionSchedule(String s) {\r\n-        _schedule = s;\r\n-    }\r\n-\r\n-    public void initialize(DataCacheManager manager) {\r\n-        if (_schedule != null && !\"\".equals(_schedule)) {\r\n-            DataCacheScheduler scheduler = manager.getDataCacheScheduler();\r\n-            if (scheduler != null)\r\n-                scheduler.scheduleEviction(this, _schedule);\r\n-        }\r\n-    }\r\n-\r\n-    public void commit(Collection additions, Collection newUpdates,\r\n-        Collection existingUpdates, Collection deletes) {\r\n-        // remove all objects in deletes list\r\n-        removeAllInternal(deletes);\r\n-\r\n-        // next, add all the new additions\r\n-        putAllInternal(additions);\r\n-        putAllInternal(newUpdates);\r\n-\r\n-        // possibly add the existing updates, depending on the\r\n-        // semantics of the cache, as dictated by recacheUpdates()\r\n-        if (recacheUpdates())\r\n-            putAllInternal(existingUpdates);\r\n-\r\n-        if (log.isTraceEnabled()) {\r\n-            Collection addIds = new ArrayList(additions.size());\r\n-            Collection upIds = new ArrayList(newUpdates.size());\r\n-            Collection exIds = new ArrayList(existingUpdates.size());\r\n-\r\n-            for (Iterator iter = additions.iterator(); iter.hasNext();)\r\n-                addIds.add(((DataCachePCData) iter.next()).getId());\r\n-            for (Iterator iter = newUpdates.iterator(); iter.hasNext();)\r\n-                upIds.add(((DataCachePCData) iter.next()).getId());\r\n-            for (Iterator iter = existingUpdates.iterator(); iter.hasNext();)\r\n-                exIds.add(((DataCachePCData) iter.next()).getId());\r\n-\r\n-            log.trace(s_loc.get(\"cache-commit\",\r\n-                new Object[]{ addIds, upIds, exIds, deletes }));\r\n-        }\r\n-    }\r\n-\r\n-    public boolean contains(Object key) {\r\n-        DataCachePCData o = getInternal(key);\r\n-        if (o != null && o.isTimedOut()) {\r\n-            o = null;\r\n-            removeInternal(key);\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(s_loc.get(\"cache-timeout\", key));\r\n-        }\r\n-        return o != null;\r\n-    }\r\n-\r\n-    public BitSet containsAll(Collection keys) {\r\n-        if (keys.isEmpty())\r\n-            return EMPTY_BITSET;\r\n-\r\n-        BitSet set = new BitSet(keys.size());\r\n-        int i = 0;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n-            if (contains(iter.next()))\r\n-                set.set(i);\r\n-        return set;\r\n-    }\r\n-\r\n-    public DataCachePCData get(Object key) {\r\n-        DataCachePCData o = getInternal(key);\r\n-        if (o != null && o.isTimedOut()) {\r\n-            o = null;\r\n-            removeInternal(key);\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(s_loc.get(\"cache-timeout\", key));\r\n-        }\r\n-\r\n-        if (log.isTraceEnabled()) {\r\n-            if (o == null)\r\n-                log.trace(s_loc.get(\"cache-miss\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-hit\", key));\r\n-        }\r\n-\r\n-        return o;\r\n-    }\r\n-\r\n-    public DataCachePCData put(DataCachePCData data) {\r\n-        DataCachePCData o = putInternal(data.getId(), data);\r\n-        if (log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-put\", data.getId()));\r\n-        return (o == null || o.isTimedOut()) ? null : o;\r\n-    }\r\n-\r\n-    public void update(DataCachePCData data) {\r\n-        if (recacheUpdates())\r\n-            putInternal(data.getId(), data);\r\n-    }\r\n-\r\n-    public DataCachePCData remove(Object key) {\r\n-        DataCachePCData o = removeInternal(key);\r\n-        if (o != null && o.isTimedOut())\r\n-            o = null;\r\n-        if (log.isTraceEnabled()) {\r\n-            if (o == null)\r\n-                log.trace(s_loc.get(\"cache-remove-miss\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-remove-hit\", key));\r\n-        }\r\n-        return o;\r\n-    }\r\n-\r\n-    public BitSet removeAll(Collection keys) {\r\n-        if (keys.isEmpty())\r\n-            return EMPTY_BITSET;\r\n-\r\n-        BitSet set = new BitSet(keys.size());\r\n-        int i = 0;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n-            if (remove(iter.next()) != null)\r\n-                set.set(i);\r\n-        return set;\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove the objects of the given class from the cache.\r\n-     */\r\n-    public void removeAll(Class cls, boolean subClasses) {\r\n-        removeAllInternal(cls, subClasses);\r\n-    }\r\n-\r\n-    public boolean pin(Object key) {\r\n-        boolean bool = pinInternal(key);\r\n-        if (log.isTraceEnabled()) {\r\n-            if (bool)\r\n-                log.trace(s_loc.get(\"cache-pin-hit\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-pin-miss\", key));\r\n-        }\r\n-        return bool;\r\n-    }\r\n-\r\n-    public BitSet pinAll(Collection keys) {\r\n-        if (keys.isEmpty())\r\n-            return EMPTY_BITSET;\r\n-\r\n-        BitSet set = new BitSet(keys.size());\r\n-        int i = 0;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n-            if (pin(iter.next()))\r\n-                set.set(i);\r\n-        return set;\r\n-    }\r\n-\r\n-    public void pinAll(Class cls, boolean subs) {\r\n-        if (log.isWarnEnabled())\r\n-            log.warn(s_loc.get(\"cache-class-pin\", getName()));\r\n-    }\r\n-\r\n-    public boolean unpin(Object key) {\r\n-        boolean bool = unpinInternal(key);\r\n-        if (log.isTraceEnabled()) {\r\n-            if (bool)\r\n-                log.trace(s_loc.get(\"cache-unpin-hit\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-unpin-miss\", key));\r\n-        }\r\n-        return bool;\r\n-    }\r\n-\r\n-    public BitSet unpinAll(Collection keys) {\r\n-        if (keys.isEmpty())\r\n-            return EMPTY_BITSET;\r\n-\r\n-        BitSet set = new BitSet(keys.size());\r\n-        int i = 0;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\r\n-            if (unpin(iter.next()))\r\n-                set.set(i);\r\n-        return set;\r\n-    }\r\n-\r\n-    public void unpinAll(Class cls, boolean subs) {\r\n-        if (log.isWarnEnabled())\r\n-            log.warn(s_loc.get(\"cache-class-unpin\", getName()));\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        clearInternal();\r\n-        if (log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-clear\", getName()));\r\n-    }\r\n-\r\n-    public void close() {\r\n-        close(true);\r\n-    }\r\n-\r\n-    protected void close(boolean clear) {\r\n-        if (!_closed) {\r\n-            if (clear)\r\n-                clearInternal();\r\n-            _closed = true;\r\n-        }\r\n-    }\r\n-\r\n-    public boolean isClosed() {\r\n-        return _closed;\r\n-    }\r\n-\r\n-    public void addExpirationListener(ExpirationListener listen) {\r\n-        addListener(listen);\r\n-    }\r\n-\r\n-    public boolean removeExpirationListener(ExpirationListener listen) {\r\n-        return removeListener(listen);\r\n-    }\r\n-\r\n-    public String toString() {\r\n-        return \"[\" + super.toString() + \":\" + _name + \"]\";\r\n-    }\r\n-\r\n-    /**\r\n-     * This method is part of the {@link RemoteCommitListener} interface. If\r\n-     * your cache subclass relies on OpenJPA for clustering support, make it\r\n-     * implement <code>RemoteCommitListener</code>. This method will take\r\n-     * care of invalidating entries from remote commits.\r\n-     */\r\n-    public void afterCommit(RemoteCommitEvent event) {\r\n-        if (_closed)\r\n-            return;\r\n-\r\n-        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\r\n-            removeAllTypeNamesInternal(event.getUpdatedTypeNames());\r\n-            removeAllTypeNamesInternal(event.getDeletedTypeNames());\r\n-        } else {\r\n-            // drop all the committed OIDs, excepting brand\r\n-            // new OIDs. brand new OIDs either won't be in\r\n-            // the cache, or if they are, will be more up to date\r\n-            removeAllInternal(event.getUpdatedObjectIds());\r\n-            removeAllInternal(event.getDeletedObjectIds());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Invoke when a key is removed from this cache. Propagates the\r\n-     * expiration event on to all expiration listeners registered\r\n-     * with this class.\r\n-     */\r\n-    protected void keyRemoved(Object key, boolean expired) {\r\n-        // Notify any expiration listeners of the expiration.\r\n-        if (hasListeners())\r\n-            fireEvent(new ExpirationEvent(this, key, expired));\r\n-\r\n-        if (expired && log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-expired\", key));\r\n-    }\r\n-\r\n-    /**\r\n-     * Return <code>true</code> if updates to data already in the\r\n-     * cache (either in {@link #commit} or the {@link #update})\r\n-     * should be put back into the cache. Returns false by default.\r\n-     */\r\n-    protected boolean recacheUpdates() {\r\n-        return false;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the object for the given oid.\r\n-     */\r\n-    protected abstract DataCachePCData getInternal(Object oid);\r\n-\r\n-    /**\r\n-     * Add the given object to the cache, returning the old object under the\r\n-     * given oid.\r\n-     */\r\n-    protected abstract DataCachePCData putInternal(Object oid,\r\n-        DataCachePCData pc);\r\n-\r\n-    /**\r\n-     * All all of the given objects to the cache.\r\n-     */\r\n-    protected void putAllInternal(Collection pcs) {\r\n-        DataCachePCData pc;\r\n-        for (Iterator iter = pcs.iterator(); iter.hasNext();) {\r\n-            pc = (DataCachePCData) iter.next();\r\n-            putInternal(pc.getId(), pc);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove the object under the given oid from the cache.\r\n-     */\r\n-    protected abstract DataCachePCData removeInternal(Object oid);\r\n-\r\n-    /**\r\n-     * Evict objects in cache by class.\r\n-     */\r\n-    protected abstract void removeAllInternal(Class cls, boolean subclasses);\r\n-\r\n-    /**\r\n-     * Remove all objects under the given oids from the cache.\r\n-     */\r\n-    protected void removeAllInternal(Collection oids) {\r\n-        for (Iterator iter = oids.iterator(); iter.hasNext();)\r\n-            removeInternal(iter.next());\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove all objects of the given class names from the cache.\r\n-     */\r\n-    protected void removeAllTypeNamesInternal(Collection classNames) {\r\n-        Collection classes = Caches.addTypesByName(conf, classNames, null);\r\n-        if (classes == null)\r\n-            return;\r\n-\r\n-        Class cls;\r\n-        for (Iterator iter = classes.iterator(); iter.hasNext();) {\r\n-            cls = (Class) iter.next();\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(s_loc.get(\"cache-removeclass\", cls.getName()));\r\n-            removeAllInternal(cls, false);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Clear the cache.\r\n-     */\r\n-    protected abstract void clearInternal();\r\n-\r\n-    /**\r\n-     * Pin an object to the cache.\r\n-     */\r\n-    protected abstract boolean pinInternal(Object oid);\r\n-\r\n-    /**\r\n-     * Unpin an object from the cache.\r\n-     */\r\n-    protected abstract boolean unpinInternal(Object oid);\r\n-\r\n-    // ---------- Configurable implementation ----------\r\n-\r\n-    public void setConfiguration(Configuration conf) {\r\n-        this.conf = (OpenJPAConfiguration) conf;\r\n-        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-        if (_name == null)\r\n-            setName(NAME_DEFAULT);\r\n-    }\r\n-\r\n-    // ---------- AbstractEventManager implementation ----------\r\n-\r\n-    protected void fireEvent(Object event, Object listener) {\r\n-        ExpirationListener listen = (ExpirationListener) listener;\r\n-        ExpirationEvent ev = (ExpirationEvent) event;\r\n-        try {\r\n-            listen.onExpire(ev);\r\n-        } catch (Exception e) {\r\n-            if (log.isWarnEnabled())\r\n-                log.warn(s_loc.get(\"exp-listener-ex\"), e);\r\n-\t\t}\r\n-\t}\r\n-\r\n-    /**\r\n-     * Returns the objects for the given key List.\r\n-     */\r\n-    public Map getAll(List keys) {\r\n-        Map resultMap = new HashMap(keys.size());\r\n-        for(int i=0; i<keys.size(); i++)\r\n-            resultMap.put(keys.get(i), get(keys.get(i)));\r\n-        return resultMap;\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.event.RemoteCommitEvent;\n+import org.apache.openjpa.event.RemoteCommitListener;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\n+\n+import serp.util.Strings;\n+\n+/**\n+ * Abstract {@link DataCache} implementation that provides various\n+ * statistics, logging, and timeout functionality common across cache\n+ * implementations.\n+ *\n+ * @author Patrick Linskey\n+ * @author Abe White\n+ */\n+public abstract class AbstractDataCache\n+    extends AbstractConcurrentEventManager\n+    implements DataCache, Configurable {\n+\n+    private static final BitSet EMPTY_BITSET = new BitSet(0);\n+\n+    private static final Localizer s_loc =\n+        Localizer.forPackage(AbstractDataCache.class);\n+\n+    /**\n+     * The configuration set by the system.\n+     */\n+    protected OpenJPAConfiguration conf;\n+\n+    /**\n+     * The log to use.\n+     */\n+    protected Log log;\n+\n+    private String _name = null;\n+    private boolean _closed = false;\n+    private String _schedule = null;\n+    \n+    protected Set<String> _includedTypes;\n+    protected Set<String> _excludedTypes;\n+\n+    public String getName() {\n+        return _name;\n+    }\n+\n+    public void setName(String name) {\n+        _name = name;\n+    }\n+\n+    public String getEvictionSchedule() {\n+        return _schedule;\n+    }\n+\n+    public void setEvictionSchedule(String s) {\n+        _schedule = s;\n+    }\n+\n+    public void initialize(DataCacheManager manager) {\n+        if (_schedule != null && !\"\".equals(_schedule)) {\n+            DataCacheScheduler scheduler = manager.getDataCacheScheduler();\n+            if (scheduler != null)\n+                scheduler.scheduleEviction(this, _schedule);\n+        }\n+    }\n+\n+    public void commit(Collection additions, Collection newUpdates,\n+        Collection existingUpdates, Collection deletes) {\n+        // remove all objects in deletes list\n+        removeAllInternal(deletes);\n+\n+        // next, add all the new additions\n+        putAllInternal(additions);\n+        putAllInternal(newUpdates);\n+\n+        // possibly add the existing updates, depending on the\n+        // semantics of the cache, as dictated by recacheUpdates()\n+        if (recacheUpdates())\n+            putAllInternal(existingUpdates);\n+\n+        if (log.isTraceEnabled()) {\n+            Collection addIds = new ArrayList(additions.size());\n+            Collection upIds = new ArrayList(newUpdates.size());\n+            Collection exIds = new ArrayList(existingUpdates.size());\n+\n+            for (Iterator iter = additions.iterator(); iter.hasNext();)\n+                addIds.add(((DataCachePCData) iter.next()).getId());\n+            for (Iterator iter = newUpdates.iterator(); iter.hasNext();)\n+                upIds.add(((DataCachePCData) iter.next()).getId());\n+            for (Iterator iter = existingUpdates.iterator(); iter.hasNext();)\n+                exIds.add(((DataCachePCData) iter.next()).getId());\n+\n+            log.trace(s_loc.get(\"cache-commit\",\n+                new Object[]{ addIds, upIds, exIds, deletes }));\n+        }\n+    }\n+\n+    public boolean contains(Object key) {\n+        DataCachePCData o = getInternal(key);\n+        if (o != null && o.isTimedOut()) {\n+            o = null;\n+            removeInternal(key);\n+            if (log.isTraceEnabled())\n+                log.trace(s_loc.get(\"cache-timeout\", key));\n+        }\n+        return o != null;\n+    }\n+\n+    public BitSet containsAll(Collection keys) {\n+        if (keys.isEmpty())\n+            return EMPTY_BITSET;\n+\n+        BitSet set = new BitSet(keys.size());\n+        int i = 0;\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n+            if (contains(iter.next()))\n+                set.set(i);\n+        return set;\n+    }\n+\n+    public DataCachePCData get(Object key) {\n+        DataCachePCData o = getInternal(key);\n+        if (o != null && o.isTimedOut()) {\n+            o = null;\n+            removeInternal(key);\n+            if (log.isTraceEnabled())\n+                log.trace(s_loc.get(\"cache-timeout\", key));\n+        }\n+\n+        if (log.isTraceEnabled()) {\n+            if (o == null)\n+                log.trace(s_loc.get(\"cache-miss\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-hit\", key));\n+        }\n+\n+        return o;\n+    }\n+\n+    public DataCachePCData put(DataCachePCData data) {\n+        DataCachePCData o = putInternal(data.getId(), data);\n+        if (log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-put\", data.getId()));\n+        return (o == null || o.isTimedOut()) ? null : o;\n+    }\n+\n+    public void update(DataCachePCData data) {\n+        if (recacheUpdates())\n+            putInternal(data.getId(), data);\n+    }\n+\n+    public DataCachePCData remove(Object key) {\n+        DataCachePCData o = removeInternal(key);\n+        if (o != null && o.isTimedOut())\n+            o = null;\n+        if (log.isTraceEnabled()) {\n+            if (o == null)\n+                log.trace(s_loc.get(\"cache-remove-miss\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-remove-hit\", key));\n+        }\n+        return o;\n+    }\n+\n+    public BitSet removeAll(Collection keys) {\n+        if (keys.isEmpty())\n+            return EMPTY_BITSET;\n+\n+        BitSet set = new BitSet(keys.size());\n+        int i = 0;\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n+            if (remove(iter.next()) != null)\n+                set.set(i);\n+        return set;\n+    }\n+\n+    /**\n+     * Remove the objects of the given class from the cache.\n+     */\n+    public void removeAll(Class cls, boolean subClasses) {\n+        removeAllInternal(cls, subClasses);\n+    }\n+\n+    public boolean pin(Object key) {\n+        boolean bool = pinInternal(key);\n+        if (log.isTraceEnabled()) {\n+            if (bool)\n+                log.trace(s_loc.get(\"cache-pin-hit\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-pin-miss\", key));\n+        }\n+        return bool;\n+    }\n+\n+    public BitSet pinAll(Collection keys) {\n+        if (keys.isEmpty())\n+            return EMPTY_BITSET;\n+\n+        BitSet set = new BitSet(keys.size());\n+        int i = 0;\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n+            if (pin(iter.next()))\n+                set.set(i);\n+        return set;\n+    }\n+\n+    public void pinAll(Class cls, boolean subs) {\n+        if (log.isWarnEnabled())\n+            log.warn(s_loc.get(\"cache-class-pin\", getName()));\n+    }\n+\n+    public boolean unpin(Object key) {\n+        boolean bool = unpinInternal(key);\n+        if (log.isTraceEnabled()) {\n+            if (bool)\n+                log.trace(s_loc.get(\"cache-unpin-hit\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-unpin-miss\", key));\n+        }\n+        return bool;\n+    }\n+\n+    public BitSet unpinAll(Collection keys) {\n+        if (keys.isEmpty())\n+            return EMPTY_BITSET;\n+\n+        BitSet set = new BitSet(keys.size());\n+        int i = 0;\n+        for (Iterator iter = keys.iterator(); iter.hasNext(); i++)\n+            if (unpin(iter.next()))\n+                set.set(i);\n+        return set;\n+    }\n+\n+    public void unpinAll(Class cls, boolean subs) {\n+        if (log.isWarnEnabled())\n+            log.warn(s_loc.get(\"cache-class-unpin\", getName()));\n+    }\n+\n+    public void clear() {\n+        clearInternal();\n+        if (log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-clear\", getName()));\n+    }\n+\n+    public void close() {\n+        close(true);\n+    }\n+\n+    protected void close(boolean clear) {\n+        if (!_closed) {\n+            if (clear)\n+                clearInternal();\n+            _closed = true;\n+        }\n+    }\n+\n+    public boolean isClosed() {\n+        return _closed;\n+    }\n+\n+    public void addExpirationListener(ExpirationListener listen) {\n+        addListener(listen);\n+    }\n+\n+    public boolean removeExpirationListener(ExpirationListener listen) {\n+        return removeListener(listen);\n+    }\n+\n+    public String toString() {\n+        return \"[\" + super.toString() + \":\" + _name + \"]\";\n+    }\n+\n+    /**\n+     * This method is part of the {@link RemoteCommitListener} interface. If\n+     * your cache subclass relies on OpenJPA for clustering support, make it\n+     * implement <code>RemoteCommitListener</code>. This method will take\n+     * care of invalidating entries from remote commits.\n+     */\n+    public void afterCommit(RemoteCommitEvent event) {\n+        if (_closed)\n+            return;\n+\n+        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\n+            removeAllTypeNamesInternal(event.getUpdatedTypeNames());\n+            removeAllTypeNamesInternal(event.getDeletedTypeNames());\n+        } else {\n+            // drop all the committed OIDs, excepting brand\n+            // new OIDs. brand new OIDs either won't be in\n+            // the cache, or if they are, will be more up to date\n+            removeAllInternal(event.getUpdatedObjectIds());\n+            removeAllInternal(event.getDeletedObjectIds());\n+        }\n+    }\n+\n+    /**\n+     * Invoke when a key is removed from this cache. Propagates the\n+     * expiration event on to all expiration listeners registered\n+     * with this class.\n+     */\n+    protected void keyRemoved(Object key, boolean expired) {\n+        // Notify any expiration listeners of the expiration.\n+        if (hasListeners())\n+            fireEvent(new ExpirationEvent(this, key, expired));\n+\n+        if (expired && log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-expired\", key));\n+    }\n+\n+    /**\n+     * Return <code>true</code> if updates to data already in the\n+     * cache (either in {@link #commit} or the {@link #update})\n+     * should be put back into the cache. Returns false by default.\n+     */\n+    protected boolean recacheUpdates() {\n+        return false;\n+    }\n+\n+    /**\n+     * Return the object for the given oid.\n+     */\n+    protected abstract DataCachePCData getInternal(Object oid);\n+\n+    /**\n+     * Add the given object to the cache, returning the old object under the\n+     * given oid.\n+     */\n+    protected abstract DataCachePCData putInternal(Object oid,\n+        DataCachePCData pc);\n+\n+    /**\n+     * All all of the given objects to the cache.\n+     */\n+    protected void putAllInternal(Collection pcs) {\n+        DataCachePCData pc;\n+        for (Iterator iter = pcs.iterator(); iter.hasNext();) {\n+            pc = (DataCachePCData) iter.next();\n+            putInternal(pc.getId(), pc);\n+        }\n+    }\n+\n+    /**\n+     * Remove the object under the given oid from the cache.\n+     */\n+    protected abstract DataCachePCData removeInternal(Object oid);\n+\n+    /**\n+     * Evict objects in cache by class.\n+     */\n+    protected abstract void removeAllInternal(Class cls, boolean subclasses);\n+\n+    /**\n+     * Remove all objects under the given oids from the cache.\n+     */\n+    protected void removeAllInternal(Collection oids) {\n+        for (Iterator iter = oids.iterator(); iter.hasNext();)\n+            removeInternal(iter.next());\n+    }\n+\n+    /**\n+     * Remove all objects of the given class names from the cache.\n+     */\n+    protected void removeAllTypeNamesInternal(Collection classNames) {\n+        Collection classes = Caches.addTypesByName(conf, classNames, null);\n+        if (classes == null)\n+            return;\n+\n+        Class cls;\n+        for (Iterator iter = classes.iterator(); iter.hasNext();) {\n+            cls = (Class) iter.next();\n+            if (log.isTraceEnabled())\n+                log.trace(s_loc.get(\"cache-removeclass\", cls.getName()));\n+            removeAllInternal(cls, false);\n+        }\n+    }\n+\n+    /**\n+     * Clear the cache.\n+     */\n+    protected abstract void clearInternal();\n+\n+    /**\n+     * Pin an object to the cache.\n+     */\n+    protected abstract boolean pinInternal(Object oid);\n+\n+    /**\n+     * Unpin an object from the cache.\n+     */\n+    protected abstract boolean unpinInternal(Object oid);\n+\n+    // ---------- Configurable implementation ----------\n+\n+    public void setConfiguration(Configuration conf) {\n+        this.conf = (OpenJPAConfiguration) conf;\n+        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+        if (_name == null)\n+            setName(NAME_DEFAULT);\n+    }\n+\n+    // ---------- AbstractEventManager implementation ----------\n+\n+    protected void fireEvent(Object event, Object listener) {\n+        ExpirationListener listen = (ExpirationListener) listener;\n+        ExpirationEvent ev = (ExpirationEvent) event;\n+        try {\n+            listen.onExpire(ev);\n+        } catch (Exception e) {\n+            if (log.isWarnEnabled())\n+                log.warn(s_loc.get(\"exp-listener-ex\"), e);\n+\t\t}\n+\t}\n+\n+    /**\n+     * Returns the objects for the given key List.\n+     */\n+    public Map getAll(List keys) {\n+        Map resultMap = new HashMap(keys.size());\n+        for(int i=0; i<keys.size(); i++)\n+            resultMap.put(keys.get(i), get(keys.get(i)));\n+        return resultMap;\n+    }\n+    \n+    public Set<String> getTypes() {\n+        return _includedTypes;\n+    }\n+    \n+    public Set<String> getExcludedTypes() {\n+        return _excludedTypes;\n+    }\n+\n+    public void setTypes(Set<String> types) {\n+        _includedTypes = types;\n+    }\n+\n+    public void setTypes(String types) {\n+        _includedTypes =\n+            StringUtils.isEmpty(types) ? null : new HashSet<String>(Arrays\n+                .asList(Strings.split(types, \";\", 0)));\n+    }\n+\n+    public void setExcludedTypes(Set<String> types) {\n+        _excludedTypes = types;\n+    }\n+\n+    public void setExcludedTypes(String types) {\n+        _excludedTypes =\n+            StringUtils.isEmpty(types) ? null : new HashSet<String>(Arrays\n+                .asList(Strings.split(types, \";\", 0)));\n+    }\n+}"},{"sha":"7a6beb97c91ff0e8290bb29e4ee67d95954ddf53","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","status":"modified","additions":322,"deletions":322,"changes":644,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/AbstractQueryCache.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,322 +1,322 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.event.RemoteCommitEvent;\r\n-import org.apache.openjpa.event.RemoteCommitListener;\r\n-import org.apache.openjpa.lib.conf.Configurable;\r\n-import org.apache.openjpa.lib.conf.Configuration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\r\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashSet;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-import org.apache.openjpa.util.Id;\r\n-\r\n-/**\r\n- * Abstract {@link QueryCache} implementation that provides various\r\n- * statistics, logging, and timeout functionality common across cache\r\n- * implementations.\r\n- *\r\n- * @author Patrick Linskey\r\n- * @author Abe White\r\n- */\r\n-public abstract class AbstractQueryCache\r\n-    extends AbstractConcurrentEventManager \r\n-    implements QueryCache, Configurable {\r\n-\r\n-    private static final Localizer s_loc =\r\n-        Localizer.forPackage(AbstractQueryCache.class);\r\n-\r\n-    /**\r\n-     * The configuration set by the system.\r\n-     */\r\n-    protected OpenJPAConfiguration conf;\r\n-\r\n-    /**\r\n-     * The log to use.\r\n-     */\r\n-    protected Log log;\r\n-\r\n-    private boolean _closed = false;\r\n-\r\n-    public void initialize(DataCacheManager manager) {\r\n-    }\r\n-\r\n-    public void onTypesChanged(TypesChangedEvent ev) {\r\n-        writeLock();\r\n-        Collection keys = null;\r\n-        try {\r\n-            if (hasListeners())\r\n-                fireEvent(ev);\r\n-            keys = keySet();\r\n-        } finally {\r\n-            writeUnlock();\r\n-        }\r\n-\r\n-        QueryKey qk;\r\n-        List removes = null;\r\n-        for (Iterator iter = keys.iterator(); iter.hasNext();) {\r\n-            qk = (QueryKey) iter.next();\r\n-            if (qk.changeInvalidatesQuery(ev.getTypes())) {\r\n-                if (removes == null)\r\n-                    removes = new ArrayList();\r\n-                removes.add(qk);\r\n-            }\r\n-        }\r\n-        if (removes != null)\r\n-            removeAllInternal(removes);\r\n-    }\r\n-\r\n-    public QueryResult get(QueryKey key) {\r\n-        QueryResult o = getInternal(key);\r\n-        if (o != null && o.isTimedOut()) {\r\n-            o = null;\r\n-            removeInternal(key);\r\n-            if (log.isTraceEnabled())\r\n-                log.trace(s_loc.get(\"cache-timeout\", key));\r\n-        }\r\n-\r\n-        if (log.isTraceEnabled()) {\r\n-            if (o == null)\r\n-                log.trace(s_loc.get(\"cache-miss\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-hit\", key));\r\n-        }\r\n-        return o;\r\n-    }\r\n-\r\n-    public QueryResult put(QueryKey qk, QueryResult oids) {\r\n-        QueryResult o = putInternal(qk, oids);\r\n-        if (log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-put\", qk));\r\n-        return (o == null || o.isTimedOut()) ? null : o;\r\n-    }\r\n-\r\n-    public QueryResult remove(QueryKey key) {\r\n-        QueryResult o = removeInternal(key);\r\n-        if (o != null && o.isTimedOut())\r\n-            o = null;\r\n-        if (log.isTraceEnabled()) {\r\n-            if (o == null)\r\n-                log.trace(s_loc.get(\"cache-remove-miss\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-remove-hit\", key));\r\n-        }\r\n-        return o;\r\n-    }\r\n-\r\n-    public boolean pin(QueryKey key) {\r\n-        boolean bool = pinInternal(key);\r\n-        if (log.isTraceEnabled()) {\r\n-            if (bool)\r\n-                log.trace(s_loc.get(\"cache-pin-hit\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-pin-miss\", key));\r\n-        }\r\n-        return bool;\r\n-    }\r\n-\r\n-    public boolean unpin(QueryKey key) {\r\n-        boolean bool = unpinInternal(key);\r\n-        if (log.isTraceEnabled()) {\r\n-            if (bool)\r\n-                log.trace(s_loc.get(\"cache-unpin-hit\", key));\r\n-            else\r\n-                log.trace(s_loc.get(\"cache-unpin-miss\", key));\r\n-        }\r\n-        return bool;\r\n-    }\r\n-\r\n-    public void clear() {\r\n-        clearInternal();\r\n-        if (log.isTraceEnabled())\r\n-            log.trace(s_loc.get(\"cache-clear\", \"<query-cache>\"));\r\n-    }\r\n-\r\n-    public void close() {\r\n-        close(true);\r\n-    }\r\n-\r\n-    protected void close(boolean clear) {\r\n-        if (!_closed) {\r\n-            if (clear)\r\n-                clearInternal();\r\n-            _closed = true;\r\n-        }\r\n-    }\r\n-\r\n-    public boolean isClosed() {\r\n-        return _closed;\r\n-    }\r\n-\r\n-    public void addTypesChangedListener(TypesChangedListener listen) {\r\n-        addListener(listen);\r\n-    }\r\n-\r\n-    public boolean removeTypesChangedListener(TypesChangedListener listen) {\r\n-        return removeListener(listen);\r\n-    }\r\n-\r\n-    /**\r\n-     * This method is part of the {@link RemoteCommitListener} interface. If\r\n-     * your cache subclass relies on OpenJPA for clustering support, make it\r\n-     * implement <code>RemoteCommitListener</code>. This method will take\r\n-     * care of invalidating entries from remote commits, by delegating to\r\n-     * {@link #onTypesChanged}.\r\n-     */\r\n-    public void afterCommit(RemoteCommitEvent event) {\r\n-        if (_closed)\r\n-            return;\r\n-\r\n-        // drop all committed classes\r\n-        Set classes = Caches.addTypesByName(conf,\r\n-            event.getPersistedTypeNames(), null);\r\n-        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\r\n-            classes = Caches.addTypesByName(conf, event.getUpdatedTypeNames(),\r\n-                classes);\r\n-            classes = Caches.addTypesByName(conf, event.getDeletedTypeNames(),\r\n-                classes);\r\n-        } else {\r\n-            classes = addTypes(event.getUpdatedObjectIds(), classes);\r\n-            classes = addTypes(event.getDeletedObjectIds(), classes);\r\n-        }\r\n-        if (classes != null)\r\n-            onTypesChanged(new TypesChangedEvent(this, classes));\r\n-    }\r\n-\r\n-    /**\r\n-     * Build up a set of classes for the given oids.\r\n-     */\r\n-    private Set addTypes(Collection oids, Set classes) {\r\n-        if (oids.isEmpty())\r\n-            return classes;\r\n-        if (classes == null)\r\n-            classes = new HashSet();\r\n-\r\n-        MetaDataRepository repos = conf.getMetaDataRepositoryInstance();\r\n-        ClassMetaData meta;\r\n-        Object oid;\r\n-        for (Iterator itr = oids.iterator(); itr.hasNext();) {\r\n-            oid = itr.next();\r\n-            if (oid instanceof Id)\r\n-                classes.add(((Id) oid).getType());\r\n-            else {\r\n-                // ok if no metadata for oid; that just means the pc type\r\n-                // probably hasn't been loaded into this JVM yet, and therefore\r\n-                // there's no chance that it's in the cache anyway\r\n-                meta = repos.getMetaData(oid, null, false);\r\n-                if (meta != null)\r\n-                    classes.add(meta.getDescribedType());\r\n-            }\r\n-        }\r\n-        return classes;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a threadsafe view of the keys in this cache. This collection\r\n-     * must be iterable without risk of concurrent modification exceptions.\r\n-     * It does not have to implement contains() efficiently or use set\r\n-     * semantics.\r\n-     */\r\n-    protected abstract Collection keySet();\r\n-\r\n-    /**\r\n-     * Return the list for the given key.\r\n-     */\r\n-    protected abstract QueryResult getInternal(QueryKey qk);\r\n-\r\n-    /**\r\n-     * Add the given result to the cache, returning the old result under the\r\n-     * given key.\r\n-     */\r\n-    protected abstract QueryResult putInternal(QueryKey qk, QueryResult oids);\r\n-\r\n-    /**\r\n-     * Remove the result under the given key from the cache.\r\n-     */\r\n-    protected abstract QueryResult removeInternal(QueryKey qk);\r\n-\r\n-    /**\r\n-     * Remove all results under the given keys from the cache.\r\n-     */\r\n-    protected void removeAllInternal(Collection qks) {\r\n-        for (Iterator iter = qks.iterator(); iter.hasNext();)\r\n-            removeInternal((QueryKey) iter.next());\r\n-    }\r\n-\r\n-    /**\r\n-     * Clear the cache.\r\n-     */\r\n-    protected abstract void clearInternal();\r\n-\r\n-    /**\r\n-     * Pin an object to the cache.\r\n-     */\r\n-    protected abstract boolean pinInternal(QueryKey qk);\r\n-\r\n-    /**\r\n-     * Unpin an object from the cache.\r\n-     */\r\n-    protected abstract boolean unpinInternal(QueryKey qk);\r\n-\r\n-    // ---------- Configurable implementation ----------\r\n-\r\n-    public void setConfiguration(Configuration conf) {\r\n-        this.conf = (OpenJPAConfiguration) conf;\r\n-        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n-    }\r\n-\r\n-    public void startConfiguration() {\r\n-    }\r\n-\r\n-    public void endConfiguration() {\r\n-    }\r\n-\r\n-    // ---------- AbstractEventManager implementation ----------\r\n-\r\n-    protected void fireEvent(Object event, Object listener) {\r\n-        TypesChangedListener listen = (TypesChangedListener) listener;\r\n-        TypesChangedEvent ev = (TypesChangedEvent) event;\r\n-        try {\r\n-            listen.onTypesChanged(ev);\r\n-        } catch (Exception e) {\r\n-            if (log.isWarnEnabled())\r\n-                log.warn(s_loc.get(\"exp-listener-ex\"), e);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Individual query results will be registered as types changed\r\n-     * listeners. We want such query results to be gc'd once\r\n-     * the only reference is held by the list of expiration listeners.\r\n-     */\r\n-    protected Collection newListenerCollection() {\r\n-        return new ConcurrentReferenceHashSet (ConcurrentReferenceHashSet.WEAK);\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.event.RemoteCommitEvent;\n+import org.apache.openjpa.event.RemoteCommitListener;\n+import org.apache.openjpa.lib.conf.Configurable;\n+import org.apache.openjpa.lib.conf.Configuration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.concurrent.AbstractConcurrentEventManager;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashSet;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.util.Id;\n+\n+/**\n+ * Abstract {@link QueryCache} implementation that provides various\n+ * statistics, logging, and timeout functionality common across cache\n+ * implementations.\n+ *\n+ * @author Patrick Linskey\n+ * @author Abe White\n+ */\n+public abstract class AbstractQueryCache\n+    extends AbstractConcurrentEventManager \n+    implements QueryCache, Configurable {\n+\n+    private static final Localizer s_loc =\n+        Localizer.forPackage(AbstractQueryCache.class);\n+\n+    /**\n+     * The configuration set by the system.\n+     */\n+    protected OpenJPAConfiguration conf;\n+\n+    /**\n+     * The log to use.\n+     */\n+    protected Log log;\n+\n+    private boolean _closed = false;\n+\n+    public void initialize(DataCacheManager manager) {\n+    }\n+\n+    public void onTypesChanged(TypesChangedEvent ev) {\n+        writeLock();\n+        Collection keys = null;\n+        try {\n+            if (hasListeners())\n+                fireEvent(ev);\n+            keys = keySet();\n+        } finally {\n+            writeUnlock();\n+        }\n+\n+        QueryKey qk;\n+        List removes = null;\n+        for (Iterator iter = keys.iterator(); iter.hasNext();) {\n+            qk = (QueryKey) iter.next();\n+            if (qk.changeInvalidatesQuery(ev.getTypes())) {\n+                if (removes == null)\n+                    removes = new ArrayList();\n+                removes.add(qk);\n+            }\n+        }\n+        if (removes != null)\n+            removeAllInternal(removes);\n+    }\n+\n+    public QueryResult get(QueryKey key) {\n+        QueryResult o = getInternal(key);\n+        if (o != null && o.isTimedOut()) {\n+            o = null;\n+            removeInternal(key);\n+            if (log.isTraceEnabled())\n+                log.trace(s_loc.get(\"cache-timeout\", key));\n+        }\n+\n+        if (log.isTraceEnabled()) {\n+            if (o == null)\n+                log.trace(s_loc.get(\"cache-miss\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-hit\", key));\n+        }\n+        return o;\n+    }\n+\n+    public QueryResult put(QueryKey qk, QueryResult oids) {\n+        QueryResult o = putInternal(qk, oids);\n+        if (log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-put\", qk));\n+        return (o == null || o.isTimedOut()) ? null : o;\n+    }\n+\n+    public QueryResult remove(QueryKey key) {\n+        QueryResult o = removeInternal(key);\n+        if (o != null && o.isTimedOut())\n+            o = null;\n+        if (log.isTraceEnabled()) {\n+            if (o == null)\n+                log.trace(s_loc.get(\"cache-remove-miss\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-remove-hit\", key));\n+        }\n+        return o;\n+    }\n+\n+    public boolean pin(QueryKey key) {\n+        boolean bool = pinInternal(key);\n+        if (log.isTraceEnabled()) {\n+            if (bool)\n+                log.trace(s_loc.get(\"cache-pin-hit\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-pin-miss\", key));\n+        }\n+        return bool;\n+    }\n+\n+    public boolean unpin(QueryKey key) {\n+        boolean bool = unpinInternal(key);\n+        if (log.isTraceEnabled()) {\n+            if (bool)\n+                log.trace(s_loc.get(\"cache-unpin-hit\", key));\n+            else\n+                log.trace(s_loc.get(\"cache-unpin-miss\", key));\n+        }\n+        return bool;\n+    }\n+\n+    public void clear() {\n+        clearInternal();\n+        if (log.isTraceEnabled())\n+            log.trace(s_loc.get(\"cache-clear\", \"<query-cache>\"));\n+    }\n+\n+    public void close() {\n+        close(true);\n+    }\n+\n+    protected void close(boolean clear) {\n+        if (!_closed) {\n+            if (clear)\n+                clearInternal();\n+            _closed = true;\n+        }\n+    }\n+\n+    public boolean isClosed() {\n+        return _closed;\n+    }\n+\n+    public void addTypesChangedListener(TypesChangedListener listen) {\n+        addListener(listen);\n+    }\n+\n+    public boolean removeTypesChangedListener(TypesChangedListener listen) {\n+        return removeListener(listen);\n+    }\n+\n+    /**\n+     * This method is part of the {@link RemoteCommitListener} interface. If\n+     * your cache subclass relies on OpenJPA for clustering support, make it\n+     * implement <code>RemoteCommitListener</code>. This method will take\n+     * care of invalidating entries from remote commits, by delegating to\n+     * {@link #onTypesChanged}.\n+     */\n+    public void afterCommit(RemoteCommitEvent event) {\n+        if (_closed)\n+            return;\n+\n+        // drop all committed classes\n+        Set classes = Caches.addTypesByName(conf,\n+            event.getPersistedTypeNames(), null);\n+        if (event.getPayloadType() == RemoteCommitEvent.PAYLOAD_EXTENTS) {\n+            classes = Caches.addTypesByName(conf, event.getUpdatedTypeNames(),\n+                classes);\n+            classes = Caches.addTypesByName(conf, event.getDeletedTypeNames(),\n+                classes);\n+        } else {\n+            classes = addTypes(event.getUpdatedObjectIds(), classes);\n+            classes = addTypes(event.getDeletedObjectIds(), classes);\n+        }\n+        if (classes != null)\n+            onTypesChanged(new TypesChangedEvent(this, classes));\n+    }\n+\n+    /**\n+     * Build up a set of classes for the given oids.\n+     */\n+    private Set addTypes(Collection oids, Set classes) {\n+        if (oids.isEmpty())\n+            return classes;\n+        if (classes == null)\n+            classes = new HashSet();\n+\n+        MetaDataRepository repos = conf.getMetaDataRepositoryInstance();\n+        ClassMetaData meta;\n+        Object oid;\n+        for (Iterator itr = oids.iterator(); itr.hasNext();) {\n+            oid = itr.next();\n+            if (oid instanceof Id)\n+                classes.add(((Id) oid).getType());\n+            else {\n+                // ok if no metadata for oid; that just means the pc type\n+                // probably hasn't been loaded into this JVM yet, and therefore\n+                // there's no chance that it's in the cache anyway\n+                meta = repos.getMetaData(oid, null, false);\n+                if (meta != null)\n+                    classes.add(meta.getDescribedType());\n+            }\n+        }\n+        return classes;\n+    }\n+\n+    /**\n+     * Return a threadsafe view of the keys in this cache. This collection\n+     * must be iterable without risk of concurrent modification exceptions.\n+     * It does not have to implement contains() efficiently or use set\n+     * semantics.\n+     */\n+    protected abstract Collection keySet();\n+\n+    /**\n+     * Return the list for the given key.\n+     */\n+    protected abstract QueryResult getInternal(QueryKey qk);\n+\n+    /**\n+     * Add the given result to the cache, returning the old result under the\n+     * given key.\n+     */\n+    protected abstract QueryResult putInternal(QueryKey qk, QueryResult oids);\n+\n+    /**\n+     * Remove the result under the given key from the cache.\n+     */\n+    protected abstract QueryResult removeInternal(QueryKey qk);\n+\n+    /**\n+     * Remove all results under the given keys from the cache.\n+     */\n+    protected void removeAllInternal(Collection qks) {\n+        for (Iterator iter = qks.iterator(); iter.hasNext();)\n+            removeInternal((QueryKey) iter.next());\n+    }\n+\n+    /**\n+     * Clear the cache.\n+     */\n+    protected abstract void clearInternal();\n+\n+    /**\n+     * Pin an object to the cache.\n+     */\n+    protected abstract boolean pinInternal(QueryKey qk);\n+\n+    /**\n+     * Unpin an object from the cache.\n+     */\n+    protected abstract boolean unpinInternal(QueryKey qk);\n+\n+    // ---------- Configurable implementation ----------\n+\n+    public void setConfiguration(Configuration conf) {\n+        this.conf = (OpenJPAConfiguration) conf;\n+        this.log = conf.getLog(OpenJPAConfiguration.LOG_DATACACHE);\n+    }\n+\n+    public void startConfiguration() {\n+    }\n+\n+    public void endConfiguration() {\n+    }\n+\n+    // ---------- AbstractEventManager implementation ----------\n+\n+    protected void fireEvent(Object event, Object listener) {\n+        TypesChangedListener listen = (TypesChangedListener) listener;\n+        TypesChangedEvent ev = (TypesChangedEvent) event;\n+        try {\n+            listen.onTypesChanged(ev);\n+        } catch (Exception e) {\n+            if (log.isWarnEnabled())\n+                log.warn(s_loc.get(\"exp-listener-ex\"), e);\n+        }\n+    }\n+\n+    /**\n+     * Individual query results will be registered as types changed\n+     * listeners. We want such query results to be gc'd once\n+     * the only reference is held by the list of expiration listeners.\n+     */\n+    protected Collection newListenerCollection() {\n+        return new ConcurrentReferenceHashSet (ConcurrentReferenceHashSet.WEAK);\n+\t}\n+}"},{"sha":"28e7e211ced156204672294e6c9cd7f36797c6b0","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","status":"modified","additions":248,"deletions":248,"changes":496,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/DataCacheScheduler.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,248 +1,248 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.security.AccessController;\r\n-import java.text.DateFormat;\r\n-import java.text.SimpleDateFormat;\r\n-import java.util.Calendar;\r\n-import java.util.Date;\r\n-import java.util.Iterator;\r\n-import java.util.Map;\r\n-import java.util.StringTokenizer;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.J2DoPrivHelper;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import java.util.concurrent.ConcurrentHashMap;\r\n-import org.apache.openjpa.util.InvalidStateException;\r\n-import org.apache.openjpa.util.UserException;\r\n-import serp.util.Strings;\r\n-\r\n-/**\r\n- * Cron-style cache eviction. Understands schedules based on cron format:\r\n- * <code>minute hour mday month wday</code>\r\n- * For example:\r\n- * <code>15,30 6,19 2,10 1 2 </code>\r\n- * Would run at 15 and 30 past the 6AM and 7PM, on the 2nd and 10th\r\n- * of January when its a Monday.\r\n- *\r\n- * @author Steve Kim\r\n- */\r\n-public class DataCacheScheduler\r\n-    implements Runnable {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (DataCacheScheduler.class);\r\n-\r\n-    private Map _caches = new ConcurrentHashMap();\r\n-    private boolean _stop = false;\r\n-    private int _interval = 2;\r\n-    private Log _log;\r\n-    private Thread _thread;\r\n-\r\n-    public DataCacheScheduler(OpenJPAConfiguration conf) {\r\n-        _log = conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_DATACACHE);\r\n-    }\r\n-\r\n-    /**\r\n-     * The interval time in minutes between cache checks. Defaults to 2.\r\n-     */\r\n-    public int getInterval() {\r\n-        return _interval;\r\n-    }\r\n-\r\n-    /**\r\n-     * The interval time in minutes between cache checks. Defaults to 2.\r\n-     */\r\n-    public void setInterval(int interval) {\r\n-        _interval = interval;\r\n-    }\r\n-\r\n-    /**\r\n-     * Stop the associated thread if there and stop the current runnable.\r\n-     */\r\n-    public synchronized void stop() {\r\n-        _stop = true;\r\n-    }\r\n-\r\n-    private boolean isStopped() {\r\n-        return _stop;\r\n-    }\r\n-\r\n-    /**\r\n-     * Schedule the given cache for eviction. Starts the scheduling thread\r\n-     * if not started.\r\n-     */\r\n-    public synchronized void scheduleEviction(DataCache cache, String times) {\r\n-        if (times == null)\r\n-            return;\r\n-\r\n-        Schedule schedule = new Schedule(times);\r\n-        _caches.put(cache, schedule);\r\n-        _stop = false;\r\n-        if (_thread == null) {\r\n-            _thread = (Thread) AccessController.doPrivileged(J2DoPrivHelper\r\n-                .newDaemonThreadAction(this, _loc.get(\"scheduler-name\")\r\n-                    .getMessage()));\r\n-            _thread.start();\r\n-            if (_log.isTraceEnabled())\r\n-                _log.trace(_loc.get(\"scheduler-start\", _thread.getName()));\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Remove the given cache from scheduling.\r\n-     */\r\n-    public synchronized void removeFromSchedule(DataCache cache) {\r\n-        _caches.remove(cache);\r\n-        if (_caches.size() == 0)\r\n-            stop();\r\n-    }\r\n-\r\n-    public void run() {\r\n-        if (_log.isTraceEnabled())\r\n-            _log.trace(_loc.get(\"scheduler-interval\", _interval + \"\"));\r\n-\r\n-        Date lastRun = new Date();\r\n-        DateFormat fom = new SimpleDateFormat(\"E HH:mm:ss\");\r\n-        while (!isStopped()) {\r\n-            try {\r\n-                Thread.sleep(_interval * 60 * 1000);\r\n-\r\n-                Date now = new Date();\r\n-                DataCache cache;\r\n-                Schedule schedule;\r\n-                Map.Entry entry;\r\n-                for (Iterator i = _caches.entrySet().iterator(); i.hasNext();) {\r\n-                    entry = (Map.Entry) i.next();\r\n-                    cache = (DataCache) entry.getKey();\r\n-                    schedule = (Schedule) entry.getValue();\r\n-                    if (schedule.matches(lastRun, now)) {\r\n-                        if (_log.isTraceEnabled())\r\n-                            _log.trace(_loc.get(\"scheduler-clear\",\r\n-                                cache.getName(), fom.format(now)));\r\n-                        evict(cache);\r\n-                    }\r\n-                }\r\n-                lastRun = now;\r\n-            } catch (Exception e) {\r\n-                throw new InvalidStateException(_loc.get(\"scheduler-fail\"), e).\r\n-                    setFatal(true);\r\n-            }\r\n-        }\r\n-\r\n-        _log.info(_loc.get(\"scheduler-stop\"));\r\n-        synchronized (this) {\r\n-            if (isStopped())\r\n-                _thread = null; // be sure to deref the thread so it can restart\r\n-        }\r\n-    }\r\n-\r\n-    protected void evict(DataCache cache) {\r\n-        cache.clear();\r\n-    }\r\n-\r\n-    /**\r\n-     * Simple class which represents the given time schedule.\r\n-     */\r\n-    private static class Schedule {\r\n-\r\n-        static final int[] WILDCARD = new int[0];\r\n-        static final int[] UNITS = {\r\n-            Calendar.MONTH,\r\n-            Calendar.DAY_OF_MONTH,\r\n-            Calendar.DAY_OF_WEEK,\r\n-            Calendar.HOUR_OF_DAY,\r\n-            Calendar.MINUTE\r\n-        };\r\n-        final int[] month;\r\n-        final int[] dayOfMonth;\r\n-        final int[] dayOfWeek;\r\n-        final int[] hour;\r\n-        final int[] min;\r\n-\r\n-        public Schedule(String date) {\r\n-            StringTokenizer token = new StringTokenizer(date, \" \\t\");\r\n-            if (token.countTokens() != 5)\r\n-                throw new UserException(_loc.get(\"bad-count\", date)).\r\n-                    setFatal(true);\r\n-            try {\r\n-                min = parse(token.nextToken(), 0, 60);\r\n-                hour = parse(token.nextToken(), 0, 24);\r\n-                dayOfMonth = parse(token.nextToken(), 1, 31);\r\n-                month = parse(token.nextToken(), 1, 13);\r\n-                dayOfWeek = parse(token.nextToken(), 1, 8);\r\n-            } catch (Throwable t) {\r\n-                throw new UserException(_loc.get(\"bad-schedule\", date), t).\r\n-                    setFatal(true);\r\n-            }\r\n-        }\r\n-\r\n-        private int[] parse(String token, int min, int max) {\r\n-            if (\"*\".equals(token.trim()))\r\n-                return WILDCARD;\r\n-            String[] tokens = Strings.split(token, \",\", 0);\r\n-            int [] times = new int[tokens.length];\r\n-            for (int i = 0; i < tokens.length; i++) {\r\n-                try {\r\n-                    times[i] = Integer.parseInt(tokens[i]);\r\n-                } catch (Throwable t) {\r\n-                    throw new UserException(_loc.get(\"not-number\", token)).\r\n-                        setFatal(true);\r\n-                }\r\n-                if (times[i] < min || times[i] >= max)\r\n-                    throw new UserException(_loc.get(\"not-range\", token,\r\n-                        String.valueOf(min), String.valueOf(max))).\r\n-                        setFatal(true);\r\n-            }\r\n-            return times;\r\n-        }\r\n-\r\n-        boolean matches(Date last, Date now) {\r\n-            Calendar time = Calendar.getInstance();\r\n-            time.setTime(now);\r\n-            time.set(Calendar.SECOND, 0);\r\n-            time.set(Calendar.MILLISECOND, 0);\r\n-\r\n-            int[][] all =\r\n-                new int[][]{ month, dayOfMonth, dayOfWeek, hour, min };\r\n-            return matches(last, now, time, all, 0);\r\n-        }\r\n-\r\n-        private boolean matches(Date last, Date now, Calendar time,\r\n-            int[][] times, int depth) {\r\n-            if (depth == UNITS.length) {\r\n-                Date compare = time.getTime();\r\n-                return compare.compareTo(last) >= 0 &&\r\n-                    compare.compareTo(now) < 0;\r\n-            }\r\n-\r\n-            if (times[depth] != WILDCARD) {\r\n-                for (int i = 0; i < times[depth].length; i++) {\r\n-                    time.set(UNITS[depth], times[depth][i]);\r\n-                    if (matches(last, now, time, times, depth + 1))\r\n-                        return true;\r\n-                }\r\n-            }\r\n-            return matches(last, now, time, times, depth + 1);\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.security.AccessController;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.StringTokenizer;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.J2DoPrivHelper;\n+import org.apache.openjpa.lib.util.Localizer;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.openjpa.util.InvalidStateException;\n+import org.apache.openjpa.util.UserException;\n+import serp.util.Strings;\n+\n+/**\n+ * Cron-style cache eviction. Understands schedules based on cron format:\n+ * <code>minute hour mday month wday</code>\n+ * For example:\n+ * <code>15,30 6,19 2,10 1 2 </code>\n+ * Would run at 15 and 30 past the 6AM and 7PM, on the 2nd and 10th\n+ * of January when its a Monday.\n+ *\n+ * @author Steve Kim\n+ */\n+public class DataCacheScheduler\n+    implements Runnable {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (DataCacheScheduler.class);\n+\n+    private Map _caches = new ConcurrentHashMap();\n+    private boolean _stop = false;\n+    private int _interval = 2;\n+    private Log _log;\n+    private Thread _thread;\n+\n+    public DataCacheScheduler(OpenJPAConfiguration conf) {\n+        _log = conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_DATACACHE);\n+    }\n+\n+    /**\n+     * The interval time in minutes between cache checks. Defaults to 2.\n+     */\n+    public int getInterval() {\n+        return _interval;\n+    }\n+\n+    /**\n+     * The interval time in minutes between cache checks. Defaults to 2.\n+     */\n+    public void setInterval(int interval) {\n+        _interval = interval;\n+    }\n+\n+    /**\n+     * Stop the associated thread if there and stop the current runnable.\n+     */\n+    public synchronized void stop() {\n+        _stop = true;\n+    }\n+\n+    private boolean isStopped() {\n+        return _stop;\n+    }\n+\n+    /**\n+     * Schedule the given cache for eviction. Starts the scheduling thread\n+     * if not started.\n+     */\n+    public synchronized void scheduleEviction(DataCache cache, String times) {\n+        if (times == null)\n+            return;\n+\n+        Schedule schedule = new Schedule(times);\n+        _caches.put(cache, schedule);\n+        _stop = false;\n+        if (_thread == null) {\n+            _thread = (Thread) AccessController.doPrivileged(J2DoPrivHelper\n+                .newDaemonThreadAction(this, _loc.get(\"scheduler-name\")\n+                    .getMessage()));\n+            _thread.start();\n+            if (_log.isTraceEnabled())\n+                _log.trace(_loc.get(\"scheduler-start\", _thread.getName()));\n+        }\n+    }\n+\n+    /**\n+     * Remove the given cache from scheduling.\n+     */\n+    public synchronized void removeFromSchedule(DataCache cache) {\n+        _caches.remove(cache);\n+        if (_caches.size() == 0)\n+            stop();\n+    }\n+\n+    public void run() {\n+        if (_log.isTraceEnabled())\n+            _log.trace(_loc.get(\"scheduler-interval\", _interval + \"\"));\n+\n+        Date lastRun = new Date();\n+        DateFormat fom = new SimpleDateFormat(\"E HH:mm:ss\");\n+        while (!isStopped()) {\n+            try {\n+                Thread.sleep(_interval * 60 * 1000);\n+\n+                Date now = new Date();\n+                DataCache cache;\n+                Schedule schedule;\n+                Map.Entry entry;\n+                for (Iterator i = _caches.entrySet().iterator(); i.hasNext();) {\n+                    entry = (Map.Entry) i.next();\n+                    cache = (DataCache) entry.getKey();\n+                    schedule = (Schedule) entry.getValue();\n+                    if (schedule.matches(lastRun, now)) {\n+                        if (_log.isTraceEnabled())\n+                            _log.trace(_loc.get(\"scheduler-clear\",\n+                                cache.getName(), fom.format(now)));\n+                        evict(cache);\n+                    }\n+                }\n+                lastRun = now;\n+            } catch (Exception e) {\n+                throw new InvalidStateException(_loc.get(\"scheduler-fail\"), e).\n+                    setFatal(true);\n+            }\n+        }\n+\n+        _log.info(_loc.get(\"scheduler-stop\"));\n+        synchronized (this) {\n+            if (isStopped())\n+                _thread = null; // be sure to deref the thread so it can restart\n+        }\n+    }\n+\n+    protected void evict(DataCache cache) {\n+        cache.clear();\n+    }\n+\n+    /**\n+     * Simple class which represents the given time schedule.\n+     */\n+    private static class Schedule {\n+\n+        static final int[] WILDCARD = new int[0];\n+        static final int[] UNITS = {\n+            Calendar.MONTH,\n+            Calendar.DAY_OF_MONTH,\n+            Calendar.DAY_OF_WEEK,\n+            Calendar.HOUR_OF_DAY,\n+            Calendar.MINUTE\n+        };\n+        final int[] month;\n+        final int[] dayOfMonth;\n+        final int[] dayOfWeek;\n+        final int[] hour;\n+        final int[] min;\n+\n+        public Schedule(String date) {\n+            StringTokenizer token = new StringTokenizer(date, \" \\t\");\n+            if (token.countTokens() != 5)\n+                throw new UserException(_loc.get(\"bad-count\", date)).\n+                    setFatal(true);\n+            try {\n+                min = parse(token.nextToken(), 0, 60);\n+                hour = parse(token.nextToken(), 0, 24);\n+                dayOfMonth = parse(token.nextToken(), 1, 31);\n+                month = parse(token.nextToken(), 1, 13);\n+                dayOfWeek = parse(token.nextToken(), 1, 8);\n+            } catch (Throwable t) {\n+                throw new UserException(_loc.get(\"bad-schedule\", date), t).\n+                    setFatal(true);\n+            }\n+        }\n+\n+        private int[] parse(String token, int min, int max) {\n+            if (\"*\".equals(token.trim()))\n+                return WILDCARD;\n+            String[] tokens = Strings.split(token, \",\", 0);\n+            int [] times = new int[tokens.length];\n+            for (int i = 0; i < tokens.length; i++) {\n+                try {\n+                    times[i] = Integer.parseInt(tokens[i]);\n+                } catch (Throwable t) {\n+                    throw new UserException(_loc.get(\"not-number\", token)).\n+                        setFatal(true);\n+                }\n+                if (times[i] < min || times[i] >= max)\n+                    throw new UserException(_loc.get(\"not-range\", token,\n+                        String.valueOf(min), String.valueOf(max))).\n+                        setFatal(true);\n+            }\n+            return times;\n+        }\n+\n+        boolean matches(Date last, Date now) {\n+            Calendar time = Calendar.getInstance();\n+            time.setTime(now);\n+            time.set(Calendar.SECOND, 0);\n+            time.set(Calendar.MILLISECOND, 0);\n+\n+            int[][] all =\n+                new int[][]{ month, dayOfMonth, dayOfWeek, hour, min };\n+            return matches(last, now, time, all, 0);\n+        }\n+\n+        private boolean matches(Date last, Date now, Calendar time,\n+            int[][] times, int depth) {\n+            if (depth == UNITS.length) {\n+                Date compare = time.getTime();\n+                return compare.compareTo(last) >= 0 &&\n+                    compare.compareTo(now) < 0;\n+            }\n+\n+            if (times[depth] != WILDCARD) {\n+                for (int i = 0; i < times[depth].length; i++) {\n+                    time.set(UNITS[depth], times[depth][i]);\n+                    if (matches(last, now, time, times, depth + 1))\n+                        return true;\n+                }\n+            }\n+            return matches(last, now, time, times, depth + 1);\n+\t\t}\n+\t}\n+}"},{"sha":"6b615df8cdbf5c8dcba5c3e6545049241f378ecf","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","status":"modified","additions":670,"deletions":670,"changes":1340,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/datacache/QueryCacheStoreQuery.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,670 +1,670 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.datacache;\r\n-\r\n-import java.io.ObjectStreamException;\r\n-import java.io.Serializable;\r\n-import java.util.AbstractList;\r\n-import java.util.ArrayList;\r\n-import java.util.BitSet;\r\n-import java.util.Collections;\r\n-import java.util.Date;\r\n-import java.util.List;\r\n-import java.util.Locale;\r\n-import java.util.Map;\r\n-import java.util.TreeMap;\r\n-\r\n-import org.apache.commons.collections.map.LinkedMap;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.LockLevels;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.QueryContext;\r\n-import org.apache.openjpa.kernel.StoreContext;\r\n-import org.apache.openjpa.kernel.StoreQuery;\r\n-import org.apache.openjpa.kernel.exps.AggregateListener;\r\n-import org.apache.openjpa.kernel.exps.FilterListener;\r\n-import org.apache.openjpa.lib.rop.ListResultObjectProvider;\r\n-import org.apache.openjpa.lib.rop.ResultObjectProvider;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.meta.MetaDataRepository;\r\n-import org.apache.openjpa.util.ObjectNotFoundException;\r\n-\r\n-import serp.util.Numbers;\r\n-\r\n-/**\r\n- * A {@link StoreQuery} implementation that caches the OIDs involved in\r\n- * the query, and can determine whether or not the query has been dirtied.\r\n- *\r\n- * @author Patrick Linskey\r\n- * @since 0.2.5.0\r\n- */\r\n-public class QueryCacheStoreQuery\r\n-    implements StoreQuery {\r\n-\r\n-    private final StoreQuery _query;\r\n-    private final QueryCache _cache;\r\n-    private StoreContext _sctx;\r\n-    private MetaDataRepository _repos;\r\n-\r\n-    /**\r\n-     * Create a new instance that delegates to <code>query</code> if no\r\n-     * cached results are available.\r\n-     */\r\n-    public QueryCacheStoreQuery(StoreQuery query, QueryCache cache) {\r\n-        _query = query;\r\n-        _cache = cache;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the {@link QueryCache} that this object is associated with.\r\n-     */\r\n-    public QueryCache getCache() {\r\n-        return _cache;\r\n-    }\r\n-\r\n-    /**\r\n-     * Delegate.\r\n-     */\r\n-    public StoreQuery getDelegate() {\r\n-        return _query;\r\n-    }\r\n-\r\n-    /**\r\n-     * Look in the query cache for a result for the given query\r\n-     * key. Only look if this query is being executed outside a\r\n-     * transaction or in a transaction with IgnoreChanges set to true\r\n-     * or in a transaction with IgnoreChanges set to false but in which\r\n-     * none of the classes involved in this query have been touched.\r\n-     *  Caching is not used when using object locking.\r\n-     * This is because we must obtain locks on the\r\n-     * data, and it is likely that making n trips to the database to\r\n-     * make the locks will be slower than running the query against\r\n-     * the database.\r\n-     *  If the fetch configuration has query caching disabled,\r\n-     * then this method returns <code>null</code>.\r\n-     *  Return the list if we meet the above criteria and if a list\r\n-     * is found for <code>qk</code>. Else, return\r\n-     * <code>null</code>.\r\n-     *  This implementation means that queries against the cache\r\n-     * are of READ_COMMITTED isolation level. It'd be nice to support\r\n-     * READ_SERIALIZABLE -- to do so, we'd just return false when in\r\n-     * a transaction.\r\n-     */\r\n-    private List checkCache(QueryKey qk) {\r\n-        if (qk == null)\r\n-            return null;\r\n-        FetchConfiguration fetch = getContext().getFetchConfiguration();\r\n-        if (!fetch.getQueryCacheEnabled())\r\n-            return null;\r\n-        if (fetch.getReadLockLevel() > LockLevels.LOCK_NONE)\r\n-            return null;\r\n-\r\n-        // get the cached data\r\n-        QueryResult res = _cache.get(qk);\r\n-        if (res == null)\r\n-            return null;\r\n-        if (res.isEmpty())\r\n-            return Collections.EMPTY_LIST;\r\n-\r\n-        int projs = getContext().getProjectionAliases().length;\r\n-        if (projs == 0) {\r\n-            // make sure the data cache contains the oids for the query result;\r\n-            // if it doesn't, then using the result could be slower than not\r\n-            // using it because of the individual by-oid lookups\r\n-            ClassMetaData meta = _repos.getMetaData(getContext().\r\n-                getCandidateType(), _sctx.getClassLoader(), true);\r\n-            if (meta.getDataCache() == null)\r\n-                return null;\r\n-\r\n-            BitSet idxs = meta.getDataCache().containsAll(res);\r\n-\r\n-            // eventually we should optimize this to figure out how many objects\r\n-            // the cache is missing and if only a few do a bulk fetch for them\r\n-            int len = idxs.length();\r\n-            if (len < res.size())\r\n-                return null;\r\n-            for (int i = 0; i < len; i++)\r\n-                if (!idxs.get(i))\r\n-                    return null;\r\n-        }\r\n-        return new CachedList(res, projs != 0, _sctx);\r\n-    }\r\n-\r\n-    /**\r\n-     * Wrap the result object provider returned by our delegate in a\r\n-     * caching provider.\r\n-     */\r\n-    private ResultObjectProvider wrapResult(ResultObjectProvider rop,\r\n-        QueryKey key) {\r\n-        if (key == null)\r\n-            return rop;\r\n-        return new CachingResultObjectProvider(rop, getContext().\r\n-            getProjectionAliases().length > 0, key);\r\n-    }\r\n-\r\n-    /**\r\n-     * Copy a projection element for caching / returning.\r\n-     */\r\n-    private static Object copyProjection(Object obj, StoreContext ctx) {\r\n-        if (obj == null)\r\n-            return null;\r\n-        switch (JavaTypes.getTypeCode(obj.getClass())) {\r\n-            case JavaTypes.STRING:\r\n-            case JavaTypes.BOOLEAN_OBJ:\r\n-            case JavaTypes.BYTE_OBJ:\r\n-            case JavaTypes.CHAR_OBJ:\r\n-            case JavaTypes.DOUBLE_OBJ:\r\n-            case JavaTypes.FLOAT_OBJ:\r\n-            case JavaTypes.INT_OBJ:\r\n-            case JavaTypes.LONG_OBJ:\r\n-            case JavaTypes.SHORT_OBJ:\r\n-            case JavaTypes.BIGDECIMAL:\r\n-            case JavaTypes.BIGINTEGER:\r\n-            case JavaTypes.OID:\r\n-                return obj;\r\n-            case JavaTypes.DATE:\r\n-                return ((Date) obj).clone();\r\n-            case JavaTypes.LOCALE:\r\n-                return ((Locale) obj).clone();\r\n-            default:\r\n-                if (obj instanceof CachedObjectId)\r\n-                    return fromObjectId(((CachedObjectId) obj).oid, ctx);\r\n-                Object oid = ctx.getObjectId(obj);\r\n-                if (oid != null)\r\n-                    return new CachedObjectId(oid);\r\n-                return obj;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the result object based on its cached oid.\r\n-     */\r\n-    private static Object fromObjectId(Object oid, StoreContext sctx) {\r\n-        if (oid == null)\r\n-            return null;\r\n-\r\n-        Object obj = sctx.find(oid, null, null, null, 0);\r\n-        if (obj == null)\r\n-            throw new ObjectNotFoundException(oid);\r\n-        return obj;\r\n-    }\r\n-\r\n-    public Object writeReplace()\r\n-        throws ObjectStreamException {\r\n-        return _query;\r\n-    }\r\n-\r\n-    public QueryContext getContext() {\r\n-        return _query.getContext();\r\n-    }\r\n-\r\n-    public void setContext(QueryContext qctx) {\r\n-        _query.setContext(qctx);\r\n-        _sctx = qctx.getStoreContext();\r\n-        _repos = _sctx.getConfiguration().getMetaDataRepositoryInstance();\r\n-    }\r\n-\r\n-    public boolean setQuery(Object query) {\r\n-        return _query.setQuery(query);\r\n-    }\r\n-\r\n-    public FilterListener getFilterListener(String tag) {\r\n-        return _query.getFilterListener(tag);\r\n-    }\r\n-\r\n-    public AggregateListener getAggregateListener(String tag) {\r\n-        return _query.getAggregateListener(tag);\r\n-    }\r\n-\r\n-    public Object newCompilationKey() {\r\n-        return _query.newCompilationKey();\r\n-    }\r\n-\r\n-    public Object newCompilation() {\r\n-        return _query.newCompilation();\r\n-    }\r\n-\r\n-    public void populateFromCompilation(Object comp) {\r\n-        _query.populateFromCompilation(comp);\r\n-    }\r\n-\r\n-    public void invalidateCompilation() {\r\n-        _query.invalidateCompilation();\r\n-    }\r\n-\r\n-    public boolean supportsDataStoreExecution() {\r\n-        return _query.supportsDataStoreExecution();\r\n-    }\r\n-\r\n-    public boolean supportsInMemoryExecution() {\r\n-        return _query.supportsInMemoryExecution();\r\n-    }\r\n-\r\n-    public Executor newInMemoryExecutor(ClassMetaData meta, boolean subs) {\r\n-        return _query.newInMemoryExecutor(meta, subs);\r\n-    }\r\n-\r\n-    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\r\n-        Executor ex = _query.newDataStoreExecutor(meta, subs);\r\n-        return new QueryCacheExecutor(ex, meta, subs);\r\n-    }\r\n-\r\n-    public boolean supportsAbstractExecutors() {\r\n-        return _query.supportsAbstractExecutors();\r\n-    }\r\n-\r\n-    public boolean requiresCandidateType() {\r\n-        return _query.requiresCandidateType();\r\n-    }\r\n-\r\n-    public boolean requiresParameterDeclarations() {\r\n-        return _query.requiresParameterDeclarations();\r\n-    }\r\n-\r\n-    public boolean supportsParameterDeclarations() {\r\n-        return _query.supportsParameterDeclarations();\r\n-    }\r\n- \r\n-    public Object evaluate(Object value, Object ob, Object[] params,\r\n-        OpenJPAStateManager sm) {\r\n-        return _query.evaluate(value, ob, params, sm);         \r\n-    }\r\n-\r\n-    /**\r\n-     * Caching executor.\r\n-     */\r\n-    private static class QueryCacheExecutor\r\n-        implements Executor {\r\n-\r\n-        private final Executor _ex;\r\n-        private final Class _candidate;\r\n-        private final boolean _subs;\r\n-\r\n-        public QueryCacheExecutor(Executor ex, ClassMetaData meta,\r\n-            boolean subs) {\r\n-            _ex = ex;\r\n-            _candidate = (meta == null) ? null : meta.getDescribedType();\r\n-            _subs = subs;\r\n-        }\r\n-\r\n-        public ResultObjectProvider executeQuery(StoreQuery q, Object[] params,\r\n-            Range range) {\r\n-            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\r\n-            QueryKey key = QueryKey.newInstance(cq.getContext(),\r\n-                _ex.isPacking(q), params, _candidate, _subs, range.start, \r\n-                range.end);\r\n-            List cached = cq.checkCache(key);\r\n-            if (cached != null)\r\n-                return new ListResultObjectProvider(cached);\r\n-\r\n-            ResultObjectProvider rop = _ex.executeQuery(cq.getDelegate(),\r\n-                params, range);\r\n-            return cq.wrapResult(rop, key);\r\n-        }\r\n-\r\n-        /**\r\n-         * Clear the cached queries associated with the access path\r\n-         * classes in the query. This is done when bulk operations\r\n-         * (such as deletes or updates) are performed so that the\r\n-         * cache remains up-to-date.\r\n-         */\r\n-        private void clearAccessPath(StoreQuery q) {\r\n-            if (q == null)\r\n-                return;\r\n-\r\n-            ClassMetaData[] cmd = getAccessPathMetaDatas(q);\r\n-            if (cmd == null || cmd.length == 0)\r\n-                return;\r\n-\r\n-            List classes = new ArrayList(cmd.length);\r\n-            for (int i = 0; i < cmd.length; i++)\r\n-                classes.add(cmd[i].getDescribedType());\r\n-\r\n-            // evict from the query cache\r\n-            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\r\n-            cq.getCache().onTypesChanged(new TypesChangedEvent\r\n-                (q.getContext(), classes));\r\n-\r\n-            // evict from the data cache\r\n-            for (int i = 0; i < cmd.length; i++) {\r\n-                if (cmd[i].getDataCache() != null)\r\n-                    cmd[i].getDataCache().removeAll(\r\n-                        cmd[i].getDescribedType(), true);\r\n-            }\r\n-        }\r\n-\r\n-        public Number executeDelete(StoreQuery q, Object[] params) {\r\n-            try {\r\n-                return _ex.executeDelete(unwrap(q), params);\r\n-            } finally {\r\n-                clearAccessPath(q);\r\n-            }\r\n-        }\r\n-\r\n-        public Number executeUpdate(StoreQuery q, Object[] params) {\r\n-            try {\r\n-                return _ex.executeUpdate(unwrap(q), params);\r\n-            } finally {\r\n-                clearAccessPath(q);\r\n-            }\r\n-        }\r\n-\r\n-        public String[] getDataStoreActions(StoreQuery q, Object[] params,\r\n-            Range range) {\r\n-            return EMPTY_STRINGS;\r\n-        }\r\n-\r\n-        public void validate(StoreQuery q) {\r\n-            _ex.validate(unwrap(q));\r\n-        }\r\n-        \r\n-        public void getRange(StoreQuery q, Object[] params, Range range) {\r\n-            _ex.getRange(q, params, range); \r\n-        }\r\n-\r\n-        public Object getOrderingValue(StoreQuery q, Object[] params,\r\n-            Object resultObject, int orderIndex) {\r\n-            return _ex.getOrderingValue(unwrap(q), params, resultObject,\r\n-                orderIndex);\r\n-        }\r\n-\r\n-        public boolean[] getAscending(StoreQuery q) {\r\n-            return _ex.getAscending(unwrap(q));\r\n-        }\r\n-\r\n-        public boolean isPacking(StoreQuery q) {\r\n-            return _ex.isPacking(unwrap(q));\r\n-        }\r\n-\r\n-        public String getAlias(StoreQuery q) {\r\n-            return _ex.getAlias(unwrap(q));\r\n-        }\r\n-\r\n-        public Class getResultClass(StoreQuery q) {\r\n-            return _ex.getResultClass(unwrap(q));\r\n-        }\r\n-\r\n-        public String[] getProjectionAliases(StoreQuery q) {\r\n-            return _ex.getProjectionAliases(unwrap(q));\r\n-        }\r\n-\r\n-        public Class[] getProjectionTypes(StoreQuery q) {\r\n-            return _ex.getProjectionTypes(unwrap(q));\r\n-        }\r\n-\r\n-        public ClassMetaData[] getAccessPathMetaDatas(StoreQuery q) {\r\n-            return _ex.getAccessPathMetaDatas(unwrap(q));\r\n-        }\r\n-\r\n-        public int getOperation(StoreQuery q) {\r\n-            return _ex.getOperation(unwrap(q));\r\n-        }\r\n-\r\n-        public boolean isAggregate(StoreQuery q) {\r\n-            return _ex.isAggregate(unwrap(q));\r\n-        }\r\n-\r\n-        public boolean hasGrouping(StoreQuery q) {\r\n-            return _ex.hasGrouping(unwrap(q));\r\n-        }\r\n-\r\n-        public LinkedMap getParameterTypes(StoreQuery q) {\r\n-            return _ex.getParameterTypes(unwrap(q));\r\n-        }\r\n-\r\n-        public Map getUpdates(StoreQuery q) {\r\n-            return _ex.getUpdates(unwrap(q));\r\n-        }\r\n-\r\n-        private static StoreQuery unwrap(StoreQuery q) {\r\n-            return ((QueryCacheStoreQuery) q).getDelegate();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Result list implementation for a cached query result. Package-protected\r\n-     * for testing.\r\n-     */\r\n-    public static class CachedList\r\n-        extends AbstractList\r\n-        implements Serializable {\r\n-\r\n-        private final QueryResult _res;\r\n-        private final boolean _proj;\r\n-        private final StoreContext _sctx;\r\n-\r\n-        public CachedList(QueryResult res, boolean proj, StoreContext ctx) {\r\n-            _res = res;\r\n-            _proj = proj;\r\n-            _sctx = ctx;\r\n-        }\r\n-\r\n-        public Object get(int idx) {\r\n-            if (!_proj)\r\n-                return fromObjectId(_res.get(idx), _sctx);\r\n-\r\n-            Object[] cached = (Object[]) _res.get(idx);\r\n-            if (cached == null)\r\n-                return null;\r\n-            Object[] uncached = new Object[cached.length];\r\n-            for (int i = 0; i < cached.length; i++)\r\n-                uncached[i] = copyProjection(cached[i], _sctx);\r\n-            return uncached;\r\n-        }\r\n-\r\n-        public int size() {\r\n-            return _res.size();\r\n-        }\r\n-\r\n-        public Object writeReplace()\r\n-            throws ObjectStreamException {\r\n-            return new ArrayList(this);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * A wrapper around a {@link ResultObjectProvider} that builds up a list of\r\n-     * all the OIDs in this list and registers that list with the\r\n-     * query cache. Abandons monitoring and registering if one of the classes\r\n-     * in the access path is modified while the query results are being loaded.\r\n-     */\r\n-    private class CachingResultObjectProvider\r\n-        implements ResultObjectProvider, TypesChangedListener {\r\n-\r\n-        private final ResultObjectProvider _rop;\r\n-        private final boolean _proj;\r\n-        private final QueryKey _qk;\r\n-        private final TreeMap _data = new TreeMap();\r\n-        private boolean _maintainCache = true;\r\n-        private int _pos = -1;\r\n-\r\n-        // used to determine list size without necessarily calling size(),\r\n-        // which may require a DB trip or return Integer.MAX_VALUE\r\n-        private int _max = -1;\r\n-        private int _size = Integer.MAX_VALUE;\r\n-\r\n-        /**\r\n-         * Constructor. Supply delegate result provider and our query key.\r\n-         */\r\n-        public CachingResultObjectProvider(ResultObjectProvider rop,\r\n-            boolean proj, QueryKey key) {\r\n-            _rop = rop;\r\n-            _proj = proj;\r\n-            _qk = key;\r\n-            _cache.addTypesChangedListener(this);\r\n-        }\r\n-\r\n-        /**\r\n-         * Stop caching.\r\n-         */\r\n-        private void abortCaching() {\r\n-            if (!_maintainCache)\r\n-                return;\r\n-\r\n-            // this can be called via an event from another thread\r\n-            synchronized (this) {\r\n-                // it's important that we set this flag first so that any\r\n-                // subsequent calls to this object are bypassed.\r\n-                _maintainCache = false;\r\n-                _cache.removeTypesChangedListener(this);\r\n-                _data.clear();\r\n-            }\r\n-        }\r\n-\r\n-        /**\r\n-         * Check whether we've buffered all results, while optionally adding\r\n-         * the given result.\r\n-         */\r\n-        private void checkFinished(Object obj, boolean result) {\r\n-            // this can be called at the same time as abortCaching via\r\n-            // a types changed event\r\n-            boolean finished = false;\r\n-            synchronized (this) {\r\n-                if (_maintainCache) {\r\n-                    if (result) {\r\n-                        Integer index = Numbers.valueOf(_pos);\r\n-                        if (!_data.containsKey(index)) {\r\n-                            Object cached;\r\n-                            if (obj == null)\r\n-                                cached = null;\r\n-                            else if (!_proj)\r\n-                                cached = _sctx.getObjectId(obj);\r\n-                            else {\r\n-                                Object[] arr = (Object[]) obj;\r\n-                                Object[] cp = new Object[arr.length];\r\n-                                for (int i = 0; i < arr.length; i++)\r\n-                                    cp[i] = copyProjection(arr[i], _sctx);\r\n-                                cached = cp;\r\n-                            }\r\n-                            if (cached != null)\r\n-                                _data.put(index, cached);\r\n-                        }\r\n-                    }\r\n-                    finished = _size == _data.size();\r\n-                }\r\n-            }\r\n-\r\n-            if (finished) {\r\n-                // an abortCaching call can sneak in here via onExpire; the\r\n-                // cache is locked during event firings, so the lock here will\r\n-                // wait for it (or will force the next firing to wait)\r\n-                _cache.writeLock();\r\n-                try {\r\n-                    // make sure we didn't abort\r\n-                    if (_maintainCache) {\r\n-                        QueryResult res = null;\r\n-                        synchronized (this) {\r\n-                            res = new QueryResult(_qk, _data.values());\r\n-                        }\r\n-                        _cache.put(_qk, res);\r\n-                        abortCaching();\r\n-                    }\r\n-                }\r\n-                finally {\r\n-                    _cache.writeUnlock();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        public boolean supportsRandomAccess() {\r\n-            return _rop.supportsRandomAccess();\r\n-        }\r\n-\r\n-        public void open()\r\n-            throws Exception {\r\n-            _rop.open();\r\n-        }\r\n-\r\n-        public Object getResultObject()\r\n-            throws Exception {\r\n-            Object obj = _rop.getResultObject();\r\n-            checkFinished(obj, true);\r\n-            return obj;\r\n-        }\r\n-\r\n-        public boolean next()\r\n-            throws Exception {\r\n-            _pos++;\r\n-            boolean next = _rop.next();\r\n-            if (!next && _pos == _max + 1) {\r\n-                _size = _pos;\r\n-                checkFinished(null, false);\r\n-            } else if (next && _pos > _max)\r\n-                _max = _pos;\r\n-            return next;\r\n-        }\r\n-\r\n-        public boolean absolute(int pos)\r\n-            throws Exception {\r\n-            _pos = pos;\r\n-            boolean valid = _rop.absolute(pos);\r\n-            if (!valid && _pos == _max + 1) {\r\n-                _size = _pos;\r\n-                checkFinished(null, false);\r\n-            } else if (valid && _pos > _max)\r\n-                _max = _pos;\r\n-            return valid;\r\n-        }\r\n-\r\n-        public int size()\r\n-            throws Exception {\r\n-            if (_size != Integer.MAX_VALUE)\r\n-                return _size;\r\n-            int size = _rop.size();\r\n-            _size = size;\r\n-            checkFinished(null, false);\r\n-            return size;\r\n-        }\r\n-\r\n-        public void reset()\r\n-            throws Exception {\r\n-            _rop.reset();\r\n-            _pos = -1;\r\n-        }\r\n-\r\n-        public void close()\r\n-            throws Exception {\r\n-            abortCaching();\r\n-            _rop.close();\r\n-        }\r\n-\r\n-        public void handleCheckedException(Exception e) {\r\n-            _rop.handleCheckedException(e);\r\n-        }\r\n-\r\n-        public void onTypesChanged(TypesChangedEvent ev) {\r\n-            if (_qk.changeInvalidatesQuery(ev.getTypes()))\r\n-                abortCaching();\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Struct to recognize cached oids.\r\n-     */\r\n-    private static class CachedObjectId {\r\n-\r\n-        public final Object oid;\r\n-\r\n-        public CachedObjectId (Object oid)\r\n-\t\t{\r\n-\t\t\tthis.oid = oid;\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.datacache;\n+\n+import java.io.ObjectStreamException;\n+import java.io.Serializable;\n+import java.util.AbstractList;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.map.LinkedMap;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.LockLevels;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.QueryContext;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.kernel.StoreQuery;\n+import org.apache.openjpa.kernel.exps.AggregateListener;\n+import org.apache.openjpa.kernel.exps.FilterListener;\n+import org.apache.openjpa.lib.rop.ListResultObjectProvider;\n+import org.apache.openjpa.lib.rop.ResultObjectProvider;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.meta.MetaDataRepository;\n+import org.apache.openjpa.util.ObjectNotFoundException;\n+\n+import serp.util.Numbers;\n+\n+/**\n+ * A {@link StoreQuery} implementation that caches the OIDs involved in\n+ * the query, and can determine whether or not the query has been dirtied.\n+ *\n+ * @author Patrick Linskey\n+ * @since 0.2.5.0\n+ */\n+public class QueryCacheStoreQuery\n+    implements StoreQuery {\n+\n+    private final StoreQuery _query;\n+    private final QueryCache _cache;\n+    private StoreContext _sctx;\n+    private MetaDataRepository _repos;\n+\n+    /**\n+     * Create a new instance that delegates to <code>query</code> if no\n+     * cached results are available.\n+     */\n+    public QueryCacheStoreQuery(StoreQuery query, QueryCache cache) {\n+        _query = query;\n+        _cache = cache;\n+    }\n+\n+    /**\n+     * Return the {@link QueryCache} that this object is associated with.\n+     */\n+    public QueryCache getCache() {\n+        return _cache;\n+    }\n+\n+    /**\n+     * Delegate.\n+     */\n+    public StoreQuery getDelegate() {\n+        return _query;\n+    }\n+\n+    /**\n+     * Look in the query cache for a result for the given query\n+     * key. Only look if this query is being executed outside a\n+     * transaction or in a transaction with IgnoreChanges set to true\n+     * or in a transaction with IgnoreChanges set to false but in which\n+     * none of the classes involved in this query have been touched.\n+     *  Caching is not used when using object locking.\n+     * This is because we must obtain locks on the\n+     * data, and it is likely that making n trips to the database to\n+     * make the locks will be slower than running the query against\n+     * the database.\n+     *  If the fetch configuration has query caching disabled,\n+     * then this method returns <code>null</code>.\n+     *  Return the list if we meet the above criteria and if a list\n+     * is found for <code>qk</code>. Else, return\n+     * <code>null</code>.\n+     *  This implementation means that queries against the cache\n+     * are of READ_COMMITTED isolation level. It'd be nice to support\n+     * READ_SERIALIZABLE -- to do so, we'd just return false when in\n+     * a transaction.\n+     */\n+    private List checkCache(QueryKey qk) {\n+        if (qk == null)\n+            return null;\n+        FetchConfiguration fetch = getContext().getFetchConfiguration();\n+        if (!fetch.getQueryCacheEnabled())\n+            return null;\n+        if (fetch.getReadLockLevel() > LockLevels.LOCK_NONE)\n+            return null;\n+\n+        // get the cached data\n+        QueryResult res = _cache.get(qk);\n+        if (res == null)\n+            return null;\n+        if (res.isEmpty())\n+            return Collections.EMPTY_LIST;\n+\n+        int projs = getContext().getProjectionAliases().length;\n+        if (projs == 0) {\n+            // make sure the data cache contains the oids for the query result;\n+            // if it doesn't, then using the result could be slower than not\n+            // using it because of the individual by-oid lookups\n+            ClassMetaData meta = _repos.getMetaData(getContext().\n+                getCandidateType(), _sctx.getClassLoader(), true);\n+            if (meta.getDataCache() == null)\n+                return null;\n+\n+            BitSet idxs = meta.getDataCache().containsAll(res);\n+\n+            // eventually we should optimize this to figure out how many objects\n+            // the cache is missing and if only a few do a bulk fetch for them\n+            int len = idxs.length();\n+            if (len < res.size())\n+                return null;\n+            for (int i = 0; i < len; i++)\n+                if (!idxs.get(i))\n+                    return null;\n+        }\n+        return new CachedList(res, projs != 0, _sctx);\n+    }\n+\n+    /**\n+     * Wrap the result object provider returned by our delegate in a\n+     * caching provider.\n+     */\n+    private ResultObjectProvider wrapResult(ResultObjectProvider rop,\n+        QueryKey key) {\n+        if (key == null)\n+            return rop;\n+        return new CachingResultObjectProvider(rop, getContext().\n+            getProjectionAliases().length > 0, key);\n+    }\n+\n+    /**\n+     * Copy a projection element for caching / returning.\n+     */\n+    private static Object copyProjection(Object obj, StoreContext ctx) {\n+        if (obj == null)\n+            return null;\n+        switch (JavaTypes.getTypeCode(obj.getClass())) {\n+            case JavaTypes.STRING:\n+            case JavaTypes.BOOLEAN_OBJ:\n+            case JavaTypes.BYTE_OBJ:\n+            case JavaTypes.CHAR_OBJ:\n+            case JavaTypes.DOUBLE_OBJ:\n+            case JavaTypes.FLOAT_OBJ:\n+            case JavaTypes.INT_OBJ:\n+            case JavaTypes.LONG_OBJ:\n+            case JavaTypes.SHORT_OBJ:\n+            case JavaTypes.BIGDECIMAL:\n+            case JavaTypes.BIGINTEGER:\n+            case JavaTypes.OID:\n+                return obj;\n+            case JavaTypes.DATE:\n+                return ((Date) obj).clone();\n+            case JavaTypes.LOCALE:\n+                return ((Locale) obj).clone();\n+            default:\n+                if (obj instanceof CachedObjectId)\n+                    return fromObjectId(((CachedObjectId) obj).oid, ctx);\n+                Object oid = ctx.getObjectId(obj);\n+                if (oid != null)\n+                    return new CachedObjectId(oid);\n+                return obj;\n+        }\n+    }\n+\n+    /**\n+     * Return the result object based on its cached oid.\n+     */\n+    private static Object fromObjectId(Object oid, StoreContext sctx) {\n+        if (oid == null)\n+            return null;\n+\n+        Object obj = sctx.find(oid, null, null, null, 0);\n+        if (obj == null)\n+            throw new ObjectNotFoundException(oid);\n+        return obj;\n+    }\n+\n+    public Object writeReplace()\n+        throws ObjectStreamException {\n+        return _query;\n+    }\n+\n+    public QueryContext getContext() {\n+        return _query.getContext();\n+    }\n+\n+    public void setContext(QueryContext qctx) {\n+        _query.setContext(qctx);\n+        _sctx = qctx.getStoreContext();\n+        _repos = _sctx.getConfiguration().getMetaDataRepositoryInstance();\n+    }\n+\n+    public boolean setQuery(Object query) {\n+        return _query.setQuery(query);\n+    }\n+\n+    public FilterListener getFilterListener(String tag) {\n+        return _query.getFilterListener(tag);\n+    }\n+\n+    public AggregateListener getAggregateListener(String tag) {\n+        return _query.getAggregateListener(tag);\n+    }\n+\n+    public Object newCompilationKey() {\n+        return _query.newCompilationKey();\n+    }\n+\n+    public Object newCompilation() {\n+        return _query.newCompilation();\n+    }\n+\n+    public void populateFromCompilation(Object comp) {\n+        _query.populateFromCompilation(comp);\n+    }\n+\n+    public void invalidateCompilation() {\n+        _query.invalidateCompilation();\n+    }\n+\n+    public boolean supportsDataStoreExecution() {\n+        return _query.supportsDataStoreExecution();\n+    }\n+\n+    public boolean supportsInMemoryExecution() {\n+        return _query.supportsInMemoryExecution();\n+    }\n+\n+    public Executor newInMemoryExecutor(ClassMetaData meta, boolean subs) {\n+        return _query.newInMemoryExecutor(meta, subs);\n+    }\n+\n+    public Executor newDataStoreExecutor(ClassMetaData meta, boolean subs) {\n+        Executor ex = _query.newDataStoreExecutor(meta, subs);\n+        return new QueryCacheExecutor(ex, meta, subs);\n+    }\n+\n+    public boolean supportsAbstractExecutors() {\n+        return _query.supportsAbstractExecutors();\n+    }\n+\n+    public boolean requiresCandidateType() {\n+        return _query.requiresCandidateType();\n+    }\n+\n+    public boolean requiresParameterDeclarations() {\n+        return _query.requiresParameterDeclarations();\n+    }\n+\n+    public boolean supportsParameterDeclarations() {\n+        return _query.supportsParameterDeclarations();\n+    }\n+ \n+    public Object evaluate(Object value, Object ob, Object[] params,\n+        OpenJPAStateManager sm) {\n+        return _query.evaluate(value, ob, params, sm);         \n+    }\n+\n+    /**\n+     * Caching executor.\n+     */\n+    private static class QueryCacheExecutor\n+        implements Executor {\n+\n+        private final Executor _ex;\n+        private final Class _candidate;\n+        private final boolean _subs;\n+\n+        public QueryCacheExecutor(Executor ex, ClassMetaData meta,\n+            boolean subs) {\n+            _ex = ex;\n+            _candidate = (meta == null) ? null : meta.getDescribedType();\n+            _subs = subs;\n+        }\n+\n+        public ResultObjectProvider executeQuery(StoreQuery q, Object[] params,\n+            Range range) {\n+            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\n+            QueryKey key = QueryKey.newInstance(cq.getContext(),\n+                _ex.isPacking(q), params, _candidate, _subs, range.start, \n+                range.end);\n+            List cached = cq.checkCache(key);\n+            if (cached != null)\n+                return new ListResultObjectProvider(cached);\n+\n+            ResultObjectProvider rop = _ex.executeQuery(cq.getDelegate(),\n+                params, range);\n+            return cq.wrapResult(rop, key);\n+        }\n+\n+        /**\n+         * Clear the cached queries associated with the access path\n+         * classes in the query. This is done when bulk operations\n+         * (such as deletes or updates) are performed so that the\n+         * cache remains up-to-date.\n+         */\n+        private void clearAccessPath(StoreQuery q) {\n+            if (q == null)\n+                return;\n+\n+            ClassMetaData[] cmd = getAccessPathMetaDatas(q);\n+            if (cmd == null || cmd.length == 0)\n+                return;\n+\n+            List classes = new ArrayList(cmd.length);\n+            for (int i = 0; i < cmd.length; i++)\n+                classes.add(cmd[i].getDescribedType());\n+\n+            // evict from the query cache\n+            QueryCacheStoreQuery cq = (QueryCacheStoreQuery) q;\n+            cq.getCache().onTypesChanged(new TypesChangedEvent\n+                (q.getContext(), classes));\n+\n+            // evict from the data cache\n+            for (int i = 0; i < cmd.length; i++) {\n+                if (cmd[i].getDataCache() != null)\n+                    cmd[i].getDataCache().removeAll(\n+                        cmd[i].getDescribedType(), true);\n+            }\n+        }\n+\n+        public Number executeDelete(StoreQuery q, Object[] params) {\n+            try {\n+                return _ex.executeDelete(unwrap(q), params);\n+            } finally {\n+                clearAccessPath(q);\n+            }\n+        }\n+\n+        public Number executeUpdate(StoreQuery q, Object[] params) {\n+            try {\n+                return _ex.executeUpdate(unwrap(q), params);\n+            } finally {\n+                clearAccessPath(q);\n+            }\n+        }\n+\n+        public String[] getDataStoreActions(StoreQuery q, Object[] params,\n+            Range range) {\n+            return EMPTY_STRINGS;\n+        }\n+\n+        public void validate(StoreQuery q) {\n+            _ex.validate(unwrap(q));\n+        }\n+        \n+        public void getRange(StoreQuery q, Object[] params, Range range) {\n+            _ex.getRange(q, params, range); \n+        }\n+\n+        public Object getOrderingValue(StoreQuery q, Object[] params,\n+            Object resultObject, int orderIndex) {\n+            return _ex.getOrderingValue(unwrap(q), params, resultObject,\n+                orderIndex);\n+        }\n+\n+        public boolean[] getAscending(StoreQuery q) {\n+            return _ex.getAscending(unwrap(q));\n+        }\n+\n+        public boolean isPacking(StoreQuery q) {\n+            return _ex.isPacking(unwrap(q));\n+        }\n+\n+        public String getAlias(StoreQuery q) {\n+            return _ex.getAlias(unwrap(q));\n+        }\n+\n+        public Class getResultClass(StoreQuery q) {\n+            return _ex.getResultClass(unwrap(q));\n+        }\n+\n+        public String[] getProjectionAliases(StoreQuery q) {\n+            return _ex.getProjectionAliases(unwrap(q));\n+        }\n+\n+        public Class[] getProjectionTypes(StoreQuery q) {\n+            return _ex.getProjectionTypes(unwrap(q));\n+        }\n+\n+        public ClassMetaData[] getAccessPathMetaDatas(StoreQuery q) {\n+            return _ex.getAccessPathMetaDatas(unwrap(q));\n+        }\n+\n+        public int getOperation(StoreQuery q) {\n+            return _ex.getOperation(unwrap(q));\n+        }\n+\n+        public boolean isAggregate(StoreQuery q) {\n+            return _ex.isAggregate(unwrap(q));\n+        }\n+\n+        public boolean hasGrouping(StoreQuery q) {\n+            return _ex.hasGrouping(unwrap(q));\n+        }\n+\n+        public LinkedMap getParameterTypes(StoreQuery q) {\n+            return _ex.getParameterTypes(unwrap(q));\n+        }\n+\n+        public Map getUpdates(StoreQuery q) {\n+            return _ex.getUpdates(unwrap(q));\n+        }\n+\n+        private static StoreQuery unwrap(StoreQuery q) {\n+            return ((QueryCacheStoreQuery) q).getDelegate();\n+        }\n+    }\n+\n+    /**\n+     * Result list implementation for a cached query result. Package-protected\n+     * for testing.\n+     */\n+    public static class CachedList\n+        extends AbstractList\n+        implements Serializable {\n+\n+        private final QueryResult _res;\n+        private final boolean _proj;\n+        private final StoreContext _sctx;\n+\n+        public CachedList(QueryResult res, boolean proj, StoreContext ctx) {\n+            _res = res;\n+            _proj = proj;\n+            _sctx = ctx;\n+        }\n+\n+        public Object get(int idx) {\n+            if (!_proj)\n+                return fromObjectId(_res.get(idx), _sctx);\n+\n+            Object[] cached = (Object[]) _res.get(idx);\n+            if (cached == null)\n+                return null;\n+            Object[] uncached = new Object[cached.length];\n+            for (int i = 0; i < cached.length; i++)\n+                uncached[i] = copyProjection(cached[i], _sctx);\n+            return uncached;\n+        }\n+\n+        public int size() {\n+            return _res.size();\n+        }\n+\n+        public Object writeReplace()\n+            throws ObjectStreamException {\n+            return new ArrayList(this);\n+        }\n+    }\n+\n+    /**\n+     * A wrapper around a {@link ResultObjectProvider} that builds up a list of\n+     * all the OIDs in this list and registers that list with the\n+     * query cache. Abandons monitoring and registering if one of the classes\n+     * in the access path is modified while the query results are being loaded.\n+     */\n+    private class CachingResultObjectProvider\n+        implements ResultObjectProvider, TypesChangedListener {\n+\n+        private final ResultObjectProvider _rop;\n+        private final boolean _proj;\n+        private final QueryKey _qk;\n+        private final TreeMap _data = new TreeMap();\n+        private boolean _maintainCache = true;\n+        private int _pos = -1;\n+\n+        // used to determine list size without necessarily calling size(),\n+        // which may require a DB trip or return Integer.MAX_VALUE\n+        private int _max = -1;\n+        private int _size = Integer.MAX_VALUE;\n+\n+        /**\n+         * Constructor. Supply delegate result provider and our query key.\n+         */\n+        public CachingResultObjectProvider(ResultObjectProvider rop,\n+            boolean proj, QueryKey key) {\n+            _rop = rop;\n+            _proj = proj;\n+            _qk = key;\n+            _cache.addTypesChangedListener(this);\n+        }\n+\n+        /**\n+         * Stop caching.\n+         */\n+        private void abortCaching() {\n+            if (!_maintainCache)\n+                return;\n+\n+            // this can be called via an event from another thread\n+            synchronized (this) {\n+                // it's important that we set this flag first so that any\n+                // subsequent calls to this object are bypassed.\n+                _maintainCache = false;\n+                _cache.removeTypesChangedListener(this);\n+                _data.clear();\n+            }\n+        }\n+\n+        /**\n+         * Check whether we've buffered all results, while optionally adding\n+         * the given result.\n+         */\n+        private void checkFinished(Object obj, boolean result) {\n+            // this can be called at the same time as abortCaching via\n+            // a types changed event\n+            boolean finished = false;\n+            synchronized (this) {\n+                if (_maintainCache) {\n+                    if (result) {\n+                        Integer index = Numbers.valueOf(_pos);\n+                        if (!_data.containsKey(index)) {\n+                            Object cached;\n+                            if (obj == null)\n+                                cached = null;\n+                            else if (!_proj)\n+                                cached = _sctx.getObjectId(obj);\n+                            else {\n+                                Object[] arr = (Object[]) obj;\n+                                Object[] cp = new Object[arr.length];\n+                                for (int i = 0; i < arr.length; i++)\n+                                    cp[i] = copyProjection(arr[i], _sctx);\n+                                cached = cp;\n+                            }\n+                            if (cached != null)\n+                                _data.put(index, cached);\n+                        }\n+                    }\n+                    finished = _size == _data.size();\n+                }\n+            }\n+\n+            if (finished) {\n+                // an abortCaching call can sneak in here via onExpire; the\n+                // cache is locked during event firings, so the lock here will\n+                // wait for it (or will force the next firing to wait)\n+                _cache.writeLock();\n+                try {\n+                    // make sure we didn't abort\n+                    if (_maintainCache) {\n+                        QueryResult res = null;\n+                        synchronized (this) {\n+                            res = new QueryResult(_qk, _data.values());\n+                        }\n+                        _cache.put(_qk, res);\n+                        abortCaching();\n+                    }\n+                }\n+                finally {\n+                    _cache.writeUnlock();\n+                }\n+            }\n+        }\n+\n+        public boolean supportsRandomAccess() {\n+            return _rop.supportsRandomAccess();\n+        }\n+\n+        public void open()\n+            throws Exception {\n+            _rop.open();\n+        }\n+\n+        public Object getResultObject()\n+            throws Exception {\n+            Object obj = _rop.getResultObject();\n+            checkFinished(obj, true);\n+            return obj;\n+        }\n+\n+        public boolean next()\n+            throws Exception {\n+            _pos++;\n+            boolean next = _rop.next();\n+            if (!next && _pos == _max + 1) {\n+                _size = _pos;\n+                checkFinished(null, false);\n+            } else if (next && _pos > _max)\n+                _max = _pos;\n+            return next;\n+        }\n+\n+        public boolean absolute(int pos)\n+            throws Exception {\n+            _pos = pos;\n+            boolean valid = _rop.absolute(pos);\n+            if (!valid && _pos == _max + 1) {\n+                _size = _pos;\n+                checkFinished(null, false);\n+            } else if (valid && _pos > _max)\n+                _max = _pos;\n+            return valid;\n+        }\n+\n+        public int size()\n+            throws Exception {\n+            if (_size != Integer.MAX_VALUE)\n+                return _size;\n+            int size = _rop.size();\n+            _size = size;\n+            checkFinished(null, false);\n+            return size;\n+        }\n+\n+        public void reset()\n+            throws Exception {\n+            _rop.reset();\n+            _pos = -1;\n+        }\n+\n+        public void close()\n+            throws Exception {\n+            abortCaching();\n+            _rop.close();\n+        }\n+\n+        public void handleCheckedException(Exception e) {\n+            _rop.handleCheckedException(e);\n+        }\n+\n+        public void onTypesChanged(TypesChangedEvent ev) {\n+            if (_qk.changeInvalidatesQuery(ev.getTypes()))\n+                abortCaching();\n+        }\n+    }\n+\n+    /**\n+     * Struct to recognize cached oids.\n+     */\n+    private static class CachedObjectId {\n+\n+        public final Object oid;\n+\n+        public CachedObjectId (Object oid)\n+\t\t{\n+\t\t\tthis.oid = oid;\n+\t\t}\n+\t}\n+}"},{"sha":"3904232254b3c6af09c6ebad37e46f7795acdc6f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","status":"modified","additions":31,"deletions":31,"changes":62,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/AttributeTranslator.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,31 +1,31 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Instances of this interface can convert a positional index for a\r\n- * {@link FieldMetaData} that uses property access into the underlying\r\n- * field name. Instances of {@link DynamicPersistenceCapable} for types\r\n- * that use property access will implement this interface.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface AttributeTranslator {\r\n-    public String pcAttributeIndexToFieldName(int i);\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Instances of this interface can convert a positional index for a\n+ * {@link FieldMetaData} that uses property access into the underlying\n+ * field name. Instances of {@link DynamicPersistenceCapable} for types\n+ * that use property access will implement this interface.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface AttributeTranslator {\n+    public String pcAttributeIndexToFieldName(int i);\n+}"},{"sha":"66fa6057c6af1df883d1dd1b1114f7b6f974c7a4","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","status":"modified","additions":151,"deletions":151,"changes":302,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ClassRedefiner.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,152 +1,152 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.lang.instrument.Instrumentation;\r\n-import java.lang.instrument.ClassFileTransformer;\r\n-import java.lang.instrument.ClassDefinition;\r\n-import java.lang.instrument.UnmodifiableClassException;\r\n-import java.lang.reflect.InvocationTargetException;\r\n-import java.lang.reflect.Method;\r\n-import java.security.ProtectionDomain;\r\n-import java.util.Map;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.ArrayList;\r\n-import java.io.IOException;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.util.JavaVersions;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.UserException;\r\n-\r\n-/**\r\n- * Redefines the method bodies of existing classes. Supports Java 5 VMs that\r\n- * have a javaagent installed on the command line as well as newer VMs without\r\n- * any javaagent flag.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class ClassRedefiner {\r\n-\r\n-    private static final Localizer _loc = \r\n-        Localizer.forPackage(ClassRedefiner.class);\r\n-\r\n-    private static Boolean _canRedefine = null;\r\n-\r\n-    /**\r\n-     * For each element in <code>classes</code>, this method will redefine\r\n-     * all the element's methods such that field accesses are intercepted\r\n-     * in-line. If {@link #canRedefineClasses()} returns <code>false</code>,\r\n-     * this method is a no-op.\r\n-     */\r\n-    public static void redefineClasses(OpenJPAConfiguration conf,\r\n-        final Map<Class,byte[]> classes) {\r\n-        if (classes == null || classes.size() == 0 || !canRedefineClasses())\r\n-            return;\r\n-\r\n-        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n-        Instrumentation inst = null;\r\n-        ClassFileTransformer t = null;\r\n-        try {\r\n-            inst = InstrumentationFactory.getInstrumentation();\r\n-\r\n-            Class[] array = classes.keySet().toArray(new Class[classes.size()]);\r\n-            if (JavaVersions.VERSION >= 6) {\r\n-                log.trace(_loc.get(\"retransform-types\", classes.keySet()));\r\n-\r\n-                t = new ClassFileTransformer() {\r\n-                    public byte[] transform(ClassLoader loader, String clsName,\r\n-                        Class<?> classBeingRedefined, ProtectionDomain pd,\r\n-                        byte[] classfileBuffer) {\r\n-                        return classes.get(classBeingRedefined);\r\n-                    }\r\n-                };\r\n-                \r\n-                // these are Java 6 methods, and we don't have a Java 6 build\r\n-                // module yet. The cost of reflection here is negligible\r\n-                // compared to the redefinition / enhancement costs in total,\r\n-                // so this should not be a big problem.\r\n-                Method meth = inst.getClass().getMethod(\"addTransformer\",\r\n-                    new Class[] { ClassFileTransformer.class, boolean.class });\r\n-                meth.invoke(inst, new Object[] { t, true });\r\n-                meth = inst.getClass().getMethod(\"retransformClasses\",\r\n-                    new Class[] { array.getClass() });\r\n-                meth.invoke(inst, new Object[] { array });\r\n-            } else {\r\n-                log.trace(_loc.get(\"redefine-types\", classes.keySet()));\r\n-                // in a Java 5 context, we can use class redefinition instead\r\n-                ClassDefinition[] defs = new ClassDefinition[array.length];\r\n-                for (int i = 0; i < defs.length; i++)\r\n-                    defs[i] = new ClassDefinition(array[i],\r\n-                        classes.get(array[i]));\r\n-                inst.redefineClasses(defs);\r\n-            }\r\n-        } catch (NoSuchMethodException e) {\r\n-            throw new InternalException(e);\r\n-        } catch (IllegalAccessException e) {\r\n-            throw new InternalException(e);\r\n-        } catch (InvocationTargetException e) {\r\n-            throw new UserException(e.getCause());\r\n-        } catch (IOException e) {\r\n-            throw new InternalException(e);\r\n-        } catch (ClassNotFoundException e) {\r\n-            throw new InternalException(e);\r\n-        } catch (UnmodifiableClassException e) {\r\n-            throw new InternalException(e);\r\n-        } finally {\r\n-            if (inst != null && t != null)\r\n-                inst.removeTransformer(t);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @return whether or not this VM has an instrumentation installed that\r\n-     * permits redefinition of classes. This assumes that all the arguments\r\n-     * will be modifiable classes according to\r\n-     * {@link java.lang.instrument.Instrumentation#isModifiableClass}, and\r\n-     * only checks whether or not an instrumentation is available and\r\n-     * if retransformation is possible.\r\n-     */\r\n-    public static boolean canRedefineClasses() {\r\n-        if (_canRedefine == null) {\r\n-            try {\r\n-                Instrumentation inst = InstrumentationFactory\r\n-                    .getInstrumentation();\r\n-                if (inst == null) {\r\n-                    _canRedefine = Boolean.FALSE;\r\n-                } else if (JavaVersions.VERSION == 5) {\r\n-                    // if inst is non-null and we're using Java 5,\r\n-                    // isRetransformClassesSupported isn't available,\r\n-                    // so we use the more basic class redefinition\r\n-                    // instead.\r\n-                    _canRedefine = Boolean.TRUE;\r\n-                } else {\r\n-                    _canRedefine = (Boolean) Instrumentation.class.getMethod(\r\n-                        \"isRetransformClassesSupported\").invoke(inst);\r\n-                }\r\n-            } catch (Exception e) {\r\n-                _canRedefine = Boolean.FALSE;\r\n-            }\r\n-        }\r\n-        return _canRedefine.booleanValue();\r\n-    }\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.lang.instrument.Instrumentation;\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.ClassDefinition;\n+import java.lang.instrument.UnmodifiableClassException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.ArrayList;\n+import java.io.IOException;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.util.JavaVersions;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.UserException;\n+\n+/**\n+ * Redefines the method bodies of existing classes. Supports Java 5 VMs that\n+ * have a javaagent installed on the command line as well as newer VMs without\n+ * any javaagent flag.\n+ *\n+ * @since 1.0.0\n+ */\n+public class ClassRedefiner {\n+\n+    private static final Localizer _loc = \n+        Localizer.forPackage(ClassRedefiner.class);\n+\n+    private static Boolean _canRedefine = null;\n+\n+    /**\n+     * For each element in <code>classes</code>, this method will redefine\n+     * all the element's methods such that field accesses are intercepted\n+     * in-line. If {@link #canRedefineClasses()} returns <code>false</code>,\n+     * this method is a no-op.\n+     */\n+    public static void redefineClasses(OpenJPAConfiguration conf,\n+        final Map<Class,byte[]> classes) {\n+        if (classes == null || classes.size() == 0 || !canRedefineClasses())\n+            return;\n+\n+        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\n+        Instrumentation inst = null;\n+        ClassFileTransformer t = null;\n+        try {\n+            inst = InstrumentationFactory.getInstrumentation();\n+\n+            Class[] array = classes.keySet().toArray(new Class[classes.size()]);\n+            if (JavaVersions.VERSION >= 6) {\n+                log.trace(_loc.get(\"retransform-types\", classes.keySet()));\n+\n+                t = new ClassFileTransformer() {\n+                    public byte[] transform(ClassLoader loader, String clsName,\n+                        Class<?> classBeingRedefined, ProtectionDomain pd,\n+                        byte[] classfileBuffer) {\n+                        return classes.get(classBeingRedefined);\n+                    }\n+                };\n+                \n+                // these are Java 6 methods, and we don't have a Java 6 build\n+                // module yet. The cost of reflection here is negligible\n+                // compared to the redefinition / enhancement costs in total,\n+                // so this should not be a big problem.\n+                Method meth = inst.getClass().getMethod(\"addTransformer\",\n+                    new Class[] { ClassFileTransformer.class, boolean.class });\n+                meth.invoke(inst, new Object[] { t, true });\n+                meth = inst.getClass().getMethod(\"retransformClasses\",\n+                    new Class[] { array.getClass() });\n+                meth.invoke(inst, new Object[] { array });\n+            } else {\n+                log.trace(_loc.get(\"redefine-types\", classes.keySet()));\n+                // in a Java 5 context, we can use class redefinition instead\n+                ClassDefinition[] defs = new ClassDefinition[array.length];\n+                for (int i = 0; i < defs.length; i++)\n+                    defs[i] = new ClassDefinition(array[i],\n+                        classes.get(array[i]));\n+                inst.redefineClasses(defs);\n+            }\n+        } catch (NoSuchMethodException e) {\n+            throw new InternalException(e);\n+        } catch (IllegalAccessException e) {\n+            throw new InternalException(e);\n+        } catch (InvocationTargetException e) {\n+            throw new UserException(e.getCause());\n+        } catch (IOException e) {\n+            throw new InternalException(e);\n+        } catch (ClassNotFoundException e) {\n+            throw new InternalException(e);\n+        } catch (UnmodifiableClassException e) {\n+            throw new InternalException(e);\n+        } finally {\n+            if (inst != null && t != null)\n+                inst.removeTransformer(t);\n+        }\n+    }\n+\n+    /**\n+     * @return whether or not this VM has an instrumentation installed that\n+     * permits redefinition of classes. This assumes that all the arguments\n+     * will be modifiable classes according to\n+     * {@link java.lang.instrument.Instrumentation#isModifiableClass}, and\n+     * only checks whether or not an instrumentation is available and\n+     * if retransformation is possible.\n+     */\n+    public static boolean canRedefineClasses() {\n+        if (_canRedefine == null) {\n+            try {\n+                Instrumentation inst = InstrumentationFactory\n+                    .getInstrumentation();\n+                if (inst == null) {\n+                    _canRedefine = Boolean.FALSE;\n+                } else if (JavaVersions.VERSION == 5) {\n+                    // if inst is non-null and we're using Java 5,\n+                    // isRetransformClassesSupported isn't available,\n+                    // so we use the more basic class redefinition\n+                    // instead.\n+                    _canRedefine = Boolean.TRUE;\n+                } else {\n+                    _canRedefine = (Boolean) Instrumentation.class.getMethod(\n+                        \"isRetransformClassesSupported\").invoke(inst);\n+                }\n+            } catch (Exception e) {\n+                _canRedefine = Boolean.FALSE;\n+            }\n+        }\n+        return _canRedefine.booleanValue();\n+    }\n }\n\\ No newline at end of file"},{"sha":"78614624c6c833d8ecaa23f13903ad1c11a50d5a","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/DynamicPersistenceCapable.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,28 +1,28 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Instances that implement this marker interface are dynamically-generated\r\n- * subtypes of managed types that were loaded before being enhanced.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface DynamicPersistenceCapable {\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Instances that implement this marker interface are dynamically-generated\n+ * subtypes of managed types that were loaded before being enhanced.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface DynamicPersistenceCapable {\n+}"},{"sha":"f7f4d44cffc234752c58d0975cdd1e6a1f203eab","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","status":"modified","additions":302,"deletions":302,"changes":604,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedClassSubclasser.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,302 +1,302 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.io.File;\r\n-import java.io.IOException;\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.HashMap;\r\n-import java.util.HashSet;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Set;\r\n-\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.BytecodeWriter;\r\n-import org.apache.openjpa.lib.util.JavaVersions;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.Files;\r\n-import org.apache.openjpa.lib.util.Localizer.Message;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.util.GeneratedClasses;\r\n-import org.apache.openjpa.util.ImplHelper;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.util.UserException;\r\n-import serp.bytecode.BCClass;\r\n-\r\n-/**\r\n- * Redefines the method bodies of existing unenhanced classes to make them\r\n- * notify state managers of mutations.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public class ManagedClassSubclasser {\r\n-    private static final Localizer _loc = Localizer.forPackage(\r\n-        ManagedClassSubclasser.class);\r\n-\r\n-    /**\r\n-     * For each element in <code>classes</code>, creates and registers a\r\n-     * new subclass that implements {@link PersistenceCapable}, and prepares\r\n-     * OpenJPA to handle new instances of the unenhanced type. If this is\r\n-     * invoked in a Java 6 environment, this method will redefine the methods\r\n-     * for each class in the argument list such that field accesses are\r\n-     * intercepted in-line. If invoked in a Java 5 environment, this\r\n-     * redefinition is not possible; in these contexts, when using field\r\n-     * access, OpenJPA will need to do state comparisons to detect any change\r\n-     * to any instance at any time, and when using property access, OpenJPA\r\n-     * will need to do state comparisons to detect changes to newly inserted\r\n-     * instances after a flush has been called.\r\n-     *\r\n-     * @return the new subclasses, or <code>null</code> if <code>classes</code>\r\n-     * is <code>null</code>.\r\n-     * @throws UserException if <code>conf</code> requires build-time\r\n-     * enhancement and <code>classes</code> includes unenhanced types.\r\n-     *\r\n-     * @since 1.0.0\r\n-     */\r\n-    public static List<Class> prepareUnenhancedClasses(\r\n-        final OpenJPAConfiguration conf,\r\n-        final Collection<? extends Class> classes,\r\n-        final ClassLoader envLoader) {\r\n-        if (classes == null)\r\n-            return null;\r\n-        if (classes.size() == 0)\r\n-            return Collections.EMPTY_LIST;\r\n-\r\n-        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n-        if (conf.getRuntimeUnenhancedClassesConstant()\r\n-            != RuntimeUnenhancedClasssesModes.SUPPORTED) {\r\n-            Collection unenhanced = new ArrayList();\r\n-            for (Class cls : classes)\r\n-                if (!PersistenceCapable.class.isAssignableFrom(cls))\r\n-                    unenhanced.add(cls);\r\n-            if (unenhanced.size() > 0) {\r\n-                Message msg = _loc.get(\"runtime-optimization-disabled\",\r\n-                    unenhanced);\r\n-                if (conf.getRuntimeUnenhancedClassesConstant()\r\n-                    == RuntimeUnenhancedClasssesModes.WARN)\r\n-                    log.warn(msg);\r\n-                else\r\n-                    throw new UserException(msg);\r\n-            }\r\n-            return null;\r\n-        }\r\n-\r\n-        boolean redefine = ClassRedefiner.canRedefineClasses();\r\n-        if (redefine)\r\n-            log.info(_loc.get(\"enhance-and-subclass-and-redef-start\",\r\n-                classes));\r\n-        else\r\n-            log.info(_loc.get(\"enhance-and-subclass-no-redef-start\",\r\n-                classes));\r\n-\r\n-        final Map<Class, byte[]> map = new HashMap<Class, byte[]>();\r\n-        final List subs = new ArrayList(classes.size());\r\n-        final List ints = new ArrayList(classes.size());\r\n-        Set<Class> unspecified = null;\r\n-        for (Iterator iter = classes.iterator(); iter.hasNext(); ) {\r\n-            final Class cls = (Class) iter.next();\r\n-            final PCEnhancer enhancer = new PCEnhancer(conf, cls); \r\n-\r\n-            enhancer.setBytecodeWriter(new BytecodeWriter() {\r\n-                public void write(BCClass bc) throws IOException {\r\n-                    ManagedClassSubclasser.write(bc, enhancer, map,\r\n-                        cls, subs, ints);\r\n-                }\r\n-            });\r\n-            if (redefine)\r\n-                enhancer.setRedefine(true);\r\n-            enhancer.setCreateSubclass(true);\r\n-            enhancer.setAddDefaultConstructor(true);\r\n-\r\n-            // set this before enhancement as well as after since enhancement\r\n-            // uses a different metadata repository, and the metadata config\r\n-            // matters in the enhancement contract. Don't do any warning here,\r\n-            // since we'll issue warnings when we do the final metadata\r\n-            // reconfiguration at the end of this method.\r\n-            configureMetaData(enhancer.getMetaData(), conf, redefine, false);\r\n-\r\n-            unspecified = collectRelatedUnspecifiedTypes(enhancer.getMetaData(),\r\n-                classes, unspecified);\r\n-\r\n-            int runResult = enhancer.run();\r\n-            if (runResult == PCEnhancer.ENHANCE_PC) {\r\n-                try {\r\n-                    enhancer.record();\r\n-                } catch (IOException e) {\r\n-                    // our impl of BytecodeWriter doesn't throw IOException\r\n-                    throw new InternalException(e);\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        if (unspecified != null && !unspecified.isEmpty())\r\n-            throw new UserException(_loc.get(\"unspecified-unenhanced-types\",\r\n-                classes, unspecified));\r\n-\r\n-        ClassRedefiner.redefineClasses(conf, map);\r\n-        for (Class cls : map.keySet()) {\r\n-            setIntercepting(conf, envLoader, cls);\r\n-            configureMetaData(conf, envLoader, cls, redefine);\r\n-        }\r\n-        for (Class cls : (Collection<Class>) subs)\r\n-            configureMetaData(conf, envLoader, cls, redefine);\r\n-        for (Class cls : (Collection<Class>) ints)\r\n-            setIntercepting(conf, envLoader, cls);\r\n-\r\n-        return subs;\r\n-    }\r\n-\r\n-    private static Set<Class> collectRelatedUnspecifiedTypes(ClassMetaData meta,\r\n-        Collection<? extends Class> classes, Set<Class> unspecified) {\r\n-        unspecified = collectUnspecifiedType(meta.getPCSuperclass(), classes,\r\n-            unspecified);\r\n-\r\n-        for (FieldMetaData fmd : meta.getFields()) {\r\n-            if (fmd.isTransient())\r\n-                continue;\r\n-            if (fmd.isTypePC())\r\n-                unspecified = collectUnspecifiedType(fmd.getType(), classes,\r\n-                    unspecified);\r\n-            if (fmd.getElement() != null && fmd.getElement().isTypePC())\r\n-                unspecified = collectUnspecifiedType(fmd.getElement().getType(),\r\n-                    classes, unspecified);\r\n-            if (fmd.getKey() != null && fmd.getKey().isTypePC())\r\n-                unspecified = collectUnspecifiedType(fmd.getKey().getType(),\r\n-                    classes, unspecified);\r\n-            if (fmd.getValue() != null && fmd.getValue().isTypePC())\r\n-                unspecified = collectUnspecifiedType(fmd.getValue().getType(),\r\n-                    classes, unspecified);\r\n-        }\r\n-        return unspecified;\r\n-    }\r\n-\r\n-    private static Set<Class> collectUnspecifiedType(Class cls,\r\n-        Collection<? extends Class> classes, Set<Class> unspecified) {\r\n-        if (cls != null && !classes.contains(cls)\r\n-            && !ImplHelper.isManagedType(null, cls)) {\r\n-            if (unspecified == null)\r\n-                unspecified = new HashSet<Class>();\r\n-            unspecified.add(cls);\r\n-        }\r\n-        return unspecified;\r\n-    }\r\n-\r\n-    private static void configureMetaData(OpenJPAConfiguration conf,\r\n-        ClassLoader envLoader, Class cls, boolean redefineAvailable) {\r\n-        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\r\n-            .getMetaData(cls, envLoader, true);\r\n-        configureMetaData(meta, conf, redefineAvailable, true);\r\n-    }\r\n-\r\n-    private static void configureMetaData(ClassMetaData meta,\r\n-        OpenJPAConfiguration conf, boolean redefineAvailable, boolean warn) {\r\n-\r\n-        setDetachedState(meta);\r\n-\r\n-        if (warn && meta.getAccessType() == ClassMetaData.ACCESS_FIELD\r\n-            && !redefineAvailable) {\r\n-            // only warn about declared fields; superclass fields will be\r\n-            // warned about when the superclass is handled\r\n-            for (FieldMetaData fmd : meta.getDeclaredFields()) {\r\n-                switch (fmd.getTypeCode()) {\r\n-                    case JavaTypes.COLLECTION:\r\n-                    case JavaTypes.MAP:\r\n-                        // we can lazily load these, since we own the\r\n-                        // relationship container\r\n-                        break;\r\n-                    default:\r\n-                        if (!fmd.isInDefaultFetchGroup()\r\n-                            && !(fmd.isVersion() || fmd.isPrimaryKey())) {\r\n-                            Log log = conf.getLog(\r\n-                                OpenJPAConfiguration.LOG_ENHANCE);\r\n-                            log.warn(_loc.get(\"subclasser-fetch-group-override\",\r\n-                                meta.getDescribedType().getName(),\r\n-                                fmd.getName()));\r\n-                            fmd.setInDefaultFetchGroup(true);\r\n-                        }\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private static void write(BCClass bc, PCEnhancer enhancer,\r\n-        Map<Class, byte[]> map, Class cls, List subs, List ints)\r\n-        throws IOException {\r\n-\r\n-        if (bc == enhancer.getManagedTypeBytecode()) {\r\n-            // if it was already defined, don't put it in the map,\r\n-            // but do set the metadata accordingly.\r\n-            if (enhancer.isAlreadyRedefined())\r\n-                ints.add(bc.getType());\r\n-            else if (JavaVersions.VERSION >= 5) {\r\n-                map.put(bc.getType(), bc.toByteArray());\r\n-                debugBytecodes(bc);\r\n-            }\r\n-        } else {\r\n-            if (!enhancer.isAlreadySubclassed()) {\r\n-                debugBytecodes(bc);\r\n-                \r\n-                // this is the new subclass\r\n-                ClassLoader loader = GeneratedClasses.getMostDerivedLoader(\r\n-                    cls, PersistenceCapable.class);\r\n-                subs.add(GeneratedClasses.loadBCClass(bc, loader));\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    private static void debugBytecodes(BCClass bc) throws IOException {\r\n-        // Write the bytecodes to disk for debugging purposes.\r\n-        if (\"true\".equals(System.getProperty(\r\n-            ManagedClassSubclasser.class.getName() + \".dumpBytecodes\")))\r\n-        {\r\n-            File tmp = new File(System.getProperty(\"java.io.tmpdir\"));\r\n-            File dir = new File(tmp, \"openjpa\");\r\n-            dir = new File(dir, \"pcsubclasses\");\r\n-            dir.mkdirs();\r\n-            dir = Files.getPackageFile(dir, bc.getPackageName(), true);\r\n-            File f = new File(dir, bc.getClassName() + \".class\");\r\n-            System.err.println(\"Writing to \" + f);\r\n-            bc.write(f);\r\n-        }\r\n-    }\r\n-\r\n-    private static void setIntercepting(OpenJPAConfiguration conf,\r\n-        ClassLoader envLoader, Class cls) {\r\n-        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\r\n-            .getMetaData(cls, envLoader, true);\r\n-        meta.setIntercepting(true);\r\n-    }\r\n-\r\n-    /**\r\n-     * If the metadata is configured to use a synthetic\r\n-     * detached state, reset it to not use a detached\r\n-     * state field, since we can't add fields when redefining.\r\n-     */\r\n-    private static void setDetachedState(ClassMetaData meta) {\r\n-        if (ClassMetaData.SYNTHETIC.equals(meta.getDetachedState()))\r\n-            meta.setDetachedState(null);\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.BytecodeWriter;\n+import org.apache.openjpa.lib.util.JavaVersions;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Files;\n+import org.apache.openjpa.lib.util.Localizer.Message;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.GeneratedClasses;\n+import org.apache.openjpa.util.ImplHelper;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.util.UserException;\n+import serp.bytecode.BCClass;\n+\n+/**\n+ * Redefines the method bodies of existing unenhanced classes to make them\n+ * notify state managers of mutations.\n+ *\n+ * @since 1.0.0\n+ */\n+public class ManagedClassSubclasser {\n+    private static final Localizer _loc = Localizer.forPackage(\n+        ManagedClassSubclasser.class);\n+\n+    /**\n+     * For each element in <code>classes</code>, creates and registers a\n+     * new subclass that implements {@link PersistenceCapable}, and prepares\n+     * OpenJPA to handle new instances of the unenhanced type. If this is\n+     * invoked in a Java 6 environment, this method will redefine the methods\n+     * for each class in the argument list such that field accesses are\n+     * intercepted in-line. If invoked in a Java 5 environment, this\n+     * redefinition is not possible; in these contexts, when using field\n+     * access, OpenJPA will need to do state comparisons to detect any change\n+     * to any instance at any time, and when using property access, OpenJPA\n+     * will need to do state comparisons to detect changes to newly inserted\n+     * instances after a flush has been called.\n+     *\n+     * @return the new subclasses, or <code>null</code> if <code>classes</code>\n+     * is <code>null</code>.\n+     * @throws UserException if <code>conf</code> requires build-time\n+     * enhancement and <code>classes</code> includes unenhanced types.\n+     *\n+     * @since 1.0.0\n+     */\n+    public static List<Class> prepareUnenhancedClasses(\n+        final OpenJPAConfiguration conf,\n+        final Collection<? extends Class> classes,\n+        final ClassLoader envLoader) {\n+        if (classes == null)\n+            return null;\n+        if (classes.size() == 0)\n+            return Collections.EMPTY_LIST;\n+\n+        Log log = conf.getLog(OpenJPAConfiguration.LOG_ENHANCE);\n+        if (conf.getRuntimeUnenhancedClassesConstant()\n+            != RuntimeUnenhancedClasssesModes.SUPPORTED) {\n+            Collection unenhanced = new ArrayList();\n+            for (Class cls : classes)\n+                if (!PersistenceCapable.class.isAssignableFrom(cls))\n+                    unenhanced.add(cls);\n+            if (unenhanced.size() > 0) {\n+                Message msg = _loc.get(\"runtime-optimization-disabled\",\n+                    unenhanced);\n+                if (conf.getRuntimeUnenhancedClassesConstant()\n+                    == RuntimeUnenhancedClasssesModes.WARN)\n+                    log.warn(msg);\n+                else\n+                    throw new UserException(msg);\n+            }\n+            return null;\n+        }\n+\n+        boolean redefine = ClassRedefiner.canRedefineClasses();\n+        if (redefine)\n+            log.info(_loc.get(\"enhance-and-subclass-and-redef-start\",\n+                classes));\n+        else\n+            log.info(_loc.get(\"enhance-and-subclass-no-redef-start\",\n+                classes));\n+\n+        final Map<Class, byte[]> map = new HashMap<Class, byte[]>();\n+        final List subs = new ArrayList(classes.size());\n+        final List ints = new ArrayList(classes.size());\n+        Set<Class> unspecified = null;\n+        for (Iterator iter = classes.iterator(); iter.hasNext(); ) {\n+            final Class cls = (Class) iter.next();\n+            final PCEnhancer enhancer = new PCEnhancer(conf, cls); \n+\n+            enhancer.setBytecodeWriter(new BytecodeWriter() {\n+                public void write(BCClass bc) throws IOException {\n+                    ManagedClassSubclasser.write(bc, enhancer, map,\n+                        cls, subs, ints);\n+                }\n+            });\n+            if (redefine)\n+                enhancer.setRedefine(true);\n+            enhancer.setCreateSubclass(true);\n+            enhancer.setAddDefaultConstructor(true);\n+\n+            // set this before enhancement as well as after since enhancement\n+            // uses a different metadata repository, and the metadata config\n+            // matters in the enhancement contract. Don't do any warning here,\n+            // since we'll issue warnings when we do the final metadata\n+            // reconfiguration at the end of this method.\n+            configureMetaData(enhancer.getMetaData(), conf, redefine, false);\n+\n+            unspecified = collectRelatedUnspecifiedTypes(enhancer.getMetaData(),\n+                classes, unspecified);\n+\n+            int runResult = enhancer.run();\n+            if (runResult == PCEnhancer.ENHANCE_PC) {\n+                try {\n+                    enhancer.record();\n+                } catch (IOException e) {\n+                    // our impl of BytecodeWriter doesn't throw IOException\n+                    throw new InternalException(e);\n+                }\n+            }\n+        }\n+\n+        if (unspecified != null && !unspecified.isEmpty())\n+            throw new UserException(_loc.get(\"unspecified-unenhanced-types\",\n+                classes, unspecified));\n+\n+        ClassRedefiner.redefineClasses(conf, map);\n+        for (Class cls : map.keySet()) {\n+            setIntercepting(conf, envLoader, cls);\n+            configureMetaData(conf, envLoader, cls, redefine);\n+        }\n+        for (Class cls : (Collection<Class>) subs)\n+            configureMetaData(conf, envLoader, cls, redefine);\n+        for (Class cls : (Collection<Class>) ints)\n+            setIntercepting(conf, envLoader, cls);\n+\n+        return subs;\n+    }\n+\n+    private static Set<Class> collectRelatedUnspecifiedTypes(ClassMetaData meta,\n+        Collection<? extends Class> classes, Set<Class> unspecified) {\n+        unspecified = collectUnspecifiedType(meta.getPCSuperclass(), classes,\n+            unspecified);\n+\n+        for (FieldMetaData fmd : meta.getFields()) {\n+            if (fmd.isTransient())\n+                continue;\n+            if (fmd.isTypePC())\n+                unspecified = collectUnspecifiedType(fmd.getType(), classes,\n+                    unspecified);\n+            if (fmd.getElement() != null && fmd.getElement().isTypePC())\n+                unspecified = collectUnspecifiedType(fmd.getElement().getType(),\n+                    classes, unspecified);\n+            if (fmd.getKey() != null && fmd.getKey().isTypePC())\n+                unspecified = collectUnspecifiedType(fmd.getKey().getType(),\n+                    classes, unspecified);\n+            if (fmd.getValue() != null && fmd.getValue().isTypePC())\n+                unspecified = collectUnspecifiedType(fmd.getValue().getType(),\n+                    classes, unspecified);\n+        }\n+        return unspecified;\n+    }\n+\n+    private static Set<Class> collectUnspecifiedType(Class cls,\n+        Collection<? extends Class> classes, Set<Class> unspecified) {\n+        if (cls != null && !classes.contains(cls)\n+            && !ImplHelper.isManagedType(null, cls)) {\n+            if (unspecified == null)\n+                unspecified = new HashSet<Class>();\n+            unspecified.add(cls);\n+        }\n+        return unspecified;\n+    }\n+\n+    private static void configureMetaData(OpenJPAConfiguration conf,\n+        ClassLoader envLoader, Class cls, boolean redefineAvailable) {\n+        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\n+            .getMetaData(cls, envLoader, true);\n+        configureMetaData(meta, conf, redefineAvailable, true);\n+    }\n+\n+    private static void configureMetaData(ClassMetaData meta,\n+        OpenJPAConfiguration conf, boolean redefineAvailable, boolean warn) {\n+\n+        setDetachedState(meta);\n+\n+        if (warn && meta.getAccessType() == ClassMetaData.ACCESS_FIELD\n+            && !redefineAvailable) {\n+            // only warn about declared fields; superclass fields will be\n+            // warned about when the superclass is handled\n+            for (FieldMetaData fmd : meta.getDeclaredFields()) {\n+                switch (fmd.getTypeCode()) {\n+                    case JavaTypes.COLLECTION:\n+                    case JavaTypes.MAP:\n+                        // we can lazily load these, since we own the\n+                        // relationship container\n+                        break;\n+                    default:\n+                        if (!fmd.isInDefaultFetchGroup()\n+                            && !(fmd.isVersion() || fmd.isPrimaryKey())) {\n+                            Log log = conf.getLog(\n+                                OpenJPAConfiguration.LOG_ENHANCE);\n+                            log.warn(_loc.get(\"subclasser-fetch-group-override\",\n+                                meta.getDescribedType().getName(),\n+                                fmd.getName()));\n+                            fmd.setInDefaultFetchGroup(true);\n+                        }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void write(BCClass bc, PCEnhancer enhancer,\n+        Map<Class, byte[]> map, Class cls, List subs, List ints)\n+        throws IOException {\n+\n+        if (bc == enhancer.getManagedTypeBytecode()) {\n+            // if it was already defined, don't put it in the map,\n+            // but do set the metadata accordingly.\n+            if (enhancer.isAlreadyRedefined())\n+                ints.add(bc.getType());\n+            else if (JavaVersions.VERSION >= 5) {\n+                map.put(bc.getType(), bc.toByteArray());\n+                debugBytecodes(bc);\n+            }\n+        } else {\n+            if (!enhancer.isAlreadySubclassed()) {\n+                debugBytecodes(bc);\n+                \n+                // this is the new subclass\n+                ClassLoader loader = GeneratedClasses.getMostDerivedLoader(\n+                    cls, PersistenceCapable.class);\n+                subs.add(GeneratedClasses.loadBCClass(bc, loader));\n+            }\n+        }\n+    }\n+\n+    private static void debugBytecodes(BCClass bc) throws IOException {\n+        // Write the bytecodes to disk for debugging purposes.\n+        if (\"true\".equals(System.getProperty(\n+            ManagedClassSubclasser.class.getName() + \".dumpBytecodes\")))\n+        {\n+            File tmp = new File(System.getProperty(\"java.io.tmpdir\"));\n+            File dir = new File(tmp, \"openjpa\");\n+            dir = new File(dir, \"pcsubclasses\");\n+            dir.mkdirs();\n+            dir = Files.getPackageFile(dir, bc.getPackageName(), true);\n+            File f = new File(dir, bc.getClassName() + \".class\");\n+            System.err.println(\"Writing to \" + f);\n+            bc.write(f);\n+        }\n+    }\n+\n+    private static void setIntercepting(OpenJPAConfiguration conf,\n+        ClassLoader envLoader, Class cls) {\n+        ClassMetaData meta = conf.getMetaDataRepositoryInstance()\n+            .getMetaData(cls, envLoader, true);\n+        meta.setIntercepting(true);\n+    }\n+\n+    /**\n+     * If the metadata is configured to use a synthetic\n+     * detached state, reset it to not use a detached\n+     * state field, since we can't add fields when redefining.\n+     */\n+    private static void setDetachedState(ClassMetaData meta) {\n+        if (ClassMetaData.SYNTHETIC.equals(meta.getDetachedState()))\n+            meta.setDetachedState(null);\n+    }\n+}"},{"sha":"ebdd746c8638de5766fb5d0add78c927b6d4b0fc","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","status":"modified","additions":28,"deletions":28,"changes":56,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ManagedInstanceProvider.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,28 +1,28 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-/**\r\n- * Instances of this interface can provide an underlying instance.\r\n- *\r\n- * @since 1.0.0\r\n- */\r\n-public interface ManagedInstanceProvider {\r\n-    public Object getManagedInstance();\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+/**\n+ * Instances of this interface can provide an underlying instance.\n+ *\n+ * @since 1.0.0\n+ */\n+public interface ManagedInstanceProvider {\n+    public Object getManagedInstance();\n+}"},{"sha":"dd95fa2373bcaeb3004ad6b707946bd68f72d661","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","status":"modified","additions":1077,"deletions":1077,"changes":2154,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCDataGenerator.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,1077 +1,1077 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.util.BitSet;\r\n-import java.util.Collection;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.openjpa.conf.OpenJPAConfiguration;\r\n-import org.apache.openjpa.kernel.AbstractPCData;\r\n-import org.apache.openjpa.kernel.FetchConfiguration;\r\n-import org.apache.openjpa.kernel.OpenJPAStateManager;\r\n-import org.apache.openjpa.kernel.PCData;\r\n-import org.apache.openjpa.kernel.StoreContext;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import java.util.concurrent.ConcurrentHashMap;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.meta.JavaTypes;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import serp.bytecode.BCClass;\r\n-import serp.bytecode.BCField;\r\n-import serp.bytecode.BCMethod;\r\n-import serp.bytecode.Code;\r\n-import serp.bytecode.Constants;\r\n-import serp.bytecode.ExceptionHandler;\r\n-import serp.bytecode.Instruction;\r\n-import serp.bytecode.JumpInstruction;\r\n-import serp.bytecode.LookupSwitchInstruction;\r\n-\r\n-/**\r\n- * Generates {@link PCData} instances which avoid primitve wrappers\r\n- * to optimize memory use and performance at the cost of slightly higher\r\n- * startup time.\r\n- *\r\n- * @author Steve Kim\r\n- * @nojavadoc\r\n- * @since 0.3.2\r\n- */\r\n-public class PCDataGenerator\r\n-    extends DynamicStorageGenerator {\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (PCDataGenerator.class);\r\n-\r\n-    protected static final String POSTFIX = \"$openjpapcdata\";\r\n-\r\n-    private final Map _generated = new ConcurrentHashMap();\r\n-    private final OpenJPAConfiguration _conf;\r\n-    private final Log _log;\r\n-\r\n-    public PCDataGenerator(OpenJPAConfiguration conf) {\r\n-        _conf = conf;\r\n-        _log = _conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_ENHANCE);\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the configuration.\r\n-     */\r\n-    public OpenJPAConfiguration getConfiguration() {\r\n-        return _conf;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return a {@link PCData} instance for the given oid and metadata.\r\n-     */\r\n-    public PCData generatePCData(Object oid, ClassMetaData meta) {\r\n-        if (meta == null)\r\n-            return null;\r\n-        Class type = meta.getDescribedType();\r\n-        DynamicStorage storage = (DynamicStorage) _generated.get(type);\r\n-        if (storage == null) {\r\n-            storage = generateStorage(meta);\r\n-            _generated.put(type, storage);\r\n-            if (_log.isTraceEnabled())\r\n-                _log.trace(_loc.get(\"pcdata-created\", type.getName(), meta));\r\n-        }\r\n-        DynamicPCData data = (DynamicPCData) storage.newInstance();\r\n-        data.setId(oid);\r\n-        data.setStorageGenerator(this);\r\n-        finish(data, meta);\r\n-        return data;\r\n-    }\r\n-\r\n-    /**\r\n-     * Actually generate the factory instance.\r\n-     */\r\n-    private DynamicStorage generateStorage(ClassMetaData meta) {\r\n-        if (_log.isTraceEnabled())\r\n-            _log.trace(_loc.get(\"pcdata-generate\", meta));\r\n-\r\n-        FieldMetaData[] fields = meta.getFields();\r\n-        int[] types = new int[fields.length];\r\n-        for (int i = 0; i < types.length; i++)\r\n-            types[i] = replaceType(fields[i]);\r\n-        return generateStorage(types, meta);\r\n-    }\r\n-\r\n-    /**\r\n-     * Perform any final actions before the pcdata is returned to client code.\r\n-     */\r\n-    protected void finish(DynamicPCData data, ClassMetaData meta) {\r\n-    }\r\n-\r\n-    protected int getCreateFieldMethods(int typeCode) {\r\n-        if (typeCode >= JavaTypes.OBJECT)\r\n-            return POLICY_SILENT;\r\n-        // don't bother creating set/get<Primitive> methods\r\n-        return POLICY_EMPTY;\r\n-    }\r\n-\r\n-    protected void declareClasses(BCClass bc) {\r\n-        super.declareClasses(bc);\r\n-        bc.declareInterface(DynamicPCData.class);\r\n-        bc.setSuperclass(AbstractPCData.class);\r\n-    }\r\n-\r\n-    protected final String getClassName(Object obj) {\r\n-        return getUniqueName(((ClassMetaData) obj).getDescribedType());\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a unique name for the given type's pcdata implementation.\r\n-     */\r\n-    protected String getUniqueName(Class type) {\r\n-        return type.getName() + \"$\" + System.identityHashCode(type) + POSTFIX;\r\n-    }\r\n-\r\n-    protected final void decorate(Object obj, BCClass bc, int[] types) {\r\n-        super.decorate(obj, bc, types);\r\n-        ClassMetaData meta = (ClassMetaData) obj;\r\n-\r\n-        enhanceConstructor(bc);\r\n-        addBaseFields(bc);\r\n-        addImplDataMethods(bc, meta);\r\n-        addFieldImplDataMethods(bc, meta);\r\n-        addVersionMethods(bc);\r\n-        addGetType(bc, meta);\r\n-        addLoadMethod(bc, meta);\r\n-        addLoadWithFieldsMethod(bc, meta);\r\n-        addStoreMethods(bc, meta);\r\n-        addNewEmbedded(bc);\r\n-        addGetData(bc);\r\n-        decorate(bc, meta);\r\n-    }\r\n-\r\n-    /**\r\n-     * Apply additional decoration to generated class.\r\n-     */\r\n-    protected void decorate(BCClass bc, ClassMetaData meta) {\r\n-    }\r\n-\r\n-    /**\r\n-     * Enhance constructor to initialize fields\r\n-     */\r\n-    private void enhanceConstructor(BCClass bc) {\r\n-        BCMethod cons = bc.getDeclaredMethod(\"<init>\", (String[]) null);\r\n-        Code code = cons.getCode(false);\r\n-        code.afterLast();\r\n-        code.previous();\r\n-\r\n-        // private BitSet loaded = new BitSet();\r\n-        BCField loaded = addBeanField(bc, \"loaded\", BitSet.class);\r\n-        loaded.setFinal(true);\r\n-        code.aload().setThis();\r\n-        code.anew().setType(BitSet.class);\r\n-        code.dup();\r\n-        code.constant().setValue(bc.getFields().length);\r\n-        code.invokespecial().setMethod(BitSet.class, \"<init>\", void.class,\r\n-            new Class[]{ int.class });\r\n-        code.putfield().setField(loaded);\r\n-\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-    }\r\n-\r\n-    /**\r\n-     * Have to load the type since it may not be available to the\r\n-     * same classloader (i.e. rar vs. ear). The context classloader\r\n-     * (i.e. the user app classloader) should be fine.\r\n-     */\r\n-    private void addGetType(BCClass bc, ClassMetaData meta) {\r\n-        BCField type = bc.declareField(\"type\", Class.class);\r\n-        type.setStatic(true);\r\n-        type.makePrivate();\r\n-        // public Class getType() {\r\n-        BCMethod getter = bc.declareMethod(\"getType\", Class.class, null);\r\n-        getter.makePublic();\r\n-        Code code = getter.getCode(true);\r\n-        // if (type == null) {\r\n-        // \t\ttry {\r\n-        // \t\t\ttype = Class.forName\r\n-        // \t\t\t\t(meta.getDescribedType().getName(), true,\r\n-        // \t\t\t\tThread.currentThread().getContextClassLoader());\r\n-        // \t\t} catch (ClassNotFoundException cnfe) {\r\n-        // \t\t\tthrow new InternalException();\r\n-        // \t\t}\r\n-        // }\r\n-        code.getstatic().setField(type);\r\n-\r\n-        Collection jumps = new LinkedList();\r\n-        jumps.add(code.ifnonnull());\r\n-        ExceptionHandler handler = code.addExceptionHandler();\r\n-\r\n-        handler.setTryStart(code.constant().setValue\r\n-            (meta.getDescribedType().getName()));\r\n-        code.constant().setValue(true);\r\n-        code.invokestatic().setMethod(Thread.class, \"currentThread\",\r\n-            Thread.class, null);\r\n-        code.invokevirtual().setMethod(Thread.class, \"getContextClassLoader\",\r\n-            ClassLoader.class, null);\r\n-        code.invokestatic().setMethod(Class.class, \"forName\", Class.class,\r\n-            new Class[]{ String.class, boolean.class, ClassLoader.class });\r\n-        code.putstatic().setField(type);\r\n-        Instruction go2 = code.go2();\r\n-        jumps.add(go2);\r\n-        handler.setTryEnd(go2);\r\n-        handler.setCatch(ClassNotFoundException.class);\r\n-        handler.setHandlerStart(throwException\r\n-            (code, InternalException.class));\r\n-        setTarget(code.getstatic().setField(type), jumps);\r\n-        code.areturn();\r\n-\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-    }\r\n-\r\n-    /**\r\n-     * Declare standard dynamic pcdata fields.\r\n-     */\r\n-    private void addBaseFields(BCClass bc) {\r\n-        addBeanField(bc, \"id\", Object.class);\r\n-        BCField field = addBeanField(bc, \"storageGenerator\",\r\n-            PCDataGenerator.class);\r\n-        field.setAccessFlags(field.getAccessFlags()\r\n-            | Constants.ACCESS_TRANSIENT);\r\n-    }\r\n-\r\n-    /**\r\n-     * Add methods for loading and storing class-level impl data.\r\n-     */\r\n-    private void addImplDataMethods(BCClass bc, ClassMetaData meta) {\r\n-        // void storeImplData(OpenJPAStateManager);\r\n-        BCMethod meth = bc.declareMethod(\"storeImplData\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-        Code code = meth.getCode(true);\r\n-\r\n-        BCField impl = null;\r\n-        if (!usesImplData(meta))\r\n-            code.vreturn();\r\n-        else {\r\n-            // if (sm.isImplDataCacheable())\r\n-            // \t\tsetImplData(sm.getImplData());\r\n-            impl = addBeanField(bc, \"implData\", Object.class);\r\n-            code.aload().setParam(0);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"isImplDataCacheable\", boolean.class, null);\r\n-            JumpInstruction ifins = code.ifeq();\r\n-            code.aload().setThis();\r\n-            code.aload().setParam(0);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"getImplData\", Object.class, null);\r\n-            code.invokevirtual().setMethod(\"setImplData\", void.class,\r\n-                new Class[]{ Object.class });\r\n-            ifins.setTarget(code.vreturn());\r\n-        }\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-\r\n-        // void loadImplData(OpenJPAStateManager);\r\n-        meth = bc.declareMethod(\"loadImplData\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-        code = meth.getCode(true);\r\n-        if (!usesImplData(meta))\r\n-            code.vreturn();\r\n-        else {\r\n-            // if (sm.getImplData() == null && implData != null)\r\n-            // \t\tsm.setImplData(impl, true);\r\n-            code.aload().setParam(0);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"getImplData\", Object.class, null);\r\n-            JumpInstruction ifins = code.ifnonnull();\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(impl);\r\n-            JumpInstruction ifins2 = code.ifnull();\r\n-            code.aload().setParam(0);\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(impl);\r\n-            code.constant().setValue(true);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"setImplData\", void.class,\r\n-                new Class[]{ Object.class, boolean.class });\r\n-            Instruction ins = code.vreturn();\r\n-            ifins.setTarget(ins);\r\n-            ifins2.setTarget(ins);\r\n-        }\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-    }\r\n-\r\n-    /**\r\n-     * Add methods for loading and storing class-level impl data.\r\n-     */\r\n-    private void addFieldImplDataMethods(BCClass bc, ClassMetaData meta) {\r\n-        // public void loadImplData(OpenJPAStateManager sm, int i)\r\n-        BCMethod meth = bc.declareMethod(\"loadImplData\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class, int.class });\r\n-        meth.makePrivate();\r\n-        Code code = meth.getCode(true);\r\n-\r\n-        int count = countImplDataFields(meta);\r\n-        BCField impl = null;\r\n-        if (count == 0)\r\n-            code.vreturn();\r\n-        else {\r\n-            // Object[] fieldImpl\r\n-            impl = bc.declareField(\"fieldImpl\", Object[].class);\r\n-            impl.makePrivate();\r\n-\r\n-            // if (fieldImpl != null)\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(impl);\r\n-            JumpInstruction ifins = code.ifnonnull();\r\n-            code.vreturn();\r\n-\r\n-            // Object obj = null;\r\n-            int obj = code.getNextLocalsIndex();\r\n-            ifins.setTarget(code.constant().setNull());\r\n-            code.astore().setLocal(obj);\r\n-\r\n-            // establish switch target, then move before it\r\n-            Instruction target = code.aload().setLocal(obj);\r\n-            code.previous();\r\n-\r\n-            // switch(i)\r\n-            code.iload().setParam(1);\r\n-            LookupSwitchInstruction lswitch = code.lookupswitch();\r\n-            FieldMetaData[] fields = meta.getFields();\r\n-            int cacheable = 0;\r\n-            for (int i = 0; i < fields.length; i++) {\r\n-                if (!usesImplData(fields[i]))\r\n-                    continue;\r\n-                // case x: obj = fieldImpl[y]; break;\r\n-                lswitch.addCase(i, code.aload().setThis());\r\n-                code.getfield().setField(impl);\r\n-                code.constant().setValue(cacheable++);\r\n-                code.aaload();\r\n-                code.astore().setLocal(obj);\r\n-                code.go2().setTarget(target);\r\n-            }\r\n-            lswitch.setDefaultTarget(target);\r\n-\r\n-            // if (obj != null)\r\n-            code.next();    // jump back over target\r\n-            ifins = code.ifnonnull();\r\n-            code.vreturn();\r\n-\r\n-            // sm.setImplData(index, impl);\r\n-            ifins.setTarget(code.aload().setParam(0));\r\n-            code.iload().setParam(1);\r\n-            code.aload().setLocal(obj);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"setImplData\", void.class,\r\n-                new Class[]{ int.class, Object.class });\r\n-            code.vreturn();\r\n-        }\r\n-        code.calculateMaxLocals();\r\n-        code.calculateMaxStack();\r\n-\r\n-        // void storeImplData(OpenJPAStateManager sm, int index, boolean loaded)\r\n-        meth = bc.declareMethod(\"storeImplData\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class, int.class, boolean.class });\r\n-        code = meth.getCode(true);\r\n-        if (count == 0)\r\n-            code.vreturn();\r\n-        else {\r\n-            // int arrIdx = -1;\r\n-            // switch(index)\r\n-            int arrIdx = code.getNextLocalsIndex();\r\n-            code.constant().setValue(-1);\r\n-            code.istore().setLocal(arrIdx);\r\n-            code.iload().setParam(1);\r\n-            LookupSwitchInstruction lswitch = code.lookupswitch();\r\n-\r\n-            // establish switch target, then move before it\r\n-            Instruction switchTarget = code.iload().setLocal(arrIdx);\r\n-            code.previous();\r\n-\r\n-            FieldMetaData[] fields = meta.getFields();\r\n-            int cacheable = 0;\r\n-            for (int i = 0; i < fields.length; i++) {\r\n-                if (!usesImplData(fields[i]))\r\n-                    continue;\r\n-                // case x: arrIdx = y; break;\r\n-                lswitch.addCase(i, code.constant().setValue(cacheable++));\r\n-                code.istore().setLocal(arrIdx);\r\n-                code.go2().setTarget(switchTarget);\r\n-            }\r\n-            lswitch.setDefaultTarget(switchTarget);\r\n-            code.next();    // step over switch target\r\n-\r\n-            // if (arrIdx != -1)\r\n-            code.constant().setValue(-1);\r\n-            JumpInstruction ifins = code.ificmpne();\r\n-            code.vreturn();\r\n-\r\n-            // create null target, then move before it\r\n-            Instruction nullTarget = code.aload().setThis();\r\n-            code.previous();\r\n-\r\n-            // if (loaded)\r\n-            ifins.setTarget(code.iload().setParam(2));\r\n-            code.ifeq().setTarget(nullTarget);\r\n-\r\n-            // Object obj = sm.getImplData(index)\r\n-            int obj = code.getNextLocalsIndex();\r\n-            code.aload().setParam(0);\r\n-            code.iload().setParam(1);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"getImplData\", Object.class, new Class[]{ int.class });\r\n-            code.astore().setLocal(obj);\r\n-\r\n-            // if (obj != null)\r\n-            code.aload().setLocal(obj);\r\n-            code.ifnull().setTarget(nullTarget);\r\n-\r\n-            // if (fieldImpl == null)\r\n-            // \t\tfieldImpl = new Object[fields];\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(impl);\r\n-            ifins = code.ifnonnull();\r\n-            code.aload().setThis();\r\n-            code.constant().setValue(count);\r\n-            code.anewarray().setType(Object.class);\r\n-            code.putfield().setField(impl);\r\n-\r\n-            // fieldImpl[arrIdx] = obj;\r\n-            // return;\r\n-            ifins.setTarget(code.aload().setThis());\r\n-            code.getfield().setField(impl);\r\n-            code.iload().setLocal(arrIdx);\r\n-            code.aload().setLocal(obj);\r\n-            code.aastore();\r\n-            code.vreturn();\r\n-\r\n-            // if (fieldImpl != null)\r\n-            // \t\tfieldImpl[index] = null;\r\n-            code.next(); // step over nullTarget\r\n-            code.getfield().setField(impl);\r\n-            ifins = code.ifnonnull();\r\n-            code.vreturn();\r\n-            ifins.setTarget(code.aload().setThis());\r\n-            code.getfield().setField(impl);\r\n-            code.iload().setLocal(arrIdx);\r\n-            code.constant().setNull();\r\n-            code.aastore();\r\n-            code.vreturn();\r\n-        }\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-    }\r\n-\r\n-    /**\r\n-     * Add methods for loading and storing version data.\r\n-     */\r\n-    protected void addVersionMethods(BCClass bc) {\r\n-        // void storeVersion(OpenJPAStateManager sm);\r\n-        addBeanField(bc, \"version\", Object.class);\r\n-        BCMethod meth = bc.declareMethod(\"storeVersion\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-        Code code = meth.getCode(true);\r\n-\r\n-        // version = sm.getVersion();\r\n-        code.aload().setThis();\r\n-        code.aload().setParam(0);\r\n-        code.invokeinterface()\r\n-            .setMethod(OpenJPAStateManager.class, \"getVersion\",\r\n-                Object.class, null);\r\n-        code.putfield().setField(\"version\", Object.class);\r\n-        code.vreturn();\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-\r\n-        // void loadVersion(OpenJPAStateManager sm)\r\n-        meth = bc.declareMethod(\"loadVersion\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-        code = meth.getCode(true);\r\n-\r\n-        // if (sm.getVersion() == null)\r\n-        // \t\tsm.setVersion(version);\r\n-        code.aload().setParam(0);\r\n-        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-            \"getVersion\", Object.class, null);\r\n-        JumpInstruction ifins = code.ifnonnull();\r\n-        code.aload().setParam(0);\r\n-        code.aload().setThis();\r\n-        code.getfield().setField(\"version\", Object.class);\r\n-        code.invokeinterface()\r\n-            .setMethod(OpenJPAStateManager.class, \"setVersion\",\r\n-                void.class, new Class[]{ Object.class });\r\n-        ifins.setTarget(code.vreturn());\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-    }\r\n-\r\n-    private void addLoadMethod(BCClass bc, ClassMetaData meta) {\r\n-        // public void load(OpenJPAStateManager sm, FetchConfiguration fetch,\r\n-        // \t\tObject context)\r\n-        Code code = addLoadMethod(bc, false);\r\n-        FieldMetaData[] fmds = meta.getFields();\r\n-        Collection jumps = new LinkedList();\r\n-        Collection jumps2;\r\n-\t\t\r\n-        int local = code.getNextLocalsIndex();\r\n-        code.constant().setNull();\r\n-        code.astore().setLocal(local);\r\n-        int inter = code.getNextLocalsIndex();\r\n-        code.constant().setNull();\r\n-        code.astore().setLocal(inter);\r\n-\r\n-        int objectCount = 0;\r\n-        boolean intermediate;\r\n-        for (int i = 0; i < fmds.length; i++) {\r\n-            jumps2 = new LinkedList();\r\n-            intermediate = usesIntermediate(fmds[i]);\r\n-            setTarget(code.aload().setThis(), jumps);\r\n-            // if (loaded.get(i)) or (!loaded.get(i)) depending on inter resp\r\n-            code.getfield().setField(\"loaded\", BitSet.class);\r\n-            code.constant().setValue(i);\r\n-            code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n-                boolean.class, new Class[]{ int.class });\r\n-            jumps.add(code.ifne());\r\n-\r\n-            if (intermediate)\r\n-                addLoadIntermediate(code, i, objectCount, jumps2, inter);\r\n-            jumps2.add(code.go2());\r\n-\r\n-            // if (fetch.requiresFetch(fmds[i])!=FetchConfiguration.FETCH_NONE)\r\n-            setTarget(code.aload().setParam(1), jumps);\r\n-            code.aload().setParam(0);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"getMetaData\", ClassMetaData.class, null);\r\n-            code.constant().setValue(fmds[i].getIndex());\r\n-            code.invokevirtual().setMethod(ClassMetaData.class,\r\n-                \"getField\", FieldMetaData.class, new Class[]{int.class});\r\n-            code.invokeinterface().setMethod (FetchConfiguration.class, \r\n-                \"requiresFetch\", int.class, new Class[]{FieldMetaData.class});\r\n-            code.constant().setValue(FetchConfiguration.FETCH_NONE);\r\n-            jumps2.add(code.ificmpeq());\r\n-            addLoad(bc, code, fmds[i], objectCount, local, false);\r\n-\r\n-            jumps = jumps2;\r\n-            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\r\n-                objectCount++;\r\n-        }\r\n-        setTarget(code.vreturn(), jumps);\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-    }\r\n-\r\n-    private void addLoadWithFieldsMethod(BCClass bc, ClassMetaData meta) {\r\n-        Code code = addLoadMethod(bc, true);\r\n-        // public void load(OpenJPAStateManager sm, BitSet fields,\r\n-        // \t\tFetchConfiguration fetch, Object conn)\r\n-        FieldMetaData[] fmds = meta.getFields();\r\n-        Collection jumps = new LinkedList();\r\n-        Collection jumps2;\r\n-        int objectCount = 0;\r\n-        boolean intermediate;\r\n-        int local = code.getNextLocalsIndex();\r\n-        code.constant().setNull();\r\n-        code.astore().setLocal(local);\r\n-        int inter = code.getNextLocalsIndex();\r\n-        code.constant().setNull();\r\n-        code.astore().setLocal(inter);\r\n-\r\n-        for (int i = 0; i < fmds.length; i++) {\r\n-            jumps2 = new LinkedList();\r\n-            intermediate = usesIntermediate(fmds[i]);\r\n-            // if (fields.get(i))\r\n-            // {\r\n-            // \t\tif (loaded.get(i))\r\n-            setTarget(code.aload().setParam(1), jumps);\r\n-            code.constant().setValue(i);\r\n-            code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n-                boolean.class, new Class[]{ int.class });\r\n-            jumps2.add(code.ifeq());\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(\"loaded\", BitSet.class);\r\n-            code.constant().setValue(i);\r\n-            code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n-                boolean.class, new Class[]{ int.class });\r\n-            if (intermediate)\r\n-                jumps.add(code.ifeq());\r\n-            else\r\n-                jumps2.add(code.ifeq());\r\n-\r\n-            addLoad(bc, code, fmds[i], objectCount, local, true);\r\n-            if (usesImplData(fmds[i])) {\r\n-                // loadImplData(sm, i);\r\n-                code.aload().setThis();\r\n-                code.aload().setParam(0);\r\n-                code.constant().setValue(i);\r\n-                code.invokevirtual().setMethod(\"loadImplData\", void.class,\r\n-                    new Class[]{ OpenJPAStateManager.class, int.class });\r\n-            }\r\n-\r\n-            // fields.clear(i);\r\n-            code.aload().setParam(1);\r\n-            code.constant().setValue(i);\r\n-            code.invokevirtual().setMethod(BitSet.class, \"clear\", void.class,\r\n-                new Class[] { int.class });\r\n-\r\n-            jumps2.add(code.go2());\r\n-\r\n-            if (intermediate)\r\n-                setTarget(addLoadIntermediate\r\n-                    (code, i, objectCount, jumps2, inter), jumps);\r\n-\r\n-            jumps = jumps2;\r\n-            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\r\n-                objectCount++;\r\n-        }\r\n-        setTarget(code.vreturn(), jumps);\r\n-        code.calculateMaxStack();\r\n-        code.calculateMaxLocals();\r\n-    }\r\n-\r\n-    /**\r\n-     * Declare and start the base load method.\r\n-     */\r\n-    private Code addLoadMethod(BCClass bc, boolean fields) {\r\n-        Class[] args = null;\r\n-        if (fields)\r\n-            args = new Class[]{ OpenJPAStateManager.class, BitSet.class,\r\n-                FetchConfiguration.class, Object.class };\r\n-        else\r\n-            args = new Class[]{ OpenJPAStateManager.class,\r\n-                FetchConfiguration.class, Object.class };\r\n-        BCMethod load = bc.declareMethod(\"load\", void.class, args);\r\n-        Code code = load.getCode(true);\r\n-\r\n-        //loadVersion(sm);\r\n-        code.aload().setThis();\r\n-        code.aload().setParam(0);\r\n-        code.invokevirtual().setMethod(\"loadVersion\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-\r\n-        //loadImplData(sm);\r\n-        code.aload().setThis();\r\n-        code.aload().setParam(0);\r\n-        code.invokevirtual().setMethod(\"loadImplData\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-        return code;\r\n-    }\r\n-\r\n-    /**\r\n-     * Add the field load.\r\n-     */\r\n-    private Instruction addLoad(BCClass bc, Code code, FieldMetaData fmd,\r\n-        int objectCount, int local, boolean fields) {\r\n-        int index = fmd.getIndex();\r\n-        int typeCode = replaceType(fmd);\r\n-        Instruction first;\r\n-        if (typeCode < JavaTypes.OBJECT) {\r\n-            // sm.store<type>(i, field<i>)\r\n-            Class type = forType(fmd.getTypeCode());\r\n-            first = code.aload().setParam(0);\r\n-            code.constant().setValue(index);\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(getFieldName(index), type);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"store\" + StringUtils.capitalize(type.getName()),\r\n-                void.class, new Class[]{ int.class, type });\r\n-        } else {\r\n-            // fmd = sm.getMetaData().getField(i);\r\n-            int offset = fields ? 1 : 0;\r\n-            first = code.aload().setParam(0);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"getMetaData\", ClassMetaData.class, null);\r\n-            code.constant().setValue(fmd.getIndex());\r\n-            code.invokevirtual().setMethod(ClassMetaData.class, \"getField\",\r\n-                FieldMetaData.class, new Class[]{ int.class });\r\n-            code.astore().setLocal(local);\r\n-            // sm.storeField(i, toField(sm, fmd, objects[objectCount],\r\n-            // \t\tfetch, context);\r\n-            code.aload().setParam(0);\r\n-            code.constant().setValue(index);\r\n-            code.aload().setThis();\r\n-            code.aload().setParam(0);\r\n-            code.aload().setLocal(local);\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(\"objects\", Object[].class);\r\n-            code.constant().setValue(objectCount);\r\n-            code.aaload();\r\n-            code.aload().setParam(1 + offset);\r\n-            code.aload().setParam(2 + offset);\r\n-            code.invokevirtual().setMethod(bc.getName(), \"toField\",\r\n-                Object.class.getName(), toStrings(new Class[]{ \r\n-                OpenJPAStateManager.class, FieldMetaData.class,\r\n-                Object.class, FetchConfiguration.class, Object.class }));\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"storeField\", void.class,\r\n-                new Class[]{ int.class, Object.class });\r\n-        }\r\n-        return first;\r\n-    }\r\n-\r\n-    /**\r\n-     * Load intermediate data if possible.\r\n-     */\r\n-    private Instruction addLoadIntermediate(Code code, int index,\r\n-        int objectCount, Collection jumps2, int inter) {\r\n-        // {\r\n-        // \t\tObject inter = objects[objectCount];\r\n-        Instruction first = code.aload().setThis();\r\n-        code.getfield().setField(\"objects\", Object[].class);\r\n-        code.constant().setValue(objectCount);\r\n-        code.aaload();\r\n-        code.astore().setLocal(inter);\r\n-        // \t\tif (inter != null && !sm.getLoaded().get(index))\r\n-        code.aload().setLocal(inter);\r\n-        jumps2.add(code.ifnull());\r\n-        code.aload().setParam(0);\r\n-        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-            \"getLoaded\", BitSet.class, null);\r\n-        code.constant().setValue(index);\r\n-        code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n-            boolean.class, new Class[]{ int.class });\r\n-        jumps2.add(code.ifne());\r\n-        //\t\t\tsm.setIntermediate(index, inter);\r\n-        //\t}  // end else\r\n-        code.aload().setParam(0);\r\n-        code.constant().setValue(index);\r\n-        code.aload().setLocal(inter);\r\n-        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-            \"setIntermediate\", void.class,\r\n-            new Class[]{ int.class, Object.class });\r\n-        return first;\r\n-    }\r\n-\r\n-    private void addStoreMethods(BCClass bc, ClassMetaData meta) {\r\n-        // i.e. void store(OpenJPAStateManager sm, BitSet fields);\r\n-        addStoreMethod(bc, meta, true);\r\n-        // i.e. void store(OpenJPAStateManager sm);\r\n-        addStoreMethod(bc, meta, false);\r\n-    }\r\n-\r\n-    private void addStoreMethod(BCClass bc, ClassMetaData meta,\r\n-        boolean fields) {\r\n-        BCMethod store;\r\n-        if (fields)\r\n-            store = bc.declareMethod(\"store\", void.class,\r\n-                new Class[]{ OpenJPAStateManager.class, BitSet.class });\r\n-        else\r\n-            store = bc.declareMethod(\"store\", void.class,\r\n-                new Class[]{ OpenJPAStateManager.class });\r\n-        Code code = store.getCode(true);\r\n-\r\n-        // initialize();\r\n-        code.aload().setThis();\r\n-        code.invokevirtual().setMethod(\"initialize\", void.class, null);\r\n-\r\n-        // storeVersion(sm);\r\n-        code.aload().setThis();\r\n-        code.aload().setParam(0);\r\n-        code.invokevirtual().setMethod(\"storeVersion\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-\r\n-        // storeImplData(sm);\r\n-        code.aload().setThis();\r\n-        code.aload().setParam(0);\r\n-        code.invokevirtual().setMethod(\"storeImplData\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-\r\n-        FieldMetaData[] fmds = meta.getFields();\r\n-        Collection jumps = new LinkedList();\r\n-        int objectCount = 0;\r\n-        for (int i = 0; i < fmds.length; i++) {\r\n-            if (fields) {\r\n-                //  if (fields != null && fields.get(index))\r\n-                setTarget(code.aload().setParam(1), jumps);\r\n-                jumps.add(code.ifnull());\r\n-                code.aload().setParam(1);\r\n-                code.constant().setValue(i);\r\n-                code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n-                    boolean.class, new Class[]{ int.class });\r\n-                jumps.add(code.ifeq());\r\n-            } else {\r\n-                // if (sm.getLoaded().get(index)))\r\n-                setTarget(code.aload().setParam(0), jumps);\r\n-                code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                    \"getLoaded\", BitSet.class, null);\r\n-                code.constant().setValue(i);\r\n-                code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n-                    boolean.class, new Class[]{ int.class });\r\n-                jumps.add(code.ifeq());\r\n-            }\r\n-            addStore(bc, code, fmds[i], objectCount);\r\n-            if (usesIntermediate(fmds[i])) {\r\n-                JumpInstruction elseIns = code.go2();\r\n-                // else if (!loaded.get(index))\r\n-                setTarget(code.aload().setThis(), jumps);\r\n-                jumps.add(elseIns);\r\n-                code.getfield().setField(\"loaded\", BitSet.class);\r\n-                code.constant().setValue(i);\r\n-                code.invokevirtual().setMethod(BitSet.class, \"get\",\r\n-                    boolean.class, new Class[]{ int.class });\r\n-                jumps.add(code.ifne());\r\n-                // Object val = sm.getIntermediate(index);\r\n-                // if (val != null)\r\n-                // \t\tobjects[objectCount] = val;\r\n-                code.aload().setParam(0);\r\n-                code.constant().setValue(i);\r\n-                code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                    \"getIntermediate\", Object.class, new Class[]{ int.class });\r\n-                int local = code.getNextLocalsIndex();\r\n-                code.astore().setLocal(local);\r\n-                code.aload().setLocal(local);\r\n-                jumps.add(code.ifnull());\r\n-                code.aload().setThis();\r\n-                code.getfield().setField(\"objects\", Object[].class);\r\n-                code.constant().setValue(objectCount);\r\n-                code.aload().setLocal(local);\r\n-                code.aastore();\r\n-            }\r\n-            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\r\n-                objectCount++;\r\n-        }\r\n-        setTarget(code.vreturn(), jumps);\r\n-        code.calculateMaxLocals();\r\n-        code.calculateMaxStack();\r\n-    }\r\n-\r\n-    private void addStore(BCClass bc, Code code, FieldMetaData fmd,\r\n-        int objectCount) {\r\n-        int typeCode = replaceType(fmd);\r\n-        int index = fmd.getIndex();\r\n-        if (typeCode < JavaTypes.OBJECT) {\r\n-            Class type = forType(typeCode);\r\n-            // field<i> = sm.fetch<Type>(index)\r\n-            code.aload().setThis();\r\n-            code.aload().setParam(0);\r\n-            code.constant().setValue(index);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"fetch\" + StringUtils.capitalize(type.getName()), type,\r\n-                new Class[]{ int.class });\r\n-            code.putfield().setField(getFieldName(index), type);\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(\"loaded\", BitSet.class);\r\n-            code.constant().setValue(index);\r\n-            code.invokevirtual().setMethod(BitSet.class, \"set\", void.class,\r\n-                new Class[]{ int.class });\r\n-        } else {\r\n-            // Object val = toData(sm.getMetaData().getField(index),\r\n-            // \t\tsm.fetchField(index, false), sm.getContext());\r\n-            int local = code.getNextLocalsIndex();\r\n-            code.aload().setThis();\r\n-            code.aload().setParam(0);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"getMetaData\", ClassMetaData.class, null);\r\n-            code.constant().setValue(fmd.getIndex());\r\n-            code.invokevirtual().setMethod(ClassMetaData.class,\r\n-                \"getField\", FieldMetaData.class, new Class[]{ int.class });\r\n-            code.aload().setParam(0);\r\n-            code.constant().setValue(fmd.getIndex());\r\n-            code.constant().setValue(false);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"fetchField\", Object.class, new Class[]\r\n-                { int.class, boolean.class });\r\n-            code.aload().setParam(0);\r\n-            code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-                \"getContext\", StoreContext.class, null);\r\n-            code.invokevirtual().setMethod(bc.getName(), \"toData\",\r\n-                Object.class.getName(), toStrings(new Class []{\r\n-                FieldMetaData.class, Object.class, StoreContext.class }));\r\n-            code.astore().setLocal(local);\r\n-\r\n-            // if (val == NULL) {\r\n-            // \t\tval = null;\r\n-            // \t\tloaded.clear(index);\r\n-            // \t} else\r\n-            // \t\tloaded.set(index);\r\n-            // \tobjects[objectCount] = val;\r\n-            code.aload().setLocal(local);\r\n-            code.getstatic().setField(AbstractPCData.class, \"NULL\",\r\n-                Object.class);\r\n-            JumpInstruction ifins = code.ifacmpne();\r\n-            code.constant().setNull();\r\n-            code.astore().setLocal(local);\r\n-            code.aload().setThis();\r\n-            code.getfield().setField(\"loaded\", BitSet.class);\r\n-            code.constant().setValue(index);\r\n-            code.invokevirtual().setMethod(BitSet.class, \"clear\", void.class,\r\n-                new Class[]{ int.class });\r\n-            JumpInstruction go2 = code.go2();\r\n-            ifins.setTarget(code.aload().setThis());\r\n-            code.getfield().setField(\"loaded\", BitSet.class);\r\n-            code.constant().setValue(index);\r\n-            code.invokevirtual().setMethod(BitSet.class, \"set\", void.class,\r\n-                new Class[]{ int.class });\r\n-            go2.setTarget(code.aload().setThis());\r\n-            code.getfield().setField(\"objects\", Object[].class);\r\n-            code.constant().setValue(objectCount);\r\n-            code.aload().setLocal(local);\r\n-            code.aastore();\r\n-        }\r\n-        if (!usesImplData(fmd))\r\n-            return;\r\n-\r\n-        // storeImplData(sm, i, loaded.get(i);\r\n-        code.aload().setThis();\r\n-        code.aload().setParam(0);\r\n-        code.constant().setValue(index);\r\n-        code.aload().setThis();\r\n-        code.getfield().setField(\"loaded\", BitSet.class);\r\n-        code.constant().setValue(index);\r\n-        code.invokevirtual().setMethod(BitSet.class, \"get\", boolean.class,\r\n-            new Class[]{ int.class });\r\n-        code.invokevirtual().setMethod(\"storeImplData\", void.class,\r\n-            new Class[]{ OpenJPAStateManager.class, int.class, boolean.class });\r\n-    }\r\n-\r\n-    private void addNewEmbedded(BCClass bc) {\r\n-        // void newEmbeddedPCData(OpenJPAStateManager embedded)\r\n-        BCMethod meth = bc.declareMethod(\"newEmbeddedPCData\", PCData.class,\r\n-            new Class[]{ OpenJPAStateManager.class });\r\n-        Code code = meth.getCode(true);\r\n-        // return getStorageGenerator().generatePCData\r\n-        // \t\t(sm.getId(), sm.getMetaData());\r\n-        code.aload().setThis();\r\n-        code.getfield().setField(\"storageGenerator\", PCDataGenerator.class);\r\n-        code.aload().setParam(0);\r\n-        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-            \"getId\", Object.class, null);\r\n-        code.aload().setParam(0);\r\n-        code.invokeinterface().setMethod(OpenJPAStateManager.class,\r\n-            \"getMetaData\", ClassMetaData.class, null);\r\n-        code.invokevirtual().setMethod(PCDataGenerator.class,\r\n-            \"generatePCData\", PCData.class, new Class[]\r\n-            { Object.class, ClassMetaData.class });\r\n-        code.areturn();\r\n-        code.calculateMaxLocals();\r\n-        code.calculateMaxStack();\r\n-    }\r\n-\r\n-    private void addGetData(BCClass bc) {\r\n-        // return getObjectField(i);\r\n-        BCMethod method = bc.declareMethod(\"getData\", Object.class,\r\n-            new Class[]{ int.class });\r\n-        Code code = method.getCode(true);\r\n-        code.aload().setThis();\r\n-        code.iload().setParam(0);\r\n-        code.invokevirtual().setMethod(\"getObject\", Object.class,\r\n-            new Class[]{ int.class });\r\n-        code.areturn();\r\n-        code.calculateMaxLocals();\r\n-        code.calculateMaxStack();\r\n-    }\r\n-\r\n-    /////////////\r\n-    // Utilities\r\n-    /////////////\r\n-\r\n-    /**\r\n-     * Return a valid {@link JavaTypes} constant for the given field\r\n-     */\r\n-    protected int replaceType(FieldMetaData fmd) {\r\n-        if (usesIntermediate(fmd))\r\n-            return JavaTypes.OBJECT;\r\n-        return fmd.getTypeCode();\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether the given field uses a cacheable intermediate value.\r\n-     */\r\n-    protected boolean usesIntermediate(FieldMetaData fmd) {\r\n-        return fmd.usesIntermediate();\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether the given type might have cacheable class-level impl data.\r\n-     */\r\n-    protected boolean usesImplData(ClassMetaData meta) {\r\n-        return true;\r\n-    }\r\n-\r\n-    /**\r\n-     * Whether the given field might have cacheable impl data.\r\n-     */\r\n-    protected boolean usesImplData(FieldMetaData fmd) {\r\n-        return fmd.usesImplData() == null;\r\n-    }\r\n-\r\n-    /**\r\n-     * The number of fields with cacheable impl data.\r\n-     */\r\n-    private int countImplDataFields(ClassMetaData meta) {\r\n-        FieldMetaData[] fmds = meta.getFields();\r\n-        int count = 0;\r\n-        for (int i = 0; i < fmds.length; i++)\r\n-            if (usesImplData(fmds[i]))\r\n-                count++;\r\n-        return count;\r\n-    }\r\n-\r\n-    /**\r\n-     * Add method which defers to AbstractPCData.\r\n-     */\r\n-    protected void callAbstractPCData(BCClass bc, String name, Class retType,\r\n-        Class[] args) {\r\n-        BCMethod meth = bc.declareMethod(name, retType, args);\r\n-        Code code = meth.getCode(true);\r\n-        code.aload().setThis();\r\n-        for (int i = 0; i < args.length; i++)\r\n-            code.xload().setParam(i).setType(args[i]);\r\n-        code.invokevirtual().setMethod(AbstractPCData.class, name, retType,\r\n-            args);\r\n-        if (!void.class.equals(retType))\r\n-            code.xreturn().setType(retType);\r\n-        code.calculateMaxLocals();\r\n-        code.calculateMaxStack();\r\n-    }\r\n-\r\n-    /**\r\n-     * Set the collection of {@link JumpInstruction}s to the given instruction,\r\n-     * clearing the collection in the process.\r\n-     */\r\n-    protected void setTarget(Instruction ins, Collection jumps) {\r\n-        for (Iterator it = jumps.iterator(); it.hasNext();)\r\n-            ((JumpInstruction) it.next()).setTarget(ins);\r\n-        jumps.clear();\r\n-    }\r\n-\r\n-    /**\r\n-     * Transform the given array of classes to strings.\r\n-     */\r\n-    private static String[] toStrings(Class[] cls) {\r\n-        String[] strings = new String[cls.length];\r\n-        for (int i = 0; i < strings.length; i++)\r\n-            strings[i] = cls[i].getName();\r\n-        return strings;\r\n-    }\r\n-\r\n-    /**\r\n-     * Dynamic {@link PCData}s generated will implement this interface\r\n-     * to simplify initialization.\r\n-     */\r\n-    public static interface DynamicPCData extends PCData {\r\n-\r\n-        public void setId(Object oid);\r\n-\r\n-        public PCDataGenerator getStorageGenerator();\r\n-\r\n-        public void setStorageGenerator (PCDataGenerator generator);\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.conf.OpenJPAConfiguration;\n+import org.apache.openjpa.kernel.AbstractPCData;\n+import org.apache.openjpa.kernel.FetchConfiguration;\n+import org.apache.openjpa.kernel.OpenJPAStateManager;\n+import org.apache.openjpa.kernel.PCData;\n+import org.apache.openjpa.kernel.StoreContext;\n+import org.apache.openjpa.lib.log.Log;\n+import org.apache.openjpa.lib.util.Localizer;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.meta.JavaTypes;\n+import org.apache.openjpa.util.InternalException;\n+import serp.bytecode.BCClass;\n+import serp.bytecode.BCField;\n+import serp.bytecode.BCMethod;\n+import serp.bytecode.Code;\n+import serp.bytecode.Constants;\n+import serp.bytecode.ExceptionHandler;\n+import serp.bytecode.Instruction;\n+import serp.bytecode.JumpInstruction;\n+import serp.bytecode.LookupSwitchInstruction;\n+\n+/**\n+ * Generates {@link PCData} instances which avoid primitve wrappers\n+ * to optimize memory use and performance at the cost of slightly higher\n+ * startup time.\n+ *\n+ * @author Steve Kim\n+ * @nojavadoc\n+ * @since 0.3.2\n+ */\n+public class PCDataGenerator\n+    extends DynamicStorageGenerator {\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (PCDataGenerator.class);\n+\n+    protected static final String POSTFIX = \"$openjpapcdata\";\n+\n+    private final Map _generated = new ConcurrentHashMap();\n+    private final OpenJPAConfiguration _conf;\n+    private final Log _log;\n+\n+    public PCDataGenerator(OpenJPAConfiguration conf) {\n+        _conf = conf;\n+        _log = _conf.getLogFactory().getLog(OpenJPAConfiguration.LOG_ENHANCE);\n+    }\n+\n+    /**\n+     * Return the configuration.\n+     */\n+    public OpenJPAConfiguration getConfiguration() {\n+        return _conf;\n+    }\n+\n+    /**\n+     * Return a {@link PCData} instance for the given oid and metadata.\n+     */\n+    public PCData generatePCData(Object oid, ClassMetaData meta) {\n+        if (meta == null)\n+            return null;\n+        Class type = meta.getDescribedType();\n+        DynamicStorage storage = (DynamicStorage) _generated.get(type);\n+        if (storage == null) {\n+            storage = generateStorage(meta);\n+            _generated.put(type, storage);\n+            if (_log.isTraceEnabled())\n+                _log.trace(_loc.get(\"pcdata-created\", type.getName(), meta));\n+        }\n+        DynamicPCData data = (DynamicPCData) storage.newInstance();\n+        data.setId(oid);\n+        data.setStorageGenerator(this);\n+        finish(data, meta);\n+        return data;\n+    }\n+\n+    /**\n+     * Actually generate the factory instance.\n+     */\n+    private DynamicStorage generateStorage(ClassMetaData meta) {\n+        if (_log.isTraceEnabled())\n+            _log.trace(_loc.get(\"pcdata-generate\", meta));\n+\n+        FieldMetaData[] fields = meta.getFields();\n+        int[] types = new int[fields.length];\n+        for (int i = 0; i < types.length; i++)\n+            types[i] = replaceType(fields[i]);\n+        return generateStorage(types, meta);\n+    }\n+\n+    /**\n+     * Perform any final actions before the pcdata is returned to client code.\n+     */\n+    protected void finish(DynamicPCData data, ClassMetaData meta) {\n+    }\n+\n+    protected int getCreateFieldMethods(int typeCode) {\n+        if (typeCode >= JavaTypes.OBJECT)\n+            return POLICY_SILENT;\n+        // don't bother creating set/get<Primitive> methods\n+        return POLICY_EMPTY;\n+    }\n+\n+    protected void declareClasses(BCClass bc) {\n+        super.declareClasses(bc);\n+        bc.declareInterface(DynamicPCData.class);\n+        bc.setSuperclass(AbstractPCData.class);\n+    }\n+\n+    protected final String getClassName(Object obj) {\n+        return getUniqueName(((ClassMetaData) obj).getDescribedType());\n+    }\n+\n+    /**\n+     * Creates a unique name for the given type's pcdata implementation.\n+     */\n+    protected String getUniqueName(Class type) {\n+        return type.getName() + \"$\" + System.identityHashCode(type) + POSTFIX;\n+    }\n+\n+    protected final void decorate(Object obj, BCClass bc, int[] types) {\n+        super.decorate(obj, bc, types);\n+        ClassMetaData meta = (ClassMetaData) obj;\n+\n+        enhanceConstructor(bc);\n+        addBaseFields(bc);\n+        addImplDataMethods(bc, meta);\n+        addFieldImplDataMethods(bc, meta);\n+        addVersionMethods(bc);\n+        addGetType(bc, meta);\n+        addLoadMethod(bc, meta);\n+        addLoadWithFieldsMethod(bc, meta);\n+        addStoreMethods(bc, meta);\n+        addNewEmbedded(bc);\n+        addGetData(bc);\n+        decorate(bc, meta);\n+    }\n+\n+    /**\n+     * Apply additional decoration to generated class.\n+     */\n+    protected void decorate(BCClass bc, ClassMetaData meta) {\n+    }\n+\n+    /**\n+     * Enhance constructor to initialize fields\n+     */\n+    private void enhanceConstructor(BCClass bc) {\n+        BCMethod cons = bc.getDeclaredMethod(\"<init>\", (String[]) null);\n+        Code code = cons.getCode(false);\n+        code.afterLast();\n+        code.previous();\n+\n+        // private BitSet loaded = new BitSet();\n+        BCField loaded = addBeanField(bc, \"loaded\", BitSet.class);\n+        loaded.setFinal(true);\n+        code.aload().setThis();\n+        code.anew().setType(BitSet.class);\n+        code.dup();\n+        code.constant().setValue(bc.getFields().length);\n+        code.invokespecial().setMethod(BitSet.class, \"<init>\", void.class,\n+            new Class[]{ int.class });\n+        code.putfield().setField(loaded);\n+\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n+    /**\n+     * Have to load the type since it may not be available to the\n+     * same classloader (i.e. rar vs. ear). The context classloader\n+     * (i.e. the user app classloader) should be fine.\n+     */\n+    private void addGetType(BCClass bc, ClassMetaData meta) {\n+        BCField type = bc.declareField(\"type\", Class.class);\n+        type.setStatic(true);\n+        type.makePrivate();\n+        // public Class getType() {\n+        BCMethod getter = bc.declareMethod(\"getType\", Class.class, null);\n+        getter.makePublic();\n+        Code code = getter.getCode(true);\n+        // if (type == null) {\n+        // \t\ttry {\n+        // \t\t\ttype = Class.forName\n+        // \t\t\t\t(meta.getDescribedType().getName(), true,\n+        // \t\t\t\tThread.currentThread().getContextClassLoader());\n+        // \t\t} catch (ClassNotFoundException cnfe) {\n+        // \t\t\tthrow new InternalException();\n+        // \t\t}\n+        // }\n+        code.getstatic().setField(type);\n+\n+        Collection jumps = new LinkedList();\n+        jumps.add(code.ifnonnull());\n+        ExceptionHandler handler = code.addExceptionHandler();\n+\n+        handler.setTryStart(code.constant().setValue\n+            (meta.getDescribedType().getName()));\n+        code.constant().setValue(true);\n+        code.invokestatic().setMethod(Thread.class, \"currentThread\",\n+            Thread.class, null);\n+        code.invokevirtual().setMethod(Thread.class, \"getContextClassLoader\",\n+            ClassLoader.class, null);\n+        code.invokestatic().setMethod(Class.class, \"forName\", Class.class,\n+            new Class[]{ String.class, boolean.class, ClassLoader.class });\n+        code.putstatic().setField(type);\n+        Instruction go2 = code.go2();\n+        jumps.add(go2);\n+        handler.setTryEnd(go2);\n+        handler.setCatch(ClassNotFoundException.class);\n+        handler.setHandlerStart(throwException\n+            (code, InternalException.class));\n+        setTarget(code.getstatic().setField(type), jumps);\n+        code.areturn();\n+\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n+    /**\n+     * Declare standard dynamic pcdata fields.\n+     */\n+    private void addBaseFields(BCClass bc) {\n+        addBeanField(bc, \"id\", Object.class);\n+        BCField field = addBeanField(bc, \"storageGenerator\",\n+            PCDataGenerator.class);\n+        field.setAccessFlags(field.getAccessFlags()\n+            | Constants.ACCESS_TRANSIENT);\n+    }\n+\n+    /**\n+     * Add methods for loading and storing class-level impl data.\n+     */\n+    private void addImplDataMethods(BCClass bc, ClassMetaData meta) {\n+        // void storeImplData(OpenJPAStateManager);\n+        BCMethod meth = bc.declareMethod(\"storeImplData\", void.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+        Code code = meth.getCode(true);\n+\n+        BCField impl = null;\n+        if (!usesImplData(meta))\n+            code.vreturn();\n+        else {\n+            // if (sm.isImplDataCacheable())\n+            // \t\tsetImplData(sm.getImplData());\n+            impl = addBeanField(bc, \"implData\", Object.class);\n+            code.aload().setParam(0);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"isImplDataCacheable\", boolean.class, null);\n+            JumpInstruction ifins = code.ifeq();\n+            code.aload().setThis();\n+            code.aload().setParam(0);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"getImplData\", Object.class, null);\n+            code.invokevirtual().setMethod(\"setImplData\", void.class,\n+                new Class[]{ Object.class });\n+            ifins.setTarget(code.vreturn());\n+        }\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+\n+        // void loadImplData(OpenJPAStateManager);\n+        meth = bc.declareMethod(\"loadImplData\", void.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+        code = meth.getCode(true);\n+        if (!usesImplData(meta))\n+            code.vreturn();\n+        else {\n+            // if (sm.getImplData() == null && implData != null)\n+            // \t\tsm.setImplData(impl, true);\n+            code.aload().setParam(0);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"getImplData\", Object.class, null);\n+            JumpInstruction ifins = code.ifnonnull();\n+            code.aload().setThis();\n+            code.getfield().setField(impl);\n+            JumpInstruction ifins2 = code.ifnull();\n+            code.aload().setParam(0);\n+            code.aload().setThis();\n+            code.getfield().setField(impl);\n+            code.constant().setValue(true);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"setImplData\", void.class,\n+                new Class[]{ Object.class, boolean.class });\n+            Instruction ins = code.vreturn();\n+            ifins.setTarget(ins);\n+            ifins2.setTarget(ins);\n+        }\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n+    /**\n+     * Add methods for loading and storing class-level impl data.\n+     */\n+    private void addFieldImplDataMethods(BCClass bc, ClassMetaData meta) {\n+        // public void loadImplData(OpenJPAStateManager sm, int i)\n+        BCMethod meth = bc.declareMethod(\"loadImplData\", void.class,\n+            new Class[]{ OpenJPAStateManager.class, int.class });\n+        meth.makePrivate();\n+        Code code = meth.getCode(true);\n+\n+        int count = countImplDataFields(meta);\n+        BCField impl = null;\n+        if (count == 0)\n+            code.vreturn();\n+        else {\n+            // Object[] fieldImpl\n+            impl = bc.declareField(\"fieldImpl\", Object[].class);\n+            impl.makePrivate();\n+\n+            // if (fieldImpl != null)\n+            code.aload().setThis();\n+            code.getfield().setField(impl);\n+            JumpInstruction ifins = code.ifnonnull();\n+            code.vreturn();\n+\n+            // Object obj = null;\n+            int obj = code.getNextLocalsIndex();\n+            ifins.setTarget(code.constant().setNull());\n+            code.astore().setLocal(obj);\n+\n+            // establish switch target, then move before it\n+            Instruction target = code.aload().setLocal(obj);\n+            code.previous();\n+\n+            // switch(i)\n+            code.iload().setParam(1);\n+            LookupSwitchInstruction lswitch = code.lookupswitch();\n+            FieldMetaData[] fields = meta.getFields();\n+            int cacheable = 0;\n+            for (int i = 0; i < fields.length; i++) {\n+                if (!usesImplData(fields[i]))\n+                    continue;\n+                // case x: obj = fieldImpl[y]; break;\n+                lswitch.addCase(i, code.aload().setThis());\n+                code.getfield().setField(impl);\n+                code.constant().setValue(cacheable++);\n+                code.aaload();\n+                code.astore().setLocal(obj);\n+                code.go2().setTarget(target);\n+            }\n+            lswitch.setDefaultTarget(target);\n+\n+            // if (obj != null)\n+            code.next();    // jump back over target\n+            ifins = code.ifnonnull();\n+            code.vreturn();\n+\n+            // sm.setImplData(index, impl);\n+            ifins.setTarget(code.aload().setParam(0));\n+            code.iload().setParam(1);\n+            code.aload().setLocal(obj);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"setImplData\", void.class,\n+                new Class[]{ int.class, Object.class });\n+            code.vreturn();\n+        }\n+        code.calculateMaxLocals();\n+        code.calculateMaxStack();\n+\n+        // void storeImplData(OpenJPAStateManager sm, int index, boolean loaded)\n+        meth = bc.declareMethod(\"storeImplData\", void.class,\n+            new Class[]{ OpenJPAStateManager.class, int.class, boolean.class });\n+        code = meth.getCode(true);\n+        if (count == 0)\n+            code.vreturn();\n+        else {\n+            // int arrIdx = -1;\n+            // switch(index)\n+            int arrIdx = code.getNextLocalsIndex();\n+            code.constant().setValue(-1);\n+            code.istore().setLocal(arrIdx);\n+            code.iload().setParam(1);\n+            LookupSwitchInstruction lswitch = code.lookupswitch();\n+\n+            // establish switch target, then move before it\n+            Instruction switchTarget = code.iload().setLocal(arrIdx);\n+            code.previous();\n+\n+            FieldMetaData[] fields = meta.getFields();\n+            int cacheable = 0;\n+            for (int i = 0; i < fields.length; i++) {\n+                if (!usesImplData(fields[i]))\n+                    continue;\n+                // case x: arrIdx = y; break;\n+                lswitch.addCase(i, code.constant().setValue(cacheable++));\n+                code.istore().setLocal(arrIdx);\n+                code.go2().setTarget(switchTarget);\n+            }\n+            lswitch.setDefaultTarget(switchTarget);\n+            code.next();    // step over switch target\n+\n+            // if (arrIdx != -1)\n+            code.constant().setValue(-1);\n+            JumpInstruction ifins = code.ificmpne();\n+            code.vreturn();\n+\n+            // create null target, then move before it\n+            Instruction nullTarget = code.aload().setThis();\n+            code.previous();\n+\n+            // if (loaded)\n+            ifins.setTarget(code.iload().setParam(2));\n+            code.ifeq().setTarget(nullTarget);\n+\n+            // Object obj = sm.getImplData(index)\n+            int obj = code.getNextLocalsIndex();\n+            code.aload().setParam(0);\n+            code.iload().setParam(1);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"getImplData\", Object.class, new Class[]{ int.class });\n+            code.astore().setLocal(obj);\n+\n+            // if (obj != null)\n+            code.aload().setLocal(obj);\n+            code.ifnull().setTarget(nullTarget);\n+\n+            // if (fieldImpl == null)\n+            // \t\tfieldImpl = new Object[fields];\n+            code.aload().setThis();\n+            code.getfield().setField(impl);\n+            ifins = code.ifnonnull();\n+            code.aload().setThis();\n+            code.constant().setValue(count);\n+            code.anewarray().setType(Object.class);\n+            code.putfield().setField(impl);\n+\n+            // fieldImpl[arrIdx] = obj;\n+            // return;\n+            ifins.setTarget(code.aload().setThis());\n+            code.getfield().setField(impl);\n+            code.iload().setLocal(arrIdx);\n+            code.aload().setLocal(obj);\n+            code.aastore();\n+            code.vreturn();\n+\n+            // if (fieldImpl != null)\n+            // \t\tfieldImpl[index] = null;\n+            code.next(); // step over nullTarget\n+            code.getfield().setField(impl);\n+            ifins = code.ifnonnull();\n+            code.vreturn();\n+            ifins.setTarget(code.aload().setThis());\n+            code.getfield().setField(impl);\n+            code.iload().setLocal(arrIdx);\n+            code.constant().setNull();\n+            code.aastore();\n+            code.vreturn();\n+        }\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n+    /**\n+     * Add methods for loading and storing version data.\n+     */\n+    protected void addVersionMethods(BCClass bc) {\n+        // void storeVersion(OpenJPAStateManager sm);\n+        addBeanField(bc, \"version\", Object.class);\n+        BCMethod meth = bc.declareMethod(\"storeVersion\", void.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+        Code code = meth.getCode(true);\n+\n+        // version = sm.getVersion();\n+        code.aload().setThis();\n+        code.aload().setParam(0);\n+        code.invokeinterface()\n+            .setMethod(OpenJPAStateManager.class, \"getVersion\",\n+                Object.class, null);\n+        code.putfield().setField(\"version\", Object.class);\n+        code.vreturn();\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+\n+        // void loadVersion(OpenJPAStateManager sm)\n+        meth = bc.declareMethod(\"loadVersion\", void.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+        code = meth.getCode(true);\n+\n+        // if (sm.getVersion() == null)\n+        // \t\tsm.setVersion(version);\n+        code.aload().setParam(0);\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+            \"getVersion\", Object.class, null);\n+        JumpInstruction ifins = code.ifnonnull();\n+        code.aload().setParam(0);\n+        code.aload().setThis();\n+        code.getfield().setField(\"version\", Object.class);\n+        code.invokeinterface()\n+            .setMethod(OpenJPAStateManager.class, \"setVersion\",\n+                void.class, new Class[]{ Object.class });\n+        ifins.setTarget(code.vreturn());\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n+    private void addLoadMethod(BCClass bc, ClassMetaData meta) {\n+        // public void load(OpenJPAStateManager sm, FetchConfiguration fetch,\n+        // \t\tObject context)\n+        Code code = addLoadMethod(bc, false);\n+        FieldMetaData[] fmds = meta.getFields();\n+        Collection jumps = new LinkedList();\n+        Collection jumps2;\n+\t\t\n+        int local = code.getNextLocalsIndex();\n+        code.constant().setNull();\n+        code.astore().setLocal(local);\n+        int inter = code.getNextLocalsIndex();\n+        code.constant().setNull();\n+        code.astore().setLocal(inter);\n+\n+        int objectCount = 0;\n+        boolean intermediate;\n+        for (int i = 0; i < fmds.length; i++) {\n+            jumps2 = new LinkedList();\n+            intermediate = usesIntermediate(fmds[i]);\n+            setTarget(code.aload().setThis(), jumps);\n+            // if (loaded.get(i)) or (!loaded.get(i)) depending on inter resp\n+            code.getfield().setField(\"loaded\", BitSet.class);\n+            code.constant().setValue(i);\n+            code.invokevirtual().setMethod(BitSet.class, \"get\",\n+                boolean.class, new Class[]{ int.class });\n+            jumps.add(code.ifne());\n+\n+            if (intermediate)\n+                addLoadIntermediate(code, i, objectCount, jumps2, inter);\n+            jumps2.add(code.go2());\n+\n+            // if (fetch.requiresFetch(fmds[i])!=FetchConfiguration.FETCH_NONE)\n+            setTarget(code.aload().setParam(1), jumps);\n+            code.aload().setParam(0);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"getMetaData\", ClassMetaData.class, null);\n+            code.constant().setValue(fmds[i].getIndex());\n+            code.invokevirtual().setMethod(ClassMetaData.class,\n+                \"getField\", FieldMetaData.class, new Class[]{int.class});\n+            code.invokeinterface().setMethod (FetchConfiguration.class, \n+                \"requiresFetch\", int.class, new Class[]{FieldMetaData.class});\n+            code.constant().setValue(FetchConfiguration.FETCH_NONE);\n+            jumps2.add(code.ificmpeq());\n+            addLoad(bc, code, fmds[i], objectCount, local, false);\n+\n+            jumps = jumps2;\n+            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\n+                objectCount++;\n+        }\n+        setTarget(code.vreturn(), jumps);\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n+    private void addLoadWithFieldsMethod(BCClass bc, ClassMetaData meta) {\n+        Code code = addLoadMethod(bc, true);\n+        // public void load(OpenJPAStateManager sm, BitSet fields,\n+        // \t\tFetchConfiguration fetch, Object conn)\n+        FieldMetaData[] fmds = meta.getFields();\n+        Collection jumps = new LinkedList();\n+        Collection jumps2;\n+        int objectCount = 0;\n+        boolean intermediate;\n+        int local = code.getNextLocalsIndex();\n+        code.constant().setNull();\n+        code.astore().setLocal(local);\n+        int inter = code.getNextLocalsIndex();\n+        code.constant().setNull();\n+        code.astore().setLocal(inter);\n+\n+        for (int i = 0; i < fmds.length; i++) {\n+            jumps2 = new LinkedList();\n+            intermediate = usesIntermediate(fmds[i]);\n+            // if (fields.get(i))\n+            // {\n+            // \t\tif (loaded.get(i))\n+            setTarget(code.aload().setParam(1), jumps);\n+            code.constant().setValue(i);\n+            code.invokevirtual().setMethod(BitSet.class, \"get\",\n+                boolean.class, new Class[]{ int.class });\n+            jumps2.add(code.ifeq());\n+            code.aload().setThis();\n+            code.getfield().setField(\"loaded\", BitSet.class);\n+            code.constant().setValue(i);\n+            code.invokevirtual().setMethod(BitSet.class, \"get\",\n+                boolean.class, new Class[]{ int.class });\n+            if (intermediate)\n+                jumps.add(code.ifeq());\n+            else\n+                jumps2.add(code.ifeq());\n+\n+            addLoad(bc, code, fmds[i], objectCount, local, true);\n+            if (usesImplData(fmds[i])) {\n+                // loadImplData(sm, i);\n+                code.aload().setThis();\n+                code.aload().setParam(0);\n+                code.constant().setValue(i);\n+                code.invokevirtual().setMethod(\"loadImplData\", void.class,\n+                    new Class[]{ OpenJPAStateManager.class, int.class });\n+            }\n+\n+            // fields.clear(i);\n+            code.aload().setParam(1);\n+            code.constant().setValue(i);\n+            code.invokevirtual().setMethod(BitSet.class, \"clear\", void.class,\n+                new Class[] { int.class });\n+\n+            jumps2.add(code.go2());\n+\n+            if (intermediate)\n+                setTarget(addLoadIntermediate\n+                    (code, i, objectCount, jumps2, inter), jumps);\n+\n+            jumps = jumps2;\n+            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\n+                objectCount++;\n+        }\n+        setTarget(code.vreturn(), jumps);\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n+    /**\n+     * Declare and start the base load method.\n+     */\n+    private Code addLoadMethod(BCClass bc, boolean fields) {\n+        Class[] args = null;\n+        if (fields)\n+            args = new Class[]{ OpenJPAStateManager.class, BitSet.class,\n+                FetchConfiguration.class, Object.class };\n+        else\n+            args = new Class[]{ OpenJPAStateManager.class,\n+                FetchConfiguration.class, Object.class };\n+        BCMethod load = bc.declareMethod(\"load\", void.class, args);\n+        Code code = load.getCode(true);\n+\n+        //loadVersion(sm);\n+        code.aload().setThis();\n+        code.aload().setParam(0);\n+        code.invokevirtual().setMethod(\"loadVersion\", void.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+\n+        //loadImplData(sm);\n+        code.aload().setThis();\n+        code.aload().setParam(0);\n+        code.invokevirtual().setMethod(\"loadImplData\", void.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+        return code;\n+    }\n+\n+    /**\n+     * Add the field load.\n+     */\n+    private Instruction addLoad(BCClass bc, Code code, FieldMetaData fmd,\n+        int objectCount, int local, boolean fields) {\n+        int index = fmd.getIndex();\n+        int typeCode = replaceType(fmd);\n+        Instruction first;\n+        if (typeCode < JavaTypes.OBJECT) {\n+            // sm.store<type>(i, field<i>)\n+            Class type = forType(fmd.getTypeCode());\n+            first = code.aload().setParam(0);\n+            code.constant().setValue(index);\n+            code.aload().setThis();\n+            code.getfield().setField(getFieldName(index), type);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"store\" + StringUtils.capitalize(type.getName()),\n+                void.class, new Class[]{ int.class, type });\n+        } else {\n+            // fmd = sm.getMetaData().getField(i);\n+            int offset = fields ? 1 : 0;\n+            first = code.aload().setParam(0);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"getMetaData\", ClassMetaData.class, null);\n+            code.constant().setValue(fmd.getIndex());\n+            code.invokevirtual().setMethod(ClassMetaData.class, \"getField\",\n+                FieldMetaData.class, new Class[]{ int.class });\n+            code.astore().setLocal(local);\n+            // sm.storeField(i, toField(sm, fmd, objects[objectCount],\n+            // \t\tfetch, context);\n+            code.aload().setParam(0);\n+            code.constant().setValue(index);\n+            code.aload().setThis();\n+            code.aload().setParam(0);\n+            code.aload().setLocal(local);\n+            code.aload().setThis();\n+            code.getfield().setField(\"objects\", Object[].class);\n+            code.constant().setValue(objectCount);\n+            code.aaload();\n+            code.aload().setParam(1 + offset);\n+            code.aload().setParam(2 + offset);\n+            code.invokevirtual().setMethod(bc.getName(), \"toField\",\n+                Object.class.getName(), toStrings(new Class[]{ \n+                OpenJPAStateManager.class, FieldMetaData.class,\n+                Object.class, FetchConfiguration.class, Object.class }));\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"storeField\", void.class,\n+                new Class[]{ int.class, Object.class });\n+        }\n+        return first;\n+    }\n+\n+    /**\n+     * Load intermediate data if possible.\n+     */\n+    private Instruction addLoadIntermediate(Code code, int index,\n+        int objectCount, Collection jumps2, int inter) {\n+        // {\n+        // \t\tObject inter = objects[objectCount];\n+        Instruction first = code.aload().setThis();\n+        code.getfield().setField(\"objects\", Object[].class);\n+        code.constant().setValue(objectCount);\n+        code.aaload();\n+        code.astore().setLocal(inter);\n+        // \t\tif (inter != null && !sm.getLoaded().get(index))\n+        code.aload().setLocal(inter);\n+        jumps2.add(code.ifnull());\n+        code.aload().setParam(0);\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+            \"getLoaded\", BitSet.class, null);\n+        code.constant().setValue(index);\n+        code.invokevirtual().setMethod(BitSet.class, \"get\",\n+            boolean.class, new Class[]{ int.class });\n+        jumps2.add(code.ifne());\n+        //\t\t\tsm.setIntermediate(index, inter);\n+        //\t}  // end else\n+        code.aload().setParam(0);\n+        code.constant().setValue(index);\n+        code.aload().setLocal(inter);\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+            \"setIntermediate\", void.class,\n+            new Class[]{ int.class, Object.class });\n+        return first;\n+    }\n+\n+    private void addStoreMethods(BCClass bc, ClassMetaData meta) {\n+        // i.e. void store(OpenJPAStateManager sm, BitSet fields);\n+        addStoreMethod(bc, meta, true);\n+        // i.e. void store(OpenJPAStateManager sm);\n+        addStoreMethod(bc, meta, false);\n+    }\n+\n+    private void addStoreMethod(BCClass bc, ClassMetaData meta,\n+        boolean fields) {\n+        BCMethod store;\n+        if (fields)\n+            store = bc.declareMethod(\"store\", void.class,\n+                new Class[]{ OpenJPAStateManager.class, BitSet.class });\n+        else\n+            store = bc.declareMethod(\"store\", void.class,\n+                new Class[]{ OpenJPAStateManager.class });\n+        Code code = store.getCode(true);\n+\n+        // initialize();\n+        code.aload().setThis();\n+        code.invokevirtual().setMethod(\"initialize\", void.class, null);\n+\n+        // storeVersion(sm);\n+        code.aload().setThis();\n+        code.aload().setParam(0);\n+        code.invokevirtual().setMethod(\"storeVersion\", void.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+\n+        // storeImplData(sm);\n+        code.aload().setThis();\n+        code.aload().setParam(0);\n+        code.invokevirtual().setMethod(\"storeImplData\", void.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+\n+        FieldMetaData[] fmds = meta.getFields();\n+        Collection jumps = new LinkedList();\n+        int objectCount = 0;\n+        for (int i = 0; i < fmds.length; i++) {\n+            if (fields) {\n+                //  if (fields != null && fields.get(index))\n+                setTarget(code.aload().setParam(1), jumps);\n+                jumps.add(code.ifnull());\n+                code.aload().setParam(1);\n+                code.constant().setValue(i);\n+                code.invokevirtual().setMethod(BitSet.class, \"get\",\n+                    boolean.class, new Class[]{ int.class });\n+                jumps.add(code.ifeq());\n+            } else {\n+                // if (sm.getLoaded().get(index)))\n+                setTarget(code.aload().setParam(0), jumps);\n+                code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                    \"getLoaded\", BitSet.class, null);\n+                code.constant().setValue(i);\n+                code.invokevirtual().setMethod(BitSet.class, \"get\",\n+                    boolean.class, new Class[]{ int.class });\n+                jumps.add(code.ifeq());\n+            }\n+            addStore(bc, code, fmds[i], objectCount);\n+            if (usesIntermediate(fmds[i])) {\n+                JumpInstruction elseIns = code.go2();\n+                // else if (!loaded.get(index))\n+                setTarget(code.aload().setThis(), jumps);\n+                jumps.add(elseIns);\n+                code.getfield().setField(\"loaded\", BitSet.class);\n+                code.constant().setValue(i);\n+                code.invokevirtual().setMethod(BitSet.class, \"get\",\n+                    boolean.class, new Class[]{ int.class });\n+                jumps.add(code.ifne());\n+                // Object val = sm.getIntermediate(index);\n+                // if (val != null)\n+                // \t\tobjects[objectCount] = val;\n+                code.aload().setParam(0);\n+                code.constant().setValue(i);\n+                code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                    \"getIntermediate\", Object.class, new Class[]{ int.class });\n+                int local = code.getNextLocalsIndex();\n+                code.astore().setLocal(local);\n+                code.aload().setLocal(local);\n+                jumps.add(code.ifnull());\n+                code.aload().setThis();\n+                code.getfield().setField(\"objects\", Object[].class);\n+                code.constant().setValue(objectCount);\n+                code.aload().setLocal(local);\n+                code.aastore();\n+            }\n+            if (replaceType(fmds[i]) >= JavaTypes.OBJECT)\n+                objectCount++;\n+        }\n+        setTarget(code.vreturn(), jumps);\n+        code.calculateMaxLocals();\n+        code.calculateMaxStack();\n+    }\n+\n+    private void addStore(BCClass bc, Code code, FieldMetaData fmd,\n+        int objectCount) {\n+        int typeCode = replaceType(fmd);\n+        int index = fmd.getIndex();\n+        if (typeCode < JavaTypes.OBJECT) {\n+            Class type = forType(typeCode);\n+            // field<i> = sm.fetch<Type>(index)\n+            code.aload().setThis();\n+            code.aload().setParam(0);\n+            code.constant().setValue(index);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"fetch\" + StringUtils.capitalize(type.getName()), type,\n+                new Class[]{ int.class });\n+            code.putfield().setField(getFieldName(index), type);\n+            code.aload().setThis();\n+            code.getfield().setField(\"loaded\", BitSet.class);\n+            code.constant().setValue(index);\n+            code.invokevirtual().setMethod(BitSet.class, \"set\", void.class,\n+                new Class[]{ int.class });\n+        } else {\n+            // Object val = toData(sm.getMetaData().getField(index),\n+            // \t\tsm.fetchField(index, false), sm.getContext());\n+            int local = code.getNextLocalsIndex();\n+            code.aload().setThis();\n+            code.aload().setParam(0);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"getMetaData\", ClassMetaData.class, null);\n+            code.constant().setValue(fmd.getIndex());\n+            code.invokevirtual().setMethod(ClassMetaData.class,\n+                \"getField\", FieldMetaData.class, new Class[]{ int.class });\n+            code.aload().setParam(0);\n+            code.constant().setValue(fmd.getIndex());\n+            code.constant().setValue(false);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"fetchField\", Object.class, new Class[]\n+                { int.class, boolean.class });\n+            code.aload().setParam(0);\n+            code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+                \"getContext\", StoreContext.class, null);\n+            code.invokevirtual().setMethod(bc.getName(), \"toData\",\n+                Object.class.getName(), toStrings(new Class []{\n+                FieldMetaData.class, Object.class, StoreContext.class }));\n+            code.astore().setLocal(local);\n+\n+            // if (val == NULL) {\n+            // \t\tval = null;\n+            // \t\tloaded.clear(index);\n+            // \t} else\n+            // \t\tloaded.set(index);\n+            // \tobjects[objectCount] = val;\n+            code.aload().setLocal(local);\n+            code.getstatic().setField(AbstractPCData.class, \"NULL\",\n+                Object.class);\n+            JumpInstruction ifins = code.ifacmpne();\n+            code.constant().setNull();\n+            code.astore().setLocal(local);\n+            code.aload().setThis();\n+            code.getfield().setField(\"loaded\", BitSet.class);\n+            code.constant().setValue(index);\n+            code.invokevirtual().setMethod(BitSet.class, \"clear\", void.class,\n+                new Class[]{ int.class });\n+            JumpInstruction go2 = code.go2();\n+            ifins.setTarget(code.aload().setThis());\n+            code.getfield().setField(\"loaded\", BitSet.class);\n+            code.constant().setValue(index);\n+            code.invokevirtual().setMethod(BitSet.class, \"set\", void.class,\n+                new Class[]{ int.class });\n+            go2.setTarget(code.aload().setThis());\n+            code.getfield().setField(\"objects\", Object[].class);\n+            code.constant().setValue(objectCount);\n+            code.aload().setLocal(local);\n+            code.aastore();\n+        }\n+        if (!usesImplData(fmd))\n+            return;\n+\n+        // storeImplData(sm, i, loaded.get(i);\n+        code.aload().setThis();\n+        code.aload().setParam(0);\n+        code.constant().setValue(index);\n+        code.aload().setThis();\n+        code.getfield().setField(\"loaded\", BitSet.class);\n+        code.constant().setValue(index);\n+        code.invokevirtual().setMethod(BitSet.class, \"get\", boolean.class,\n+            new Class[]{ int.class });\n+        code.invokevirtual().setMethod(\"storeImplData\", void.class,\n+            new Class[]{ OpenJPAStateManager.class, int.class, boolean.class });\n+    }\n+\n+    private void addNewEmbedded(BCClass bc) {\n+        // void newEmbeddedPCData(OpenJPAStateManager embedded)\n+        BCMethod meth = bc.declareMethod(\"newEmbeddedPCData\", PCData.class,\n+            new Class[]{ OpenJPAStateManager.class });\n+        Code code = meth.getCode(true);\n+        // return getStorageGenerator().generatePCData\n+        // \t\t(sm.getId(), sm.getMetaData());\n+        code.aload().setThis();\n+        code.getfield().setField(\"storageGenerator\", PCDataGenerator.class);\n+        code.aload().setParam(0);\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+            \"getId\", Object.class, null);\n+        code.aload().setParam(0);\n+        code.invokeinterface().setMethod(OpenJPAStateManager.class,\n+            \"getMetaData\", ClassMetaData.class, null);\n+        code.invokevirtual().setMethod(PCDataGenerator.class,\n+            \"generatePCData\", PCData.class, new Class[]\n+            { Object.class, ClassMetaData.class });\n+        code.areturn();\n+        code.calculateMaxLocals();\n+        code.calculateMaxStack();\n+    }\n+\n+    private void addGetData(BCClass bc) {\n+        // return getObjectField(i);\n+        BCMethod method = bc.declareMethod(\"getData\", Object.class,\n+            new Class[]{ int.class });\n+        Code code = method.getCode(true);\n+        code.aload().setThis();\n+        code.iload().setParam(0);\n+        code.invokevirtual().setMethod(\"getObject\", Object.class,\n+            new Class[]{ int.class });\n+        code.areturn();\n+        code.calculateMaxLocals();\n+        code.calculateMaxStack();\n+    }\n+\n+    /////////////\n+    // Utilities\n+    /////////////\n+\n+    /**\n+     * Return a valid {@link JavaTypes} constant for the given field\n+     */\n+    protected int replaceType(FieldMetaData fmd) {\n+        if (usesIntermediate(fmd))\n+            return JavaTypes.OBJECT;\n+        return fmd.getTypeCode();\n+    }\n+\n+    /**\n+     * Whether the given field uses a cacheable intermediate value.\n+     */\n+    protected boolean usesIntermediate(FieldMetaData fmd) {\n+        return fmd.usesIntermediate();\n+    }\n+\n+    /**\n+     * Whether the given type might have cacheable class-level impl data.\n+     */\n+    protected boolean usesImplData(ClassMetaData meta) {\n+        return true;\n+    }\n+\n+    /**\n+     * Whether the given field might have cacheable impl data.\n+     */\n+    protected boolean usesImplData(FieldMetaData fmd) {\n+        return fmd.usesImplData() == null;\n+    }\n+\n+    /**\n+     * The number of fields with cacheable impl data.\n+     */\n+    private int countImplDataFields(ClassMetaData meta) {\n+        FieldMetaData[] fmds = meta.getFields();\n+        int count = 0;\n+        for (int i = 0; i < fmds.length; i++)\n+            if (usesImplData(fmds[i]))\n+                count++;\n+        return count;\n+    }\n+\n+    /**\n+     * Add method which defers to AbstractPCData.\n+     */\n+    protected void callAbstractPCData(BCClass bc, String name, Class retType,\n+        Class[] args) {\n+        BCMethod meth = bc.declareMethod(name, retType, args);\n+        Code code = meth.getCode(true);\n+        code.aload().setThis();\n+        for (int i = 0; i < args.length; i++)\n+            code.xload().setParam(i).setType(args[i]);\n+        code.invokevirtual().setMethod(AbstractPCData.class, name, retType,\n+            args);\n+        if (!void.class.equals(retType))\n+            code.xreturn().setType(retType);\n+        code.calculateMaxLocals();\n+        code.calculateMaxStack();\n+    }\n+\n+    /**\n+     * Set the collection of {@link JumpInstruction}s to the given instruction,\n+     * clearing the collection in the process.\n+     */\n+    protected void setTarget(Instruction ins, Collection jumps) {\n+        for (Iterator it = jumps.iterator(); it.hasNext();)\n+            ((JumpInstruction) it.next()).setTarget(ins);\n+        jumps.clear();\n+    }\n+\n+    /**\n+     * Transform the given array of classes to strings.\n+     */\n+    private static String[] toStrings(Class[] cls) {\n+        String[] strings = new String[cls.length];\n+        for (int i = 0; i < strings.length; i++)\n+            strings[i] = cls[i].getName();\n+        return strings;\n+    }\n+\n+    /**\n+     * Dynamic {@link PCData}s generated will implement this interface\n+     * to simplify initialization.\n+     */\n+    public static interface DynamicPCData extends PCData {\n+\n+        public void setId(Object oid);\n+\n+        public PCDataGenerator getStorageGenerator();\n+\n+        public void setStorageGenerator (PCDataGenerator generator);\n+\t}\n+}"},{"sha":"a73a22669b76bd7d1e5196a98f071589dfa3703c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","status":"modified","additions":87,"deletions":10,"changes":97,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCEnhancer.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -113,6 +113,8 @@\n     // Each enhanced class will return the value of this field via\n     // public int getEnhancementContractVersion()\n     public static final int ENHANCER_VERSION = 2;\n+    \n+    boolean _addVersionInitFlag = true;\n \n     public static final int ENHANCE_NONE = 0;\n     public static final int ENHANCE_AWARE = 2 << 0;\n@@ -134,6 +136,8 @@\n     private static final String SUPER = PRE + \"PCSuperclass\";\n     private static final Class OIDFSTYPE = FieldSupplier.class;\n     private static final Class OIDFCTYPE = FieldConsumer.class;\n+    \n+    private static final String VERSION_INIT_STR =  PRE + \"VersionInit\";\n \n     private static final Localizer _loc = Localizer.forPackage\n         (PCEnhancer.class);\n@@ -151,12 +155,12 @@\n             try {\n                 auxEnhancers.add(AccessController.doPrivileged(\n                     J2DoPrivHelper.newInstanceAction(classes[i])));\n-\t\t    } catch (Throwable t) {\n+            } catch (Throwable t) {\n                 // aux enhancer may rely on non-existant spec classes, etc\n-\t\t    }\n-\t\t}\n-    \t_auxEnhancers = (AuxiliaryEnhancer[]) auxEnhancers.toArray\n-            (new AuxiliaryEnhancer[auxEnhancers.size()]);\n+            }\n+        }\n+        _auxEnhancers = (AuxiliaryEnhancer[]) auxEnhancers.toArray\n+        (new AuxiliaryEnhancer[auxEnhancers.size()]);\n     }\n \n     private BCClass _pc;\n@@ -428,6 +432,7 @@ public boolean getCreateSubclass() {\n      */\n     public void setCreateSubclass(boolean subclass) {\n         _subclass = subclass;\n+        _addVersionInitFlag = false;\n     }\n \n     /**\n@@ -1093,8 +1098,13 @@ private void addPCMethods()\n             addCopyKeyFieldsToObjectIdMethod(false);\n             addCopyKeyFieldsFromObjectIdMethod(true);\n             addCopyKeyFieldsFromObjectIdMethod(false);\n+            if (_meta.hasAbstractPKField() == true) {\n+                addGetIDOwningClass();\n+            }\n             addNewObjectIdInstanceMethod(true);\n             addNewObjectIdInstanceMethod(false);\n+        } else if (_meta.hasPKFieldsFromAbstractClass()) {\n+            addGetIDOwningClass();\n         }\n     }\n \n@@ -1342,6 +1352,16 @@ private void addReplaceFieldsMethods()\n                     code.checkcast().setType(fmds[i].getDeclaredType());\n \n                 addSetManagedValueCode(code, fmds[i]);\n+                \n+                if(_addVersionInitFlag){\n+                    if(fmds[i].isVersion()){\n+                        // If this case is setting the version field\n+                        // pcVersionInit = true;\n+                        loadManagedInstance(code, false);\n+                        code.constant().setValue(1);\n+                        putfield(code, null, VERSION_INIT_STR, boolean.class);\n+                    }\n+                }\n                 code.vreturn();\n             }\n \n@@ -2486,14 +2506,28 @@ private void addNewObjectIdInstanceMethod(boolean obj)\n             // new ObjectId (cls, oid)\n             code.anew().setType(ObjectId.class);\n             code.dup();\n-            code.classconstant().setClass(getType(_meta));\n+            if (_meta.hasAbstractPKField() == false) {\n+                code.classconstant().setClass(getType(_meta));\n+            } else {\n+                code.aload().setThis();\n+                code.invokevirtual().setMethod(\n+                        PRE + \"GetIDOwningClass\", Class.class, null);\n+            }\n         }\n \n         // new <oid class> ();\n         code.anew().setType(oidType);\n         code.dup();\n         if (_meta.isOpenJPAIdentity() || (obj && usesClsString == Boolean.TRUE))\n-            code.classconstant().setClass(getType(_meta));\n+        {\n+            if (_meta.hasAbstractPKField() == false) {\n+                code.classconstant().setClass(getType(_meta));\n+            } else {\n+                code.aload().setThis();\n+                code.invokevirtual().setMethod(\n+                    PRE + \"GetIDOwningClass\", Class.class, null);\n+            }\n+        }\n         if (obj) {\n             code.aload().setParam(0);\n             code.checkcast().setType(String.class);\n@@ -2526,6 +2560,18 @@ else if (_meta.getObjectIdType() == Date.class)\n         code.calculateMaxLocals();\n     }\n \n+    private void addGetIDOwningClass() throws NoSuchMethodException {\n+        BCMethod method = _pc.declareMethod(PRE + \"GetIDOwningClass\",\n+            Class.class, null);\n+        Code code = method.getCode(true);\n+\n+        code.classconstant().setClass(getType(_meta));\n+        code.areturn();\n+\n+        code.calculateMaxStack();\n+        code.calculateMaxLocals();\n+    }\n+\n     /**\n      * When communicating with the StateManager, many methods are used\n      * depending on the class of state being passed. This method,\n@@ -2674,7 +2720,12 @@ private void addFields() {\n         _pc.declareField(PRE + \"FieldTypes\", Class[].class).setStatic(true);\n         _pc.declareField(PRE + \"FieldFlags\", byte[].class).setStatic(true);\n         _pc.declareField(SUPER, Class.class).setStatic(true);\n-\n+        if (_addVersionInitFlag && _meta.getVersionField() != null) {\n+            // protected transient boolean pcVersionInit;\n+            BCField field = _pc.declareField(VERSION_INIT_STR, boolean.class);\n+            field.makeProtected();\n+            field.setTransient(true);\n+        }\n         if (_meta.getPCSuperclass() == null || getCreateSubclass()) {\n             BCField field = _pc.declareField(SM, SMTYPE);\n             field.makeProtected();\n@@ -3123,8 +3174,25 @@ private boolean writeIsDetachedMethod(Code code)\n             ifins = ifDefaultValue(code, version);\n             code.getstatic().setField(Boolean.class, \"TRUE\", Boolean.class);\n             code.areturn();\n-            ifins.setTarget(code.getstatic().setField(Boolean.class, \"FALSE\",\n-                Boolean.class));\n+            if (!_addVersionInitFlag){\n+                // else return false;\n+                ifins.setTarget(code.getstatic().setField(Boolean.class, \"FALSE\", Boolean.class));\n+            }else{\n+                FieldMetaData versionInit = _meta.getDeclaredField(VERSION_INIT_STR);\n+                // noop\n+                ifins.setTarget(code.nop());\n+                // if (pcVersionInit)\n+                // return true\n+                // else return false;\n+                loadManagedInstance(code, false);\n+                getfield(code, null, versionInit.getName());\n+                ifins = ifDefaultValue(code, versionInit);\n+                code.getstatic().setField(Boolean.class, \"TRUE\", Boolean.class);\n+                code.areturn();\n+                ifins.setTarget(code.nop());\n+                code.getstatic().setField(Boolean.class, \"FALSE\", Boolean.class);\n+                \n+            }\n             code.areturn();\n             return false;\n         }\n@@ -3587,6 +3655,14 @@ private void addSetMethod(int index, FieldMetaData fmd)\n         loadManagedInstance(code, true);\n         code.xload().setParam(firstParamOffset);\n         addSetManagedValueCode(code, fmd);\n+        if(fmd.isVersion()==true && _addVersionInitFlag){\n+            // if we are setting the version, flip the versionInit flag to true\n+            FieldMetaData v = _meta.addDeclaredField(VERSION_INIT_STR, boolean.class);\n+            v.setTransient(true);\n+            loadManagedInstance(code, true);\n+            code.constant().setValue(1);\n+            addSetManagedValueCode(code, v);   \n+        }\n         code.vreturn();\n \n         // inst.pcStateManager.setting<fieldType>Field (inst,\n@@ -4193,6 +4269,7 @@ private void addGetManagedValueCode(Code code, FieldMetaData fmd,\n         } else {\n             // regular enhancement + property access\n             Method meth = (Method) fmd.getBackingMember();\n+\n             code.invokevirtual().setMethod(PRE + meth.getName(),\n                 meth.getReturnType(), meth.getParameterTypes());\n         }"},{"sha":"454e16efb8ad24e24cc0604eef9b9b250428add6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","status":"modified","additions":288,"deletions":288,"changes":576,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCRegistry.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,288 +1,288 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.    \r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.util.Collection;\r\n-import java.util.Collections;\r\n-import java.util.Iterator;\r\n-import java.util.LinkedList;\r\n-import java.util.Map;\r\n-\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.ReferenceMap;\r\n-import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\r\n-import org.apache.openjpa.util.UserException;\r\n-import org.apache.openjpa.util.InvalidStateException;\r\n-\r\n-/**\r\n- * Tracks registered persistence-capable classes.\r\n- *\r\n- * @since 0.4.0\r\n- * @author Abe White\r\n- */\r\n-public class PCRegistry {\r\n-    // DO NOT ADD ADDITIONAL DEPENDENCIES TO THIS CLASS\r\n-\r\n-    private static final Localizer _loc = Localizer.forPackage\r\n-        (PCRegistry.class);\r\n-\r\n-    // map of pc classes to meta structs; weak so the VM can GC classes\r\n-    private static final Map _metas = new ConcurrentReferenceHashMap\r\n-        (ReferenceMap.WEAK, ReferenceMap.HARD);\r\n-\r\n-    // register class listeners\r\n-    private static final Collection _listeners = new LinkedList();\r\n-\r\n-    /**\r\n-     * Register a {@link RegisterClassListener}.\r\n-     */\r\n-    public static void addRegisterClassListener(RegisterClassListener rcl) {\r\n-        if (rcl == null)\r\n-            return;\r\n-\r\n-        // we have to be positive that every listener gets notified for\r\n-        // every class, so lots of locking\r\n-        synchronized (_listeners) {\r\n-            _listeners.add(rcl);\r\n-        }\r\n-        synchronized (_metas) {\r\n-            for (Iterator itr = _metas.keySet().iterator(); itr.hasNext();)\r\n-                rcl.register((Class) itr.next());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Removes a {@link RegisterClassListener}.\r\n-     */\r\n-    public static void removeRegisterClassListener(RegisterClassListener rcl) {\r\n-        synchronized (_listeners) {\r\n-            _listeners.remove(rcl);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Get the field names for a <code>PersistenceCapable</code> class.\r\n-     */\r\n-    public static String[] getFieldNames(Class pcClass) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        return meta.fieldNames;\r\n-    }\r\n-\r\n-    /**\r\n-     * Get the field types for a <code>PersistenceCapable</code> class.\r\n-     */\r\n-    public static Class[] getFieldTypes(Class pcClass) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        return meta.fieldTypes;\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the persistent superclass for a <code>PersistenceCapable</code>\r\n-     * class, or null if none. The superclass may or may not implement\r\n-     * {@link PersistenceCapable}, depending on the access type of the class.\r\n-     */\r\n-    public static Class getPersistentSuperclass(Class pcClass) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        return meta.pcSuper;\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new instance of the class and assign its state manager.\r\n-     * The new instance has its flags set to <code>LOAD_REQUIRED</code>.\r\n-     */\r\n-    public static PersistenceCapable newInstance(Class pcClass,\r\n-        StateManager sm, boolean clear) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        return (meta.pc == null) ? null : meta.pc.pcNewInstance(sm, clear);\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new instance of the class and assign its state manager and oid.\r\n-     * The new instance has its flags set to <code>LOAD_REQUIRED</code>.\r\n-     */\r\n-    public static PersistenceCapable newInstance(Class pcClass,\r\n-        StateManager sm, Object oid, boolean clear) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        return (meta.pc == null) ? null : meta.pc.pcNewInstance(sm, oid, clear);\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the persistence-capable type for <code>type</code>. This might\r\n-     * be a generated subclass of <code>type</code>.\r\n-     *\r\n-     * @since 1.1.0\r\n-     */\r\n-    public static Class getPCType(Class type) {\r\n-        Meta meta = getMeta(type);\r\n-        return (meta.pc == null) ? null : meta.pc.getClass();\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new identity object for the given\r\n-     * <code>PersistenceCapable</code> class.\r\n-     */\r\n-    public static Object newObjectId(Class pcClass) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        return (meta.pc == null) ? null : meta.pc.pcNewObjectIdInstance();\r\n-    }\r\n-\r\n-    /**\r\n-     * Create a new identity object for the given\r\n-     * <code>PersistenceCapable</code> class, using the <code>String</code>\r\n-     * form of the constructor.\r\n-     */\r\n-    public static Object newObjectId(Class pcClass, String str) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        return (meta.pc == null) ? null : meta.pc.pcNewObjectIdInstance(str);\r\n-    }\r\n-\r\n-    /**\r\n-     * Return the alias for the given type.\r\n-     */\r\n-    public static String getTypeAlias(Class pcClass) {\r\n-        return getMeta(pcClass).alias;\r\n-    }\r\n-\r\n-    /**\r\n-     * Copy fields from an outside source to the key fields in the identity\r\n-     * object.\r\n-     */\r\n-    public static void copyKeyFieldsToObjectId(Class pcClass, FieldSupplier fm,\r\n-        Object oid) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        if (meta.pc == null)\r\n-            throw new UserException(_loc.get(\"copy-no-id\", pcClass));\r\n-\r\n-        meta.pc.pcCopyKeyFieldsToObjectId(fm, oid);\r\n-    }\r\n-\r\n-    /**\r\n-     * Copy fields to an outside source from the key fields in the identity\r\n-     * object.\r\n-     */\r\n-    public static void copyKeyFieldsFromObjectId(Class pcClass,\r\n-        FieldConsumer fm, Object oid) {\r\n-        Meta meta = getMeta(pcClass);\r\n-        if (meta.pc == null)\r\n-            throw new UserException(_loc.get(\"copy-no-id\", pcClass));\r\n-\r\n-        meta.pc.pcCopyKeyFieldsFromObjectId(fm, oid);\r\n-    }\r\n-\r\n-    /**\r\n-     * Register metadata by class.\r\n-     *\r\n-     * @param fieldTypes managed field types\r\n-     * @param fieldFlags managed field flags\r\n-     * @param sup the most immediate persistent superclass\r\n-     * @param pcClass the <code>PersistenceCapable</code> class\r\n-     * @param fieldNames managed field names\r\n-     * @param alias the class alias\r\n-     * @param pc an instance of the class, if not abstract\r\n-     */\r\n-    public static void register(Class pcClass, String[] fieldNames,\r\n-        Class[] fieldTypes, byte[] fieldFlags, Class sup, String alias,\r\n-        PersistenceCapable pc) {\r\n-        if (pcClass == null)\r\n-            throw new NullPointerException();\r\n-\r\n-        // we have to be positive that every listener gets notified for\r\n-        // every class, so lots of locking\r\n-        Meta meta = new Meta(pc, fieldNames, fieldTypes, sup, alias);\r\n-        synchronized (_metas) {\r\n-            _metas.put(pcClass, meta);\r\n-        }\r\n-        synchronized (_listeners) {\r\n-            for (Iterator i = _listeners.iterator(); i.hasNext();)\r\n-                ((RegisterClassListener) i.next()).register(pcClass);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * De-Register all metadata associated with the given ClassLoader. \r\n-     * Allows ClassLoaders to be garbage collected.\r\n-     *\r\n-     * @param cl the ClassLoader\r\n-     */\r\n-    public static void deRegister(ClassLoader cl) {\r\n-        synchronized (_metas) {\r\n-            for (Iterator i = _metas.keySet().iterator(); i.hasNext();) {\r\n-                Class pcClass = (Class) i.next();\r\n-                if (pcClass.getClassLoader() == cl) {\r\n-                    _metas.remove(pcClass);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-    \r\n-    /**\r\n-     * Returns a collection of class objects of the registered\r\n-     * persistence-capable classes.\r\n-     */\r\n-    public static Collection getRegisteredTypes() {\r\n-        return Collections.unmodifiableCollection(_metas.keySet());\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns <code>true</code> if <code>cls</code> is already registered.\r\n-     */\r\n-    public static boolean isRegistered(Class cls) {\r\n-        return _metas.containsKey(cls);\r\n-    }\r\n-\r\n-    /**\r\n-     * Look up the metadata for a <code>PersistenceCapable</code> class.\r\n-     */\r\n-    private static Meta getMeta(Class pcClass) {\r\n-        Meta ret = (Meta) _metas.get(pcClass);\r\n-        if (ret == null)\r\n-            throw new IllegalStateException(_loc.get(\"no-meta\", pcClass).\r\n-                getMessage());\r\n-        return ret;\r\n-    }\r\n-\r\n-    /**\r\n-     * Listener for persistent class registration events.\r\n-     */\r\n-    public static interface RegisterClassListener {\r\n-\r\n-        public void register(Class cls);\r\n-    }\r\n-\r\n-    /**\r\n-     * This is a helper class to manage metadata per persistence-capable class.\r\n-     */\r\n-    private static class Meta {\r\n-\r\n-        public final PersistenceCapable pc;\r\n-        public final String[] fieldNames;\r\n-        public final Class[] fieldTypes;\r\n-        public final Class pcSuper;\r\n-        public final String alias;\r\n-\r\n-        public Meta(PersistenceCapable pc, String[] fieldNames,\r\n-            Class[] fieldTypes, Class pcSuper, String alias) {\r\n-            this.pc = pc;\r\n-            this.fieldNames = fieldNames;\r\n-            this.fieldTypes = fieldTypes;\r\n-            this.pcSuper = pcSuper;\r\n-\t\t\tthis.alias = alias;\r\n-\t\t}\r\n-\t}\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.    \n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.Map;\n+\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.ReferenceMap;\n+import org.apache.openjpa.lib.util.concurrent.ConcurrentReferenceHashMap;\n+import org.apache.openjpa.util.UserException;\n+import org.apache.openjpa.util.InvalidStateException;\n+\n+/**\n+ * Tracks registered persistence-capable classes.\n+ *\n+ * @since 0.4.0\n+ * @author Abe White\n+ */\n+public class PCRegistry {\n+    // DO NOT ADD ADDITIONAL DEPENDENCIES TO THIS CLASS\n+\n+    private static final Localizer _loc = Localizer.forPackage\n+        (PCRegistry.class);\n+\n+    // map of pc classes to meta structs; weak so the VM can GC classes\n+    private static final Map _metas = new ConcurrentReferenceHashMap\n+        (ReferenceMap.WEAK, ReferenceMap.HARD);\n+\n+    // register class listeners\n+    private static final Collection _listeners = new LinkedList();\n+\n+    /**\n+     * Register a {@link RegisterClassListener}.\n+     */\n+    public static void addRegisterClassListener(RegisterClassListener rcl) {\n+        if (rcl == null)\n+            return;\n+\n+        // we have to be positive that every listener gets notified for\n+        // every class, so lots of locking\n+        synchronized (_listeners) {\n+            _listeners.add(rcl);\n+        }\n+        synchronized (_metas) {\n+            for (Iterator itr = _metas.keySet().iterator(); itr.hasNext();)\n+                rcl.register((Class) itr.next());\n+        }\n+    }\n+\n+    /**\n+     * Removes a {@link RegisterClassListener}.\n+     */\n+    public static void removeRegisterClassListener(RegisterClassListener rcl) {\n+        synchronized (_listeners) {\n+            _listeners.remove(rcl);\n+        }\n+    }\n+\n+    /**\n+     * Get the field names for a <code>PersistenceCapable</code> class.\n+     */\n+    public static String[] getFieldNames(Class pcClass) {\n+        Meta meta = getMeta(pcClass);\n+        return meta.fieldNames;\n+    }\n+\n+    /**\n+     * Get the field types for a <code>PersistenceCapable</code> class.\n+     */\n+    public static Class[] getFieldTypes(Class pcClass) {\n+        Meta meta = getMeta(pcClass);\n+        return meta.fieldTypes;\n+    }\n+\n+    /**\n+     * Return the persistent superclass for a <code>PersistenceCapable</code>\n+     * class, or null if none. The superclass may or may not implement\n+     * {@link PersistenceCapable}, depending on the access type of the class.\n+     */\n+    public static Class getPersistentSuperclass(Class pcClass) {\n+        Meta meta = getMeta(pcClass);\n+        return meta.pcSuper;\n+    }\n+\n+    /**\n+     * Create a new instance of the class and assign its state manager.\n+     * The new instance has its flags set to <code>LOAD_REQUIRED</code>.\n+     */\n+    public static PersistenceCapable newInstance(Class pcClass,\n+        StateManager sm, boolean clear) {\n+        Meta meta = getMeta(pcClass);\n+        return (meta.pc == null) ? null : meta.pc.pcNewInstance(sm, clear);\n+    }\n+\n+    /**\n+     * Create a new instance of the class and assign its state manager and oid.\n+     * The new instance has its flags set to <code>LOAD_REQUIRED</code>.\n+     */\n+    public static PersistenceCapable newInstance(Class pcClass,\n+        StateManager sm, Object oid, boolean clear) {\n+        Meta meta = getMeta(pcClass);\n+        return (meta.pc == null) ? null : meta.pc.pcNewInstance(sm, oid, clear);\n+    }\n+\n+    /**\n+     * Return the persistence-capable type for <code>type</code>. This might\n+     * be a generated subclass of <code>type</code>.\n+     *\n+     * @since 1.1.0\n+     */\n+    public static Class getPCType(Class type) {\n+        Meta meta = getMeta(type);\n+        return (meta.pc == null) ? null : meta.pc.getClass();\n+    }\n+\n+    /**\n+     * Create a new identity object for the given\n+     * <code>PersistenceCapable</code> class.\n+     */\n+    public static Object newObjectId(Class pcClass) {\n+        Meta meta = getMeta(pcClass);\n+        return (meta.pc == null) ? null : meta.pc.pcNewObjectIdInstance();\n+    }\n+\n+    /**\n+     * Create a new identity object for the given\n+     * <code>PersistenceCapable</code> class, using the <code>String</code>\n+     * form of the constructor.\n+     */\n+    public static Object newObjectId(Class pcClass, String str) {\n+        Meta meta = getMeta(pcClass);\n+        return (meta.pc == null) ? null : meta.pc.pcNewObjectIdInstance(str);\n+    }\n+\n+    /**\n+     * Return the alias for the given type.\n+     */\n+    public static String getTypeAlias(Class pcClass) {\n+        return getMeta(pcClass).alias;\n+    }\n+\n+    /**\n+     * Copy fields from an outside source to the key fields in the identity\n+     * object.\n+     */\n+    public static void copyKeyFieldsToObjectId(Class pcClass, FieldSupplier fm,\n+        Object oid) {\n+        Meta meta = getMeta(pcClass);\n+        if (meta.pc == null)\n+            throw new UserException(_loc.get(\"copy-no-id\", pcClass));\n+\n+        meta.pc.pcCopyKeyFieldsToObjectId(fm, oid);\n+    }\n+\n+    /**\n+     * Copy fields to an outside source from the key fields in the identity\n+     * object.\n+     */\n+    public static void copyKeyFieldsFromObjectId(Class pcClass,\n+        FieldConsumer fm, Object oid) {\n+        Meta meta = getMeta(pcClass);\n+        if (meta.pc == null)\n+            throw new UserException(_loc.get(\"copy-no-id\", pcClass));\n+\n+        meta.pc.pcCopyKeyFieldsFromObjectId(fm, oid);\n+    }\n+\n+    /**\n+     * Register metadata by class.\n+     *\n+     * @param fieldTypes managed field types\n+     * @param fieldFlags managed field flags\n+     * @param sup the most immediate persistent superclass\n+     * @param pcClass the <code>PersistenceCapable</code> class\n+     * @param fieldNames managed field names\n+     * @param alias the class alias\n+     * @param pc an instance of the class, if not abstract\n+     */\n+    public static void register(Class pcClass, String[] fieldNames,\n+        Class[] fieldTypes, byte[] fieldFlags, Class sup, String alias,\n+        PersistenceCapable pc) {\n+        if (pcClass == null)\n+            throw new NullPointerException();\n+\n+        // we have to be positive that every listener gets notified for\n+        // every class, so lots of locking\n+        Meta meta = new Meta(pc, fieldNames, fieldTypes, sup, alias);\n+        synchronized (_metas) {\n+            _metas.put(pcClass, meta);\n+        }\n+        synchronized (_listeners) {\n+            for (Iterator i = _listeners.iterator(); i.hasNext();)\n+                ((RegisterClassListener) i.next()).register(pcClass);\n+        }\n+    }\n+\n+    /**\n+     * De-Register all metadata associated with the given ClassLoader. \n+     * Allows ClassLoaders to be garbage collected.\n+     *\n+     * @param cl the ClassLoader\n+     */\n+    public static void deRegister(ClassLoader cl) {\n+        synchronized (_metas) {\n+            for (Iterator i = _metas.keySet().iterator(); i.hasNext();) {\n+                Class pcClass = (Class) i.next();\n+                if (pcClass.getClassLoader() == cl) {\n+                    _metas.remove(pcClass);\n+                }\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Returns a collection of class objects of the registered\n+     * persistence-capable classes.\n+     */\n+    public static Collection getRegisteredTypes() {\n+        return Collections.unmodifiableCollection(_metas.keySet());\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if <code>cls</code> is already registered.\n+     */\n+    public static boolean isRegistered(Class cls) {\n+        return _metas.containsKey(cls);\n+    }\n+\n+    /**\n+     * Look up the metadata for a <code>PersistenceCapable</code> class.\n+     */\n+    private static Meta getMeta(Class pcClass) {\n+        Meta ret = (Meta) _metas.get(pcClass);\n+        if (ret == null)\n+            throw new IllegalStateException(_loc.get(\"no-meta\", pcClass).\n+                getMessage());\n+        return ret;\n+    }\n+\n+    /**\n+     * Listener for persistent class registration events.\n+     */\n+    public static interface RegisterClassListener {\n+\n+        public void register(Class cls);\n+    }\n+\n+    /**\n+     * This is a helper class to manage metadata per persistence-capable class.\n+     */\n+    private static class Meta {\n+\n+        public final PersistenceCapable pc;\n+        public final String[] fieldNames;\n+        public final Class[] fieldTypes;\n+        public final Class pcSuper;\n+        public final String alias;\n+\n+        public Meta(PersistenceCapable pc, String[] fieldNames,\n+            Class[] fieldTypes, Class pcSuper, String alias) {\n+            this.pc = pc;\n+            this.fieldNames = fieldNames;\n+            this.fieldTypes = fieldTypes;\n+            this.pcSuper = pcSuper;\n+\t\t\tthis.alias = alias;\n+\t\t}\n+\t}\n+}"},{"sha":"aef221a3223762557d2d3c570628c63e318767b3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","status":"modified","additions":272,"deletions":272,"changes":544,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/PCSubclassValidator.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675","patch":"@@ -1,272 +1,272 @@\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-package org.apache.openjpa.enhance;\r\n-\r\n-import java.lang.reflect.Modifier;\r\n-import java.lang.reflect.Constructor;\r\n-import java.lang.reflect.Method;\r\n-import java.util.ArrayList;\r\n-import java.util.Collection;\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.openjpa.meta.ClassMetaData;\r\n-import org.apache.openjpa.meta.FieldMetaData;\r\n-import org.apache.openjpa.util.UserException;\r\n-import org.apache.openjpa.util.InternalException;\r\n-import org.apache.openjpa.lib.util.Localizer;\r\n-import org.apache.openjpa.lib.util.Localizer.Message;\r\n-import org.apache.openjpa.lib.log.Log;\r\n-import serp.bytecode.BCField;\r\n-import serp.bytecode.BCClass;\r\n-import serp.bytecode.BCMethod;\r\n-\r\n-/**\r\n- *\t<p>Validates that a given type meets the JPA contract, plus a few\r\n- *  OpenJPA-specific additions for subclassing / redefinition:\r\n- *\r\n- *\t<ul>\r\n- * \t\t<li>must have an accessible no-args constructor</li>\r\n- * \t\t<li>must be a public or protected class</li>\r\n- * \t\t<li>must not be final</li>\r\n- * \t\t<li>must not extend an enhanced class</li>\r\n- *\t\t<li>all persistent data represented by accessible setter/getter\r\n- * \t\t\tmethods (persistent properties)</li>\r\n- * \t\t<li>if versioning is to be used, exactly one persistent property for\r\n- * \t\t\tthe numeric version data</li> <!-- ##### is this true? -->\r\n- *\r\n- * \t\t<li>When using property access, the backing field for a persistent\r\n- *          property must be:\r\n- * \t\t\t<ul>\r\n- * \t\t\t\t<!-- ##### JPA validation of these needs to be tested -->\r\n- * \t\t\t\t<li>private</li>\r\n- * \t\t\t\t<li>set only in the designated setter,\r\n- * \t\t\t\t\tin the constructor, or in {@link Object#clone()},\r\n- * \t\t\t\t\t<code>readObject(ObjectInputStream)</code>, or\r\n- * \t\t\t\t\t{@link Externalizable#readExternal(ObjectInput)}.</li>\r\n- * \t\t\t\t<li>read only in the designated getter and the\r\n- * \t\t\t\t\tconstructor.</li>\r\n- *\t\t\t</ul>\r\n- * \t\t</li>\r\n- * \t</ul>\r\n- *\r\n- * \t<p>If you use this technique and use the <code>new</code> keyword instead of\r\n- * \ta OpenJPA-supplied construction routine, OpenJPA will need to do extra work\r\n- *  with persistent-new-flushed instances, since OpenJPA cannot in this case\r\n- *  track what happens to such an instance.</p>\r\n- *\r\n- * \t@since 1.0.0\r\n- */\r\n-public class PCSubclassValidator {\r\n-\r\n-    private static final Localizer loc =\r\n-        Localizer.forPackage(PCSubclassValidator.class);\r\n-\r\n-    private final ClassMetaData meta;\r\n-    private final BCClass pc;\r\n-    private final Log log;\r\n-    private final boolean failOnContractViolations;\r\n-\r\n-    private Collection errors;\r\n-    private Collection contractViolations;\r\n-\r\n-    public PCSubclassValidator(ClassMetaData meta, BCClass bc, Log log,\r\n-        boolean enforceContractViolations) {\r\n-        this.meta = meta;\r\n-        this.pc = bc;\r\n-        this.log = log;\r\n-        this.failOnContractViolations = enforceContractViolations;\r\n-    }\r\n-\r\n-    public void assertCanSubclass() {\r\n-        Class superclass = meta.getDescribedType();\r\n-        String name = superclass.getName();\r\n-        if (superclass.isInterface())\r\n-            addError(loc.get(\"subclasser-no-ifaces\", name), meta);\r\n-        if (Modifier.isFinal(superclass.getModifiers()))\r\n-            addError(loc.get(\"subclasser-no-final-classes\", name), meta);\r\n-        if (Modifier.isPrivate(superclass.getModifiers()))\r\n-            addError(loc.get(\"subclasser-no-private-classes\", name), meta);\r\n-        if (PersistenceCapable.class.isAssignableFrom(superclass))\r\n-            addError(loc.get(\"subclasser-super-already-pc\", name), meta);\r\n-\r\n-        try {\r\n-            Constructor c = superclass.getDeclaredConstructor(new Class[0]);\r\n-            if (!(Modifier.isProtected(c.getModifiers())\r\n-                || Modifier.isPublic(c.getModifiers())))\r\n-                addError(loc.get(\"subclasser-private-ctor\", name), meta);\r\n-        }\r\n-        catch (NoSuchMethodException e) {\r\n-            addError(loc.get(\"subclasser-no-void-ctor\", name),\r\n-                meta);\r\n-        }\r\n-\r\n-        // if the BCClass we loaded is already pc and the superclass is not,\r\n-        // then we should never get here, so let's make sure that the\r\n-        // calling context is caching correctly by throwing an exception.\r\n-        if (pc.isInstanceOf(PersistenceCapable.class) &&\r\n-            !PersistenceCapable.class.isAssignableFrom(superclass))\r\n-            throw new InternalException(\r\n-                loc.get(\"subclasser-class-already-pc\", name));\r\n-\r\n-        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY)\r\n-            checkPropertiesAreInterceptable();\r\n-\r\n-        if (errors != null && !errors.isEmpty())\r\n-            throw new UserException(errors.toString());\r\n-        else if (contractViolations != null &&\r\n-            !contractViolations.isEmpty() && log.isWarnEnabled())\r\n-            log.warn(contractViolations.toString());\r\n-    }\r\n-\r\n-    private void checkPropertiesAreInterceptable() {\r\n-        // just considers accessor methods for now.\r\n-        FieldMetaData[] fmds = meta.getFields();\r\n-        for (int i = 0; i < fmds.length; i++) {\r\n-            Method getter = (Method) fmds[i].getBackingMember();\r\n-            if (getter == null) {\r\n-                addError(loc.get(\"subclasser-no-getter\",\r\n-                    fmds[i].getName()), fmds[i]);\r\n-                continue;\r\n-            }\r\n-            BCField returnedField = checkGetterIsSubclassable(getter, fmds[i]);\r\n-\r\n-            Method setter = setterForField(fmds[i]);\r\n-            if (setter == null) {\r\n-                addError(loc.get(\"subclasser-no-setter\", fmds[i].getName()),\r\n-                    fmds[i]);\r\n-                continue;\r\n-            }\r\n-            BCField assignedField = checkSetterIsSubclassable(setter, fmds[i]);\r\n-            if (assignedField == null)\r\n-                continue;\r\n-\r\n-            if (assignedField != returnedField)\r\n-                addContractViolation(loc.get\r\n-                    (\"subclasser-setter-getter-field-mismatch\",\r\n-                        fmds[i].getName(), returnedField,assignedField),\r\n-                    fmds[i]);\r\n-\r\n-            // ### scan through all the rest of the class to make sure it\r\n-            // ### doesn't use the field.\r\n-        }\r\n-    }\r\n-\r\n-    private Method setterForField(FieldMetaData fmd) {\r\n-        try {\r\n-            return fmd.getDeclaringType().getDeclaredMethod(\r\n-                \"set\" + StringUtils.capitalize(fmd.getName()),\r\n-                new Class[]{ fmd.getDeclaredType() });\r\n-        }\r\n-        catch (NoSuchMethodException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @return the name of the field that is returned by <code>meth</code>, or\r\n-     *         <code>null</code> if something other than a single field is\r\n-     *         returned, or if it cannot be determined what is returned.\r\n-     */\r\n-    private BCField checkGetterIsSubclassable(Method meth, FieldMetaData fmd) {\r\n-        checkMethodIsSubclassable(meth, fmd);\r\n-        BCField field = PCEnhancer.getReturnedField(getBCMethod(meth));\r\n-        if (field == null) {\r\n-            addContractViolation(loc.get(\"subclasser-invalid-getter\",\r\n-                fmd.getName()), fmd);\r\n-            return null;\r\n-        } else {\r\n-            return field;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * @return the field that is set in <code>meth</code>, or\r\n-     *         <code>null</code> if something other than a single field is\r\n-     *         set, or if it cannot be determined what is set.\r\n-     */\r\n-    private BCField checkSetterIsSubclassable(Method meth, FieldMetaData fmd) {\r\n-        checkMethodIsSubclassable(meth, fmd);\r\n-        BCField field = PCEnhancer.getAssignedField(getBCMethod(meth));\r\n-        if (field == null) {\r\n-            addContractViolation(loc.get(\"subclasser-invalid-setter\",\r\n-                fmd.getName()), fmd);\r\n-            return null;\r\n-        } else {\r\n-            return field;\r\n-        }\r\n-    }\r\n-\r\n-    private BCMethod getBCMethod(Method meth) {\r\n-        BCClass bc = pc.getProject().loadClass(meth.getDeclaringClass());\r\n-        return bc.getDeclaredMethod(meth.getName(), meth.getParameterTypes());\r\n-    }\r\n-\r\n-    private void checkMethodIsSubclassable(Method meth, FieldMetaData fmd) {\r\n-        String className = fmd.getDefiningMetaData().\r\n-            getDescribedType().getName();\r\n-        if (!(Modifier.isProtected(meth.getModifiers())\r\n-            || Modifier.isPublic(meth.getModifiers())))\r\n-            addError(loc.get(\"subclasser-private-accessors-unsupported\",\r\n-                className, meth.getName()), fmd);\r\n-        if (Modifier.isFinal(meth.getModifiers()))\r\n-            addError(loc.get(\"subclasser-final-methods-not-allowed\",\r\n-                className, meth.getName()), fmd);\r\n-        if (Modifier.isNative(meth.getModifiers()))\r\n-            addContractViolation(loc.get\r\n-                (\"subclasser-native-methods-not-allowed\", className,\r\n-                    meth.getName()),\r\n-                fmd);\r\n-        if (Modifier.isStatic(meth.getModifiers()))\r\n-            addError(loc.get(\"subclasser-static-methods-not-supported\",\r\n-                className, meth.getName()), fmd);\r\n-    }\r\n-\r\n-    private void addError(Message s, ClassMetaData cls) {\r\n-        if (errors == null)\r\n-            errors = new ArrayList();\r\n-\r\n-        errors.add(loc.get(\"subclasser-error-meta\", s,\r\n-            cls.getDescribedType().getName(),\r\n-            cls.getSourceFile()));\r\n-    }\r\n-\r\n-    private void addError(Message s, FieldMetaData fmd) {\r\n-        if (errors == null)\r\n-            errors = new ArrayList();\r\n-\r\n-        errors.add(loc.get(\"subclasser-error-field\", s,\r\n-            fmd.getFullName(),\r\n-            fmd.getDeclaringMetaData().getSourceFile()));\r\n-    }\r\n-\r\n-    private void addContractViolation(Message m, FieldMetaData fmd) {\r\n-        // add the violation as an error in case we're processing violations\r\n-        // as errors; this keeps them in the order that they were found rather\r\n-        // than just adding the violations to the end of the list.\r\n-        if (failOnContractViolations)\r\n-            addError(m, fmd);\r\n-\r\n-        if (contractViolations == null)\r\n-            contractViolations = new ArrayList();\r\n-\r\n-        contractViolations.add(loc.get\r\n-            (\"subclasser-contract-violation-field\", m.getMessage(),\r\n-                fmd.getFullName(), fmd.getDeclaringMetaData().getSourceFile()));\r\n-    }\r\n-}\r\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.openjpa.enhance;\n+\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.openjpa.meta.ClassMetaData;\n+import org.apache.openjpa.meta.FieldMetaData;\n+import org.apache.openjpa.util.UserException;\n+import org.apache.openjpa.util.InternalException;\n+import org.apache.openjpa.lib.util.Localizer;\n+import org.apache.openjpa.lib.util.Localizer.Message;\n+import org.apache.openjpa.lib.log.Log;\n+import serp.bytecode.BCField;\n+import serp.bytecode.BCClass;\n+import serp.bytecode.BCMethod;\n+\n+/**\n+ *\t<p>Validates that a given type meets the JPA contract, plus a few\n+ *  OpenJPA-specific additions for subclassing / redefinition:\n+ *\n+ *\t<ul>\n+ * \t\t<li>must have an accessible no-args constructor</li>\n+ * \t\t<li>must be a public or protected class</li>\n+ * \t\t<li>must not be final</li>\n+ * \t\t<li>must not extend an enhanced class</li>\n+ *\t\t<li>all persistent data represented by accessible setter/getter\n+ * \t\t\tmethods (persistent properties)</li>\n+ * \t\t<li>if versioning is to be used, exactly one persistent property for\n+ * \t\t\tthe numeric version data</li> <!-- ##### is this true? -->\n+ *\n+ * \t\t<li>When using property access, the backing field for a persistent\n+ *          property must be:\n+ * \t\t\t<ul>\n+ * \t\t\t\t<!-- ##### JPA validation of these needs to be tested -->\n+ * \t\t\t\t<li>private</li>\n+ * \t\t\t\t<li>set only in the designated setter,\n+ * \t\t\t\t\tin the constructor, or in {@link Object#clone()},\n+ * \t\t\t\t\t<code>readObject(ObjectInputStream)</code>, or\n+ * \t\t\t\t\t{@link Externalizable#readExternal(ObjectInput)}.</li>\n+ * \t\t\t\t<li>read only in the designated getter and the\n+ * \t\t\t\t\tconstructor.</li>\n+ *\t\t\t</ul>\n+ * \t\t</li>\n+ * \t</ul>\n+ *\n+ * \t<p>If you use this technique and use the <code>new</code> keyword instead of\n+ * \ta OpenJPA-supplied construction routine, OpenJPA will need to do extra work\n+ *  with persistent-new-flushed instances, since OpenJPA cannot in this case\n+ *  track what happens to such an instance.</p>\n+ *\n+ * \t@since 1.0.0\n+ */\n+public class PCSubclassValidator {\n+\n+    private static final Localizer loc =\n+        Localizer.forPackage(PCSubclassValidator.class);\n+\n+    private final ClassMetaData meta;\n+    private final BCClass pc;\n+    private final Log log;\n+    private final boolean failOnContractViolations;\n+\n+    private Collection errors;\n+    private Collection contractViolations;\n+\n+    public PCSubclassValidator(ClassMetaData meta, BCClass bc, Log log,\n+        boolean enforceContractViolations) {\n+        this.meta = meta;\n+        this.pc = bc;\n+        this.log = log;\n+        this.failOnContractViolations = enforceContractViolations;\n+    }\n+\n+    public void assertCanSubclass() {\n+        Class superclass = meta.getDescribedType();\n+        String name = superclass.getName();\n+        if (superclass.isInterface())\n+            addError(loc.get(\"subclasser-no-ifaces\", name), meta);\n+        if (Modifier.isFinal(superclass.getModifiers()))\n+            addError(loc.get(\"subclasser-no-final-classes\", name), meta);\n+        if (Modifier.isPrivate(superclass.getModifiers()))\n+            addError(loc.get(\"subclasser-no-private-classes\", name), meta);\n+        if (PersistenceCapable.class.isAssignableFrom(superclass))\n+            addError(loc.get(\"subclasser-super-already-pc\", name), meta);\n+\n+        try {\n+            Constructor c = superclass.getDeclaredConstructor(new Class[0]);\n+            if (!(Modifier.isProtected(c.getModifiers())\n+                || Modifier.isPublic(c.getModifiers())))\n+                addError(loc.get(\"subclasser-private-ctor\", name), meta);\n+        }\n+        catch (NoSuchMethodException e) {\n+            addError(loc.get(\"subclasser-no-void-ctor\", name),\n+                meta);\n+        }\n+\n+        // if the BCClass we loaded is already pc and the superclass is not,\n+        // then we should never get here, so let's make sure that the\n+        // calling context is caching correctly by throwing an exception.\n+        if (pc.isInstanceOf(PersistenceCapable.class) &&\n+            !PersistenceCapable.class.isAssignableFrom(superclass))\n+            throw new InternalException(\n+                loc.get(\"subclasser-class-already-pc\", name));\n+\n+        if (meta.getAccessType() == ClassMetaData.ACCESS_PROPERTY)\n+            checkPropertiesAreInterceptable();\n+\n+        if (errors != null && !errors.isEmpty())\n+            throw new UserException(errors.toString());\n+        else if (contractViolations != null &&\n+            !contractViolations.isEmpty() && log.isWarnEnabled())\n+            log.warn(contractViolations.toString());\n+    }\n+\n+    private void checkPropertiesAreInterceptable() {\n+        // just considers accessor methods for now.\n+        FieldMetaData[] fmds = meta.getFields();\n+        for (int i = 0; i < fmds.length; i++) {\n+            Method getter = (Method) fmds[i].getBackingMember();\n+            if (getter == null) {\n+                addError(loc.get(\"subclasser-no-getter\",\n+                    fmds[i].getName()), fmds[i]);\n+                continue;\n+            }\n+            BCField returnedField = checkGetterIsSubclassable(getter, fmds[i]);\n+\n+            Method setter = setterForField(fmds[i]);\n+            if (setter == null) {\n+                addError(loc.get(\"subclasser-no-setter\", fmds[i].getName()),\n+                    fmds[i]);\n+                continue;\n+            }\n+            BCField assignedField = checkSetterIsSubclassable(setter, fmds[i]);\n+            if (assignedField == null)\n+                continue;\n+\n+            if (assignedField != returnedField)\n+                addContractViolation(loc.get\n+                    (\"subclasser-setter-getter-field-mismatch\",\n+                        fmds[i].getName(), returnedField,assignedField),\n+                    fmds[i]);\n+\n+            // ### scan through all the rest of the class to make sure it\n+            // ### doesn't use the field.\n+        }\n+    }\n+\n+    private Method setterForField(FieldMetaData fmd) {\n+        try {\n+            return fmd.getDeclaringType().getDeclaredMethod(\n+                \"set\" + StringUtils.capitalize(fmd.getName()),\n+                new Class[]{ fmd.getDeclaredType() });\n+        }\n+        catch (NoSuchMethodException e) {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @return the name of the field that is returned by <code>meth</code>, or\n+     *         <code>null</code> if something other than a single field is\n+     *         returned, or if it cannot be determined what is returned.\n+     */\n+    private BCField checkGetterIsSubclassable(Method meth, FieldMetaData fmd) {\n+        checkMethodIsSubclassable(meth, fmd);\n+        BCField field = PCEnhancer.getReturnedField(getBCMethod(meth));\n+        if (field == null) {\n+            addContractViolation(loc.get(\"subclasser-invalid-getter\",\n+                fmd.getName()), fmd);\n+            return null;\n+        } else {\n+            return field;\n+        }\n+    }\n+\n+    /**\n+     * @return the field that is set in <code>meth</code>, or\n+     *         <code>null</code> if something other than a single field is\n+     *         set, or if it cannot be determined what is set.\n+     */\n+    private BCField checkSetterIsSubclassable(Method meth, FieldMetaData fmd) {\n+        checkMethodIsSubclassable(meth, fmd);\n+        BCField field = PCEnhancer.getAssignedField(getBCMethod(meth));\n+        if (field == null) {\n+            addContractViolation(loc.get(\"subclasser-invalid-setter\",\n+                fmd.getName()), fmd);\n+            return null;\n+        } else {\n+            return field;\n+        }\n+    }\n+\n+    private BCMethod getBCMethod(Method meth) {\n+        BCClass bc = pc.getProject().loadClass(meth.getDeclaringClass());\n+        return bc.getDeclaredMethod(meth.getName(), meth.getParameterTypes());\n+    }\n+\n+    private void checkMethodIsSubclassable(Method meth, FieldMetaData fmd) {\n+        String className = fmd.getDefiningMetaData().\n+            getDescribedType().getName();\n+        if (!(Modifier.isProtected(meth.getModifiers())\n+            || Modifier.isPublic(meth.getModifiers())))\n+            addError(loc.get(\"subclasser-private-accessors-unsupported\",\n+                className, meth.getName()), fmd);\n+        if (Modifier.isFinal(meth.getModifiers()))\n+            addError(loc.get(\"subclasser-final-methods-not-allowed\",\n+                className, meth.getName()), fmd);\n+        if (Modifier.isNative(meth.getModifiers()))\n+            addContractViolation(loc.get\n+                (\"subclasser-native-methods-not-allowed\", className,\n+                    meth.getName()),\n+                fmd);\n+        if (Modifier.isStatic(meth.getModifiers()))\n+            addError(loc.get(\"subclasser-static-methods-not-supported\",\n+                className, meth.getName()), fmd);\n+    }\n+\n+    private void addError(Message s, ClassMetaData cls) {\n+        if (errors == null)\n+            errors = new ArrayList();\n+\n+        errors.add(loc.get(\"subclasser-error-meta\", s,\n+            cls.getDescribedType().getName(),\n+            cls.getSourceFile()));\n+    }\n+\n+    private void addError(Message s, FieldMetaData fmd) {\n+        if (errors == null)\n+            errors = new ArrayList();\n+\n+        errors.add(loc.get(\"subclasser-error-field\", s,\n+            fmd.getFullName(),\n+            fmd.getDeclaringMetaData().getSourceFile()));\n+    }\n+\n+    private void addContractViolation(Message m, FieldMetaData fmd) {\n+        // add the violation as an error in case we're processing violations\n+        // as errors; this keeps them in the order that they were found rather\n+        // than just adding the violations to the end of the list.\n+        if (failOnContractViolations)\n+            addError(m, fmd);\n+\n+        if (contractViolations == null)\n+            contractViolations = new ArrayList();\n+\n+        contractViolations.add(loc.get\n+            (\"subclasser-contract-violation-field\", m.getMessage(),\n+                fmd.getFullName(), fmd.getDeclaringMetaData().getSourceFile()));\n+    }\n+}"},{"sha":"b49ad7e8630bddcb873e2a4747bfb1dcc6d51d94","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RedefinitionHelper.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"d3bce1033e51876f7dfcb0ea500663fefa881cd3","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/ReflectingPersistenceCapable.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"a37b53753593756a5f49f37ab603b0875a6df885","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClassesModes.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClassesModes.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClassesModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClassesModes.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"41848ae2942c0d72bac8123c2663ba6124caaa31","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/enhance/RuntimeUnenhancedClasssesModes.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"4c2ba87e2c6a9ef03124fb598aae0218f6e25e95","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEvent.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"183e7ebf4084b11e2a3b6588a4bbe9abcccdeb35","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryEventManager.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"35f129c5d49ba00ddd51f06f3bfb309fe75488a8","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/BrokerFactoryListener.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"a0525a0537b3f5e769415a113612e75d39d3d540","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostDeleteListener.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"7af19bb90d32c6ac853a103a4fb374285a9a3383","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/PostPersistListener.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"3168a6b6aa71e54c4b4400dfbb1b1a75c2efe179","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/RemoteCommitEventManager.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"b796f26cf675ee1a52718f0b65dcd5c1c88ffb5c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/SingleJVMRemoteCommitProvider.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"079d80239f3b1dc8179ae77eaff57ce13703d992","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TCPRemoteCommitProvider.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"b8062348dc244aba3751546c022e54e4afe13b42","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/TransactionEventManager.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"a9f24b061c04bc6b2fa11379e73d520eb16548ad","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/event/UpdateListener.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"7398858be29d01f61149753b59ad80c565aa6b2f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractBrokerFactory.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"273fdbb3298a45d3e7612364838389310edde60c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AbstractStoreQuery.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"2906698764916771a52bfcb0904ed11311aeed7c","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/AttachStrategy.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"f441052d283eee2c717e413f068ea50f57ba0eab","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/BrokerImpl.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"8a8afefd9b1a7409bec05da63b4ee17080f7aba2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachManager.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"24f2a95960eafd07e42bb11c8a0a9ce48a2c6522","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/DetachedStateManager.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"5d300f96c55f2b1f87e9a919b79fb540cd93ea56","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ExtentImpl.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"a6527f7c91c76763b1754e69e965e0a9fbd73503","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/ManagedCache.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"5f7faa86a0ee8bbfab330f78f33d3acb377051aa","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/QueryImpl.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"ccd1c21743b71fa5744d9095f2b21792dd51aa3f","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/kernel/StoreQuery.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"94c52263689ffeda3e6c1297361cbcf3082ebaed","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/ClassMetaData.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"22cc0c736135c53610c163baa098d22a3d6ce901","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/FetchGroup.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"559b1ab16f4634149f4ece394b9c7fd4c62cf807","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/MetaDataRepository.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"2ac03497fe2144db0bdb0b31425dd872e5d14db6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/meta/NonPersistentMetaData.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"b5aa972b4fb87ff1a09254f3aa2ec68300d48be2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigDecimalId.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"55a597610226c591557dba9cd68d6f1f66a83dd2","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/BigIntegerId.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"d885a5d1e74a40c5343c45de7c10b25db0415683","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/CacheMap.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"16168945faa8b8f594bb874de7ee8cccf0e09631","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/GeneratedClasses.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"a305b59d6e26332ad8faae53fe971f874880d0c6","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ImplHelper.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"5f2991981cc80e5c9959c4fe9d4d2362ff69ce89","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/OpenJPAId.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"3f9e0713b9c1430ccf348f299d7c0b9ade40c850","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/ProxyManagerImpl.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"2cd29655ee8bb3f2c404ce82835ceecf12123688","filename":"openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/java/org/apache/openjpa/util/StoreFacadeTypeRegistry.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"d4ac3bde93dbfc959efe13f84dfb6fac75a735a4","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/ee/localizer.properties","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/resources/org/apache/openjpa/ee/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/resources/org/apache/openjpa/ee/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/ee/localizer.properties?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"a4d439c7e2b13c526198ae5a16aed6c5e64982fa","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/kernel/localizer.properties?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"541703691524e414ccfe32e343978189875be318","filename":"openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/main/resources/org/apache/openjpa/meta/localizer.properties?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"f60c8ca8fc296ca72a8d49f3f5de3106e4524987","filename":"openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/test/java/org/apache/openjpa/ee/TestWASManagedRuntime.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"ce0958229f1aec56780e61974d3e32f908c1d0dd","filename":"openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestGetDeclaredMethod.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"2237cde18e6ccb4fdf2a66b61154985473d41b92","filename":"openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/test/java/org/apache/openjpa/enhance/TestPCSubclassNameConversion.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"eb8f78a3b557ae31d3954fda5bf242b6a71615c0","filename":"openjpa-kernel/src/test/java/org/apache/openjpa/meta/TestMemberProvider.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/test/java/org/apache/openjpa/meta/TestMemberProvider.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-kernel/src/test/java/org/apache/openjpa/meta/TestMemberProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-kernel/src/test/java/org/apache/openjpa/meta/TestMemberProvider.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"7738d50744bd2420a76e65578ababebf3b43d0cc","filename":"openjpa-lib/pom.xml","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/pom.xml?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"94b98bf8e5253d78219852b530e1777a6be16662","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/BootstrapException.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"c61b2bcc5a3eb5ba46f1c6f8f44825977b778595","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/Configurations.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"55d9a2699e2fa0068e1554cb011b46595a15a602","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/conf/ObjectValue.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"e40e160910ef01d40326a0b10f353465a76c7eb5","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/BreadthFirstWalk.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"f1f5001cf0da8c0c7d9a01cd62bb96df94a7f054","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"aa57109b62f5fcfde616c78983d9928b955271b3","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Edge.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"77f9d74ead100310ffe8136d3f3039c8b5b5d95f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/Graph.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"b9c67ff6daef47f8283e81ae68d4682c458c69ca","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/GraphVisitor.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"9ece659a36b83abf2776a321fac1b2178f77d51d","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/NodeInfo.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"66fdd78027af10c57c3ebfe7cc7b29bb36ab8aee","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DecoratingDataSource.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"6f3b4e03facbf8a58630a4147c9e9ea6792e37dd","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/DelegatingDatabaseMetaData.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"b9714b1281cd241dee2d21bf4cc166e318db0b91","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/jdbc/JDBCEventConnectionDecorator.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"7b178d91fa04cd32f64af1de3f3123247719d3b3","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryAdapter.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"24c258087591b23bd6cbe13f6daa48e01689aecf","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/LogFactoryImpl.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"7c05693c780b214a0efb09f474eed944ca92ffde","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/log/MultiLogFactory.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"9acd5d656285426d5b7c25d72f1799054a71b654","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractNonSequentialResultList.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractNonSequentialResultList.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractNonSequentialResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/AbstractNonSequentialResultList.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"f3a84b9559652279ff4b28b7d95516fdfea29ba8","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/LazyForwardResultList.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/LazyForwardResultList.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/LazyForwardResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/LazyForwardResultList.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"145c164482d6682bdedc3106d244285ece9d773d","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ListResultList.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ListResultList.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ListResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/rop/ListResultList.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"9eebc566c3e3ad02e0a90637e22163f10eda369b","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Bytes.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"82a3edcf6f3963bc8dd2b1f6e8ba431593b76e2c","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPriv5Helper.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"919258cd6b7165d06afae66d84c5c94a914ca777","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPrivHelper.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPrivHelper.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPrivHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/J2DoPrivHelper.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"f5a04ea7fa0ad931de33dcf88f530285aa2e3de1","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/Localizer.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"96dfd32f5775291b461256dda8a6e040de456d1f","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TimestampHelper.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TimestampHelper.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TimestampHelper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/TimestampHelper.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"e5dadba9ad3c167c40956e52b231945d82e484c5","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/NullSafeConcurrentHashMap.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"c001a4cf0bafd1740024602aeaed921d999ab751","filename":"openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/main/java/org/apache/openjpa/lib/util/concurrent/SizedConcurrentHashMap.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"fcea58dd616124f857324a3784039d3b59f9c6fd","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/TestXMLCaseConversions.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"e06648dc6642844a5e502df682eb7213b41f2abc","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/conf/test/ConfigurationTestProductDerivation.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"1df285153bb30953b5a7799b6be28fdd79b236bb","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestDepthFirstAnalysis.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"3b21530ffeb82b4c131a042d4b88c688da26bc08","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/graph/TestGraph.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"915580982cc4ee4541b8212d33d8f51c2dc50ee5","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/ResultListTest.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/ResultListTest.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/ResultListTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/ResultListTest.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"6e4e22262401ae2aa18c3b69908ddb0416947e71","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestEagerResultList.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestEagerResultList.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestEagerResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestEagerResultList.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"3eb648417cccb91befee06426985b1f0904872f6","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestLazyForwardResultList.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestLazyForwardResultList.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestLazyForwardResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestLazyForwardResultList.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"41e4de4d671d11f19537f5f617eab1e12f8e8cc5","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestListResultList.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestListResultList.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestListResultList.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/rop/TestListResultList.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"49a389f0b97f54634eba55fb5023a18f5c47f72e","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/test/AbstractTestCase.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"bfb6538f3d8c2517b0663ab7572f2292ed3a82f8","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestAbstractEventManager.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"6110d8e41c3e69050541117f7e8875b1b8f9e1f1","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/TestPropertiesParser.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"a39620107e864578a1cdb44e391b902778e5b1ea","filename":"openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-lib/src/test/java/org/apache/openjpa/lib/util/concurrent/TestNullSafeConcurrentHashMap.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"2498608fe3e5914a4dd10a46eac3398dc5769611","filename":"openjpa-persistence-jdbc/pom.xml","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/pom.xml","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/pom.xml","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/pom.xml?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"4f40d52d1443f582cb5c186222e6ed57043d6b7b","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumn.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumn.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumn.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"af682fbeb733a71a207594b5c765f63e166fb6aa","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumns.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumns.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumns.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementColumns.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"a4c2062c0ff1f2734d41024a68dbf13f4917573c","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementEmbeddedMapping.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementEmbeddedMapping.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementEmbeddedMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementEmbeddedMapping.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"9dfb75c97d39d3efca09d6aabfafa01606f364f4","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementStrategy.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/ElementStrategy.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"8dbf2233247539a53bb698a4e4c04a3bc4c8cf97","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyClassCriteria.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyClassCriteria.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyClassCriteria.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyClassCriteria.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"7046272f7a74cb0d4d7054b74a2b1ea2b6c38bcf","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumn.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumn.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumn.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"0505c5967fa011c6d963b839ce259a85f9b20701","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumns.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumns.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumns.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyColumns.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"89472aa62ec0d9881eb6f9469e2717a6712659b4","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyEmbeddedMapping.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyEmbeddedMapping.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyEmbeddedMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyEmbeddedMapping.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"dfc13a52f052a659d6289067f42942f6b925b775","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyForeignKey.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyForeignKey.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyForeignKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyForeignKey.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"20d1709f275fa3c76b490b6f1bd7b31d3ee473d3","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyIndex.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyIndex.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyIndex.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyIndex.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"391b0af45d9c0adb90f687e5a35c3d77bf15d4c5","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumn.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumn.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumn.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumn.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"8ff0946554d1aaa52033097b0c7fd065e07f1a48","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumns.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumns.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumns.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyJoinColumns.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"05d6fcde0394e991850aff86957ca97dd8d36298","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyNonpolymorphic.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyNonpolymorphic.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyNonpolymorphic.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyNonpolymorphic.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"629247b9aff77c6224707c89958ef5b7ab2dc737","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyStrategy.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyStrategy.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyStrategy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/KeyStrategy.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"b7401d43e8f01190208c14e49f73ad378b1ab03d","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XEmbeddedMapping.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XEmbeddedMapping.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XEmbeddedMapping.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XEmbeddedMapping.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"b083800e50d1903e8c2ac64fe98e56479854375c","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverride.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverride.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverride.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverride.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"a439e55c32c88ec5e0ac75a86cfa38a1c8635f20","filename":"openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverrides.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverrides.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverrides.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/main/java/org/apache/openjpa/persistence/jdbc/XMappingOverrides.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"8a3b4a0e0caa1614854772304bf8ffa8db74db91","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestBadJdbcUrl.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestBadJdbcUrl.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestBadJdbcUrl.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestBadJdbcUrl.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"7e315428ec7a1d6f34010a48ba1b3d2a5e355435","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshaller.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshaller.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshaller.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshaller.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"e8739b1b8e556e93bfecb92913c0ca43e87005b8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshallerEndToEnd.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshallerEndToEnd.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshallerEndToEnd.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestCacheMarshallerEndToEnd.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"c05392f3a85917081c6ba8459a308d961c23ed81","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/conf/TestDynamicConfiguration.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"0b446c0836128120930005157c584cb26f5a2cea","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/AbstractUnenhancedClassTest.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"c3ab5d217aed21ba58efb48c0555c60f8e5d360b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestDataCachingAndUnenhancedPropertyAccess.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"4348b23b976d9c8a7f360eb57a57167c8add4f8c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementConfiguration.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"15392bfde1faefb596162be1ed6198ac641438f0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementWithMultiplePUs.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementWithMultiplePUs.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementWithMultiplePUs.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestEnhancementWithMultiplePUs.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"44077384fc3daa7e93cb4052d0648cdaf87e143e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestPCEnhancerFindField.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"1dd81d1539c1dfc524583f48b273a3eb6b414ca6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestRelationToUnlistedClass.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"ed60af83394108bd9f2ea9d2d5d700d6c624ee92","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestSimpleUnenhancedQuery.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestSimpleUnenhancedQuery.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestSimpleUnenhancedQuery.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestSimpleUnenhancedQuery.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"36f3949ec4b1728119b9caaee47252435180e149","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPK.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"866bbc5bee6c06761bd90ff06e72babfc23f3f20","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedCompoundPKSubclass.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"1e69bf9170405d7cfe5dcc6cf5bcfdbaf565cc25","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccess.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"01b3294f53a3e05549e31cc2eb14f66c63943caf","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedFieldAccessPrimitiveWrapper.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"116ed5014cb1b3849dc1f84fdbd01b7ae567a5be","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedOneToMany.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedOneToMany.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedOneToMany.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedOneToMany.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"638018e5ac44a2effc583b577274faedc43e25dd","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/TestUnenhancedPropertyAccess.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"130d78820ee6cea5e401485d1fcbca1aaef28393","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"287c5e321aa492fe4a9f63e1bf3a9c6c8f107ac9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance2.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance2.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedBootstrapInstance2.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"33298a5cf356431f08bd4f939007db1f2b045389","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccess.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"f79a4c9b6e48486661631c90007b1a794cd5cedb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSubclass.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"0b101412e10ad756e28c4daf13e566277a434856","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKFieldAccessSuperclass.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"03e33912f6de6f6a27ba78fc31a9cd86f2c2b3ca","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedCompoundPKPropertyAccess.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"acfbaa2c3928a3f7646aa6f60d22acb2b42c6c51","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccess.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"31c009a84689d904afc140ea1f9bb69bf7af8cda","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapper.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"d8780d021fbbfe217ff4712a3530da767e9728c9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessPrimitiveWrapperSubclass.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"ac928a6c7adaf9207f13a4dd18d4cb216a4cdd8e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedFieldAccessSubclass.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"1044e0f3c99938d343149dab394caa6080d1362c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedIdentityIdPropertyAccess.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"f034ac9ecdc41b73c7312dcfa41c669634e46c03","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedMany.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedMany.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedMany.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedMany.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"a8bdbcef7fd78109dd7f15c26da2f4cf48158960","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedOne.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedOne.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedOne.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedOne.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"027e973a88f738aa871562a7517d5013ede409f7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPObject.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPObject.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPObject.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPObject.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"22efc08eed127653ccf7d9f0babf4c140e24a931","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccess.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"de4cfa30a848eba647d418771a08575506bceac7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedPropertyAccessSubclass.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"79331c7248bf9c206d7d10f68299054c65a06776","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedSubtype.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"ef19b8f1ef93b8b12e96c6edee65fcab5c2e1789","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedType.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"5bca64e0d83fac455829c82d17728c7d79f9c039","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedClass.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"b44ff2fedb2a7d4cdc7312509682e7c788748b82","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/enhance/UnenhancedUnlistedReferer.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"26f684183541e3b1f98b051f0cd1e291892b2dd5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestLifecycleListener.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"d9172f21616f9858b8c256dda7bb474ab54be5ca","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/event/TestSJVMRemoteCommitProvider.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"77ed7187289d221aa425477eb377e373002a997d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityA.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"0c9f8697b41b87115e18f0e3e912811f2669d46d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityB.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"36e7328d2d8d100873b8a268e01b1168bf1c1cbe","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityC.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"7239aace49a18303b4adaa5bcdb79aff82f39258","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityD.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"7888c89ed91b0bb5857359327b12f619e234650d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityF.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityF.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityF.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityF.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"38750bf59d402bb7b830ccffc97511e9a7a1e78c","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityG.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityG.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityG.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/EntityG.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"2b24115d765f95ed1c43b45171ec1c5e79c1e9a3","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/kernel/TestNoForeignKeyViolation.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"01cab7f45ec4f508f2aa511549a4ad5b0b26f4a8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/AbstractLobTest.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/AbstractLobTest.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/AbstractLobTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/AbstractLobTest.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"a546d39478b7fec6d7840911c2e0038552098709","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobEntity.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobEntity.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobEntity.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"486f23f1430b174438c8f6afcd7e0f725191a5cc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobTest.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobTest.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamLobTest.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"8cd9dd9a549307a45f53d6cad198bff68f331913","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamWrapper.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamWrapper.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamWrapper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/InputStreamWrapper.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"57e983837a2e9da0892947a0459e9e55cd992c4f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/LobEntity.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/LobEntity.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/LobEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/LobEntity.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"769b5418b3946911ee424325e091a602cf21da5e","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobEntity.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobEntity.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobEntity.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"61a9ee6ca4a50ecd7592c85a03ca4cff68d66559","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobTest.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobTest.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderLobTest.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"e77c4bfacffaaae558a995290ebf0734f8ca3b1d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderWrapper.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderWrapper.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderWrapper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/jdbc/meta/strats/ReaderWrapper.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"ff3e7a71f7673566c53d9c4ed0b70c6326c91600","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractBrokerSerializationTest.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"e5b9204e62c902c39a0262b7fd1f86e4d74f2d81","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractUnenhancedRelationBrokerSerializationTest.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractUnenhancedRelationBrokerSerializationTest.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractUnenhancedRelationBrokerSerializationTest.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/AbstractUnenhancedRelationBrokerSerializationTest.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"f240d27db0a753ecef0458f3dd56a0579fddf673","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryEventManager.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"63dc8813a393366d422650aab0ce1188a5af5fd6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestBrokerFactoryListenerRegistry.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"6fa77b9f1eaa2f5563602aeb4c3d8c6f19cab349","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestDynamicClassRegistration.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestDynamicClassRegistration.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestDynamicClassRegistration.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestDynamicClassRegistration.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"f71250591c2878f6b02a10c47155f4bcf503f88d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEnhancedInstanceBrokerSerialization.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEnhancedInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEnhancedInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEnhancedInstanceBrokerSerialization.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"562ed6a8a38448f1230b85c05ee02c8c9961e04d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEntityManagerFactoryPool.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEntityManagerFactoryPool.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEntityManagerFactoryPool.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestEntityManagerFactoryPool.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"8a17714ecedc2542781768ec80ea8fcb76bd23d5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestInstanceGraphBrokerSerialization.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestInstanceGraphBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestInstanceGraphBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestInstanceGraphBrokerSerialization.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"0ecf316290b6c9e9dd08f83d16dc5e133896bd48","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessInstanceBrokerSerialization.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessInstanceBrokerSerialization.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"511e32b10d9dde2438dac41c21731553ceabf936","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessWithRelationInstanceBrokerSerialization.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessWithRelationInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessWithRelationInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedFieldAccessWithRelationInstanceBrokerSerialization.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"710445075eba806c59d80a88d537e917f43fc7b8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessInstanceBrokerSerialization.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessInstanceBrokerSerialization.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"4499cfa0ed296ecd65d3163d531af191d2375f25","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessWithRelationInstanceBrokerSerialization.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessWithRelationInstanceBrokerSerialization.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessWithRelationInstanceBrokerSerialization.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/kernel/TestUnenhancedPropertyAccessWithRelationInstanceBrokerSerialization.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"61f740e34c5140094d448a0df8e487a8441174bb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/lib/conf/TestAnchorParsing.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/lib/conf/TestAnchorParsing.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/lib/conf/TestAnchorParsing.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/lib/conf/TestAnchorParsing.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"f6b9a378d1cd0db051afa7bfa5e9567ec445d715","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/A.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"6c680f396d953f78380404fb7c53026040fed2a4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/AbstractThing.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"ff573eff5db794e1a128e4f7209978da5c23005b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Artist.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Artist.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Artist.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Artist.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"8beb7ab736ea24ff0f777abb321cb8a5b19792d2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/B.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"08c5920215ae8121adaee83d21602274327d6cdc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/C.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"e1c413cf1ca7a42ed395e7f747ca2f6b13e87cca","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Item.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Item.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Item.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Item.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"6326fb12e05103be11935ee00ac1efd00382db6d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Painter.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Painter.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Painter.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Painter.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"fe7f17ea3e95b774098448eef593afe8be488e96","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Person.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Person.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Person.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/Person.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"29ef0d070c99d97ac2707708937f8ecd1bc52111","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestGetMetaData.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestGetMetaData.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestGetMetaData.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestGetMetaData.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"b78fe8d34b60149ceba969d635985fd299593a58","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/meta/TestMetaDataInheritanceComparator.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"9f39748f856f82b36ec6152fee95f089bb8ed8bf","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/AnnotationTestCase.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/AnnotationTestCase.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/AnnotationTestCase.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/AnnotationTestCase.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"f757ff86a6e1f86f55aa3f6b7173a5059bcb8955","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAdvAnnot.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAdvAnnot.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAdvAnnot.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAdvAnnot.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"024f593908da3157525e49ff538b6aa685d020ee","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAnnotationBasics.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAnnotationBasics.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAnnotationBasics.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestAnnotationBasics.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"41acca647d76dc7bee81b89539bccd93052de9f3","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestDDCallbackMethods.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestDDCallbackMethods.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestDDCallbackMethods.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestDDCallbackMethods.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"98b6176f22261466a72ecd7c26e0638e661e34bd","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEJBEmbedded.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEJBEmbedded.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEJBEmbedded.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEJBEmbedded.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"a373c898c81d2ffbf7bc9b77b72bcca5136ae7af","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddableSuperclass.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddableSuperclass.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddableSuperclass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddableSuperclass.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"2f2fd083403c7a6b9e97c2368b6efef062f471e8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddedId.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddedId.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddedId.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEmbeddedId.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"6ee4ae17455a1a8637077e453cd5f638978134ca","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityListenerAnnot.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityListenerAnnot.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityListenerAnnot.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityListenerAnnot.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"b22458cc6143b5204db1219c6c2e3de0062580d1","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityOrderBy.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityOrderBy.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityOrderBy.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEntityOrderBy.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"0ca620f486359f9370ec7fcf20d94025b51f96bf","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEnumerated.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEnumerated.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEnumerated.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestEnumerated.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"d8c70b9af7747f39e499c94610b3e0cd52063578","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestFlatInheritance.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestFlatInheritance.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestFlatInheritance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestFlatInheritance.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"300e6fbad2264f5e474d8ed30c4aa4cebfb18491","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestGenerators.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestGenerators.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestGenerators.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestGenerators.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"0462985119eb9c1b8feb88affb9edb539ee50d44","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestJoinedInheritance.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestJoinedInheritance.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestJoinedInheritance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestJoinedInheritance.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"5bad087a25cd38528f6f1e7d2f2124ad01449f2a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestManyToMany.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestManyToMany.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestManyToMany.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestManyToMany.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"4f551bfcf01f18d30639d0fae4296b76b8e0c011","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestMapKey.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestMapKey.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestMapKey.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestMapKey.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"13174c1ef0989368bf1cc9918294b0dad57745a8","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToMany.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToMany.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToMany.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToMany.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"834cca869264f4a3127f2dad70b20a4f4ce58de4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToOne.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToOne.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToOne.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestOneToOne.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"e061cdca25f310a0cf013bb33a69138b7eedcefe","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestPropertyAccess.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestPropertyAccess.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestPropertyAccess.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestPropertyAccess.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"c754b40f20c44e28415b5663f4cb42c1320083fc","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestSerializedLobs.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestSerializedLobs.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestSerializedLobs.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestSerializedLobs.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"5a680fa5af905185838b58fc88c38e47d613bbfe","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestTablePerClassInheritance.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestTablePerClassInheritance.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestTablePerClassInheritance.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestTablePerClassInheritance.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"56ed85ff73428d677ff85387afa97db2bbe2b5e7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestVersion.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestVersion.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestVersion.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/TestVersion.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"9cbecb9786c2fa711b3bcf838296389c1bb6bf75","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest1.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest1.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest1.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"8ef6311a2dee019b77e31557b0f3135c63af960a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest2.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest2.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest2.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"8c398b4e04aa979f6c0d947d8fb5f338c0db4282","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest3.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest3.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest3.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/AnnoTest3.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"a81e004d425a4afef344dd691bbb2b339d386cff","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/CallbackStorage.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/CallbackStorage.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/CallbackStorage.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/CallbackStorage.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"14ed9500140971013af596eee67f2cb192d8a8e9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/ContractEmployee.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/ContractEmployee.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/ContractEmployee.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/ContractEmployee.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"7026713b1ada04fd7bacbf9f12834f351aa2fcbb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DateValidator.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DateValidator.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DateValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DateValidator.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"24bc9e9bbd011a778544ba0e9d914f9ba9115139","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DefaultCallbackListener.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DefaultCallbackListener.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DefaultCallbackListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/DefaultCallbackListener.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"0e46ead850839e783ef043cd417d189b1aced8d5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedOwner.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedOwner.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedOwner.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedOwner.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"ded0639941433ef2fde6adea577426554e8f74a6","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"5f408b2884f472aacdd84e60ed5ac1f42bf789d0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue2.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue2.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbedValue2.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"0093c448b09e36cce2cc21f04415c64a8c3ce2c9","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuper.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuper.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuper.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuper.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"7109223ca16d0a06d9c646a55765d6289b202a43","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuperSub.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuperSub.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuperSub.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddableSuperSub.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"7ab7564dda1798643a6caa9c2fb04bbafa5c0bd5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdClass.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdClass.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdClass.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdClass.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"a182ea322e2784a4be8db1a0ea83827f64ae1845","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdEntity.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdEntity.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/EmbeddedIdEntity.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"3d896513025b897a1f3b94b3baf8d8d45bd64f2f","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Employee.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Employee.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Employee.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Employee.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"7a6fd4547e1020717c9ebbe07f63f03c5754522d","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity1.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity1.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity1.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"b2a3406c2e2bee92f039d3a4944cd07dabfa5534","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity2.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity2.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Entity2.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"b4f1373c24538ff1768639aa3b6eec37ca22b3f4","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat1.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat1.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat1.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"5370d5a3d215a85ed924ac49f2da6e17584980c7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat2.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat2.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Flat2.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"9fe8e3a6e5e32c04af5afa5201ae04313289d7db","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/FlightSchedule.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/FlightSchedule.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/FlightSchedule.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/FlightSchedule.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"74d4c7d38fdcca6c215748404dbbb6b1ff24df6b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Generator.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Generator.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Generator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Generator.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"b8e3013656cf8ed84a06e193f343ec626cc223f7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/LongNameValidator.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/LongNameValidator.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/LongNameValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/LongNameValidator.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"6dcc1844cf8705ac2c6937c5636329b4afe09168","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NameValidator.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NameValidator.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NameValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NameValidator.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"6cc2c14503f468a8c149564890f83c7877de9b83","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NamedEntity.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NamedEntity.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NamedEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/NamedEntity.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"d09cb344752a4d9eb2db9851d702f2d38c367d1b","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/OrderByEntity.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/OrderByEntity.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/OrderByEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/OrderByEntity.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"dcd4e03497cd90a963ab7a07d7ad363b016e8943","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/PropertyAccess1.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/PropertyAccess1.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/PropertyAccess1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/PropertyAccess1.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"e8c9768e8505b2f46857da9cf44a6c29d6fef3ee","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Schedule.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Schedule.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Schedule.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/Schedule.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"390ea719213f48751f84b6ba4e17e27b4dacd4fb","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/StringValidator.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/StringValidator.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/StringValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/StringValidator.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"c2d468f3a15ebca093b9ba46fcc0c15d431a7db7","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass1.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass1.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass1.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"e9ff8e0ecdd7c0cca36ec7e4591683119d1eec72","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass2.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass2.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass2.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TablePerClass2.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"0f0c554e640bdeceabe09ac2a9a169e1754a83d2","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TxRollbackEntity.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TxRollbackEntity.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TxRollbackEntity.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/annotype/TxRollbackEntity.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"c2b3ea52e0ea94db2797192d51fb6d293a679188","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/CallbackStorage.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/CallbackStorage.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/CallbackStorage.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/CallbackStorage.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"91f840332afa5053d99e63ec73a53dad26f26eb5","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/ContractEmployee.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/ContractEmployee.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/ContractEmployee.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/ContractEmployee.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"7e911402fd6bf2711def106b7e2f09be835ae18a","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DateValidator.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DateValidator.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DateValidator.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DateValidator.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"abacdb1a3612986a17a2dd3f576b3afea328a414","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DefaultCallbackListener.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DefaultCallbackListener.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DefaultCallbackListener.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/DefaultCallbackListener.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"c28a2ed9d17b58638dee6d303b4890c5ef289bf0","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Employee.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Employee.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Employee.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Employee.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"},{"sha":"c59ca3618bc35f36901c9fd968aa85f427f1df20","filename":"openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity1.java","status":"modified","additions":0,"deletions":0,"changes":0,"blob_url":"https://github.com/apache/openjpa/blob/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity1.java","raw_url":"https://github.com/apache/openjpa/raw/9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity1.java","contents_url":"https://api.github.com/repos/apache/openjpa/contents/openjpa-persistence-jdbc/src/test/java/org/apache/openjpa/persistence/annotations/common/apps/annotApp/ddtype/Entity1.java?ref=9d34ef9dfc27f9fd5e712e1afe7f3ac25d119675"}]}

